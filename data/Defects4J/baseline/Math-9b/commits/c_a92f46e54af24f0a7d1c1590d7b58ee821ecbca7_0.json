{"sha": "a92f46e54af24f0a7d1c1590d7b58ee821ecbca7", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20783 Submitted by:\tphil@steitz.com   ", "commit": "\n--- a/src/java/org/apache/commons/math/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/RealMatrix.java\n /**\n  * Interface defining a real-valued matrix with basic algebraic operations\n  * @author  Phil Steitz\n- * @version $Revision: 1.3 $ $Date: 2003/06/11 14:50:29 $\n+ * @version $Revision: 1.4 $ $Date: 2003/06/15 17:01:39 $\n  */\n public interface RealMatrix {\n \n-    public RealMatrix copy();\n-    \n-    /**\n-     * Compute the sum of *this and m\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    RealMatrix copy();\n+    \n+    /**\n+     * Compute the sum of this and m.\n+     *\n      * @param m    matrix to be added\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as *this\n-     */\n-    public RealMatrix add(RealMatrix m);   \n-    \n-    /**\n-     * Compute *this minus m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    RealMatrix add(RealMatrix m) throws IllegalArgumentException;   \n+    \n+    /**\n+     * Compute this minus m.\n+     *\n      * @param m    matrix to be subtracted\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as *this\n-     */\n-    public RealMatrix subtract(RealMatrix m);   \n-    \n-    /**\n-     * Returns the rank of the matrix\n-     * @return     the rank of this matrix\n-     */\n-    public int getRank();\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    RealMatrix subtract(RealMatrix m) throws IllegalArgumentException;   \n+    \n+    /**\n+     * Returns the rank of the matrix.\n+     *\n+     * @return the rank of this matrix\n+     */\n+    int getRank();\n     \n      /**\n-     * Returns the result of adding d to each entry of *this\n+     * Returns the result of adding d to each entry of this.\n+     *\n      * @param d    value to be added to each entry\n      * @return     d + this\n      */\n-    public RealMatrix scalarAdd(double d);\n-    \n-    /**\n-     * Returns the result multiplying each entry of *this by d\n+    RealMatrix scalarAdd(double d);\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n      * @param d    value to multiply all entries by\n-     * @return     d*this\n-     */\n-    public RealMatrix scalarMultiply(double d);\n-    \n-    /**\n-     * Returns the result postmultiplyin *this by m\n+     * @return     d * this\n+     */\n+    RealMatrix scalarMultiply(double d);\n+    \n+    /**\n+     * Returns the result postmultiplying this by m.\n+     *\n      * @param m    matrix to postmultiply by\n-     * @return     this*m\n+     * @return     this * m\n      * @throws     IllegalArgumentException \n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    public RealMatrix multiply(RealMatrix m);\n-    \n-    /**\n-     * Returns matrix entries as a two-dimensional array\n+    RealMatrix multiply(RealMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n      * @return    2-dimensional array of entries\n      */\n-    public double[][] getData();\n-    \n-    /**\n-     * Sets/overwrites the underlying data for the matrix\n+    double[][] getData();\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix with\n+     * a fresh copy of <code>data</code>.\n+     *\n      * @param  data  2-dimensional array of entries\n      */\n-    public void setData(double[][] data);\n-    \n-    /**\n-     * Returns the norm of the matrix\n+    void setData(double[][] data);\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/\n+     * MaximumAbsoluteRowSumNorm.html\">maximum absolute row sum norm</a> \n+     * of the matrix.\n+     *\n      * @return norm\n      */\n-    public double getNorm();\n-    \n-    /**\n-     * Returns entries in row as an array\n-     * @param row  the row to be fetched\n-     * @return     array of entries in the row\n-     * @throws     IllegalArgumentException if row > rowDimension\n-     */\n-    public double[] getRow(int row);\n-    \n-    /**\n-     * Returns entries in column as an array\n+    double getNorm();\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws IllegalArgumentException if row > rowDimension\n+     */\n+    double[] getRow(int row) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     *\n      * @param col  column to fetch\n-     * @return     array of entries in the column\n-     * @throws     IllegalArgumentException if column > columnDimension\n-     */\n-    public double[] getColumn(int col);\n-    \n-    /**\n-     * Returns the entry in the specified row and column\n+     * @return array of entries in the column\n+     * @throws IllegalArgumentException if column > columnDimension\n+     */\n+    double[] getColumn(int col) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column.\n+     *\n      * @param row  row location of entry to be fetched  \n      * @param column  column location of entry to be fetched\n      * @return     matrix entry in row,column\n      * @throws     IllegalArgumentException if entry does not exist\n      */\n-    public double getEntry(int row, int column);\n-    \n-    /**\n-     * Sets the entry in the specified row and column to the specified value\n+    double getEntry(int row, int column) throws IllegalArgumentException;\n+    \n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n      * @param row    row location of entry to be set \n      * @param column    column location of entry to be set\n      * @param value  value to set \n      * @throws IllegalArgumentException if entry does not exist\n      */\n-    public void setEntry(int row, int column, double value);\n-    \n-    /**\n-     * Returns the transpose of this matrix\n+    void setEntry(int row, int column, double value) \n+        throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n      * @return transpose matrix\n      */\n-    public RealMatrix transpose();\n-    \n-    /**\n-     * Returns the inverse of this matrix\n+    RealMatrix transpose();\n+    \n+    /**\n+     * Returns the inverse of this matrix.\n+     *\n      * @return inverse matrix\n      * @throws IllegalArgumentException if *this is not invertible\n      */\n-    public RealMatrix inverse();\n-    \n-    /**\n-     * Returns the determinant of this matrix\n+    RealMatrix inverse() throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n      * @return determinant\n      */\n-    public double getDeterminant();\n+    double getDeterminant();\n     \n     /**\n      * Is this a square matrix?\n      * @return true if the matrix is square (rowDimension = columnDimension)\n      */\n-    public boolean isSquare();\n+    boolean isSquare();\n     \n     /**\n      * Is this a singular matrix?\n      * @return true if the matrix is singular\n      */\n-    public boolean isSingular();\n-    \n-    /**\n-     * Returns the number of rows in the matrix\n+    boolean isSingular();\n+    \n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n      * @return rowDimension\n      */\n-    public int getRowDimension();\n-    \n-    /**\n-     * Returns the number of columns in the matrix\n+    int getRowDimension();\n+    \n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n      * @return columnDimension\n      */\n-    public int getColumnDimension();\n-    \n-    /**\n-     * Returns the trace of the matrix\n+    int getColumnDimension();\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n      * @return trace\n      */\n-    public double getTrace();\n-    \n-    /**\n-     * Returns the result of multiplying this by vector v\n+    double getTrace();\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n      * @return this*v\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n-    public double[] operate(double[] v);\n-    \n-    /**\n-     * Returns the result of premultiplying this by vector v\n+    double[] operate(double[] v) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n      * @return v*this\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n-    public RealMatrix preMultiply(double[] v);  \n+    RealMatrix preMultiply(double[] v) throws IllegalArgumentException;  \n     \n     /**\n      * Returns the solution vector for a linear system with coefficient\n-     * matrix = *this and constant vector = b \n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n      * @param b  constant vector\n      * @return   vector of solution values to AX = b, where A is *this\n      * @throws   IllegalArgumentException if rowDimension != b.length or matrix \n      *           is singular\n      */\n-    public double[] solve(double[] b);\n+    double[] solve(double[] b) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if rowDimension != row dimension of b\n+     * or this is singular\n+     */\n+    RealMatrix solve(RealMatrix b) throws IllegalArgumentException;\n }\n \n--- a/src/java/org/apache/commons/math/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/RealMatrixImpl.java\n import java.io.Serializable;\n \n /**\n- * Implementation for RealMatrix using double[][] array\n- * @author  Phil Stetiz\n- * @version $Revision: 1.3 $ $Date: 2003/06/11 14:50:29 $\n+ * Implementation for RealMatrix using a double[][] array to store entries\n+ * and <a href=\"http://www.math.gatech.edu/~bourbaki/\n+ * math2601/Web-notes/2num.pdf\">LU decompostion</a> to support linear system \n+ * solution and inverse.\n+ * <p>\n+ * The <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes\n+ * /2num.pdf\">LU decompostion</a> is performed as needed, to support the \n+ * following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul>\n+ * <p>\n+ * <strong>Usage note</strong>:<br>\n+ * The LU decomposition is stored and reused on subsequent calls.  If matrix\n+ * data are modified using any of the public setXxx methods, the saved \n+ * decomposition is discarded.  If data are modified via references to the\n+ * underlying array obtained using <code>getDataRef()</code>, then the stored\n+ * LU decomposition will not be discarded.  In this case, you need to \n+ * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.\n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.4 $ $Date: 2003/06/15 17:01:39 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n \n     /** Entries of the matrix */\n-    private double data[][];\n-    \n+    private double data[][] = null;\n+    \n+    /** Entries of LU decomposition.\n+     * All updates to data (other than luDecompostion) *must* set this to null\n+     */\n+    private double lu[][] = null;\n+    \n+    /** Pivot array associated with LU decompostion */\n+    private int[] pivot = null;\n+    \n+    /** Parity of the permutation associated with the LU decomposition */\n+    private int parity = 1;\n+    \n+    /** Bound to determine effective singularity in LU decomposition */\n+    private static double TOO_SMALL = 10E-12;\n+    \n+    /** \n+     * Creates a matrix with no data\n+     */\n     public RealMatrixImpl() {\n     }\n-\n-     /**\n-     * Create a new RealMatrix with the supplied row and column dimensions\n+    \n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n      * @param rowDimension      the number of rows in the new matrix\n      * @param columnDimension   the number of columns in the new matrix\n-     */ \n+     */\n     public RealMatrixImpl(int rowDimension,\n-        int columnDimension) {\n+    int columnDimension) {\n         data = new double[rowDimension][columnDimension];\n-    }\n-    \n-    public RealMatrixImpl(double[][] data) {\n-        this.data = data;\n-    }\n-    \n-    /**\n-     * Create a new RealMatrix which is a copy of *this\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new RealMatrix using the <code>data</code> as the underlying\n+     * data array.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param d data for new matrix\n+     */\n+    public RealMatrixImpl(double[][] d) {\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new (column) RealMatrix using <code>v</code> as the \n+     * data for the unique column of the <code>v.length x 1</code> matrix \n+     * created.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public RealMatrixImpl(double[] v) {\n+        int nRows = v.length;\n+        data = new double[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+    \n+    /**\n+     * Create a new RealMatrix which is a copy of this.\n+     *\n      * @return  the cloned matrix\n      */\n     public RealMatrix copy() {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Compute the sum of *this and m\n+        return new RealMatrixImpl(this.copyOut());\n+    }\n+    \n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n      * @param m    matrix to be added\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as *this\n-     */\n-    public RealMatrix add(RealMatrix m) {\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getColumnDimension() ||\n-            this.getRowDimension() != m.getRowDimension()) {\n-                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n         int rowCount = this.getRowDimension();\n         int columnCount = this.getColumnDimension();\n     }\n     \n     /**\n-     * Compute *this minus m\n+     * Compute  this minus <code>m</code>.\n+     *\n      * @param m    matrix to be subtracted\n      * @return     this + m\n      * @exception  IllegalArgumentException if m is not the same size as *this\n      */\n-    public RealMatrix subtract(RealMatrix m) {\n+    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getColumnDimension() ||\n-            this.getRowDimension() != m.getRowDimension()) {\n-                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n         int rowCount = this.getRowDimension();\n         int columnCount = this.getColumnDimension();\n     }\n     \n     /**\n-     * Returns the rank of the matrix\n-     * @return     the rank of this matrix\n+     * Returns the rank of the matrix.\n+     *\n+     * @return the rank of this matrix\n      */\n     public int getRank() {\n+        // FIXME: need to add singular value decomposition or drop this\n         throw new UnsupportedOperationException(\"not implemented yet\");\n     }\n-        \n-    \n-     /**\n-     * Returns the result of adding d to each entry of *this\n+    \n+    \n+    /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n      * @param d    value to be added to each entry\n      * @return     d + this\n      */\n         }\n         return new RealMatrixImpl(outData);\n     }\n-     \n-    /**\n-     * Returns the result multiplying each entry of *this by d\n-     * @param d    value to multiply all entries by\n-     * @return     d*this\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by <code>d</code>\n+     * @param d  value to multiply all entries by\n+     * @return d * this\n      */\n     public RealMatrix scalarMultiply(double d) {\n         int rowCount = this.getRowDimension();\n         double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col]*d;\n+                outData[row][col] = data[row][col] * d;\n             }\n         }\n         return new RealMatrixImpl(outData);\n     }\n     \n     /**\n-     * Returns the result postmultiplying *this by m\n+     * Returns the result postmultiplying this by <code>m</code>.\n      * @param m    matrix to postmultiply by\n      * @return     this*m\n-     * @throws     IllegalArgumentException \n+     * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    public RealMatrix multiply(RealMatrix m) {\n-      if (this.getColumnDimension() != m.getRowDimension()) {\n-         throw new IllegalArgumentException\n+    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException\n             (\"Matrices are not multiplication compatible.\");\n-      }\n-      double[][] mData = m.getData();\n-      double[][] outData = \n-        new double[this.getRowDimension()][m.getColumnDimension()];\n-      double sum = 0;\n-      for (int row = 0; row < this.getRowDimension(); row++) {\n-         for (int col = 0; col < m.getColumnDimension(); col++) {\n-            sum = 0;\n-            for (int i = 0; i < this.getColumnDimension(); i++) {\n-                sum += data[row][i] * mData[i][col];\n-            }\n-            outData[row][col] = sum;\n-         }\n-      }\n-      return new RealMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Returns matrix entries as a two-dimensional array\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        double[][] mData = m.getData();\n+        double[][] outData =\n+        new double[nRows][nCols];\n+        double sum = 0;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                sum = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    sum += data[row][i] * mData[i][col];\n+                }\n+                outData[row][col] = sum;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     * <p>\n+     * Makes a fresh copy of the underlying data.\n+     *\n      * @return    2-dimensional array of entries\n      */\n     public double[][] getData() {\n+        return copyOut();\n+    }\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a fresh copy of <code>inData</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setData(double[][] inData) {\n+        copyIn(inData);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does not make a fresh copy of the underlying data.\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public double[][] getDataRef() {\n         return data;\n     }\n     \n     /**\n-     * Sets/overwrites the underlying data for the matrix\n-     * @param  data  2-dimensional array of entries\n-     */\n-    public void setData(double[][] data) {\n-        this.data = data;\n-    }\n-    \n-    /**\n-     * Returns the 1-norm of the matrix (max column sum) \n+     * Overwrites the underlying data for the matrix\n+     * with a reference to <code>inData</code>.\n+     * <p>\n+     * Does not make a fresh copy of <code>data</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setDataRef(double[][] inData) {\n+        this.data = inData;\n+        lu = null;\n+    }\n+    \n+    /**\n+     *\n      * @return norm\n      */\n     public double getNorm() {\n-      double maxColSum = 0;\n-      for (int col = 0; col < this.getColumnDimension(); col++) {\n-         double sum = 0;\n-         for (int row = 0; row < this.getRowDimension(); row++) {\n-            sum += Math.abs(data[row][col]);\n-         }\n-         maxColSum = Math.max(maxColSum,sum);\n-      }\n-      return maxColSum;\n-    }\n-    \n-    /**\n-     * Returns entries in row as an array\n+        double maxColSum = 0;\n+        for (int col = 0; col < this.getColumnDimension(); col++) {\n+            double sum = 0;\n+            for (int row = 0; row < this.getRowDimension(); row++) {\n+                sum += Math.abs(data[row][col]);\n+            }\n+            maxColSum = Math.max(maxColSum, sum);\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /**\n+     *\n      * @param row  the row to be fetched\n-     * @return     array of entries in the row\n-     * @throws     IllegalArgumentException if row > rowDimension\n-     */\n-    public double[] getRow(int row) {\n-        return data[row];\n-    }\n-    \n-    /**\n-     * Returns entries in column as an array\n-     * @param col  column to fetch\n-     * @return     array of entries in the column\n-     * @throws     IllegalArgumentException if column > columnDimension\n-     */\n-    public double[] getColumn(int col) {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Returns the entry in the specified row and column\n-     * @param row  row location of entry to be fetched  \n+     * @return array of entries in the row\n+     * @throws IllegalArgumentException if row > rowDimension or row < 1\n+     */\n+    public double[] getRow(int row) throws IllegalArgumentException {\n+        if (row > this.getRowDimension() || row < 1) {\n+            throw new IllegalArgumentException(\"illegal row argument\");\n+        }\n+        int ncols = this.getColumnDimension();\n+        double[] out = new double[ncols];\n+        System.arraycopy(data[row - 1], 0, out, 0, ncols);\n+        return out;\n+    }\n+    \n+    /**\n+     * @param col column to fetch\n+     * @return array of entries in the column\n+     * @throws IllegalArgumentException if column > columnDimension or\n+     * column < 1\n+     */\n+    public double[] getColumn(int col) throws IllegalArgumentException {\n+        if (col > this.getColumnDimension() || col < 1) {\n+            throw new IllegalArgumentException(\"illegal column argument\");\n+        }\n+        int nRows = this.getRowDimension();\n+        double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = data[row][col - 1];\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n-     * @return     matrix entry in row,column\n-     * @throws     IllegalArgumentException if entry does not exist\n-     */\n-    public double getEntry(int row, int column) {\n-        if (row < 1 || column < 1 || row > this.getRowDimension() \n-            || column > this.getColumnDimension()) {\n-                throw new IllegalArgumentException\n-                    (\"matrix entry does not exist\");\n-        }\n-        return data[row-1][column-1];\n-    }\n-    \n-    /**\n-     * Sets the entry in the specified row and column to the specified value\n-     * @param row    row location of entry to be set \n+     * @return matrix entry in row,column\n+     * @throws IllegalArgumentException if entry does not exist\n+     */\n+    public double getEntry(int row, int column)\n+    throws IllegalArgumentException {\n+        if (row < 1 || column < 1 || row > this.getRowDimension()\n+        || column > this.getColumnDimension()) {\n+            throw new IllegalArgumentException\n+            (\"matrix entry does not exist\");\n+        }\n+        return data[row - 1][column - 1];\n+    }\n+    \n+    /**\n+     * @param row    row location of entry to be set\n      * @param column    column location of entry to be set\n-     * @param value  value to set \n+     * @param value  value to set\n      * @throws IllegalArgumentException if entry does not exist\n      */\n-    public void setEntry(int row, int column, double value) {\n+    public void setEntry(int row, int column, double value)\n+    throws IllegalArgumentException {\n         if (row < 1 || column < 1 || row > this.getRowDimension()\n-            || column > this.getColumnDimension()) {\n-                throw new IllegalArgumentException\n-                    (\"matrix entry does not exist\");\n-        }\n-        data[row-1][column-1] = value;\n-    }\n-    \n-    /**\n-     * Returns the transpose of this matrix\n+        || column > this.getColumnDimension()) {\n+            throw new IllegalArgumentException\n+            (\"matrix entry does not exist\");\n+        }\n+        data[row - 1][column - 1] = value;\n+        lu = null;\n+    }\n+    \n+    /**\n+     *\n      * @return transpose matrix\n      */\n     public RealMatrix transpose() {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-        \n-    \n-    /**\n-     * Returns the inverse of this matrix\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n+        double[][] outData = out.getDataRef();\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                outData[col][row] = data[row][col];\n+            }\n+        }\n+        return out;\n+    }   \n+    \n+    /**\n      * @return inverse matrix\n-     * @throws IllegalArgumentException if *this is not invertible\n-     */\n-    public RealMatrix inverse() {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Returns the determinant of this matrix\n+     * @throws IllegalArgumentException if this is not invertible\n+     */\n+    public RealMatrix inverse() throws IllegalArgumentException {\n+        return solve(getIdentity(this.getRowDimension()));\n+    }\n+    \n+    /**\n      * @return determinant\n-     */\n-    public double getDeterminant() {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Is this a square matrix?\n+     * @throws IllegalArgumentException if matrix is not square\n+     */\n+    public double getDeterminant() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new IllegalArgumentException(\"matrix is not square\");\n+        }\n+        if (isSingular()) {  // note: this has side effect of attempting LU\n+            return 0d;        //       decomp if lu == null\n+        } else {\n+            double det = (double) parity;\n+            for (int i = 0; i < this.getRowDimension(); i++) {\n+                det *= lu[i][i];\n+            }\n+            return det;\n+        }\n+    }\n+    \n+    /**\n      * @return true if the matrix is square (rowDimension = columnDimension)\n      */\n     public boolean isSquare() {\n     }\n     \n     /**\n-     * Is this a singular matrix?\n      * @return true if the matrix is singular\n      */\n     public boolean isSingular() {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Returns the number of rows in the matrix\n+        if (lu == null) {\n+            try {\n+                LUDecompose();\n+                return false;\n+            } catch (IllegalArgumentException ex) {\n+                return true;\n+            }\n+        } else {            // LU decomp must have been successfully performed\n+            return false;   // so the matrix is not singular\n+        }\n+    }\n+    \n+    /**\n      * @return rowDimension\n      */\n     public int getRowDimension() {\n-        return data.length;  \n-    }\n-    \n-    /**\n-     * Returns the number of columns in the matrix\n+        return data.length;\n+    }\n+    \n+    /**\n      * @return columnDimension\n      */\n     public int getColumnDimension() {\n     }\n     \n     /**\n-     * Returns the trace of the matrix\n      * @return trace\n-     */\n-    public double getTrace() {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Returns the result of multiplying this by the vector b\n-     * @return this*v\n-     * @throws IllegalArgumentException if columnDimension != v.size()\n-     */\n-    public double[] operate(double[] v) {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Returns the result of premultiplying this by the vector v\n-     * @return v*this\n-     * @throws IllegalArgumentException if rowDimension != v.size()\n-     */\n-    public RealMatrix preMultiply(double[] v) {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    /**\n-     * Returns the solution vector for a linear system with coefficient\n-     * matrix = *this and constant vector = b \n+     * @throws IllegalArgumentException if the matrix is not square\n+     */\n+    public double getTrace() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new IllegalArgumentException(\"matrix is not square\");\n+        }\n+        double trace = data[0][0];\n+        for (int i = 1; i < this.getRowDimension(); i++) {\n+            trace += data[i][i];\n+        }\n+        return trace;\n+    }\n+    \n+    /**\n+     * @param v vector to operate on\n+     * @throws IllegalArgumentException if columnDimension != v.length\n+     * @return resulting vector\n+     */\n+    public double[] operate(double[] v) throws IllegalArgumentException {\n+        if (v.length != this.getColumnDimension()) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        double[] out = new double[v.length];\n+        for (int row = 0; row < nRows; row++) {\n+            double sum = 0;\n+            for (int i = 0; i < nCols; i++) {\n+                sum += data[row][i] * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+        return out;      \n+    }\n+    \n+    /**\n+     * @param v vector to premultiply by\n+     * @throws IllegalArgumentException if rowDimension != v.length\n+     * @return resulting matrix\n+     */\n+    public RealMatrix preMultiply(double[] v) throws IllegalArgumentException {\n+        int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        // being a bit lazy here -- probably should implement directly, like\n+        // operate\n+        RealMatrix pm = new RealMatrixImpl(v).transpose();\n+        return pm.multiply(this);     \n+    }\n+    \n+    /**\n      * @param b  constant vector\n-     * @return   vector of solution values to AX = b, where A is *this\n-     * @throws   IllegalArgumentException if rowDimension != b.length or matrix \n+     * @return   vector of solution values to AX = b, where A is this\n+     * @throws   IllegalArgumentException if rowDimension != b.length or matrix\n      *           is singular\n      */\n-    public double[] solve(double[] b) {\n-      throw new UnsupportedOperationException(\"not implemented yet\");\n-    } \n-    \n+    public double[] solve(double[] b) throws IllegalArgumentException {\n+        int nRows = this.getRowDimension();\n+        if (b.length != nRows) {\n+            throw new IllegalArgumentException\n+                (\"constant vector has wrong length\");\n+        }\n+        RealMatrix bMatrix = new RealMatrixImpl(b);\n+        double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n+        double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = solution[row][0];\n+        }\n+        return out;\n+    }\n+       \n+    /**\n+     * Uses LU decomposition, performing the composition if the matrix has\n+     * not been decomposed, or if there have been changes to the matrix since\n+     * the last decomposition.\n+     *\n+     * @param b the constant vector\n+     * @return solution matrix\n+     * @throws IllegalArgumentException if this is singular or dimensions\n+     * do not match.\n+     */\n+    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException {\n+        if (b.getRowDimension() != this.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (this.isSingular()) {  // side effect: compute LU decomp\n+            throw new IllegalArgumentException(\"Matrix is singular.\");\n+        }\n+        \n+        int nCol = this.getColumnDimension();\n+        int nRow = this.getRowDimension();\n+        int nColB = b.getColumnDimension();\n+        int nRowB = b.getRowDimension();\n+        \n+        // Apply permutations to b\n+        double[][] bv = b.getData();\n+        double[][] bp = new double[nRowB][nColB];\n+        for (int row = 0; row < nRowB; row++) {\n+            for (int col = 0; col < nColB; col++) {\n+                bp[row][col] = bv[pivot[row]][col];\n+            }\n+        }\n+        bv = null;\n+        \n+        // Solve LY = b\n+        for (int col = 0; col < nCol; col++) {\n+            for (int i = col + 1; i < nCol; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                }\n+            }\n+        }\n+        \n+        // Solve UX = Y\n+        for (int col = nCol - 1; col >= 0; col--) {\n+            for (int j = 0; j < nColB; j++) {\n+                bp[col][j] /= lu[col][col];\n+            }\n+            for (int i = 0; i < col; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                }\n+            }\n+        }\n+        \n+        RealMatrixImpl outMat = new RealMatrixImpl(bp);\n+        return outMat;\n+    }\n+    \n+    /**\n+     * Computes a new <a href=\"http://www.math.gatech.edu/~bourbaki/\n+     * math2601/Web-notes/2num.pdf\">LU decompostion</a> for this matrix,\n+     * storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/\n+     * people/sd/lectures/nummeth98/linear.htm\">Crout's algortithm</a>,\n+     * with partial pivoting.\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.\n+     *\n+     * @throws IllegalArgumentException if the matrix is singular\n+     */\n+    public void LUDecompose() throws IllegalArgumentException {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        lu = this.getData();\n+        \n+        // Initialize pivot array and parity\n+        pivot = new int[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            pivot[row] = row;\n+        }\n+        parity = 1;\n+        \n+        // Loop over columns\n+        for (int col = 0; col < nCols; col++) {\n+            \n+            double sum = 0;\n+            \n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= lu[row][i] * lu[i][col];\n+                }\n+                lu[row][col] = sum;\n+            }\n+            \n+            // lower\n+            int max = col; // pivot row\n+            double largest = 0d;\n+            for (int row = col; row < nRows; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= lu[row][i] * lu[i][col];\n+                }\n+                lu[row][col] = sum;\n+                \n+                // maintain best pivot choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+            \n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n+                lu = null;\n+                throw new IllegalArgumentException(\"matrix is singular\");\n+            }\n+            \n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                parity = -parity;\n+            }\n+            \n+            //Divide the lower elements by the \"winning\" diagonal elt.\n+            for (int row = col + 1; row < nRows; row++) {\n+                lu[row][col] /= lu[col][col];\n+            }\n+        }\n+    }\n+    \n+    //------------------------ Protected methods\n+    \n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     */\n+    protected RealMatrix getIdentity(int dimension) {\n+        RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n+        double[][] d = out.getDataRef();\n+        for (int row = 0; row < dimension; row++) {\n+            for (int col = 0; col < dimension; col++) {\n+                d[row][col] = row == col ? 1d : 0d;\n+            }\n+        }\n+        return out;\n+    }\n+    \n+    //------------------------ Private methods\n+    \n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private double[][] copyOut() {\n+        int nRows = this.getRowDimension();\n+        double[][] out =\n+            new double[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(double[][] in) {\n+        int nRows = in.length;\n+        int nCols = in[0].length;\n+        data = new double[nRows][nCols];\n+        System.arraycopy(in, 0, data, 0, in.length);\n+        for (int i = 0; i < nRows ; i++) {\n+            System.arraycopy(in[i], 0, data[i], 0, nCols);\n+        }\n+        lu = null;\n+    }\n }\n--- a/src/test/org/apache/commons/math/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/RealMatrixImplTest.java\n  * Test cases for the {@link RealMatrixImpl} class.\n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.1 $ $Date: 2003/05/12 19:02:53 $\n+ * @version $Revision: 1.2 $ $Date: 2003/06/15 17:01:39 $\n  */\n \n public final class RealMatrixImplTest extends TestCase {\n     \n     private double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    private double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    private double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    private double[] testDataRow1 = {1d,2d,3d};\n+    private double[] testDataCol3 = {3d,3d,8d};\n     private double[][] testDataInv = \n         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    private double[][] preMultTest = {{8,12,33}};\n     private double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    private double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n     private double[][] testDataPlusInv = \n         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n     private double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    private double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    private double[][] singular = { {2d,3d}, {2d,3d} };\n+    private double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    private double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n     private double[] testVector = {1,2,3};\n-    private double entryTolerance = Math.pow(2,-64);\n-    private double normTolerance = Math.pow(2,-64);\n+    private double[] testVector2 = {1,2,3,4};\n+    private double entryTolerance = 10E-16;\n+    private double normTolerance = 10E-14;\n     \n     public RealMatrixImplTest(String name) {\n         super(name);\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    }     \n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        m2.setData(m.getData());\n+        assertClose(\"getData\",m2,m,entryTolerance);\n+        // no dangling reference...\n+        m2.setEntry(1,1,2000d);\n+        RealMatrixImpl m3 = new RealMatrixImpl(testData);\n+        assertClose(\"no getData side effect\",m,m3,entryTolerance);\n+        m3 = (RealMatrixImpl) m.copy();\n+        double[][] stompMe = {{1d,2d,3d}};\n+        m3.setDataRef(stompMe);\n+        assertClose(\"no copy side effect\",m,new RealMatrixImpl(testData),\n+            entryTolerance);\n+    }           \n     \n     /** test add */\n     public void testAdd() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);\n         assertClose(\"m-n = m + -n\",m.subtract(m2),\n-            m2.scalarMultiply(-1d).add(m),entryTolerance);\n+            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+        try {\n+            RealMatrix a = m.subtract(new RealMatrixImpl(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n     }\n     \n     /** test multiply */\n         assertClose(\"identity multiply\",identity.multiply(mInv),\n             mInv,entryTolerance);\n         assertClose(\"identity multiply\",m2.multiply(identity),\n-            m2,entryTolerance);       \n-    }\n-    \n+            m2,entryTolerance); \n+        try {\n+            RealMatrix a = m.multiply(new RealMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }   \n+        \n+    /** test isSingular */\n+    public void testIsSingular() {\n+        RealMatrixImpl m = new RealMatrixImpl(singular);\n+        assertTrue(\"singular\",m.isSingular());\n+        m = new RealMatrixImpl(bigSingular);\n+        assertTrue(\"big singular\",m.isSingular());\n+        m = new RealMatrixImpl(id);\n+        assertTrue(\"identity nonsingular\",!m.isSingular());\n+        m = new RealMatrixImpl(testData);\n+        assertTrue(\"testData nonsingular\",!m.isSingular());\n+    }\n+        \n+    /** test inverse */\n+    public void testInverse() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n+        assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n+        assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n+    }\n+    \n+    /** test solve */\n+    public void testSolve() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n+        // being a bit slothful here -- actually testing that X = A^-1 * B\n+        assertClose(\"inverse-operate\",mInv.operate(testVector),\n+            m.solve(testVector),normTolerance);\n+        try {\n+            double[] x = m.solve(testVector2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }       \n+        RealMatrix bs = new RealMatrixImpl(bigSingular);\n+        try {\n+            RealMatrix a = bs.solve(bs);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            RealMatrix a = m.solve(bs);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test determinant */\n+    public void testDeterminant() {       \n+        RealMatrix m = new RealMatrixImpl(bigSingular);\n+        assertEquals(\"singular determinant\",0,m.getDeterminant(),0);\n+        m = new RealMatrixImpl(detData);\n+        assertEquals(\"nonsingular test\",-3d,m.getDeterminant(),normTolerance);\n+        try {\n+            double a = new RealMatrixImpl(testData2).getDeterminant();\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new RealMatrixImpl(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new RealMatrixImpl(testData2);\n+        try {\n+            double x = m.getTrace();\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertClose(\"scalar add\",new RealMatrixImpl(testDataPlus2),\n+            m.scalarAdd(2d),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new RealMatrixImpl(id);\n+        double[] x = m.operate(testVector);\n+        assertClose(\"identity operate\",testVector,x,entryTolerance);\n+        m = new RealMatrixImpl(bigSingular);\n+        try {\n+            x = m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new RealMatrixImpl(testData); \n+        assertClose(\"inverse-transpose\",m.inverse().transpose(),\n+            m.transpose().inverse(),normTolerance);\n+        m = new RealMatrixImpl(testData2);\n+        RealMatrix mt = new RealMatrixImpl(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply */\n+    public void testPremultiply() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        RealMatrix mp = new RealMatrixImpl(preMultTest);\n+        assertClose(\"premultiply\",m.preMultiply(testVector),mp,normTolerance);\n+        m = new RealMatrixImpl(bigSingular);\n+        try {\n+            RealMatrix x = m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertClose(\"get row\",m.getRow(1),testDataRow1,entryTolerance);\n+        assertClose(\"get col\",m.getColumn(3),testDataCol3,entryTolerance);\n+        try {\n+            double[] x = m.getRow(10);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double[] x = m.getColumn(-1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testEntryMutators() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertEquals(\"get entry\",m.getEntry(1,2),2d,entryTolerance);\n+        m.setEntry(1,2,100d);\n+        assertEquals(\"get entry\",m.getEntry(1,2),100d,entryTolerance);\n+        try {\n+            double x = m.getEntry(0,2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            m.setEntry(1,4,200d);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+        \n+    \n+    //--------------- -----------------Private methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n     private void assertClose(String msg, RealMatrix m, RealMatrix n,\n         double tolerance) {\n         assertTrue(msg,m.subtract(n).getNorm() < tolerance);\n     }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    private void assertClose(String msg, double[] m, double[] n,\n+        double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", \n+                m[i],n[i],tolerance);\n+        }\n+    }\n+    \n+    /** Useful for debugging */\n+    private void dumpMatrix(RealMatrix m) {\n+          for (int i = 0; i < m.getRowDimension(); i++) {\n+              String os = \"\";\n+              for (int j = 0; j < m.getColumnDimension(); j++) {\n+                  os += m.getEntry(i+1, j+1) + \" \";\n+              }\n+              System.out.println(os);\n+          }\n+    }\n         \n }\n ", "timestamp": 1055696499, "metainfo": ""}