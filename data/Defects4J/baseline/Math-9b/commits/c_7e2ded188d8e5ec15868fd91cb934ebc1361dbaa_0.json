{"sha": "7e2ded188d8e5ec15868fd91cb934ebc1361dbaa", "log": "Javadoc and code formatting.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n  * @since 3.0\n  */\n \n-public class CMAESOptimizer extends\n-        BaseAbstractScalarOptimizer<MultivariateRealFunction> implements\n-        MultivariateRealOptimizer {\n-\n+public class CMAESOptimizer\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    implements MultivariateRealOptimizer {\n     /** Default value for {@link #checkFeasableCount}: {@value}. */\n     public static final int DEFAULT_CHECKFEASABLECOUNT = 0;\n     /** Default value for {@link #stopfitness}: {@value}. */\n     }\n \n     /**\n-     * @param lambda\n-     *            Population size.\n+     * @param lambda Population size.\n      */\n     public CMAESOptimizer(int lambda) {\n         this(lambda, null, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n-                DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n-                DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n-    }\n-\n-    /**\n-     * @param lambda\n-     *            Population size.\n-     * @param inputSigma\n-     *            Initial search volume - sigma of offspring objective\n-     *            variables.\n-     * @param boundaries\n-     *            Boundaries for objective variables.\n+             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n+             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n+    }\n+\n+    /**\n+     * @param lambda Population size.\n+     * @param inputSigma Initial search volume; sigma of offspring objective variables.\n+     * @param boundaries Boundaries for objective variables.\n      */\n     public CMAESOptimizer(int lambda, double[] inputSigma,\n-            double[][] boundaries) {\n+                          double[][] boundaries) {\n         this(lambda, inputSigma, boundaries, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n-                DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n-                DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n-    }\n-\n-    /**\n-     * @param lambda\n-     *            Population size.\n-     * @param inputSigma\n-     *            Initial search volume - sigma of offspring objective\n-     *            variables.\n-     * @param boundaries\n-     *            Boundaries for objective variables.\n-     * @param maxIterations\n-     *            Maximal number of iterations.\n-     * @param stopfitness\n-     *            stop if objective function value < stopfitness.\n-     * @param isActiveCMA\n-     *            Chooses the covariance matrix update method.\n-     * @param diagonalOnly\n-     *            Number of initial iterations, where the covariance matrix\n-     *            remains diagonal.\n-     * @param checkFeasableCount\n-     *            Determines how often new. random objective variables are\n-     *            generated in case they are out of bounds.\n-     * @param random\n-     *            Used random generator.\n-     * @param generateStatistics\n-     *            Indicates whether statistic data is collected.\n+             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n+             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n+    }\n+\n+    /**\n+     * @param lambda Population size.\n+     * @param inputSigma Initial search volume; sigma of offspring objective variables.\n+     * @param boundaries Boundaries for objective variables.\n+     * @param maxIterations Maximal number of iterations.\n+     * @param stopFitness Whether to stop if objective function value is smaller than\n+     * {@code stopFitness}.\n+     * @param isActiveCMA Chooses the covariance matrix update method.\n+     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n+     * remains diagonal.\n+     * @param checkFeasableCount Determines how often new random objective variables are\n+     * generated in case they are out of bounds.\n+     * @param random Random generator.\n+     * @param generateStatistics Whether statistic data is collected.\n      */\n     public CMAESOptimizer(int lambda, double[] inputSigma,\n-            double[][] boundaries, int maxIterations, double stopfitness,\n-            boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n-            RandomGenerator random, boolean generateStatistics) {\n+                          double[][] boundaries, int maxIterations, double stopFitness,\n+                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n+                          RandomGenerator random, boolean generateStatistics) {\n         this.lambda = lambda;\n         this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n         if (boundaries == null) {\n     /**\n      * Initialization of the dynamic search parameters\n      *\n-     * @param guess\n-     *            initial guess for the arguments of the fitness function\n-     */\n-\n+     * @param guess Initial guess for the arguments of the fitness function.\n+     */\n     private void initializeCMA(double[] guess) {\n         if (lambda <= 0) {\n             lambda = 4 + (int) (3. * Math.log(dimension));\n     }\n \n     /**\n-     * Update of the evolution paths ps and pc\n+     * Update of the evolution paths ps and pc.\n      *\n-     * @param zmean\n-     *            weighted row matrix of the gaussian random numbers generating\n-     *            the current offspring\n-     * @param xold\n-     *            xmean matrix of the previous generation\n-     * @return hsig flag indicating a small correction\n+     * @param zmean Weighted row matrix of the gaussian random numbers generating\n+     * the current offspring.\n+     * @param xold xmean matrix of the previous generation.\n+     * @return hsig flag indicating a small correction.\n      */\n     private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n         ps = ps.scalarMultiply(1. - cs).add(\n     /**\n      * Update of the covariance matrix C for diagonalOnly > 0\n      *\n-     * @param hsig\n-     *            flag indicating a small correction\n-     * @param bestArz\n-     *            fitness-sorted matrix of the gaussian random values of the\n-     *            current offspring\n-     * @param xold\n-     *            xmean matrix of the previous generation\n-     */\n-    private void updateCovarianceDiagonalOnly(boolean hsig, final RealMatrix bestArz,\n-            final RealMatrix xold) {\n+     * @param hsig Flag indicating a small correction.\n+     * @param bestArz Fitness-sorted matrix of the gaussian random values of the\n+     * current offspring.\n+     * @param xold xmean matrix of the previous generation.\n+     */\n+    private void updateCovarianceDiagonalOnly(boolean hsig,\n+                                              final RealMatrix bestArz,\n+                                              final RealMatrix xold) {\n         // minor correction if hsig==false\n         double oldFac = hsig ? 0 : ccov1Sep * cc * (2. - cc);\n         oldFac += 1. - ccov1Sep - ccovmuSep;\n     }\n \n     /**\n-     * Update of the covariance matrix C\n+     * Update of the covariance matrix C.\n      *\n-     * @param hsig\n-     *            flag indicating a small correction\n-     * @param bestArx\n-     *            fitness-sorted matrix of the argument vectors producing the\n-     *            current offspring\n-     * @param arz\n-     *            unsorted matrix containing the gaussian random values of the\n-     *            current offspring\n-     * @param arindex\n-     *            indices indicating the fitness-order of the current offspring\n-     * @param xold\n-     *            xmean matrix of the previous generation\n+     * @param hsig Flag indicating a small correction.\n+     * @param bestArx Fitness-sorted matrix of the argument vectors producing the\n+     * current offspring.\n+     * @param arz Unsorted matrix containing the gaussian random values of the\n+     * current offspring.\n+     * @param arindex Indices indicating the fitness-order of the current offspring.\n+     * @param xold xmean matrix of the previous generation.\n      */\n     private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n             final RealMatrix arz, final int[] arindex, final RealMatrix xold) {\n     }\n \n     /**\n-     * Update B and D from C\n+     * Update B and D from C.\n      *\n-     * @param negccov\n-     *            Negative covariance factor.\n+     * @param negccov Negative covariance factor.\n      */\n     private void updateBD(double negccov) {\n         if (ccov1 + ccovmu + negccov > 0 &&\n     /**\n      * Pushes the current best fitness value in a history queue.\n      *\n-     * @param vals\n-     *            the history queue\n-     * @param val\n-     *            current best fitness value\n+     * @param vals History queue.\n+     * @param val Current best fitness value.\n      */\n     private static void push(double[] vals, double val) {\n         for (int i = vals.length-1; i > 0; i--) {\n     /**\n      * Sorts fitness values.\n      *\n-     * @param doubles\n-     *            array of values to be sorted\n-     * @return sorted array of indices pointing into doubles\n+     * @param doubles Array of values to be sorted.\n+     * @return a sorted array of indices pointing into doubles.\n      */\n     private int[] sortedIndices(final double[] doubles) {\n         DoubleIndex[] dis = new DoubleIndex[doubles.length];\n      * order.\n      */\n     private static class DoubleIndex implements Comparable<DoubleIndex> {\n-\n         /** Value to compare. */\n         private double value;\n         /** Index into sorted array. */\n         private int index;\n \n         /**\n-         * @param value\n-         *            Value to compare.\n-         * @param index\n-         *            Index into sorted array.\n+         * @param value Value to compare.\n+         * @param index Index into sorted array.\n          */\n         DoubleIndex(double value, int index) {\n             this.value = value;\n      * setValueRange().\n      */\n     private class FitnessFunction {\n-\n         /** Determines the penalty for boundary violations */\n         private double valueRange;\n         /**\n         }\n \n         /**\n-         * @param x\n-         *            Original objective variables.\n-         * @return Normalized objective variables.\n+         * @param x Original objective variables.\n+         * @return the normalized objective variables.\n          */\n         public double[] encode(final double[] x) {\n             if (boundaries == null) {\n         }\n \n         /**\n-         * @param x\n-         *            Normalized objective variables.\n-         * @return Original objective variables.\n+         * @param x Normalized objective variables.\n+         * @return the original objective variables.\n          */\n         public double[] decode(final double[] x) {\n             if (boundaries == null) {\n         }\n \n         /**\n-         * @param point\n-         *            Normalized objective variables.\n-         * @return Objective value + penalty for violated bounds.\n+         * @param point Normalized objective variables.\n+         * @return the objective value + penalty for violated bounds.\n          */\n         public double value(final double[] point) {\n             double value;\n         }\n \n         /**\n-         * @param x\n-         *            Normalized objective variables.\n-         * @return True if in bounds\n+         * @param x Normalized objective variables.\n+         * @return {@code true} if in bounds.\n          */\n         public boolean isFeasible(final double[] x) {\n             if (boundaries == null) {\n         }\n \n         /**\n-         * @param valueRange\n-         *            Adjusts the penalty computation.\n+         * @param valueRange Adjusts the penalty computation.\n          */\n         public void setValueRange(double valueRange) {\n             this.valueRange = valueRange;\n         }\n \n         /**\n-         * @param x\n-         *            Normalized objective variables.\n-         * @return Repaired objective variables - all in bounds.\n+         * @param x Normalized objective variables.\n+         * @return the repaired objective variables - all in bounds.\n          */\n         private double[] repair(final double[] x) {\n             double[] repaired = new double[x.length];\n         }\n \n         /**\n-         * @param x\n-         *            Normalized objective variables.\n-         * @param repaired\n-         *            Repaired objective variables.\n+         * @param x Normalized objective variables.\n+         * @param repaired Repaired objective variables.\n          * @return Penalty value according to the violation of the bounds.\n          */\n         private double penalty(final double[] x, final double[] repaired) {\n     // -----Matrix utility functions similar to the Matlab build in functions------\n \n     /**\n-     * @param m\n-     *            Input matrix\n-     * @return Matrix representing the element wise logarithm of m.\n+     * @param m Input matrix\n+     * @return Matrix representing the element-wise logarithm of m.\n      */\n     private static RealMatrix log(final RealMatrix m) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n     /**\n      * @param m\n      *            Input matrix\n-     * @return Matrix representing the element wise square root of m.\n+     * @return Matrix representing the element-wise square root of m.\n      */\n     private static RealMatrix sqrt(final RealMatrix m) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n \n     /**\n      * @param m Input matrix\n-     * @return Matrix representing the element wise square (^2) of m.\n+     * @return Matrix representing the element-wise square (^2) of m.\n      */\n     private static RealMatrix square(final RealMatrix m) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n     }\n \n     /**\n-     * @param m\n-     *            Input matrix 1.\n-     * @param n\n-     *            Input matrix 2.\n-     * @return Matrix where the elements of m and m are element wise multiplied.\n+     * @param m Input matrix 1.\n+     * @param n Input matrix 2.\n+     * @return the matrix where the elements of m and n are element-wise multiplied.\n      */\n     private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n         for (int r = 0; r < m.getRowDimension(); r++) {\n             for (int c = 0; c < m.getColumnDimension(); c++) {\n-                d[r][c] = m.getEntry(r, c)*n.getEntry(r, c);\n+                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n             }\n         }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n     /**\n-     * @param m\n-     *            Input matrix 1.\n-     * @param n\n-     *            Input matrix 2.\n-     * @return Matrix where the elements of m and m are element wise divided.\n+     * @param m Input matrix 1.\n+     * @param n Input matrix 2.\n+     * @return Matrix where the elements of m and n are element-wise divided.\n      */\n     private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n         for (int r = 0; r < m.getRowDimension(); r++) {\n             for (int c = 0; c < m.getColumnDimension(); c++) {\n-                d[r][c] = m.getEntry(r, c)/n.getEntry(r, c);\n+                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n             }\n         }\n         return new Array2DRowRealMatrix(d, false);\n \n     /**\n      * @param m Input matrix.\n-     * @param k diagonal position.\n+     * @param k Diagonal position.\n      * @return Upper triangular part of matrix.\n      */\n     private static RealMatrix triu(final RealMatrix m, int k) {\n     }\n \n     /**\n-     * @param m\n-     *            Input matrix.\n+     * @param m Input matrix.\n      * @return Row matrix representing the sums of the rows.\n      */\n     private static RealMatrix sumRows(final RealMatrix m) {\n     }\n \n     /**\n-     * @param m\n-     *            Input matrix.\n-     * @return Diagonal n X n matrix if m is a column matrix, Column matrix\n-     *         representing the diagonal if m is a nXn matrix.\n+     * @param m Input matrix.\n+     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n+     * matrix representing the diagonal if m is a n-by-n matrix.\n      */\n     private static RealMatrix diag(final RealMatrix m) {\n         if (m.getColumnDimension() == 1) {\n     /**\n      * Copies a column from m1 to m2.\n      *\n-     * @param m1\n-     *            Source matrix 1.\n-     * @param col1\n-     *            Source column.\n-     * @param m2\n-     *            Target matrix.\n-     * @param col2\n-     *            Target column.\n+     * @param m1 Source matrix 1.\n+     * @param col1 Source column.\n+     * @param m2 Target matrix.\n+     * @param col2 Target column.\n      */\n     private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {\n         for (int i = 0; i < m1.getRowDimension(); i++) {\n     }\n \n     /**\n-     * @param n\n-     *            Number of rows.\n-     * @param m\n-     *            Number of columns.\n-     * @return n X m matrix of 1.0-values.\n+     * @param n Number of rows.\n+     * @param m Number of columns.\n+     * @return n-by-m matrix filled with 1.\n      */\n     private static RealMatrix ones(int n, int m) {\n         double[][] d = new double[n][m];\n     }\n \n     /**\n-     * @param n\n-     *            Number of rows.\n-     * @param m\n-     *            Number of columns.\n-     * @return n X m matrix of 0.0-values, diagonal has values 1.0.\n+     * @param n Number of rows.\n+     * @param m Number of columns.\n+     * @return n-by-m matrix of 0.0-values, diagonal has values 1.0.\n      */\n     private static RealMatrix eye(int n, int m) {\n         double[][] d = new double[n][m];\n     }\n \n     /**\n-     * @param n\n-     *            Number of rows.\n-     * @param m\n-     *            Number of columns.\n-     * @return n X m matrix of 0.0-values.\n+     * @param n Number of rows.\n+     * @param m Number of columns.\n+     * @return n-by-m matrix of 0.0-values.\n      */\n     private static RealMatrix zeros(int n, int m) {\n         return new Array2DRowRealMatrix(n, m);\n     }\n \n     /**\n-     * @param mat\n-     *            Input matrix.\n-     * @param n\n-     *            Number of row replicates.\n-     * @param m\n-     *            Number of column replicates.\n-     * @return Matrix which replicates the input matrix in both directions.\n+     * @param mat Input matrix.\n+     * @param n Number of row replicates.\n+     * @param m Number of column replicates.\n+     * @return a matrix which replicates the input matrix in both directions.\n      */\n     private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n         int rd = mat.getRowDimension();\n     }\n \n     /**\n-     * @param start\n-     *            Start value.\n-     * @param end\n-     *            End value.\n-     * @param step\n-     *            Step size.\n-     * @return Sequence as column matrix.\n+     * @param start Start value.\n+     * @param end End value.\n+     * @param step Step size.\n+     * @return a sequence as column matrix.\n      */\n     private static RealMatrix sequence(double start, double end, double step) {\n         int size = (int) ((end - start) / step + 1);\n     }\n \n     /**\n-     * @param m\n-     *            Input matrix.\n-     * @return Maximum of matrix element values.\n+     * @param m Input matrix.\n+     * @return the maximum of the matrix element values.\n      */\n     private static double max(final RealMatrix m) {\n         double max = -Double.MAX_VALUE;\n     }\n \n     /**\n-     * @param m\n-     *            Input matrix.\n-     * @return Minimum of matrix element values.\n+     * @param m Input matrix.\n+     * @return the minimum of the matrix element values.\n      */\n     private static double min(final RealMatrix m) {\n         double min = Double.MAX_VALUE;\n     }\n \n     /**\n-     * @param m\n-     *            Input array.\n-     * @return Maximum of array values.\n+     * @param m Input array.\n+     * @return the maximum of the array values.\n      */\n     private static double max(final double[] m) {\n         double max = -Double.MAX_VALUE;\n     }\n \n     /**\n-     * @param m\n-     *            Input array.\n-     * @return Minimum of array values.\n+     * @param m Input array.\n+     * @return the minimum of the array values.\n      */\n     private static double min(final double[] m) {\n         double min = Double.MAX_VALUE;\n     }\n \n     /**\n-     * @param indices\n-     *            Input index array.\n-     * @return Inverse of the mapping defined by indices\n+     * @param indices Input index array.\n+     * @return the inverse of the mapping defined by indices.\n      */\n     private static int[] inverse(final int[] indices) {\n         int[] inverse = new int[indices.length];\n     }\n \n     /**\n-     * @param indices\n-     *            Input index array.\n-     * @return Indices in inverse order (last is first)\n+     * @param indices Input index array.\n+     * @return the indices in inverse order (last is first).\n      */\n     private static int[] reverse(final int[] indices) {\n         int[] reverse = new int[indices.length];\n     }\n \n     /**\n-     * @param size\n-     *            Length of random array.\n-     * @return Array of gaussian random numbers.\n+     * @param size Length of random array.\n+     * @return an array of Gaussian random numbers.\n      */\n     private double[] randn(int size) {\n         double[] randn = new double[size];\n     }\n \n     /**\n-     * @param size\n-     *            Number of rows.\n-     * @param popSize\n-     *            Population size.\n-     * @return 2-dimensional matrix of gaussian random numbers.\n+     * @param size Number of rows.\n+     * @param popSize Population size.\n+     * @return a 2-dimensional matrix of Gaussian random numbers.\n      */\n     private RealMatrix randn1(int size, int popSize) {\n         double[][] d = new double[size][popSize];\n         return new Array2DRowRealMatrix(d, false);\n     }\n }\n-", "timestamp": 1319842996, "metainfo": ""}