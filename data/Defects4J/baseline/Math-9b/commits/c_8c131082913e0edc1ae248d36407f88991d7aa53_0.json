{"sha": "8c131082913e0edc1ae248d36407f88991d7aa53", "log": "MATH-361 Added new exceptions. Replaced several instances of \"IllegalArgumentException\" with a more specific exception. For not yet released code, removed the checked \"DimensionMismatchException\" from the method signature and replaced its instances with the new (unchecked) version of the exception. Corrected typos in Javadoc comments.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n             throw new DimensionMismatchException(xLen, d2FdXdY.length);\n         }\n \n-        MathUtils.checkOrder(x, 1, true);\n-        MathUtils.checkOrder(y, 1, true);\n+        MathUtils.checkOrder(x);\n+        MathUtils.checkOrder(y);\n \n         xval = x.clone();\n         yval = y.clone();\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n             throw new DimensionMismatchException(xval.length, fval.length);\n         }\n \n-        MathUtils.checkOrder(xval, 1, true);\n-        MathUtils.checkOrder(yval, 1, true);\n+        MathUtils.checkOrder(xval);\n+        MathUtils.checkOrder(yval);\n \n         final int xLen = xval.length;\n         final int yLen = yval.length;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.fitting.PolynomialFitter;\n     public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                           final double[] yval,\n                                                           final double[][] fval)\n-        throws MathException, IllegalArgumentException {\n+        throws MathException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xval.length != fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\n             }\n         }\n \n-        MathUtils.checkOrder(xval, 1, true);\n-        MathUtils.checkOrder(yval, 1, true);\n+        MathUtils.checkOrder(xval);\n+        MathUtils.checkOrder(yval);\n \n         // For each line y[j] (0 <= j < yLen), construct a polynomial, with\n         // respect to variable x, fitting array fval[][j]\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n \n import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n \n /**\n      * every grid point.\n      * @param d3FdXdYdZ Values of the cross partial derivative of function on\n      * every grid point.\n+     * @throws NoDataException if any of the arrays has zero length.\n      * @throws DimensionMismatchException if the various arrays do not contain\n      * the expected number of elements.\n      * @throws IllegalArgumentException if {@code x}, {@code y} or {@code z}\n                                                double[][][] d2FdXdY,\n                                                double[][][] d2FdXdZ,\n                                                double[][][] d2FdYdZ,\n-                                               double[][][] d3FdXdYdZ)\n-        throws DimensionMismatchException {\n+                                               double[][][] d3FdXdYdZ) {\n         final int xLen = x.length;\n         final int yLen = y.length;\n         final int zLen = z.length;\n \n         if (xLen == 0 || yLen == 0 || z.length == 0\n             || f.length == 0 || f[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xLen != f.length) {\n             throw new DimensionMismatchException(xLen, f.length);\n             throw new DimensionMismatchException(xLen, d3FdXdYdZ.length);\n         }\n \n-        MathUtils.checkOrder(x, 1, true);\n-        MathUtils.checkOrder(y, 1, true);\n-        MathUtils.checkOrder(z, 1, true);\n+        MathUtils.checkOrder(x);\n+        MathUtils.checkOrder(y);\n+        MathUtils.checkOrder(z);\n \n         xval = x.clone();\n         yval = y.clone();\n     public double value(double x, double y, double z) {\n         final int i = searchIndex(x, xval);\n         if (i == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  x, xval[0], xval[xval.length - 1]);\n+            throw new OutOfRangeException(x, xval[0], xval[xval.length - 1]);\n         }\n         final int j = searchIndex(y, yval);\n         if (j == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  y, yval[0], yval[yval.length - 1]);\n+            throw new OutOfRangeException(y, yval[0], yval[yval.length - 1]);\n         }\n         final int k = searchIndex(z, zval);\n         if (k == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  z, zval[0], zval[zval.length - 1]);\n+            throw new OutOfRangeException(z, zval[0], zval[zval.length - 1]);\n         }\n \n         final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n      */\n     public double value(double x, double y, double z) {\n         if (x < 0 || x > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      x, 0, 1);\n+            throw new OutOfRangeException(x, 0, 1);\n         }\n         if (y < 0 || y > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      y, 0, 1);\n+            throw new OutOfRangeException(y, 0, 1);\n         }\n         if (z < 0 || z > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      z, 0, 1);\n+            throw new OutOfRangeException(z, 0, 1);\n         }\n \n         final double x2 = x * x;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n                                                            final double[] yval,\n                                                            final double[] zval,\n                                                            final double[][][] fval)\n-        throws MathException, IllegalArgumentException {\n+        throws MathException {\n         if (xval.length == 0 || yval.length == 0 || zval.length == 0 || fval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xval.length != fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\n         }\n \n-        MathUtils.checkOrder(xval, 1, true);\n-        MathUtils.checkOrder(yval, 1, true);\n-        MathUtils.checkOrder(zval, 1, true);\n+        MathUtils.checkOrder(xval);\n+        MathUtils.checkOrder(yval);\n+        MathUtils.checkOrder(zval);\n \n         final int xLen = xval.length;\n         final int yLen = yval.length;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n  * sample points must be specified on a regular grid.\n  *\n  * @version $Revision$ $Date$\n+ * @since 2.2\n  */\n public interface TrivariateRealGridInterpolator {\n     /**\n      * in increasing order.\n      * @param fval the values of the interpolation points on all the grid knots:\n      * {@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}.\n-     * @return a function which interpolates the data set.\n+     * @return a function that interpolates the data set.\n+     * @throws NoDataException if any of the arrays has zero length.\n+     * @throws DimensionMismatchException if the array lengths are inconsistent.\n      * @throws MathException if arguments violate assumptions made by the\n      *         interpolation algorithm.\n      */\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n     /**\n      * Construct an exception.\n      *\n-     * @param Localizable pattern.\n+     * @param pattern Localizable pattern.\n      * @param arguments Arguments. The first element must be the requested\n      * value that raised the exception.\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NoDataException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when the required data is missing.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class NoDataException extends MathIllegalArgumentException {\n+    /**\n+     * Construct the exception.\n+     */\n+    public NoDataException() {\n+        super(LocalizedFormats.NO_DATA, null);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NonMonotonousSequenceException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Exception to be thrown when the a sequence of values is not monotonously\n+ * increasing or decreasing.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class NonMonotonousSequenceException extends MathIllegalNumberException {\n+    /**\n+     * Direction (positive for increasing, negative for decreasing).\n+     */\n+    private final MathUtils.Order.Direction direction;\n+    /**\n+     * Whether the sequence must be strictly increasing or decreasing.\n+     */\n+    private final boolean strict;\n+    /**\n+     * Index of the wrong value.\n+     */\n+    private final int index;\n+    /**\n+     * Previous value.\n+     */\n+    private final Number previous;\n+\n+    /**\n+     * Construct the exception.\n+     * This constructor uses default values assuming that the sequence should\n+     * have been strictly increasing.\n+     *\n+     * @param wrong Value that did not match the requirements.\n+     * @param previous Previous value in the sequence.\n+     * @param index Index of the value that did not match the requirements.\n+     */\n+    public NonMonotonousSequenceException(Number wrong,\n+                                          Number previous,\n+                                          int index) {\n+        this(wrong, previous, index, MathUtils.Order.Direction.INCREASING, true);\n+    }\n+\n+    /**\n+     * Construct the exception.\n+     *\n+     * @param wrong Value that did not match the requirements.\n+     * @param previous Previous value in the sequence.\n+     * @param index Index of the value that did not match the requirements.\n+     * @param direction Strictly positive for a sequence required to be\n+     * increasing, negative (or zero) for a decreasing sequence.\n+     * @param strict Whether the sequence must be strictly increasing or\n+     * decreasing.\n+     */\n+    public NonMonotonousSequenceException(Number wrong,\n+                                          Number previous,\n+                                          int index,\n+                                          MathUtils.Order.Direction direction,\n+                                          boolean strict) {\n+        super(direction == MathUtils.Order.Direction.INCREASING ?\n+              (strict ?\n+               LocalizedFormats.NOT_STRICTLY_INCREASING_SEQUENCE :\n+               LocalizedFormats.NOT_INCREASING_SEQUENCE) :\n+              (strict ?\n+               LocalizedFormats.NOT_STRICTLY_DECREASING_SEQUENCE :\n+               LocalizedFormats.NOT_DECREASING_SEQUENCE),\n+              wrong, previous, index, index - 1);\n+\n+        this.direction = direction;\n+        this.strict = strict;\n+        this.index = index;\n+        this.previous = previous;\n+    }\n+\n+    /**\n+     * @return the order direction.\n+     **/\n+    public MathUtils.Order.Direction getDirection() {\n+        return direction;\n+    }\n+    /**\n+     * @return {@code true} is the sequence should be strictly monotonous.\n+     **/\n+    public boolean getStrict() {\n+        return strict;\n+    }\n+    /**\n+     * Get the index of the wrong value.\n+     *\n+     * @return the current index.\n+     */\n+    public int getIndex() {\n+        return index;\n+    }\n+    /**\n+     * @return the previous value.\n+     */\n+    public Number getPrevious() {\n+        return previous;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n     NORMALIZE_NAN(\"Cannot normalize to NaN\"),\n     NOT_ADDITION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not addition compatible\"),\n     NOT_DECREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not decreasing ({2} < {3})\"),\n+    NOT_DECREASING_SEQUENCE(\"points {3} and {2} are not decreasing ({1} < {0})\"), /* keep */\n     NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS(\"not enough data ({0} rows) for this many predictors ({1} predictors)\"),\n     NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION(\"spline partition must have at least {0} points, got {1}\"),\n     NOT_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not increasing ({2} > {3})\"),\n+    NOT_INCREASING_SEQUENCE(\"points {3} and {2} are not increasing ({1} > {0})\"), /* keep */\n     NOT_MULTIPLICATION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\"),\n     NOT_STRICTLY_POSITIVE(\"{0} is not strictly positive\"), /* keep */\n     NOT_POSITIVE(\"{0} is not positive\"), /* keep */\n     NOT_POWER_OF_TWO_CONSIDER_PADDING(\"{0} is not a power of 2, consider padding for fix\"),\n     NOT_POWER_OF_TWO_PLUS_ONE(\"{0} is not a power of 2 plus one\"),\n     NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not strictly decreasing ({2} <= {3})\"),\n+    NOT_STRICTLY_DECREASING_SEQUENCE(\"points {3} and {2} are not strictly decreasing ({1} <= {0})\"), /* keep */\n     NOT_STRICTLY_INCREASING_KNOT_VALUES(\"knot values must be strictly increasing\"),\n     NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not strictly increasing ({2} >= {3})\"),\n+    NOT_STRICTLY_INCREASING_SEQUENCE(\"points {3} and {2} are not strictly increasing ({1} >= {0})\"), /* keep */\n     NOT_SUBTRACTION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not subtraction compatible\"),\n     NOT_SYMMETRIC_MATRIX(\"not symmetric matrix\"),\n     NO_BIN_SELECTED(\"no bin selected\"),\n     NO_CONVERGENCE_WITH_ANY_START_POINT(\"none of the {0} start points lead to convergence\"),\n-    NO_DATA(\"no data\"),\n+    NO_DATA(\"no data\"), /* keep */\n     NO_DEGREES_OF_FREEDOM(\"no degrees of freedom ({0} measurements, {1} parameters)\"),\n     NO_DENSITY_FOR_THIS_DISTRIBUTION(\"This distribution does not have a density function implemented\"),\n     NO_FEASIBLE_SOLUTION(\"no feasible solution\"),\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n import java.util.Arrays;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n      * 3.0, the semantics will change in order to comply with IEEE754 where it\n      * is specified that {@code NaN != NaN}.\n      * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link equalsIncludingNaN(double,double)\n+     * useful (see e.g. {@link #equalsIncludingNaN(double,double)\n      * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n      * 3.0, the semantics will change in order to comply with IEEE754 where it\n      * is specified that {@code NaN != NaN}.\n      * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link equalsIncludingNaN(double[],double[])\n+     * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n      * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         return max;\n     }\n \n+    public static class Order {\n+        public static enum Direction {\n+                INCREASING,\n+                DECREASING\n+        };\n+    }\n+\n+    /**\n+     * Checks that the given array is sorted.\n+     *\n+     * @param val Values.\n+     * @param dir Order direction.\n+     * @param strict Whether the order should be strict.\n+     * @throws NonMonotonousSequenceException if the array is not sorted.\n+     */\n+    public static void checkOrder(double[] val, Order.Direction dir, boolean strict) {\n+        double previous = val[0];\n+        boolean ok = true;\n+\n+        int max = val.length;\n+        for (int i = 1; i < max; i++) {\n+            switch (dir) {\n+            case INCREASING:\n+                if (strict) {\n+                    if (val[i] <= previous) {\n+                        ok = false;\n+                    }\n+                } else {\n+                    if (val[i] < previous) {\n+                        ok = false;\n+                    }\n+                }\n+                break;\n+            case DECREASING:\n+                if (strict) {\n+                    if (val[i] >= previous) {\n+                        ok = false;\n+                    }\n+                } else {\n+                    if (val[i] > previous) {\n+                        ok = false;\n+                    }\n+                }\n+                break;\n+            default:\n+                // Should never happen.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (!ok) {\n+                throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);\n+            }\n+            previous = val[i];\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given array is sorted in strictly increasing order.\n+     *\n+     * @param val Values.\n+     * @throws NonMonotonousSequenceException if the array is not sorted.\n+     */\n+    public static void checkOrder(double[] val) {\n+        checkOrder(val, Order.Direction.INCREASING, true);\n+    }\n+\n     /**\n      * Checks that the given array is sorted.\n      *\n      * @param val Values\n      * @param dir Order direction (-1 for decreasing, 1 for increasing)\n      * @param strict Whether the order should be strict\n-     * @throws IllegalArgumentException if the array is not sorted.\n+     * @throws NonMonotonousSequenceException if the array is not sorted.\n+     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],Order.Direction,boolean)\n+     * checkOrder} method). To be removed in 3.0.\n      */\n     public static void checkOrder(double[] val, int dir, boolean strict) {\n-        double previous = val[0];\n-\n-        int max = val.length;\n-        for (int i = 1; i < max; i++) {\n-            if (dir > 0) {\n-                if (strict) {\n-                    if (val[i] <= previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n-                                                                                  i - 1, i, previous, val[i]);\n-                    }\n-                } else {\n-                    if (val[i] < previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_INCREASING_NUMBER_OF_POINTS,\n-                                                                                  i - 1, i, previous, val[i]);\n-                    }\n-                }\n-            } else {\n-                if (strict) {\n-                    if (val[i] >= previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS,\n-                                                                                  i - 1, i, previous, val[i]);\n-                    }\n-                } else {\n-                    if (val[i] > previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_DECREASING_NUMBER_OF_POINTS,\n-                                                                                  i - 1, i, previous, val[i]);\n-                    }\n-                }\n-            }\n-\n-            previous = val[i];\n+        if (dir > 0) {\n+            checkOrder(val, Order.Direction.INCREASING, strict);\n+        } else {\n+            checkOrder(val, Order.Direction.DECREASING, strict);\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n      * Convert to multidimensional counter.\n      *\n      * @param index Index in unidimensional counter.\n-     * @returns the multidimensional counts.\n+     * @return the multidimensional counts.\n      * @throws {@link OutOfRangeException} if {@code index} is not between\n      * {@code 0} and the value returned by {@link #getSize()} (excluded).\n      */\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/exception/NonMonotonousSequenceExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link NonMonotonousSequenceException}.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public class NonMonotonousSequenceExceptionTest {\n+    @Test\n+    public void testAccessors() {\n+        NonMonotonousSequenceException e\n+            = new NonMonotonousSequenceException(0, -1, 1, MathUtils.Order.Direction.DECREASING, false);\n+        Assert.assertEquals(0, e.getArgument());\n+        Assert.assertEquals(-1, e.getPrevious());\n+        Assert.assertEquals(1, e.getIndex());\n+        Assert.assertTrue(e.getDirection() == MathUtils.Order.Direction.DECREASING);\n+        Assert.assertFalse(e.getStrict());\n+\n+        e = new NonMonotonousSequenceException(-1, 0, 1);\n+        Assert.assertEquals(-1, e.getArgument());\n+        Assert.assertEquals(0, e.getPrevious());\n+        Assert.assertEquals(1, e.getIndex());\n+        Assert.assertTrue(e.getDirection() == MathUtils.Order.Direction.INCREASING);\n+        Assert.assertTrue(e.getStrict());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n \n /**\n  * Test cases for the MathUtils class.\n     }\n \n     public void testCheckOrder() {\n-        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15}, 1, true);\n-        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 2}, 1, false);\n-        MathUtils.checkOrder(new double[] {3, -5.5, -11, -27.5}, -1, true);\n-        MathUtils.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5}, -1, false);\n-\n-        try {\n-            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15}, 1, true);\n+        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15},\n+                             MathUtils.Order.Direction.INCREASING, true);\n+        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 2},\n+                             MathUtils.Order.Direction.INCREASING, false);\n+        MathUtils.checkOrder(new double[] {3, -5.5, -11, -27.5},\n+                             MathUtils.Order.Direction.DECREASING, true);\n+        MathUtils.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5},\n+                             MathUtils.Order.Direction.DECREASING, false);\n+\n+        try {\n+            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},\n+                                 MathUtils.Order.Direction.INCREASING, true);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n         try {\n-            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2}, 1, false);\n+            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2},\n+                                 MathUtils.Order.Direction.INCREASING, false);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n         try {\n-            MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5}, -1, true);\n+            MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},\n+                                 MathUtils.Order.Direction.DECREASING, true);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n         try {\n-            MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5}, -1, false);\n+            MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},\n+                                 MathUtils.Order.Direction.DECREASING, false);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n     }", "timestamp": 1277987443, "metainfo": ""}