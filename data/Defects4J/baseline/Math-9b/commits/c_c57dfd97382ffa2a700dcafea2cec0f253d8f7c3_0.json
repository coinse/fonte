{"sha": "c57dfd97382ffa2a700dcafea2cec0f253d8f7c3", "log": "Fixes MATH-435 for FieldMatrix<T>, too.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n package org.apache.commons.math.linear;\n \n import java.lang.reflect.Array;\n+import java.util.ArrayList;\n import java.util.Arrays;\n \n import org.apache.commons.math.Field;\n     public FieldMatrix<T> preMultiply(final FieldMatrix<T> m) {\n         return m.multiply(this);\n     }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> power(final int p) {\n+        if (p < 0) {\n+            throw new IllegalArgumentException(\"p must be >= 0\");\n+        }\n+        \n+        if (!isSquare()) {\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n+        }\n+        \n+        if (p == 0) {\n+            return MatrixUtils.createFieldIdentityMatrix(this.getField(), this.getRowDimension());\n+        }\n+        \n+        if (p == 1) {\n+            return this.copy();\n+        }\n+\n+        final int power = p - 1;\n+\n+        /*\n+         * Only log_2(p) operations is used by doing as follows:\n+         * 5^214 = 5^128 * 5^64 * 5^16 * 5^4 * 5^2\n+         * \n+         * In general, the same approach is used for A^p.\n+         */\n+\n+        final char[] binaryRepresentation = Integer.toBinaryString(power)\n+                .toCharArray();\n+        final ArrayList<Integer> nonZeroPositions = new ArrayList<Integer>();\n+\n+        for (int i = 0; i < binaryRepresentation.length; ++i) {\n+            if (binaryRepresentation[i] == '1') {\n+                final int pos = binaryRepresentation.length - i - 1;\n+                nonZeroPositions.add(pos);\n+            }\n+        }\n+\n+        ArrayList<FieldMatrix<T>> results = new ArrayList<FieldMatrix<T>>(\n+                binaryRepresentation.length);\n+\n+        results.add(0, this.copy());\n+\n+        for (int i = 1; i < binaryRepresentation.length; ++i) {\n+            final FieldMatrix<T> s = results.get(i - 1);\n+            final FieldMatrix<T> r = s.multiply(s);\n+            results.add(i, r);\n+        }\n+\n+        FieldMatrix<T> result = this.copy();\n+\n+        for (Integer i : nonZeroPositions) {\n+            result = result.multiply(results.get(i));\n+        }\n+\n+        return result;\n+    }\n \n     /** {@inheritDoc} */\n     public T[][] getData() {\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n     FieldMatrix<T> preMultiply(FieldMatrix<T> m);\n \n     /**\n+     * Returns the result multiplying this with itself <code>p</code> times. \n+     * Depending on the type of the field elements, T, \n+     * instability for high powers might occur. \n+     * @param      p raise this to power p\n+     * @return     this^p\n+     * @throws     IllegalArgumentException if p < 0\n+     *             NonSquareMatrixException if the matrix is not square\n+     */\n+    FieldMatrix<T> power(final int p);\n+    \n+    /**\n      * Returns matrix entries as a two-dimensional array.\n      *\n      * @return a 2-dimensional array of entries.\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n        TestUtils.assertEquals(m3.multiply(m4), m5);\n    }\n+\n+    @Test\n+    public void testPower() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        FieldMatrix<Fraction> mPlusInv = new Array2DRowFieldMatrix<Fraction>(testDataPlusInv);\n+        FieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);\n+        \n+        TestUtils.assertEquals(m.power(0), identity);        \n+        TestUtils.assertEquals(mInv.power(0), identity);        \n+        TestUtils.assertEquals(mPlusInv.power(0), identity);\n+        \n+        TestUtils.assertEquals(m.power(1), m);        \n+        TestUtils.assertEquals(mInv.power(1), mInv);        \n+        TestUtils.assertEquals(mPlusInv.power(1), mPlusInv); \n+        \n+        FieldMatrix<Fraction> C1 = m.copy();\n+        FieldMatrix<Fraction> C2 = mInv.copy();\n+        FieldMatrix<Fraction> C3 = mPlusInv.copy();\n+        \n+        // stop at 5 to avoid overflow\n+        for (int i = 2; i <= 5; ++i) {\n+            C1 = C1.multiply(m);\n+            C2 = C2.multiply(mInv);\n+            C3 = C3.multiply(mPlusInv);\n+            \n+            TestUtils.assertEquals(m.power(i), C1);        \n+            TestUtils.assertEquals(mInv.power(i), C2);        \n+            TestUtils.assertEquals(mPlusInv.power(i), C3);            \n+        }\n+        \n+        try {\n+            FieldMatrix<Fraction> mNotSquare = new Array2DRowFieldMatrix<Fraction>(testData2T);\n+            mNotSquare.power(2);\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }\n+        \n+        try {\n+            m.power(-1);\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n \n     /** test trace */\n     @Test", "timestamp": 1300699714, "metainfo": ""}