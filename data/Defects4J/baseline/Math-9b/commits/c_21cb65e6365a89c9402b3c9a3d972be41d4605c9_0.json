{"sha": "21cb65e6365a89c9402b3c9a3d972be41d4605c9", "log": "MATH-707 \"SimpleRealPointChecker\" and \"SimpleVectorialPointChecker\" are replaced by the generic \"SimplePointChecker\" (instantiated using \"PointValuePair\" and \"PointVectorValuePair\", respectively).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n  * @param <PAIR> Type of the (point, objective value) pair.\n  *\n  * @see org.apache.commons.math.optimization.SimpleScalarValueChecker\n- * @see org.apache.commons.math.optimization.SimpleRealPointChecker\n+ * @see org.apache.commons.math.optimization.SimplePointChecker<PointValuePair>\n  *\n  * @version $Id$\n  * @since 3.0\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimplePointChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.Pair;\n+\n+/**\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n+ * only point coordinates.\n+ *\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between each point coordinate are smaller than a threshold\n+ * or if either the absolute difference between the point coordinates are\n+ * smaller than another threshold.\n+ *\n+ * @param <PAIR> Type of the (point, value) pair.\n+ * @param <V> Type of the \"value\" part of the pair (not used by this class).\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class SimplePointChecker<PAIR extends Pair<double[], ? extends Object>>\n+    extends AbstractConvergenceChecker<PAIR> {\n+    /**\n+     * Build an instance with default threshold.\n+     */\n+    public SimplePointChecker() {}\n+\n+    /**\n+     * Build an instance with specified thresholds.\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimplePointChecker(final double relativeThreshold,\n+                              final double absoluteThreshold) {\n+        super(relativeThreshold, absoluteThreshold);\n+    }\n+\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n+     * @return {@code true} if the algorithm has converged.\n+     */\n+    @Override\n+    public boolean converged(final int iteration,\n+                             final PAIR previous,\n+                             final PAIR current) {\n+        final double[] p = previous.getKey();\n+        final double[] c = current.getKey();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double pi = p[i];\n+            final double ci = c[i];\n+            final double difference = FastMath.abs(pi - ci);\n+            final double size = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n+            if (difference > size * getRelativeThreshold() &&\n+                difference > getAbsoluteThreshold()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n  * user should provide a class implementing this interface to allow the optimization\n  * algorithm to stop its search according to the problem at hand.</p>\n  * <p>For convenience, two implementations that fit simple needs are already provided:\n- * {@link SimpleVectorialValueChecker} and {@link SimpleVectorialPointChecker}. The first\n+ * {@link SimpleVectorialValueChecker} and {@link SimplePointChecker<PointVectorValuePair>}. The first\n  * one considers convergence is reached when the objective function value does not\n  * change much anymore, it does not use the point set at all. The second one\n  * considers convergence is reached when the input point set does not change\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapterTest.java\n import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleRealPointChecker;\n+import org.apache.commons.math.optimization.SimplePointChecker;\n import org.junit.Assert;\n import org.junit.Test;\n \n                                                            biQuadratic.getUpper(),\n                                                            1000.0, new double[] { 100.0, 100.0 });\n \n-        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-11, 1.0e-20));\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-11, 1.0e-20));\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n         final PointValuePair optimum\n                                                            biQuadratic.getUpper(),\n                                                            1000.0, new double[] { 100.0, 100.0 });\n \n-        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-10, 1.0e-20));\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-10, 1.0e-20));\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n         final PointValuePair optimum", "timestamp": 1329089391, "metainfo": ""}