{"sha": "154551fe96b952a6ccb3709b12b194f76e8f1dc1", "log": "MATH-311.  Changed probability calculations for Binomial, Poisson, and Hypergeometric distributions to use Catherine Loader's saddle point approximations  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n \n \n /**\n  * The default implementation of {@link BinomialDistribution}.\n- *\n- * @version $Revision$ $Date$\n+ * \n+ * @version $Revision$ $Date: 2009-09-05 12:36:48 -0500 (Sat, 05 Sep\n+ *          2009) $\n  */\n-public class BinomialDistributionImpl\n-    extends AbstractIntegerDistribution\n-    implements BinomialDistribution, Serializable {\n+public class BinomialDistributionImpl extends AbstractIntegerDistribution\n+        implements BinomialDistribution, Serializable {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 6751309484392813623L;\n     /**\n      * Create a binomial distribution with the given number of trials and\n      * probability of success.\n+     * \n      * @param trials the number of trials.\n      * @param p the probability of success.\n      */\n \n     /**\n      * Access the number of trials for this distribution.\n+     * \n      * @return the number of trials.\n      */\n     public int getNumberOfTrials() {\n \n     /**\n      * Access the probability of success for this distribution.\n+     * \n      * @return the probability of success.\n      */\n     public double getProbabilityOfSuccess() {\n \n     /**\n      * Change the number of trials for this distribution.\n+     * \n      * @param trials the new number of trials.\n      * @throws IllegalArgumentException if <code>trials</code> is not a valid\n-     *         number of trials.\n+     *             number of trials.\n      */\n     public void setNumberOfTrials(int trials) {\n         if (trials < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"number of trials must be non-negative ({0})\", trials);\n+                    \"number of trials must be non-negative ({0})\", trials);\n         }\n         numberOfTrials = trials;\n     }\n \n     /**\n      * Change the probability of success for this distribution.\n+     * \n      * @param p the new probability of success.\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     *             probability.\n      */\n     public void setProbabilityOfSuccess(double p) {\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                    \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         }\n         probabilityOfSuccess = p;\n     }\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     *\n+     * \n      * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n+     *         <code>p</code>\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     *\n+     * \n      * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n+     *         <code>p</code>\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n \n     /**\n      * For this distribution, X, this method returns P(X &le; x).\n+     * \n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * @throws MathException if the cumulative probability can not be computed\n+     *             due to convergence or other numerical errors.\n      */\n     @Override\n     public double cumulativeProbability(int x) throws MathException {\n         } else if (x >= getNumberOfTrials()) {\n             ret = 1.0;\n         } else {\n-            ret =\n-                1.0 - Beta.regularizedBeta(\n-                        getProbabilityOfSuccess(),\n-                        x + 1.0,\n-                        getNumberOfTrials() - x);\n+            ret = 1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),\n+                    x + 1.0, getNumberOfTrials() - x);\n         }\n         return ret;\n     }\n \n     /**\n      * For this distribution, X, this method returns P(X = x).\n-     *\n+     * \n      * @param x the value at which the PMF is evaluated.\n      * @return PMF for this distribution.\n      */\n         if (x < 0 || x > getNumberOfTrials()) {\n             ret = 0.0;\n         } else {\n-            ret = MathUtils.binomialCoefficientDouble(\n-                    getNumberOfTrials(), x) *\n-                  Math.pow(getProbabilityOfSuccess(), x) *\n-                  Math.pow(1.0 - getProbabilityOfSuccess(),\n-                        getNumberOfTrials() - x);\n+            ret = Math.exp(SaddlePointExpansion.logBinomialProbability(x,\n+                    numberOfTrials, probabilityOfSuccess,\n+                    1.0 - probabilityOfSuccess));\n         }\n         return ret;\n     }\n \n     /**\n-     * For this distribution, X, this method returns the largest x, such\n-     * that P(X &le; x) &le; <code>p</code>.\n+     * For this distribution, X, this method returns the largest x, such that\n+     * P(X &le; x) &le; <code>p</code>.\n      * <p>\n      * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code> for\n-     * p=1.</p>\n-     *\n+     * p=1.\n+     * </p>\n+     * \n      * @param p the desired probability\n      * @return the largest x such that P(X &le; x) <= p\n      * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     *             computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if p < 0 or p > 1\n      */\n     @Override\n-    public int inverseCumulativeProbability(final double p) throws MathException {\n+    public int inverseCumulativeProbability(final double p)\n+            throws MathException {\n         // handle extreme values explicitly\n         if (p == 0) {\n             return -1;\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n \n package org.apache.commons.math.distribution;\n \n /**\n  * The default implementation of {@link HypergeometricDistribution}.\n- *\n- * @version $Revision$ $Date$\n+ * \n+ * @version $Revision$ $Date: 2009-09-05 12:36:48 -0500 (Sat, 05 Sep\n+ *          2009) $\n  */\n public class HypergeometricDistributionImpl extends AbstractIntegerDistribution\n-    implements HypergeometricDistribution, Serializable\n-{\n+        implements HypergeometricDistribution, Serializable {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -436928820673516179L;\n     /**\n      * Construct a new hypergeometric distribution with the given the population\n      * size, the number of successes in the population, and the sample size.\n+     * \n      * @param populationSize the population size.\n      * @param numberOfSuccesses number of successes in the population.\n      * @param sampleSize the sample size.\n      */\n     public HypergeometricDistributionImpl(int populationSize,\n-        int numberOfSuccesses, int sampleSize) {\n+            int numberOfSuccesses, int sampleSize) {\n         super();\n         if (numberOfSuccesses > populationSize) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                \"number of successes ({0}) must be less than or equal to population size ({1})\",\n-                numberOfSuccesses, populationSize);\n+            throw MathRuntimeException\n+                    .createIllegalArgumentException(\n+                            \"number of successes ({0}) must be less than or equal to population size ({1})\",\n+                            numberOfSuccesses, populationSize);\n         }\n         if (sampleSize > populationSize) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  \"sample size ({0}) must be less than or equal to population size ({1})\",\n-                  sampleSize, populationSize);\n+            throw MathRuntimeException\n+                    .createIllegalArgumentException(\n+                            \"sample size ({0}) must be less than or equal to population size ({1})\",\n+                            sampleSize, populationSize);\n         }\n         setPopulationSize(populationSize);\n         setSampleSize(sampleSize);\n \n     /**\n      * For this distribution, X, this method returns P(X &le; x).\n+     * \n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n      */\n         int[] domain = getDomain(n, m, k);\n         if (x < domain[0]) {\n             ret = 0.0;\n-        } else if(x >= domain[1]) {\n+        } else if (x >= domain[1]) {\n             ret = 1.0;\n         } else {\n             ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);\n \n     /**\n      * Return the domain for the given hypergeometric distribution parameters.\n+     * \n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n      * @return a two element array containing the lower and upper bounds of the\n      *         hypergeometric distribution.\n      */\n-    private int[] getDomain(int n, int m, int k){\n-        return new int[]{\n-            getLowerDomain(n, m, k),\n-            getUpperDomain(m, k)\n-        };\n+    private int[] getDomain(int n, int m, int k) {\n+        return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n     }\n \n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     *\n+     * \n      * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n+     *         <code>p</code>\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n         return getLowerDomain(getPopulationSize(), getNumberOfSuccesses(),\n-            getSampleSize());\n+                getSampleSize());\n     }\n \n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     *\n+     * \n      * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n+     *         <code>p</code>\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n     /**\n      * Return the lowest domain value for the given hypergeometric distribution\n      * parameters.\n+     * \n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n \n     /**\n      * Access the number of successes.\n+     * \n      * @return the number of successes.\n      */\n     public int getNumberOfSuccesses() {\n \n     /**\n      * Access the population size.\n+     * \n      * @return the population size.\n      */\n     public int getPopulationSize() {\n \n     /**\n      * Access the sample size.\n+     * \n      * @return the sample size.\n      */\n     public int getSampleSize() {\n     /**\n      * Return the highest domain value for the given hypergeometric distribution\n      * parameters.\n+     * \n      * @param m number of successes in the population.\n      * @param k the sample size.\n      * @return the highest domain value of the hypergeometric distribution.\n      */\n-    private int getUpperDomain(int m, int k){\n+    private int getUpperDomain(int m, int k) {\n         return Math.min(k, m);\n     }\n \n     /**\n      * For this distribution, X, this method returns P(X = x).\n-     *\n+     * \n      * @param x the value at which the PMF is evaluated.\n      * @return PMF for this distribution.\n      */\n     public double probability(int x) {\n+        double ret;\n+\n+        int m = getPopulationSize();\n+        int s = getNumberOfSuccesses();\n+        int f = m - s;\n+        int k = getSampleSize();\n+\n+        int[] domain = getDomain(m, s, k);\n+        if (x < domain[0] || x > domain[1]) {\n+            ret = 0.0;\n+        } else {\n+            double p = (double) sampleSize / (double) m;\n+            double q = (double) (m - sampleSize) / (double) m;\n+            double p1 = SaddlePointExpansion.logBinomialProbability(x,\n+                    numberOfSuccesses, p, q);\n+            double p2 = SaddlePointExpansion.logBinomialProbability(sampleSize\n+                    - x, f, p, q);\n+            double p3 = SaddlePointExpansion.logBinomialProbability(sampleSize,\n+                    m, p, q);\n+            ret = Math.exp(p1 + p2 - p3);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * For the distribution, X, defined by the given hypergeometric distribution\n+     * parameters, this method returns P(X = x).\n+     * \n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @param x the value at which the PMF is evaluated.\n+     * @return PMF for the distribution.\n+     */\n+    private double probability(int n, int m, int k, int x) {\n+        return Math.exp(MathUtils.binomialCoefficientLog(m, x)\n+                + MathUtils.binomialCoefficientLog(n - m, k - x)\n+                - MathUtils.binomialCoefficientLog(n, k));\n+    }\n+\n+    /**\n+     * Modify the number of successes.\n+     * \n+     * @param num the new number of successes.\n+     * @throws IllegalArgumentException if <code>num</code> is negative.\n+     */\n+    public void setNumberOfSuccesses(int num) {\n+        if (num < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"number of successes must be non-negative ({0})\", num);\n+        }\n+        numberOfSuccesses = num;\n+    }\n+\n+    /**\n+     * Modify the population size.\n+     * \n+     * @param size the new population size.\n+     * @throws IllegalArgumentException if <code>size</code> is not positive.\n+     */\n+    public void setPopulationSize(int size) {\n+        if (size <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"population size must be positive ({0})\", size);\n+        }\n+        populationSize = size;\n+    }\n+\n+    /**\n+     * Modify the sample size.\n+     * \n+     * @param size the new sample size.\n+     * @throws IllegalArgumentException if <code>size</code> is negative.\n+     */\n+    public void setSampleSize(int size) {\n+        if (size < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"sample size must be positive ({0})\", size);\n+        }\n+        sampleSize = size;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &ge; x).\n+     * \n+     * @param x the value at which the CDF is evaluated.\n+     * @return upper tail CDF for this distribution.\n+     * @since 1.1\n+     */\n+    public double upperCumulativeProbability(int x) {\n         double ret;\n \n         int n = getPopulationSize();\n         int k = getSampleSize();\n \n         int[] domain = getDomain(n, m, k);\n-        if(x < domain[0] || x > domain[1]){\n-            ret = 0.0;\n-        } else {\n-            ret = probability(n, m, k, x);\n-        }\n-\n-        return ret;\n-    }\n-\n-    /**\n-     * For the distribution, X, defined by the given hypergeometric distribution\n-     * parameters, this method returns P(X = x).\n-     *\n-     * @param n the population size.\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n-     * @param x the value at which the PMF is evaluated.\n-     * @return PMF for the distribution.\n-     */\n-    private double probability(int n, int m, int k, int x) {\n-        return Math.exp(MathUtils.binomialCoefficientLog(m, x) +\n-            MathUtils.binomialCoefficientLog(n - m, k - x) -\n-            MathUtils.binomialCoefficientLog(n, k));\n-    }\n-\n-    /**\n-     * Modify the number of successes.\n-     * @param num the new number of successes.\n-     * @throws IllegalArgumentException if <code>num</code> is negative.\n-     */\n-    public void setNumberOfSuccesses(int num) {\n-        if(num < 0){\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  \"number of successes must be non-negative ({0})\",\n-                  num);\n-        }\n-        numberOfSuccesses = num;\n-    }\n-\n-    /**\n-     * Modify the population size.\n-     * @param size the new population size.\n-     * @throws IllegalArgumentException if <code>size</code> is not positive.\n-     */\n-    public void setPopulationSize(int size) {\n-        if(size <= 0){\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  \"population size must be positive ({0})\",\n-                  size);\n-        }\n-        populationSize = size;\n-    }\n-\n-    /**\n-     * Modify the sample size.\n-     * @param size the new sample size.\n-     * @throws IllegalArgumentException if <code>size</code> is negative.\n-     */\n-    public void setSampleSize(int size) {\n-        if (size < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  \"sample size must be positive ({0})\",\n-                  size);\n-        }\n-        sampleSize = size;\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(X &ge; x).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return upper tail CDF for this distribution.\n-     * @since 1.1\n-     */\n-    public double upperCumulativeProbability(int x) {\n-        double ret;\n-\n-        int n = getPopulationSize();\n-        int m = getNumberOfSuccesses();\n-        int k = getSampleSize();\n-\n-        int[] domain = getDomain(n, m, k);\n         if (x < domain[0]) {\n             ret = 1.0;\n-        } else if(x > domain[1]) {\n+        } else if (x > domain[1]) {\n             ret = 0.0;\n         } else {\n             ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(x0 &le; X &le; x1).  This\n+     * For this distribution, X, this method returns P(x0 &le; X &le; x1). This\n      * probability is computed by summing the point probabilities for the values\n      * x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx.\n+     * \n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n      * @param dx the direction of summation. 1 indicates summing from x0 to x1.\n-     *           0 indicates summing from x1 to x0.\n+     *            0 indicates summing from x1 to x0.\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n      * @return P(x0 &le; X &le; x1).\n      */\n-    private double innerCumulativeProbability(\n-        int x0, int x1, int dx, int n, int m, int k)\n-    {\n+    private double innerCumulativeProbability(int x0, int x1, int dx, int n,\n+            int m, int k) {\n         double ret = probability(n, m, k, x0);\n         while (x0 != x1) {\n             x0 += dx;\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n \n \n /**\n  * Implementation for the {@link PoissonDistribution}.\n- *\n- * @version $Revision$ $Date$\n+ * \n+ * @version $Revision$ $Date: 2009-09-05 12:36:48 -0500 (Sat, 05 Sep\n+ *          2009) $\n  */\n public class PoissonDistributionImpl extends AbstractIntegerDistribution\n         implements PoissonDistribution, Serializable {\n     private double mean;\n \n     /**\n-     * Create a new Poisson distribution with the given the mean.\n-     * The mean value must be positive; otherwise an\n-     * <code>IllegalArgument</code> is thrown.\n-     *\n+     * Create a new Poisson distribution with the given the mean. The mean value\n+     * must be positive; otherwise an <code>IllegalArgument</code> is thrown.\n+     * \n      * @param p the Poisson mean\n      * @throws IllegalArgumentException if p &le; 0\n      */\n     }\n \n     /**\n-     * Create a new Poisson distribution with the given the mean.\n-     * The mean value must be positive; otherwise an\n-     * <code>IllegalArgument</code> is thrown.\n-     *\n+     * Create a new Poisson distribution with the given the mean. The mean value\n+     * must be positive; otherwise an <code>IllegalArgument</code> is thrown.\n+     * \n      * @param p the Poisson mean\n      * @param z a normal distribution used to compute normal approximations.\n      * @throws IllegalArgumentException if p &le; 0\n \n     /**\n      * Get the Poisson mean for the distribution.\n-     *\n+     * \n      * @return the Poisson mean for the distribution.\n      */\n     public double getMean() {\n     }\n \n     /**\n-     * Set the Poisson mean for the distribution.\n-     * The mean value must be positive; otherwise an\n-     * <code>IllegalArgument</code> is thrown.\n-     *\n+     * Set the Poisson mean for the distribution. The mean value must be\n+     * positive; otherwise an <code>IllegalArgument</code> is thrown.\n+     * \n      * @param p the Poisson mean value\n      * @throws IllegalArgumentException if p &le; 0\n      */\n     public void setMean(double p) {\n         if (p <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"the Poisson mean must be positive ({0})\",\n-                  p);\n+                    \"the Poisson mean must be positive ({0})\", p);\n         }\n         this.mean = p;\n         normal.setMean(p);\n \n     /**\n      * The probability mass function P(X = x) for a Poisson distribution.\n-     *\n-     * @param x the value at which the probability density function is evaluated.\n+     * \n+     * @param x the value at which the probability density function is\n+     *            evaluated.\n      * @return the value of the probability mass function at x\n      */\n     public double probability(int x) {\n+        double ret;\n         if (x < 0 || x == Integer.MAX_VALUE) {\n-            return 0;\n+            ret = 0.0;\n+        } else if (x == 0) {\n+            ret = Math.exp(-mean);\n+        } else {\n+            ret = Math.exp(-SaddlePointExpansion.getStirlingError(x)\n+                    - SaddlePointExpansion.getDeviancePart(x, mean))\n+                    / Math.sqrt(2.0 * Math.PI * x); // TODO make MathUtils.PI\n+                                                    // public\n         }\n-        return Math.pow(getMean(), x) /\n-            MathUtils.factorialDouble(x) * Math.exp(-mean);\n+        return ret;\n     }\n \n     /**\n-     * The probability distribution function P(X <= x) for a Poisson distribution.\n-     *\n+     * The probability distribution function P(X <= x) for a Poisson\n+     * distribution.\n+     * \n      * @param x the value at which the PDF is evaluated.\n      * @return Poisson distribution function evaluated at x\n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * @throws MathException if the cumulative probability can not be computed\n+     *             due to convergence or other numerical errors.\n      */\n     @Override\n     public double cumulativeProbability(int x) throws MathException {\n         if (x == Integer.MAX_VALUE) {\n             return 1;\n         }\n-        return Gamma.regularizedGammaQ((double)x + 1, mean,\n-                1E-12, Integer.MAX_VALUE);\n+        return Gamma.regularizedGammaQ((double) x + 1, mean, 1E-12,\n+                Integer.MAX_VALUE);\n     }\n \n     /**\n      * Calculates the Poisson distribution function using a normal\n-     * approximation.  The <code>N(mean, sqrt(mean))</code>\n-     * distribution is used to approximate the Poisson distribution.\n+     * approximation. The <code>N(mean, sqrt(mean))</code> distribution is used\n+     * to approximate the Poisson distribution.\n      * <p>\n      * The computation uses \"half-correction\" -- evaluating the normal\n-     * distribution function at <code>x + 0.5</code></p>\n-     *\n+     * distribution function at <code>x + 0.5</code>\n+     * </p>\n+     * \n      * @param x the upper bound, inclusive\n-     * @return the distribution function value calculated using a normal approximation\n-     * @throws MathException if an error occurs computing the normal approximation\n+     * @return the distribution function value calculated using a normal\n+     *         approximation\n+     * @throws MathException if an error occurs computing the normal\n+     *             approximation\n      */\n     public double normalApproximateProbability(int x) throws MathException {\n         // calculate the probability using half-correction\n \n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n+     * bracket a CDF root. This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n+     * \n      * @param p the desired probability for the critical value\n      * @return domain lower bound\n      */\n \n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n+     * bracket a CDF root. This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n+     * \n      * @param p the desired probability for the critical value\n      * @return domain upper bound\n      */\n     }\n \n     /**\n-     * Modify the normal distribution used to compute normal approximations.\n-     * The caller is responsible for insuring the normal distribution has the\n-     * proper parameter settings.\n+     * Modify the normal distribution used to compute normal approximations. The\n+     * caller is responsible for insuring the normal distribution has the proper\n+     * parameter settings.\n+     * \n      * @param value the new distribution\n      * @since 1.2\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/SaddlePointExpansion.java\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.special.Gamma;\n+\n+/**\n+ * <p>\n+ * Utility class used by various distributions to accurately compute their\n+ * respective probability mass functions. The implementation for this class is\n+ * based on the Catherine Loader's <a target=\"_blank\"\n+ * href=\"http://www.herine.net/stat/software/dbinom.html\">dbinom</a> routines.\n+ * </p>\n+ * <p>\n+ * This class is not intended to be called directly.\n+ * </p>\n+ * <p>\n+ * References:\n+ * <ol>\n+ * <li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\n+ * Probabilities.\". <a target=\"_blank\"\n+ * href=\"http://www.herine.net/stat/papers/dbinom.pdf\">\n+ * http://www.herine.net/stat/papers/dbinom.pdf</a></li>\n+ * </ol>\n+ * </p>\n+ * \n+ * @since 1.2\n+ * @version $Revision: 1.3 $ $Date: 2007/11/18 23:51:21 $\n+ */\n+final class SaddlePointExpansion {\n+\n+    /** 2 &#960;. */\n+    private static double PI_2 = 2.0 * Math.PI;\n+\n+    /** 1/2 * log(2 &#960;). */\n+    private static double HALF_LOG_2_PI = 0.5 * Math.log(PI_2);\n+\n+    /** exact striling expansion error for certain values. */\n+    private static final double[] EXACT_STIRLING_ERRORS = { 0.0, /* 0.0 */\n+    0.1534264097200273452913848, /* 0.5 */\n+    0.0810614667953272582196702, /* 1.0 */\n+    0.0548141210519176538961390, /* 1.5 */\n+    0.0413406959554092940938221, /* 2.0 */\n+    0.03316287351993628748511048, /* 2.5 */\n+    0.02767792568499833914878929, /* 3.0 */\n+    0.02374616365629749597132920, /* 3.5 */\n+    0.02079067210376509311152277, /* 4.0 */\n+    0.01848845053267318523077934, /* 4.5 */\n+    0.01664469118982119216319487, /* 5.0 */\n+    0.01513497322191737887351255, /* 5.5 */\n+    0.01387612882307074799874573, /* 6.0 */\n+    0.01281046524292022692424986, /* 6.5 */\n+    0.01189670994589177009505572, /* 7.0 */\n+    0.01110455975820691732662991, /* 7.5 */\n+    0.010411265261972096497478567, /* 8.0 */\n+    0.009799416126158803298389475, /* 8.5 */\n+    0.009255462182712732917728637, /* 9.0 */\n+    0.008768700134139385462952823, /* 9.5 */\n+    0.008330563433362871256469318, /* 10.0 */\n+    0.007934114564314020547248100, /* 10.5 */\n+    0.007573675487951840794972024, /* 11.0 */\n+    0.007244554301320383179543912, /* 11.5 */\n+    0.006942840107209529865664152, /* 12.0 */\n+    0.006665247032707682442354394, /* 12.5 */\n+    0.006408994188004207068439631, /* 13.0 */\n+    0.006171712263039457647532867, /* 13.5 */\n+    0.005951370112758847735624416, /* 14.0 */\n+    0.005746216513010115682023589, /* 14.5 */\n+    0.005554733551962801371038690 /* 15.0 */\n+    };\n+\n+    /**\n+     * Default constructor.\n+     */\n+    private SaddlePointExpansion() {\n+        super();\n+    }\n+\n+    /**\n+     * Compute the error of Stirling's series at the given value.\n+     * <p>\n+     * References:\n+     * <ol>\n+     * <li>Eric W. Weisstein. \"Stirling's Series.\" From MathWorld--A Wolfram Web\n+     * Resource. <a target=\"_blank\"\n+     * href=\"http://mathworld.wolfram.com/StirlingsSeries.html\">\n+     * http://mathworld.wolfram.com/StirlingsSeries.html</a></li>\n+     * </ol>\n+     * </p>\n+     * \n+     * @param z the value.\n+     * @return the Striling's series error.\n+     */\n+    static double getStirlingError(double z) {\n+        double ret;\n+        if (z < 15.0) {\n+            double z2 = 2.0 * z;\n+            if (Math.floor(z2) == z2) {\n+                ret = EXACT_STIRLING_ERRORS[(int) z2];\n+            } else {\n+                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * Math.log(z) + z\n+                        - HALF_LOG_2_PI;\n+            }\n+        } else {\n+            double z2 = z * z;\n+            ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2)\n+                    / z2)\n+                    / z2)\n+                    / z2)\n+                    / z;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * A part of the deviance portion of the saddle point approximation.\n+     * <p>\n+     * References:\n+     * <ol>\n+     * <li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\n+     * Probabilities.\". <a target=\"_blank\"\n+     * href=\"http://www.herine.net/stat/papers/dbinom.pdf\">\n+     * http://www.herine.net/stat/papers/dbinom.pdf</a></li>\n+     * </ol>\n+     * </p>\n+     * \n+     * @param x the x value.\n+     * @param mu the average.\n+     * @return a part of the deviance.\n+     */\n+    static double getDeviancePart(double x, double mu) {\n+        double ret;\n+        if (Math.abs(x - mu) < 0.1 * (x + mu)) {\n+            double d = (x - mu);\n+            double v = d / (x + mu);\n+            double s1 = v * d;\n+            double s = Double.NaN;\n+            double ej = 2.0 * x * v;\n+            v = v * v;\n+            int j = 1;\n+            while (s1 != s) {\n+                s = s1;\n+                ej *= v;\n+                s1 = s + ej / ((j * 2) + 1);\n+                ++j;\n+            }\n+            ret = s1;\n+        } else {\n+            ret = x * Math.log(x / mu) + mu - x;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Compute the PMF for a binomial distribution using the saddle point\n+     * expansion.\n+     * \n+     * @param x the value at which the probability is evaluated.\n+     * @param n the number of trials.\n+     * @param p the probability of success.\n+     * @param q the probability of failure (1 - p).\n+     * @return log(p(x)).\n+     */\n+    static double logBinomialProbability(int x, int n, double p, double q) {\n+        double ret;\n+        if (x == 0) {\n+            if (p < 0.1) {\n+                ret = -getDeviancePart(n, n * q) - n * p;\n+            } else {\n+                ret = n * Math.log(q);\n+            }\n+        } else if (x == n) {\n+            if (q < 0.1) {\n+                ret = -getDeviancePart(n, n * p) - n * q;\n+            } else {\n+                ret = n * Math.log(p);\n+            }\n+        } else {\n+            ret = getStirlingError(n) - getStirlingError(x)\n+                    - getStirlingError(n - x) - getDeviancePart(x, n * p)\n+                    - getDeviancePart(n - x, n * q);\n+            double f = (PI_2 * x * (n - x)) / n;\n+            ret = -0.5 * Math.log(f) + ret;\n+        }\n+        return ret;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n \n /**\n- * Test cases for BinomialDistribution.\n- * Extends IntegerDistributionAbstractTest.  See class javadoc for\n- * IntegerDistributionAbstractTest for details.\n- *\n- * @version $Revision$ $Date$\n+ * Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest.\n+ * See class javadoc for IntegerDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date: 2009-09-05 12:36:48 -0500 (Sat, 05 Sep\n+ *          2009) $\n  */\n public class BinomialDistributionTest extends IntegerDistributionAbstractTest {\n \n     /**\n      * Constructor for BinomialDistributionTest.\n+     * \n      * @param name\n      */\n     public BinomialDistributionTest(String name) {\n         super(name);\n     }\n \n-    //-------------- Implementations for abstract methods -----------------------\n+    // -------------- Implementations for abstract methods\n+    // -----------------------\n \n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new BinomialDistributionImpl(10,0.70);\n+        return new BinomialDistributionImpl(10, 0.70);\n     }\n \n     /** Creates the default probability density test input values */\n     @Override\n     public int[] makeDensityTestPoints() {\n-        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };\n     }\n \n     /** Creates the default probability density test expected values */\n     @Override\n     public double[] makeDensityTestValues() {\n-        return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d,\n-                0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};\n+        return new double[] { 0d, 0.0000059049d, 0.000137781d, 0.0014467d,\n+                0.00900169d, 0.0367569d, 0.102919d, 0.200121d, 0.266828d,\n+                0.233474d, 0.121061d, 0.0282475d, 0d };\n     }\n \n     /** Creates the default cumulative probability density test input values */\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,\n-                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};\n-        }\n+        return new double[] { 0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,\n+                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d };\n+    }\n \n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n-        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d,1};\n-        }\n+        return new double[] { 0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d,\n+                0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1 };\n+    }\n \n-    /** Creates the default inverse cumulative probability density test expected values */\n+    /**\n+     * Creates the default inverse cumulative probability density test expected\n+     * values\n+     */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n-        return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};\n+        return new int[] { -1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE };\n     }\n \n-    //----------------- Additional test cases ---------------------------------\n+    // ----------------- Additional test cases ---------------------------------\n \n-    /** Test degenerate case p = 0   */\n+    /** Test degenerate case p = 0 */\n     public void testDegenerate0() throws Exception {\n-        setDistribution(new BinomialDistributionImpl(5,0.0d));\n-        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });\n-        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});\n-        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});\n-        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});\n-        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {-1, -1});\n+        setDistribution(new BinomialDistributionImpl(5, 0.0d));\n+        setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });\n+        setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d });\n+        setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 });\n+        setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d });\n+        setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });\n+        setInverseCumulativeTestValues(new int[] { -1, -1 });\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n     }\n \n-    /** Test degenerate case p = 1   */\n+    /** Test degenerate case p = 1 */\n     public void testDegenerate1() throws Exception {\n-        setDistribution(new BinomialDistributionImpl(5,1.0d));\n-        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n-        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});\n-        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});\n-        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d});\n-        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {4, 4});\n+        setDistribution(new BinomialDistributionImpl(5, 1.0d));\n+        setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });\n+        setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d });\n+        setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });\n+        setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d });\n+        setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });\n+        setInverseCumulativeTestValues(new int[] { 4, 4 });\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();", "timestamp": 1256759961, "metainfo": ""}