{"sha": "fcabfb5a821e31e42aa15740ebc7d740e689819f", "log": "Resolved multiple problems leading to inaccuracy and/or failure to compute Normal, ChiSquare and  Poisson probabilities, Erf and Gamma functions.  JIRA: MATH-282 JIRA: MATH-301  Summary of changes:  * BrentSolver has been changed to expose its configured absolute accuracy. This solver is used by   the default inverse cum implementation in AbstractContinuousDistribution and the hard-coded setting   (1E-6) was limiting accuracy in inverse cumulative probability estimates. AbstractContinuousDistribution   was changed to allow distributions to set this value and NormalDistributionImpl was changed to set it to   1E-9 by default and allow users to configure it via a constructor argument.  * AbstractContinuousDistribution and AbstractIntegerDistribution inverseCumulativeProbability methods   have been modified to check for NaN values returned by cumulativeProbability and throw MathExceptions   when this happens.  * The criteria for choosing between the Lanczos series and continued fraction expansion when computing   regularized gamma functions has been changed to (x >= a + 1). When using the series approximation   (regularizedGammaP), divergence to infinity is checked and when this happens, 1 is returned.  * When scaling continued fractions to (try to) avoid divergence to infinity, the larger of a and b is   used as a scale factor and the attempt to scale is repeated up to 5 times, using successive powers   of the scale factor.  * The maximum number of iterations used in estimating cumulative probabilities for PoissonDistributionImpl   has been decreased from Integer.MAX_VALUE to 10000000 and made configurable.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n       \"Divergence de fraction continue \\u00e0 l''infini pour la valeur {0}\" },\n     { \"Continued fraction convergents failed to converge for value {0}\",\n       \"\\u00c9chec de convergence de fraction continue pour la valeur {0}\" },\n+    { \"Continued fraction diverged to NaN for value {0}\",\n+      \"Divergence de fraction continue \\u00e0 NaN pour la valeur {0}\"},\n \n     // org.apache.commons.math.util.DefaultTransformer\n     { \"Conversion Exception in Transformation, Object is null\",\n      \"la borne inf\\u00e9rieure ({0}) devrait \\u00eatre inf\\u00e9rieure \" +\n      \"ou \\u00e9gale \\u00e0 la borne sup\\u00e9rieure ({1})\" },\n \n+   // org.apache.commons.math.distribution.AbstractContinuousDistribution\n+   { \"Cumulative probability function returned NaN for argument {0} p = {1}\",\n+     \"Fonction de probabilit\\u00e9 cumulative retourn\\u00e9 NaN \\u00e0 l''argument de {0} p = {1}\" },\n+\n+   // org.apache.commons.math.distribution.AbstractIntegerDistribution\n+   { \"Discrete cumulative probability function returned NaN for argument {0}\",\n+     \"Discr\\u00e8tes fonction de probabilit\\u00e9 cumulative retourn\\u00e9 NaN \\u00e0 l''argument de {0}\" },\n+\n+\n    // org.apache.commons.math.distribution.BinomialDistributionImpl\n    { \"number of trials must be non-negative ({0})\",\n      \"le nombre d''essais ne doit pas \\u00eatre n\\u00e9gatif ({0})\" },\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n \n+    /** Default absolute accuracy */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1E-6;\n+\n+    /** Default maximum number of iterations */\n+    public static final int DEFAULT_MAXIMUM_ITERATIONS = 100;\n+\n     /** Error message for non-bracketing interval. */\n     private static final String NON_BRACKETING_MESSAGE =\n         \"function values at endpoints do not have different signs.  \" +\n      */\n     @Deprecated\n     public BrentSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n-     * Construct a solver.\n+        super(f, DEFAULT_MAXIMUM_ITERATIONS, DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Construct a solver with default properties.\n      */\n     public BrentSolver() {\n-        super(100, 1E-6);\n+        super(DEFAULT_MAXIMUM_ITERATIONS, DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Construct a solver with the given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy lower bound for absolute accuracy of solutions returned by the solver\n+     */\n+    public BrentSolver(double absoluteAccuracy) {\n+        super(DEFAULT_MAXIMUM_ITERATIONS, absoluteAccuracy);\n+    }\n+\n+    /**\n+     * Contstruct a solver with the given maximum iterations and absolute accuracy.\n+     *\n+     * @param maximumIterations maximum number of iterations\n+     * @param absoluteAccuracy lower bound for absolute accuracy of solutions returned by the solver\n+     */\n+    public BrentSolver(int maximumIterations, double absoluteAccuracy) {\n+        super(maximumIterations, absoluteAccuracy);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n \n /**\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n+\n+    /** Solver absolute accuracy for inverse cum computation */\n+    private double solverAbsoluteAccuracy = BrentSolver.DEFAULT_ABSOLUTE_ACCURACY;\n \n     /**\n      * Default constructor.\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n             public double value(double x) throws FunctionEvaluationException {\n+                double ret = Double.NaN;\n                 try {\n-                    return cumulativeProbability(x) - p;\n+                    ret = cumulativeProbability(x) - p;\n                 } catch (MathException ex) {\n                     throw new FunctionEvaluationException(ex, x, ex.getPattern(), ex.getArguments());\n                 }\n+                if (Double.isNaN(ret)) {\n+                    throw new FunctionEvaluationException(x,\n+                        \"Cumulative probability function returned NaN for argument {0} p = {1}\", x, p);\n+                }\n+                return ret;\n             }\n         };\n \n              * Check domain endpoints to see if one gives value that is within\n              * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n              * case if density has bounded support and p is 0 or 1).\n-             *\n-             * TODO: expose the default solver, defaultAbsoluteAccuracy as\n-             * a constant.\n              */\n             if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                 return lowerBound;\n \n         // find root\n         double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n-                bracket[0],bracket[1]);\n+                // override getSolverAbsoluteAccuracy() to use a Brent solver with\n+                // absolute accuracy different from BrentSolver default\n+                bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n         return root;\n     }\n \n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     protected abstract double getDomainUpperBound(double p);\n+\n+    /**\n+     * Returns the solver absolute accuracy for inverse cum computation.\n+     *\n+     * @return the maximum absolute error in inverse cumulative probability estimates\n+     */\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n \n         double pm;\n         while (x0 < x1) {\n             int xm = x0 + (x1 - x0) / 2;\n-            pm = cumulativeProbability(xm);\n+            pm = checkedCumulativeProbability(xm);\n             if (pm > p) {\n                 // update x1\n                 if (xm == x1) {\n         }\n \n         // insure x0 is the correct critical point\n-        pm = cumulativeProbability(x0);\n+        pm = checkedCumulativeProbability(x0);\n         while (pm > p) {\n             --x0;\n-            pm = cumulativeProbability(x0);\n+            pm = checkedCumulativeProbability(x0);\n         }\n \n         return x0;\n+    }\n+\n+    /**\n+     * Computes the cumulative probablity function and checks for NaN values returned.\n+     * Throws MathException if the value is NaN. Wraps and rethrows any MathException encountered\n+     * evaluating the cumulative probability function in a FunctionEvaluationException. Throws\n+     * FunctionEvaluationException of the cumulative probability function returns NaN.\n+     *\n+     * @param argument input value\n+     * @return cumulative probability\n+     * @throws FunctionEvaluationException if a MathException occurs computing the cumulative probability\n+     */\n+    private double checkedCumulativeProbability(int argument) throws FunctionEvaluationException {\n+        double result = Double.NaN;\n+        try {\n+            result = cumulativeProbability(argument);\n+        } catch (MathException ex) {\n+            throw new FunctionEvaluationException(ex, argument, ex.getPattern(), ex.getArguments());\n+        }\n+        if (Double.isNaN(result)) {\n+            throw new FunctionEvaluationException(argument,\n+                \"Discrete cumulative probability function returned NaN for argument {0}\", argument);\n+        }\n+        return result;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n public class NormalDistributionImpl extends AbstractContinuousDistribution\n         implements NormalDistribution, Serializable {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n \n     /** The standard deviation of this distribution. */\n     private double standardDeviation = 1;\n+\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a normal distribution using the given mean and standard deviation.\n      * @param sd standard deviation for this distribution\n      */\n     public NormalDistributionImpl(double mean, double sd){\n+        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a normal distribution using the given mean, standard deviation and\n+     * inverse cumulative distribution accuracy.\n+     *\n+     * @param mean mean for this distribution\n+     * @param sd standard deviation for this distribution\n+     * @param inverseCumAccuracy inverse cumulative probability accuracy\n+     */\n+    public NormalDistributionImpl(double mean, double sd, double inverseCumAccuracy) {\n         super();\n-        setMean(mean);\n-        setStandardDeviation(sd);\n+        this.mean = mean;\n+        this.standardDeviation = sd;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n     }\n \n     /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n public class PoissonDistributionImpl extends AbstractIntegerDistribution\n         implements PoissonDistribution, Serializable {\n \n+    /**\n+     * Default maximum number of iterations for cumulative probability calculations.\n+     */\n+    public static final int DEFAULT_MAX_ITERATIONS = 10000000;\n+\n+    /**\n+     * Default convergence criterion\n+     */\n+    public static final double DEFAULT_EPSILON = 1E-12;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3349935121172596109L;\n \n     private double mean;\n \n     /**\n+     * Maximum number of iterations for cumulative probability.\n+     *\n+     * Cumulative probabilities are estimated using either Lanczos series approximation of\n+     * Gamma#regularizedGammaP or continued fraction approximation of Gamma#regularizedGammaQ.\n+     */\n+    private int maxIterations = DEFAULT_MAX_ITERATIONS;\n+\n+    /**\n+     * Convergence criterion for cumulative probability.\n+     */\n+    private double epsilon = DEFAULT_EPSILON;\n+\n+    /**\n      * Create a new Poisson distribution with the given the mean. The mean value\n      * must be positive; otherwise an <code>IllegalArgument</code> is thrown.\n      *\n     public PoissonDistributionImpl(double p) {\n         this(p, new NormalDistributionImpl());\n     }\n+\n+    /**\n+     * Create a new Poisson distribution with the given mean, convergence criterion\n+     * and maximum number of iterations.\n+     *\n+     * @param p the Poisson mean\n+     * @param epsilon the convergence criteria for cumulative probabilites\n+     * @param maxIterations the maximum number of iterations for cumulative probabilites\n+     */\n+    public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n+        setMean(p);\n+        this.epsilon = epsilon;\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * Create a new Poisson distribution with the given mean and convergence criterion.\n+     *\n+     * @param p the Poisson mean\n+     * @param epsilon the convergence criteria for cumulative probabilites\n+     */\n+    public PoissonDistributionImpl(double p, double epsilon) {\n+        setMean(p);\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Create a new Poisson distribution with the given mean and maximum number of iterations.\n+     *\n+     * @param p the Poisson mean\n+     * @param maxIterations the maximum number of iterations for cumulative probabilites\n+     */\n+    public PoissonDistributionImpl(double p, int maxIterations) {\n+        setMean(p);\n+        this.maxIterations = maxIterations;\n+    }\n+\n \n     /**\n      * Create a new Poisson distribution with the given the mean. The mean value\n         if (x == Integer.MAX_VALUE) {\n             return 1;\n         }\n-        return Gamma.regularizedGammaQ((double) x + 1, mean, 1E-12,\n-                Integer.MAX_VALUE);\n+        return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon, maxIterations);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (x >= a + 1) {\n             // use regularizedGammaQ because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n             double n = 0.0; // current element index\n             double an = 1.0 / a; // n-th element in the series\n             double sum = an; // partial sum\n-            while (Math.abs(an) > epsilon && n < maxIterations) {\n+            while (Math.abs(an/sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n                 // compute next element in the series\n                 n = n + 1.0;\n                 an = an * (x / (a + n));\n             }\n             if (n >= maxIterations) {\n                 throw new MaxIterationsExceededException(maxIterations);\n+            } else if (Double.isInfinite(sum)) {\n+                ret = 1.0;\n             } else {\n                 ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n             }\n      * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n      * Regularized Gamma Function</a>, equation (1).</li>\n      * <li>\n-     * <a href=\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n+     * <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n      * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>\n      * </ul>\n      *\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 1.0;\n-        } else if (x < a || a < 1.0) {\n+        } else if (x < a + 1.0) {\n             // use regularizedGammaP because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n--- a/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n             double b = getB(n, x);\n             double p2 = a * p1 + b * p0;\n             double q2 = a * q1 + b * q0;\n+            boolean infinite = false;\n             if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n-                // need to scale\n-                if (a != 0.0) {\n-                    p2 = p1 + (b / a * p0);\n-                    q2 = q1 + (b / a * q0);\n-                } else if (b != 0) {\n-                    p2 = (a / b * p1) + p0;\n-                    q2 = (a / b * q1) + q0;\n-                } else {\n-                    // can not scale an convergent is unbounded.\n+                /*\n+                 * Need to scale. Try successive powers of the larger of a or b\n+                 * up to 5th power. Throw ConvergenceException if one or both\n+                 * of p2, q2 still overflow.\n+                 */\n+                double scaleFactor = 1d;\n+                double lastScaleFactor = 1d;\n+                final int maxPower = 5;\n+                final double scale = Math.max(a,b);\n+                if (scale <= 0) {  // Can't scale\n                     throw new ConvergenceException(\n-                        \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n-                        x);\n+                            \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+                             x);\n+                }\n+                infinite = true;\n+                for (int i = 0; i < maxPower; i++) {\n+                    lastScaleFactor = scaleFactor;\n+                    scaleFactor *= scale;\n+                    if (a != 0.0 && a > b) {\n+                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n+                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n+                    } else if (b != 0) {\n+                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n+                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n+                    }\n+                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n+                    if (!infinite) {\n+                        break;\n+                    }\n                 }\n             }\n+\n+            if (infinite) {\n+               // Scaling failed\n+               throw new ConvergenceException(\n+                 \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+                  x);\n+            }\n+\n             double r = p2 / q2;\n+\n+            if (Double.isNaN(r)) {\n+                throw new ConvergenceException(\n+                  \"Continued fraction diverged to NaN for value {0}\",\n+                  x);\n+            }\n             relativeError = Math.abs(r / c - 1.0);\n \n             // prepare for next iteration\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n     @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R\n-        return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d,\n-                6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};\n+        return new double[] {-2.226325228634938d, -1.156887023657177d, -0.643949578356075d, -0.2027950777320613d, 0.305827808237559d,\n+                6.42632522863494d, 5.35688702365718d, 4.843949578356074d, 4.40279507773206d, 3.89417219176244d};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     }\n \n     // --------------------- Override tolerance  --------------\n+    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n-        setTolerance(1E-6);\n+        setTolerance(defaultTolerance);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n         double mu = distribution.getMean();\n         double sigma = distribution.getStandardDeviation();\n         setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,\n-                mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,\n+                mu, mu + sigma, mu + 2 * sigma,  mu + 3 * sigma, mu + 4 * sigma,\n                 mu + 5 * sigma});\n         // Quantiles computed using R (same as Mathematica)\n-        setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447,\n-                0.9772499, 0.9986501, 0.9999683,  0.9999997});\n+        setCumulativeTestValues(new double[] {0.02275013194817921, 0.158655253931457, 0.5, 0.841344746068543,\n+                0.977249868051821, 0.99865010196837, 0.999968328758167,  0.999999713348428});\n         verifyCumulativeProbabilities();\n     }\n \n \n     public void testMath280() throws MathException {\n         NormalDistribution normal = new NormalDistributionImpl(0,1);\n-        double result = normal.inverseCumulativeProbability(0.9772498680518209);\n-        assertEquals(2.0, result, 1.0e-12);\n+        double result = normal.inverseCumulativeProbability(0.9986501019683698);\n+        assertEquals(3.0, result, defaultTolerance);\n+        result = normal.inverseCumulativeProbability(0.841344746068543);\n+        assertEquals(1.0, result, defaultTolerance);\n+        result = normal.inverseCumulativeProbability(0.9999683287581673);\n+        assertEquals(4.0, result, defaultTolerance);\n+        result = normal.inverseCumulativeProbability(0.9772498680518209);\n+        assertEquals(2.0, result, defaultTolerance);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n     \n     /**\n      * JIRA: MATH-282\n-     * TODO: activate this test when MATH-282 is resolved\n      */\n     public void testCumulativeProbabilitySpecial() throws Exception {\n-        /*\n         PoissonDistribution dist = new PoissonDistributionImpl(1.0);\n         dist.setMean(9120);\n         checkProbability(dist, 9075);\n         checkProbability(dist, 5044);\n         dist.setMean(6986);\n         checkProbability(dist, 6950);\n-        */\n     }\n     \n     private void checkProbability(PoissonDistribution dist, double x) throws Exception {\n                 dist.getMean() + \" x = \" + x, p > 0);\n     }\n \n-    public void testLargeMeanInverseCumulativeProbability() {\n+    public void testLargeMeanInverseCumulativeProbability() throws Exception {\n         PoissonDistribution dist = new PoissonDistributionImpl(1.0);\n         double mean = 1.0;\n-        while (mean <= 10000000.0) {\n+        while (mean <= 100000.0) { // Extended test value: 1E7.  Reduced to limit run time.\n             dist.setMean(mean);\n-\n             double p = 0.1;\n             double dp = p;\n-            while (p < 1.0) {\n+            while (p < .99) { \n+                double ret = Double.NaN;\n                 try {\n-                    dist.inverseCumulativeProbability(p);\n+                    ret = dist.inverseCumulativeProbability(p);\n+                    // Verify that returned value satisties definition\n+                    assertTrue(p >= dist.cumulativeProbability(ret));\n+                    assertTrue(p < dist.cumulativeProbability(ret + 1));\n                 } catch (MathException ex) {\n                     fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n                 }\n                 p += dp;\n             }\n-\n             mean *= 10.0;\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/special/ErfTest.java\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n         expected = -expected;\n         assertEquals(expected, actual, 1.0e-5);\n     }\n+    \n+    /**\n+     * MATH-301\n+     */\n+    public void testLargeValues() throws Exception {\n+        for (int i = 1; i < 200; i++) {\n+            double result = Erf.erf(i);\n+            assertFalse(Double.isNaN(result));\n+            assertTrue(result > 0 && result <= 1);  \n+        }\n+    }\n }", "timestamp": 1268089052, "metainfo": ""}