{"sha": "cad6e4ae20fc7ff4535e42b1f3aa9a462f82c0ba", "log": "MATH-689 Moved array utilities from \"MathUtils\" to \"MathArrays\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n      * weights are to be treated as \"expansion values,\" as will be the case if for example\n      * the weights represent frequency counts. To normalize weights so that the denominator\n      * in the variance computation equals the length of the input vector minus one, use <pre>\n-     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length)); </code>\n+     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>\n      * </pre>\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * weights are to be treated as \"expansion values,\" as will be the case if for example\n      * the weights represent frequency counts. To normalize weights so that the denominator\n      * in the variance computation equals the length of the input vector minus one, use <pre>\n-     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length)); </code>\n+     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>\n      * </pre>\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * weights are to be treated as \"expansion values,\" as will be the case if for example\n      * the weights represent frequency counts. To normalize weights so that the denominator\n      * in the variance computation equals the length of the input vector minus one, use <pre>\n-     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length), mean); </code>\n+     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n      * </pre>\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * weights are to be treated as \"expansion values,\" as will be the case if for example\n      * the weights represent frequency counts. To normalize weights so that the denominator\n      * in the variance computation equals the length of the input vector minus one, use <pre>\n-     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length), mean); </code>\n+     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n      * </pre>\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n--- a/src/main/java/org/apache/commons/math/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math/util/MathArrays.java\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.MathArithmeticException;\n \n /**\n  * Arrays utilities.\n         }\n         return true;\n     }\n+\n+     /**\n+      * Normalizes an array to make it sum to a specified value.\n+      * Returns the result of the transformation <pre>\n+      *    x |-> x * normalizedSum / sum\n+      * </pre>\n+      * applied to each non-NaN element x of the input array, where sum is the\n+      * sum of the non-NaN entries in the input array.</p>\n+      *\n+      * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite\n+      * or NaN and ArithmeticException if the input array contains any infinite elements\n+      * or sums to 0.</p>\n+      *\n+      * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n+      *\n+      * @param values Input array to be normalized\n+      * @param normalizedSum Target sum for the normalized array\n+      * @return the normalized array.\n+      * @throws MathArithmeticException if the input array contains infinite\n+      * elements or sums to zero.\n+      * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n+      * @since 2.1\n+      */\n+     public static double[] normalizeArray(double[] values, double normalizedSum) {\n+         if (Double.isInfinite(normalizedSum)) {\n+             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n+         }\n+         if (Double.isNaN(normalizedSum)) {\n+             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n+         }\n+         double sum = 0d;\n+         final int len = values.length;\n+         double[] out = new double[len];\n+         for (int i = 0; i < len; i++) {\n+             if (Double.isInfinite(values[i])) {\n+                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n+             }\n+             if (!Double.isNaN(values[i])) {\n+                 sum += values[i];\n+             }\n+         }\n+         if (sum == 0) {\n+             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n+         }\n+         for (int i = 0; i < len; i++) {\n+             if (Double.isNaN(values[i])) {\n+                 out[i] = Double.NaN;\n+             } else {\n+                 out[i] = values[i] * normalizedSum / sum;\n+             }\n+         }\n+         return out;\n+     }\n }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n         return a - p * FastMath.floor((a - offset) / p) - offset;\n     }\n \n-     /**\n-      * <p>Normalizes an array to make it sum to a specified value.\n-      * Returns the result of the transformation <pre>\n-      *    x |-> x * normalizedSum / sum\n-      * </pre>\n-      * applied to each non-NaN element x of the input array, where sum is the\n-      * sum of the non-NaN entries in the input array.</p>\n-      *\n-      * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite\n-      * or NaN and ArithmeticException if the input array contains any infinite elements\n-      * or sums to 0</p>\n-      *\n-      * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n-      *\n-      * @param values input array to be normalized\n-      * @param normalizedSum target sum for the normalized array\n-      * @return normalized array\n-      * @throws MathArithmeticException if the input array contains infinite elements or sums to zero\n-      * @throws MathIllegalArgumentException if the target sum is infinite or NaN\n-      * @since 2.1\n-      */\n-     public static double[] normalizeArray(double[] values, double normalizedSum) {\n-         if (Double.isInfinite(normalizedSum)) {\n-             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n-         }\n-         if (Double.isNaN(normalizedSum)) {\n-             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n-         }\n-         double sum = 0d;\n-         final int len = values.length;\n-         double[] out = new double[len];\n-         for (int i = 0; i < len; i++) {\n-             if (Double.isInfinite(values[i])) {\n-                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n-             }\n-             if (!Double.isNaN(values[i])) {\n-                 sum += values[i];\n-             }\n-         }\n-         if (sum == 0) {\n-             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n-         }\n-         for (int i = 0; i < len; i++) {\n-             if (Double.isNaN(values[i])) {\n-                 out[i] = Double.NaN;\n-             } else {\n-                 out[i] = values[i] * normalizedSum / sum;\n-             }\n-         }\n-         return out;\n-     }\n-\n     /**\n      * Round the given value to the specified number of decimal places. The\n      * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.junit.Assert;\n import org.junit.Test;\n \n         // All weights the same -> when weights are normalized to sum to the length of the values array,\n         // weighted variance = unweighted value\n         Assert.assertEquals(expectedValue(),\n-                variance.evaluate(testArray, MathUtils.normalizeArray(identicalWeightsArray, testArray.length),\n+                variance.evaluate(testArray, MathArrays.normalizeArray(identicalWeightsArray, testArray.length),\n                         0, testArray.length), getTolerance());\n \n     }\n--- a/src/test/java/org/apache/commons/math/util/MathArraysTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathArraysTest.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.random.Well1024a;\n+import org.apache.commons.math.TestUtils;\n \n import org.junit.Assert;\n import org.junit.Test;\n         Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d },\n                                                          new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n     }\n+\n+    @Test\n+    public void testNormalizeArray() {\n+        double[] testValues1 = new double[] {1, 1, 2};\n+        TestUtils.assertEquals( new double[] {.25, .25, .5},\n+                                MathArrays.normalizeArray(testValues1, 1),\n+                                Double.MIN_VALUE);\n+\n+        double[] testValues2 = new double[] {-1, -1, 1};\n+        TestUtils.assertEquals( new double[] {1, 1, -1},\n+                                MathArrays.normalizeArray(testValues2, 1),\n+                                Double.MIN_VALUE);\n+\n+        // Ignore NaNs\n+        double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN};\n+        TestUtils.assertEquals( new double[] {1, 1,Double.NaN, -1, Double.NaN},\n+                                MathArrays.normalizeArray(testValues3, 1),\n+                                Double.MIN_VALUE);\n+\n+        // Zero sum -> MathArithmeticException\n+        double[] zeroSum = new double[] {-1, 1};\n+        try {\n+            MathArrays.normalizeArray(zeroSum, 1);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n+\n+        // Infinite elements -> MathArithmeticException\n+        double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};\n+        try {\n+            MathArrays.normalizeArray(hasInf, 1);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n+\n+        // Infinite target -> MathIllegalArgumentException\n+        try {\n+            MathArrays.normalizeArray(testValues1, Double.POSITIVE_INFINITY);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n+\n+        // NaN target -> MathIllegalArgumentException\n+        try {\n+            MathArrays.normalizeArray(testValues1, Double.NaN);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n     }\n \n     @Test\n-    public void testNormalizeArray() {\n-        double[] testValues1 = new double[] {1, 1, 2};\n-        TestUtils.assertEquals(\n-                new double[] {.25, .25, .5},\n-                MathUtils.normalizeArray(testValues1, 1),\n-                Double.MIN_VALUE);\n-\n-        double[] testValues2 = new double[] {-1, -1, 1};\n-        TestUtils.assertEquals(\n-                new double[] {1, 1, -1},\n-                MathUtils.normalizeArray(testValues2, 1),\n-                Double.MIN_VALUE);\n-\n-        // Ignore NaNs\n-        double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN};\n-        TestUtils.assertEquals(\n-                new double[] {1, 1,Double.NaN, -1, Double.NaN},\n-                MathUtils.normalizeArray(testValues3, 1),\n-                Double.MIN_VALUE);\n-\n-        // Zero sum -> MathArithmeticException\n-        double[] zeroSum = new double[] {-1, 1};\n-        try {\n-            MathUtils.normalizeArray(zeroSum, 1);\n-            Assert.fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {}\n-\n-        // Infinite elements -> MathArithmeticException\n-        double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};\n-        try {\n-            MathUtils.normalizeArray(hasInf, 1);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {}\n-\n-        // Infinite target -> MathIllegalArgumentException\n-        try {\n-            MathUtils.normalizeArray(testValues1, Double.POSITIVE_INFINITY);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {}\n-\n-        // NaN target -> MathIllegalArgumentException\n-        try {\n-            MathUtils.normalizeArray(testValues1, Double.NaN);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {}\n-\n-    }\n-\n-    @Test\n     public void testRoundDouble() {\n         double x = 1.234567890;\n         Assert.assertEquals(1.23, MathUtils.round(x, 2), 0.0);", "timestamp": 1318376277, "metainfo": ""}