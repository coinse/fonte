{"sha": "90d3cc41ac5f8f40bcb155794cabf254068f85ee", "log": "Add throw declarations for filter package, javadoc formatting.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/filter/DefaultMeasurementModel.java\n+++ b/src/main/java/org/apache/commons/math3/filter/DefaultMeasurementModel.java\n  */\n package org.apache.commons.math3.filter;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n \n /**\n- * Default implementation of a {@link MeasurementModel} for the use with a\n- * {@link KalmanFilter}.\n+ * Default implementation of a {@link MeasurementModel} for the use with a {@link KalmanFilter}.\n  *\n  * @since 3.0\n  * @version $Id$\n     private RealMatrix measurementNoise;\n \n     /**\n-     * Create a new {@link MeasurementModel}, taking double arrays as input\n-     * parameters for the respective measurement matrix and noise.\n+     * Create a new {@link MeasurementModel}, taking double arrays as input parameters for the\n+     * respective measurement matrix and noise.\n      *\n-     * @param measMatrix the measurement matrix\n-     * @param measNoise the measurement noise matrix\n+     * @param measMatrix\n+     *            the measurement matrix\n+     * @param measNoise\n+     *            the measurement noise matrix\n+     * @throws NullArgumentException\n+     *             if any of the input matrices is {@code null}\n+     * @throws NoDataException\n+     *             if any row / column dimension of the input matrices is zero\n+     * @throws DimensionMismatchException\n+     *             if any of the input matrices is non-rectangular\n      */\n-    public DefaultMeasurementModel(final double[][] measMatrix, final double[][] measNoise) {\n+    public DefaultMeasurementModel(final double[][] measMatrix, final double[][] measNoise)\n+            throws NullArgumentException, NoDataException, DimensionMismatchException {\n         this(new Array2DRowRealMatrix(measMatrix), new Array2DRowRealMatrix(measNoise));\n     }\n \n--- a/src/main/java/org/apache/commons/math3/filter/DefaultProcessModel.java\n+++ b/src/main/java/org/apache/commons/math3/filter/DefaultProcessModel.java\n  */\n package org.apache.commons.math3.filter;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.RealVector;\n \n /**\n- * Default implementation of a {@link ProcessModel} for the use with a\n- * {@link KalmanFilter}.\n+ * Default implementation of a {@link ProcessModel} for the use with a {@link KalmanFilter}.\n  *\n  * @since 3.0\n  * @version $Id$\n  */\n public class DefaultProcessModel implements ProcessModel {\n     /**\n-     * The state transition matrix, used to advance the internal state\n-     * estimation each time-step.\n+     * The state transition matrix, used to advance the internal state estimation each time-step.\n      */\n     private RealMatrix stateTransitionMatrix;\n \n     /**\n-     * The control matrix, used to integrate a control input into the state\n-     * estimation.\n+     * The control matrix, used to integrate a control input into the state estimation.\n      */\n     private RealMatrix controlMatrix;\n \n     private RealMatrix initialErrorCovMatrix;\n \n     /**\n-     * Create a new {@link ProcessModel}, taking double arrays as input\n-     * parameters.\n+     * Create a new {@link ProcessModel}, taking double arrays as input parameters.\n      *\n-     * @param stateTransition the state transition matrix\n-     * @param control the control matrix\n-     * @param processNoise the process noise matrix\n-     * @param initialStateEstimate the initial state estimate vector\n-     * @param initialErrorCovariance the initial error covariance matrix\n+     * @param stateTransition\n+     *            the state transition matrix\n+     * @param control\n+     *            the control matrix\n+     * @param processNoise\n+     *            the process noise matrix\n+     * @param initialStateEstimate\n+     *            the initial state estimate vector\n+     * @param initialErrorCovariance\n+     *            the initial error covariance matrix\n+     * @throws NullArgumentException\n+     *             if any of the input arrays is {@code null}\n+     * @throws NoDataException\n+     *             if any row / column dimension of the input matrices is zero\n+     * @throws DimensionMismatchException\n+     *             if any of the input matrices is non-rectangular\n      */\n     public DefaultProcessModel(final double[][] stateTransition,\n                                final double[][] control,\n                                final double[][] processNoise,\n                                final double[] initialStateEstimate,\n-                               final double[][] initialErrorCovariance) {\n+                               final double[][] initialErrorCovariance)\n+            throws NullArgumentException, NoDataException, DimensionMismatchException {\n+\n         this(new Array2DRowRealMatrix(stateTransition),\n                 new Array2DRowRealMatrix(control),\n                 new Array2DRowRealMatrix(processNoise),\n     }\n \n     /**\n-     * Create a new {@link ProcessModel}, taking double arrays as input\n-     * parameters. The initial state estimate and error covariance are omitted\n-     * and will be initialized by the {@link KalmanFilter} to default values.\n+     * Create a new {@link ProcessModel}, taking double arrays as input parameters.\n+     * <p>\n+     * The initial state estimate and error covariance are omitted and will be initialized by the\n+     * {@link KalmanFilter} to default values.\n      *\n-     * @param stateTransition the state transition matrix\n-     * @param control the control matrix\n-     * @param processNoise the process noise matrix\n+     * @param stateTransition\n+     *            the state transition matrix\n+     * @param control\n+     *            the control matrix\n+     * @param processNoise\n+     *            the process noise matrix\n+     * @throws NullArgumentException\n+     *             if any of the input arrays is {@code null}\n+     * @throws NoDataException\n+     *             if any row / column dimension of the input matrices is zero\n+     * @throws DimensionMismatchException\n+     *             if any of the input matrices is non-rectangular\n      */\n     public DefaultProcessModel(final double[][] stateTransition,\n                                final double[][] control,\n-                               final double[][] processNoise) {\n+                               final double[][] processNoise)\n+            throws NullArgumentException, NoDataException, DimensionMismatchException {\n+\n         this(new Array2DRowRealMatrix(stateTransition),\n                 new Array2DRowRealMatrix(control),\n                 new Array2DRowRealMatrix(processNoise), null, null);\n     }\n \n     /**\n-     * Create a new {@link ProcessModel}, taking double arrays as input\n-     * parameters.\n+     * Create a new {@link ProcessModel}, taking double arrays as input parameters.\n      *\n-     * @param stateTransition the state transition matrix\n-     * @param control the control matrix\n-     * @param processNoise the process noise matrix\n-     * @param initialStateEstimate the initial state estimate vector\n-     * @param initialErrorCovariance the initial error covariance matrix\n+     * @param stateTransition\n+     *            the state transition matrix\n+     * @param control\n+     *            the control matrix\n+     * @param processNoise\n+     *            the process noise matrix\n+     * @param initialStateEstimate\n+     *            the initial state estimate vector\n+     * @param initialErrorCovariance\n+     *            the initial error covariance matrix\n      */\n     public DefaultProcessModel(final RealMatrix stateTransition,\n                                final RealMatrix control,\n--- a/src/main/java/org/apache/commons/math3/filter/KalmanFilter.java\n+++ b/src/main/java/org/apache/commons/math3/filter/KalmanFilter.java\n package org.apache.commons.math3.filter;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.CholeskyDecomposition;\n import org.apache.commons.math3.linear.NonSquareMatrixException;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.RealVector;\n+import org.apache.commons.math3.linear.SingularMatrixException;\n import org.apache.commons.math3.util.MathUtils;\n \n /**\n  * <i>z<sub>k</sub></i> = <b>H</b><i>x<sub>k</sub></i> + <i>v<sub>k</sub></i>.\n  * </pre>\n  *\n+ * <p>\n  * The random variables <i>w<sub>k</sub></i> and <i>v<sub>k</sub></i> represent\n  * the process and measurement noise and are assumed to be independent of each\n  * other and distributed with normal probability (white noise).\n  * <li>predict: project the current state estimate ahead in time</li>\n  * <li>correct: adjust the projected estimate by an actual measurement</li>\n  * </ol>\n- * </p>\n- * <br/>\n  * <p>\n  * The Kalman filter is initialized with a {@link ProcessModel} and a\n  * {@link MeasurementModel}, which contain the corresponding transformation and\n  * <li>R - measurement noise covariance matrix</li>\n  * <li>P - error covariance matrix</li>\n  * </ul>\n- * </p>\n  *\n  * @see <a href=\"http://www.cs.unc.edu/~welch/kalman/\">Kalman filter\n  *      resources</a>\n      *            the model defining the underlying process dynamics\n      * @param measurement\n      *            the model defining the given measurement characteristics\n-     * @throws org.apache.commons.math3.exception.NullArgumentException\n-     *             if any of the given inputs is null (except for the control\n-     *             matrix)\n+     * @throws NullArgumentException\n+     *             if any of the given inputs is null (except for the control matrix)\n      * @throws NonSquareMatrixException\n      *             if the transition matrix is non square\n+     * @throws DimensionMismatchException\n+     *             if the column dimension of the transition matrix does not match the dimension of the\n+     *             initial state estimation vector\n      * @throws MatrixDimensionMismatchException\n      *             if the matrix dimensions do not fit together\n      */\n-    public KalmanFilter(final ProcessModel process,\n-                        final MeasurementModel measurement) {\n+    public KalmanFilter(final ProcessModel process, final MeasurementModel measurement)\n+            throws NullArgumentException, NonSquareMatrixException, DimensionMismatchException,\n+                   MatrixDimensionMismatchException {\n \n         MathUtils.checkNotNull(process);\n         MathUtils.checkNotNull(measurement);\n         // set the initial state estimate to a zero vector if it is not\n         // available from the process model\n         if (processModel.getInitialStateEstimate() == null) {\n-            stateEstimation =\n-                new ArrayRealVector(transitionMatrix.getColumnDimension());\n+            stateEstimation = new ArrayRealVector(transitionMatrix.getColumnDimension());\n         } else {\n             stateEstimation = processModel.getInitialStateEstimate();\n         }\n      * @throws DimensionMismatchException\n      *             if the dimension of the control vector does not fit\n      */\n-    public void predict(final double[] u) {\n+    public void predict(final double[] u) throws DimensionMismatchException {\n         predict(new ArrayRealVector(u));\n     }\n \n     /**\n      * Predict the internal state estimation one time step ahead.\n      *\n-     * @param u the control vector\n-     * @throws DimensionMismatchException if the dimension of the control\n-     * vector does not fit\n-     */\n-    public void predict(final RealVector u) {\n+     * @param u\n+     *            the control vector\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the control vector does not match\n+     */\n+    public void predict(final RealVector u) throws DimensionMismatchException {\n         // sanity checks\n         if (u != null &&\n             u.getDimension() != controlMatrix.getColumnDimension()) {\n     /**\n      * Correct the current state estimate with an actual measurement.\n      *\n-     * @param z the measurement vector\n-     * @throws DimensionMismatchException\n-     * if the dimension of the measurement vector does not fit\n-     * @throws org.apache.commons.math3.linear.SingularMatrixException\n-     * if the covariance matrix could not be inverted\n-     */\n-    public void correct(final double[] z) {\n+     * @param z\n+     *            the measurement vector\n+     * @throws NullArgumentException\n+     *             if the measurement vector is {@code null}\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the measurement vector does not fit\n+     * @throws SingularMatrixException\n+     *             if the covariance matrix could not be inverted\n+     */\n+    public void correct(final double[] z)\n+            throws NullArgumentException, DimensionMismatchException, SingularMatrixException {\n         correct(new ArrayRealVector(z));\n     }\n \n     /**\n      * Correct the current state estimate with an actual measurement.\n      *\n-     * @param z the measurement vector\n-     * @throws DimensionMismatchException if the dimension of the\n-     * measurement vector does not fit\n-     * @throws org.apache.commons.math3.linear.SingularMatrixException\n-     * if the covariance matrix could not be inverted\n-     */\n-    public void correct(final RealVector z) {\n+     * @param z\n+     *            the measurement vector\n+     * @throws NullArgumentException\n+     *             if the measurement vector is {@code null}\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the measurement vector does not fit\n+     * @throws SingularMatrixException\n+     *             if the covariance matrix could not be inverted\n+     */\n+    public void correct(final RealVector z)\n+            throws NullArgumentException, DimensionMismatchException, SingularMatrixException {\n+\n         // sanity checks\n         MathUtils.checkNotNull(z);\n         if (z.getDimension() != measurementMatrix.getRowDimension()) {\n--- a/src/main/java/org/apache/commons/math3/filter/MeasurementModel.java\n+++ b/src/main/java/org/apache/commons/math3/filter/MeasurementModel.java\n     RealMatrix getMeasurementMatrix();\n \n     /**\n-     * Returns the measurement noise matrix. This method is called by the\n-     * {@link KalmanFilter} every correct step, so implementations of this\n-     * interface may return a modified measurement noise depending on current\n-     * iteration step.\n+     * Returns the measurement noise matrix. This method is called by the {@link KalmanFilter} every\n+     * correction step, so implementations of this interface may return a modified measurement noise\n+     * depending on the current iteration step.\n      *\n      * @return the measurement noise matrix\n      * @see KalmanFilter#correct(double[])\n--- a/src/main/java/org/apache/commons/math3/filter/ProcessModel.java\n+++ b/src/main/java/org/apache/commons/math3/filter/ProcessModel.java\n     RealMatrix getControlMatrix();\n \n     /**\n-     * Returns the process noise matrix. This method is called by the\n-     * {@link KalmanFilter} every predict step, so implementations of this\n-     * interface may return a modified process noise depending on current\n-     * iteration step.\n+     * Returns the process noise matrix. This method is called by the {@link KalmanFilter} every\n+     * prediction step, so implementations of this interface may return a modified process noise\n+     * depending on the current iteration step.\n      *\n      * @return the process noise matrix\n      * @see KalmanFilter#predict()\n     /**\n      * Returns the initial state estimation vector.\n      * <p>\n-     * Note: if the return value is zero, the Kalman filter will initialize the\n+     * <b>Note:</b> if the return value is zero, the Kalman filter will initialize the\n      * state estimation with a zero vector.\n-     * </p>\n      *\n      * @return the initial state estimation vector\n      */\n     /**\n      * Returns the initial error covariance matrix.\n      * <p>\n-     * Note: if the return value is zero, the Kalman filter will initialize the\n+     * <b>Note:</b> if the return value is zero, the Kalman filter will initialize the\n      * error covariance with the process noise matrix.\n-     * </p>\n      *\n      * @return the initial error covariance matrix\n      */", "timestamp": 1346875567, "metainfo": ""}