{"sha": "b68a2cae5a9192bc95c245464054cbc2ef34bc7d", "log": "Added erf(double,double) to Erf and used this to improve tail probability accuracy in NormalDistributionImpl.  JIRA: MATH-364.  Reported and patched by Christian Winter.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Erf;\n import org.apache.commons.math.util.FastMath;\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 8589540077390120676L;\n-    /** &sqrt;(2 &pi;) */\n+    /** &radic;(2 &pi;) */\n     private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n+    /** &radic;(2) */\n+    private static final double SQRT2 = FastMath.sqrt(2.0);\n     /** Mean of this distribution. */\n     private final double mean;\n     /** Standard deviation of this distribution. */\n         if (FastMath.abs(dev) > 40 * standardDeviation) {\n             return dev < 0 ? 0.0d : 1.0d;\n         }\n-        return 0.5 * (1 + Erf.erf(dev / (standardDeviation * FastMath.sqrt(2))));\n+        return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double cumulativeProbability(double x0, double x1) throws MathException {\n+        if (x0 > x1) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                                                x0, x1, true);\n+        }\n+        final double denom = standardDeviation * SQRT2;\n+        final double v0 = (x0 - mean) / denom;\n+        final double v1 = (x1 - mean) / denom;\n+        return 0.5 * Erf.erf(v0, v1);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/special/Erf.java\n+++ b/src/main/java/org/apache/commons/math/special/Erf.java\n  * @version $Id$\n  */\n public class Erf {\n+\n+    /**\n+     * The number {@code X_CRIT} is used by {@link #erf(double, double)} internally.\n+     * This number solves {@code erf(x)=0.5} within 1ulp.\n+     * More precisely, the current implementations of\n+     * {@link #erf(double)} and {@link #erfc(double)} satisfy:<br/>\n+     * {@code erf(X_CRIT) < 0.5},<br/>\n+     * {@code erf(Math.nextUp(X_CRIT) > 0.5},<br/>\n+     * {@code erfc(X_CRIT) = 0.5}, and<br/>\n+     * {@code erfc(Math.nextUp(X_CRIT) < 0.5}\n+     */\n+    private static final double X_CRIT = 0.4769362762044697;\n+\n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n         if (FastMath.abs(x) > 40) {\n             return x > 0 ? 1 : -1;\n         }\n-        double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n-        if (x < 0) {\n-            ret = -ret;\n-        }\n-        return ret;\n+        final double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n+        return x < 0 ? -ret : ret;\n     }\n \n     /**\n         final double ret = Gamma.regularizedGammaQ(0.5, x * x, 1.0e-15, 10000);\n         return x < 0 ? 2 - ret : ret;\n     }\n+\n+    /**\n+     * Returns the difference between erf(x1) and erf(x2).\n+     *\n+     * The implementation uses either erf(double) or erfc(double)\n+     * depending on which provides the most precise result.\n+     *\n+     * @param x1 the first value\n+     * @param x2 the second value\n+     * @return erf(x2) - erf(x1)\n+     */\n+    public static double erf(double x1, double x2) {\n+        if(x1 > x2) {\n+            return -erf(x2, x1);\n+        }\n+\n+        return\n+        x1 < -X_CRIT ?\n+            x2 < 0.0 ?\n+                erfc(-x2) - erfc(-x1) :\n+                erf(x2) - erf(x1) :\n+            x2 > X_CRIT && x1 > 0.0 ?\n+                erfc(x1) - erfc(x2) :\n+                erf(x2) - erf(x1);\n+    }\n }\n \n--- a/src/test/java/org/apache/commons/math/special/ErfTest.java\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n             TestUtils.assertRelativelyEquals(ref[i][1], result, 1E-13);\n         }\n     }\n+    \n+    /**\n+     * Test the implementation of Erf.erf(double, double) for consistency with results\n+     * obtained from Erf.erf(double) and Erf.erfc(double).\n+     */\n+    @Test\n+    public void testTwoArgumentErf() throws Exception {\n+        double[] xi = new double[]{-2.0, -1.0, -0.9, -0.1, 0.0, 0.1, 0.9, 1.0, 2.0};\n+        for(double x1 : xi) {\n+            for(double x2 : xi) {\n+                double a = Erf.erf(x1, x2);\n+                double b = Erf.erf(x2) - Erf.erf(x1);\n+                double c = Erf.erfc(x1) - Erf.erfc(x2);\n+                Assert.assertEquals(a, b, 1E-15);\n+                Assert.assertEquals(a, c, 1E-15);\n+            }\n+        }\n+    }\n }", "timestamp": 1314840277, "metainfo": ""}