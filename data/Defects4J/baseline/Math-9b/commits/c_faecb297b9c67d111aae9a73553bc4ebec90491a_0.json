{"sha": "faecb297b9c67d111aae9a73553bc4ebec90491a", "log": "improved consistency in class naming with respect to functions in the analysis package  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link DifferentiableMultivariateRealFunction\n+ * scalar differentiable objective functions}.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.</p>\n+ * @see MultivariateRealOptimizer\n+ * @see DifferentiableMultivariateVectorialOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateRealOptimizer extends Serializable {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /** Get the number of evaluations of the objective function gradient.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function gradient\n+     */\n+    int getGradientEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(RealConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @return object used to check for convergence\n+     */\n+    RealConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * @param f objective function\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    RealPointValuePair optimize(DifferentiableMultivariateRealFunction f,\n+                                  GoalType goalType,\n+                                  double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link DifferentiableMultivariateVectorialFunction\n+ * vectorial differentiable objective functions}.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.</p>\n+ * @see MultivariateRealOptimizer\n+ * @see DifferentiableMultivariateRealOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateVectorialOptimizer extends Serializable {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     * .\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+      * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * @return number of iterations\n+    */\n+   int getIterations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /** Get the number of evaluations of the objective function jacobian .\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function jacobian\n+     */\n+    int getJacobianEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(VectorialConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @return object used to check for convergence\n+     */\n+    VectorialConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * <p>\n+     * Optimization is considered to be a weighted least-squares minimization.\n+     * The cost function to be minimized is\n+     * &sum;weight<sub>i</sub>(objective<sub>i</sub>-target<sub>i</sub>)<sup>2</sup>\n+     * </p>\n+     * @param f objective function\n+     * @param target target value for the objective functions at optimum\n+     * @param weights weight for the least squares cost computation\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    VectorialPointValuePair optimize(DifferentiableMultivariateVectorialFunction f,\n+                                     double[] target, double[] weights,\n+                                     double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link DifferentiableMultivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartDifferentiableMultivariateRealOptimizer\n+    implements DifferentiableMultivariateRealOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3220364832729994537L;\n+\n+    /** Underlying classical optimizer. */\n+    private final DifferentiableMultivariateRealOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of gradient evaluations already performed for all starts. */\n+    private int totalGradientEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private RealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartDifferentiableMultivariateRealOptimizer(final DifferentiableMultivariateRealOptimizer optimizer,\n+                                                             final int starts,\n+                                                             final RandomVectorGenerator generator) {\n+        this.optimizer                = optimizer;\n+        this.maxIterations            = Integer.MAX_VALUE;\n+        this.totalIterations          = 0;\n+        this.totalEvaluations         = 0;\n+        this.totalGradientEvaluations = 0;\n+        this.starts                   = starts;\n+        this.generator                = generator;\n+        this.optima                   = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public RealPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (RealPointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getGradientEvaluations() {\n+        return totalGradientEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n+                                         final GoalType goalType,\n+                                         double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        optima                   = new RealPointValuePair[starts];\n+        totalIterations          = 0;\n+        totalEvaluations         = 0;\n+        totalGradientEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (OptimizationException oe) {\n+                optima[i] = null;\n+            }\n+\n+            totalIterations          += optimizer.getIterations();\n+            totalEvaluations         += optimizer.getEvaluations();\n+            totalGradientEvaluations += optimizer.getGradientEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n+            public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link DifferentiableMultivariateVectorialOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartDifferentiableMultivariateVectorialOptimizer\n+    implements DifferentiableMultivariateVectorialOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 9206382258980561530L;\n+\n+    /** Underlying classical optimizer. */\n+    private final DifferentiableMultivariateVectorialOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of jacobian evaluations already performed for all starts. */\n+    private int totalJacobianEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private VectorialPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartDifferentiableMultivariateVectorialOptimizer(\n+                final DifferentiableMultivariateVectorialOptimizer optimizer,\n+                final int starts,\n+                final RandomVectorGenerator generator) {\n+        this.optimizer                = optimizer;\n+        this.maxIterations            = Integer.MAX_VALUE;\n+        this.totalIterations          = 0;\n+        this.totalEvaluations         = 0;\n+        this.totalJacobianEvaluations = 0;\n+        this.starts                   = starts;\n+        this.generator                = generator;\n+        this.optima                   = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public VectorialPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (VectorialPointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getJacobianEvaluations() {\n+        return totalJacobianEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(VectorialConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n+                                            final double[] target, final double[] weights,\n+                                            final double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        optima                   = new VectorialPointValuePair[starts];\n+        totalIterations          = 0;\n+        totalEvaluations         = 0;\n+        totalJacobianEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optima[i] = optimizer.optimize(f, target, weights,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (OptimizationException oe) {\n+                optima[i] = null;\n+            }\n+\n+            totalIterations          += optimizer.getIterations();\n+            totalEvaluations         += optimizer.getEvaluations();\n+            totalJacobianEvaluations += optimizer.getJacobianEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n+            public int compare(final VectorialPointValuePair o1, final VectorialPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                return Double.compare(weightedResidual(o1), weightedResidual(o2));\n+            }\n+            private double weightedResidual(final VectorialPointValuePair pv) {\n+                final double[] value = pv.getValueRef();\n+                double sum = 0;\n+                for (int i = 0; i < value.length; ++i) {\n+                    final double ri = value[i] - target[i];\n+                    sum += weights[i] * ri * ri;\n+                }\n+                return sum;\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link MultivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartMultivariateRealOptimizer implements MultivariateRealOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5983375963110961019L;\n+\n+    /** Underlying classical optimizer. */\n+    private final MultivariateRealOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private RealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartMultivariateRealOptimizer(final MultivariateRealOptimizer optimizer,\n+                                               final int starts,\n+                                               final RandomVectorGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.maxIterations    = Integer.MAX_VALUE;\n+        this.totalIterations  = 0;\n+        this.totalEvaluations = 0;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public RealPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (RealPointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final MultivariateRealFunction f,\n+                                         final GoalType goalType,\n+                                         double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        optima           = new RealPointValuePair[starts];\n+        totalIterations  = 0;\n+        totalEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (OptimizationException oe) {\n+                optima[i] = null;\n+            }\n+\n+            totalIterations  += optimizer.getIterations();\n+            totalEvaluations += optimizer.getEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n+            public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.random.RandomGenerator;\n+\n+/** \n+ * Special implementation of the {@link UnivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5983375963110961019L;\n+\n+    /** Underlying classical optimizer. */\n+    private final UnivariateRealOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomGenerator generator;\n+\n+    /** Found optima. */\n+    private double[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random generator to use for restarts\n+     */\n+    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,\n+                                             final int starts,\n+                                             final RandomGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.maxIterations    = Integer.MAX_VALUE;\n+        this.totalIterations  = 0;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValue() {\n+        return optimizer.getFunctionValue();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        return optimizer.getResult();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAbsoluteAccuracy() {\n+        return optimizer.getAbsoluteAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterationCount() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaximalIterationCount() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRelativeAccuracy() {\n+        return optimizer.getRelativeAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetAbsoluteAccuracy() {\n+        optimizer.resetAbsoluteAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetMaximalIterationCount() {\n+        optimizer.resetMaximalIterationCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetRelativeAccuracy() {\n+        optimizer.resetRelativeAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAbsoluteAccuracy(double accuracy) {\n+        optimizer.setAbsoluteAccuracy(accuracy);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaximalIterationCount(int count) {\n+        this.maxIterations = count;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRelativeAccuracy(double accuracy) {\n+        optimizer.setRelativeAccuracy(accuracy);\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public double[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max)\n+        throws ConvergenceException,\n+            FunctionEvaluationException {\n+        return optimize(f, goalType, min, max, min + generator.nextDouble() * (max - min));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max, final double startValue)\n+            throws ConvergenceException, FunctionEvaluationException {\n+\n+        optima          = new double[starts];\n+        totalIterations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n+                optima[i] = optimizer.optimize(f, goalType, min, max,\n+                                               (i == 0) ? startValue : generator.nextDouble() * (max - min));\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = Double.NaN;\n+            } catch (ConvergenceException ce) {\n+                optima[i] = Double.NaN;\n+            }\n+\n+            totalIterations  += optimizer.getIterationCount();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by NaN elements\n+        int lastNaN = optima.length;\n+        for (int i = 0; i < lastNaN; ++i) {\n+            if (Double.isNaN(optima[i])) {\n+                optima[i] = optima[--lastNaN];\n+                optima[lastNaN + 1] = Double.NaN;\n+            }\n+        }\n+        Arrays.sort(optima, 0, lastNaN);\n+        if (goalType == GoalType.MAXIMIZE) {\n+            for (int i = 0, j = lastNaN - 1; i < j; ++i, --j) {\n+                double tmp = optima[i];\n+                optima[i] = optima[j];\n+                optima[j] = tmp;\n+            }\n+        }\n+\n+        if (Double.isNaN(optima[0])) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link MultivariateRealFunction\n+ * scalar objective functions}.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.</p>\n+ * @see DifferentiableMultivariateRealOptimizer\n+ * @see DifferentiableMultivariateVectorialOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultivariateRealOptimizer extends Serializable {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(RealConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @return object used to check for convergence\n+     */\n+    RealConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * @param f objective function\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    RealPointValuePair optimize(MultivariateRealFunction f,\n+                                  GoalType goalType,\n+                                  double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/RealConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** This interface specifies how to check if an {@link MultivariateRealOptimizer optimization\n+ * algorithm} has converged.\n+ *\n+ * <p>Deciding if convergence has been reached is a problem-dependent issue. The\n+ * user should provide a class implementing this interface to allow the optimization\n+ * algorithm to stop its search according to the problem at hand.</p>\n+ * <p>For convenience, two implementations that fit simple needs are already provided:\n+ * {@link SimpleScalarValueChecker} and {@link SimpleScalarPointChecker}. The first\n+ * one considers convergence is reached when the objective function value does not\n+ * change much anymore, it does not use the point set at all. The second one\n+ * considers convergence is reached when the input point set does not change\n+ * much anymore, it does not use objective function value at all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public interface RealConvergenceChecker extends Serializable {\n+\n+  /** Check if the optimization algorithm has converged considering the last points.\n+   * <p>\n+   * This method may be called several time from the same algorithm iteration with\n+   * different points. This can be detected by checking the iteration number at each\n+   * call if needed. Each time this method is called, the previous and current point\n+   * correspond to points with the same role at each iteration, so they can be\n+   * compared. As an example, simplex-based algorithms call this method for all\n+   * points of the simplex, not only for the best or worst ones.\n+   * </p>\n+   * @param iteration index of current iteration\n+   * @param previous point from previous iteration\n+   * @param current point from current iteration\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  boolean converged(int iteration, RealPointValuePair previous, RealPointValuePair current);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/RealPointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/** \n+ * This class holds a point and the value of an objective function at this point.\n+ * <p>This is a simple immutable container.</p>\n+ * @see VectorialPointValuePair\n+ * @see MultivariateRealFunction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealPointValuePair implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+\n+    /** Point coordinates. */\n+    private final double[] point;\n+\n+    /** Value of the objective function at the point. */\n+    private final double value;\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     */\n+    public RealPointValuePair(final double[] point, final double value) {\n+        this.point = point.clone();\n+        this.value  = value;\n+    }\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     */\n+    public RealPointValuePair(final double[] point, final double value,\n+                                final boolean copyArray) {\n+        this.point = copyArray ? point.clone() : point;\n+        this.value  = value;\n+    }\n+\n+    /** Get the point.\n+     * @return a copy of the stored point\n+     */\n+    public double[] getPoint() {\n+        return point.clone();\n+    }\n+\n+    /** Get a reference to the point.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the point\n+     */\n+    public double[] getPointRef() {\n+        return point;\n+    }\n+\n+    /** Get the value of the objective function.\n+     * @return the stored value of the objective function\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n import org.apache.commons.math.util.MathUtils;\n \n /** \n- * Simple implementation of the {@link ScalarConvergenceChecker} interface using\n+ * Simple implementation of the {@link RealConvergenceChecker} interface using\n  * only objective function values.\n  * <p>\n  * Convergence is considered to have been reached if either the relative\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class SimpleScalarValueChecker implements ScalarConvergenceChecker {\n+public class SimpleScalarValueChecker implements RealConvergenceChecker {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 2490271385513842607L;\n \n     /** {@inheritDoc} */\n     public boolean converged(final int iteration,\n-                             final ScalarPointValuePair previous,\n-                             final ScalarPointValuePair current) {\n+                             final RealPointValuePair previous,\n+                             final RealPointValuePair current) {\n         final double p          = previous.getValue();\n         final double c          = current.getValue();\n         final double difference = Math.abs(p - c);\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) optimization algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface UnivariateRealOptimizer extends ConvergingAlgorithm {\n+\n+    /**\n+     * Find an optimum in the given interval.\n+     * <p>\n+     * An optimizer may require that the interval brackets a single optimum.\n+     * </p>\n+     * @param f the function to optimize.\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is optimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the optimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the optimizer\n+     */\n+    double optimize(UnivariateRealFunction f, GoalType goalType,\n+                    double min, double max)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Find an optimum in the given interval, start at startValue.\n+     * <p>\n+     * An optimizer may require that the interval brackets a single optimum.\n+     * </p>\n+     * @param f the function to optimize.\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is optimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the optimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the optimizer\n+     */\n+    double optimize(UnivariateRealFunction f, GoalType goalType,\n+                    double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Get the result of the last run of the optimizer.\n+     * \n+     * @return the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Get the result of the last run of the optimizer.\n+     * \n+     * @return the value of the function at the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getFunctionValue();\n+\n+}\n--- a/src/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+++ b/src/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n /** This interface specifies how to check if an {@link VectorialOptimizer optimization\n  * algorithm} has converged.\n  *\n- * <p>Deciding if convergence has been reached is a problem-dependent\n- * issue. The user should provide a class implementing this interface\n- * to allow the optimization algorithm to stop its search according to\n- * the problem at hand.</p>\n+ * <p>Deciding if convergence has been reached is a problem-dependent issue. The\n+ * user should provide a class implementing this interface to allow the optimization\n+ * algorithm to stop its search according to the problem at hand.</p>\n+ * <p>For convenience, two implementations that fit simple needs are already provided:\n+ * {@link SimpleVectorialValueChecker} and {@link SimpleVectorialPointChecker}. The first\n+ * one considers convergence is reached when the objective function value does not\n+ * change much anymore, it does not use the point set at all. The second one\n+ * considers convergence is reached when the input point set does not change\n+ * much anymore, it does not use objective function value at all.</p>\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n+++ b/src/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+\n /** \n  * This class holds a point and the vectorial value of an objective function at this point.\n  * <p>This is a simple immutable container.</p>\n- * @see ScalarPointValuePair\n- * @see VectorialObjectiveFunction\n+ * @see RealPointValuePair\n+ * @see MultivariateVectorialFunction\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */", "timestamp": 1237932574, "metainfo": ""}