{"sha": "c98a111ee2378bd55ff084ff5c14e0edc798b4d0", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20375 Submitted by:\tAlbert Davidson Chou   ", "commit": "\n--- a/src/java/org/apache/commons/math/RootFinding.java\n+++ b/src/java/org/apache/commons/math/RootFinding.java\n \n /**\n  * Utility class comprised of root finding techniques.\n- * \n+ *\n  * @author Brent Worden\n  */\n public class RootFinding {\n     /** Maximum allowed numerical error. */\n     private static final double EPSILON = 10e-9;\n \n-\t/**\n-\t * Default constructor. Prohibit construction.\n-\t */\n-\tprivate RootFinding(){\n-\t\tsuper();\n-\t}\n+    /**\n+     * Default constructor. Prohibit construction.\n+     */\n+    private RootFinding(){\n+        super();\n+    }\n \n     /**\n      * For a function, f, this method returns two values, a and b that bracket\n      * a root of f.  That is to say, there exists a value c between a and b\n      * such that f(c) = 0.\n-     * \n+     *\n      * @param function the function\n      * @param initial midpoint of the returned range.\n      * @param lowerBound for numerical safety, a never is less than this value.\n      * @param upperBound for numerical safety, b never is greater than this value.\n      * @return a two element array holding {a, b}.\n      */\n-    public static double[] bracket(UnivariateFunction function, \n-                                   double initial, \n-                                   double lowerBound, \n+    public static double[] bracket(UnivariateFunction function,\n+                                   double initial,\n+                                   double lowerBound,\n                                    double upperBound){\n+        return bracket( function, initial, lowerBound, upperBound, Integer.MAX_VALUE ) ;\n+    }\n+\n+    /**\n+     * For a function, f, this method returns two values, a and b that bracket\n+     * a root of f.  That is to say, there exists a value c between a and b\n+     * such that f(c) = 0.\n+     *\n+     * @param function the function\n+     * @param initial midpoint of the returned range.\n+     * @param lowerBound for numerical safety, a never is less than this value.\n+     * @param upperBound for numerical safety, b never is greater than this value.\n+     * @param maximumIterations to guard against infinite looping, maximum number of iterations to perform\n+     * @return a two element array holding {a, b}.\n+     */\n+    public static double[] bracket(UnivariateFunction function,\n+                                   double initial,\n+                                   double lowerBound,\n+                                   double upperBound,\n+                                   int maximumIterations){\n         double a = initial;\n         double b = initial;\n         double fa;\n         double fb;\n-                \n-        do {        \n+        int numIterations = 0 ;\n+\n+        do {\n             a = Math.max(a - 1.0, lowerBound);\n             b = Math.min(b + 1.0, upperBound);\n             fa = function.evaluate(a);\n             fb = function.evaluate(b);\n-        } while(fa * fb > 0.0);\n-        \n-        return new double[]{a, b};  \n+            numIterations += 1 ;\n+        } while ( (fa * fb > 0.0) && ( numIterations < maximumIterations ) );\n+\n+        return new double[]{a, b};\n     }\n-    \n+\n     /**\n      * For a function, f, this method returns a root c that lies between a and\n      * b, and satisfies f(c) = 0.\n-     * \n+     *\n      * @param function the function\n-     * @param a lower bound of a root\n-     * @param b upper bound of a root\n+     * @param a lower (or upper) bound of a root\n+     * @param b upper (or lower) bound of a root\n      * @return a root of f\n      */\n-    public static double bisection(UnivariateFunction function, \n-                                   double a, \n+    public static double bisection(UnivariateFunction function,\n+                                   double a,\n                                    double b){\n         double m;\n         double fm;\n         double fa;\n-        double fb;\n-        \n+\n+        if ( b < a )\n+        {\n+            double xtemp = a ;\n+            a = b ;\n+            b = xtemp ;\n+        }\n+\n+        fa = function.evaluate(a);\n+\n         while(Math.abs(a - b) > EPSILON){\n-            fa = function.evaluate(a);\n-            fb = function.evaluate(b);\n-            \n-            m = a + (b - a) / 2.0;  // midpoint\n+            m = (a + b) * 0.5;  // midpoint\n             fm = function.evaluate(m);\n \n             if(fm * fa > 0.0){\n+                // b and m bracket the root.\n+                a = m;\n                 fa = fm;\n-                a  = m;\n             } else {\n-                fb = fm;\n-                b  = m;\n+                // a and m bracket the root.\n+                b = m;\n             }\n         }\n-        \n-        return a + (b - a) / 2.0;\n+\n+        return (a + b) * 0.5;\n     }\n }", "timestamp": 1054693037, "metainfo": ""}