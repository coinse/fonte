{"sha": "53dc23b721f012add52fc44a2d5420c1d7f8ccca", "log": "MATH-800 Deprecated \"PolynomialFitter\" and adapted unit test to use \"CurveFitter\" directly.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n  * searched by a least square estimator.</p>\n  * @version $Id$\n  * @since 2.0\n+ *\n+ * @deprecated Since 3.1 (to be removed in 4.0, see <a href=\"https://issues.apache.org/jira/browse/MATH-800\">MATH-800</a>).\n+ * Please use {@link CurveFitter} directly, by passing an instance of\n+ * {@link org.apache.commons.math3.analysis.polynomials.PolynomialFunction.Parametric PolynomialFunction.Parametric}\n+ * as an argument to the\n+ * {@link CurveFitter#fit(int,org.apache.commons.math3.analysis.ParametricUnivariateFunction,double[]) fit}\n+ * method.\n  */\n-\n public class PolynomialFitter extends CurveFitter {\n     /** Polynomial degree. */\n     private final int degree;\n--- a/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math3.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer;\n+import org.apache.commons.math3.optimization.SimpleVectorValueChecker;\n import org.apache.commons.math3.util.FastMath;\n \n import org.junit.Test;\n import org.junit.Assert;\n \n+/**\n+ * Test for class {@link CurveFitter} where the function to fit is a\n+ * polynomial.\n+ */\n public class PolynomialFitterTest {\n \n     @Test\n         for (int degree = 1; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n \n-            PolynomialFitter fitter =\n-                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());\n+            CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n             for (int i = 0; i <= degree; ++i) {\n                 fitter.addObservedPoint(1.0, i, p.value(i));\n             }\n \n-            PolynomialFunction fitted = new PolynomialFunction(fitter.fit());\n+            final double[] init = new double[degree + 1];\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(Integer.MAX_VALUE,\n+                                                                          new PolynomialFunction.Parametric(),\n+                                                                          init));\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n         for (int degree = 0; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n \n-            PolynomialFitter fitter =\n-                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());\n+            CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 fitter.addObservedPoint(1.0, x,\n                                         p.value(x) + 0.1 * randomizer.nextGaussian());\n             }\n \n-            PolynomialFunction fitted = new PolynomialFunction(fitter.fit());\n+            final double[] init = new double[degree + 1];\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(Integer.MAX_VALUE,\n+                                                                          new PolynomialFunction.Parametric(),\n+                                                                          init));\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n             }\n         }\n         Assert.assertTrue(maxError > 0.01);\n-\n     }\n \n     @Test\n     @Test\n     public void testRedundantUnsolvable() {\n         // Gauss-Newton should not be able to solve redundant information\n-        DifferentiableMultivariateVectorOptimizer optimizer =\n-            new GaussNewtonOptimizer(true);\n-        checkUnsolvableProblem(optimizer, false);\n+        checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false);\n     }\n \n     private void checkUnsolvableProblem(DifferentiableMultivariateVectorOptimizer optimizer,\n         for (int degree = 0; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n \n-            PolynomialFitter fitter = new PolynomialFitter(degree, optimizer);\n+            CurveFitter fitter = new CurveFitter(optimizer);\n \n             // reusing the same point over and over again does not bring\n             // information, the problem cannot be solved in this case for\n             }\n \n             try {\n-                fitter.fit();\n+                final double[] init = new double[degree + 1];\n+                fitter.fit(Integer.MAX_VALUE,\n+                           new PolynomialFunction.Parametric(),\n+                           init);\n                 Assert.assertTrue(solvable || (degree == 0));\n             } catch(ConvergenceException e) {\n                 Assert.assertTrue((! solvable) && (degree > 0));", "timestamp": 1339022022, "metainfo": ""}