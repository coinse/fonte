{"sha": "9c8d2c79c1ef565337599849cd066ff63b8d5816", "log": "added missing @Override annotations  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public String getLocalizedMessage() {\n         return getMessage(Locale.getDefault());\n     }\n     /**\n      * Prints the stack trace of this exception to the standard error stream.\n      */\n+    @Override\n     public void printStackTrace() {\n         printStackTrace(System.err);\n     }\n      *\n      * @param out  the <code>PrintStream</code> to use for output\n      */\n+    @Override\n     public void printStackTrace(PrintStream out) {\n         synchronized (out) {\n             PrintWriter pw = new PrintWriter(out, false);\n--- a/src/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public String getLocalizedMessage() {\n         return getMessage(Locale.getDefault());\n     }\n     /**\n      * Prints the stack trace of this exception to the standard error stream.\n      */\n+    @Override\n     public void printStackTrace() {\n         printStackTrace(System.err);\n     }\n      *\n      * @param out  the <code>PrintStream</code> to use for output\n      */\n+    @Override\n     public void printStackTrace(final PrintStream out) {\n         synchronized (out) {\n             PrintWriter pw = new PrintWriter(out, false);\n             private static final long serialVersionUID = 7705628723242533939L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = -3394748305449283486L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = 279461544586092584L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = -6555453980658317913L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = -95247648156277208L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = 6134247282754009421L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = 7304273322489425799L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = -3075660477939965216L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n             private static final long serialVersionUID = -1103502177342465975L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public String getLocalizedMessage() {\n                 return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    * Get the non-translated/translated messages arrays from this resource bundle.\n    * @return non-translated/translated messages arrays\n    */\n+  @Override\n   public Object[][] getContents() {\n     return (Object[][]) contents.clone();\n   }\n--- a/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void verifyIterationCount() throws IllegalArgumentException {\n         super.verifyIterationCount();\n         // at most 32 bisection refinements due to higher order divider\n--- a/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void verifyIterationCount() throws IllegalArgumentException {\n         super.verifyIterationCount();\n         // at most 64 bisection refinements\n--- a/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void verifyIterationCount() throws IllegalArgumentException {\n         super.verifyIterationCount();\n         // at most 64 bisection refinements\n--- a/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n      * @return a string representation of the polynomial\n \n      */\n+    @Override\n      public String toString() {\n \n        StringBuffer s = new StringBuffer();\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImpl.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public UnivariateRealSolver newDefaultSolver() {\n         return newBrentSolver();\n     }\n     \n     /** {@inheritDoc} */\n+    @Override\n     public UnivariateRealSolver newBisectionSolver() {\n         return new BisectionSolver();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public UnivariateRealSolver newBrentSolver() {\n         return new BrentSolver();\n     }\n     \n     /** {@inheritDoc} */\n+    @Override\n     public UnivariateRealSolver newNewtonSolver() {\n         return new NewtonSolver();\n     }\n     \n     /** {@inheritDoc} */\n+    @Override\n     public UnivariateRealSolver newSecantSolver() {\n         return new SecantSolver();\n     }\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n      *         not equal to this Complex instance\n      * \n      */\n+    @Override\n     public boolean equals(Object other) {\n         boolean ret;\n         \n      * \n      * @return a hash code value for this object\n      */\n+    @Override\n     public int hashCode() {\n         if (isNaN()) {\n             return 7;\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n+    @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n         \n      * @return the parsed object.\n      * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n+    @Override\n     public Object parseObject(String source, ParsePosition pos) {\n         return parse(source, pos);\n     }\n--- a/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n      * computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if <code>x0 > x1</code>\n      */\n+    @Override\n     public double cumulativeProbability(double x0, double x1)\n         throws MathException {\n         if (x0 > x1) {\n--- a/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double inverseCumulativeProbability(double p) throws MathException {\n         if (p == 0) {\n             return 0;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double getInitialDomain(double p) {\n         return p;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         return 0;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         return 1;\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double cumulativeProbability(double x0, double x1) throws MathException {\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected int getDomainLowerBound(double p) {\n         return -1;\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected int getDomainUpperBound(double p) {\n         return getNumberOfTrials();\n     }\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n+    @Override\n     public double cumulativeProbability(int x) throws MathException {\n         double ret;\n         if (x < 0) {\n      *            computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if p < 0 or p > 1\n      */\n+    @Override\n     public int inverseCumulativeProbability(final double p) throws MathException {\n         // handle extreme values explicitly\n         if (p == 0) {\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(double p) {\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         double ret;\n \n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         double ret;\n \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         double ret;\n \n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(final double p)\n         throws MathException {\n         if (p == 0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         return Double.MIN_VALUE * getGamma().getBeta();\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         // NOTE: chi squared is skewed to the left\n         // NOTE: therefore, P(X < &mu;) > .5\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         // NOTE: chi squared is skewed to the left\n         // NOTE: therefore, P(X < &mu;) > .5\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n      *            computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if p < 0 or p > 1.\n      */\n+    @Override\n     public double inverseCumulativeProbability(double p) throws MathException {\n         double ret;\n         \n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         return 0;\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         // NOTE: exponential is skewed to the left\n         // NOTE: therefore, P(X < &mu;) > .5\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         // TODO: try to improve on this estimate\n         // TODO: what should really happen here is not derive from AbstractContinuousDistribution\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(final double p) \n         throws MathException {\n         if (p == 0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         return 0.0;\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         return Double.MAX_VALUE;\n     }\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         double ret = 1.0;\n         double d = getDenominatorDegreesOfFreedom();\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(final double p) \n     throws MathException {\n         if (p == 0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         // TODO: try to improve on this estimate\n         return Double.MIN_VALUE;\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         // TODO: try to improve on this estimate\n         // NOTE: gamma is skewed to the left\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         // TODO: try to improve on this estimate\n         // Gamma is skewed to the left, therefore, P(X < &mu;) > .5\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n+    @Override\n     public double cumulativeProbability(int x) {\n         double ret;\n         \n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected int getDomainLowerBound(double p) {\n         return getLowerDomain(getPopulationSize(), getNumberOfSuccesses(),\n             getSampleSize());\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected int getDomainUpperBound(double p) {\n         return getUpperDomain(getSampleSize(), getNumberOfSuccesses());\n     }\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(final double p) \n     throws MathException {\n         if (p == 0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         double ret;\n \n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         double ret;\n \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         double ret;\n \n--- a/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n      * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n      *         <code>p</code>\n      */\n+    @Override\n     protected int getDomainLowerBound(double p) {\n         return -1;\n     }\n      * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n      *         <code>p</code>\n      */\n+    @Override\n     protected int getDomainUpperBound(double p) {\n         // use MAX - 1 because MAX causes loop\n         return Integer.MAX_VALUE - 1;\n      * @throws MathException if the cumulative probability can not be computed\n      *         due to convergence or other numerical errors\n      */\n+    @Override\n     public double cumulativeProbability(int x) throws MathException {\n         double ret;\n         if (x < 0) {\n      *         computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if p < 0 or p > 1\n      */\n+    @Override\n     public int inverseCumulativeProbability(final double p)\n         throws MathException {\n         int ret;\n--- a/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n+    @Override\n     public double cumulativeProbability(int x) throws MathException {\n         if (x < 0) {\n             return 0;\n      * @param p the desired probability for the critical value\n      * @return domain lower bound\n      */\n+    @Override\n     protected int getDomainLowerBound(double p) {\n         return 0;\n     }\n      * @param p the desired probability for the critical value\n      * @return domain upper bound\n      */\n+    @Override\n     protected int getDomainUpperBound(double p) {\n         return Integer.MAX_VALUE;\n     }\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(final double p) \n     throws MathException {\n         if (p == 0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         return -Double.MAX_VALUE;\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         return Double.MAX_VALUE;\n     }\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         return 0.0;\n     }\n--- a/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n+    @Override\n     public double inverseCumulativeProbability(double p) {\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainLowerBound(double p) {\n         return 0.0;\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected double getDomainUpperBound(double p) {\n         return Double.MAX_VALUE;\n     }\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+    @Override\n     protected double getInitialDomain(double p) {\n         // use median\n         return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());\n--- a/src/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n      * @param x the value at which the PDF is evaluated.\n      * @return Zipf distribution function evaluated at x\n      */\n+    @Override\n     public double cumulativeProbability(final int x) {\n         if (x <= 0) {\n             return 0.0;\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n+    @Override\n     protected int getDomainLowerBound(final double p) {\n         return 0;\n     }\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n+    @Override\n     protected int getDomainUpperBound(final double p) {\n         return numberOfElements;\n     }\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n      * @see EstimationProblem\n      *\n      */\n+    @Override\n     public void estimate(EstimationProblem problem)\n     throws EstimationException {\n \n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n    * @see #setParRelativeTolerance\n    * @see #setOrthoTolerance\n    */\n+  @Override\n   public void estimate(EstimationProblem problem)\n     throws EstimationException {\n \n--- a/src/java/org/apache/commons/math/fraction/AbstractFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/AbstractFormat.java\n      * @return a reference to the appended buffer\n      * @see {@link #format(Object, StringBuffer, FieldPosition)}\n      */\n+    @Override\n     public StringBuffer format(final double value,\n                                final StringBuffer buffer, final FieldPosition position) {\n         return format(Double.valueOf(value), buffer, position);\n      * @return a reference to the appended buffer\n      * @see {@link #format(Object, StringBuffer, FieldPosition)}\n      */\n+    @Override\n     public StringBuffer format(final long value,\n                                final StringBuffer buffer, final FieldPosition position) {\n         return format(Long.valueOf(value), buffer, position);\n--- a/src/java/org/apache/commons/math/fraction/BigFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/BigFractionFormat.java\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n+    @Override\n     public StringBuffer format(final Object obj,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n \n      * @exception ParseException if the beginning of the specified string\n      *            cannot be parsed.\n      */\n+    @Override\n     public BigFraction parse(final String source) throws ParseException {\n         final ParsePosition parsePosition = new ParsePosition(0);\n         final BigFraction result = parse(source, parsePosition);\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link BigFraction} object.\n      */\n+    @Override\n     public BigFraction parse(final String source, final ParsePosition pos) {\n         final int initialIndex = pos.getIndex();\n \n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n      * the numerator divided by denominator.\n      * @return the fraction as a <tt>double</tt>\n      */\n+    @Override\n     public double doubleValue() {\n         return (double)numerator / (double)denominator;\n     }\n      *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal\n      *         to this fraction instance.\n      */\n+    @Override\n     public boolean equals(Object other) {\n         boolean ret;\n         \n      * the numerator divided by denominator.\n      * @return the fraction as a <tt>float</tt>\n      */\n+    @Override\n     public float floatValue() {\n         return (float)doubleValue();\n     }\n      * Gets a hashCode for the fraction.\n      * @return a hash code value for this object\n      */\n+    @Override\n     public int hashCode() {\n         return 37 * (37 * 17 + getNumerator()) + getDenominator();\n     }\n      * of the fraction.\n      * @return the whole number fraction part\n      */\n+    @Override\n     public int intValue() {\n         return (int)doubleValue();\n     }\n      * of the fraction.\n      * @return the whole number fraction part\n      */\n+    @Override\n     public long longValue() {\n         return (long)doubleValue();\n     }\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n+    @Override\n     public StringBuffer format(final Object obj,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n         StringBuffer ret = null;\n      * @exception ParseException if the beginning of the specified string\n      *            cannot be parsed.\n      */\n+    @Override\n     public Fraction parse(final String source) throws ParseException {\n         final ParsePosition parsePosition = new ParsePosition(0);\n         final Fraction result = parse(source, parsePosition);\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n      */\n+    @Override\n     public Fraction parse(final String source, final ParsePosition pos) {\n         final int initialIndex = pos.getIndex();\n \n--- a/src/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      */\n+    @Override\n     public StringBuffer format(final BigFraction fraction,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n         \n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link BigFraction} object.\n      */\n+    @Override\n     public BigFraction parse(final String source, final ParsePosition pos) {\n         // try to parse improper BigFraction\n         BigFraction ret = super.parse(source, pos);\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      */\n+    @Override\n     public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n             FieldPosition pos) {\n         \n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n      */\n+    @Override\n     public Fraction parse(String source, ParsePosition pos) {\n         // try to parse improper fraction\n         Fraction ret = super.parse(source, pos);\n--- a/src/java/org/apache/commons/math/geometry/RotationOrder.java\n+++ b/src/java/org/apache/commons/math/geometry/RotationOrder.java\n   /** Get a string representation of the instance.\n    * @return a string representation of the instance (in fact, its name)\n    */\n+  @Override\n   public String toString() {\n     return name;\n   }\n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n    *         not equal to this Vector3D instance\n    * \n    */\n+  @Override\n   public boolean equals(Object other) {\n \n     if (this == other) { \n    * \n    * @return a hash code value for this object\n    */\n+  @Override\n   public int hashCode() {\n       if (isNaN()) {\n           return 8;\n   /** Get a string representation of this vector.\n    * @return a string representation of this vector\n    */\n+  @Override\n   public String toString() {\n       return DEFAULT_FORMAT.format(this);\n   }\n--- a/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n+    @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n                                FieldPosition pos) {\n \n      * @return the parsed object.\n      * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n+    @Override\n     public Object parseObject(String source, ParsePosition pos) {\n         return parse(source, pos);\n     }\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     /** Cached LU solver.\n      * @deprecated as of release 2.0, since all methods using this are deprecated\n      */\n+    @Deprecated\n     private DecompositionSolver lu;\n \n     /**\n             private static final long serialVersionUID = 4572851009041214720L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public double visit(final int row, final int column, final double value) {\n                 return getEntry(selectedRows[row], selectedColumns[column]);\n             }\n             private int startColumn;\n \n             /** {@inheritDoc} */\n+            @Override\n             public void start(final int rows, final int columns,\n                               final int startRow, final int endRow,\n                               final int startColumn, final int endColumn) {\n             }\n \n             /** {@inheritDoc} */\n+            @Override\n             public void visit(final int row, final int column, final double value) {\n                 destination[row - startRow][column - startColumn] = value;\n             }\n             private static final long serialVersionUID = 2482589609486637597L;\n \n             /** {@inheritDoc} */\n+            @Override\n             public void visit(final int row, final int column, final double value) {\n                 out.setEntry(column, row, value);\n             }\n      * Get a string representation for this matrix.\n      * @return a string representation for this matrix\n      */\n+    @Override\n     public String toString() {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n+    @Override\n     public boolean equals(final Object object) {\n         if (object == this ) {\n             return true;\n      * \n      * @return hashcode for matrix\n      */\n+    @Override\n     public int hashCode() {\n         int ret = 7;\n         final int nRows = getRowDimension();\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n      * Get a string representation for this matrix.\n      * @return a string representation for this matrix\n      */\n+    @Override\n     public String toString() {\n         StringBuffer res = new StringBuffer();\n         res.append(\"BigMatrixImpl{\");\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n+    @Override\n     public boolean equals(Object object) {\n         if (object == this ) {\n             return true;\n      * \n      * @return hashcode for matrix\n      */\n+    @Override\n     public int hashCode() {\n         int ret = 7;\n         final int nRows = getRowDimension();\n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n         return new DenseRealMatrix(rowDimension, columnDimension);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix copy() {\n \n         // create an empty matrix\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix add(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix subtract(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix scalarAdd(final double d)\n         throws IllegalArgumentException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix scalarMultiply(final double d)\n         throws IllegalArgumentException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix multiply(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[][] getData() {\n \n         final double[][] data = new double[getRowDimension()][getColumnDimension()];\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getNorm() {\n         final double[] colSums = new double[BLOCK_SIZE];\n         double maxColSum = 0;\n     }\n     \n     /** {@inheritDoc} */\n+    @Override\n     public double getFrobeniusNorm() {\n         double sum2 = 0;\n         for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix getSubMatrix(final int startRow, final int endRow,\n                                    final int startColumn, final int endColumn)\n         throws MatrixIndexException {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix getRowMatrix(final int row)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setRowMatrix(final int row, final RealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n     }\n     \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix getColumnMatrix(final int column)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setColumnMatrix(final int column, final RealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n         }\n \n     }\n-    \n-    /** {@inheritDoc} */\n+\n+    /** {@inheritDoc} */\n+    @Override\n     public RealVector getRowVector(final int row)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setRowVector(final int row, final RealVector vector)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector getColumnVector(final int column)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setColumnVector(final int column, final RealVector vector)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] getRow(final int row)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setRow(final int row, final double[] array)\n         throws MatrixIndexException, InvalidMatrixException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] getColumn(final int column)\n         throws MatrixIndexException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setColumn(final int column, final double[] array)\n         throws MatrixIndexException, InvalidMatrixException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getEntry(final int row, final int column)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setEntry(final int row, final int column, final double value)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void addToEntry(final int row, final int column, final double increment)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void multiplyEntry(final int row, final int column, final double factor)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix transpose() {\n \n         final int nRows = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int getRowDimension() {\n         return rows;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int getColumnDimension() {\n         return columns;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] operate(final double[] v)\n         throws IllegalArgumentException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] preMultiply(final double[] v)\n         throws IllegalArgumentException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n         return new RealMatrixImpl(rowDimension, columnDimension);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix copy() {\n         return new RealMatrixImpl(copyOut(), false);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix add(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix subtract(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix multiply(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[][] getData() {\n         return copyOut();\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n     throws MatrixIndexException {\n         if (data == null) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getEntry(final int row, final int column)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setEntry(final int row, final int column, final double value)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void addToEntry(final int row, final int column, final double increment)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void multiplyEntry(final int row, final int column, final double factor)\n         throws MatrixIndexException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int getRowDimension() {\n         return (data == null) ? 0 : data.length;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int getColumnDimension() {\n         return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] operate(final double[] v)\n         throws IllegalArgumentException {\n         final int nRows = this.getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] preMultiply(final double[] v)\n         throws IllegalArgumentException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n--- a/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n+    @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n                                FieldPosition pos) {\n \n      * @return the parsed object.\n      * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n+    @Override\n     public Object parseObject(String source, ParsePosition pos) {\n         return parse(source, pos);\n     }\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public String toString(){\n         return DEFAULT_FORMAT.format(this);\n     }\n      *         not equal to this Vector3D instance\n      * \n      */\n+    @Override\n     public boolean equals(Object other) {\n \n       if (this == other) { \n      * <p>All NaN values have the same hash code.</p>\n      * @return a hash code value for this object\n      */\n+    @Override\n     public int hashCode() {\n         if (isNaN()) {\n             return 9;\n--- a/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix add(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix subtract(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthStepInterpolator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected StepInterpolator doCopy() {\n         return new AdamsBashforthStepInterpolator(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void initializeCoefficients() {\n \n         neville  = new double[previousF.length];\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void storeTime(final double t) {\n         nonTruncatedEnd = t;\n         nonTruncatedH   = nonTruncatedEnd - previousTime;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setInterpolatedTime(final double time)\n         throws DerivativeException {\n         interpolatedTime = time;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n         interpolateDerivatives();\n         interpolateState(theta);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void writeExternal(final ObjectOutput out)\n         throws IOException {\n         super.writeExternal(out);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void readExternal(final ObjectInput in)\n         throws IOException {\n         nonTruncatedEnd = in.readDouble();\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonStepInterpolator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected StepInterpolator doCopy() {\n         return new AdamsMoultonStepInterpolator(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void initializeCoefficients() {\n \n         neville  = new double[previousF.length];\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void storeTime(final double t) {\n         nonTruncatedEnd = t;\n         nonTruncatedH   = nonTruncatedEnd - previousTime;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setInterpolatedTime(final double time)\n         throws DerivativeException {\n         interpolatedTime = time;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n         interpolateDerivatives();\n         interpolateState(theta);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void writeExternal(final ObjectOutput out)\n         throws IOException {\n         super.writeExternal(out);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void readExternal(final ObjectInput in)\n         throws IOException {\n         nonTruncatedEnd = in.readDouble();\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n    * @param y placeholder where to put the state vector\n    * @exception IntegratorException if some inconsistency is detected\n    */\n+  @Override\n   protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n                               final double t0, final double[] y0,\n                               final double t, final double[] y)\n     throws DerivativeException, IntegratorException;\n \n   /** {@inheritDoc} */\n+  @Override\n   public double getCurrentStepStart() {\n     return stepStart;\n   }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected StepInterpolator doCopy() {\n         return new ClassicalRungeKuttaStepInterpolator(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void computeInterpolatedState(final double theta,\n                                             final double oneMinusThetaH)\n         throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public int getOrder() {\n     return 5;\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected double estimateError(final double[][] yDotK,\n                                  final double[] y0, final double[] y1,\n                                  final double h) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new DormandPrince54StepInterpolator(this);\n   }\n \n \n   /** {@inheritDoc} */\n+  @Override\n   public void reinitialize(final FirstOrderDifferentialEquations equations,\n                            final double[] y, final double[][] yDotK, final boolean forward) {\n     super.reinitialize(equations, y, yDotK, forward);\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void storeTime(final double t) {\n     super.storeTime(t);\n     vectorsInitialized = false;\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public int getOrder() {\n     return 8;\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected double estimateError(final double[][] yDotK,\n                                  final double[] y0, final double[] y1,\n                                  final double h) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new DormandPrince853StepInterpolator(this);\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void reinitialize(final FirstOrderDifferentialEquations equations,\n                            final double[] y, final double[][] yDotK, final boolean forward) {\n \n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void storeTime(final double t) {\n     super.storeTime(t);\n     vectorsInitialized = false;\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n   }\n  \n   /** {@inheritDoc} */\n+  @Override\n   protected void doFinalize()\n     throws DerivativeException {\n \n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public double integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0,\n                           final double t, final double[] y)\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new EulerStepInterpolator(this);\n   }\n \n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new GillStepInterpolator(this);\n   }\n \n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void addStepHandler (final StepHandler handler) {\n \n     super.addStepHandler(handler);\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void addEventHandler(final EventHandler function,\n                               final double maxCheckInterval,\n                               final double convergence,\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public double integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0, final double t, final double[] y)\n   throws DerivativeException, IntegratorException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new GraggBulirschStoerStepInterpolator(this);\n   }\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n   }\n     \n   /** {@inheritDoc} */\n+  @Override\n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public int getOrder() {\n     return 5;\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected double estimateError(final double[][] yDotK,\n                                  final double[] y0, final double[] y1,\n                                  final double h) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new HighamHall54StepInterpolator(this);\n   }\n \n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new MidpointStepInterpolator(this);\n   }\n \n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new ThreeEighthesStepInterpolator(this);\n   }\n \n \n   /** {@inheritDoc} */\n+  @Override\n   protected void computeInterpolatedState(final double theta,\n                                           final double oneMinusThetaH)\n       throws DerivativeException {\n--- a/src/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n   /** Really copy the finalized instance.\n    * @return a copy of the finalized instance\n    */\n+  @Override\n   protected StepInterpolator doCopy() {\n     return new DummyStepInterpolator(this);\n   }\n    * @throws DerivativeException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n+  @Override\n   protected void computeInterpolatedState(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n       System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n    * @param out output channel\n    * @exception IOException if the instance cannot be written\n    */\n+  @Override\n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n     // save the state of the base class\n    * @param in input channel\n    * @exception IOException if the instance cannot be read\n    */\n+  @Override\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n--- a/src/java/org/apache/commons/math/ode/sampling/MultistepStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/MultistepStepInterpolator.java\n     protected abstract void initializeCoefficients();\n \n     /** {@inheritDoc} */\n+    @Override\n     public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void readExternal(final ObjectInput in)\n     throws IOException {\n \n--- a/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n--- a/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException {\n \n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public VectorialPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n--- a/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected VectorialPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n--- a/src/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected RealPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n         try {\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealPointValuePair doOptimize()\n         throws OptimizationException {\n         final SimplexTableau tableau =\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n          * @param delta  grid size\n          * @throws IOException if an IO error occurs\n          */\n+        @Override\n         public void computeBinStats(double min, double delta)\n                 throws IOException {\n             String str = null;\n          * \n          * @throws IOException if an IOError occurs\n          */\n+        @Override\n         public void computeStats() throws IOException {\n             String str = null;\n             double val = 0.0;\n          * \n          * @throws IOException if an IO error occurs\n          */\n+        @Override\n         public void computeStats() throws IOException {\n             sampleStats = new SummaryStatistics();\n             for (int i = 0; i < inputArray.length; i++) {\n          * @param delta  grid size\n          * @throws IOException  if an IO error occurs\n          */\n+        @Override\n         public void computeBinStats(double min, double delta)\n             throws IOException {\n             for (int i = 0; i < inputArray.length; i++) {\n--- a/src/java/org/apache/commons/math/random/RandomAdaptor.java\n+++ b/src/java/org/apache/commons/math/random/RandomAdaptor.java\n      * <code>boolean</code> value from this random number generator's\n      * sequence\n      */\n+    @Override\n     public boolean nextBoolean() {\n         return randomGenerator.nextBoolean();\n     }\n      * @param bytes the non-null byte array in which to put the \n      * random bytes\n      */\n+    @Override\n     public void nextBytes(byte[] bytes) {\n         randomGenerator.nextBytes(bytes);\n     }\n      *  <code>double</code> value between <code>0.0</code> and\n      *  <code>1.0</code> from this random number generator's sequence\n      */  \n+    @Override\n     public double nextDouble() {\n         return randomGenerator.nextDouble();\n     }\n      * value between <code>0.0</code> and <code>1.0</code> from this\n      * random number generator's sequence\n      */\n+    @Override\n     public float nextFloat() {\n         return randomGenerator.nextFloat();\n     }\n      * standard deviation <code>1.0</code> from this random number\n      *  generator's sequence\n      */\n+    @Override\n     public double nextGaussian() {\n         return randomGenerator.nextGaussian();\n     }\n      * @return the next pseudorandom, uniformly distributed <code>int</code>\n      *  value from this random number generator's sequence\n      */\n+    @Override\n     public int nextInt() {\n         return randomGenerator.nextInt();\n     }\n      * value between 0 (inclusive) and n (exclusive).\n      * @throws IllegalArgumentException  if n is not positive.\n      */\n+    @Override\n     public int nextInt(int n) {\n         return randomGenerator.nextInt(n);\n     }\n      * @return  the next pseudorandom, uniformly distributed <code>long</code>\n      *value from this random number generator's sequence\n      */\n+    @Override\n     public long nextLong() {\n         return randomGenerator.nextLong();\n     }\n      *\n      * @param seed the seed value\n      */\n+    @Override\n     public void setSeed(long seed) {\n         if (randomGenerator != null) {  // required to avoid NPE in constructor\n             randomGenerator.setSeed(seed);\n--- a/src/java/org/apache/commons/math/special/Beta.java\n+++ b/src/java/org/apache/commons/math/special/Beta.java\n \n                 private static final long serialVersionUID = -7658917278956100597L;\n \n+                @Override\n                 protected double getB(int n, double x) {\n                     double ret;\n                     double m;\n                     return ret;\n                 }\n \n+                @Override\n                 protected double getA(int n, double x) {\n                     return 1.0;\n                 }\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n \n                 private static final long serialVersionUID = 5378525034886164398L;\n \n+                @Override\n                 protected double getA(int n, double x) {\n                     return ((2.0 * n) + 1.0) - a + x;\n                 }\n \n+                @Override\n                 protected double getB(int n, double x) {\n                     return n * (a - n);\n                 }\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n      * \n      * @return a string representation.\n      */\n+    @Override\n     public String toString() {\n         NumberFormat nf = NumberFormat.getPercentInstance();\n         StringBuffer outBuffer = new StringBuffer();\n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n      * @return the value of the statistic applied to the input array\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n      */\n+    @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n             throw new IllegalArgumentException(\"input value array is null\");\n      * @return the value of the statistic applied to the included array entries\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         if (test(values, begin, length)) {\n             clear();\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public abstract StorelessUnivariateStatistic copy();\n \n     /**\n      * @param object object to test equality against.\n      * @return true if object returns the same value as this\n      */\n+    @Override\n     public boolean equals(Object object) {\n         if (object == this ) {\n             return true;\n      * \n      * @return hash code\n      */\n+    @Override\n     public int hashCode() {\n         return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());\n     }\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n      * \n      * @return String with line feeds displaying statistics\n      */\n+    @Override\n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n         String endl = \"\\n\";\n--- a/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n      * have been added.\n      * @return String with line feeds displaying statistics\n      */\n+    @Override\n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n         outBuffer.append(\"MultivariateSummaryStatistics:\\n\");\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n+    @Override\n     public boolean equals(Object object) {\n         if (object == this ) {\n             return true;\n      * \n      * @return hash code\n      */\n+    @Override\n     public int hashCode() {\n         int result = 31 + MathUtils.hash(getGeometricMean());\n         result = result * 31 + MathUtils.hash(getGeometricMean());\n--- a/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n+    @Override\n     public boolean equals(Object object) {\n         if (object == this ) {\n             return true;\n      * \n      * @return hash code\n      */\n+    @Override\n     public int hashCode() {\n         int result = 31 + MathUtils.hash(getMax());\n         result = result * 31 + MathUtils.hash(getMean());\n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n      * @return String with line feeds displaying statistics\n      * @since 1.2\n      */\n+    @Override\n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n         String endl = \"\\n\";\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n+    @Override\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n      * Returns hash code based on values of statistics\n      * @return hash code\n      */\n+    @Override\n     public int hashCode() {\n         int result = 31 + MathUtils.hash(getGeometricMean());\n         result = result * 31 + MathUtils.hash(getGeometricMean());\n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void addValue(double v) {\n         super.addValue(v);\n     }\n \n     /**\n-     * Apply the given statistic to this univariate collection.\n-     * @param stat the statistic to apply\n-     * @return the computed value of the statistic.\n+     * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double apply(UnivariateStatistic stat) {\n         return super.apply(stat);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void clear() {\n         super.clear();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getElement(int index) {\n         return super.getElement(index);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized long getN() {\n         return super.getN();\n     }\n \n     /** \n-     * Returns the standard deviation of the available values.\n-     * @return The standard deviation, Double.NaN if no values have been added \n-     * or 0.0 for a single value set. \n+     * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getStandardDeviation() {\n         return super.getStandardDeviation();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getValues() {\n         return super.getValues();\n     }\n \n     /**\n-     * Access the window size.\n-     * @return the current window size.\n+     * {@inheritDoc}\n      */\n+    @Override\n     public synchronized int getWindowSize() {\n         return super.getWindowSize();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setWindowSize(int windowSize) {\n         super.setWindowSize(windowSize);\n     }\n \n     /**\n-     * Generates a text report displaying univariate statistics from values\n-     * that have been added.  Each statistic is displayed on a separate\n-     * line.\n-     * \n-     * @return String with line feeds displaying statistics\n+     * {@inheritDoc}\n      */\n+    @Override\n     public synchronized String toString() {\n         return super.toString();\n     }\n      * \n      * @return a copy of this\n      */\n+    @Override\n     public synchronized SynchronizedDescriptiveStatistics copy() {\n         SynchronizedDescriptiveStatistics result = \n             new SynchronizedDescriptiveStatistics();\n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void addValue(double[] value)\n       throws DimensionMismatchException {\n       super.addValue(value);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized int getDimension() {\n         return super.getDimension();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized long getN() {\n         return super.getN();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getSum() {\n         return super.getSum();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getSumSq() {\n         return super.getSumSq();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getSumLog() {\n         return super.getSumLog();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getMean() {\n         return super.getMean();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getStandardDeviation() {\n         return super.getStandardDeviation();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized RealMatrix getCovariance() {\n         return super.getCovariance();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getMax() {\n         return super.getMax();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getMin() {\n         return super.getMin();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double[] getGeometricMean() {\n         return super.getGeometricMean();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized String toString() {\n         return super.toString();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void clear() {\n         super.clear();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized boolean equals(Object object) {\n         return super.equals(object);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized int hashCode() {\n         return super.hashCode();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getSumImpl() {\n         return super.getSumImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n       throws DimensionMismatchException {\n         super.setSumImpl(sumImpl);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getSumsqImpl() {\n         return super.getSumsqImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n       throws DimensionMismatchException {\n         super.setSumsqImpl(sumsqImpl);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getMinImpl() {\n         return super.getMinImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n       throws DimensionMismatchException {\n         super.setMinImpl(minImpl);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getMaxImpl() {\n         return super.getMaxImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n       throws DimensionMismatchException {\n         super.setMaxImpl(maxImpl);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getSumLogImpl() {\n         return super.getSumLogImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n       throws DimensionMismatchException {\n         super.setSumLogImpl(sumLogImpl);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getGeoMeanImpl() {\n         return super.getGeoMeanImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n       throws DimensionMismatchException {\n         super.setGeoMeanImpl(geoMeanImpl);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic[] getMeanImpl() {\n         return super.getMeanImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n       throws DimensionMismatchException {\n         super.setMeanImpl(meanImpl);\n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StatisticalSummary getSummary() {\n         return super.getSummary();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void addValue(double value) {\n         super.addValue(value);\n     }\n     /** \n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized long getN() {\n         return super.getN();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getSum() {\n         return super.getSum();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getSumsq() {\n         return super.getSumsq();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getMean() {\n         return super.getMean();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getStandardDeviation() {\n         return super.getStandardDeviation();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getVariance() {\n         return super.getVariance();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getMax() {\n         return super.getMax();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getMin() {\n         return super.getMin();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized double getGeometricMean() {\n         return super.getGeometricMean();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized String toString() {\n         return super.toString();\n     }\n     /** \n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void clear() {\n         super.clear();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized boolean equals(Object object) {\n         return super.equals(object);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized int hashCode() {\n         return super.hashCode();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getSumImpl() {\n         return super.getSumImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n         super.setSumImpl(sumImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getSumsqImpl() {\n         return super.getSumsqImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n         super.setSumsqImpl(sumsqImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getMinImpl() {\n         return super.getMinImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setMinImpl(StorelessUnivariateStatistic minImpl) {\n         super.setMinImpl(minImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getMaxImpl() {\n         return super.getMaxImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n         super.setMaxImpl(maxImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getSumLogImpl() {\n         return super.getSumLogImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n         super.setSumLogImpl(sumLogImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getGeoMeanImpl() {\n         return super.getGeoMeanImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n         super.setGeoMeanImpl(geoMeanImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getMeanImpl() {\n         return super.getMeanImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n         super.setMeanImpl(meanImpl);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized StorelessUnivariateStatistic getVarianceImpl() {\n         return super.getVarianceImpl();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public synchronized void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n         super.setVarianceImpl(varianceImpl);\n     }\n      * \n      * @return a copy of this\n      */\n+    @Override\n     public synchronized SynchronizedSummaryStatistics copy() {\n         SynchronizedSummaryStatistics result = \n             new SynchronizedSummaryStatistics();\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n     /**\n      * {@inheritDoc}\n      */\n+     @Override\n     public void increment(final double d) {\n         if (n == 0) {\n             m1 = 0.0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         m1 = Double.NaN;\n         n = 0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return m1;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public FirstMoment copy() {\n         FirstMoment result = new FirstMoment();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n     /**\n      * {@inheritDoc}\n      */\n+     @Override\n     public void increment(final double d) {\n         if (n < 1) {\n             m4 = 0.0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return m4;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         super.clear();\n         m4 = Double.NaN;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public FourthMoment copy() {\n         FourthMoment result = new FourthMoment();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public GeometricMean copy() {\n         GeometricMean result = new GeometricMean();\n         copy(this, result);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         sumOfLogs.increment(d);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         if (sumOfLogs.getN() > 0) {\n             return Math.exp(sumOfLogs.getResult() / (double) sumOfLogs.getN());\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         sumOfLogs.clear();\n     }\n      * @throws IllegalArgumentException if the input array is null or the array\n      * index parameters are not valid\n      */\n+    @Override\n     public double evaluate(\n         final double[] values, final int begin, final int length) {\n         return Math.exp(\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         double kurtosis = Double.NaN;\n         if (moment.getN() > 3) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         if (incMoment) {\n             moment.clear();\n      * @throws IllegalArgumentException if the input array is null or the array\n      * index parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         // Initialize the kurtosis  \n         double kurt = Double.NaN;   \n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Kurtosis copy() {\n         Kurtosis result = new Kurtosis();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         if (incMoment) {\n             moment.clear();\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return moment.m1;\n     }\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         if (test(values, begin, length)) {\n             Sum sum = new Sum();\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Mean copy() {\n         Mean result = new Mean();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (n < 1) {\n             m1 = m2 = 0.0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         super.clear();\n         m2 = Double.NaN;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return m2;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public SecondMoment copy() {\n         SecondMoment result = new SecondMoment();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n      * \n      * @return the skewness of the available values.\n      */\n+    @Override\n     public double getResult() {\n         \n         if (moment.n < 3) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         if (incMoment) {\n             moment.clear();\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values,final int begin, \n             final int length) {\n \n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Skewness copy() {\n         Skewness result = new Skewness();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         variance.increment(d);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return Math.sqrt(variance.getResult());\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         variance.clear();\n     }\n      * @return the standard deviation of the values or Double.NaN if length = 0\n      * @throws IllegalArgumentException if the array is null\n      */  \n+    @Override\n     public double evaluate(final double[] values)  {\n         return Math.sqrt(variance.evaluate(values));\n     }\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length)  {\n        return Math.sqrt(variance.evaluate(values, begin, length));\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public StandardDeviation copy() {\n         StandardDeviation result = new StandardDeviation();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (n < 1) {\n             m3 = m2 = m1 = 0.0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return m3;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         super.clear();\n         m3 = Double.NaN;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public ThirdMoment copy() {\n         ThirdMoment result = new ThirdMoment();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n      * list of values together to execute a two-pass algorithm.  \n      * See {@link Variance}.</p>\n      */\n+    @Override\n     public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n             if (moment.n == 0) {\n                 return Double.NaN;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         if (incMoment) {\n             moment.clear();\n      * @return the variance of the values or Double.NaN if length = 0\n      * @throws IllegalArgumentException if the array is null\n      */\n+    @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n             throw new IllegalArgumentException(\"input values array is null\");\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n \n         double var = Double.NaN;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Variance copy() {\n         Variance result = new Variance();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (d > value || Double.isNaN(value)) {\n             value = d;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         value = Double.NaN;\n         n = 0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return value;\n     }\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double max = Double.NaN;\n         if (test(values, begin, length)) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Max copy() {\n         Max result = new Max();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (d < value || Double.isNaN(value)) {\n             value = d;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         value = Double.NaN;\n         n = 0;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return value;\n     }\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         double min = Double.NaN;\n         if (test(values, begin, length)) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Min copy() {\n         Min result = new Min();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n      * @throws IllegalArgumentException if the parameters are not valid\n      * \n      */\n+    @Override\n     public double evaluate( final double[] values, final int start, final int length) {\n         return evaluate(values, start, length, quantile);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Percentile copy() {\n         Percentile result = new Percentile();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (n == 0) {\n             value = d;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return value;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         value = Double.NaN;\n         n = 0;\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double product = Double.NaN;\n         if (test(values, begin, length)) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Product copy() {\n         Product result = new Product();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (n == 0) {\n             value = d;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return value;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         value = Double.NaN;\n         n = 0;\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sum = Double.NaN;\n         if (test(values, begin, length)) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Sum copy() {\n         Sum result = new Sum();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         value += Math.log(d);\n         n++;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         if (n > 0) {\n             return value;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         value = 0d;\n         n = 0;\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sumLog = Double.NaN;\n         if (test(values, begin, length)) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public SumOfLogs copy() {\n         SumOfLogs result = new SumOfLogs();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void increment(final double d) {\n         if (n == 0) {\n             value = d * d;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getResult() {\n         return value;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         value = Double.NaN;\n         n = 0;\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n+    @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         double sumSq = Double.NaN;\n         if (test(values, begin, length)) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public SumOfSquares copy() {\n         SumOfSquares result = new SumOfSquares();\n         copy(this, result);\n--- a/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n      * </pre>\n      * @return beta\n      */\n+    @Override\n     protected RealMatrix calculateBeta() {\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XT = X.transpose();\n      * </pre>\n      * @return The beta variance matrix\n      */\n+    @Override\n     protected RealMatrix calculateBetaVariance() {\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n      * </pre>\n      * @return The Y variance\n      */\n+    @Override\n     protected double calculateYVariance() {\n         RealMatrix u = calculateResiduals();\n         RealMatrix sse =  u.transpose().multiply(getOmegaInverse()).multiply(u);\n--- a/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n      * \n      * Computes and caches QR decomposition of the X matrix\n      */\n+    @Override\n     public void newSampleData(double[] data, int nobs, int nvars) {\n         super.newSampleData(data, nobs, nvars);\n         qr = new QRDecompositionImpl(X);\n      * \n      * @param x the [n,k] array representing the x sample\n      */\n+    @Override\n     protected void newXSampleData(double[][] x) {\n         this.X = new RealMatrixImpl(x);\n         qr = new QRDecompositionImpl(X);\n      * \n      * @return beta\n      */\n+    @Override\n     protected RealMatrix calculateBeta() {\n         return solveUpperTriangular(qr.getR(), qr.getQ().transpose().multiply(Y));\n     }\n      * \n      * @return The beta variance\n      */\n+    @Override\n     protected RealMatrix calculateBetaVariance() {\n         int p = X.getColumnDimension();\n         RealMatrix Raug = qr.getR().getSubMatrix(0, p - 1 , 0, p - 1);\n      * </p>\n      * @return The Y variance\n      */\n+    @Override\n     protected double calculateYVariance() {\n         RealMatrix u = calculateResiduals();\n         RealMatrix sse = u.transpose().multiply(u);\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      * @return the internal storage array used by this object\n      * @deprecated replaced by {@link #getInternalValues()} as of 2.0\n      */\n+    @Deprecated\n     public synchronized double[] getValues() {\n         return (internalArray);\n     }\n      * properties as this\n      * @since 2.0\n      */\n+    @Override\n     public boolean equals(Object object) {\n         if (object == this ) {\n             return true;\n      * @return hash code representing this ResizableDoubleArray\n      * @since 2.0\n      */\n+    @Override\n     public int hashCode() {\n         int[] hashData = new int[7];\n         hashData[0] = new Float(expansionFactor).hashCode();\n--- a/src/test/org/apache/commons/math/RetryTestCase.java\n+++ b/src/test/org/apache/commons/math/RetryTestCase.java\n     /**\n      *  Override runTest() to catch AssertionFailedError and retry\n      */\n+    @Override\n     protected void runTest() throws Throwable {\n         try {\n             super.runTest();\n--- a/src/test/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImplTest.java\n+++ b/src/test/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImplTest.java\n      * @throws java.lang.Exception\n      * @see junit.framework.TestCase#tearDown()\n      */\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         factory = new UnivariateRealSolverFactoryImpl();\n      * @throws java.lang.Exception\n      * @see junit.framework.TestCase#tearDown()\n      */\n+    @Override\n     protected void tearDown() throws Exception {\n         factory = null;\n         super.tearDown();\n--- a/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n     protected abstract Locale getLocale();\n \n     protected abstract char getDecimalCharacter();\n-    \n+\n+    @Override\n     protected void setUp() throws Exception {\n         complexFormat = ComplexFormat.getInstance(getLocale());\n         complexFormatJ = ComplexFormat.getInstance(getLocale());\n--- a/src/test/org/apache/commons/math/complex/ComplexFormatTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexFormatTest.java\n \n \n public class ComplexFormatTest extends ComplexFormatAbstractTest {\n+    @Override\n     protected char getDecimalCharacter() {\n         return '.';\n     }\n     \n+    @Override\n     protected Locale getLocale() {\n         return Locale.US;\n     }\n--- a/src/test/org/apache/commons/math/complex/FrenchComplexFormatTest.java\n+++ b/src/test/org/apache/commons/math/complex/FrenchComplexFormatTest.java\n \n \n public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {\n-    \n+\n+    @Override\n     protected char getDecimalCharacter() {\n         return ',';\n     }\n-    \n+\n+    @Override\n     protected Locale getLocale() {\n         return Locale.FRENCH;\n     }\n--- a/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n     public IntegerDistribution makeDistribution() {\n         return new BinomialDistributionImpl(10,0.70);\n     }\n     \n     /** Creates the default probability density test input values */\n+    @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n     }\n     \n     /** Creates the default probability density test expected values */\n+    @Override\n     public double[] makeDensityTestValues() {\n         return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d, \n                 0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};\n     }\n     \n     /** Creates the default cumulative probability density test input values */\n+    @Override\n     public int[] makeCumulativeTestPoints() {\n         return makeDensityTestPoints();\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,\n                 0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};\n         }\n     \n     /** Creates the default inverse cumulative probability test input values */\n+    @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d,1}; \n         }\n     \n     /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};\n     }\n--- a/src/test/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/CauchyDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new CauchyDistributionImpl(1.2, 2.1);\n     }   \n     \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using Mathematica \n         return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n                 0.975d, 0.990d, 0.999d};\n--- a/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new ChiSquaredDistributionImpl(5.0);\n     }   \n     \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n         return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, \n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d}; \n     }\n     \n     /** Creates the default inverse cumulative probability test input values */\n+    @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d, 1};     \n     }\n     \n     /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n     public double[] makeInverseCumulativeTestValues() {\n         return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, \n                 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d, \n     }\n     \n  // --------------------- Override tolerance  --------------\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         setTolerance(5e-6);\n--- a/src/test/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n     /**\n      * Setup sets all test instance data to default values \n      */\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         distribution = makeDistribution();\n     /**\n      * Cleans up test instance data\n      */\n+    @Override\n     protected void tearDown() throws Exception {      \n         super.tearDown();\n         distribution = null;\n--- a/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new ExponentialDistributionImpl(5.0);\n     }   \n     \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n         return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d, \n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d}; \n--- a/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new FDistributionImpl(5.0, 6.0);\n     }   \n     \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n         return new double[] {0.03468084d ,0.09370091d, 0.1433137d,\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d}; \n     }\n     \n     // --------------------- Override tolerance  --------------\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         setTolerance(4e-6);\n--- a/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new GammaDistributionImpl(4d, 2d);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n         return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d};\n     }\n \n     // --------------------- Override tolerance  --------------\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         setTolerance(6e-6);\n--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n     public IntegerDistribution makeDistribution() {\n         return new HypergeometricDistributionImpl(10,5, 5);\n     }\n     \n     /** Creates the default probability density test input values */\n+    @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};\n     }\n     \n     /** Creates the default probability density test expected values */\n+    @Override\n     public double[] makeDensityTestValues() {\n         return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, \n                 0.099206d, 0.003968d, 0d};\n     }\n     \n     /** Creates the default cumulative probability density test input values */\n+    @Override\n     public int[] makeCumulativeTestPoints() {\n         return makeDensityTestPoints();\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,\n                 1.00000d, 1d};\n     }\n     \n     /** Creates the default inverse cumulative probability test input values */\n+    @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d, 1d}; \n     }\n     \n     /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};\n     }\n--- a/src/test/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n     /**\n      * Setup sets all test instance data to default values \n      */\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         distribution = makeDistribution();\n     /**\n      * Cleans up test instance data\n      */\n+    @Override\n     protected void tearDown() throws Exception {      \n         super.tearDown();\n         distribution = null;\n--- a/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new NormalDistributionImpl(2.1, 1.4);\n     }   \n     \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R \n         return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d, \n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d}; \n     }\n     \n     // --------------------- Override tolerance  --------------\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1E-6);\n--- a/src/test/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/PascalDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n     public IntegerDistribution makeDistribution() {\n         return new PascalDistributionImpl(10,0.70);\n     }\n     \n     /** Creates the default probability density test input values */\n+    @Override\n     public int[] makeDensityTestPoints() {\n       return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n     }\n     \n     /** Creates the default probability density test expected values */\n+    @Override\n     public double[] makeDensityTestValues() {\n       return new double[] {0d, 0.02824d, 0.08474d, 0.13982d, \n           0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};\n     }\n     \n     /** Creates the default cumulative probability density test input values */\n+    @Override\n     public int[] makeCumulativeTestPoints() {\n       return makeDensityTestPoints();\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n       return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,\n           0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};\n         }\n     \n     /** Creates the default inverse cumulative probability test input values */\n+    @Override\n     public double[] makeInverseCumulativeTestPoints() {\n       return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n           0.990d, 0.975d, 0.950d, 0.900d, 1}; \n         }\n     \n     /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n     public int[] makeInverseCumulativeTestValues() {\n       return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};\n     }\n--- a/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n     /** \n      * Creates the default discrete distribution instance to use in tests. \n      */\n+    @Override\n     public IntegerDistribution makeDistribution() {\n         return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);  \n     }\n     /** \n      * Creates the default probability density test input values.\n      */\n+    @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n     }\n      * Creates the default probability density test expected values.\n      * These and all other test values are generated by R, version 1.8.1\n      */\n+    @Override\n     public double[] makeDensityTestValues() {\n         return new double[] { 0d, 0.0183156388887d,  0.073262555555d,\n                 0.14652511111d, 0.195366814813d, 0.195366814813, \n     /**\n      * Creates the default cumulative probability density test input values.\n      */\n+    @Override\n     public int[] makeCumulativeTestPoints() {\n         return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };\n     }\n     /**\n      * Creates the default cumulative probability density test expected values.\n      */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] { 0d,  0.0183156388887d, 0.0915781944437d, \n                 0.238103305554d, 0.433470120367d, 0.62883693518,\n      * probabilities for corresponding values exceeds the target value (still \n      * within tolerance).\n      */\n+    @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] { 0d,  0.018315638889d, 0.0915781944437d, \n                 0.238103305554d, 0.433470120367d, 0.62883693518,\n     /**\n      * Creates the default inverse cumulative probability density test expected values.\n      */\n+    @Override\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n     }\n--- a/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n //-------------- Implementations for abstract methods -----------------------\n \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new TDistributionImpl(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n         return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d};\n     }\n \n     // --------------------- Override tolerance  --------------\n+    @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1E-6);\n--- a/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n     public ContinuousDistribution makeDistribution() {\n         return new WeibullDistributionImpl(1.2, 2.1);\n     }   \n     \n     /** Creates the default cumulative probability distribution test input values */\n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using Mathematica \n         return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n                 0.975d, 0.990d, 0.999d};\n--- a/src/test/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ZipfDistributionTest.java\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n     public IntegerDistribution makeDistribution() {\n         return new ZipfDistributionImpl(10, 1);\n     }\n     \n     /** Creates the default probability density test input values */\n+    @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n     }\n     \n     /** Creates the default probability density test expected values */\n+    @Override\n     public double[] makeDensityTestValues() {\n         return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d, \n                 0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d};\n     }\n     \n     /** Creates the default cumulative probability density test input values */\n+    @Override\n     public int[] makeCumulativeTestPoints() {\n         return makeDensityTestPoints();\n     }\n     \n     /** Creates the default cumulative probability density test expected values */\n+    @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d,\n                 0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d};\n         }\n     \n     /** Creates the default inverse cumulative probability test input values */\n+    @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d, 1}; \n         }\n     \n     /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};\n     }\n--- a/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n       setIgnored(false);\n     }\n \n+    @Override\n     public double getTheoreticalValue() {\n       double v = 0;\n       for (int i = 0; i < factors.length; ++i) {\n       return v;\n     }\n \n+    @Override\n     public double getPartial(EstimatedParameter parameter) {\n       for (int i = 0; i < parameters.length; ++i) {\n         if (parameters[i] == parameter) {\n         this.py = py;\n       }\n \n+      @Override\n       public double getPartial(EstimatedParameter parameter) {\n         if (parameter == cx) {\n           return getPartialDiX() - getPartialRadiusX();\n         return (cy.getEstimate() - py) / getCenterDistance();\n       }\n \n+      @Override\n       public double getTheoreticalValue() {\n         return getCenterDistance() - getRadius();\n       }\n--- a/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n       this.parameters = parameters;\n     }\n \n+    @Override\n     public double getTheoreticalValue() {\n       double v = 0;\n       for (int i = 0; i < factors.length; ++i) {\n       return v;\n     }\n \n+    @Override\n     public double getPartial(EstimatedParameter parameter) {\n       for (int i = 0; i < parameters.length; ++i) {\n         if (parameters[i] == parameter) {\n         this.py = py;\n       }\n \n+      @Override\n       public double getPartial(EstimatedParameter parameter) {\n         if (parameter == cx) {\n           return getPartialDiX() - getPartialRadiusX();\n         return (cy.getEstimate() - py) / getCenterDistance();\n       }\n \n+      @Override\n       public double getTheoreticalValue() {\n         return getCenterDistance() - getRadius();\n       }\n               this.x = x;\n           }\n \n+          @Override\n           public double getTheoreticalValue() {\n               return theoreticalValue(x);\n           }\n \n+          @Override\n           public double getPartial(EstimatedParameter parameter) {\n               return partial(x, parameter);\n           }\n--- a/src/test/org/apache/commons/math/estimation/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/estimation/MinpackTest.java\n         this.index = index;\n       }\n \n+      @Override\n       public double getTheoreticalValue() {\n         // this is obviously NOT efficient as we recompute the whole vector\n         // each time we need only one element, but it is only for test\n         return getResiduals()[index];\n       }\n \n+      @Override\n       public double getPartial(EstimatedParameter parameter) {\n         // this is obviously NOT efficient as we recompute the whole jacobian\n         // each time we need only one element, but it is only for test\n             theoreticalMinCost, buildArray(n, -1.0));\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double t = 2.0 / m;\n       double[][] jacobian = new double[m][];\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double sum = 0;\n       for (int i = 0; i < n; ++i) {\n       super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double[] f = new double[m];\n       double sum = 0;\n             null);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double[] f = new double[m];\n       double sum = 0;\n       super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double x1 = parameters[0].getEstimate();\n       return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             new double[] { 1.0, 0.0, 0.0 });\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n       };\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n       super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n       };\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double x2 = parameters[1].getEstimate();\n       return new double[][] {\n       };\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x2 = parameters[1].getEstimate();\n       double   x3 = parameters[2].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double   x1 = parameters[0].getEstimate();\n       double   x2 = parameters[1].getEstimate();\n       }\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x1 = parameters[0].getEstimate();\n       double   x2 = parameters[1].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n       }\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x1 = parameters[0].getEstimate();\n       double   x2 = parameters[1].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n \n       double[][] jacobian = new double[m][];\n \n     }\n \n+    @Override\n     protected double[] getResiduals() {\n      double[] f = new double[m];\n      for (int i = 0; i < (m - 2); ++i) {\n             0.0, new double[] { 1.0, 10.0, 1.0 });\n    }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x1 = parameters[0].getEstimate();\n       double   x2 = parameters[1].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x1 = parameters[0].getEstimate();\n       double   x2 = parameters[1].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x1 = parameters[0].getEstimate();\n       double   x2 = parameters[1].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n \n       double[][] jacobian = new double[m][];\n \n     }\n \n+    @Override\n     protected double[] getResiduals() {\n \n       double[] f = new double[m];\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n \n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double[] f = new double[m];\n       double sum  = -(n + 1);\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x2 = parameters[1].getEstimate();\n       double   x3 = parameters[2].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x1 = parameters[0].getEstimate();\n       double x2 = parameters[1].getEstimate();\n             theoreticalMinCost, theoreticalMinParams);\n     }\n \n+    @Override\n     protected double[][] getJacobian() {\n       double   x01 = parameters[0].getEstimate();\n       double   x02 = parameters[1].getEstimate();\n       return jacobian;\n     }\n \n+    @Override\n     protected double[] getResiduals() {\n       double x01 = parameters[0].getEstimate();\n       double x02 = parameters[1].getEstimate();\n--- a/src/test/org/apache/commons/math/estimation/WeightedMeasurementTest.java\n+++ b/src/test/org/apache/commons/math/estimation/WeightedMeasurementTest.java\n     return new TestSuite(WeightedMeasurementTest.class);\n   }\n \n+  @Override\n   public void setUp() {\n     p1 = new EstimatedParameter(\"p1\", 1.0);\n     p2 = new EstimatedParameter(\"p2\", 2.0);\n   }\n \n+  @Override\n   public void tearDown() {\n     p1 = null;\n     p2 = null;\n       this.testInstance = testInstance;\n     }\n \n+    @Override\n     public double getTheoreticalValue() {\n       return testInstance.theoretical();\n     }\n \n+    @Override\n     public double getPartial(EstimatedParameter p) {\n       return testInstance.partial(p);\n     }\n--- a/src/test/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+++ b/src/test/org/apache/commons/math/fraction/BigFractionFormatTest.java\n         return Locale.getDefault();\n     }\n \n+    @Override\n     protected void setUp() throws Exception {\n         properFormat = BigFractionFormat.getProperInstance(getLocale());\n         improperFormat = BigFractionFormat.getImproperInstance(getLocale());\n--- a/src/test/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionFormatTest.java\n         return Locale.getDefault();\n     }\n \n+    @Override\n     protected void setUp() throws Exception {\n         properFormat = FractionFormat.getProperInstance(getLocale());\n         improperFormat = FractionFormat.getImproperInstance(getLocale());\n--- a/src/test/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n+++ b/src/test/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n \n \n public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {\n-    \n+\n+    @Override\n     protected char getDecimalCharacter() {\n         return ',';\n     }\n-    \n+\n+    @Override\n     protected Locale getLocale() {\n         return Locale.FRENCH;\n     }\n--- a/src/test/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n     protected abstract Locale getLocale();\n \n     protected abstract char getDecimalCharacter();\n-    \n+\n+    @Override\n     protected void setUp() throws Exception {\n         vector3DFormat = Vector3DFormat.getInstance(getLocale());\n         final NumberFormat nf = NumberFormat.getInstance(getLocale());\n--- a/src/test/org/apache/commons/math/geometry/Vector3DFormatTest.java\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DFormatTest.java\n \n \n public class Vector3DFormatTest extends Vector3DFormatAbstractTest {\n+\n+    @Override\n     protected char getDecimalCharacter() {\n         return '.';\n     }\n-    \n+\n+    @Override\n     protected Locale getLocale() {\n         return Locale.US;\n     }\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n     \n     public BigMatrixImplTest(String name) {\n         super(name);\n-    }\n-    \n-    public void setUp() {\n-        \n     }\n     \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n     \n     public DenseRealMatrixTest(String name) {\n         super(name);\n-    }\n-    \n-    public void setUp() {\n-        \n     }\n     \n     public static Test suite() {\n     \n     private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n         private static final long serialVersionUID = 1773444180892369386L;\n+        @Override\n         public double visit(int i, int j, double value) {\n             return i + j / 1024.0;\n         }\n     private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n         private static final long serialVersionUID = -7745543227178932689L;\n         private int count = 0;\n+        @Override\n         public void visit(int i, int j, double value) {\n             ++count;\n             assertEquals(i + j / 1024.0, value, 0.0);\n--- a/src/test/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n+++ b/src/test/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n \n \n public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {\n-    \n+\n+    @Override\n     protected char getDecimalCharacter() {\n         return ',';\n     }\n-    \n+\n+    @Override\n     protected Locale getLocale() {\n         return Locale.FRENCH;\n     }\n--- a/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n         super(name);\n     }\n     \n-    public void setUp() {     \n-    }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(MatrixUtilsTest.class);\n         suite.setName(\"MatrixUtils Tests\");\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         super(name);\n     }\n     \n-    public void setUp() {\n-        \n-    }\n-    \n     public static Test suite() {\n         TestSuite suite = new TestSuite(RealMatrixImplTest.class);\n         suite.setName(\"RealMatrixImpl Tests\");\n     \n     private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n         private static final long serialVersionUID = -5082825244208703349L;\n+        @Override\n         public double visit(int i, int j, double value) {\n             return i + j / 1024.0;\n         }\n     private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n         private static final long serialVersionUID = 849639072339030818L;\n         private int count = 0;\n+        @Override\n         public void visit(int i, int j, double value) {\n             ++count;\n             assertEquals(i + j / 1024.0, value, 0.0);\n--- a/src/test/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n     protected abstract Locale getLocale();\n \n     protected abstract char getDecimalCharacter();\n-    \n-    protected void setUp() throws Exception {\n+\n+    @Override\n+    public void setUp() throws Exception {\n         realVectorFormat = RealVectorFormat.getInstance(getLocale());\n         final NumberFormat nf = NumberFormat.getInstance(getLocale());\n         nf.setMaximumFractionDigits(2);\n--- a/src/test/org/apache/commons/math/linear/RealVectorFormatTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatTest.java\n \n \n public class RealVectorFormatTest extends RealVectorFormatAbstractTest {\n+\n+    @Override\n     protected char getDecimalCharacter() {\n         return '.';\n     }\n-    \n+\n+    @Override\n     protected Locale getLocale() {\n         return Locale.US;\n     }\n--- a/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n \n     public SparseRealMatrixTest(String name) {\n         super(name);\n-    }\n-\n-    public void setUp() {\n-\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/linear/decomposition/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/EigenDecompositionImplTest.java\n         return found;\n     }\n \n+    @Override\n     public void setUp() {\n         refValues = new double[] {\n                 2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n         matrix = createTestMatrix(new Random(35992629946426l), refValues);\n     }\n \n+    @Override\n     public void tearDown() {\n         refValues = null;\n         matrix    = null;\n--- a/src/test/org/apache/commons/math/linear/decomposition/EigenSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/EigenSolverTest.java\n \n     }\n \n+    @Override\n     public void setUp() {\n         refValues = new double[] {\n                 2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n         matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);\n     }\n \n+    @Override\n     public void tearDown() {\n         refValues = null;\n         matrix    = null;\n--- a/src/test/org/apache/commons/math/linear/decomposition/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/QRDecompositionImplTest.java\n     private void checkUpperTriangular(RealMatrix m) {\n         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             private static final long serialVersionUID = -7685630069569815930L;\n+            @Override\n             public void visit(int row, int column, double value) {\n                 if (column < row) {\n                     assertEquals(0.0, value, entryTolerance);\n     private void checkTrapezoidal(RealMatrix m) {\n         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             private static final long serialVersionUID = -43649044361860701L;\n+            @Override\n             public void visit(int row, int column, double value) {\n                 if (column > row) {\n                     assertEquals(0.0, value, entryTolerance);\n         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n             private static final long serialVersionUID = -556118291433400034L;\n+            @Override\n             public double visit(int row, int column, double value)\n                 throws MatrixVisitorException {\n                 return 2.0 * r.nextDouble() - 1.0;\n--- a/src/test/org/apache/commons/math/linear/decomposition/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/QRSolverTest.java\n         final double noise = 0.001;\n         b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n             private static final long serialVersionUID = 3533849820776962636L;\n+            @Override\n             public double visit(int row, int column, double value) {\n                 return value * (1.0 + noise * (2 * r.nextDouble() - 1));\n             }\n         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n             private static final long serialVersionUID = -556118291433400034L;\n+            @Override\n             public double visit(int row, int column, double value)\n                 throws MatrixVisitorException {\n                 return 2.0 * r.nextDouble() - 1.0;\n--- a/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n     return new TestSuite(ContinuousOutputModelTest.class);\n   }\n \n+  @Override\n   public void setUp() {\n     pb = new TestProblem3(0.9);\n     double minStep = 0;\n     integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);\n   }\n \n+  @Override\n   public void tearDown() {\n     pb    = null;\n     integ = null;\n--- a/src/test/org/apache/commons/math/ode/nonstiff/TestProblem1.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem1.java\n    * Clone operation.\n    * @return a copy of the instance\n    */\n+  @Override\n   public Object clone() {\n     return new TestProblem1(this);\n   }\n \n+  @Override\n   public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n \n     // compute the derivatives\n \n   }\n \n+  @Override\n   public double[] computeTheoreticalState(double t) {\n     double c = Math.exp (t0 - t);\n     for (int i = 0; i < n; ++i) {\n--- a/src/test/org/apache/commons/math/ode/nonstiff/TestProblem2.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem2.java\n    * Clone operation.\n    * @return a copy of the instance\n    */\n+  @Override\n   public Object clone() {\n     return new TestProblem2(this);\n   }\n \n+  @Override\n   public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n \n     // compute the derivatives\n \n   }\n \n+  @Override\n   public double[] computeTheoreticalState(double t) {\n     double t2 = t * t;\n     double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/TestProblem3.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem3.java\n    * Clone operation.\n    * @return a copy of the instance\n    */\n+  @Override\n   public Object clone() {\n     return new TestProblem3(this);\n   }\n \n+  @Override\n   public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n \n     // current radius\n \n   }\n \n+  @Override\n   public double[] computeTheoreticalState(double t) {\n \n     // solve Kepler's equation\n--- a/src/test/org/apache/commons/math/ode/nonstiff/TestProblem4.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem4.java\n    * Clone operation.\n    * @return a copy of the instance\n    */\n+  @Override\n   public Object clone() {\n     return new TestProblem4(this);\n   }\n \n+  @Override\n   public EventHandler[] getEventsHandlers() {\n     return new EventHandler[] { new Bounce(), new Stop() };\n   }\n \n+  @Override\n   public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n     yDot[0] =  y[1];\n     yDot[1] = -y[0];\n   }\n \n+  @Override\n   public double[] computeTheoreticalState(double t) {\n     double sin = Math.sin(t + a);\n     double cos = Math.cos(t + a);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/TestProblemAbstract.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemAbstract.java\n    * Clone operation.\n    * @return a copy of the instance\n    */\n+  @Override\n   public abstract Object clone();\n \n   /**\n--- a/src/test/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n       public BadStepInterpolator(double[] y, boolean forward) {\n           super(y, forward);\n       }\n+      @Override\n       protected void doFinalize()\n       throws DerivativeException {\n           throw new DerivativeException(null);\n       protected ErrorGeneratingInterpolator(double[] y, boolean forward) {\n           super(y, forward);\n       }\n+      @Override\n       public void computeInterpolatedState(double theta, double oneMinusThetaH)\n       throws DerivativeException {\n           throw new DerivativeException(null);\n--- a/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n     return new TestSuite(StepNormalizerTest.class);\n   }\n \n+  @Override\n   public void setUp() {\n     pb = new TestProblem3(0.9);\n     double minStep = 0;\n     lastSeen = false;\n   }\n \n+  @Override\n   public void tearDown() {\n     pb    = null;\n     integ = null;\n--- a/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n             buildArray(n, -1.0));\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double t = 2.0 / m;\n       double[][] jacobian = new double[m][];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double sum = 0;\n       for (int i = 0; i < n; ++i) {\n       super(m, buildArray(n, x0), theoreticalMinCost, null);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double[] f = new double[m];\n       double sum = 0;\n             null);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double[] f = new double[m];\n       double sum = 0;\n       super(2, startParams, 0.0, buildArray(2, 1.0));\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double x1 = variables[0];\n       return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       };\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       super(4, startParams, 0.0, buildArray(4, 0.0));\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       };\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double x2 = variables[1];\n       return new double[][] {\n       };\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       }\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       }\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n \n       double[][] jacobian = new double[m][];\n \n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n      double[] f = new double[m];\n      for (int i = 0; i < (m - 2); ++i) {\n             new double[] { 1.0, 10.0, 1.0 });\n    }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n \n       double[][] jacobian = new double[m][];\n \n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n \n       double[] f = new double[m];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n \n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double[] f = new double[m];\n       double sum  = -(n + 1);\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n             theoreticalMinParams);\n     }\n \n+    @Override\n     public double[][] jacobian(double[] variables) {\n       double   x01 = variables[0];\n       double   x02 = variables[1];\n       return jacobian;\n     }\n \n+    @Override\n     public double[] value(double[] variables) {\n       double x01 = variables[0];\n       double x02 = variables[1];\n--- a/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n         return suite;\n     }\n     \n+    @Override\n     public void testNextInt() {\n         try {\n             testGenerator.nextInt(-1);\n                 testStatistic.chiSquare(expected,observed) < 16.27);    \n     }\n     \n+    @Override\n     public void testNextLong() {\n         long q1 = Long.MAX_VALUE/4;\n         long q2 = 2 *  q1;\n--- a/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n \n     }\n \n+    @Override\n     public void setUp() {\n         try {\n             mean = new double[] { 0.0, 1.0, -3.0, 2.3};\n         }\n     }\n \n+    @Override\n     public void tearDown() {\n         mean       = null;\n         covariance = null;\n--- a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n         super(name);\n     }\n \n+    @Override\n     public void setUp() throws IOException {\n         empiricalDistribution = new EmpiricalDistributionImpl(100);\n         url = getClass().getResource(\"testData.txt\");\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n     protected RandomDataImpl randomData = null; \n     protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n     \n-    public void setUp() { \n-    }\n-\n     public static Test suite() {\n         TestSuite suite = new TestSuite(RandomDataTest.class);\n         suite.setName(\"RandomData Tests\");\n--- a/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n+++ b/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n \n     private static final long serialVersionUID = -9161426374178114548L;\n     private Random random = new Random();\n-    \n+\n+    @Override\n     public void setSeed(long seed) {\n        clear();\n        random.setSeed(seed);\n     }\n-    \n+\n+    @Override\n     public double nextDouble() {\n         return random.nextDouble();\n     }\n--- a/src/test/org/apache/commons/math/random/UncorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/UncorrelatedRandomVectorGeneratorTest.java\n \n     }\n \n+    @Override\n     public void setUp() {\n         mean              = new double[] {0.0, 1.0, -3.0, 2.3};\n         standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};\n                     new GaussianRandomGenerator(rg));\n     }\n \n+    @Override\n     public void tearDown() {\n         mean = null;\n         standardDeviation = null;\n--- a/src/test/org/apache/commons/math/random/ValueServerTest.java\n+++ b/src/test/org/apache/commons/math/random/ValueServerTest.java\n         super(name);\n     }\n \n+    @Override\n     public void setUp() {\n         vs.setMode(ValueServer.DIGEST_MODE);\n         try {\n--- a/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n+++ b/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n      */\n     public CertifiedDataTest(String name) {\n         super(name);\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see junit.framework.TestCase#setUp()\n-     */\n-    public void setUp() {\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n     public FrequencyTest(String name) {\n         super(name);\n     }\n-    \n+\n+    @Override\n     public void setUp() {  \n         f = new Frequency();\n     }\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n         super(name);\n     }\n \n-    public void setUp() {\n-    }\n-\n     public static Test suite() {\n         TestSuite suite = new TestSuite(StatUtilsTest.class);\n         suite.setName(\"StatUtil Tests\");\n--- a/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n     private SummaryStatistics summaries;\n     \n     private Map<String, Double> certifiedValues;\n-    \n+\n+    @Override\n     protected void setUp() throws Exception {\n         descriptives = new DescriptiveStatistics();\n         summaries = new SummaryStatistics();\n     protected double getMaximumAbsoluteError() {\n         return 1.0e-5;\n     }\n-    \n+\n+    @Override\n     protected void tearDown() throws Exception {\n         descriptives.clear();\n         descriptives = null;\n--- a/src/test/org/apache/commons/math/stat/data/LewTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/LewTest.java\n  */\n public class LewTest extends CertifiedDataAbstractTest {\n \n+    @Override\n     protected String getResourceName() {\n         return \"org/apache/commons/math/stat/data/Lew.txt\";\n     }\n--- a/src/test/org/apache/commons/math/stat/data/LotteryTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/LotteryTest.java\n  */\n public class LotteryTest extends CertifiedDataAbstractTest {\n \n+    @Override\n     protected String getResourceName() {\n         return \"org/apache/commons/math/stat/data/Lottery.txt\";\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n      * Always returns currently set quantile\n      */\n     static class subPercentile extends Percentile {\n+        @Override\n         public double evaluate(double[] values, int begin, int length) {\n             return getQuantile();\n         }\n+        @Override\n         public double evaluate(double[] values) {\n             return getQuantile();\n         }  \n         private static final long serialVersionUID = 8040701391045914979L;\n+        @Override\n         public Percentile copy() {\n             subPercentile result = new subPercentile();\n             return result;\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n         this.transformer = transformer;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getValues()\n-     */\n+    /** {@inheritDoc} */\n+    @Override\n     public double[] getValues() {\n \n         int length = list.size();\n         return copiedArray;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getElement(int)\n-     */\n+    /** {@inheritDoc} */\n+    @Override\n     public double getElement(int index) {\n \n         double value = Double.NaN;\n         return value;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getN()\n-     */\n+    /** {@inheritDoc} */\n+    @Override\n     public long getN() {\n         int n = 0;\n \n         return n;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n-     */\n+    /** {@inheritDoc} */\n+    @Override\n     public void addValue(double v) {\n         list.add(Double.valueOf(v));\n     }\n      * <p>\n      * <strong>N.B.: </strong> This method has the side effect of clearing the underlying list.\n      */\n+    @Override\n     public void clear() {\n         list.clear();\n     }\n      * @param stat the statistic to apply\n      * @return the computed value of the statistic.\n      */\n+    @Override\n     public double apply(UnivariateStatistic stat) {\n         double[] v = this.getValues();\n \n         this.transformer = transformer;\n     }\n     \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#setWindowSize(int)\n-     */\n+    /** {@inheritDoc} */\n+    @Override\n     public synchronized void setWindowSize(int windowSize) {\n         this.windowSize = windowSize;\n         //Discard elements from the front of the list if the windowSize is less than \n         }\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getWindowSize\n-     */\n+    /** {@inheritDoc} */\n+    @Override\n     public synchronized int getWindowSize() {\n         return windowSize;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n     \n     public ListUnivariateImplTest(String name) {\n         super(name);\n-    }\n-    \n-    public void setUp() {  \n     }\n     \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n \n         transformers.putTransformer(Bar.class, new BarTransformer());\n \n-    }\n-\n-    public void setUp() {\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n     \n     public StatisticalSummaryValuesTest(String name) {\n         super(name);\n-    }\n-    \n-    public void setUp() {  \n     }\n     \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n     protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};\n \n     /** Return a new instance of the statistic */\n+    @Override\n     public abstract UnivariateStatistic getUnivariateStatistic();\n \n     /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    @Override\n     public abstract double expectedValue();\n     \n     /** \n--- a/src/test/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n         return suite;\n     }\n \n+    @Override\n     protected SummaryStatistics createSummaryStatistics() {\n         return new SynchronizedSummaryStatistics();\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new FirstMoment();\n     }\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n      */\n+    @Override\n     public double expectedValue() {\n         return this.mean;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new FourthMoment();\n     }\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n      */\n+    @Override\n     public double expectedValue() {\n        return this.fourthMoment;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new GeometricMean();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.geoMean;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n         return suite;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Kurtosis();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.kurt;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Mean();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.mean;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new SecondMoment();\n     }\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n      */\n+    @Override\n     public double expectedValue() {\n         return this.secondMoment;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n         super(name);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Skewness();\n     }\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.skew;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n         super(name);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new StandardDeviation();\n     }\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.std;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new ThirdMoment();\n     }\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n      */\n+    @Override\n     public double expectedValue() {\n       return this.thirdMoment;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n         super(name);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Variance();\n     }\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.var;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n \n     }\n \n+    @Override\n     public void setUp() {\n         points = new double[][] {\n                 { 1.2, 2.3,  4.5},\n         };\n     }\n \n+    @Override\n     public void tearDown() {\n         points = null;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/VectorialMeanTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/VectorialMeanTest.java\n \n     }\n \n+    @Override\n     public void setUp() {\n         points = new double[][] {\n                 { 1.2, 2.3,  4.5},\n         };\n     }\n \n+    @Override\n     public void tearDown() {\n         points = null;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Max();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.max;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {  \n         return new Median();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.median;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Min();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.min;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {   \n         return new Percentile(95.0);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.percentile95;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Product();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double getTolerance() {\n         return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.product;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {        \n         return new SumOfLogs();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.sumLog;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new SumOfSquares();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.sumSq;\n     }\n--- a/src/test/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n         return suite;\n     }\n     \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n         return new Sum();      \n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+    /**\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double expectedValue() {\n         return this.sum;\n     }\n--- a/src/test/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n     public ChiSquareFactoryTest(String name) {\n         super(name);\n     }\n-    \n-    public void setUp() {\n+\n+    @Override\n+    public void setUp() throws Exception {\n     \tsuper.setUp();\n         testStatistic = TestUtils.getUnknownDistributionChiSquareTest();\n     }\n--- a/src/test/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n         super(name);\n     }\n \n-    public void setUp() {\n-    }\n-\n     public static Test suite() {\n         TestSuite suite = new TestSuite(ChiSquareTestTest.class);\n         suite.setName(\"TestStatistic Tests\");\n--- a/src/test/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n \n     public OneWayAnovaTest(String name) {\n         super(name);\n-    }\n-\n-    public void setUp() {\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n     public TTestFactoryTest(String name) {\n         super(name);\n     }\n-    \n+\n+    @Override\n     public void setUp() {\n     \tsuper.setUp();\n         testStatistic = TestUtils.getTTest();\n--- a/src/test/org/apache/commons/math/stat/inference/TTestTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/TTestTest.java\n         super(name);\n     }\n \n+    @Override\n     public void setUp() {\n         tooShortStats = new SummaryStatistics();\n         tooShortStats.addValue(0d);\n--- a/src/test/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/TestUtilsTest.java\n         super(name);\n     }\n \n-    public void setUp() {\n-    }\n-\n     public static Test suite() {\n         TestSuite suite = new TestSuite(TestUtilsTest.class);\n         suite.setName(\"TestUtils Tests\");\n--- a/src/test/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n     private double[][] omega;\n \n     @Before\n+    @Override\n     public void setUp(){\n         y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};\n         x = new double[6][];\n         createRegression().newSampleData(y, x, omega);\n     }\n \n+    @Override\n     protected GLSMultipleLinearRegression createRegression() {\n         GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();\n         regression.newSampleData(y, x, omega);\n         return regression;\n     }\n \n+    @Override\n     protected int getNumberOfRegressors() {\n         return x[0].length;\n     }\n \n+    @Override\n     protected int getSampleSize() {\n         return y.length;\n     }\n--- a/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n     private double[][] x;\n     \n     @Before\n+    @Override\n     public void setUp(){\n         y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};\n         x = new double[6][];\n         super.setUp();\n     }\n \n+    @Override\n     protected OLSMultipleLinearRegression createRegression() {\n         OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();\n         regression.newSampleData(y, x);\n         return regression;\n     }\n \n+    @Override\n     protected int getNumberOfRegressors() {\n         return x[0].length;\n     }\n \n+    @Override\n     protected int getSampleSize() {\n         return y.length;\n     }\n--- a/src/test/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n \n     public SimpleRegressionTest(String name) {\n         super(name);\n-    }\n-\n-    public void setUp() {\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/util/ContinuedFractionTest.java\n+++ b/src/test/org/apache/commons/math/util/ContinuedFractionTest.java\n         ContinuedFraction cf = new ContinuedFraction() {\n             private static final long serialVersionUID = 4696264881688589546L;\n \n+            @Override\n             public double getA(int n, double x) {\n                 return 1.0;\n             }\n \n+            @Override\n             public double getB(int n, double x) {\n                 return 1.0;\n             }\n--- a/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n     public ResizableDoubleArrayTest(String name) {\n         super( name );\n     }\n-      \n+\n+    @Override\n     protected void tearDown() throws Exception {\n         da = null;\n         ra = null;\n     }\n        \n+    @Override\n     protected void setUp() throws Exception {\n         da = new ResizableDoubleArray();\n         ra = new ResizableDoubleArray();\n         testDa.addElement(1d);\n         assertEquals(4, testDa.getInternalLength());         \n     }\n-    \n+\n+    @Override\n     public void testAdd1000() {\n         super.testAdd1000();\n         assertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n                 \"16 and an expansion factor of 2.0\",\n                 1024, ((ResizableDoubleArray) da).getInternalLength());\n     }\n-    \n+\n+    @Override\n     public void testAddElementRolling() {\n         super.testAddElementRolling();\n         ", "timestamp": 1238941218, "metainfo": ""}