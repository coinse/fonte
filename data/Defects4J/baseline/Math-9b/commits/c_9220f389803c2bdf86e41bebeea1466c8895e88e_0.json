{"sha": "9220f389803c2bdf86e41bebeea1466c8895e88e", "log": "Added probability density functions computation for distributions for which it is feasible JIRA: MATH-222  ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface ChiSquaredDistribution extends ContinuousDistribution {\n+public interface ChiSquaredDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Modify the degrees of freedom.\n      * @param degreesOfFreedom the new degrees of freedom.\n      * @return the degrees of freedom.\n      */\n     double getDegreesOfFreedom();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     public double getDegreesOfFreedom() {\n         return getGamma().getAlpha() * 2.0;\n     }\n-        \n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        return gamma.density(x);\n+    }\n+\n     /**\n      * For this distribution, X, this method returns P(X &lt; x).\n      * @param x the value at which the CDF is evaluated.\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface ExponentialDistribution extends ContinuousDistribution {\n+public interface ExponentialDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Modify the mean.\n      * @param mean the new mean.\n      * @return the mean.\n      */\n     double getMean();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n      */\n     public double getMean() {\n         return mean;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return Math.exp(-x / getMean()) / getMean();\n     }\n \n     /**\n      */\n     protected double getInitialDomain(double p) {\n         // TODO: try to improve on this estimate\n+        // TODO: what should really happen here is not derive from AbstractContinuousDistribution\n+        // TODO: because the inverse cumulative distribution is simple.\n         // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n         if (p < .5) {\n             // use 1/2 mean\n--- a/src/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface GammaDistribution extends ContinuousDistribution {\n+public interface GammaDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Modify the shape parameter, alpha.\n      * @param alpha the new shape parameter.\n      * @return beta.\n      */\n     double getBeta();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n     public double getBeta() {\n         return beta;\n     }\n-    \n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        if (x < 0) return 0;\n+        return Math.pow(x / getBeta(), getAlpha() - 1) / getBeta() * Math.exp(-x / getBeta()) / Math.exp(Gamma.logGamma(getAlpha()));\n+    }\n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/HasDensity.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface that signals that a distribution can compute the probability density function\n+ * for a particular point.\n+ * @version $Revision$ $Date$\n+ */\n+public interface HasDensity<P> {\n+\n+    /**\n+     * Compute the probability density function.\n+     * @param x point for which the probability density is requested\n+     * @return probability density at point x\n+     * @throws MathException if probability density cannot be computed at specifed point\n+     */\n+    double density(P x) throws MathException;\n+\n+}\n--- a/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface NormalDistribution extends ContinuousDistribution {\n+public interface NormalDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Access the mean.\n      * @return mean for this distribution\n      * @param sd standard deviation for this distribution\n      */\n     void setStandardDeviation(double sd);\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n     \n     /** The standard deviation of this distribution. */\n     private double standardDeviation = 1;\n-    \n+    private static final double SQRT2PI = Math.sqrt(2 * Math.PI);\n+\n     /**\n      * Create a normal distribution using the given mean and standard deviation.\n      * @param mean mean for this distribution\n                 \"Standard deviation must be positive.\");\n         }       \n         standardDeviation = sd;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        double x0 = x - getMean();\n+        return Math.exp(-x0 * x0 / (2 * getStandardDeviation() * getStandardDeviation())) / (getStandardDeviation() * SQRT2PI);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-    } \n-    \n+    }\n+\n+    public void testDensity() {\n+        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n+        //R 2.5: print(dchisq(x, df=1), digits=10)\n+        checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});\n+        //R 2.5: print(dchisq(x, df=0.1), digits=10)\n+        checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});\n+        //R 2.5: print(dchisq(x, df=2), digits=10)\n+        checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});\n+        //R 2.5: print(dchisq(x, df=10), digits=10)\n+        checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});\n+    }\n+\n+    private void checkDensity(double df, double[] x, double[] expected) {\n+        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n \n /**\n  * Test cases for ExponentialDistribution.\n         double actual = getDistribution().cumulativeProbability(0.25, 0.75);\n         assertEquals(0.0905214, actual, 10e-4);\n     }\n+\n+    public void testDensity() throws MathException {\n+        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);\n+        assertEquals(0.0, d1.density(-1e-9));\n+        assertEquals(1.0, d1.density(0.0));\n+        assertEquals(0.0, d1.density(1000.0));\n+        assertEquals(Math.exp(-1), d1.density(1.0));\n+        assertEquals(Math.exp(-2), d1.density(2.0));\n+\n+        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n+        assertEquals(1/3.0, d2.density(0.0));\n+        // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5\n+        assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n+\n+        // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5\n+        assertEquals(0.1711390397, d2.density(2.0), 1e-8);\n+    }\n     \n     public void testMeanAccessors() {\n         ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();\n--- a/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n     public GammaDistributionTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     public ContinuousDistribution makeDistribution() {\n         return new GammaDistributionImpl(4d, 2d);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n             3.489539, 26.12448, 20.09024, 17.53455,\n             15.50731, 13.36157};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d}; \n+                0.990d, 0.975d, 0.950d, 0.900d};\n     }\n-    \n+\n     // --------------------- Override tolerance  --------------\n     protected void setUp() throws Exception {\n         super.setUp();\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-    } \n-    \n+    }\n+\n     public void testProbabilities() throws Exception {\n         testProbability(-1.000, 4.0, 2.0, .0000);\n         testProbability(15.501, 4.0, 2.0, .9499);\n         double actual = distribution.inverseCumulativeProbability(p);\n         assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n     }\n-    \n+\n+    public void testDensity() {\n+        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n+        // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)\n+        checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});\n+        // R2.5: print(dgamma(x, shape=2, rate=1), digits=10)\n+        checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});\n+        // R2.5: print(dgamma(x, shape=4, rate=1), digits=10)\n+        checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});\n+        // R2.5: print(dgamma(x, shape=4, rate=10), digits=10)\n+        checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});\n+        // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)\n+        checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});\n+        // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)\n+        checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});\n+        // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)\n+        checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});\n+        // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)\n+        checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});\n+    }\n+\n+    private void checkDensity(double alpha, double rate, double[] x, double[] expected) {\n+        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n--- a/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n             // Expected\n         }\n     }\n-    \n+\n+    public void testDensity() {\n+        double [] x = new double[]{-2, -1, 0, 1, 2};\n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)\n+        checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});\n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) \n+        checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});\n+    }\n+\n+    private void checkDensity(double mean, double sd, double[] x, double[] expected) {\n+        NormalDistribution d = new NormalDistributionImpl(mean, sd);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-9);\n+        }\n+    }\n+\n     /**\n      * Check to make sure top-coding of extreme values works correctly.\n      * Verifies fix for JIRA MATH-167", "timestamp": 1220992628, "metainfo": ""}