{"sha": "843f20d9f8ede125d080060c9ae51e052dab1e9f", "log": "MATH-707 Class name change:   \"BaseAbstractVectorialOptimizer\" -> \"BaseAbstractMultivariateVectorOptimizer\"   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.analysis.MultivariateVectorFunction;\n+import org.apache.commons.math.optimization.BaseMultivariateVectorOptimizer;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions.\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ *\n+ * @param <FUNC> the type of the objective function to be optimized\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class BaseAbstractMultivariateVectorOptimizer<FUNC extends MultivariateVectorFunction>\n+    implements BaseMultivariateVectorOptimizer<FUNC> {\n+    /** Evaluations counter. */\n+    protected final Incrementor evaluations = new Incrementor();\n+    /** Convergence checker. */\n+    private ConvergenceChecker<VectorialPointValuePair> checker;\n+    /** Target value for the objective functions at optimum. */\n+    private double[] target;\n+    /** Weight for the least squares cost computation. */\n+    private double[] weight;\n+    /** Initial guess. */\n+    private double[] start;\n+    /** Objective function. */\n+    private MultivariateVectorFunction function;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleVectorialValueChecker} and\n+     * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n+     */\n+    protected BaseAbstractMultivariateVectorOptimizer() {\n+        this(new SimpleVectorialValueChecker());\n+    }\n+    /**\n+     * @param checker Convergence checker.\n+     */\n+    protected BaseAbstractMultivariateVectorOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at the specified point.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n+     */\n+    protected double[] computeObjectiveValue(double[] point) {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(int maxEval, FUNC f, double[] t, double[] w,\n+                                            double[] startPoint) {\n+        // Checks.\n+        if (f == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (t == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (w == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (startPoint == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (t.length != w.length) {\n+            throw new DimensionMismatchException(t.length, w.length);\n+        }\n+\n+        // Reset.\n+        evaluations.setMaximalCount(maxEval);\n+        evaluations.resetCount();\n+\n+        // Store optimization problem characteristics.\n+        function = f;\n+        target = t.clone();\n+        weight = w.clone();\n+        start = startPoint.clone();\n+\n+        // Perform computation.\n+        return doOptimize();\n+    }\n+\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double[] getStartPoint() {\n+        return start.clone();\n+    }\n+\n+    /**\n+     * Perform the bulk of the optimization algorithm.\n+     *\n+     * @return the point/value pair giving the optimal value for the\n+     * objective function.\n+     */\n+    protected abstract VectorialPointValuePair doOptimize();\n+\n+    /**\n+     * @return a reference to the {@link #target array}.\n+     */\n+    protected double[] getTargetRef() {\n+        return target;\n+    }\n+    /**\n+     * @return a reference to the {@link #weight array}.\n+     */\n+    protected double[] getWeightRef() {\n+        return weight;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n-import org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer;\n+import org.apache.commons.math.optimization.direct.BaseAbstractMultivariateVectorOptimizer;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @since 1.2\n  */\n public abstract class AbstractLeastSquaresOptimizer\n-    extends BaseAbstractVectorialOptimizer<DifferentiableMultivariateVectorFunction>\n+    extends BaseAbstractMultivariateVectorOptimizer<DifferentiableMultivariateVectorFunction>\n     implements DifferentiableMultivariateVectorOptimizer {\n     /** Singularity threshold (cf. {@link #getCovariances(double)}). */\n     private static final double DEFAULT_SINGULARITY_THRESHOLD = 1e-14;", "timestamp": 1323433708, "metainfo": ""}