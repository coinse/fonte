{"sha": "912d9beb43edb26caf87a32f08664ea634136c73", "log": "Merged most functions from ComplexUtils into Complex class, added static factory method to Complex. JIRA: MATH-171 Reported and patched by Niall Pemberton   ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n      * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex add(Complex rhs) {   \n-        return new Complex(real + rhs.getReal(),\n+        return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n     \n         if (isNaN()) {\n             return NaN;\n         }   \n-        return new Complex(real, -imaginary);\n+        return createComplex(real, -imaginary);\n     }\n     \n     /**\n \n         if (Math.abs(c) < Math.abs(d)) {\n             if (d == 0.0) {\n-                return new Complex(real/c, imaginary/c);\n+                return createComplex(real/c, imaginary/c);\n             }\n             double q = c / d;\n             double denominator = c * q + d;\n-            return new Complex((real * q + imaginary) / denominator,\n+            return createComplex((real * q + imaginary) / denominator,\n                 (imaginary * q - real) / denominator);\n         } else {\n             if (c == 0.0) {\n-                return new Complex(imaginary/d, -real/c);\n+                return createComplex(imaginary/d, -real/c);\n             }\n             double q = d / c;\n             double denominator = d * q + c;\n-            return new Complex((imaginary * q + real) / denominator,\n+            return createComplex((imaginary * q + real) / denominator,\n                 (imaginary - real * q) / denominator);\n         }\n     }\n         if (isNaN() || rhs.isNaN()) {\n             return NaN;\n         }\n-        return new Complex(real * rhs.real - imaginary * rhs.imaginary,\n+        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                 real * rhs.imaginary + imaginary * rhs.real);\n     }\n     \n             return NaN;\n         }\n         \n-        return new Complex(-real, -imaginary);\n+        return createComplex(-real, -imaginary);\n     }\n     \n     /**\n             return NaN;\n         }\n         \n-        return new Complex(real - rhs.getReal(),\n+        return createComplex(real - rhs.getReal(),\n             imaginary - rhs.getImaginary());\n     }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n+     * inverse cosine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.\n+     * \n+     * @return the inverse cosine of this complex number\n+     * @since 1.2\n+     */\n+    public Complex acos() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n+              .multiply(Complex.I.negate());\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n+     * inverse sine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.\n+     * \n+     * @return the inverse sine of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex asin() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return sqrt1z().add(this.multiply(Complex.I)).log()\n+              .multiply(Complex.I.negate());\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n+     * inverse tangent</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite. \n+     * \n+     * @return the inverse tangent of this complex number\n+     * @since 1.2\n+     */\n+    public Complex atan() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n+            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n+     * cosine</a>\n+     * of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n+     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n+     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * \n+     * @return the cosine of this complex number\n+     * @since 1.2\n+     */\n+    public Complex cos() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n+            -Math.sin(real) * MathUtils.sinh(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n+     * hyperbolic cosine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n+     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * \n+     * @return the hyperbolic cosine of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex cosh() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n+            MathUtils.sinh(real) * Math.sin(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the\n+     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n+     * exponential function</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n+     * {@link java.lang.Math#sin}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * exp(INFINITY + i) = INFINITY + INFINITY i\n+     * exp(-INFINITY + i) = 0 + 0i\n+     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * \n+     * @return <i>e</i><sup><code>this</code></sup>\n+     * @since 1.2\n+     */\n+    public Complex exp() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double expReal = Math.exp(real);\n+        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n+     * natural logarithm</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n+     * where ln on the right hand side is {@link java.lang.Math#log},\n+     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n+     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite (or critical) values in real or imaginary parts of the input may\n+     * result in infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n+     * log(INFINITY + i) = INFINITY + 0i\n+     * log(-INFINITY + i) = INFINITY + &pi;i\n+     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n+     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n+     * log(0 + 0i) = -INFINITY + 0i\n+     * </code></pre>\n+     * \n+     * @return ln of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex log() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return createComplex(Math.log(abs()),\n+            Math.atan2(imaginary, real));        \n+    }\n+    \n+    /**\n+     * Returns of value of this complex number raised to the power of <code>x</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n+     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n+     * {@link #log}, respectively.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n+     * equals {@link Complex#ZERO}.\n+     * \n+     * @param x the exponent.\n+     * @return <code>this</code><sup><code>x</code></sup>\n+     * @throws NullPointerException if x is null\n+     * @since 1.2\n+     */\n+    public Complex pow(Complex x) {\n+        if (x == null) {\n+            throw new NullPointerException();\n+        }\n+        return this.log().multiply(x).exp();\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n+     * sine</a>\n+     * of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n+     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n+     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * \n+     * @return the sine of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex sin() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n+            Math.cos(real) * MathUtils.sinh(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n+     * hyperbolic sine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n+     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre\n+     * \n+     * @return the hyperbolic sine of this complex number\n+     * @since 1.2\n+     */\n+    public Complex sinh() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n+            MathUtils.cosh(real) * Math.sin(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n+     * square root</a> of this complex number.\n+     * <p>\n+     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: \n+     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n+     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n+     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n+     * </ol>\n+     * where <ul>\n+     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n+     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n+     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n+     * </ul>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n+     * sqrt(INFINITY + i) = INFINITY + 0i\n+     * sqrt(-INFINITY + i) = 0 + INFINITY i\n+     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n+     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n+     * </code></pre>\n+     * \n+     * @return the square root of this complex number\n+     * @since 1.2\n+     */\n+    public Complex sqrt() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        if (real == 0.0 && imaginary == 0.0) {\n+            return createComplex(0.0, 0.0);\n+        }\n+        \n+        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n+        if (real >= 0.0) {\n+            return createComplex(t, imaginary / (2.0 * t));\n+        } else {\n+            return createComplex(Math.abs(imaginary) / (2.0 * t),\n+                MathUtils.indicator(imaginary) * t);\n+        }\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n+     * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n+     * number.\n+     * <p>\n+     * Computes the result directly as \n+     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result. \n+     * \n+     * @return the square root of 1 - <code>this</code><sup>2</sup>\n+     * @since 1.2\n+     */\n+    public Complex sqrt1z() {\n+        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n+     * tangent</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite (or critical) values in real or imaginary parts of the input may\n+     * result in infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n+     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre>\n+     * \n+     * @return the tangent of this complex number\n+     * @since 1.2\n+     */\n+    public Complex tan() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double real2 = 2.0 * real;\n+        double imaginary2 = 2.0 * imaginary;\n+        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n+        \n+        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n+    }\n+    \n+    /**\n+     * Compute the\n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n+     * hyperbolic tangent</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre>\n+     *\n+     * @return the hyperbolic tangent of this complex number\n+     * @since 1.2\n+     */\n+    public Complex tanh() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double real2 = 2.0 * real;\n+        double imaginary2 = 2.0 * imaginary;\n+        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n+        \n+        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n+    }\n+\n+    /**\n+     * Create a complex number given the real and imaginary parts.\n+     *\n+     * @param real the real part\n+     * @param imaginary the imaginary part\n+     * @return a new complex number instance\n+     * @since 1.2\n+     */\n+    protected Complex createComplex(double real, double imaginary) {\n+        return new Complex(real, imaginary);\n+    }\n }\n--- a/src/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java\n      * @param z the value whose inverse cosine is to be returned\n      * @return the inverse cosine of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.acos()\n      */\n     public static Complex acos(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-\n-        return Complex.I.negate().multiply(log(z.add(\n-            Complex.I.multiply(sqrt1z(z)))));       \n+        return z.acos();\n     }\n     \n     /**\n      * @param z the value whose inverse sine is to be returned.\n      * @return the inverse sine of <code>z</code>.\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.asin()\n      */\n     public static Complex asin(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-\n-        return Complex.I.negate().multiply(log(sqrt1z(z).add(\n-            Complex.I.multiply(z))));       \n+        return z.asin();\n     }\n     \n     /**\n      * @param z the value whose inverse tangent is to be returned\n      * @return the inverse tangent of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.atan()\n      */\n     public static Complex atan(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        return Complex.I.multiply(\n-            log(Complex.I.add(z).divide(Complex.I.subtract(z))))\n-            .divide(new Complex(2.0, 0.0));\n+        return z.atan();\n     }\n     \n     /**\n      * @param z the value whose cosine is to be returned\n      * @return the cosine of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.cos()\n      */\n     public static Complex cos(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a = z.getReal();\n-        double b = z.getImaginary();\n-        \n-        return new Complex(Math.cos(a) * MathUtils.cosh(b),\n-            -Math.sin(a) * MathUtils.sinh(b));\n+        return z.cos();\n     }\n     \n     /**\n      * \n      * @param z the value whose hyperbolic cosine is to be returned.\n      * @return the hyperbolic cosine of <code>z</code>.\n+     * @deprecated use Complex.cosh()\n      */\n     public static Complex cosh(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a = z.getReal();\n-        double b = z.getImaginary();\n-        \n-        return new Complex(MathUtils.cosh(a) * Math.cos(b),\n-            MathUtils.sinh(a) * Math.sin(b));\n+        return z.cosh();\n     }\n     \n     /**\n      * \n      * @param z the value\n      * @return <i>e</i><sup><code>z</code></sup>\n+     * @deprecated use Complex.exp()\n      */\n     public static Complex exp(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double b = z.getImaginary();\n-        double expA = Math.exp(z.getReal());\n-        return new Complex(expA *  Math.cos(b), expA * Math.sin(b));\n+        return z.exp();\n     }\n     \n     /**\n      * \n      * @param z the value.\n      * @return ln <code>z</code>.\n+     * @deprecated use Complex.log()\n      */\n     public static Complex log(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-\n-        return new Complex(Math.log(z.abs()),\n-            Math.atan2(z.getImaginary(), z.getReal()));        \n+        return z.log();\n     }\n     \n     /**\n      * @param x the exponent.\n      * @return <code>y</code><sup><code>x</code></sup>\n      * @throws NullPointerException if either x or y is null\n+     * @deprecated use Complex.pow(x)\n      */\n     public static Complex pow(Complex y, Complex x) {\n-        return exp(x.multiply(log(y)));\n+        return y.pow(x);\n     }\n     \n     /**\n      * \n      * @param z the value whose sine is to be returned.\n      * @return the sine of <code>z</code>.\n+     * @deprecated use Complex.sin()\n      */\n     public static Complex sin(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a = z.getReal();\n-        double b = z.getImaginary();\n-        \n-        return new Complex(Math.sin(a) * MathUtils.cosh(b),\n-            Math.cos(a) * MathUtils.sinh(b));\n+        return z.sin();\n     }\n     \n     /**\n      * @param z the value whose hyperbolic sine is to be returned\n      * @return the hyperbolic sine of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.sinh()\n      */\n     public static Complex sinh(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a = z.getReal();\n-        double b = z.getImaginary();\n-        \n-        return new Complex(MathUtils.sinh(a) * Math.cos(b),\n-            MathUtils.cosh(a) * Math.sin(b));\n+        return z.sinh();\n     }\n     \n     /**\n      * @param z the value whose square root is to be returned\n      * @return the square root of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.sqrt()\n      */\n     public static Complex sqrt(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a = z.getReal();\n-        double b = z.getImaginary();\n-        if (a == 0.0 && b == 0.0) {\n-            return new Complex(0.0, 0.0);\n-        }\n-        \n-        double t = Math.sqrt((Math.abs(a) + z.abs()) / 2.0);\n-        if (a >= 0.0) {\n-            return new Complex(t, b / (2.0 * t));\n-        } else {\n-            return new Complex(Math.abs(b) / (2.0 * t),\n-                MathUtils.indicator(b) * t);\n-        }\n+        return z.sqrt();\n     }\n     \n     /**\n      * @param z the value\n      * @return the square root of 1 - <code>z</code><sup>2</sup>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.sqrt1z()\n      */\n     public static Complex sqrt1z(Complex z) {\n-        return sqrt(Complex.ONE.subtract(z.multiply(z)));\n+        return z.sqrt1z();\n     }\n     \n     /**\n      * @param z the value whose tangent is to be returned\n      * @return the tangent of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.tan()\n      */\n     public static Complex tan(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a2 = 2.0 * z.getReal();\n-        double b2 = 2.0 * z.getImaginary();\n-        double d = Math.cos(a2) + MathUtils.cosh(b2);\n-        \n-        return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / d);\n+        return z.tan();\n     }\n     \n     /**\n      * @param z the value whose hyperbolic tangent is to be returned\n      * @return the hyperbolic tangent of <code>z</code>\n      * @throws NullPointerException if <code>z</code> is null\n+     * @deprecated use Complex.tanh()\n      */\n     public static Complex tanh(Complex z) {\n-        if (z.isNaN()) {\n-            return Complex.NaN;\n-        }\n-        \n-        double a2 = 2.0 * z.getReal();\n-        double b2 = 2.0 * z.getImaginary();\n-        double d = MathUtils.cosh(a2) + Math.cos(b2);\n-        \n-        return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / d);\n+        return z.tanh();\n     }\n }\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n \n package org.apache.commons.math.complex;\n \n+import org.apache.commons.math.TestUtils;\n+\n import junit.framework.TestCase;\n \n /**\n     private double inf = Double.POSITIVE_INFINITY;\n     private double neginf = Double.NEGATIVE_INFINITY;\n     private double nan = Double.NaN;\n+    private double pi = Math.PI;\n     private Complex oneInf = new Complex(1, inf);\n     private Complex oneNegInf = new Complex(1, neginf);\n     private Complex infOne = new Complex(inf, 1);\n+    private Complex infZero = new Complex(inf, 0);\n+    private Complex infNaN = new Complex(inf, nan);\n+    private Complex infNegInf = new Complex(inf, neginf);\n+    private Complex infInf = new Complex(inf, inf);\n     private Complex negInfInf = new Complex(neginf, inf);\n+    private Complex negInfZero = new Complex(neginf, 0);\n+    private Complex negInfOne = new Complex(neginf, 1);\n+    private Complex negInfNaN = new Complex(neginf, nan);\n     private Complex negInfNegInf = new Complex(neginf, neginf);\n     private Complex oneNaN = new Complex(1, nan);\n+    private Complex zeroInf = new Complex(0, inf);\n+    private Complex zeroNaN = new Complex(0, nan);\n+    private Complex nanInf = new Complex(nan, inf);\n+    private Complex nanNegInf = new Complex(nan, neginf);\n+    private Complex nanZero = new Complex(nan, 0);\n     \n     public void testConstructor() {\n         Complex z = new Complex(3.0, 4.0);\n         assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n         assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n     }\n+    \n+    public void testAcos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.936812, -2.30551);\n+        TestUtils.assertEquals(expected, z.acos(), 1.0e-5);\n+        TestUtils.assertEquals(new Complex(Math.acos(0), 0), \n+                Complex.ZERO.acos(), 1.0e-12);\n+    }\n+    \n+    public void testAcosInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.acos());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.acos());\n+        TestUtils.assertSame(Complex.NaN, infOne.acos());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.acos());\n+        TestUtils.assertSame(Complex.NaN, infInf.acos());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.acos());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.acos());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());\n+    }\n+    \n+    public void testAcosNaN() {\n+        assertTrue(Complex.NaN.acos().isNaN());\n+    }\n+    \n+    public void testAsin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.633984, 2.30551);\n+        TestUtils.assertEquals(expected, z.asin(), 1.0e-5);\n+    }\n+    \n+    public void testAsinNaN() {\n+        assertTrue(Complex.NaN.asin().isNaN());\n+    }\n+    \n+    public void testAsinInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.asin());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.asin());\n+        TestUtils.assertSame(Complex.NaN, infOne.asin());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.asin());\n+        TestUtils.assertSame(Complex.NaN, infInf.asin());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.asin());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.asin());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.asin());\n+    }\n+    \n+   \n+    public void testAtan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.44831, 0.158997);\n+        TestUtils.assertEquals(expected, z.atan(), 1.0e-5);\n+    }\n+    \n+    public void testAtanInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.atan());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());\n+        TestUtils.assertSame(Complex.NaN, infOne.atan());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.atan());\n+        TestUtils.assertSame(Complex.NaN, infInf.atan());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.atan());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.atan());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());\n+    } \n+    \n+    public void testAtanNaN() {\n+        assertTrue(Complex.NaN.atan().isNaN());\n+        assertTrue(Complex.I.atan().isNaN());\n+    }\n+    \n+    public void testCos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-27.03495, -3.851153);\n+        TestUtils.assertEquals(expected, z.cos(), 1.0e-5);\n+    }\n+    \n+    public void testCosNaN() {\n+        assertTrue(Complex.NaN.cos().isNaN());\n+    }\n+    \n+    public void testCosInf() {\n+        TestUtils.assertSame(infNegInf, oneInf.cos());\n+        TestUtils.assertSame(infInf, oneNegInf.cos());\n+        TestUtils.assertSame(Complex.NaN, infOne.cos());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.cos());\n+        TestUtils.assertSame(Complex.NaN, infInf.cos());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.cos());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.cos());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());\n+    } \n+    \n+    public void testCosh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.58066, -7.58155);\n+        TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);\n+    }\n+    \n+    public void testCoshNaN() {\n+        assertTrue(Complex.NaN.cosh().isNaN());\n+    }\n+    \n+    public void testCoshInf() {  \n+        TestUtils.assertSame(Complex.NaN, oneInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());\n+        TestUtils.assertSame(infInf, infOne.cosh());\n+        TestUtils.assertSame(infNegInf, negInfOne.cosh());\n+        TestUtils.assertSame(Complex.NaN, infInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());\n+    } \n+    \n+    public void testExp() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-13.12878, -15.20078);\n+        TestUtils.assertEquals(expected, z.exp(), 1.0e-5);\n+        TestUtils.assertEquals(Complex.ONE, \n+                Complex.ZERO.exp(), 10e-12);\n+        Complex iPi = Complex.I.multiply(new Complex(pi,0));\n+        TestUtils.assertEquals(Complex.ONE.negate(), \n+                iPi.exp(), 10e-12);\n+    }\n+    \n+    public void testExpNaN() {\n+        assertTrue(Complex.NaN.exp().isNaN());\n+    }\n+    \n+    public void testExpInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.exp());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.exp());\n+        TestUtils.assertSame(infInf, infOne.exp());\n+        TestUtils.assertSame(Complex.ZERO, negInfOne.exp());\n+        TestUtils.assertSame(Complex.NaN, infInf.exp());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.exp());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.exp());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());\n+    }\n+    \n+    public void testLog() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.60944, 0.927295);\n+        TestUtils.assertEquals(expected, z.log(), 1.0e-5);\n+    }\n+    \n+    public void testLogNaN() {\n+        assertTrue(Complex.NaN.log().isNaN());\n+    }\n+    \n+    public void testLogInf() {\n+        TestUtils.assertEquals(new Complex(inf, pi / 2),\n+                oneInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, -pi / 2),\n+                oneNegInf.log(), 10e-12);\n+        TestUtils.assertEquals(infZero, infOne.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, pi),\n+                negInfOne.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, pi / 4),\n+                infInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, -pi / 4),\n+                infNegInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),\n+                negInfInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),\n+                negInfNegInf.log(), 10e-12);\n+    }\n+    \n+    public void testLogZero() {\n+        TestUtils.assertSame(negInfZero, Complex.ZERO.log());\n+    }\n+    \n+    public void testPow() {\n+        Complex x = new Complex(3, 4);\n+        Complex y = new Complex(5, 6);\n+        Complex expected = new Complex(-1.860893, 11.83677);\n+        TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);\n+    }\n+    \n+    public void testPowNaNBase() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(Complex.NaN.pow(x).isNaN());\n+    }\n+    \n+    public void testPowNaNExponent() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(x.pow(Complex.NaN).isNaN());\n+    }\n+    \n+   public void testPowInf() {\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));   \n+   }\n+   \n+   public void testPowZero() {\n+       TestUtils.assertSame(Complex.NaN, \n+               Complex.ZERO.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN, \n+               Complex.ZERO.pow(Complex.ZERO));\n+       TestUtils.assertSame(Complex.NaN, \n+               Complex.ZERO.pow(Complex.I));\n+       TestUtils.assertEquals(Complex.ONE,\n+               Complex.ONE.pow(Complex.ZERO), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE,\n+               Complex.I.pow(Complex.ZERO), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE,\n+               new Complex(-1, 3).pow(Complex.ZERO), 10e-12);\n+   }\n+    \n+    public void testpowNull() {\n+        try {\n+            Complex.ONE.pow(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(3.853738, -27.01681);\n+        TestUtils.assertEquals(expected, z.sin(), 1.0e-5);\n+    }\n+    \n+    public void testSinInf() {\n+        TestUtils.assertSame(infInf, oneInf.sin());\n+        TestUtils.assertSame(infNegInf, oneNegInf.sin());\n+        TestUtils.assertSame(Complex.NaN, infOne.sin());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.sin());\n+        TestUtils.assertSame(Complex.NaN, infInf.sin());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.sin());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.sin());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());\n+    }\n+    \n+    public void testSinNaN() {\n+        assertTrue(Complex.NaN.sin().isNaN());\n+    }\n+    \n+    public void testSinh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.54812, -7.61923);\n+        TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);\n+    }\n+    \n+    public void testSinhNaN() {\n+        assertTrue(Complex.NaN.sinh().isNaN());\n+    }\n+    \n+    public void testSinhInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());\n+        TestUtils.assertSame(infInf, infOne.sinh());\n+        TestUtils.assertSame(negInfInf, negInfOne.sinh());\n+        TestUtils.assertSame(Complex.NaN, infInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());\n+    }\n+    \n+    public void testSqrtRealPositive() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(2, 1);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealZero() {\n+        Complex z = new Complex(0.0, 4);\n+        Complex expected = new Complex(1.41421, 1.41421);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealNegative() {\n+        Complex z = new Complex(-3.0, 4);\n+        Complex expected = new Complex(1, 2);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryZero() {\n+        Complex z = new Complex(-3.0, 0.0);\n+        Complex expected = new Complex(0.0, 1.73205);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryNegative() {\n+        Complex z = new Complex(-3.0, -4.0);\n+        Complex expected = new Complex(1.0, -2.0);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtPolar() {\n+        double r = 1;\n+        for (int i = 0; i < 5; i++) {\n+            r += i;\n+            double theta = 0;\n+            for (int j =0; j < 11; j++) {\n+                theta += pi /12;\n+                Complex z = ComplexUtils.polar2Complex(r, theta);\n+                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);\n+                TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);\n+            }\n+        }       \n+    }\n+    \n+    public void testSqrtNaN() {\n+        assertTrue(Complex.NaN.sqrt().isNaN());\n+    }\n+      \n+    public void testSqrtInf() {\n+        TestUtils.assertSame(infNaN, oneInf.sqrt());\n+        TestUtils.assertSame(infNaN, oneNegInf.sqrt());\n+        TestUtils.assertSame(infZero, infOne.sqrt());\n+        TestUtils.assertSame(zeroInf, negInfOne.sqrt());\n+        TestUtils.assertSame(infNaN, infInf.sqrt());\n+        TestUtils.assertSame(infNaN, infNegInf.sqrt());\n+        TestUtils.assertSame(nanInf, negInfInf.sqrt());\n+        TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());\n+    }\n+    \n+    public void testSqrt1z() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(4.08033, -2.94094);\n+        TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);\n+    }\n+    \n+    public void testSqrt1zNaN() {\n+        assertTrue(Complex.NaN.sqrt1z().isNaN());\n+    }\n+    \n+    public void testTan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-0.000187346, 0.999356);\n+        TestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n+    }\n+    \n+    public void testTanNaN() {\n+        assertTrue(Complex.NaN.tan().isNaN());\n+    }\n+    \n+    public void testTanInf() {\n+        TestUtils.assertSame(zeroNaN, oneInf.tan());\n+        TestUtils.assertSame(zeroNaN, oneNegInf.tan());\n+        TestUtils.assertSame(Complex.NaN, infOne.tan());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.tan());\n+        TestUtils.assertSame(Complex.NaN, infInf.tan());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.tan());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.tan());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());\n+    }\n+    \n+   public void testTanCritical() {\n+        TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());\n+        TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());\n+    }\n+    \n+    public void testTanh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.00071, 0.00490826);\n+        TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n+    }\n+    \n+    public void testTanhNaN() {\n+        assertTrue(Complex.NaN.tanh().isNaN());\n+    }\n+    \n+    public void testTanhInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());\n+        TestUtils.assertSame(nanZero, infOne.tanh());\n+        TestUtils.assertSame(nanZero, negInfOne.tanh());\n+        TestUtils.assertSame(Complex.NaN, infInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());\n+    }\n+    \n+    public void testTanhCritical() {\n+        TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());\n+    }\n }", "timestamp": 1195429085, "metainfo": ""}