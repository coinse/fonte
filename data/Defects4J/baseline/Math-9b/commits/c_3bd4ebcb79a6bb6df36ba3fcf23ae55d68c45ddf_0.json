{"sha": "3bd4ebcb79a6bb6df36ba3fcf23ae55d68c45ddf", "log": "MATH-599 Added brackets around single-statement conditional branches.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n         // If one of the bounds is the exact root, return it. Since these are\n         // not under-approximations or over-approximations, we can return them\n         // regardless of the allowed solutions.\n-        if (f0 == 0.0) return x0;\n-        if (f1 == 0.0) return x1;\n+        if (f0 == 0.0) {\n+            return x0;\n+        }\n+        if (f1 == 0.0) {\n+            return x1;\n+        }\n \n         // Verify bracketing of initial solution.\n         verifyBracketing(x0, x1);\n             // If the new approximation is the exact root, return it. Since\n             // this is not an under-approximation or an over-approximation,\n             // we can return it regardless of the allowed solutions.\n-            if (fx == 0.0) return x;\n+            if (fx == 0.0) {\n+                return x;\n+            }\n \n             // Update the bounds with the new approximation.\n             if (method == Method.SECANT) {\n                 inverted = !inverted;\n             } else {\n                 // We had [x0..x1]. We update it to [x0, x].\n-                if (method == Method.ILLINOIS) f0 *= 0.5;\n-                if (method == Method.PEGASUS) f0 *= f1 / (f1 + fx);\n+                if (method == Method.ILLINOIS) {\n+                    f0 *= 0.5;\n+                }\n+                if (method == Method.PEGASUS) {\n+                    f0 *= f1 / (f1 + fx);\n+                }\n                 x1 = x;\n                 f1 = fx;\n             }", "timestamp": 1308957180, "metainfo": ""}