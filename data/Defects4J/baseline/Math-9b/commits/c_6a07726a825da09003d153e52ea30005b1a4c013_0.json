{"sha": "6a07726a825da09003d153e52ea30005b1a4c013", "log": "MATH-413 Moving classes to a more appropriate package. Removed unused interfaces.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions.\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public abstract class BaseAbstractScalarOptimizer<FUNC extends MultivariateRealFunction>\n+    implements BaseMultivariateRealOptimizer<FUNC> {\n+    /** Evaluations counter. */\n+    protected final Incrementor evaluations = new Incrementor();\n+    /** Convergence checker. */\n+    private ConvergenceChecker<RealPointValuePair> checker;\n+    /** Type of optimization. */\n+    private GoalType goal;\n+    /** Initial guess. */\n+    private double[] start;\n+    /** Objective function. */\n+    private MultivariateRealFunction function;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleScalarValueChecker} and\n+     * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n+     */\n+    protected BaseAbstractScalarOptimizer() {\n+        this(new SimpleScalarValueChecker(), Integer.MAX_VALUE);\n+    }\n+    /**\n+     * @param checker Convergence checker.\n+     * @param maxEvaluations Maximum number of function evaluations.\n+     */\n+    protected BaseAbstractScalarOptimizer(ConvergenceChecker<RealPointValuePair> checker,\n+                                          int maxEvaluations) {\n+        this.checker = checker;\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> convergenceChecker) {\n+        this.checker = convergenceChecker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at the specified point.\n+     * @throws FunctionEvaluationException if the function cannot be evaluated.\n+     * @throws TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n+     */\n+    protected double computeObjectiveValue(double[] point)\n+        throws FunctionEvaluationException {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(FUNC f,\n+                                       GoalType goalType,\n+                                       double[] startPoint)\n+        throws FunctionEvaluationException {\n+        // Checks.\n+        if (f == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (goalType == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (startPoint == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        // Reset.\n+        evaluations.resetCount();\n+\n+        // Store optimization problem characteristics.\n+        function = f;\n+        goal = goalType;\n+        start = startPoint.clone();\n+\n+        // Perform computation.\n+        return doOptimize();\n+    }\n+\n+    /**\n+     * @return the optimization type.\n+     */\n+    public GoalType getGoalType() {\n+        return goal;\n+    }\n+\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double[] getStartPoint() {\n+        return start.clone();\n+    }\n+\n+    /**\n+     * Perform the bulk of the optimization algorithm.\n+     *\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @throws FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     */\n+    protected abstract RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.optimization.BaseMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions.\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ *\n+ * @param <FUNC> the type of the objective function to be optimized\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class BaseAbstractVectorialOptimizer<FUNC extends MultivariateVectorialFunction>\n+    implements BaseMultivariateVectorialOptimizer<FUNC> {\n+    /** Evaluations counter. */\n+    protected final Incrementor evaluations = new Incrementor();\n+    /** Convergence checker. */\n+    private ConvergenceChecker<VectorialPointValuePair> checker;\n+    /** Target value for the objective functions at optimum. */\n+    private double[] target;\n+    /** Weight for the least squares cost computation. */\n+    private double[] weight;\n+    /** Initial guess. */\n+    private double[] start;\n+    /** Objective function. */\n+    private MultivariateVectorialFunction function;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleVectorialValueChecker} and\n+     * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n+     */\n+    protected BaseAbstractVectorialOptimizer() {\n+        this(new SimpleVectorialValueChecker(),  Integer.MAX_VALUE);\n+    }\n+    /**\n+     * @param checker Convergence checker.\n+     * @param maxEvaluations Maximum number of function evaluations.\n+     */\n+    protected BaseAbstractVectorialOptimizer(ConvergenceChecker<VectorialPointValuePair> checker,\n+                                             int maxEvaluations) {\n+        this.checker = checker;\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker<VectorialPointValuePair> convergenceChecker) {\n+        this.checker = convergenceChecker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at the specified point.\n+     * @throws FunctionEvaluationException if the function cannot be evaluated.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n+     */\n+    protected double[] computeObjectiveValue(double[] point)\n+        throws FunctionEvaluationException {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(FUNC f,\n+                                            double[] t, double[] w,\n+                                            double[] startPoint)\n+        throws FunctionEvaluationException {\n+        // Checks.\n+        if (f == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (t == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (w == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (startPoint == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (t.length != w.length) {\n+            throw new DimensionMismatchException(t.length, w.length);\n+        }\n+\n+        // Reset.\n+        evaluations.resetCount();\n+\n+        // Store optimization problem characteristics.\n+        function = f;\n+        target = t.clone();\n+        weight = w.clone();\n+        start = startPoint.clone();\n+\n+        // Perform computation.\n+        return doOptimize();\n+    }\n+\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double[] getStartPoint() {\n+        return start.clone();\n+    }\n+\n+    /**\n+     * Perform the bulk of the optimization algorithm.\n+     *\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @throws FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     */\n+    protected abstract VectorialPointValuePair doOptimize()\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * @return a reference to the {@link #target array}.\n+     */\n+    protected double[] getTargetRef() {\n+        return target;\n+    }\n+    /**\n+     * @return a reference to the {@link #weight array}.\n+     */\n+    protected double[] getWeightRef() {\n+        return weight;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n-import org.apache.commons.math.optimization.general.AbstractScalarOptimizer;\n \n /**\n  * This class implements simplex-based direct search optimization\n  * performed by the derived classes according to the implemented\n  * algorithms.</p>\n  *\n- * implements MultivariateRealOptimizer since 2.0\n- *\n  * @see MultivariateRealFunction\n  * @see NelderMead\n  * @see MultiDirectional\n  * @since 1.2\n  */\n public abstract class DirectSearchOptimizer\n-    extends AbstractScalarOptimizer\n-    implements MultivariateRealOptimizer {\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction> {\n     /** Simplex. */\n     protected RealPointValuePair[] simplex;\n     /** Start simplex configuration. */\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n \n /**\n  * This class implements the multi-directional direct search method.\n  * @see NelderMead\n  * @since 1.2\n  */\n-public class MultiDirectional extends DirectSearchOptimizer {\n-\n+public class MultiDirectional extends DirectSearchOptimizer\n+    implements MultivariateRealOptimizer {\n     /** Expansion coefficient. */\n     private final double khi;\n-\n     /** Contraction coefficient. */\n     private final double gamma;\n \n-    /** Build a multi-directional optimizer with default coefficients.\n-     * <p>The default values are 2.0 for khi and 0.5 for gamma.</p>\n+    /**\n+     * Build a multi-directional optimizer with default coefficients.\n+     * The default values are 2.0 for khi and 0.5 for gamma.\n      */\n     public MultiDirectional() {\n         this.khi   = 2.0;\n         this.gamma = 0.5;\n     }\n \n-    /** Build a multi-directional optimizer with specified coefficients.\n-     * @param khi expansion coefficient\n-     * @param gamma contraction coefficient\n+    /**\n+     * Build a multi-directional optimizer with specified coefficients.\n+     *\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n      */\n     public MultiDirectional(final double khi, final double gamma) {\n         this.khi   = khi;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n \n /**\n  * This class implements the Nelder-Mead direct search method.\n  * @see MultiDirectional\n  * @since 1.2\n  */\n-public class NelderMead extends DirectSearchOptimizer {\n-\n+public class NelderMead extends DirectSearchOptimizer\n+    implements MultivariateRealOptimizer {\n     /** Reflection coefficient. */\n     private final double rho;\n-\n     /** Expansion coefficient. */\n     private final double khi;\n-\n     /** Contraction coefficient. */\n     private final double gamma;\n-\n     /** Shrinkage coefficient. */\n     private final double sigma;\n \n-    /** Build a Nelder-Mead optimizer with default coefficients.\n-     * <p>The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n-     * for both gamma and sigma.</p>\n+    /**\n+     * Build a Nelder-Mead optimizer with default coefficients.\n+     * The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+     * for both gamma and sigma.\n      */\n     public NelderMead() {\n         this.rho   = 1.0;\n         this.sigma = 0.5;\n     }\n \n-    /** Build a Nelder-Mead optimizer with specified coefficients.\n-     * @param rho reflection coefficient\n-     * @param khi expansion coefficient\n-     * @param gamma contraction coefficient\n-     * @param sigma shrinkage coefficient\n+    /**\n+     * Build a Nelder-Mead optimizer with specified coefficients.\n+     *\n+     * @param rho Reflection coefficient.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @param sigma Shrinkage coefficient.\n      */\n     public NelderMead(final double rho, final double khi,\n                       final double gamma, final double sigma) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.univariate.BracketFinder;\n+import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair;\n+\n+/**\n+ * Powell algorithm.\n+ * This code is translated and adapted from the Python version of this\n+ * algorithm (as implemented in module {@code optimize.py} v0.5 of\n+ * <em>SciPy</em>).\n+ * <br/>\n+ * The default stopping criterion is based on the differences of the\n+ * function value between two successive iterations. It is however possible\n+ * to define custom convergence criteria by calling a {@link\n+ * #setConvergenceChecker(ConvergenceChecker) setConvergenceChecker}\n+ * prior to using the optimizer.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class PowellOptimizer\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    implements MultivariateRealOptimizer {\n+    /**\n+     * Minimum relative tolerance.\n+     */\n+    private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d);\n+    /**\n+     * Relative threshold.\n+     */\n+    private double relativeThreshold;\n+    /**\n+     * Absolute threshold.\n+     */\n+    private double absoluteThreshold;\n+    /**\n+     * Line search.\n+     */\n+    private LineSearch line;\n+\n+    /**\n+     * The arguments control the behaviour of the default convergence\n+     * checking procedure.\n+     *\n+     * @param rel Relative threshold.\n+     * @param abs Absolute threshold.\n+     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n+     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n+     */\n+    public PowellOptimizer(double rel,\n+                           double abs) {\n+        if (rel < MIN_RELATIVE_TOLERANCE) {\n+            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n+        }\n+        if (abs <= 0) {\n+            throw new NotStrictlyPositiveException(abs);\n+        }\n+        relativeThreshold = rel;\n+        absoluteThreshold = abs;\n+\n+        // Line search tolerances can be much lower than the tolerances\n+        // required for the optimizer itself.\n+        final double minTol = 1e-4;\n+        final double lsRel = Math.min(FastMath.sqrt(relativeThreshold), minTol);\n+        final double lsAbs = Math.min(FastMath.sqrt(absoluteThreshold), minTol);\n+        line = new LineSearch(lsRel, lsAbs);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        super.setMaxEvaluations(maxEvaluations);\n+\n+        // We must allow at least as many iterations to the underlying line\n+        // search optimizer. Because the line search inner class will call\n+        // \"computeObjectiveValue\" in this class, we ensure that this class\n+        // will be the first to eventually throw \"TooManyEvaluationsException\".\n+        line.setMaxEvaluations(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException {\n+        final GoalType goal = getGoalType();\n+        final double[] guess = getStartPoint();\n+        final int n = guess.length;\n+\n+        final double[][] direc = new double[n][n];\n+        for (int i = 0; i < n; i++) {\n+            direc[i][i] = 1;\n+        }\n+\n+        final ConvergenceChecker<RealPointValuePair> checker\n+            = getConvergenceChecker();\n+\n+        double[] x = guess;\n+        double fVal = computeObjectiveValue(x);\n+        double[] x1 = x.clone();\n+        int iter = 0;\n+        while (true) {\n+            ++iter;\n+\n+            double fX = fVal;\n+            double fX2 = 0;\n+            double delta = 0;\n+            int bigInd = 0;\n+            double alphaMin = 0;\n+\n+            for (int i = 0; i < n; i++) {\n+                final double[] d = Arrays.copyOf(direc[i], n);\n+\n+                fX2 = fVal;\n+\n+                final UnivariateRealPointValuePair optimum = line.search(x, d);\n+                fVal = optimum.getValue();\n+                alphaMin = optimum.getPoint();\n+                final double[][] result = newPointAndDirection(x, d, alphaMin);\n+                x = result[0];\n+\n+                if ((fX2 - fVal) > delta) {\n+                    delta = fX2 - fVal;\n+                    bigInd = i;\n+                }\n+            }\n+\n+            // Default convergence check.\n+            boolean stop = 2 * (fX - fVal) <=\n+                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n+                 absoluteThreshold);\n+\n+            final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n+            final RealPointValuePair current = new RealPointValuePair(x, fVal);\n+            if (!stop) { // User-defined stopping criteria.\n+                if (checker != null) {\n+                    stop = checker.converged(iter, previous, current);\n+                }\n+            }\n+            if (stop) {\n+                if (goal == GoalType.MINIMIZE) {\n+                    return (fVal < fX) ? current : previous;\n+                } else {\n+                    return (fVal > fX) ? current : previous;\n+                }\n+            }\n+\n+            final double[] d = new double[n];\n+            final double[] x2 = new double[n];\n+            for (int i = 0; i < n; i++) {\n+                d[i] = x[i] - x1[i];\n+                x2[i] = 2 * x[i] - x1[i];\n+            }\n+\n+            x1 = x.clone();\n+            fX2 = computeObjectiveValue(x2);\n+\n+            if (fX > fX2) {\n+                double t = 2 * (fX + fX2 - 2 * fVal);\n+                double temp = fX - fVal - delta;\n+                t *= temp * temp;\n+                temp = fX - fX2;\n+                t -= delta * temp * temp;\n+\n+                if (t < 0.0) {\n+                    final UnivariateRealPointValuePair optimum = line.search(x, d);\n+                    fVal = optimum.getValue();\n+                    alphaMin = optimum.getPoint();\n+                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n+                    x = result[0];\n+\n+                    final int lastInd = n - 1;\n+                    direc[bigInd] = direc[lastInd];\n+                    direc[lastInd] = result[1];\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compute a new point (in the original space) and a new direction\n+     * vector, resulting from the line search.\n+     * The parameters {@code p} and {@code d} will be changed in-place.\n+     *\n+     * @param p Point used in the line search.\n+     * @param d Direction used in the line search.\n+     * @param optimum Optimum found by the line search.\n+     * @return a 2-element array containing the new point (at index 0) and\n+     * the new direction (at index 1).\n+     */\n+    private double[][] newPointAndDirection(double[] p,\n+                                            double[] d,\n+                                            double optimum) {\n+        final int n = p.length;\n+        final double[][] result = new double[2][n];\n+        final double[] nP = result[0];\n+        final double[] nD = result[1];\n+        for (int i = 0; i < n; i++) {\n+            nD[i] = d[i] * optimum;\n+            nP[i] = p[i] + nD[i];\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Class for finding the minimum of the objective function along a given\n+     * direction.\n+     */\n+    private class LineSearch extends BrentOptimizer {\n+        /**\n+         * Automatic bracketing.\n+         */\n+        private final BracketFinder bracket = new BracketFinder();\n+\n+        /**\n+         * @param rel Relative threshold.\n+         * @param abs Absolute threshold.\n+         */\n+        LineSearch(double rel,\n+                   double abs) {\n+            super(rel, abs);\n+        }\n+\n+        /**\n+         * Find the minimum of the function {@code f(p + alpha * d)}.\n+         *\n+         * @param p Starting point.\n+         * @param d Search direction.\n+         * @return the optimum.\n+         * @throws FunctionEvaluationException if the function evaluation\n+         * fails.\n+         * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+         * if the number of evaluations is exceeded.\n+         */\n+        public UnivariateRealPointValuePair search(final double[] p,\n+                                                   final double[] d)\n+            throws FunctionEvaluationException {\n+\n+            final int n = p.length;\n+            final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    public double value(double alpha)\n+                        throws FunctionEvaluationException {\n+                        final double[] x = new double[n];\n+                        for (int i = 0; i < n; i++) {\n+                            x[i] = p[i] + alpha * d[i];\n+                        }\n+                        final double obj = PowellOptimizer.this.computeObjectiveValue(x);\n+                        return obj;\n+                    }\n+                };\n+\n+            final GoalType goal = PowellOptimizer.this.getGoalType();\n+            bracket.search(f, goal, 0, 1);\n+            return optimize(f, goal, bracket.getLo(), bracket.getHi(),\n+                            bracket.getMid());\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer;\n import org.apache.commons.math.util.FastMath;\n \n /**\n \n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleVectorialValueChecker}.\n+     * The convergence check is set to a {@link\n+     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}.\n      */\n     protected AbstractLeastSquaresOptimizer() {}\n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.direct.BaseAbstractScalarOptimizer;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.SumSincFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link PowellOptimizer}.\n+ */\n+public class PowellOptimizerTest {\n+\n+    @Test\n+    public void testSumSinc() throws MathException {\n+        final MultivariateRealFunction func = new SumSincFunction(-1);\n+\n+        int dim = 2;\n+        final double[] minPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            minPoint[i] = 0;\n+        }\n+\n+        double[] init = new double[dim];\n+\n+        // Initial is minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i];\n+        }\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);\n+\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i] + 3;\n+        }\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);\n+    }\n+\n+    @Test\n+    public void testQuadratic() throws MathException {\n+        final MultivariateRealFunction func = new MultivariateRealFunction() {\n+                public double value(double[] x)\n+                    throws FunctionEvaluationException {\n+                    final double a = x[0] - 1;\n+                    final double b = x[1] - 1;\n+                    return a * a + b * b + 1;\n+                }\n+            };\n+\n+        int dim = 2;\n+        final double[] minPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            minPoint[i] = 1;\n+        }\n+\n+        double[] init = new double[dim];\n+\n+        // Initial is minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i];\n+        }\n+        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);\n+\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i] - 20;\n+        }\n+        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);\n+    }\n+\n+    @Test\n+    public void testMaximizeQuadratic() throws MathException {\n+        final MultivariateRealFunction func = new MultivariateRealFunction() {\n+                public double value(double[] x)\n+                    throws FunctionEvaluationException {\n+                    final double a = x[0] - 1;\n+                    final double b = x[1] - 1;\n+                    return -a * a - b * b + 1;\n+                }\n+            };\n+\n+        int dim = 2;\n+        final double[] maxPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            maxPoint[i] = 1;\n+        }\n+\n+        double[] init = new double[dim];\n+\n+        // Initial is minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = maxPoint[i];\n+        }\n+        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);\n+\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = maxPoint[i] - 20;\n+        }\n+        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);\n+    }\n+\n+    /**\n+     * @param func Function to optimize.\n+     * @param optimum Expected optimum.\n+     * @param init Starting point.\n+     * @param goal Minimization or maximization.\n+     * @param fTol Tolerance (relative error on the objective function) for\n+     * \"Powell\" algorithm.\n+     * @param pointTol Tolerance for checking that the optimum is correct.\n+     */\n+    private void doTest(MultivariateRealFunction func,\n+                        double[] optimum,\n+                        double[] init,\n+                        GoalType goal,\n+                        double fTol,\n+                        double pointTol)\n+        throws MathException {\n+        final MultivariateRealOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));\n+        optim.setMaxEvaluations(1000);\n+\n+        final RealPointValuePair result = optim.optimize(func, goal, init);\n+        final double[] found = result.getPoint();\n+\n+        for (int i = 0, dim = optimum.length; i < dim; i++) {\n+            Assert.assertEquals(optimum[i], found[i], pointTol);\n+        }\n+    }\n+}", "timestamp": 1285163665, "metainfo": ""}