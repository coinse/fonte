{"sha": "fa13ca04770ba71ae53ee76f248ca6853272367a", "log": "Added rank transformations.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/ranking/NaNStrategy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+/**\n+ * Strategies for handling NaN values in rank transformations.\n+ * <ul>\n+ * <li>MINIMAL - NaNs are treated as minimal in the ordering, equivalent to\n+ * (that is, tied with) <code>Double.NEGATIVE_INFINITY</code>.</li>\n+ * <li>MAXIMAL - NaNs are treated as maximal in the ordering, equivalent to\n+ * <code>Double.POSITIVE_INFINITY</code></li>\n+ * <li>REMOVED - NaNs are removed before the rank transform is applied</li>\n+ * <li>FIXED - NaNs are left \"in place,\" that is the rank transformation is\n+ * applied to the other elements in the input array, but the NaN elements\n+ * are returned unchanged.</li>\n+ * </ul>\n+ *\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public enum NaNStrategy {\n+    \n+    /** NaNs are considered minimal in the ordering */\n+    MINIMAL,\n+    \n+    /** NaNs are considered maximal in the ordering */\n+    MAXIMAL,\n+    \n+    /** NaNs are removed before computing ranks */\n+    REMOVED,\n+    \n+    /** NaNs are left in place */\n+    FIXED\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.random.RandomGenerator;\n+\n+\n+/**\n+ * <p> Ranking based on the natural ordering on doubles.</p>\n+ * <p>NaNs are treated according to the configured {@link NaNStrategy} and ties\n+ * are handled using the selected {@link TiesStrategy}. \n+ * Configuration settings are supplied in optional constructor arguments.\n+ * Defaults are {@link NaNStrategy#MAXIMAL} and {@link TiesStrategy#AVERAGE},\n+ * respectively. When using {@link TiesStrategy#RANDOM}, a \n+ * {@link RandomGenerator} may be supplied as a constructor argument.</p>\n+ * <p>Examples:\n+ * <table border=\"1\" cellpadding=\"3\">\n+ * <tr><th colspan=\"3\">\n+ * Input data: (20, 17, 30, 42.3, 17, 50, Double.NaN, Double.NEGATIVE_INFINITY, 17)\n+ * </th></tr>\n+ * <tr><th>NaNStrategy</th><th>TiesStrategy</th>\n+ * <th><code>rank(data)</code></th>\n+ * <tr>\n+ * <td>default (NaNs maximal)</td>\n+ * <td>default (ties averaged)</td>\n+ * <td>(5, 3, 6, 7, 3, 8, 9, 1, 3)</td></tr>\n+ * <tr>\n+ * <td>default (NaNs maximal)</td>\n+ * <td>MINIMUM</td>\n+ * <td>(5, 2, 6, 7, 2, 8, 9, 1, 2)</td></tr>\n+ * <tr>\n+ * <td>MINIMAL</td>\n+ * <td>default (ties averaged)</td>\n+ * <td>(6, 4, 7, 8, 4, 9, 1.5, 1.5, 4)</td></tr>\n+ * <tr>\n+ * <td>REMOVED</td>\n+ * <td>SEQUENTIAL</td>\n+ * <td>(5, 2, 6, 7, 3, 8, 1, 4)</td></tr>\n+ * <tr>\n+ * <td>MINIMAL</td>\n+ * <td>MAXIMUM</td>\n+ * <td>(6, 5, 7, 8, 5, 9, 2, 2, 5)</td></tr></table></p>\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public class NaturalRanking implements RankingAlgorithm {\n+   \n+    /** NaN strategy - defaults to NaNs maximal */\n+    private final NaNStrategy nanStrategy;\n+    \n+    /** Ties strategy - defaults to ties averaged */\n+    private final TiesStrategy tiesStrategy;\n+    \n+    /** Source of random data - used only when ties strategy is RANDOM */\n+    private final RandomData randomData;\n+    \n+    /** default NaN strategy */\n+    public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.MAXIMAL;\n+    \n+    /** default ties strategy */\n+    public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;\n+    \n+    /**\n+     * Create a NaturalRanking with default strategies for handling ties and NaNs.\n+     */\n+    public NaturalRanking() {\n+        super();\n+        tiesStrategy = DEFAULT_TIES_STRATEGY;\n+        nanStrategy = DEFAULT_NAN_STRATEGY;\n+        randomData = null;\n+    }\n+\n+    /**\n+     * Create a NaturalRanking with the given TiesStrategy.\n+     * \n+     * @param tiesStrategy the TiesStrategy to use\n+     */\n+    public NaturalRanking(TiesStrategy tiesStrategy) {\n+        super();\n+        this.tiesStrategy = tiesStrategy;\n+        nanStrategy = DEFAULT_NAN_STRATEGY;\n+        randomData = new RandomDataImpl();\n+    }\n+\n+    /**\n+     * Create a NaturalRanking with the given NaNStrategy.\n+     * \n+     * @param nanStrategy the NaNStrategy to use\n+     */\n+    public NaturalRanking(NaNStrategy nanStrategy) {\n+        super();\n+        this.nanStrategy = nanStrategy;\n+        tiesStrategy = DEFAULT_TIES_STRATEGY;\n+        randomData = null; \n+    }\n+\n+    /**\n+     * Create a NaturalRanking with the given NaNStrategy and TiesStrategy.\n+     * \n+     * @param nanStrategy NaNStrategy to use\n+     * @param tiesStrategy TiesStrategy to use\n+     */\n+    public NaturalRanking(NaNStrategy nanStrategy, TiesStrategy tiesStrategy) {\n+        super();\n+        this.nanStrategy = nanStrategy;\n+        this.tiesStrategy = tiesStrategy;\n+        randomData = new RandomDataImpl();\n+    }\n+    \n+    /**\n+     * Create a NaturalRanking with TiesStrategy.RANDOM and the given\n+     * RandomGenerator as the source of random data.\n+     * \n+     * @param randomGenerator source of random data\n+     */\n+    public NaturalRanking(RandomGenerator randomGenerator) {\n+        super();\n+        this.tiesStrategy = TiesStrategy.RANDOM;\n+        nanStrategy = DEFAULT_NAN_STRATEGY;\n+        randomData = new RandomDataImpl(randomGenerator);\n+    }\n+\n+\n+    /**\n+     * Create a NaturalRanking with the given NaNStrategy, TiesStrategy.RANDOM\n+     * and the given source of random data.\n+     * \n+     * @param nanStrategy NaNStrategy to use\n+     * @param randomGenerator source of random data\n+     */\n+    public NaturalRanking(NaNStrategy nanStrategy,\n+            RandomGenerator randomGenerator) {\n+        super();\n+        this.nanStrategy = nanStrategy;\n+        this.tiesStrategy = TiesStrategy.RANDOM;\n+        randomData = new RandomDataImpl(randomGenerator);\n+    }\n+    \n+    /**\n+     * Return the NaNStrategy\n+     * \n+     * @return returns the NaNStrategy\n+     */\n+    public NaNStrategy getNanStrategy() {\n+        return nanStrategy;\n+    }\n+\n+    /**\n+     * Return the TiesStrategy\n+     * \n+     * @return the TiesStrategy\n+     */\n+    public TiesStrategy getTiesStrategy() {\n+        return tiesStrategy;\n+    }\n+\n+    /**\n+     * Rank <code>data</code> using the natural ordering on Doubles, with\n+     * NaN values handled according to <code>nanStrategy</code> and ties\n+     * resolved using <code>tiesStrategy.</code>\n+     * \n+     * @param data array to be ranked\n+     * @return array of ranks\n+     */\n+    public double[] rank(double[] data) {\n+        \n+        // Array recording initial positions of data to be ranked\n+        IntDoublePair[] ranks = new IntDoublePair[data.length];  \n+        for (int i = 0; i < data.length; i++) {\n+            ranks[i] = new IntDoublePair(data[i], i);\n+        }\n+        \n+        // Recode, remove or record positions of NaNs\n+        List<Integer> nanPositions = null;\n+        switch (nanStrategy) {\n+            case MAXIMAL: // Replace NaNs with +INFs\n+                recodeNaNs(ranks, Double.POSITIVE_INFINITY);\n+                break;\n+            case MINIMAL: // Replace NaNs with -INFs\n+                recodeNaNs(ranks, Double.NEGATIVE_INFINITY);\n+                break;\n+            case REMOVED: // Drop NaNs from data\n+                ranks = removeNaNs(ranks);\n+                break;\n+            case FIXED:   // Record positions of NaNs\n+                nanPositions = getNanPositions(ranks);\n+                break;\n+        }\n+        \n+        // Sort the IntDoublePairs\n+        Arrays.sort(ranks);\n+        \n+        // Walk the sorted array, filling output array using sorted positions,\n+        // resolving ties as we go\n+        double[] out = new double[ranks.length];\n+        int pos = 1;  // position in sorted array \n+        out[ranks[0].getPosition()] = pos;\n+        List<Integer> tiesTrace = new ArrayList<Integer>();\n+        tiesTrace.add(ranks[0].getPosition());\n+        for (int i = 1; i < ranks.length; i++) {\n+            if (Double.compare(ranks[i].getValue(), ranks[i - 1].getValue()) > 0) {\n+                // tie sequence has ended (or had length 1)\n+                pos = i + 1;\n+                if (tiesTrace.size() > 1) {  // if seq is nontrivial, resolve\n+                    resolveTie(out, tiesTrace);\n+                }\n+                tiesTrace = new ArrayList<Integer>();\n+                tiesTrace.add(ranks[i].getPosition());\n+            } else {\n+                // tie sequence continues\n+                tiesTrace.add(ranks[i].getPosition());\n+            }\n+            out[ranks[i].getPosition()] = pos;\n+        }\n+        if (tiesTrace.size() > 1) {  // handle tie sequence at end\n+            resolveTie(out, tiesTrace);\n+        }\n+        if (nanStrategy == NaNStrategy.FIXED) {\n+            restoreNaNs(out, nanPositions);\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns an array that is a copy of the input array with IntDoublePairs\n+     * having NaN values removed.\n+     * \n+     * @param ranks input array\n+     * @return array with NaN-valued entries removed\n+     */\n+    private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) {\n+        if (!containsNaNs(ranks)) {\n+            return ranks;\n+        }\n+        IntDoublePair[] outRanks = new IntDoublePair[ranks.length];\n+        int j = 0;\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                // drop, but adjust original ranks of later elements\n+                for (int k = i + 1; k < ranks.length; k++) {\n+                    ranks[k] = new IntDoublePair(\n+                            ranks[k].getValue(), ranks[k].getPosition() - 1);\n+                }\n+            } else {\n+                outRanks[j] = new IntDoublePair(\n+                        ranks[i].getValue(), ranks[i].getPosition());\n+                j++;\n+            }\n+        }\n+        IntDoublePair[] returnRanks = new IntDoublePair[j];\n+        System.arraycopy(outRanks, 0, returnRanks, 0, j);\n+        return returnRanks;\n+    }\n+\n+    /**\n+     * Recodes NaN values to the given value. \n+     * \n+     * @param ranks array to recode\n+     * @param value the value to replace NaNs with\n+     */\n+    private void recodeNaNs(IntDoublePair[] ranks, double value) {\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                ranks[i] = new IntDoublePair(\n+                        value, ranks[i].getPosition());\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Checks for presence of NaNs in <code>ranks.</code>\n+     * \n+     * @param ranks array to be searched for NaNs\n+     * @return true iff ranks contains one or more NaNs\n+     */\n+    private boolean containsNaNs(IntDoublePair[] ranks) {\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Resolve a sequence of ties, using the cconfigured {@link TiesStrategy}.\n+     * The input <code>ranks</code> array is expected to take the same value\n+     * for all indices in <code>tiesTrace</code>.  The common value is recoded\n+     * according to the tiesStrategy. For example, if ranks = <5,8,2,6,2,7,1,2>,\n+     * tiesTrace = <2,4,7> and tiesStrategy is MINIMUM, ranks will be unchanged.\n+     * The same array and trace with tiesStrategy AVERAGE will come out\n+     * <5,8,3,6,3,7,1,3>.\n+     * \n+     * @param ranks array of ranks \n+     * @param tiesTrace list of indices where <code>ranks</code> is constant\n+     * -- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j] \n+     * </code>\n+     */\n+    private void resolveTie(double[] ranks, List<Integer> tiesTrace) {\n+        \n+        // constant value of ranks over tiesTrace\n+        final double c = ranks[tiesTrace.get(0)];\n+        \n+        // length of sequence of tied ranks\n+        final int length = tiesTrace.size();\n+        \n+        switch (tiesStrategy) {\n+            case  AVERAGE:  // Replace ranks with average\n+                fill(ranks, tiesTrace, (2 * c + length - 1) / 2d);\n+                break;\n+            case MAXIMUM:   // Replace ranks with maximum values\n+                fill(ranks, tiesTrace, c + length - 1);\n+                break;\n+            case MINIMUM:   // Replace ties with minimum\n+                fill(ranks, tiesTrace, c);\n+                break;\n+            case RANDOM:    // Fill with random integral values in [c, c + length - 1]\n+                Iterator<Integer> iterator = tiesTrace.iterator();\n+                long f = Math.round(c);\n+                while (iterator.hasNext()) {\n+                    ranks[iterator.next()] = \n+                        randomData.nextLong(f, f + length - 1);\n+                }\n+                break;\n+            case SEQUENTIAL:  // Fill sequentially from c to c + length - 1\n+                // walk and fill\n+                iterator = tiesTrace.iterator();\n+                f = Math.round(c);\n+                int i = 0;\n+                while (iterator.hasNext()) {\n+                    ranks[iterator.next()] = f + i++;\n+                }\n+                break;\n+        }   \n+    }\n+    \n+    /**\n+     * Sets<code>data[i] = value</code> for each i in <code>tiesTrace.</code>\n+     * \n+     * @param data array to modify\n+     * @param tiesTrace list of index values to set\n+     * @param value value to set\n+     */\n+    private void fill(double[] data, List<Integer> tiesTrace, double value) {\n+        Iterator<Integer> iterator = tiesTrace.iterator();\n+        while (iterator.hasNext()) {\n+            data[iterator.next()] = value;\n+        }\n+    }\n+    \n+    /**\n+     * Set <code>ranks[i] = Double.NaN</code> for each i in <code>nanPositions.</code>\n+     * \n+     * @param ranks array to modify\n+     * @param nanPositions list of index values to set to <code>Double.NaN</code>\n+     */\n+    private void restoreNaNs(double[] ranks, List<Integer> nanPositions) {\n+        if (nanPositions.size() == 0) {\n+            return;\n+        }\n+        Iterator<Integer> iterator = nanPositions.iterator();\n+        while (iterator.hasNext()) {\n+            ranks[iterator.next().intValue()] = Double.NaN;  \n+        }\n+        \n+    }\n+    \n+    /**\n+     * Returns a list of indexes where <code>ranks</code> is <code>NaN.</code>\n+     * \n+     * @param ranks array to search for <code>NaNs</code>\n+     * @return list of indexes i such that <code>ranks[i] = NaN</code>\n+     */\n+    private List<Integer> getNanPositions(IntDoublePair[] ranks) {\n+        ArrayList<Integer> out = new ArrayList<Integer>();\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                out.add(Integer.valueOf(i));\n+            }\n+        }\n+        return out;     \n+    }\n+    \n+    /**\n+     * Represents the position of a double value in an ordering.\n+     * Comparable interface is implemented so Arrays.sort can be used\n+     * to sort an array of IntDoublePairs by value.  Note that the\n+     * implicitly defined natural ordering is NOT consistent with equals.\n+     */\n+    private static class IntDoublePair implements Comparable<IntDoublePair>  {\n+\n+        /** Value of the pair */\n+        final private double value;\n+\n+        /** Original position of the pair */\n+        final private int position;\n+\n+        /**\n+         * Construct an IntDoublePair with the given value and position.\n+         * @param value the value of the pair\n+         * @param position the original position\n+         */\n+        public IntDoublePair(double value, int position) {\n+            this.value = value;\n+            this.position = position;\n+        }\n+\n+        /**\n+         * Compare this IntDoublePair to another pair.\n+         * Only the <strong>values</strong> are compared.\n+         * \n+         * @param other the other pair to compare this to\n+         * @return result of <code>Double.compare(value, other.value)</code>\n+         */\n+        public int compareTo(IntDoublePair other) {\n+            return Double.compare(value, other.value);\n+        }\n+\n+        /**\n+         * Returns the value of the pair.\n+         * @return value\n+         */\n+        public double getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Returns the original position of the pair.\n+         * @return position\n+         */\n+        public int getPosition() {\n+            return position;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/ranking/RankingAlgorithm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+/**\n+ * Interface representing a rank transformation.\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public interface RankingAlgorithm {\n+    /**\n+     * <p>Performs a rank transformation on the input data, returning an array\n+     * of ranks.</p>\n+     * \n+     * <p>Ranks should be 1-based - that is, the smallest value\n+     * returned in an array of ranks should be greater than or equal to one,\n+     * rather than 0. Ranks should in general take integer values, though\n+     * implementations may return averages or other floating point values\n+     * to resolve ties in the input data.</p>\n+     * \n+     * @param data array of data to be ranked\n+     * @return an array of ranks corresponding to the elements of the input array\n+     */\n+    double[] rank (double[] data);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/ranking/TiesStrategy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+/**\n+ * Strategies for handling tied values in rank transformations.\n+ * <ul>\n+ * <li>SEQUENTIAL - Ties are assigned ranks in order of occurrence in the original array,\n+ * for example (1,3,4,3) is ranked as (1,2,4,3)</li>\n+ * <li>MINIMUM - Tied values are assigned the minimum applicable rank, or the rank\n+ * of the first occurrence. For example, (1,3,4,3) is ranked as (1,2,4,2)</li>\n+ * <li>MAXIMUM - Tied values are assigned the maximum applicable rank, or the rank\n+ * of the last occurrence. For example, (1,3,4,3) is ranked as (1,3,4,3)</li>\n+ * <li>AVERAGE - Tied values are assigned the average of the applicable ranks.  \n+ * For example, (1,3,4,3) is ranked as (1,2.5,4,2.5)</li>\n+ * <li>AVERAGE - Tied values are assigned a random integer rank from among the\n+ * applicable values. The assigned rank will always be an integer, (inclusively)\n+ * between the values retured by the MINIMUM and MAXIMUM strategies.</li>\n+ * </ul>\n+ *\n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public enum TiesStrategy {\n+    \n+    /** Ties assigned sequential ranks in order of occurrence */\n+    SEQUENTIAL,\n+    \n+    /** Ties get the minimum applicable rank */\n+    MINIMUM,\n+    \n+    /** Ties get the maximum applicable rank */\n+    MAXIMUM,\n+    \n+    /** Ties get the average of applicable ranks */\n+    AVERAGE,\n+    \n+    /** Ties get a random integral value from among applicable ranks */\n+    RANDOM\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n+/*\n+ * TiesEquivalentRankTest.java created on Aug 24, 2005 by jdgant01\n+ *\n+ */\n+package org.apache.commons.math.stat.ranking;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomGenerator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for NaturalRanking class\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public class NaturalRankingTest extends TestCase {\n+    \n+    private final double[] exampleData = \n+    {20, 17, 30, 42.3, 17, 50, Double.NaN, Double.NEGATIVE_INFINITY, 17};\n+    private final double[] tiesFirst = {0, 0, 2, 1, 4};\n+    private final double[] tiesLast = {4, 4, 1, 0};\n+    private final double[] multipleNaNs = {0, 1, Double.NaN, Double.NaN};\n+    private final double[] multipleTies = {3, 2, 5, 5, 6, 6, 1};\n+    private final double[] allSame = {0, 0, 0, 0};\n+    \n+    public NaturalRankingTest(String arg0) {\n+        super(arg0);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    public void testDefault() {  // Ties averaged, NaNs maximal\n+        NaturalRanking ranking = new NaturalRanking();\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = {5, 3, 6, 7, 3, 8, 9, 1, 3};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d); \n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] {1.5, 1.5, 4, 3, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] {3.5, 3.5, 2, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] {1, 2, 3.5, 3.5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] {3, 2, 4.5, 4.5, 6.5, 6.5, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] {2.5, 2.5, 2.5, 2.5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+    \n+    public void testNaNsMaximalTiesMinimum() {\n+        NaturalRanking ranking = new NaturalRanking(TiesStrategy.MINIMUM);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = {5, 2, 6, 7, 2, 8, 9, 1, 2};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d); \n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] {1, 1, 4, 3, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] {3, 3, 2, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] {1, 2, 3, 3};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] {3, 2, 4, 4, 6, 6, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] {1, 1, 1, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+    \n+    public void testNaNsRemovedTiesSequential() {\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED, \n+                TiesStrategy.SEQUENTIAL);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = {5, 2, 6, 7, 3, 8, 1, 4};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d); \n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] {1, 2, 4, 3, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] {3, 4, 2, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] {1, 2};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] {3, 2, 4, 5, 6, 7, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] {1, 2, 3, 4};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+    \n+    public void testNaNsMinimalTiesMaximum() {\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL, \n+                TiesStrategy.MAXIMUM);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = {6, 5, 7, 8, 5, 9, 2, 2, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d); \n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] {2, 2, 4, 3, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] {4, 4, 2, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] {3, 4, 2, 2};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] {3, 2, 5, 5, 7, 7, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] {4, 4, 4, 4};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+    \n+    public void testNaNsMinimalTiesAverage() {\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = {6, 4, 7, 8, 4, 9, 1.5, 1.5, 4};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d); \n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] {1.5, 1.5, 4, 3, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] {3.5, 3.5, 2, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] {3, 4, 1.5, 1.5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] {3, 2, 4.5, 4.5, 6.5, 6.5, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] {2.5, 2.5, 2.5, 2.5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+    \n+    public void testNaNsFixedTiesRandom() {\n+        RandomGenerator randomGenerator = new JDKRandomGenerator();\n+        randomGenerator.setSeed(1000);\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,\n+                randomGenerator);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = {5, 4, 6, 7, 3, 8, Double.NaN, 1, 4};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d); \n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] {1, 1, 4, 3, 5};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] {3, 4, 2, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] {1, 2, Double.NaN, Double.NaN};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] {3, 2, 5, 5, 7, 6, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] {1, 3, 4, 4};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);  \n+    }\n+    \n+    public void testNaNsAndInfs() {\n+        double[] data = {0, Double.POSITIVE_INFINITY, Double.NaN, Double.NEGATIVE_INFINITY};\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL);\n+        double[] ranks = ranking.rank(data);\n+        double[] correctRanks = new double[] {2, 3.5, 3.5, 1};\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranking = new NaturalRanking(NaNStrategy.MINIMAL);\n+        ranks = ranking.rank(data);\n+        correctRanks = new double[] {3, 4, 1.5, 1.5};\n+    }\n+}", "timestamp": 1242739894, "metainfo": ""}