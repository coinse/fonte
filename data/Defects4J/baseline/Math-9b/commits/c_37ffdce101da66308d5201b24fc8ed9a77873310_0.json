{"sha": "37ffdce101da66308d5201b24fc8ed9a77873310", "log": "This is an Implementation of StatUtils that uses the new UnivariateStatistic Framework and passes all JUnit StatUtils tests.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  */\n package org.apache.commons.math.stat;\n \n+import org.apache.commons.math.stat.univariate.UnivariateStatistic;\n+import org.apache.commons.math.stat.univariate.moment.GeometricMean;\n+import org.apache.commons.math.stat.univariate.moment.Kurtosis;\n+import org.apache.commons.math.stat.univariate.moment.Mean;\n+import org.apache.commons.math.stat.univariate.moment.Skewness;\n+import org.apache.commons.math.stat.univariate.moment.Variance;\n+import org.apache.commons.math.stat.univariate.rank.Max;\n+import org.apache.commons.math.stat.univariate.rank.Median;\n+import org.apache.commons.math.stat.univariate.rank.Min;\n+import org.apache.commons.math.stat.univariate.rank.Percentile;\n+import org.apache.commons.math.stat.univariate.summary.Product;\n+import org.apache.commons.math.stat.univariate.summary.Sum;\n+import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n+import org.apache.commons.math.stat.univariate.summary.SumOfSquares;\n+\n /**\n  * StatUtils provides easy static implementations of common double[] based\n  * statistical methods. These return a single result value or in some cases, as\n  */\n public class StatUtils {\n \n+    /** Sum Of Logs */\n+    private static UnivariateStatistic sumLog = new SumOfLogs();\n+    \n+    /** Product */\n+    private static UnivariateStatistic product = new Product();\n+    \n+    /** Geometric Mean */\n+    private static UnivariateStatistic geoMean = new GeometricMean();\n+    \n+    /** Mean */\n+    private static UnivariateStatistic mean = new Mean();\n+    \n+    /** Variance */\n+    private static UnivariateStatistic var = new Variance();\n+    \n+    /** Skewness */\n+    private static UnivariateStatistic skew = new Skewness();\n+    \n+    /** Kurtosis */\n+    private static UnivariateStatistic kurt = new Kurtosis();\n+    \n+    /** Min Of Logs */\n+    private static UnivariateStatistic min = new Min();\n+    \n+    /** Max */\n+    private static UnivariateStatistic max = new Max();\n+    \n+    /** Median */\n+    private static UnivariateStatistic median = new Median();\n+    \n+    /** Sum */\n+    private static UnivariateStatistic sum = new Sum();\n+    \n+    /** Sum Of Squares */\n+    private static UnivariateStatistic sumSq = new SumOfSquares();\n+    \n+    /** Percentile */\n+    private static Percentile percentile = new Percentile();\n+\n     /**\n      * The sum of the values that have been added to Univariate.\n      * @param values Is a double[] containing the values\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n     public static double sum(double[] values) {\n-        return sum(values, 0, values.length);\n+        return sum.evaluate(values, 0, values.length);\n     }\n \n     /**\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n     public static double sum(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        double accum = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += values[i];\n-        }\n-        return accum;\n+        return sum.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n     public static double sumSq(double[] values) {\n-        return sumSq(values, 0, values.length);\n+        return sumSq.evaluate(values);\n     }\n \n     /**\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n     public static double sumSq(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        double accum = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow(values[i], 2.0);\n-        }\n-        return accum;\n+        return sumSq.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the product values or Double.NaN if the array is empty\n      */\n     public static double product(double[] values) {\n-        return product(values, 0, values.length);\n+        return product.evaluate(values);\n     }\n \n     /**\n      * @return the product values or Double.NaN if the array is empty\n      */\n     public static double product(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        double product = 1.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            product *= values[i];\n-        }\n-        return product;\n+        return product.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n     public static double sumLog(double[] values) {\n-        return sumLog(values, 0, values.length);\n+        return sumLog.evaluate(values);\n     }\n \n     /**\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n     public static double sumLog(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        double sumLog = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            sumLog += Math.log(values[i]);\n-        }\n-        return sumLog;\n+        return sumLog.evaluate(values, begin, length);\n     }\n \n     /**\n      * any of the values are &lt;= 0.\n      */\n     public static double geometricMean(double[] values) {\n-        return geometricMean(values, 0, values.length);\n+        return geoMean.evaluate(values);\n     }\n \n     /**\n      * @return the geometric mean or Double.NaN if the array is empty or\n      * any of the values are &lt;= 0.\n      */\n-    public static double geometricMean(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        return Math.exp(sumLog(values, begin, length) / (double) length );\n+    public static double geometricMean(\n+        double[] values,\n+        int begin,\n+        int length) {\n+        return geoMean.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the mean of the values or Double.NaN if the array is empty\n      */\n     public static double mean(double[] values) {\n-        return sum(values) / (double) values.length;\n+        return mean.evaluate(values);\n     }\n \n     /**\n       * @return the mean of the values or Double.NaN if the array is empty\n       */\n     public static double mean(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        return sum(values, begin, length) / ((double) length);\n+        return mean.evaluate(values, begin, length);\n     }\n \n     /**\n         double[] values,\n         int begin,\n         int length) {\n-        testInput(values, begin, length);\n+\n         double stdDev = Double.NaN;\n         if (values.length != 0) {\n             stdDev = Math.sqrt(variance(values, begin, length));\n      * or 0.0 for a single value set.  \n      */\n     public static double variance(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-\n-        double variance = Double.NaN;\n-        if (values.length == 1) {\n-            variance = 0;\n-        } else if (values.length > 1) {\n-            double mean = mean(values, begin, length);\n-            double accum = 0.0;\n-            double accum2 = 0.0;\n-            for (int i = begin; i < begin + length; i++) {\n-                accum += Math.pow((values[i] - mean), 2.0);\n-                accum2 += (values[i] - mean);\n-            }\n-            variance =\n-                (accum - (Math.pow(accum2, 2) / ((double)length)))\n-                    / (double) (length - 1);\n-        }\n-        return variance;\n+        return var.evaluate(values, begin, length);\n     }\n \n     /**\n     public static double skewness(double[] values) {\n         return skewness(values, 0, values.length);\n     }\n-        /**\n-     * Returns the skewness of a collection of values.  Skewness is a \n-     * measure of the assymetry of a given distribution. \n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     * @return the skewness of the values or Double.NaN if the array is empty\n-     */\n+    /**\n+    * Returns the skewness of a collection of values.  Skewness is a \n+    * measure of the assymetry of a given distribution. \n+    * @param values Is a double[] containing the values\n+    * @param begin processing at this point in the array\n+    * @param length processing at this point in the array\n+    * @return the skewness of the values or Double.NaN if the array is empty\n+    */\n     public static double skewness(double[] values, int begin, int length) {\n-\n-        testInput(values, begin, length);\n-\n-        // Initialize the skewness\n-        double skewness = Double.NaN;\n-\n-        // Get the mean and the standard deviation\n-        double mean = mean(values, begin, length);\n-\n-        // Calc the std, this is implemented here instead of using the \n-        // standardDeviation method eliminate a duplicate pass to get the mean\n-        double accum = 0.0;\n-        double accum2 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow((values[i] - mean), 2.0);\n-            accum2 += (values[i] - mean);\n-        }\n-        double stdDev =\n-            Math.sqrt(\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1));\n-\n-        // Calculate the skew as the sum the cubes of the distance \n-        // from the mean divided by the standard deviation.\n-        double accum3 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum3 += Math.pow((values[i] - mean) / stdDev, 3.0);\n-        }\n-\n-        // Get N\n-        double n = length;\n-\n-        // Calculate skewness\n-        skewness = (n / ((n - 1) * (n - 2))) * accum3;\n-\n-        return skewness;\n+        return skew.evaluate(values, begin, length);\n     }\n \n     /**\n     public static double kurtosis(double[] values) {\n         return kurtosis(values, 0, values.length);\n     }\n-    \n+\n     /**\n      * Returns the kurtosis for this collection of values. Kurtosis is a \n      * measure of the \"peakedness\" of a distribution.\n      * @return the kurtosis of the values or Double.NaN if the array is empty\n      */\n     public static double kurtosis(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-\n-        // Initialize the kurtosis\n-        double kurtosis = Double.NaN;\n-\n-        // Get the mean and the standard deviation\n-        double mean = mean(values, begin, length);\n-\n-        // Calc the std, this is implemented here instead of using the \n-        // standardDeviation method eliminate a duplicate pass to get the mean\n-        double accum = 0.0;\n-        double accum2 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow((values[i] - mean), 2.0);\n-            accum2 += (values[i] - mean);\n-        }\n-        \n-        double stdDev =\n-            Math.sqrt(\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1));\n-\n-        // Sum the ^4 of the distance from the mean divided by the \n-        // standard deviation\n-        double accum3 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum3 += Math.pow((values[i] - mean) / stdDev, 4.0);\n-        }\n-\n-        // Get N\n-        double n = length;\n-\n-        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n-        double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n-        \n-        // Calculate kurtosis\n-        kurtosis = (coefficientOne * accum3) - termTwo;\n-\n-        return kurtosis;\n-    }\n-    \n+        return kurt.evaluate(values, begin, length);\n+    }\n+\n     /**\n      * Returns the maximum of the available values\n      * @param values Is a double[] containing the values\n      * @return the maximum of the values or Double.NaN if the array is empty\n      */\n     public static double max(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        double max = Double.NaN;\n-        for (int i = begin; i < begin + length; i++) {\n-            if (i == 0) {\n-                max = values[i];\n-            } else {\n-                max = (max > values[i]) ? max : values[i];\n-            }\n-        }\n-        return max;\n+        return max.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the minimum of the values or Double.NaN if the array is empty\n      */\n     public static double min(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-\n-        double min = Double.NaN;\n-        for (int i = begin; i < begin + length; i++) {\n-            if (i == 0) {\n-                min = values[i];\n-            } else {\n-                min = (min < values[i]) ? min : values[i];\n-            }\n-        }\n-        return min;\n-    }\n-\n-    /**\n-     * Private testInput method used by all methods to verify the content \n-     * of the array and indicies are correct.\n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     */\n-    private static void testInput(double[] values, int begin, int length) {\n-\n-        if (length > values.length)\n-            throw new IllegalArgumentException(\"length > values.length\");\n-\n-        if (begin + length > values.length)\n-            throw new IllegalArgumentException(\"begin + length > values.length\");\n-\n-        if (values == null)\n-            throw new IllegalArgumentException(\"input value array is null\");\n-\n+        return min.evaluate(values, begin, length);\n+    }\n+\n+    /**\n+     * Returns the p'th percentile for a double[]\n+     * @param values Is a double[] containing the values\n+     * @param p is 0 <= p <= 100\n+     * @return the value at the p'th percentile\n+     */\n+    public static double percentile(double[] values, double p) {\n+        return percentile.evaluate(values, p);\n+    }\n+\n+    /**\n+     * Returns the p'th percentile for a double[]\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @param p is 0 <= p <= 100\n+     * @return the value at the p'th percentile\n+     */\n+    public static double percentile(\n+        double[] values,\n+        int begin,\n+        int length,\n+        double p) {\n+        return percentile.evaluate(values, begin, length, p);\n     }\n }", "timestamp": 1057429775, "metainfo": ""}