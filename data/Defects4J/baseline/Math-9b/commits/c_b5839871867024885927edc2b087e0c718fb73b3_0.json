{"sha": "b5839871867024885927edc2b087e0c718fb73b3", "log": "Added unit test.   ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/CircleProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.optimization.general;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Class that models a circle.\n+ * The parameters of problem are:\n+ * <ul>\n+ *  <li>the x-coordinate of the circle center,</li>\n+ *  <li>the y-coordinate of the circle center,</li>\n+ *  <li>the radius of the circle.</li>\n+ * </ul>\n+ * The model functions are:\n+ * <ul>\n+ *  <li>for each triplet (cx, cy, r), the (x, y) coordinates of a point on the\n+ *   corresponding circle.</li>\n+ * </ul>\n+ */\n+class CircleProblem implements DifferentiableMultivariateVectorFunction {\n+    /** Cloud of points assumed to be fitted by a circle. */\n+    private final ArrayList<double[]> points;\n+    /** Error on the x-coordinate of the points. */\n+    private final double xSigma;\n+    /** Error on the y-coordinate of the points. */\n+    private final double ySigma;\n+    /** Number of points on the circumference (when searching which\n+        model point is closest to a given \"observation\". */\n+    private final int resolution;\n+\n+    /**\n+     * @param xError Assumed error for the x-coordinate of the circle points.\n+     * @param xError Assumed error for the y-coordinate of the circle points.\n+     * @param searchResolution Number of points to try when searching the one\n+     * that is closest to a given \"observed\" point.\n+     */\n+    public CircleProblem(double xError,\n+                         double yError,\n+                         int searchResolution) {\n+        points = new ArrayList<double[]>();\n+        xSigma = xError;\n+        ySigma = yError;\n+        resolution = searchResolution;\n+    }\n+\n+    /**\n+     * @param xError Assumed error for the x-coordinate of the circle points.\n+     * @param xError Assumed error for the y-coordinate of the circle points.\n+     */\n+    public CircleProblem(double xError,\n+                         double yError) {\n+        this(xError, yError, 500);\n+    }\n+\n+    public void addPoint(double px, double py) {\n+        points.add(new double[] { px, py });\n+    }\n+\n+    public double[] target() {\n+        final double[] t = new double[points.size() * 2];\n+        for (int i = 0; i < points.size(); i++) {\n+            final double[] p = points.get(i);\n+            final int index = i * 2;\n+            t[index] = p[0];\n+            t[index + 1] = p[1];\n+        }\n+\n+        return t;\n+    }\n+\n+    public double[] weight() {\n+        final double wX = 1 / (xSigma * xSigma);\n+        final double wY = 1 / (ySigma * ySigma);\n+        final double[] w = new double[points.size() * 2];\n+        for (int i = 0; i < points.size(); i++) {\n+            final int index = i * 2;\n+            w[index] = wX;\n+            w[index + 1] = wY;\n+        }\n+\n+        return w;\n+    }\n+\n+    public double[] value(double[] params) {\n+        final double cx = params[0];\n+        final double cy = params[1];\n+        final double r = params[2];\n+\n+        final double[] model = new double[points.size() * 2];\n+\n+        final double deltaTheta = MathUtils.TWO_PI / resolution;\n+        for (int i = 0; i < points.size(); i++) {\n+            final double[] p = points.get(i);\n+            final double px = p[0];\n+            final double py = p[1];\n+\n+            double bestX = 0;\n+            double bestY = 0;\n+            double dMin = Double.POSITIVE_INFINITY;\n+\n+            // Find the angle for which the circle passes closest to the\n+            // current point (using a resolution of 100 points along the\n+            // circumference).\n+            for (double theta = 0; theta <= MathUtils.TWO_PI; theta += deltaTheta) {\n+                final double currentX = cx + r * FastMath.cos(theta);\n+                final double currentY = cy + r * FastMath.sin(theta);\n+                final double dX = currentX - px;\n+                final double dY = currentY - py;\n+                final double d = dX * dX + dY * dY;\n+                if (d < dMin) {\n+                    dMin = d;\n+                    bestX = currentX;\n+                    bestY = currentY;\n+                }\n+            }\n+\n+            final int index = i * 2;\n+            model[index] = bestX;\n+            model[index + 1] = bestY;\n+        }\n+\n+        return model;\n+    }\n+\n+    public MultivariateMatrixFunction jacobian() {\n+        return new MultivariateMatrixFunction() {\n+            public double[][] value(double[] point) {\n+                return jacobian(point);\n+            }\n+        };\n+    }\n+\n+    private double[][] jacobian(double[] params) {\n+        final double[][] jacobian = new double[points.size() * 2][3];\n+\n+        for (int i = 0; i < points.size(); i++) {\n+            final int index = i * 2;\n+            // Partial derivative wrt x-coordinate of center. \n+            jacobian[index][0] = 1;\n+            jacobian[index + 1][0] = 0;\n+            // Partial derivative wrt y-coordinate of center.\n+            jacobian[index][1] = 0;\n+            jacobian[index + 1][1] = 1;\n+            // Partial derivative wrt radius.\n+            final double[] p = points.get(i);\n+            jacobian[index][2] = (p[0] - params[0]) / params[2];\n+            jacobian[index + 1][2] = (p[1] - params[1]) / params[2];\n+        }\n+\n+        return jacobian;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n         }\n     }\n \n+    @Test\n+    public void testCircleFitting2() {\n+        final double xCenter = 123.456;\n+        final double yCenter = 654.321;\n+        final double xSigma = 10;\n+        final double ySigma = 15;\n+        final double radius = 111.111;\n+        final RandomCirclePointGenerator factory\n+            = new RandomCirclePointGenerator(xCenter, yCenter, radius,\n+                                             xSigma, ySigma,\n+                                             59421063L);\n+        final CircleProblem circle = new CircleProblem(xSigma, ySigma);\n+\n+        final int numPoints = 10;\n+        for (Point2D.Double p : factory.generate(numPoints)) {\n+            circle.addPoint(p.x, p.y);\n+            // System.out.println(p.x + \" \" + p.y);\n+        }\n+\n+        // First guess for the center's coordinates and radius.\n+        final double[] init = { 90, 659, 115 };\n+\n+        final LevenbergMarquardtOptimizer optimizer\n+            = new LevenbergMarquardtOptimizer();\n+        final PointVectorValuePair optimum = optimizer.optimize(100, circle,\n+                                                                circle.target(), circle.weight(),\n+                                                                init);\n+\n+        final double[] paramFound = optimum.getPoint();\n+\n+        // Retrieve errors estimation.\n+        final double[][] covMatrix = optimizer.getCovariances();\n+        final double[] asymptoticStandardErrorFound = optimizer.guessParametersErrors();\n+        final double[] sigmaFound = new double[covMatrix.length];\n+        for (int i = 0; i < covMatrix.length; i++) {\n+            sigmaFound[i] = FastMath.sqrt(covMatrix[i][i]);\n+//             System.out.println(\"i=\" + i + \" value=\" + paramFound[i]\n+//                                + \" sigma=\" + sigmaFound[i]\n+//                                + \" ase=\" + asymptoticStandardErrorFound[i]);\n+        }\n+\n+        // System.out.println(\"chi2=\" + optimizer.getChiSquare());\n+\n+        // Check that the parameters are found within the assumed error bars.\n+        Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]);\n+        Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]);\n+        Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]);\n+    }\n+\n     private static class LinearProblem implements DifferentiableMultivariateVectorFunction, Serializable {\n \n         private static final long serialVersionUID = 703247177355019415L;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/RandomCirclePointGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import org.apache.commons.math3.random.RandomData;\n+import org.apache.commons.math3.random.RandomDataImpl;\n+import org.apache.commons.math3.random.Well44497b;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Factory for generating a cloud of points that approximate a circle.\n+ */\n+public class RandomCirclePointGenerator {\n+    /** RNG. */\n+    private final RandomData random;\n+    /** Radius of the circle. */\n+    private final double radius;\n+    /** x-coordinate of the circle center. */\n+    private final double x;\n+    /** y-coordinate of the circle center. */\n+    private final double y;\n+    /** Error on the x-coordinate of the center. */\n+    private final double xSigma;\n+    /** Error on the x-coordinate of the center. */\n+    private final double ySigma;\n+\n+    /**\n+     * @param x Abscissa of the circle center.\n+     * @param y Ordinate of the circle center.\n+     * @param radius Radius of the circle.\n+     * @param xSigma Error on the x-coordinate of the circumferenc points.\n+     * @param ySigma Error on the y-coordinate of the circumferenc points.\n+     * @param seed RNG seed.\n+     */\n+    public RandomCirclePointGenerator(double x,\n+                                      double y,\n+                                      double radius,\n+                                      double xSigma,\n+                                      double ySigma,\n+                                      long seed) {\n+        random = new RandomDataImpl(new Well44497b((seed)));\n+        this.radius = radius;\n+        this.x = x;\n+        this.y = y;\n+        this.xSigma = xSigma;\n+        this.ySigma = ySigma;\n+    }\n+\n+    /**\n+     * Point generator.\n+     *\n+     * @param n Number of points to create.\n+     * @return the cloud of {@code n} points.\n+     */\n+    public Point2D.Double[] generate(int n) {\n+        final Point2D.Double[] cloud = new Point2D.Double[n];\n+        for (int i = 0; i < n; i++) {\n+            cloud[i] = create();\n+        }\n+        return cloud;\n+    }\n+\n+    /**\n+     * Create one point.\n+     *\n+     * @return a point.\n+     */\n+    private Point2D.Double create() {\n+        final double cX = random.nextGaussian(x, xSigma);\n+        final double cY = random.nextGaussian(y, ySigma);\n+        final double t = random.nextUniform(0, MathUtils.TWO_PI);\n+\n+        final double pX = cX + radius * FastMath.cos(t);\n+        final double pY = cY + radius * FastMath.sin(t);\n+\n+        return new Point2D.Double(pX, pY);\n+    }\n+}", "timestamp": 1335442429, "metainfo": ""}