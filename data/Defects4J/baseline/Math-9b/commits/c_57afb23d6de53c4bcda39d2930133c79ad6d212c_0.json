{"sha": "57afb23d6de53c4bcda39d2930133c79ad6d212c", "log": "Fixed a problem when building rotations from two pairs of vectors. In very rare cases, due to numerical inaccuracies the computed quaternion was not normalized (some examples went as high as 1.0e8) and even after normalization, the quaternion was plain wrong.  JIRA: MATH-801  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n               det);\n     }\n \n-    // There are different ways to compute the quaternions elements\n-    // from the matrix. They all involve computing one element from\n-    // the diagonal of the matrix, and computing the three other ones\n-    // using a formula involving a division by the first element,\n-    // which unfortunately can be zero. Since the norm of the\n-    // quaternion is 1, we know at least one element has an absolute\n-    // value greater or equal to 0.5, so it is always possible to\n-    // select the right formula and avoid division by zero and even\n-    // numerical inaccuracy. Checking the elements in turn and using\n-    // the first one greater than 0.45 is safe (this leads to a simple\n-    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n-    double s = ort[0][0] + ort[1][1] + ort[2][2];\n-    if (s > -0.19) {\n-      // compute q0 and deduce q1, q2 and q3\n-      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n-      double inv = 0.25 / q0;\n-      q1 = inv * (ort[1][2] - ort[2][1]);\n-      q2 = inv * (ort[2][0] - ort[0][2]);\n-      q3 = inv * (ort[0][1] - ort[1][0]);\n-    } else {\n-      s = ort[0][0] - ort[1][1] - ort[2][2];\n+    double[] quat = mat2quat(ort);\n+    q0 = quat[0];\n+    q1 = quat[1];\n+    q2 = quat[2];\n+    q3 = quat[3];\n+\n+  }\n+\n+  /** Convert an orthogonal rotation matrix to a quaternion.\n+   * @param ort orthogonal rotation matrix\n+   * @return quaternion corresponding to the matrix\n+   */\n+  private static double[] mat2quat(final double[][] ort) {\n+\n+      final double[] quat = new double[4];\n+\n+      // There are different ways to compute the quaternions elements\n+      // from the matrix. They all involve computing one element from\n+      // the diagonal of the matrix, and computing the three other ones\n+      // using a formula involving a division by the first element,\n+      // which unfortunately can be zero. Since the norm of the\n+      // quaternion is 1, we know at least one element has an absolute\n+      // value greater or equal to 0.5, so it is always possible to\n+      // select the right formula and avoid division by zero and even\n+      // numerical inaccuracy. Checking the elements in turn and using\n+      // the first one greater than 0.45 is safe (this leads to a simple\n+      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+      double s = ort[0][0] + ort[1][1] + ort[2][2];\n       if (s > -0.19) {\n-        // compute q1 and deduce q0, q2 and q3\n-        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n-        double inv = 0.25 / q1;\n-        q0 = inv * (ort[1][2] - ort[2][1]);\n-        q2 = inv * (ort[0][1] + ort[1][0]);\n-        q3 = inv * (ort[0][2] + ort[2][0]);\n+          // compute q0 and deduce q1, q2 and q3\n+          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n+          double inv = 0.25 / quat[0];\n+          quat[1] = inv * (ort[1][2] - ort[2][1]);\n+          quat[2] = inv * (ort[2][0] - ort[0][2]);\n+          quat[3] = inv * (ort[0][1] - ort[1][0]);\n       } else {\n-        s = ort[1][1] - ort[0][0] - ort[2][2];\n-        if (s > -0.19) {\n-          // compute q2 and deduce q0, q1 and q3\n-          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n-          double inv = 0.25 / q2;\n-          q0 = inv * (ort[2][0] - ort[0][2]);\n-          q1 = inv * (ort[0][1] + ort[1][0]);\n-          q3 = inv * (ort[2][1] + ort[1][2]);\n-        } else {\n-          // compute q3 and deduce q0, q1 and q2\n-          s = ort[2][2] - ort[0][0] - ort[1][1];\n-          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n-          double inv = 0.25 / q3;\n-          q0 = inv * (ort[0][1] - ort[1][0]);\n-          q1 = inv * (ort[0][2] + ort[2][0]);\n-          q2 = inv * (ort[2][1] + ort[1][2]);\n-        }\n-      }\n-    }\n+          s = ort[0][0] - ort[1][1] - ort[2][2];\n+          if (s > -0.19) {\n+              // compute q1 and deduce q0, q2 and q3\n+              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n+              double inv = 0.25 / quat[1];\n+              quat[0] = inv * (ort[1][2] - ort[2][1]);\n+              quat[2] = inv * (ort[0][1] + ort[1][0]);\n+              quat[3] = inv * (ort[0][2] + ort[2][0]);\n+          } else {\n+              s = ort[1][1] - ort[0][0] - ort[2][2];\n+              if (s > -0.19) {\n+                  // compute q2 and deduce q0, q1 and q3\n+                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n+                  double inv = 0.25 / quat[2];\n+                  quat[0] = inv * (ort[2][0] - ort[0][2]);\n+                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n+                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n+              } else {\n+                  // compute q3 and deduce q0, q1 and q2\n+                  s = ort[2][2] - ort[0][0] - ort[1][1];\n+                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n+                  double inv = 0.25 / quat[3];\n+                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n+                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n+                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n+              }\n+          }\n+      }\n+\n+      return quat;\n \n   }\n \n    * @param u2 second vector of the origin pair\n    * @param v1 desired image of u1 by the rotation\n    * @param v2 desired image of u2 by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero\n-   */\n-  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n-\n-  // norms computation\n-  double u1u1 = u1.getNormSq();\n-  double u2u2 = u2.getNormSq();\n-  double v1v1 = v1.getNormSq();\n-  double v2v2 = v2.getNormSq();\n-  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n-    throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n-  }\n-\n-  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n-  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n-\n-  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n-  double u1u2   = u1.dotProduct(u2);\n-  double v1v2   = v1.dotProduct(v2);\n-  double coeffU = u1u2 / u1u1;\n-  double coeffV = v1v2 / u1u1;\n-  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n-  double alpha  = coeffU - beta * coeffV;\n-  v2 = new Vector3D(alpha, v1, beta, v2);\n-\n-  // preliminary computation\n-  Vector3D uRef  = u1;\n-  Vector3D vRef  = v1;\n-  Vector3D v1Su1 = v1.subtract(u1);\n-  Vector3D v2Su2 = v2.subtract(u2);\n-  Vector3D k     = v1Su1.crossProduct(v2Su2);\n-  Vector3D u3    = u1.crossProduct(u2);\n-  double c       = k.dotProduct(u3);\n-  final double inPlaneThreshold = 0.001;\n-  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);\n-      c = k.dotProduct(u2.crossProduct(u3));\n-\n-      if (c <= 0) {\n-        // the (q1, q2, q3) vector is aligned with everything\n-        // this is really the identity rotation\n-        q0 = 1.0;\n-        q1 = 0.0;\n-        q2 = 0.0;\n-        q3 = 0.0;\n-        return;\n-      }\n-\n-      // we will have to use u2 and v2 to compute the scalar part\n-      uRef = u2;\n-      vRef = v2;\n-\n-    }\n-\n-  }\n-\n-  // compute the vectorial part\n-  c = FastMath.sqrt(c);\n-  double inv = 1.0 / (c + c);\n-  q1 = inv * k.getX();\n-  q2 = inv * k.getY();\n-  q3 = inv * k.getZ();\n-\n-  // compute the scalar part\n-   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n-                    uRef.getZ() * q1 - uRef.getX() * q3,\n-                    uRef.getX() * q2 - uRef.getY() * q1);\n-  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n+   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero,\n+   * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n+   */\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n+      throws MathIllegalArgumentException {\n+\n+      // build orthonormalized base from u1, u2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D u3 = u1.crossProduct(u2).normalize();\n+      u2 = u3.crossProduct(u1).normalize();\n+      u1 = u1.normalize();\n+\n+      // build an orthonormalized base from v1, v2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D v3 = v1.crossProduct(v2).normalize();\n+      v2 = v3.crossProduct(v1).normalize();\n+      v1 = v1.normalize();\n+\n+      // buid a matrix transforming the first base into the second one\n+      final double[][] m = new double[][] {\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n+              MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n+              MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n+          }\n+      };\n+\n+      double[] quat = mat2quat(m);\n+      q0 = quat[0];\n+      q1 = quat[1];\n+      q2 = quat[2];\n+      q3 = quat[3];\n \n   }\n \n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java\n \n package org.apache.commons.math3.geometry.euclidean.threed;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathUtils;\n     try {\n         new Rotation(u1, u2, Vector3D.ZERO, v2);\n         Assert.fail(\"an exception should have been thrown\");\n-    } catch (IllegalArgumentException e) {\n+    } catch (MathArithmeticException e) {\n       // expected behavior\n     }\n \n       Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);\n   }\n \n+  @Test\n+  public void testIssue801() {\n+      Vector3D u1 = new Vector3D(0.9999988431610581, -0.0015210774290851095, 0.0);\n+      Vector3D u2 = new Vector3D(0.0, 0.0, 1.0);\n+\n+      Vector3D v1 = new Vector3D(0.9999999999999999, 0.0, 0.0);\n+      Vector3D v2 = new Vector3D(0.0, 0.0, -1.0);\n+\n+      Rotation quat = new Rotation(u1, u2, v1, v2);\n+      double q2 = quat.getQ0() * quat.getQ0() +\n+                  quat.getQ1() * quat.getQ1() +\n+                  quat.getQ2() * quat.getQ2() +\n+                  quat.getQ3() * quat.getQ3();\n+      Assert.assertEquals(1.0, q2, 1.0e-14);\n+      Assert.assertEquals(0.0, Vector3D.angle(v1, quat.applyTo(u1)), 1.0e-14);\n+      Assert.assertEquals(0.0, Vector3D.angle(v2, quat.applyTo(u2)), 1.0e-14);\n+      \n+  }\n+\n   private void checkVector(Vector3D v1, Vector3D v2) {\n     Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n   }", "timestamp": 1338920762, "metainfo": ""}