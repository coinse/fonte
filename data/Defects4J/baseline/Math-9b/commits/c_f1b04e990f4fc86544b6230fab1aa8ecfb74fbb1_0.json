{"sha": "f1b04e990f4fc86544b6230fab1aa8ecfb74fbb1", "log": "MATH-855 (second take). Best point must be returned.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n import org.apache.commons.math3.optimization.GoalType;\n \n /**\n- * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * For a function defined on some interval {@code (lo, hi)}, this class\n+ * finds an approximation {@code x} to the point at which the function\n+ * attains its minimum.\n+ * It implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n- * univariate functions. This implementation is an adaptation partly\n- * based on the Python code from SciPy (module \"optimize.py\" v0.5).\n- * If the function is defined on some interval {@code (lo, hi)}, then\n- * this method finds an approximation {@code x} to the point at which\n- * the function attains its minimum.\n+ * univariate functions.\n+ * <br/>\n+ * This code is an adaptation, partly based on the Python code from SciPy\n+ * (module \"optimize.py\" v0.5); the original algorithm is also modified\n+ * <ul>\n+ *  <li>to use an initial guess provided by the user,</li>\n+ *  <li>to ensure that the best point encountered is the one returned.</li>\n+ * </ul>\n  *\n  * @version $Id$\n  * @since 2.0\n         UnivariatePointValuePair previous = null;\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+        // Best point encountered so far (which is the initial guess).\n+        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+                best = best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return best;\n                     }\n                 }\n \n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(current, previous, isMinim);\n+                return best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n             }\n             ++iter;\n         }\n      * @param isMinim {@code true} if the selected point must be the one with\n      * the lowest value.\n      * @return the best point, or {@code null} if {@code a} and {@code b} are\n-     * both {@code null}.\n+     * both {@code null}. When {@code a} and {@code b} have the same function\n+     * value, {@code a} is returned.\n      */\n     private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                           UnivariatePointValuePair b,\n         }\n \n         if (isMinim) {\n-            return a.getValue() < b.getValue() ? a : b;\n+            return a.getValue() <= b.getValue() ? a : b;\n         } else {\n-            return a.getValue() > b.getValue() ? a : b;\n+            return a.getValue() >= b.getValue() ? a : b;\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java\n     }\n \n     /**\n+     * Contrived example showing that prior to the resolution of MATH-855\n+     * (second revision), the algorithm would not return the best point if\n+     * it happened to be the initial guess.\n+     */\n+    @Test\n+    public void testKeepInitIfBest() {\n+        final double minSin = 3 * Math.PI / 2;\n+        final double offset = 1e-8;\n+        final double delta = 1e-7;\n+        final UnivariateFunction f1 = new Sin();\n+        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\n+                                                       new double[] { 0, -1, 0 });\n+        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n+        // A slightly less stringent tolerance would make the test pass\n+        // even with the previous implementation.\n+        final double relTol = 1e-8;\n+        final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\n+        final double init = minSin + 1.5 * offset;\n+        final UnivariatePointValuePair result\n+            = optimizer.optimize(200, f, GoalType.MINIMIZE,\n+                                 minSin - 6.789 * delta,\n+                                 minSin + 9.876 * delta,\n+                                 init);\n+        final int numEval = optimizer.getEvaluations();\n+\n+        final double sol = result.getPoint();\n+        final double expected = init;\n+\n+//         System.out.println(\"numEval=\" + numEval);\n+//         System.out.println(\"min=\" + init + \" f=\" + f.value(init));\n+//         System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n+//         System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n+\n+        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n+    }\n+\n+    /**\n      * Contrived example showing that prior to the resolution of MATH-855,\n      * the algorithm, by always returning the last evaluated point, would\n      * sometimes not report the best point it had found.\n         final UnivariateFunction f = FunctionUtils.add(f1, f2);\n         final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);\n         final UnivariatePointValuePair result\n-            = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta);\n+            = optimizer.optimize(200, f, GoalType.MINIMIZE,\n+                                 minSin - 6.789 * delta,\n+                                 minSin + 9.876 * delta);\n         final int numEval = optimizer.getEvaluations();\n \n         final double sol = result.getPoint();", "timestamp": 1347032620, "metainfo": ""}