{"sha": "8a1d5e0a29e6da7384b94b2564684a96663c967e", "log": "Just Checkstyle and Javadoc corrections   ", "commit": "\n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n \n /**\n  * Signals a configuration problem with any of the factory methods.\n- * \n- * @version $Revision: 1.5 $ $Date: 2003/07/30 21:58:10 $\n+ * @version $Revision: 1.6 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class MathConfigurationException extends MathException {\n \n      * Construct an exception with the given message.\n      * @param message message describing the problem\n      */\n-    public MathConfigurationException(String message) {\n+    public MathConfigurationException(final String message) {\n         super(message);\n     }\n \n      * @param message message describing the problem\n      * @param throwable caught exception causing this problem\n      */\n-    public MathConfigurationException(String message, Throwable throwable) {\n+    public MathConfigurationException(\n+        final String message,\n+        final Throwable throwable) {\n         super(message, throwable);\n     }\n \n      * Construct an exception with the given root cause.\n      * @param throwable caught exception causing this problem\n      */\n-    public MathConfigurationException(Throwable throwable) {\n+    public MathConfigurationException(final Throwable throwable) {\n         super(throwable);\n     }\n }\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n \n /**\n  * A generic exception indicating problems in the math package.\n- *  \n- * @version $Revision: 1.4 $ $Date: 2003/07/09 20:02:44 $\n+ * @version $Revision: 1.5 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class MathException extends Exception {\n \n     /**\n-     * \n+     * Constructs a MathException\n      */\n     public MathException() {\n         super();\n     /**\n      * @param message message describing the problem\n      */\n-    public MathException(String message) {\n+    public MathException(final String message) {\n         super(message);\n     }\n \n      * @param message message describing the problem\n      * @param throwable caught exception causing this problem\n      */\n-    public MathException(String message, Throwable throwable) {\n+    public MathException(final String message, final Throwable throwable) {\n         super(message, throwable);\n     }\n \n     /**\n      * @param throwable caught exception causing this problem\n      */\n-    public MathException(Throwable throwable) {\n+    public MathException(final Throwable throwable) {\n         super(throwable);\n     }\n \n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n  * Provide the bisection algorithm for solving for zeros of real univariate\n  * functions.  It will only search for one zero in the given interval.  The\n  * function is supposed to be continuous but not necessarily smooth.\n- *  \n- * @version $Revision: 1.2 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class BisectionSolver extends UnivariateRealSolverImpl {\n     /**\n--- a/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n  * univariate statistics for a List of Java Beans by property.  This \n  * implementation uses beanutils' PropertyUtils to get a simple, nested,\n  * indexed, mapped, or combined property from an element of a List.\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 21:45:23 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class BeanListUnivariateImpl extends ListUnivariateImpl {\n \n         this.transformer = new BeanTransformer(propertyName);\n     }\n \n-   /**\n-     * @see org.apache.commons.math.Univariate#addValue(double)\n-     */\n+    /**\n+      * @see org.apache.commons.math.Univariate#addValue(double)\n+      */\n     public void addValue(double v) {\n         String msg =\n             \"The BeanListUnivariateImpl does not accept values \"\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  * StatUtils provides easy static implementations of common double[] based\n  * statistical methods. These return a single result value or in some cases, as\n  * identified in the javadoc for each method, Double.NaN.\n- * @version $Revision: 1.14 $ $Date: 2003/07/09 21:45:23 $\n+ * @version $Revision: 1.15 $ $Date: 2003/08/09 04:03:41 $\n  */\n-public class StatUtils {\n+public final class StatUtils {\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private StatUtils() {\n+    }\n \n     /**\n      * The sum of the values that have been added to Univariate.\n      * @param values Is a double[] containing the values\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n-    public static double sum(double[] values) {\n+    public static double sum(final double[] values) {\n         return sum(values, 0, values.length);\n     }\n \n      * @param length processing at this point in the array\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n-    public static double sum(double[] values, int begin, int length) {\n+    public static double sum(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n         double accum = 0.0;\n         for (int i = begin; i < begin + length; i++) {\n      * @param values Is a double[] containing the values\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n-    public static double sumSq(double[] values) {\n+    public static double sumSq(final double[] values) {\n         return sumSq(values, 0, values.length);\n     }\n \n      * @param length processing at this point in the array\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n-    public static double sumSq(double[] values, int begin, int length) {\n+    public static double sumSq(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n         double accum = 0.0;\n         for (int i = begin; i < begin + length; i++) {\n      * @param values Is a double[] containing the values\n      * @return the product values or Double.NaN if the array is empty\n      */\n-    public static double product(double[] values) {\n+    public static double product(final double[] values) {\n         return product(values, 0, values.length);\n     }\n \n      * @param length processing at this point in the array\n      * @return the product values or Double.NaN if the array is empty\n      */\n-    public static double product(double[] values, int begin, int length) {\n+    public static double product(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n         double product = 1.0;\n         for (int i = begin; i < begin + length; i++) {\n      * @param values Is a double[] containing the values\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n-    public static double sumLog(double[] values) {\n+    public static double sumLog(final double[] values) {\n         return sumLog(values, 0, values.length);\n     }\n \n      * @param length processing at this point in the array\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n-    public static double sumLog(double[] values, int begin, int length) {\n+    public static double sumLog(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n         double sumLog = 0.0;\n         for (int i = begin; i < begin + length; i++) {\n \n     /**\n      * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n-     * arithmetic mean </a> of the available values \n+     * arithmetic mean </a> of the available values\n      * @param values Is a double[] containing the values\n      * @return the mean of the values or Double.NaN if the array is empty\n      */\n-    public static double mean(double[] values) {\n+    public static double mean(final double[] values) {\n         return sum(values) / (double) values.length;\n     }\n \n     /**\n       * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n-      * arithmetic mean </a> of the available values \n+      * arithmetic mean </a> of the available values\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n       * @return the mean of the values or Double.NaN if the array is empty\n       */\n-    public static double mean(double[] values, int begin, int length) {\n+    public static double mean(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n         return sum(values, begin, length) / ((double) length);\n     }\n \n     /**\n      * Returns the variance of the available values. This uses a corrected\n-     * two pass algorithm of the following \n+     * two pass algorithm of the following\n      * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n      * corrected two pass formula (14.1.8)</a>, and also referenced in:<p/>\n      * \"Algorithms for Computing the Sample Variance: Analysis and\n-     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n      * 1983, American Statistician, vol. 37, pp. 242?247.\n-     * \n-     * @param values Is a double[] containing the values\n-     * @return the result, Double.NaN if no values for an empty array \n-     * or 0.0 for a single value set.  \n-     */\n-    public static double variance(double[] values) {\n+     *\n+     * @param values Is a double[] containing the values\n+     * @return the result, Double.NaN if no values for an empty array\n+     * or 0.0 for a single value set.\n+     */\n+    public static double variance(final double[] values) {\n         return variance(values, 0, values.length);\n     }\n \n     /**\n      * Returns the variance of the available values. This uses a corrected\n-     * two pass algorithm of the following \n+     * two pass algorithm of the following\n      * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n      * corrected two pass formula (14.1.8)</a>, and also referenced in:<p/>\n      * \"Algorithms for Computing the Sample Variance: Analysis and\n-     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n      * 1983, American Statistician, vol. 37, pp. 242?247.\n-     * \n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     * @return the result, Double.NaN if no values for an empty array \n-     * or 0.0 for a single value set.  \n-     */\n-    public static double variance(double[] values, int begin, int length) {\n+     *\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the result, Double.NaN if no values for an empty array\n+     * or 0.0 for a single value set.\n+     */\n+    public static double variance(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n \n         double variance = Double.NaN;\n                 accum2 += (values[i] - mean);\n             }\n             variance =\n-                (accum - (Math.pow(accum2, 2) / ((double)length)))\n+                (accum - (Math.pow(accum2, 2) / ((double) length)))\n                     / (double) (length - 1);\n         }\n         return variance;\n      * @param values Is a double[] containing the values\n      * @return the maximum of the values or Double.NaN if the array is empty\n      */\n-    public static double max(double[] values) {\n+    public static double max(final double[] values) {\n         return max(values, 0, values.length);\n     }\n \n      * @param length processing at this point in the array\n      * @return the maximum of the values or Double.NaN if the array is empty\n      */\n-    public static double max(double[] values, int begin, int length) {\n+    public static double max(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         testInput(values, begin, length);\n         double max = Double.NaN;\n         for (int i = begin; i < begin + length; i++) {\n             if (i == 0) {\n                 max = values[i];\n             } else {\n-                max = (max > values[i]) ? max : values[i];\n+                if (max < values[i]) {\n+                    max = values[i];\n+                }\n             }\n         }\n         return max;\n      * @param values Is a double[] containing the values\n      * @return the minimum of the values or Double.NaN if the array is empty\n      */\n-    public static double min(double[] values) {\n+    public static double min(final double[] values) {\n         return min(values, 0, values.length);\n     }\n \n      * @param length processing at this point in the array\n      * @return the minimum of the values or Double.NaN if the array is empty\n      */\n-    public static double min(double[] values, int begin, int length) {\n+    public static double min(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n+\n         testInput(values, begin, length);\n \n         double min = Double.NaN;\n             if (i == 0) {\n                 min = values[i];\n             } else {\n-                min = (min < values[i]) ? min : values[i];\n+                if (min > values[i]) {\n+                    min = values[i];\n+                }\n             }\n         }\n         return min;\n     }\n \n     /**\n-     * Private testInput method used by all methods to verify the content \n+     * Private testInput method used by all methods to verify the content\n      * of the array and indicies are correct.\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n      */\n-    private static void testInput(double[] values, int begin, int length) {\n-\n-        if (length > values.length)\n+    private static void testInput(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n+\n+        if (length > values.length) {\n             throw new IllegalArgumentException(\"length > values.length\");\n-\n-        if (begin + length > values.length)\n-            throw new IllegalArgumentException(\"begin + length > values.length\");\n-\n-        if (values == null)\n+        }\n+\n+        if (begin + length > values.length) {\n+            throw new IllegalArgumentException(\n+               \"begin + length > values.length\");\n+        }\n+\n+        if (values == null) {\n             throw new IllegalArgumentException(\"input value array is null\");\n-\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/AbstractStorelessUnivariateStatistic.java\n  * Provides the ability to extend polymophically so that\n  * indiviual statistics do not need to implement these methods unless\n  * there are better algorithms for handling the calculation.\n- * @version $Revision: 1.6 $ $Date: 2003/07/30 21:58:11 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public abstract class AbstractStorelessUnivariateStatistic\n     extends AbstractUnivariateStatistic\n     implements StorelessUnivariateStatistic {\n \n     /**\n-     * This implements the AbstractUnivariateStatistic impl to funnel \n+     * This implements the AbstractUnivariateStatistic impl to funnel\n      * calculation off to the instantanious increment method. In most cases of\n-     * StorelessUnivariateStatistic this is never really used because more \n+     * StorelessUnivariateStatistic this is never really used because more\n      * efficient algorithms are available for that statistic.\n-     * @see org.apache.commons.math.stat.univariate.\n-     * UnivariateStatistic#evaluate(double[], int, int)\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         if (this.test(values, begin, length)) {\n             this.clear();\n             int l = begin + length;\n         return getResult();\n     }\n \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public abstract void clear();\n+\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n+     */\n+    public abstract double getResult();\n+\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public abstract void increment(final double d);\n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/AbstractUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/AbstractUnivariateStatistic.java\n /**\n  * Abstract Implementation for UnivariateStatistics.\n  * Provides the ability to extend polymophically so that\n- * indiviual statistics do not need to implement these methods. \n- * @version $Revision: 1.5 $ $Date: 2003/07/15 03:37:10 $\n+ * indiviual statistics do not need to implement these methods.\n+ * @version $Revision: 1.6 $ $Date: 2003/08/09 04:03:41 $\n  */\n public abstract class AbstractUnivariateStatistic\n     implements UnivariateStatistic {\n     /**\n      * This implementation provides a simple wrapper around the double[]\n      * and passes the request onto the evaluate(DoubleArray da) method.\n-     * \n-     * @see org.apache.commons.math.stat.univariate.\n-     * UnivariateStatistic#evaluate(double[])\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[])\n      */\n-    public double evaluate(double[] values) {\n+    public double evaluate(final double[] values) {\n         return evaluate(values, 0, values.length);\n     }\n \n     /**\n      * Subclasses of AbstractUnivariateStatistc need to implement this method.\n-     * @see org.apache.commons.math.stat.univariate.\n-     * UnivariateStatistic#evaluate(double[], int, int)\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public abstract double evaluate(double[] values, int begin, int length);\n+    public abstract double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length);\n \n     /**\n-     * this protected test method used by all methods to verify the content \n+     * this protected test method used by all methods to verify the content\n      * of the array and indicies are correct.\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n+     * @return this is used to determine if the array is of 0 length or not,\n+     * it is used by an individual statistic to determine if continuation\n+     * of a statistical calculation should continue or return NaN.\n      */\n-    protected boolean test(double[] values, int begin, int length) {\n+    protected boolean test(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n \n         if (length > values.length) {\n             throw new IllegalArgumentException(\"length > values.length\");\n         }\n \n         if (begin + length > values.length) {\n-            throw new IllegalArgumentException(\"begin + length > values.length\");\n+            throw new IllegalArgumentException(\n+                \"begin + length > values.length\");\n         }\n \n         if (values == null) {\n--- a/src/java/org/apache/commons/math/stat/univariate/StorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/StorelessUnivariateStatistic.java\n /**\n  * Extends the capabilities of UnivariateStatistic with a statefull incremental\n  * strategy through three methods for calculating a statistic without having to\n- * maintain a double[] of the values. Because a StorelessUnivariateStatistic \n- * does not require that a double[] storage structure be maintained with the \n- * values in it, there are only a subset of known statistics can actually be \n- * implemented using it. If a Statistic cannot be implemented in a Storeless \n- * approach it should implement the UnivariateStatistic interface directly \n+ * maintain a double[] of the values. Because a StorelessUnivariateStatistic\n+ * does not require that a double[] storage structure be maintained with the\n+ * values in it, there are only a subset of known statistics can actually be\n+ * implemented using it. If a Statistic cannot be implemented in a Storeless\n+ * approach it should implement the UnivariateStatistic interface directly\n  * instead.\n- * @version $Revision: 1.6 $ $Date: 2003/07/15 03:37:10 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public interface StorelessUnivariateStatistic extends UnivariateStatistic {\n \n--- a/src/java/org/apache/commons/math/stat/univariate/UnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/UnivariateStatistic.java\n package org.apache.commons.math.stat.univariate;\n \n /**\n- * UnivariateStatistic interface provides methods to evaluate \n- * double[] based content using an implemented statistical approach. \n- * The interface provides two \"stateless\" simple methods to calculate \n+ * UnivariateStatistic interface provides methods to evaluate\n+ * double[] based content using an implemented statistical approach.\n+ * The interface provides two \"stateless\" simple methods to calculate\n  * a statistic from a double[] based parameter.\n- * @version $Revision: 1.5 $ $Date: 2003/07/15 03:37:10 $\n+ * @version $Revision: 1.6 $ $Date: 2003/08/09 04:03:41 $\n  */\n public interface UnivariateStatistic {\n-    \n+\n     /**\n      * Evaluates the double[] returning the result of the evaluation.\n      * @param values Is a double[] containing the values\n-     * @return the result of the evaluation or Double.NaN \n+     * @return the result of the evaluation or Double.NaN\n      * if the array is empty\n      */\n     double evaluate(double[] values);\n \n     /**\n-     * Evaluates part of a double[] returning the result \n+     * Evaluates part of a double[] returning the result\n      * of the evaluation.\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n-     * @return the result of the evaluation or Double.NaN \n+     * @return the result of the evaluation or Double.NaN\n      * if the array is empty\n      */\n-    double evaluate(double[] values, int begin, int length); \n+    double evaluate(double[] values, int begin, int length);\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n \n /**\n  * FirstMoment.java\n- * \n- * The FirstMoment (arithmentic mean) is calculated using the following \n+ *\n+ * The FirstMoment (arithmentic mean) is calculated using the following\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.5 $ $Date: 2003/07/15 03:36:36 $\n+ * @version $Revision: 1.6 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class FirstMoment extends AbstractStorelessUnivariateStatistic {\n \n     /** first moment of values that have been added */\n     protected double m1 = Double.NaN;\n \n-    /** \n+    /**\n      * temporary internal state made available for\n-     * higher order moments \n+     * higher order moments\n      */\n     protected double dev = 0.0;\n \n-    /** \n+    /**\n      * temporary internal state made available for\n-     * higher order moments \n+     * higher order moments\n      */\n     protected double v = 0.0;\n \n-    /** \n+    /**\n      * temporary internal state made available for\n-     * higher order moments \n+     * higher order moments\n      */\n     protected double n0 = 0.0;\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#increment(double)\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (n < 1) {\n             m1 = 0.0;\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#clear()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n         m1 = Double.NaN;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return m1;\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n package org.apache.commons.math.stat.univariate.moment;\n \n /**\n- * The FourthMoment is calculated using the following \n+ * The FourthMoment is calculated using the following\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:10 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class FourthMoment extends ThirdMoment {\n \n     /** fourth moment of values that have been added */\n     protected double m4 = Double.NaN;\n-    \n+\n     /** temporary internal state made available for higher order moments */\n     protected double prevM3 = 0.0;\n \n     /** temporary internal state made available for higher order moments */\n     protected double n3 = 0.0;\n-            \n-            \n+\n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (n < 1) {\n-            m4 = m3 = m2 = m1 = 0.0;\n+            m4 = 0.0;\n+            m3 = 0.0;\n+            m2 = 0.0;\n+            m1 = 0.0;\n         }\n \n         /* retain previous m3 */\n         prevM3 = m3;\n-        \n+\n         /* increment m1, m2 and m3 (and prevM2, _n0, _n1, _n2, _v, _v2) */\n         super.increment(d);\n \n         n3 = (double) (n - 3);\n-        \n+\n         m4 =\n             m4\n                 - (4.0 * v * prevM3)\n                 + (6.0 * v2 * prevM2)\n                 + ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n     }\n-    \n+\n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return m4;\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n \n import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n \n-/** \n+/**\n  * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n  * geometric mean </a> of the available values\n- * @version $Revision: 1.8 $ $Date: 2003/07/09 20:04:10 $\n+ * @version $Revision: 1.9 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class GeometricMean extends SumOfLogs {\n \n+    /** */\n     protected int n = 0;\n \n+    /** */\n     private double geoMean = Double.NaN;\n-    \n+\n+    /** */\n     private double lastSum = 0.0;\n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         n++;\n         super.increment(d);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         if (lastSum != super.getResult() || n == 1) {\n      * any of the values are &lt;= 0.\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         return Math.exp(\n             super.evaluate(values, begin, length) / (double) length);\n     }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:10 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class Kurtosis extends AbstractStorelessUnivariateStatistic {\n \n+    /** */\n     protected FourthMoment moment = null;\n \n+    /** */\n     protected boolean incMoment = true;\n \n+    /** */\n     private double kurtosis = Double.NaN;\n \n+    /** */\n     private int n = 0;\n-    \n+\n+    /**\n+     * Construct a Kurtosis\n+     */\n     public Kurtosis() {\n         moment = new FourthMoment();\n     }\n \n-    public Kurtosis(FourthMoment m4) {\n+    /**\n+     * Construct a Kurtosis with an external moment\n+     * @param m4 external Moment\n+     */\n+    public Kurtosis(final FourthMoment m4) {\n         incMoment = false;\n         this.moment = m4;\n     }\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         if (n < moment.n) {\n             }\n             n = moment.n;\n         }\n-        \n+\n         return kurtosis;\n     }\n \n \n     /*UnvariateStatistic Approach */\n \n+    /** */\n     Mean mean = new Mean();\n \n     /**\n-    * This algorithm uses a corrected two pass algorithm of the following \n+    * This algorithm uses a corrected two pass algorithm of the following\n      * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n      * corrected two pass formula (14.1.8)</a>, and also referenced in:\n      * <p>\n      * \"Algorithms for Computing the Sample Variance: Analysis and\n-     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n      * 1983, American Statistician, vol. 37, pp. 242?247.\n      * </p>\n-    * Returns the kurtosis for this collection of values. Kurtosis is a \n+    * Returns the kurtosis for this collection of values. Kurtosis is a\n     * measure of the \"peakedness\" of a distribution.\n     * @param values Is a double[] containing the values\n     * @param begin processing at this point in the array\n     * @param length processing at this point in the array\n     * @return the kurtosis of the values or Double.NaN if the array is empty\n     */\n-    public double evaluate(double[] values, int begin, int length) {\n-        ;\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n \n         // Initialize the kurtosis\n         double kurt = Double.NaN;\n                 // Get the mean and the standard deviation\n                 double m = mean.evaluate(values, begin, length);\n \n-                // Calc the std, this is implemented here instead of using the \n-                // standardDeviation method eliminate a duplicate pass to get the mean\n+                // Calc the std, this is implemented here instead\n+                // of using the standardDeviation method eliminate\n+                // a duplicate pass to get the mean\n                 double accum = 0.0;\n                 double accum2 = 0.0;\n                 for (int i = begin; i < begin + length; i++) {\n                         (accum - (Math.pow(accum2, 2) / ((double) length)))\n                             / (double) (length - 1));\n \n-                // Sum the ^4 of the distance from the mean divided by the \n+                // Sum the ^4 of the distance from the mean divided by the\n                 // standard deviation\n                 double accum3 = 0.0;\n                 for (int i = begin; i < begin + length; i++) {\n                 }\n \n                 // Get N\n-                double n = length;\n+                double n0 = length;\n \n                 double coefficientOne =\n-                    (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n+                    (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));\n                 double termTwo =\n-                    ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n+                    ((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));\n \n                 // Calculate kurtosis\n                 kurt = (coefficientOne * accum3) - termTwo;\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.univariate.summary.Sum;\n \n /**\n  * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n  * arithmetic mean </a> of the available values.\n- * @version $Revision: 1.7 $ $Date: 2003/07/15 03:36:36 $\n+ * @version $Revision: 1.8 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class Mean extends AbstractStorelessUnivariateStatistic {\n \n     /** first moment of values that have been added */\n     protected FirstMoment moment = null;\n \n+    /** */\n     protected boolean incMoment = true;\n \n+    /** */\n     public Mean() {\n         moment = new FirstMoment();\n     }\n \n-    public Mean(FirstMoment m1) {\n+    /**\n+     * Constructs a Mean with an External Moment.\n+     * @param m1 the moment\n+     */\n+    public Mean(final FirstMoment m1) {\n         this.moment = m1;\n         incMoment = false;\n     }\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return moment.m1;\n     }\n \n     /*UnvariateStatistic Approach */\n-    Sum sum = new Sum();\n-    \n+\n+    /** */\n+    protected Sum sum = new Sum();\n+\n     /**\n      * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n      * arithmetic mean </a> of a double[] of the available values.\n      * @return the mean of the values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         if (test(values, begin, length)) {\n             return sum.evaluate(values) / ((double) length);\n         }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n package org.apache.commons.math.stat.univariate.moment;\n \n /**\n- * The SecondMoment is calculated using the following \n+ * The SecondMoment is calculated using the following\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:10 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class SecondMoment extends FirstMoment {\n \n \n     /** temporary internal state made availabel for higher order moments */\n     protected double n1 = 0.0;\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (n < 1) {\n             m1 = m2 = 0.0;\n         }\n-        \n+\n         /* increment m1 and _n0, _dev,  _v) */\n         super.increment(d);\n \n         n1 = n0 - 1;\n-        \n+\n         /* increment and return m2 */\n         m2 += n1 * dev * v;\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return m2;\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * \n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:10 $\n+ *\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class Skewness extends AbstractStorelessUnivariateStatistic {\n \n+    /** */\n     protected ThirdMoment moment = null;\n \n+    /** */\n     protected boolean incMoment = true;\n \n+    /** */\n     protected double skewness = Double.NaN;\n \n+    /** */\n     private int n = 0;\n-    \n+\n+    /**\n+     * Constructs a Skewness\n+     */\n     public Skewness() {\n         moment = new ThirdMoment();\n     }\n \n-    public Skewness(ThirdMoment m3) {\n+    /**\n+     * Constructs a Skewness with an external moment\n+     * @param m3 external moment\n+     */\n+    public Skewness(final ThirdMoment m3) {\n         incMoment = false;\n         this.moment = m3;\n     }\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         if (n < moment.n) {\n         skewness = Double.NaN;\n         n = 0;\n     }\n-    \n+\n     /*UnvariateStatistic Approach */\n \n+    /** */\n     Mean mean = new Mean();\n \n     /**\n-     * This algorithm uses a corrected two pass algorithm of the following \n+     * This algorithm uses a corrected two pass algorithm of the following\n      * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n-     * corrected two pass formula (14.1.8)</a>, and also referenced in:\n+     * corrected two pass formula (14.1.8)</a>, and also referenced in\n      * <p>\n      * \"Algorithms for Computing the Sample Variance: Analysis and\n-     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n      * 1983, American Statistician, vol. 37, pp. 242?247.\n      * </p>\n-     * Returns the skewness of a collection of values.  Skewness is a \n-     * measure of the assymetry of a given distribution. \n+     * Returns the skewness of a collection of values.  Skewness is a\n+     * measure of the assymetry of a given distribution.\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n      * @return the skewness of the values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n \n         // Initialize the skewness\n         double skew = Double.NaN;\n                 // Get the mean and the standard deviation\n                 double m = mean.evaluate(values, begin, length);\n \n-                // Calc the std, this is implemented here instead of using the \n-                // standardDeviation method eliminate a duplicate pass to get the mean\n+                // Calc the std, this is implemented here instead\n+                // of using the standardDeviation method eliminate\n+                // a duplicate pass to get the mean\n                 double accum = 0.0;\n                 double accum2 = 0.0;\n                 for (int i = begin; i < begin + length; i++) {\n                         (accum - (Math.pow(accum2, 2) / ((double) length)))\n                             / (double) (length - 1));\n \n-                // Calculate the skew as the sum the cubes of the distance \n+                // Calculate the skew as the sum the cubes of the distance\n                 // from the mean divided by the standard deviation.\n                 double accum3 = 0.0;\n                 for (int i = begin; i < begin + length; i++) {\n                 }\n \n                 // Get N\n-                double n = length;\n+                double n0 = length;\n \n                 // Calculate skewness\n-                skew = (n / ((n - 1) * (n - 2))) * accum3;\n+                skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;\n             }\n         }\n \n--- a/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n package org.apache.commons.math.stat.univariate.moment;\n \n /**\n- * \n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:10 $\n+ *\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class StandardDeviation extends Variance {\n \n+    /** */\n     protected double std = Double.NaN;\n \n+    /** */\n     private double lastVar = 0.0;\n-    \n+\n+    /**\n+     * Constructs a StandardDeviation\n+     */\n     public StandardDeviation() {\n         super();\n     }\n \n-    public StandardDeviation(SecondMoment m2) {\n+    /**\n+     * Constructs a StandardDeviation with an external moment\n+     * @param m2 the external moment\n+     */\n+    public StandardDeviation(final SecondMoment m2) {\n         super(m2);\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         super.increment(d);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         if (lastVar != super.getResult()) {\n     }\n \n     /**\n-     * Returns the Standard Deviation on an array of values.  \n+     * Returns the Standard Deviation on an array of values.\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n-     * @return the result, Double.NaN if no values for an empty array \n-     * or 0.0 for a single value set.  \n+     * @return the result, Double.NaN if no values for an empty array\n+     * or 0.0 for a single value set.\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n+\n         double var = super.evaluate(values, begin, length);\n \n         if (Double.isNaN(var)) {\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n package org.apache.commons.math.stat.univariate.moment;\n \n /**\n- * The ThirdMoment (arithmentic mean) is calculated using the following \n+ * The ThirdMoment (arithmentic mean) is calculated using the following\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:10 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n  */\n-public class ThirdMoment extends SecondMoment{\n+public class ThirdMoment extends SecondMoment {\n \n     /** third moment of values that have been added */\n     protected double m3 = Double.NaN;\n \n     /** temporary internal state made availabel for higher order moments */\n     protected double v2 = 0.0;\n-    \n+\n     /** temporary internal state made availabel for higher order moments */\n     protected double n2 = 0.0;\n-            \n+\n     /** temporary internal state made availabel for higher order moments */\n     protected double prevM2 = 0.0;\n-                  \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (n < 1) {\n             m3 = m2 = m1 = 0.0;\n         }\n-        \n+\n         /* retain a reference to the last m2*/\n         prevM2 = m2;\n-        \n+\n         /* increment m1 and m2 (and _n0, _n1, _v) */\n         super.increment(d);\n-        \n+\n         v2 = v * v;\n         n2 = (double) (n - 2);\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return m3;\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n \n /**\n  *\n- * @version $Revision: 1.7 $ $Date: 2003/07/15 03:36:36 $\n+ * @version $Revision: 1.8 $ $Date: 2003/08/09 04:03:40 $\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic {\n \n+    /** SecondMoment is used in incremental calculation of Variance*/\n     protected SecondMoment moment = null;\n \n+    /**\n+     * Boolean test to determine if this Variance should also increment\n+     * the second moment, this evaluates to false when this Variance is\n+     * constructed with an external SecondMoment as a parameter.\n+     */\n     protected boolean incMoment = true;\n \n+    /**\n+     * This property maintains the latest calculated\n+     * variance for efficiency when getResult() is called\n+     * many times between increments.\n+     */\n     protected double variance = Double.NaN;\n \n+    /**\n+     * Maintains the current count of inrementations that have occured.\n+     * If the external SecondMoment is used, the this is updated from\n+     * that moments counter\n+     */\n     protected int n = 0;\n-    \n+\n+    /**\n+     * Constructs a Variance.\n+     */\n     public Variance() {\n         moment = new SecondMoment();\n     }\n \n-    public Variance(SecondMoment m2) {\n+    /**\n+     * Constructs a Variance based on an externalized second moment.\n+     * @param m2 the SecondMoment (Thrid or Fourth moments work\n+     * here as well.)\n+     */\n+    public Variance(final SecondMoment m2) {\n         incMoment = false;\n         this.moment = m2;\n     }\n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#increment(double)\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         if (n < moment.n) {\n             } else if (moment.n <= 1) {\n                 variance = 0.0;\n             } else {\n-                variance = moment.m2 / (moment.n0 - 1); \n+                variance = moment.m2 / (moment.n0 - 1);\n             }\n             n = moment.n;\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#clear()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n         if (incMoment) {\n         n = 0;\n     }\n \n-    /*UnvariateStatistic Approach */\n-    Mean mean = new Mean();\n+    /** Mean to be used in UnvariateStatistic evaluation approach. */\n+    protected Mean mean = new Mean();\n \n     /**\n      * Returns the variance of the available values. This uses a corrected\n-     * two pass algorithm of the following \n+     * two pass algorithm of the following\n      * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n      * corrected two pass formula (14.1.8)</a>, and also referenced in:\n      * <p>\n      * \"Algorithms for Computing the Sample Variance: Analysis and\n-     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n      * 1983, American Statistician, vol. 37, pp. 242?247.\n      * </p>\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n-     * @return the result, Double.NaN if no values for an empty array \n-     * or 0.0 for a single value set.  \n-     * @see org.apache.commons.math.stat.univariate.\n-     * UnivariateStatistic#evaluate(double[], int, int)\n+     * @return the result, Double.NaN if no values for an empty array\n+     * or 0.0 for a single value set.\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n \n         double var = Double.NaN;\n \n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class Max extends AbstractStorelessUnivariateStatistic {\n \n+    /** */\n     private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         value = Double.isNaN(value) ? d : Math.max(value, d);\n     }\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return value;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         double max = Double.NaN;\n         if (test(values, begin, length)) {\n             max = values[begin];\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Median.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Median.java\n \n \n /**\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class Median extends Percentile {\n \n+    /**\n+     *\n+     */\n     public Median() {\n         super(50.0);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class Min extends AbstractStorelessUnivariateStatistic {\n \n+    /** */\n     private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         value = Double.isNaN(value) ? d : Math.min(value, d);\n     }\n \n     public void clear() {\n         value = Double.NaN;\n     }\n-    \n+\n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return value;\n     /**\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         double min = Double.NaN;\n         if (test(values, begin, length)) {\n             min = values[begin];\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n import org.apache.commons.math.stat.univariate.AbstractUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.4 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.5 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class Percentile extends AbstractUnivariateStatistic {\n \n+    /** */\n     private double percentile = 0.0;\n \n     /**\n         super();\n         percentile = 50.0;\n     }\n-    \n+\n     /**\n      * Constructs a Percentile with the specific percentile value.\n-     * @param percentile\n+     * @param p the percentile\n      */\n-    public Percentile(double percentile) {\n-        this.percentile = percentile;\n+    public Percentile(final double p) {\n+        this.percentile = p;\n     }\n \n     /**\n-     * Evaluates the double[] top the specified percentile. \n-     * This does not alter the interal percentile state of the \n+     * Evaluates the double[] top the specified percentile.\n+     * This does not alter the interal percentile state of the\n      * statistic.\n      * @param values Is a double[] containing the values\n      * @param p Is the percentile to evaluate to.\n-     * @return the result of the evaluation or Double.NaN \n+     * @return the result of the evaluation or Double.NaN\n      * if the array is empty\n      */\n-    public double evaluate(double[] values, double p) {\n-        return evaluate(values, 0,values.length, p);\n+    public double evaluate(final double[] values, final double p) {\n+        return evaluate(values, 0, values.length, p);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int start, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int start,\n+        final int length) {\n+\n         return evaluate(values, start, length, percentile);\n     }\n \n     /**\n-     * Evaluates the double[] top the specified percentile. \n-     * This does not alter the interal percentile state of the \n+     * Evaluates the double[] top the specified percentile.\n+     * This does not alter the interal percentile state of the\n      * statistic.\n      * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n-     * @param p Is the percentile to evaluate to.* \n-     * @return the result of the evaluation or Double.NaN \n+     * @param p Is the percentile to evaluate to.*\n+     * @return the result of the evaluation or Double.NaN\n      * if the array is empty\n      */\n-    public double evaluate(double[] values, int begin, int length, double p) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length,\n+        final double p) {\n \n-        test(values,begin,length);\n-        \n+        test(values, begin, length);\n+\n         if ((p > 100) || (p <= 0)) {\n             throw new IllegalArgumentException(\"invalid percentile value\");\n         }\n         int intPos = (int) fpos;\n         double dif = pos - fpos;\n         double[] sorted = new double[length];\n-        System.arraycopy(values, begin,sorted, 0, length);\n+        System.arraycopy(values, begin, sorted, 0, length);\n         Arrays.sort(sorted);\n-        \n+\n         if (pos < 1) {\n             return sorted[0];\n         }\n         double upper = sorted[intPos];\n         return lower + dif * (upper - lower);\n     }\n-                \n+\n     /**\n      * The default internal state of this percentile can be set.\n      * This will return that value.\n      * This will setthat value.\n      * @param p a value between 0 <= p <= 100\n      */\n-    public void setPercentile(double p) {\n+    public void setPercentile(final double p) {\n         percentile = p;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:13 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class Product extends AbstractStorelessUnivariateStatistic {\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (Double.isNaN(value)) {\n             value = d;\n         } else {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return value;\n      * @return the product values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         double product = Double.NaN;\n         if (test(values, begin, length)) {\n             product = 1.0;\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.8 $ $Date: 2003/07/15 03:38:50 $\n+ * @version $Revision: 1.9 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class Sum extends AbstractStorelessUnivariateStatistic {\n \n     private double value = Double.NaN;\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#increment(double)\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (Double.isNaN(value)) {\n             value = d;\n         } else {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return value;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.\n-     * StorelessUnivariateStatistic#clear()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n         value = Double.NaN;\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n      * @return the sum of the values or Double.NaN if the array is empty\n-     * @see org.apache.commons.math.stat.univariate.\n-     * UnivariateStatistic#evaluate(double[], int, int)\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         double sum = Double.NaN;\n         if (test(values, begin, length)) {\n             sum = 0.0;\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:13 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class SumOfLogs extends AbstractStorelessUnivariateStatistic {\n \n      */\n     private double value = Double.NaN;\n \n+    /** */\n     private boolean init = true;\n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n+    public void increment(final double d) {\n         if (init) {\n             value = Math.log(d);\n             init = false;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return value;\n         value = Double.NaN;\n         init = true;\n     }\n-    \n+\n     /**\n      * Returns the sum of the natural logs for this collection of values\n      * @param values Is a double[] containing the values\n      * @return the sumLog value or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         double sumLog = Double.NaN;\n         if (test(values, begin, length)) {\n             sumLog = 0.0;\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/07/09 20:04:13 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class SumOfSquares extends AbstractStorelessUnivariateStatistic {\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public void increment(double d) {\n-        if (Double.isNaN(value )) {\n+    public void increment(final double d) {\n+        if (Double.isNaN(value)) {\n             value = d * d;\n         } else {\n             value += d * d;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n         return value;\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] values, int begin, int length) {\n+    public double evaluate(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n         double sumSq = Double.NaN;\n         if (test(values, begin, length)) {\n             sumSq = 0.0;\n         }\n         return sumSq;\n     }\n-   \n \n }\n--- a/src/java/org/apache/commons/math/util/BeanTransformer.java\n+++ b/src/java/org/apache/commons/math/util/BeanTransformer.java\n \n /**\n  * Uses PropertyUtils to map a Bean getter to a double value.\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/09 04:03:41 $\n  */\n public class BeanTransformer implements NumberTransformer {\n \n     private String propertyName;\n \n     /**\n-     * Create a BeanTransformer \n+     * Create a BeanTransformer\n      */\n     public BeanTransformer() {\n         super();\n \n     /**\n      * Create a BeanTransformer with a specific PropertyName.\n-     * @param propertyName The property.\n+     * @param property The property.\n      */\n-    public BeanTransformer(String propertyName) {\n-        this.propertyName = propertyName;\n+    public BeanTransformer(final String property) {\n+        this.propertyName = property;\n     }\n \n     /**\n      * @see org.apache.commons.math.util.NumberTransformer#transform(java.lang.Object)\n      */\n-    public double transform(Object o) {\n+    public double transform(final Object o) {\n         double d = Double.NaN;\n         try {\n             d =\n      * Set the propertyString\n      * @param string The string to set the property to.\n      */\n-    public void setPropertyName(String string) {\n+    public void setPropertyName(final String string) {\n         propertyName = string;\n     }\n \n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /**\n  * Some useful additions to the built-in functions in lang.Math<p>\n  *\n- * @version $Revision: 1.2 $ $Date: 2003/07/07 23:19:22 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/09 04:03:41 $\n  */\n-public class MathUtils {\n+public final class MathUtils {\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private MathUtils() {\n+    }\n \n     /**\n      * For a double precision value x, this method returns +1.0 if x >= 0\n      * and -1.0 if x < 0.\n-     *\n-     * @author Albert Davidson Chou\n      * @param x the value, a double\n      * @return +1.0 or -1.0, depending on the the sign of x\n      */\n-    public static double sign( double x ) {\n-        if ( x >= 0.0 ) {\n-            return 1.0 ;\n-        } else {\n-            return -1.0 ;\n+    public static double sign(final double x) {\n+        if (x >= 0.0) {\n+            return 1.0;\n+        } else {\n+            return -1.0;\n         }\n     }\n \n     /**\n      * For a float value x, this method returns +1.0F if x >= 0\n      * and -1.0F if x < 0.\n-     *\n-     * @author Albert Davidson Chou\n      * @param x the value, a float\n      * @return +1.0F or -1.0F, depending on the the sign of x\n      */\n-    public static float sign( float x ) {\n-        if ( x >= 0.0F ) {\n-            return 1.0F ;\n-        } else {\n-            return -1.0F ;\n+    public static float sign(final float x) {\n+        if (x >= 0.0F) {\n+            return 1.0F;\n+        } else {\n+            return -1.0F;\n         }\n     }\n \n     /**\n      * For a byte value x, this method returns (byte)(+1) if x >= 0\n      * and (byte)(-1) if x < 0.\n-     *\n-     * @author Albert Davidson Chou\n      * @param x the value, a byte\n      * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n      */\n-    public static byte sign( byte x ) {\n-        if ( x >= (byte)0 ) {\n-            return (byte)1 ;\n-        } else {\n-            return (byte)(-1) ;\n+    public static byte sign(final byte x) {\n+        if (x >= (byte) 0) {\n+            return (byte) 1;\n+        } else {\n+            return (byte) (-1);\n         }\n     }\n \n      * For a short value x, this method returns (short)(+1) if x >= 0\n      * and (short)(-1) if x < 0.\n      *\n-     * @author Albert Davidson Chou\n      * @param x the value, a short\n      * @return (short)(+1) or (short)(-1), depending on the the sign of x\n      */\n-    public static short sign( short x ) {\n-        if ( x >= (short)0 ) {\n-            return (short)1 ;\n-        } else {\n-            return (short)(-1) ;\n+    public static short sign(final short x) {\n+        if (x >= (short) 0) {\n+            return (short) 1;\n+        } else {\n+            return (short) (-1);\n         }\n     }\n \n      * For an int value x, this method returns +1 if x >= 0\n      * and -1 if x < 0.\n      *\n-     * @author Albert Davidson Chou\n      * @param x the value, an int\n      * @return +1 or -1, depending on the the sign of x\n      */\n-    public static int sign( int x ) {\n-        if ( x >= 0 ) {\n-            return 1 ;\n-        } else {\n-            return -1 ;\n-        }\n-    }\n- \n+    public static int sign(final int x) {\n+        if (x >= 0) {\n+            return 1;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n     /**\n      * For a long value x, this method returns +1L if x >= 0\n      * and -1L if x < 0.\n      *\n-     * @author Albert Davidson Chou\n      * @param x the value, a long\n      * @return +1L or -1L, depending on the the sign of x\n      */\n-    public static long sign( long x ) {\n-        if ( x >= 0L ) {\n-            return 1L ;\n-        } else {\n-            return -1L ;\n-        }\n-    }\n-   /**\n-    * Returns an exact representation of the\n-    * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n-    * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n-    * the number of <code>k</code>-element subsets that can be selected from\n-    * an <code>n</code>-element set.\n-    * <p>\n-    * <Strong>Preconditions</strong>:<ul>\n-    * <li> <code>0 < k <= n </code> (otherwise \n-    * <li> <code>0 < k <= n </code> (otherwise\n-    *      <code>IllegalArgumentException</code> is thrown)</li>\n-    * <li> The result is small enough to fit into a <code>long</code>.  The \n-    *      largest value of <code>n</code> for which all coefficients are \n-    *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value \n-    * <li> The result is small enough to fit into a <code>long</code>.  The\n-    *      largest value of <code>n</code> for which all coefficients are\n-    *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n-    *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n-    *      </code> is thrown.</li>\n-    * </ul>\n-    * \n-    *\n-    * @param n the size of the set\n-    * @param k the size of the subsets to be counted\n-    * @return <code>n choose k</code>\n-    */\n-    public static long binomialCoefficient(int n, int k) {     \n+    public static long sign(final long x) {\n+        if (x >= 0L) {\n+            return 1L;\n+        } else {\n+            return -1L;\n+        }\n+    }\n+    /**\n+     * Returns an exact representation of the\n+     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+     * the number of <code>k</code>-element subsets that can be selected from\n+     * an <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>0 < k <= n </code> (otherwise\n+     * <li> <code>0 < k <= n </code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>. The\n+     *      largest value of <code>n</code> for which all coefficients are\n+     *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n+     * <li> The result is small enough to fit into a <code>long</code>.  The\n+     *      largest value of <code>n</code> for which all coefficients are\n+     *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n+     *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n+     *      </code> is thrown.</li>\n+     * </ul>\n+     *\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return <code>n choose k</code>\n+     */\n+    public static long binomialCoefficient(final int n, final int k) {\n         if (n < k) {\n-            throw new IllegalArgumentException\n-                (\"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n <= 0)  {\n-            throw new IllegalArgumentException\n-                (\"must have n > 0 for binomial coefficient (n,k)\");\n+            throw new IllegalArgumentException(\n+                \"must have n >= k for binomial coefficient (n,k)\");\n+        }\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\n+                \"must have n > 0 for binomial coefficient (n,k)\");\n         }\n         if ((n == k) || (k == 0)) {\n             return 1;\n \n         long result = Math.round(binomialCoefficientDouble(n, k));\n         if (result == Long.MAX_VALUE) {\n-            throw new ArithmeticException\n-                (\"result too large to represent in a long integer\");\n+            throw new ArithmeticException(\n+                \"result too large to represent in a long integer\");\n         }\n         return result;\n     }\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n      */\n-    public static double binomialCoefficientDouble(int n, int k) {\n-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + .5);\n+    public static double binomialCoefficientDouble(final int n, final int k) {\n+        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n     }\n \n     /**\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n      */\n-    public static double binomialCoefficientLog(int n, int k) {\n+    public static double binomialCoefficientLog(final int n, final int k) {\n         if (n < k) {\n-            throw new IllegalArgumentException\n-                (\"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n <= 0)  {\n-            throw new IllegalArgumentException\n-                (\"must have n > 0 for binomial coefficient (n,k)\");\n+            throw new IllegalArgumentException(\n+                \"must have n >= k for binomial coefficient (n,k)\");\n+        }\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\n+                \"must have n > 0 for binomial coefficient (n,k)\");\n         }\n         if ((n == k) || (k == 0)) {\n             return 0;\n      * @param n argument\n      * @return <code>n!</code>\n      */\n-    public static long factorial(int n) {\n+    public static long factorial(final int n) {\n         long result = Math.round(factorialDouble(n));\n         if (result == Long.MAX_VALUE) {\n-            throw new ArithmeticException\n-                (\"result too large to represent in a long integer\");\n+            throw new ArithmeticException(\n+                \"result too large to represent in a long integer\");\n         }\n         return result;\n     }\n      * @param n argument\n      * @return <code>n!</code>\n      */\n-    public static double factorialDouble(int n) {\n-        if (n <= 0)  {\n-            throw new IllegalArgumentException\n-                (\"must have n > 0 for n!\");\n+    public static double factorialDouble(final int n) {\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n-   /**\n-     * Returns the natural <code>log</code> of <code>n</code>\n-     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n-     * Factorial</a>, or <code>n!</code>,\n-     * the product of the numbers <code>1,...,n</code>, as as\n-     * <code>double</code>.\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>n > 0</code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * </ul>\n-     *\n-     * @param n argument\n-     * @return <code>n!</code>\n-     */\n-    public static double factorialLog(int n) {\n-        if (n <= 0)  {\n-            throw new IllegalArgumentException\n-                (\"must have n > 0 for n!\");\n+    /**\n+      * Returns the natural <code>log</code> of <code>n</code>\n+      * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+      * Factorial</a>, or <code>n!</code>,\n+      * the product of the numbers <code>1,...,n</code>, as as\n+      * <code>double</code>.\n+      * <p>\n+      * <Strong>Preconditions</strong>:<ul>\n+      * <li> <code>n > 0</code> (otherwise\n+      *      <code>IllegalArgumentException</code> is thrown)</li>\n+      * </ul>\n+      *\n+      * @param n argument\n+      * @return <code>n!</code>\n+      */\n+    public static double factorialLog(final int n) {\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {", "timestamp": 1060401821, "metainfo": ""}