{"sha": "7f5762d469f5ecc0ea100113a92c9371ef50ddcd", "log": "Moved transform.FastFourierTransformer.sample(UnivariateFunction, double, double, int) to analysis.FunctionUtils.sample(UnivariateFunction, double, double, int) and created simple unit tests.  Related to MATH-677.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.analysis.function.Identity;\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * Utilities for manipulating function objects.\n             }\n         };\n     }\n+\n+    /**\n+     * <p>\n+     * Samples the specified univariate real function on the specified interval.\n+     * </p>\n+     * <p>\n+     * The interval is divided equally into {@code n} sections and sample points\n+     * are taken from {@code min} to {@code max - (max - min) / n}; therefore\n+     * {@code f} is not sampled at the upper bound {@code max}.\n+     * </p>\n+     *\n+     * @param f the function to be sampled\n+     * @param min the (inclusive) lower bound of the interval\n+     * @param max the (exclusive) upper bound of the interval\n+     * @param n the number of sample points\n+     * @return the array of samples\n+     * @throws NonMonotonicSequenceException if the lower bound {@code min} is\n+     * greater than, or equal to the upper bound {@code max}\n+     * @throws NotStrictlyPositiveException if the number of sample points\n+     * {@code n} is negative\n+     */\n+    public static double[] sample(UnivariateFunction f,\n+            double min, double max, int n) throws\n+            NonMonotonicSequenceException,\n+            NotStrictlyPositiveException {\n+\n+        if (n <= 0) {\n+            throw new NotStrictlyPositiveException(\n+                    LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES,\n+                    Integer.valueOf(n));\n+        }\n+        if (min >= max) {\n+            throw new NonMonotonicSequenceException(\n+                    Double.valueOf(max),\n+                    Double.valueOf(min),\n+                    1);\n+        }\n+\n+        double[] s = new double[n];\n+        double h = (max - min) / n;\n+        for (int i = 0; i < n; i++) {\n+            s[i] = f.value(min + i * h);\n+        }\n+        return s;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n+import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n         NotStrictlyPositiveException,\n         MathIllegalArgumentException {\n \n-        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        final double[] data = FunctionUtils.sample(f, min, max, n);\n         return transform(data);\n     }\n \n         NotStrictlyPositiveException,\n         MathIllegalArgumentException {\n \n-        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        final double[] data = FunctionUtils.sample(f, min, max, n);\n         return inverseTransform(data);\n     }\n \n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n \n+import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.DimensionMismatchException;\n             NotStrictlyPositiveException,\n             MathIllegalArgumentException {\n \n-        final double[] data = sample(f, min, max, n);\n+        final double[] data = FunctionUtils.sample(f, min, max, n);\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(n);\n             return scaleArray(fft(data, false), s);\n             NotStrictlyPositiveException,\n             MathIllegalArgumentException {\n \n-        final double[] data = sample(f, min, max, n);\n+        final double[] data = FunctionUtils.sample(f, min, max, n);\n         final double s = 1.0 / (unitary ? FastMath.sqrt(n) : n);\n         return scaleArray(fft(data, true), s);\n     }\n     }\n \n     /**\n-     * <p>\n-     * Sample the given univariate real function on the given interval.\n-     * </p>\n-     * <p>\n-     * The interval is divided equally into {@code n} sections and sample points\n-     * are taken from {@code min} to {@code max - (max - min) / N}. Usually\n-     * {@code f(x)} is periodic such that {@code f(min) = f(max)} (note that\n-     * {@code max} is not sampled), but this condition is not required by the\n-     * present method.\n-     * </p>\n-     *\n-     * @param f the function to be sampled\n-     * @param min the (inclusive) lower bound for the interval\n-     * @param max the (exclusive) upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the samples array\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points\n-     * {@code n} is negative\n-     */\n-    public static double[] sample(UnivariateFunction f,\n-            double min, double max, int n) throws\n-            NonMonotonicSequenceException,\n-            NotStrictlyPositiveException {\n-\n-        if (n <= 0) {\n-            throw new NotStrictlyPositiveException(\n-                    LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES,\n-                    Integer.valueOf(n));\n-        }\n-        verifyInterval(min, max);\n-\n-        double[] s = new double[n];\n-        double h = (max - min) / n;\n-        for (int i = 0; i < n; i++) {\n-            s[i] = f.value(min + i * h);\n-        }\n-        return s;\n-    }\n-\n-    /**\n      * Multiply every component in the given real array by the\n      * given real number. The change is made in place.\n      *\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                     Integer.valueOf(o.length));\n-        }\n-    }\n-\n-    /**\n-     * Verifies that the end-points specify an interval.\n-     *\n-     * @param lower the lower end-point\n-     * @param upper the upper end-point\n-     * @throws NonMonotonicSequenceException if the lower end-point is greater\n-     * than, or equal to the upper end-point\n-     */\n-    public static void verifyInterval(double lower, double upper)\n-        throws NonMonotonicSequenceException {\n-\n-        if (lower >= upper) {\n-            throw new NonMonotonicSequenceException(\n-                    Double.valueOf(upper),\n-                    Double.valueOf(lower),\n-                    1);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n+import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n         NotStrictlyPositiveException,\n         MathIllegalArgumentException {\n \n-        return fht(FastFourierTransformer.sample(f, min, max, n));\n+        return fht(FunctionUtils.sample(f, min, max, n));\n     }\n \n     /**\n         MathIllegalArgumentException {\n \n         final double[] unscaled =\n-            fht(FastFourierTransformer.sample(f, min, max, n));\n+            fht(FunctionUtils.sample(f, min, max, n));\n         return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);\n     }\n \n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n+import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n         NotStrictlyPositiveException,\n         MathIllegalArgumentException {\n \n-        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        final double[] data = FunctionUtils.sample(f, min, max, n);\n         data[0] = 0.0;\n         if (orthogonal) {\n             final double s = FastMath.sqrt(2.0 / n);\n             return transform(f, min, max, n);\n         }\n \n-        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        final double[] data = FunctionUtils.sample(f, min, max, n);\n         data[0] = 0.0;\n         final double s = 2.0 / n;\n \n--- a/src/test/java/org/apache/commons/math/analysis/FunctionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/FunctionUtilsTest.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.function.Add;\n+import org.apache.commons.math.analysis.function.Constant;\n+import org.apache.commons.math.analysis.function.Cos;\n+import org.apache.commons.math.analysis.function.Cosh;\n+import org.apache.commons.math.analysis.function.Divide;\n import org.apache.commons.math.analysis.function.Identity;\n-import org.apache.commons.math.analysis.function.Constant;\n+import org.apache.commons.math.analysis.function.Inverse;\n+import org.apache.commons.math.analysis.function.Log;\n+import org.apache.commons.math.analysis.function.Max;\n+import org.apache.commons.math.analysis.function.Min;\n import org.apache.commons.math.analysis.function.Minus;\n-import org.apache.commons.math.analysis.function.Inverse;\n+import org.apache.commons.math.analysis.function.Multiply;\n+import org.apache.commons.math.analysis.function.Pow;\n import org.apache.commons.math.analysis.function.Power;\n import org.apache.commons.math.analysis.function.Sin;\n import org.apache.commons.math.analysis.function.Sinc;\n-import org.apache.commons.math.analysis.function.Cos;\n-import org.apache.commons.math.analysis.function.Cosh;\n-import org.apache.commons.math.analysis.BivariateRealFunction;\n-import org.apache.commons.math.analysis.function.Add;\n-import org.apache.commons.math.analysis.function.Multiply;\n-import org.apache.commons.math.analysis.function.Divide;\n-import org.apache.commons.math.analysis.function.Min;\n-import org.apache.commons.math.analysis.function.Max;\n-import org.apache.commons.math.analysis.function.Pow;\n-import org.apache.commons.math.analysis.function.Log;\n-import org.apache.commons.math.analysis.MultivariateFunction;\n-\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n             Assert.assertEquals(pow1.value(x), pow2.value(x), 0);\n         }\n     }\n+\n+    @Test(expected = NonMonotonicSequenceException.class)\n+    public void testSampleWrongBounds(){\n+        FunctionUtils.sample(new Sin(), Math.PI, 0.0, 10);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testSampleNegativeNumberOfPoints(){\n+        FunctionUtils.sample(new Sin(), 0.0, Math.PI, -1);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testSampleNullNumberOfPoints(){\n+        FunctionUtils.sample(new Sin(), 0.0, Math.PI, 0);\n+    }\n+\n+    @Test\n+    public void testSample() {\n+        final int n = 11;\n+        final double min = 0.0;\n+        final double max = Math.PI;\n+        final double[] actual = FunctionUtils.sample(new Sin(), min, max, n);\n+        for (int i = 0; i < n; i++) {\n+            final double x = min + (max - min) / n * i;\n+            Assert.assertEquals(\"x = \" + x, FastMath.sin(x), actual[i], 0.0);\n+        }\n+    }\n }", "timestamp": 1325735207, "metainfo": ""}