{"sha": "a04a035c49bf2bcb34c41a5a7a16195084e4b852", "log": "changed the Adams-Bashforth and Adams-Moulton multistep integrators to adaptive stepsize. this was made possible thanks to the Nordsieck representation of integration state  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.FieldDecompositionSolver;\n+import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;\n+import org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator;\n+\n+/** Transformer for Nordsieck vectors.\n+ * <p>This class i used by {@link MultistepIntegrator multistep integrators}\n+ * to convert between classical representation with several previous first\n+ * derivatives and Nordsieck representation with higher order scaled derivatives.</p>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>With the previous definition, the classical representation of multistep methods\n+ * uses first derivatives only, i.e. it handles y<sub>n</sub>, s<sub>1</sub>(n) and\n+ * q<sub>n</sub> where q<sub>n</sub> is defined as:\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity).</p>\n+ *\n+ * <p>Another possible representation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step, i.e it handles y<sub>n</sub>,\n+ * s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector at step end. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ *\n+ * <p>Changing -i into +i in the formula above can be used to compute a similar transform between\n+ * classical representation and Nordsieck vector at step start. The resulting Q matrix is simply\n+ * the absolute value of matrix P.</p>\n+ * \n+ * <p>Using the Nordsieck vector has several advantages:\n+ * <ul>\n+ *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n+ *   Taylor series formulas,</li>\n+ *   <li>it simplifies step changes that occur when discrete events that truncate\n+ *   the step are triggered,</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize (not implemented yet).</li>\n+ * </ul></p>\n+ * \n+ * <p>For {@link AdamsBashforthIntegrator Adams-Bashforth} method, the Nordsieck vector\n+ * at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre></p>\n+ *\n+ * <p>For {@link AdamsMoultonIntegrator Adams-Moulton} method, the predicted Nordsieck vector\n+ * at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n+ *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre>\n+ * From this predicted vector, the corrected vector is computed as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + S<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = R<sub>n+1</sub> + (s<sub>1</sub>(n+1) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>\n+ * </ul>\n+ * where the upper case Y<sub>n+1</sub>, S<sub>1</sub>(n+1) and R<sub>n+1</sub> represent the\n+ * predicted states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>\n+ * represent the corrected states.</p>\n+ *\n+ * <p>We observe that both methods use similar update formulas. In both cases a P<sup>-1</sup>u\n+ * vector and a P<sup>-1</sup> A P matrix are used that do not depend on the state,\n+ * they only depend on k. This class handles these transformations.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NordsieckTransformer {\n+\n+    /** Cache for already computed coefficients. */\n+    private static final Map<Integer, NordsieckTransformer> cache =\n+        new HashMap<Integer, NordsieckTransformer>();\n+\n+    /** Initialization matrix for the higher order derivatives wrt y'', y''' ... */\n+    private final RealMatrix initialization;\n+\n+    /** Update matrix for the higher order derivatives h<sup>2</sup>/2y'', h<sup>3</sup>/6 y''' ... */\n+    private final RealMatrix update;\n+\n+    /** Update coefficients of the higher order derivatives wrt y'. */\n+    private final double[] c1;\n+\n+    /** Simple constructor.\n+     * @param nSteps number of steps of the multistep method\n+     * (including the one being computed)\n+     */\n+    private NordsieckTransformer(final int nSteps) {\n+\n+        // compute exact coefficients\n+        FieldMatrix<BigFraction> bigP = buildP(nSteps);\n+        FieldDecompositionSolver<BigFraction> pSolver =\n+            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver();\n+        BigFraction[] u = new BigFraction[nSteps - 1];\n+        Arrays.fill(u, BigFraction.ONE);\n+        BigFraction[] bigC1 = pSolver.solve(u);\n+\n+        // update coefficients are computed by combining transform from\n+        // Nordsieck to multistep, then shifting rows to represent step advance\n+        // then applying inverse transform\n+        BigFraction[][] shiftedP = bigP.getData();\n+        for (int i = shiftedP.length - 1; i > 0; --i) {\n+            // shift rows\n+            shiftedP[i] = shiftedP[i - 1];\n+        }\n+        shiftedP[0] = new BigFraction[nSteps - 1];\n+        Arrays.fill(shiftedP[0], BigFraction.ZERO);\n+        FieldMatrix<BigFraction> bigMSupdate =\n+            pSolver.solve(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n+\n+        // initialization coefficients, computed from a Q matrix = abs(P)\n+        bigP.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<BigFraction>(BigFraction.ZERO) {\n+            /** {@inheritDoc} */\n+            @Override\n+            public BigFraction visit(int row, int column, BigFraction value) {\n+                return ((column & 0x1) == 0x1) ? value : value.negate();\n+            }\n+        });\n+        FieldMatrix<BigFraction> bigQInverse =\n+            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver().getInverse();\n+\n+        // convert coefficients to double\n+        initialization = MatrixUtils.bigFractionMatrixToRealMatrix(bigQInverse);\n+        update         = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n+        c1             = new double[nSteps - 1];\n+        for (int i = 0; i < nSteps - 1; ++i) {\n+            c1[i] = bigC1[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** Get the Nordsieck transformer for a given number of steps.\n+     * @param nSteps number of steps of the multistep method\n+     * (including the one being computed)\n+     * @return Nordsieck transformer for the specified number of steps\n+     */\n+    public static NordsieckTransformer getInstance(final int nSteps) {\n+        synchronized(cache) {\n+            NordsieckTransformer t = cache.get(nSteps);\n+            if (t == null) {\n+                t = new NordsieckTransformer(nSteps);\n+                cache.put(nSteps, t);\n+            }\n+            return t;\n+        }\n+    }\n+\n+    /** Build the P matrix transforming multistep to Nordsieck.\n+     * <p>\n+     * Multistep representation uses y(k), s<sub>1</sub>(k), s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)).\n+     * Nordsieck representation uses y(k), s<sub>1</sub>(k), s<sub>2</sub>(k) ... s<sub>n</sub>(k).\n+     * The two representations share their two first components y(k) and\n+     * s<sub>1</sub>(k). The P matrix is used to transform the remaining ones:\n+     * <pre>\n+     * [ s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)]<sup>T</sup> = s<sub>1</sub>(k) [1 ... 1]<sup>T</sup> + P [s<sub>2</sub>(k) ... s<sub>n</sub>(k)]<sup>T</sup>\n+     * </pre>\n+     * </p>\n+     * @param nSteps number of steps of the multistep method\n+     * (including the one being computed)\n+     * @return P matrix\n+     */\n+    private FieldMatrix<BigFraction> buildP(final int nSteps) {\n+\n+        final BigFraction[][] pData = new BigFraction[nSteps - 1][nSteps - 1];\n+\n+        for (int i = 0; i < pData.length; ++i) {\n+            // build the P matrix elements from Taylor series formulas\n+            final BigFraction[] pI = pData[i];\n+            final int factor = -(i + 1);\n+            int aj = factor;\n+            for (int j = 0; j < pI.length; ++j) {\n+                pI[j] = new BigFraction(aj * (j + 2));\n+                aj *= factor;\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n+\n+    }\n+\n+    /** Initialize the high order scaled derivatives at step start.\n+     * @param first first scaled derivative at step start\n+     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+     * will be modified\n+     * @return high order derivatives at step start\n+     */\n+    public RealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                     final double[][] multistep) {\n+        for (int i = 0; i < multistep.length; ++i) {\n+            final double[] msI = multistep[i];\n+            for (int j = 0; j < first.length; ++j) {\n+                msI[j] -= first[j];\n+            }\n+        }\n+        return initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n+    }\n+\n+    /** Update the high order scaled derivatives (phase 1).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n+     * @param highOrder high order scaled derivatives\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @return updated high order derivatives\n+     * @see #updateHighOrderDerivativesPhase2(double[], double[], RealMatrix)\n+     */\n+    public RealMatrix updateHighOrderDerivativesPhase1(final RealMatrix highOrder) {\n+        return update.multiply(highOrder);\n+    }\n+\n+    /** Update the high order scaled derivatives (phase 2).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n+     * <p>Phase 1 of the update must already have been performed.</p>\n+     * @param start first order scaled derivatives at step start\n+     * @param end first order scaled derivatives at step end\n+     * @param highOrder high order scaled derivatives, will be modified\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @see #updateHighOrderDerivativesPhase1(RealMatrix)\n+     */\n+    public void updateHighOrderDerivativesPhase2(final double[] start,\n+                                                 final double[] end,\n+                                                 final RealMatrix highOrder) {\n+        highOrder.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            /** {@inheritDoc} */\n+            @Override\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                return value + c1[row] * (start[column] - end[column]);\n+            }\n+        });\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n import java.io.Serializable;\n-import java.lang.reflect.Field;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.fraction.BigFraction;\n-import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n-import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n-import org.apache.commons.math.linear.FieldMatrix;\n-import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n-import org.apache.commons.math.linear.MatrixUtils;\n-import org.apache.commons.math.linear.MatrixVisitorException;\n+\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 67792782787082199L;\n \n-    /** Cache for already computed coefficients. */\n-    private static final Map<Integer, CachedCoefficients> cache =\n-        new HashMap<Integer, CachedCoefficients>();\n-\n-    /** Coefficients of the method. */\n-    private final transient CachedCoefficients coefficients;\n-\n-    /** Integration step. */\n-    private final double step;\n-\n     /**\n      * Build an Adams-Bashforth with the given order and step size.\n      * @param order order of the method (must be greater than 1: due to\n      * an implementation limitation the order 1 method is not supported)\n-     * @param step integration step size\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n      * @exception IllegalArgumentException if order is 1 or less\n      */\n-    public AdamsBashforthIntegrator(final int order, final double step)\n+    public AdamsBashforthIntegrator(final int order,\n+                                    final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance)\n         throws IllegalArgumentException {\n-\n-        super(\"Adams-Bashforth\", order);\n-        if (order <= 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} is supported only for orders 2 or more\",\n-                  getName());\n-        }\n-\n-        // cache the coefficients for each order, to avoid recomputing them\n-        synchronized(cache) {\n-            CachedCoefficients coeff = cache.get(order);\n-            if (coeff == null) {\n-                coeff = new CachedCoefficients(order);\n-                cache.put(order, coeff);\n-            }\n-            coefficients = coeff;\n-        }\n-\n-        this.step = Math.abs(step);\n-\n+        super(\"Adams-Bashforth\", order, order, minStep, maxStep,\n+              scalAbsoluteTolerance, scalRelativeTolerance);\n     }\n \n+    /**\n+     * Build an Adams-Bashforth with the given order and step size.\n+     * @param order order of the method (must be greater than 1: due to\n+     * an implementation limitation the order 1 method is not supported)\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsBashforthIntegrator(final int order,\n+                                    final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(\"Adams-Bashforth\", order, order, minStep, maxStep,\n+              vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n     /** {@inheritDoc} */\n+    @Override\n     public double integrate(final FirstOrderDifferentialEquations equations,\n                             final double t0, final double[] y0,\n                             final double t, final double[] y)\n         if (y != y0) {\n             System.arraycopy(y0, 0, y, 0, n);\n         }\n+        final double[] yDot = new double[n];\n+        final double[] yTmp = new double[y0.length];\n \n         // set up an interpolator sharing the integrator arrays\n         final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n         interpolator.reinitialize(y, forward);\n+        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n+        interpolatorTmp.reinitialize(yTmp, forward);\n \n         // set up integration control objects\n-        stepStart = t0;\n-        stepSize  = forward ? step : -step;\n         for (StepHandler handler : stepHandlers) {\n             handler.reset();\n         }\n         CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n \n-        // compute the first few steps using the configured starter integrator\n-        double stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n-        if (Double.isNaN(previousT[0])) {\n-            return stopTime;\n-        }\n-        stepStart = previousT[0];\n-\n-        // convert to Nordsieck representation\n-        double[]   scaled    = convertToNordsieckLow();\n-        RealMatrix nordsieck = convertToNordsieckHigh(scaled);\n+        // compute the initial Nordsieck vector using the configured starter integrator\n+        start(t0, y, t);\n         interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n         interpolator.storeTime(stepStart);\n-\n+        final int lastRow = nordsieck.getRowDimension() - 1;\n+\n+        // reuse the step that was chosen by the starter integrator\n+        double hNew = stepSize;\n+        interpolator.rescale(hNew);\n+        \n         boolean lastStep = false;\n         while (!lastStep) {\n \n             // shift all data\n             interpolator.shift();\n \n-            // discrete events handling\n-            interpolator.storeTime(stepStart + stepSize);\n-            if (manager.evaluateStep(interpolator)) {\n-                stepSize = manager.getEventTime() - stepStart;\n+            double error = 0;\n+            for (boolean loop = true; loop;) {\n+\n+                stepSize = hNew;\n+\n+                // evaluate error using the last term of the Taylor expansion\n+                error = 0;\n+                for (int i = 0; i < y0.length; ++i) {\n+                    final double yScale = Math.abs(y[i]);\n+                    final double tol = (vecAbsoluteTolerance == null) ?\n+                                       (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                                       (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n+                    final double ratio  = nordsieck.getEntry(lastRow, i) / tol;\n+                    error += ratio * ratio;\n+                }\n+                error = Math.sqrt(error / y0.length);\n+\n+                if (error <= 1.0) {\n+\n+                    // predict a first estimate of the state at step end\n+                    final double stepEnd = stepStart + stepSize;\n+                    interpolator.setInterpolatedTime(stepEnd);\n+                    System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n+\n+                    // evaluate the derivative\n+                    computeDerivatives(stepEnd, yTmp, yDot);\n+\n+                    // update Nordsieck vector\n+                    final double[] predictedScaled = new double[y0.length];\n+                    for (int j = 0; j < y0.length; ++j) {\n+                        predictedScaled[j] = stepSize * yDot[j];\n+                    }\n+                    final RealMatrix nordsieckTmp =\n+                        transformer.updateHighOrderDerivativesPhase1(nordsieck);\n+                    transformer.updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n+\n+                    // discrete events handling\n+                    interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n+                    interpolatorTmp.storeTime(stepStart);\n+                    interpolatorTmp.shift();\n+                    interpolatorTmp.storeTime(stepEnd);\n+                    if (manager.evaluateStep(interpolatorTmp)) {\n+                        final double dt = manager.getEventTime() - stepStart;\n+                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                            // rejecting the step would lead to a too small next step, we accept it\n+                            loop = false;\n+                        } else {\n+                            // reject the step to match exactly the next switch time\n+                            hNew = dt;\n+                            interpolator.rescale(hNew);\n+                        }\n+                    } else {\n+                        // accept the step\n+                        scaled    = predictedScaled;\n+                        nordsieck = nordsieckTmp;\n+                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n+                        loop = false;\n+                    }\n+\n+                } else {\n+                    // reject the step and attempt to reduce error by stepsize control\n+                    final double factor = computeStepGrowShrinkFactor(error);\n+                    hNew = filterStep(stepSize * factor, forward, false);\n+                    interpolator.rescale(hNew);\n+                }\n+\n             }\n \n             // the step has been accepted (may have been truncated)\n             final double nextStep = stepStart + stepSize;\n+            System.arraycopy(yTmp, 0, y, 0, n);\n             interpolator.storeTime(nextStep);\n-            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, n);\n             manager.stepAccepted(nextStep, y);\n             lastStep = manager.stop();\n \n-            // update the Nordsieck vector\n-            final double[] f0 = previousF[0];\n-            previousT[0] = nextStep;\n-            computeDerivatives(nextStep, y, f0);\n-            nordsieck = coefficients.msUpdate.multiply(nordsieck);\n-            final double[] end = new double[y0.length];\n-            for (int j = 0; j < y0.length; ++j) {\n-                end[j] = stepSize * f0[j];\n-            }\n-            nordsieck.walkInOptimizedOrder(new NordsieckUpdater(scaled, end, coefficients.c1));\n-            scaled = end;\n-            interpolator.reinitialize(nextStep, stepSize, scaled, nordsieck);\n-\n             // provide the step data to the step handler\n             for (StepHandler handler : stepHandlers) {\n+                interpolator.setInterpolatedTime(nextStep);\n                 handler.handleStep(interpolator, lastStep);\n             }\n             stepStart = nextStep;\n \n                 // some events handler has triggered changes that\n                 // invalidate the derivatives, we need to restart from scratch\n-                stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n-                if (Double.isNaN(previousT[0])) {\n-                    return stopTime;\n-                }\n-                stepStart = previousT[0];\n-\n-                // convert to Nordsieck representation\n-                scaled    = convertToNordsieckLow();\n-                nordsieck = convertToNordsieckHigh(scaled);\n+                start(stepStart, y, t);\n                 interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n \n             }\n \n+            if (! lastStep) {\n+                // in some rare cases we may get here with stepSize = 0, for example\n+                // when an event occurs at integration start, reducing the first step\n+                // to zero; we have to reset the step to some safe non zero value\n+                stepSize = filterStep(stepSize, forward, true);\n+\n+                // stepsize control for next step\n+                final double  factor     = computeStepGrowShrinkFactor(error);\n+                final double  scaledH    = stepSize * factor;\n+                final double  nextT      = stepStart + scaledH;\n+                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+                hNew = filterStep(scaledH, forward, nextIsLast);\n+                interpolator.rescale(hNew);\n+            }\n+\n         }\n \n-        stopTime  = stepStart;\n+        final double stopTime  = stepStart;\n         stepStart = Double.NaN;\n         stepSize  = Double.NaN;\n         return stopTime;\n \n     }\n \n-    /** Convert the multistep representation after a restart to Nordsieck representation.\n-     * @return first scaled derivative\n-     */\n-    private double[] convertToNordsieckLow() {\n-\n-        final double[] f0 = previousF[0];\n-        final double[] scaled = new double[f0.length];\n-        for (int j = 0; j < f0.length; ++j) {\n-            scaled[j] = stepSize * f0[j];\n-        }\n-        return scaled;\n-\n-    }\n-\n-    /** Convert the multistep representation after a restart to Nordsieck representation.\n-     * @param scaled first scaled derivative\n-     * @return Nordsieck matrix of the higher scaled derivatives\n-     */\n-    private RealMatrix convertToNordsieckHigh(final double[] scaled) {\n-\n-        final double[] f0 = previousF[0];\n-        final double[][] multistep = new double[coefficients.msToN.getColumnDimension()][f0.length];\n-        for (int i = 0; i < multistep.length; ++i) {\n-            final double[] msI = multistep[i];\n-            final double[] fI  = previousF[i + 1];\n-            for (int j = 0; j < f0.length; ++j) {\n-                msI[j] = stepSize * fI[j] - scaled[j];\n-            }\n-        }\n-\n-        return coefficients.msToN.multiply(new Array2DRowRealMatrix(multistep, false));\n-\n-    }\n-\n-    /** Updater for Nordsieck vector. */\n-    private static class NordsieckUpdater extends DefaultRealMatrixChangingVisitor {\n-\n-        /** Scaled first derivative at step start. */\n-        private final double[] start;\n-\n-        /** Scaled first derivative at step end. */\n-        private final double[] end;\n-\n-        /** Update coefficients. */\n-        private final double[] c1;\n-\n-        /** Simple constructor.\n-         * @param start scaled first derivative at step start\n-         * @param end scaled first derivative at step end\n-         * @param c1 update coefficients\n-         */\n-        public NordsieckUpdater(final double[] start, final double[] end,\n-                                final double[] c1) {\n-            this.start = start;\n-            this.end   = end;\n-            this.c1    = c1;\n-        }\n-\n-       /** {@inheritDoc} */\n-        @Override\n-        public double visit(int row, int column, double value)\n-            throws MatrixVisitorException {\n-            return value + c1[row] * (start[column] - end[column]);\n-        }\n-\n-    }\n-\n-    /** Cache for already computed coefficients. */\n-    private static class CachedCoefficients {\n-\n-        /** Transformer between multistep and Nordsieck representations. */\n-        private final RealMatrix msToN;\n-\n-        /** Update coefficients of the higher order derivatives wrt y'', y''' ... */\n-        private final RealMatrix msUpdate;\n-\n-        /** Update coefficients of the higher order derivatives wrt y'. */\n-        private final double[] c1;\n-\n-        /** Simple constructor.\n-         * @param order order of the method (must be greater than 1: due to\n-         * an implementation limitation the order 1 method is not supported)\n-         */\n-        public CachedCoefficients(int order) {\n-\n-            // compute exact coefficients\n-            FieldMatrix<BigFraction> bigNtoMS = buildP(order);\n-            FieldMatrix<BigFraction> bigMStoN =\n-                new FieldLUDecompositionImpl<BigFraction>(bigNtoMS).getSolver().getInverse();\n-            BigFraction[] u = new BigFraction[order - 1];\n-            Arrays.fill(u, BigFraction.ONE);\n-            BigFraction[] bigC1 = bigMStoN.operate(u);\n-\n-            // update coefficients are computed by combining transform from\n-            // Nordsieck to multistep, then shifting rows to represent step advance\n-            // then applying inverse transform\n-            BigFraction[][] shiftedP = bigNtoMS.getData();\n-            for (int i = shiftedP.length - 1; i > 0; --i) {\n-                // shift rows\n-                shiftedP[i] = shiftedP[i - 1];\n-            }\n-            shiftedP[0] = new BigFraction[order - 1];\n-            Arrays.fill(shiftedP[0], BigFraction.ZERO);\n-            FieldMatrix<BigFraction> bigMSupdate =\n-                bigMStoN.multiply(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n-\n-            // convert coefficients to double\n-            msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n-            msUpdate = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n-            c1       = new double[order - 1];\n-            for (int i = 0; i < order - 1; ++i) {\n-                c1[i] = bigC1[i].doubleValue();\n-            }\n-\n-        }\n-\n-        /** Build the P matrix transforming multistep to Nordsieck.\n-         * <p>\n-         * <p>\n-         * Multistep representation uses y(k), s<sub>1</sub>(k), s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)).\n-         * Nordsieck representation uses y(k), s<sub>1</sub>(k), s<sub>2</sub>(k) ... s<sub>n</sub>(k).\n-         * The two representations share their two first components y(k) and\n-         * s<sub>1</sub>(k). The P matrix is used to transform the remaining ones:\n-         * <pre>\n-         * [ s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)]<sup>T</sup> = s<sub>1</sub>(k) [1 ... 1]<sup>T</sup> + P [s<sub>2</sub>(k) ... s<sub>n</sub>(k)]<sup>T</sup>\n-         * </pre>\n-         * </p>\n-         * @param order order of the method (must be strictly positive)\n-         * @return P matrix\n-         */\n-        private static FieldMatrix<BigFraction> buildP(final int order) {\n-\n-            final BigFraction[][] pData = new BigFraction[order - 1][order - 1];\n-\n-            for (int i = 0; i < pData.length; ++i) {\n-                // build the P matrix elements from Taylor series formulas\n-                final BigFraction[] pI = pData[i];\n-                final int factor = -(i + 1);\n-                int aj = factor;\n-                for (int j = 0; j < pI.length; ++j) {\n-                    pI[j] = new BigFraction(aj * (j + 2));\n-                    aj *= factor;\n-                }\n-            }\n-\n-            return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n-\n-        }\n-\n-    }\n-\n-    /** Serialize the instance.\n-     * @param oos stream where object should be written\n-     * @throws IOException if object cannot be written to stream\n-     */\n-    private void writeObject(ObjectOutputStream oos)\n-        throws IOException {\n-        oos.defaultWriteObject();\n-        oos.writeInt(coefficients.msToN.getRowDimension() + 1);\n-    }\n-\n-    /** Deserialize the instance.\n-     * @param ois stream from which the object should be read\n-     * @throws ClassNotFoundException if a class in the stream cannot be found\n-     * @throws IOException if object cannot be read from the stream\n-     */\n-    private void readObject(ObjectInputStream ois)\n-      throws ClassNotFoundException, IOException {\n-        try {\n-\n-            ois.defaultReadObject();\n-            final int order = ois.readInt();\n-\n-            final Class<AdamsBashforthIntegrator> cl = AdamsBashforthIntegrator.class;\n-            final Field f = cl.getDeclaredField(\"coefficients\");\n-            f.setAccessible(true);\n-\n-            // cache the coefficients for each order, to avoid recomputing them\n-            synchronized(cache) {\n-                CachedCoefficients coeff = cache.get(order);\n-                if (coeff == null) {\n-                    coeff = new CachedCoefficients(order);\n-                    cache.put(order, coeff);\n-                }\n-                f.set(this, coeff);\n-            }\n-\n-        } catch (NoSuchFieldException nsfe) {\n-            IOException ioe = new IOException();\n-            ioe.initCause(nsfe);\n-            throw ioe;\n-        } catch (IllegalAccessException iae) {\n-            IOException ioe = new IOException();\n-            ioe.initCause(iae);\n-            throw ioe;\n-        }\n-\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n import java.io.Serializable;\n-import java.lang.reflect.Field;\n import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.fraction.BigFraction;\n-import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n-import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n-import org.apache.commons.math.linear.FieldMatrix;\n-import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n-import org.apache.commons.math.linear.MatrixUtils;\n+\n import org.apache.commons.math.linear.MatrixVisitorException;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n      */\n     private static final long serialVersionUID = 3624292432281962886L;\n \n-    /** Cache for already computed coefficients. */\n-    private static final Map<Integer, CachedCoefficients> cache =\n-        new HashMap<Integer, CachedCoefficients>();\n-\n-    /** Coefficients of the method. */\n-    private final transient CachedCoefficients coefficients;\n-\n-    /** Integration step. */\n-    private final double step;\n-\n     /**\n      * Build an Adams-Moulton integrator with the given order and step size.\n      * @param order order of the method (must be greater than 1: due to\n      * an implementation limitation the order 1 method is not supported)\n-     * @param step integration step size\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n      * @exception IllegalArgumentException if order is 1 or less\n      */\n-    public AdamsMoultonIntegrator(final int order, final double step)\n+    public AdamsMoultonIntegrator(final int order,\n+                                  final double minStep, final double maxStep,\n+                                  final double scalAbsoluteTolerance,\n+                                  final double scalRelativeTolerance)\n         throws IllegalArgumentException {\n-\n-        super(\"Adams-Moulton\", order);\n-        if (order <= 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} is supported only for orders 2 or more\",\n-                  getName());\n-        }\n-\n-        // cache the coefficients for each order, to avoid recomputing them\n-        synchronized(cache) {\n-            CachedCoefficients coeff = cache.get(order);\n-            if (coeff == null) {\n-                coeff = new CachedCoefficients(order);\n-                cache.put(order, coeff);\n-            }\n-            coefficients = coeff;\n-        }\n-\n-        this.step = Math.abs(step);\n-\n+        super(\"Adams-Moulton\", order, order, minStep, maxStep,\n+              scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Build an Adams-Moulton integrator with the given order and step size.\n+     * @param order order of the method (must be greater than 1: due to\n+     * an implementation limitation the order 1 method is not supported)\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsMoultonIntegrator(final int order,\n+                                  final double minStep, final double maxStep,\n+                                  final double[] vecAbsoluteTolerance,\n+                                  final double[] vecRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(\"Adams-Moulton\", order, order, minStep, maxStep,\n+              vecAbsoluteTolerance, vecRelativeTolerance);\n     }\n       \n     \n     /** {@inheritDoc} */\n+    @Override\n     public double integrate(final FirstOrderDifferentialEquations equations,\n                             final double t0, final double[] y0,\n                             final double t, final double[] y)\n         if (y != y0) {\n             System.arraycopy(y0, 0, y, 0, n);\n         }\n+        final double[] yDot = new double[y0.length];\n         final double[] yTmp = new double[y0.length];\n \n         // set up two interpolators sharing the integrator arrays\n         interpolatorTmp.reinitialize(yTmp, forward);\n \n         // set up integration control objects\n-        stepStart = t0;\n-        stepSize  = forward ? step : -step;\n         for (StepHandler handler : stepHandlers) {\n             handler.reset();\n         }\n         CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n \n-        // compute the first few steps using the configured starter integrator\n-        double stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n-        if (Double.isNaN(previousT[0])) {\n-            return stopTime;\n-        }\n-        stepStart = previousT[0];\n-        double hNew = 0;\n-\n-        // convert to Nordsieck representation\n-        double[]   scaled    = convertToNordsieckLow();\n-        RealMatrix nordsieck = convertToNordsieckHigh(scaled);\n+\n+        // compute the initial Nordsieck vector using the configured starter integrator\n+        start(t0, y, t);\n         interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n         interpolator.storeTime(stepStart);\n \n+        double hNew = stepSize;\n+        interpolator.rescale(hNew);\n+        \n         boolean lastStep = false;\n         while (!lastStep) {\n \n             // shift all data\n             interpolator.shift();\n \n-            hNew  = forward ? step : -step;\n+            double error = 0;\n             for (boolean loop = true; loop;) {\n \n                 stepSize = hNew;\n                 System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n \n                 // evaluate a first estimate of the derivative (first E in the PECE sequence)\n-                final double[] f0 = previousF[0];\n-                previousT[0] = stepEnd;\n-                computeDerivatives(stepEnd, yTmp, f0);\n+                computeDerivatives(stepEnd, yTmp, yDot);\n \n                 // update Nordsieck vector\n-                final RealMatrix nordsieckTmp = coefficients.msUpdate.multiply(nordsieck);\n                 final double[] predictedScaled = new double[y0.length];\n                 for (int j = 0; j < y0.length; ++j) {\n-                    predictedScaled[j] = stepSize * f0[j];\n+                    predictedScaled[j] = stepSize * yDot[j];\n                 }\n-                nordsieckTmp.walkInOptimizedOrder(new NordsieckUpdater(scaled, predictedScaled, coefficients.c1));\n+                final RealMatrix nordsieckTmp =\n+                    transformer.updateHighOrderDerivativesPhase1(nordsieck);\n+                transformer.updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n \n                 // apply correction (C in the PECE sequence)\n-                nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n-\n-                // evaluate a final estimate of the derivative (second E in the PECE sequence)\n-                computeDerivatives(stepEnd, yTmp, f0);\n-\n-                // update Nordsieck vector\n-                final double[] correctedScaled = new double[y0.length];\n-                for (int j = 0; j < y0.length; ++j) {\n-                    correctedScaled[j] = stepSize * f0[j];\n-                }\n-                nordsieckTmp.walkInOptimizedOrder(new NordsieckUpdater(predictedScaled, correctedScaled, coefficients.c1));\n-\n-                // discrete events handling\n-                interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n-                interpolatorTmp.storeTime(stepStart);\n-                interpolatorTmp.shift();\n-                interpolatorTmp.storeTime(stepEnd);\n-                if (manager.evaluateStep(interpolatorTmp)) {\n-                    final double dt = manager.getEventTime() - stepStart;\n-                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                        // rejecting the step would lead to a too small next step, we accept it\n+                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n+\n+                if (error <= 1.0) {\n+\n+                    // evaluate a final estimate of the derivative (second E in the PECE sequence)\n+                    computeDerivatives(stepEnd, yTmp, yDot);\n+\n+                    // update Nordsieck vector\n+                    final double[] correctedScaled = new double[y0.length];\n+                    for (int j = 0; j < y0.length; ++j) {\n+                        correctedScaled[j] = stepSize * yDot[j];\n+                    }\n+                    transformer.updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n+\n+                    // discrete events handling\n+                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n+                    interpolatorTmp.storeTime(stepStart);\n+                    interpolatorTmp.shift();\n+                    interpolatorTmp.storeTime(stepEnd);\n+                    if (manager.evaluateStep(interpolatorTmp)) {\n+                        final double dt = manager.getEventTime() - stepStart;\n+                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                            // rejecting the step would lead to a too small next step, we accept it\n+                            loop = false;\n+                        } else {\n+                            // reject the step to match exactly the next switch time\n+                            hNew = dt;\n+                            interpolator.rescale(hNew);\n+                        }\n+                    } else {\n+                        // accept the step\n+                        scaled    = correctedScaled;\n+                        nordsieck = nordsieckTmp;\n+                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n                         loop = false;\n-                    } else {\n-                        // reject the step to match exactly the next switch time\n-                        hNew = dt;\n                     }\n+\n                 } else {\n-                    // accept the step\n-                    scaled    = correctedScaled;\n-                    nordsieck = nordsieckTmp;\n-                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n-                    loop = false;\n+                    // reject the step and attempt to reduce error by stepsize control\n+                    final double factor = computeStepGrowShrinkFactor(error);\n+                    hNew = filterStep(stepSize * factor, forward, false);\n+                    interpolator.rescale(hNew);\n                 }\n \n             }\n             lastStep = manager.stop();\n \n             // provide the step data to the step handler\n-            interpolator.setInterpolatedTime(nextStep);\n             for (StepHandler handler : stepHandlers) {\n+                interpolator.setInterpolatedTime(nextStep);\n                 handler.handleStep(interpolator, lastStep);\n             }\n             stepStart = nextStep;\n \n                 // some events handler has triggered changes that\n                 // invalidate the derivatives, we need to restart from scratch\n-                stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n-                if (Double.isNaN(previousT[0])) {\n-                    return stopTime;\n-                }\n-                stepStart = previousT[0];\n-\n-                // convert to Nordsieck representation\n-                scaled    = convertToNordsieckLow();\n-                nordsieck = convertToNordsieckHigh(scaled);\n+                start(stepStart, y, t);\n                 interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n-                interpolator.storeTime(stepStart);\n-\n-            }\n-\n-        }\n-\n-        stopTime  = stepStart;\n+\n+            }\n+\n+            if (! lastStep) {\n+                // in some rare cases we may get here with stepSize = 0, for example\n+                // when an event occurs at integration start, reducing the first step\n+                // to zero; we have to reset the step to some safe non zero value\n+                stepSize = filterStep(stepSize, forward, true);\n+\n+                // stepsize control for next step\n+                final double  factor     = computeStepGrowShrinkFactor(error);\n+                final double  scaledH    = stepSize * factor;\n+                final double  nextT      = stepStart + scaledH;\n+                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+                hNew = filterStep(scaledH, forward, nextIsLast);\n+                interpolator.rescale(hNew);\n+            }\n+\n+        }\n+\n+        final double stopTime  = stepStart;\n         stepStart = Double.NaN;\n         stepSize  = Double.NaN;\n         return stopTime;\n-\n-    }\n-\n-    /** Convert the multistep representation after a restart to Nordsieck representation.\n-     * @return first scaled derivative\n-     */\n-    private double[] convertToNordsieckLow() {\n-\n-        final double[] f0 = previousF[0];\n-        final double[] scaled = new double[f0.length];\n-        for (int j = 0; j < f0.length; ++j) {\n-            scaled[j] = stepSize * f0[j];\n-        }\n-        return scaled;\n-\n-    }\n-\n-    /** Convert the multistep representation after a restart to Nordsieck representation.\n-     * @param scaled first scaled derivative\n-     * @return Nordsieck matrix of the higher scaled derivatives\n-     */\n-    private RealMatrix convertToNordsieckHigh(final double[] scaled) {\n-\n-        final double[] f0 = previousF[0];\n-        final double[][] multistep = new double[coefficients.msToN.getColumnDimension()][f0.length];\n-        for (int i = 0; i < multistep.length; ++i) {\n-            final double[] msI = multistep[i];\n-            final double[] fI  = previousF[i + 1];\n-            for (int j = 0; j < f0.length; ++j) {\n-                msI[j] = stepSize * fI[j] - scaled[j];\n-            }\n-        }\n-\n-        return coefficients.msToN.multiply(new Array2DRowRealMatrix(multistep, false));\n \n     }\n \n      * </pre>\n      * </p>\n      */\n-    private static class Corrector implements RealMatrixPreservingVisitor {\n+    private class Corrector implements RealMatrixPreservingVisitor {\n \n         /** Previous state. */\n         private final double[] previous;\n         /** Current scaled first derivative. */\n         private final double[] scaled;\n \n-        /** Placeholder where to put the recomputed current state. */\n-        private final double[] corrected;\n+        /** Current state before correction. */\n+        private final double[] before;\n+\n+        /** Current state after correction. */\n+        private final double[] after;\n \n         /** Simple constructor.\n          * @param previous previous state\n          * @param scaled current scaled first derivative\n-         * @param corrected placeholder where to put the corrected current state\n+         * @param state state to correct (will be overwritten after visit)\n          */\n-        public Corrector(final double[] previous, final double[] scaled, final double[] corrected) {\n+        public Corrector(final double[] previous, final double[] scaled, final double[] state) {\n             this.previous = previous;\n-            this.scaled    = scaled;\n-            this.corrected  = corrected;\n+            this.scaled   = scaled;\n+            this.after    = state;\n+            this.before   = state.clone();\n         }\n \n         /** {@inheritDoc} */\n         public void start(int rows, int columns,\n                           int startRow, int endRow, int startColumn, int endColumn) {\n-            Arrays.fill(corrected, 0.0);\n+            Arrays.fill(after, 0.0);\n         }\n \n         /** {@inheritDoc} */\n         public void visit(int row, int column, double value)\n             throws MatrixVisitorException {\n             if ((row & 0x1) == 0) {\n-                corrected[column] -= value;\n+                after[column] -= value;\n             } else {\n-                corrected[column] += value;\n-            }\n-        }\n-\n-        /** {@inheritDoc} */\n+                after[column] += value;\n+            }\n+        }\n+\n+        /**\n+         * End visiting te Nordsieck vector.\n+         * <p>The correction is used to control stepsize. So its amplitude is\n+         * considered to be an error, which must be normalized according to\n+         * error control settings. If the normalized value is greater than 1,\n+         * the correction was too large and the step must be rejected.</p>\n+         * @return the normalized correction, if greater than 1, the step\n+         * must be rejected\n+         */\n         public double end() {\n-            for (int i = 0; i < corrected.length; ++i) {\n-                corrected[i] += previous[i] + scaled[i];\n-            }\n-            return 0;\n+\n+            double error = 0;\n+            for (int i = 0; i < after.length; ++i) {\n+                after[i] += previous[i] + scaled[i];\n+                final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n+                final double tol = (vecAbsoluteTolerance == null) ?\n+                                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                                   (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n+                final double ratio  = (after[i] - before[i]) / tol;\n+                error += ratio * ratio;\n+            }\n+\n+            return Math.sqrt(error / after.length);\n+\n         }\n     }\n \n-    /** Updater for Nordsieck vector. */\n-    private static class NordsieckUpdater extends DefaultRealMatrixChangingVisitor {\n-\n-        /** Scaled first derivative at step start. */\n-        private final double[] start;\n-\n-        /** Scaled first derivative at step end. */\n-        private final double[] end;\n-\n-        /** Update coefficients. */\n-        private final double[] c1;\n-\n-        /** Simple constructor.\n-         * @param start scaled first derivative at step start\n-         * @param end scaled first derivative at step end\n-         * @param c1 update coefficients\n-         */\n-        public NordsieckUpdater(final double[] start, final double[] end,\n-                                final double[] c1) {\n-            this.start = start;\n-            this.end   = end;\n-            this.c1    = c1;\n-        }\n-\n-       /** {@inheritDoc} */\n-        @Override\n-        public double visit(int row, int column, double value)\n-            throws MatrixVisitorException {\n-            return value + c1[row] * (start[column] - end[column]);\n-        }\n-\n-    }\n-\n-    /** Cache for already computed coefficients. \n-     * @param <impements>*/\n-    private static class CachedCoefficients implements Serializable {\n-\n-        /**\n-         * Serialization UID\n-         */\n-        private static final long serialVersionUID = -8464316300182136812L;\n-\n-        /** Transformer between multistep and Nordsieck representations. */\n-        private final RealMatrix msToN;\n-\n-        /** Update coefficients of the higher order derivatives wrt y'', y''' ... */\n-        private final RealMatrix msUpdate;\n-\n-        /** Update coefficients of the higher order derivatives wrt y'. */\n-        private final double[] c1;\n-\n-        /** Simple constructor.\n-         * @param order order of the method (must be greater than 1: due to\n-         * an implementation limitation the order 1 method is not supported)\n-         */\n-        public CachedCoefficients(int order) {\n-\n-            // compute exact coefficients\n-            FieldMatrix<BigFraction> bigNtoMS = buildP(order);\n-            FieldMatrix<BigFraction> bigMStoN =\n-                new FieldLUDecompositionImpl<BigFraction>(bigNtoMS).getSolver().getInverse();\n-            BigFraction[] u = new BigFraction[order - 1];\n-            Arrays.fill(u, BigFraction.ONE);\n-            BigFraction[] bigC1 = bigMStoN.operate(u);\n-\n-            // update coefficients are computed by combining transform from\n-            // Nordsieck to multistep, then shifting rows to represent step advance\n-            // then applying inverse transform\n-            BigFraction[][] shiftedP = bigNtoMS.getData();\n-            for (int i = shiftedP.length - 1; i > 0; --i) {\n-                // shift rows\n-                shiftedP[i] = shiftedP[i - 1];\n-            }\n-            shiftedP[0] = new BigFraction[order - 1];\n-            Arrays.fill(shiftedP[0], BigFraction.ZERO);\n-            FieldMatrix<BigFraction> bigMSupdate =\n-                bigMStoN.multiply(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n-\n-            // convert coefficients to double\n-            msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n-            msUpdate = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n-            c1       = new double[order - 1];\n-            for (int i = 0; i < order - 1; ++i) {\n-                c1[i] = bigC1[i].doubleValue();\n-            }\n-\n-        }\n-\n-        /** Build the P matrix transforming multistep to Nordsieck.\n-         * <p>\n-         * <p>\n-         * Multistep representation uses y(k), s<sub>1</sub>(k), s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)).\n-         * Nordsieck representation uses y(k), s<sub>1</sub>(k), s<sub>2</sub>(k) ... s<sub>n</sub>(k).\n-         * The two representations share their two first components y(k) and\n-         * s<sub>1</sub>(k). The P matrix is used to transform the remaining ones:\n-         * <pre>\n-         * [ s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)]<sup>T</sup> = s<sub>1</sub>(k) [1 ... 1]<sup>T</sup> + P [s<sub>2</sub>(k) ... s<sub>n</sub>(k)]<sup>T</sup>\n-         * </pre>\n-         * </p>\n-         * @param order order of the method (must be strictly positive)\n-         * @return P matrix\n-         */\n-        private static FieldMatrix<BigFraction> buildP(final int order) {\n-\n-            final BigFraction[][] pData = new BigFraction[order - 1][order - 1];\n-\n-            for (int i = 0; i < pData.length; ++i) {\n-                // build the P matrix elements from Taylor series formulas\n-                final BigFraction[] pI = pData[i];\n-                final int factor = -(i + 1);\n-                int aj = factor;\n-                for (int j = 0; j < pI.length; ++j) {\n-                    pI[j] = new BigFraction(aj * (j + 2));\n-                    aj *= factor;\n-                }\n-            }\n-\n-            return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n-\n-        }\n-\n-    }\n-\n-    /** Serialize the instance.\n-     * @param oos stream where object should be written\n-     * @throws IOException if object cannot be written to stream\n-     */\n-    private void writeObject(ObjectOutputStream oos)\n-        throws IOException {\n-        oos.defaultWriteObject();\n-        oos.writeInt(coefficients.msToN.getRowDimension() + 1);\n-    }\n-\n-    /** Deserialize the instance.\n-     * @param ois stream from which the object should be read\n-     * @throws ClassNotFoundException if a class in the stream cannot be found\n-     * @throws IOException if object cannot be read from the stream\n-     */\n-    private void readObject(ObjectInputStream ois)\n-      throws ClassNotFoundException, IOException {\n-        try {\n-\n-            ois.defaultReadObject();\n-            final int order = ois.readInt();\n-\n-            final Class<AdamsMoultonIntegrator> cl = AdamsMoultonIntegrator.class;\n-            final Field f = cl.getDeclaredField(\"coefficients\");\n-            f.setAccessible(true);\n-\n-            // cache the coefficients for each order, to avoid recomputing them\n-            synchronized(cache) {\n-                CachedCoefficients coeff = cache.get(order);\n-                if (coeff == null) {\n-                    coeff = new CachedCoefficients(order);\n-                    cache.put(order, coeff);\n-                }\n-                f.set(this, coeff);\n-            }\n-\n-        } catch (NoSuchFieldException nsfe) {\n-            IOException ioe = new IOException();\n-            ioe.initCause(nsfe);\n-            throw ioe;\n-        } catch (IllegalAccessException iae) {\n-            IOException ioe = new IOException();\n-            ioe.initCause(iae);\n-            throw ioe;\n-        }\n-\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n import java.io.ObjectOutput;\n import java.util.Arrays;\n \n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n \n /**\n         return new NordsieckStepInterpolator(this);\n     }\n \n-    /** Reinitialize the instance\n+    /** Reinitialize the instance.\n      * <p>Beware that all arrays <em>must</em> be references to integrator\n      * arrays, in order to ensure proper update without copy.</p>\n      * @param y reference to the integrator array holding the state at\n         super.reinitialize(y, forward);\n     }\n \n-    /** Reinitialize the instance\n+    /** Reinitialize the instance.\n      * <p>Beware that all arrays <em>must</em> be references to integrator\n      * arrays, in order to ensure proper update without copy.</p>\n      * @param referenceTime time at which all arrays are defined\n \n     }\n \n+    /** Rescale the instance.\n+     * <p>Since the scaled and Nordiseck arrays are shared with the caller,\n+     * this method has the side effect of rescaling this arrays in the caller too.</p>\n+     * @param scalingH new step size to use in the scaled and nordsieck arrays\n+     */\n+    public void rescale(final double scalingH) {\n+        final double ratio = scalingH / this.scalingH;\n+        for (int i = 0; i < scaled.length; ++i) {\n+            scaled[i] *= ratio;\n+        }\n+        nordsieck.walkInOptimizedOrder(new Rescaler(ratio));\n+        this.scalingH = scalingH;\n+    }\n+\n     /** {@inheritDoc} */\n     @Override\n     protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n          * @param theta normalized interpolation abscissa within the step\n          */\n         public StateEstimator(final double scale, final double theta) {\n-            this.scale  = scale;\n+            this.scale = scale;\n             lowPower   = theta;\n             highPowers = new double[nordsieck.getRowDimension()];\n             double thetaN = theta;\n             return 0;\n         }\n \n+    }\n+\n+    /** Visitor rescaling the Nordsieck vector. */\n+    private class Rescaler extends DefaultRealMatrixChangingVisitor {\n+\n+        /** Powers of the rescaling ratio. */\n+        private final double[] powers;\n+\n+        /** Simple constructor.\n+         * @param ratio rescaling ratio\n+         */\n+        public Rescaler(final double ratio) {\n+            powers = new double[nordsieck.getRowDimension()];\n+            double f = ratio;\n+            for (int i = 0; i < powers.length; ++i) {\n+                f *= ratio;\n+                powers[i] = f;\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public double visit(final int row, final int column, final double value) {\n+            return value * powers[row];\n+        }\n+        \n     }\n \n     /** {@inheritDoc} */\n--- a/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.EventHandler;\n import org.junit.Test;\n \n public class AdamsBashforthIntegratorTest {\n     @Test(expected=IntegratorException.class)\n     public void dimensionCheck() throws DerivativeException, IntegratorException {\n         TestProblem1 pb = new TestProblem1();\n-        new AdamsBashforthIntegrator(3, 0.01).integrate(pb,\n-                                                        0.0, new double[pb.getDimension()+10],\n-                                                        1.0, new double[pb.getDimension()+10]);\n+        FirstOrderIntegrator integ =\n+            new AdamsBashforthIntegrator(3, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        integ.integrate(pb,\n+                        0.0, new double[pb.getDimension()+10],\n+                        1.0, new double[pb.getDimension()+10]);\n     }\n \n-    @Test\n-    public void decreasingSteps() throws DerivativeException, IntegratorException {\n+    @Test(expected=IntegratorException.class)\n+    public void testMinStep() throws DerivativeException, IntegratorException {\n \n-        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n-        for (int k = 0; k < problems.length; ++k) {\n+          TestProblem1 pb = new TestProblem1();\n+          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+          double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n \n-            double previousError = Double.NaN;\n-            for (int i = 6; i < 10; ++i) {\n-\n-                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n-                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n-\n-                FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n-                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-                integ.addStepHandler(handler);\n-                EventHandler[] functions = pb.getEventsHandlers();\n-                for (int l = 0; l < functions.length; ++l) {\n-                    integ.addEventHandler(functions[l],\n-                                          Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);\n-                }\n-                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n-                                                  pb.getFinalTime(), new double[pb.getDimension()]);\n-                if (functions.length == 0) {\n-                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n-                }\n-\n-                double error = handler.getMaximalValueError();\n-                if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {\n-                    assertTrue(error <= Math.abs(1.05 * previousError));\n-                }\n-                previousError = error;\n-\n-            }\n-\n-        }\n+          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, minStep, maxStep,\n+                                                                    vecAbsoluteTolerance,\n+                                                                    vecRelativeTolerance);\n+          TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+          integ.addStepHandler(handler);\n+          integ.integrate(pb,\n+                          pb.getInitialTime(), pb.getInitialState(),\n+                          pb.getFinalTime(), new double[pb.getDimension()]);\n \n     }\n \n     @Test\n-    public void smallStep() throws DerivativeException, IntegratorException {\n+    public void testIncreasingTolerance()\n+        throws DerivativeException, IntegratorException {\n \n-        TestProblem1 pb  = new TestProblem1();\n-        double range = pb.getFinalTime() - pb.getInitialTime();\n-        double step = range * 0.001;\n+        int previousCalls = Integer.MAX_VALUE;\n+        for (int i = -12; i < -2; ++i) {\n+            TestProblem1 pb = new TestProblem1();\n+            double minStep = 0;\n+            double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+            double scalAbsoluteTolerance = Math.pow(10.0, i);\n+            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n-        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, step);\n-        integ.setStarterIntegrator(new DormandPrince853Integrator(0, range, 1.0e-12, 1.0e-12));\n-        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.addStepHandler(handler);\n-        integ.integrate(pb,\n-                        pb.getInitialTime(), pb.getInitialState(),\n-                        pb.getFinalTime(), new double[pb.getDimension()]);\n+            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb,\n+                            pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        assertTrue(handler.getLastError() < 2.0e-9);\n-        assertTrue(handler.getMaximalValueError() < 9.0e-9);\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n-        assertEquals(\"Adams-Bashforth\", integ.getName());\n-        assertTrue(integ.getEvaluations() > 1000);\n-        assertEquals(Integer.MAX_VALUE, integ.getMaxEvaluations());\n+            // the 28 and 42 factors are only valid for this test\n+            // and has been obtained from trial and error\n+            // there is no general relation between local and global errors\n+            assertTrue(handler.getMaximalValueError() > (28.0 * scalAbsoluteTolerance));\n+            assertTrue(handler.getMaximalValueError() < (42.0 * scalAbsoluteTolerance));\n+            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+\n+            int calls = pb.getCalls();\n+            assertEquals(integ.getEvaluations(), calls);\n+            assertTrue(calls <= previousCalls);\n+            previousCalls = calls;\n+\n+        }\n \n     }\n \n \n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n-        double step = range * 0.001;\n \n-        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, step);\n-        integ.setStarterIntegrator(new DormandPrince853Integrator(0, range, 1.0e-12, 1.0e-12));\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n-        integ.setMaxEvaluations(1000);\n+        integ.setMaxEvaluations(650);\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n     }\n \n     @Test\n-    public void bigStep() throws DerivativeException, IntegratorException {\n-\n-        TestProblem1 pb  = new TestProblem1();\n-        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n-\n-        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);\n-        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.addStepHandler(handler);\n-        integ.integrate(pb,\n-                        pb.getInitialTime(), pb.getInitialState(),\n-                        pb.getFinalTime(), new double[pb.getDimension()]);\n-\n-        assertTrue(handler.getLastError() > 0.06);\n-        assertTrue(handler.getMaximalValueError() > 0.06);\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n-\n-    }\n-\n-    @Test\n     public void backward() throws DerivativeException, IntegratorException {\n \n         TestProblem5 pb = new TestProblem5();\n-        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        assertTrue(handler.getLastError() < 8.0e-11);\n-        assertTrue(handler.getMaximalValueError() < 8.0e-11);\n+        assertTrue(handler.getLastError() < 1.0e-8);\n+        assertTrue(handler.getMaximalValueError() < 1.0e-8);\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n         assertEquals(\"Adams-Bashforth\", integ.getName());\n     }\n     @Test\n     public void polynomial() throws DerivativeException, IntegratorException {\n         TestProblem6 pb = new TestProblem6();\n-        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         for (int order = 2; order < 9; ++order) {\n-            AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(order, step);\n-            integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,\n-                                                                      1.0e-5, 1.0e-5));\n+            AdamsBashforthIntegrator integ =\n+                new AdamsBashforthIntegrator(order, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (order < 5) {\n-                assertTrue(handler.getMaximalValueError() > 1.0e-5);\n+                assertTrue(integ.getEvaluations() > 160);\n             } else {\n-                assertTrue(handler.getMaximalValueError() < 7.0e-12);\n+                assertTrue(integ.getEvaluations() < 70);\n             }\n         }\n \n                IOException, ClassNotFoundException {\n \n         TestProblem6 pb = new TestProblem6();\n-        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.01;\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-        oos.writeObject(new AdamsBashforthIntegrator(8, step));\n-        \n+        oos.writeObject(new AdamsBashforthIntegrator(5, 0, range, 1.0e-12, 1.0e-12));\n+        assertTrue(bos.size() > 2800);\n+        assertTrue(bos.size() < 3000);\n+\n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);\n         FirstOrderIntegrator integ  = (AdamsBashforthIntegrator) ois.readObject();\n         integ.addStepHandler(handler);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n-        assertTrue(handler.getMaximalValueError() < 7.0e-13);\n+        assertTrue(handler.getMaximalValueError() < 2.0e-11);\n \n     }\n \n--- a/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.EventHandler;\n import org.junit.Test;\n \n public class AdamsMoultonIntegratorTest {\n \n     @Test(expected=IntegratorException.class)\n-    public void dimensionCheck()\n-        throws DerivativeException, IntegratorException {\n+    public void dimensionCheck() throws DerivativeException, IntegratorException {\n         TestProblem1 pb = new TestProblem1();\n-        new AdamsMoultonIntegrator(3, 0.01).integrate(pb,\n-                                                      0.0, new double[pb.getDimension()+10],\n-                                                      1.0, new double[pb.getDimension()+10]);\n+        FirstOrderIntegrator integ =\n+            new AdamsMoultonIntegrator(3, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        integ.integrate(pb,\n+                        0.0, new double[pb.getDimension()+10],\n+                        1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test(expected=IntegratorException.class)\n+    public void testMinStep() throws DerivativeException, IntegratorException {\n+\n+          TestProblem1 pb = new TestProblem1();\n+          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+          double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, minStep, maxStep,\n+                                                                    vecAbsoluteTolerance,\n+                                                                    vecRelativeTolerance);\n+          TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+          integ.addStepHandler(handler);\n+          integ.integrate(pb,\n+                          pb.getInitialTime(), pb.getInitialState(),\n+                          pb.getFinalTime(), new double[pb.getDimension()]);\n+\n     }\n \n     @Test\n-    public void decreasingSteps()\n+    public void testIncreasingTolerance()\n         throws DerivativeException, IntegratorException {\n \n-        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n-        for (int k = 0; k < problems.length; ++k) {\n+        int previousCalls = Integer.MAX_VALUE;\n+        for (int i = -12; i < -2; ++i) {\n+            TestProblem1 pb = new TestProblem1();\n+            double minStep = 0;\n+            double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+            double scalAbsoluteTolerance = Math.pow(10.0, i);\n+            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n-            double previousError = Double.NaN;\n-            for (int i = 6; i < 10; ++i) {\n+            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb,\n+                            pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n \n-                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n-                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+            // the 0.4 and 3.0 factors are only valid for this test\n+            // and has been obtained from trial and error\n+            // there is no general relation between local and global errors\n+            assertTrue(handler.getMaximalValueError() > (0.4 * scalAbsoluteTolerance));\n+            assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));\n+            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n \n-                FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n-                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-                integ.addStepHandler(handler);\n-                EventHandler[] functions = pb.getEventsHandlers();\n-                for (int l = 0; l < functions.length; ++l) {\n-                    integ.addEventHandler(functions[l],\n-                                          Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);\n-                }\n-                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n-                                                  pb.getFinalTime(), new double[pb.getDimension()]);\n-                if (functions.length == 0) {\n-                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n-                }\n-\n-                double error = handler.getMaximalValueError();\n-                if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {\n-                    assertTrue(error <= Math.abs(1.05 * previousError));\n-                }\n-                previousError = error;\n-\n-            }\n+            int calls = pb.getCalls();\n+            assertEquals(integ.getEvaluations(), calls);\n+            assertTrue(calls <= previousCalls);\n+            previousCalls = calls;\n \n         }\n \n     }\n \n-    @Test\n-    public void smallStep()\n-        throws DerivativeException, IntegratorException {\n+    @Test(expected = DerivativeException.class)\n+    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {\n \n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n-        double step = range * 0.001;\n \n-        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(3, step);\n-        integ.setStarterIntegrator(new DormandPrince853Integrator(0, range, 1.0e-12, 1.0e-12));\n+        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(3, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n+        integ.setMaxEvaluations(650);\n         integ.integrate(pb,\n-                pb.getInitialTime(), pb.getInitialState(),\n-                pb.getFinalTime(), new double[pb.getDimension()]);\n-\n-        assertTrue(handler.getLastError() < 2.0e-10);\n-        assertTrue(handler.getMaximalValueError() < 1.0e-9);\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n-        assertEquals(\"Adams-Moulton\", integ.getName());\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n \n     }\n \n     @Test\n-    public void bigStep()\n-        throws DerivativeException, IntegratorException {\n-\n-        TestProblem1 pb  = new TestProblem1();\n-        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n-\n-        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);\n-        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.addStepHandler(handler);\n-        integ.integrate(pb,\n-                pb.getInitialTime(), pb.getInitialState(),\n-                pb.getFinalTime(), new double[pb.getDimension()]);\n-\n-        assertTrue(handler.getMaximalValueError() > 6.0e-6);\n-\n-    }\n-\n-    @Test\n-    public void backward()\n-        throws DerivativeException, IntegratorException {\n+    public void backward() throws DerivativeException, IntegratorException {\n \n         TestProblem5 pb = new TestProblem5();\n-        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        assertTrue(handler.getLastError() < 4.0e-12);\n-        assertTrue(handler.getMaximalValueError() < 4.0e-12);\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n+        assertTrue(handler.getLastError() < 1.0e-9);\n+        assertTrue(handler.getMaximalValueError() < 1.0e-9);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n         assertEquals(\"Adams-Moulton\", integ.getName());\n     }\n \n     @Test\n-    public void polynomial()\n-        throws DerivativeException, IntegratorException {\n-        final TestProblem6 pb = new TestProblem6();\n-        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;\n+    public void polynomial() throws DerivativeException, IntegratorException {\n+        TestProblem6 pb = new TestProblem6();\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        for (int order = 2; order < 9; ++order) {\n-            AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(order, step);\n-            integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,\n-                                                                      1.0e-5, 1.0e-5));\n-            final TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        for (int order = 2; order < 8; ++order) {\n+            AdamsMoultonIntegrator integ =\n+                new AdamsMoultonIntegrator(order, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (order < 5) {\n-                assertTrue(handler.getMaximalValueError() > 1.0e-6);\n+                assertTrue(integ.getEvaluations() > 150);\n             } else {\n-                assertTrue(handler.getMaximalValueError() < 4.0e-13);\n+                assertTrue(integ.getEvaluations() < 90);\n             }\n         }\n \n                IOException, ClassNotFoundException {\n \n         TestProblem6 pb = new TestProblem6();\n-        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.01;\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-        oos.writeObject(new AdamsMoultonIntegrator(8, step));\n-        \n+        oos.writeObject(new AdamsMoultonIntegrator(5, 0, range, 1.0e-12, 1.0e-12));\n+        assertTrue(bos.size() > 2800);\n+        assertTrue(bos.size() < 3000);\n+\n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);\n         FirstOrderIntegrator integ  = (AdamsMoultonIntegrator) ois.readObject();\n         integ.addStepHandler(handler);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n-        assertTrue(handler.getMaximalValueError() < 2.0e-13);\n+        assertTrue(handler.getMaximalValueError() < 8.0e-11);\n \n     }\n \n--- a/src/test/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n     public void derivativesConsistency()\n     throws DerivativeException, IntegratorException {\n         TestProblem3 pb = new TestProblem3();\n-        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n-        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, step);\n-        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 7e-10);\n     }\n \n     @Test\n     IOException, ClassNotFoundException {\n \n         TestProblem1 pb = new TestProblem1();\n-        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n-        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, 0.0, 1.0, 1.0e-10, 1.0e-10);\n         integ.addStepHandler(new ContinuousOutputModel());\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n             oos.writeObject(handler);\n         }\n \n-        assertTrue(bos.size () > 148000);\n-        assertTrue(bos.size () < 149000);\n+        assertTrue(bos.size () >  16000);\n+        assertTrue(bos.size () <  17000);\n \n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);", "timestamp": 1245521754, "metainfo": ""}