{"sha": "6120284c3713886137a3fc71e27606b8f32c9eb2", "log": "Added method to walk matrix entries with or without changing them in the visitor design pattern sense. Two different orders can be used, row by row of following internal storage. Internal order should be preferred when no specific order is needed, because it will be more cache efficient.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n             return new RealVectorImpl(out);\n \n         }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n import org.apache.commons.math.MathRuntimeException;\n \n /**\n- * Implementation of RealMatrix using a flat arrays to store square blocks of the matrix.\n+ * Cache-friendly implementation of RealMatrix using a flat arrays to store\n+ * square blocks of the matrix.\n  * <p>\n- * This implementation is cache-friendly. Square blocks are stored as small arrays and allow\n- * efficient traversal of data both in row major direction and columns major direction. This\n- * greatly increases performances for algorithms that use crossed directions loops like\n- * multiplication or transposition.\n+ * This implementation is specially designed to be cache-friendly. Square blocks are\n+ * stored as small arrays and allow efficient traversal of data both in row major direction\n+ * and columns major direction, one block at a time. This greatly increases performances\n+ * for algorithms that use crossed directions loops like multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The size of square blocks is a static parameter. It may be tuned according to the cache\n+ * size of the target computer processor. As a rule of thumbs, it should be the largest\n+ * value that allows three blocks to be simultaneously cached (this is necessary for example\n+ * for matrix multiplication). The default value is to use 52x52 blocks which is well suited\n+ * for processors with 64k L1 cache (one block holds 2704 values or 21632 bytes). This value\n+ * could be lowered to 36x36 for processors with 32k L1 cache.\n+ * </p>\n+ * <p>\n+ * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks\n+ * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square\n+ * blocks are flattened in row major order in single dimension arrays which are therefore\n+ * {@link #BLOCK_SIZE}<sup>2</sup> elements long for regular blocks. The blocks are themselves\n+ * organized in row major order.\n+ * </p>\n+ * <p>\n+ * As an example, for a block size of 52x52, a 100x60 matrix would be stored in 4 blocks.\n+ * Block 0 would be a double[2704] array holding the upper left 52x52 square, block 1 would be\n+ * a double[416] array holding the upper right 52x8 rectangle, block 2 would be a double[2496]\n+ * array holding the lower left 48x52 rectangle and block 3 would be a double[384] array\n+ * holding the lower right 48x8 rectangle.\n  * </p>\n  * <p>\n  * The layout complexity overhead versus simple mapping of matrices to java\n \n     }\n \n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final double[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final double[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Get the height of a block.\n      * @param blockRow row index (in block sense) of the block\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/MatrixVisitorException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Thrown when a visitor encounters an error while processing a matrix entry.\n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixVisitorException extends MathRuntimeException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 3814333035048617048L;\n+\n+    /**\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MatrixVisitorException(final String pattern, final Object[] arguments) {\n+      super(pattern, arguments);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n      * counting from 0 to n-1.\n      *\n      * @param startRow Initial row index\n-     * @param endRow Final row index\n+     * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n-     * @param endColumn Final column index\n+     * @param endColumn Final column index (inclusive)\n      * @return The subMatrix containing the data of the\n      *         specified rows and columns\n      * @exception MatrixIndexException  if the indices are not valid\n     RealVector preMultiply(RealVector v) throws IllegalArgumentException;\n \n     /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInRowOrder(RealMatrixChangingVisitor visitor) throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInRowOrder(RealMatrixPreservingVisitor visitor) throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInRowOrder(RealMatrixChangingVisitor visitor,\n+                        int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInRowOrder(RealMatrixPreservingVisitor visitor,\n+                        int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>The matrix internal order depends on the exact matrix class. It may be\n+     * different from traditional row order, but is generally faster. If there is no need\n+     * for an explicit walk order, this method should be preferred to the {@link\n+     * #walkInRowOrder(RealMatrixChangingVisitor)} one.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInInternalOrder(RealMatrixChangingVisitor visitor) throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * <p>The matrix internal order depends on the exact matrix class. It may be\n+     * different from traditional row order, but is generally faster. If there is no need\n+     * for an explicit walk order, this method should be preferred to the {@link\n+     * #walkInRowOrder(RealMatrixPreservingVisitor)} one.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInInternalOrder(RealMatrixPreservingVisitor visitor) throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>The matrix internal order depends on the exact matrix class. It may be\n+     * different from traditional row order, but is generally faster. If there is no need\n+     * for an explicit walk order, this method should be preferred to the {@link\n+     * #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)} one.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     */\n+    void walkInInternalOrder(RealMatrixChangingVisitor visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>The matrix internal order depends on the exact matrix class. It may be\n+     * different from traditional row order, but is generally faster. If there is no need\n+     * for an explicit walk order, this method should be preferred to the {@link\n+     * #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)} one.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     */\n+    void walkInInternalOrder(RealMatrixPreservingVisitor visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n      * Returns the solution vector for a linear system with coefficient\n      * matrix = this and constant vector = <code>b</code>.\n      *\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealMatrixChangingVisitor extends Serializable {\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @return the new value to be set for the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    double visit(int row, int column, double value)\n+        throws MatrixVisitorException;\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n \n     }\n \n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+    }\n+\n     /**\n      * Returns a fresh copy of the underlying data array.\n      *\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealMatrixPreservingVisitor extends Serializable {\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    void visit(int row, int column, double value)\n+        throws MatrixVisitorException;\n+\n+}\n--- a/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n         }\n         \n     }\n-    \n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new DenseRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInInternalOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInInternalOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+\n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInInternalOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInInternalOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+    \n+    private static class SetVisitor implements RealMatrixChangingVisitor {\n+        private static final long serialVersionUID = -5724808764099124932L;\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor implements RealMatrixPreservingVisitor {\n+        private static final long serialVersionUID = 1299771253908695242L;\n+        int count = 0;\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    };\n+\n     //--------------- -----------------Protected methods\n         \n     /** verifies that two matrices are close (1-norm) */              \n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         }\n         \n     }\n-    \n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new RealMatrixImpl(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInInternalOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInInternalOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInInternalOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInInternalOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+    \n+    private static class SetVisitor implements RealMatrixChangingVisitor {\n+        private static final long serialVersionUID = -5724808764099124932L;\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor implements RealMatrixPreservingVisitor {\n+        private static final long serialVersionUID = 1299771253908695242L;\n+        int count = 0;\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    };\n+\n     //--------------- -----------------Protected methods\n         \n     /** verifies that two matrices are close (1-norm) */              ", "timestamp": 1230411312, "metainfo": ""}