{"sha": "c28099c6ede92badb1c26c003ea64c5f3f38377e", "log": "added an abstract implementation of RealMatrix and used it for RealMatrixImpl JIRA: MATH-231  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"index {0} out of allowed range [{1}, {2}]\",\n       \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n \n+    // org.apache.commons.math.linear.AbstractRealMatrix\n+    { \"invalid row dimension: {0} (must be positive)\",\n+      \"nombre de lignes invalide : {0} (doit \\u00eatre positif)\" },\n+    { \"invalid column dimension: {0} (must be positive)\",\n+      \"nombre de colonnes invalide : {0} (doit \\u00eatre positif)\" },\n+    { \"vector length mismatch: got {0} but expected {1}\",\n+      \"taille de vecteur invalide : {0} au lieu de {1} attendue\" },\n+\n     // org.apache.commons.math.linear.BigMatrixImpl\n     // org.apache.commons.math.linear.RealMatrixImpl\n+    { \"matrix must have at least one row\",\n+      \"une matrice doit comporter au moins une ligne\" },\n+    { \"matrix must have at least one column\",\n+      \"une matrice doit comporter au moins une colonne\" },\n+    { \"some rows have length {0} while others have length {1}\",\n+      \"certaines ligne ont une longueur de {0} alors que d''autres ont une longueur de {1}\" },\n     { \"row index {0} out of allowed range [{1}, {2}]\",\n       \"index de ligne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n     { \"column index {0} out of allowed range [{1}, {2}]\",\n    { \"first {0} columns are not initialized yet\",\n      \"les {0} premi\\u00e8res colonnes ne sont pas encore initialis\\u00e9es\" },\n \n-   // org.apache.commons.math.linear.EigenDecompositionImpl\n-   // org.apache.commons.math.linear.LUDecompositionImpl\n-   // org.apache.commons.math.linear.QRDecompositionImpl\n-   // org.apache.commons.math.linear.SingularValueDecompositionImpl\n-   { \"no matrix have been decomposed yet\",\n-     \"aucune matrice n''a encore \\u00e9t\\u00e9 d\\u00e9compos\\u00e9e\" },\n-\n    // org.apache.commons.math.random.EmpiricalDistributionImpl\n    { \"distribution not loaded\",\n      \"aucune distribution n''a \\u00e9t\\u00e9 charg\\u00e9e\" },\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Basic implementation of RealMatrix methods regardless of the underlying storage.\n+ * <p>All the methods implemented here use {@link #getEntry(int, int)} to access\n+ * matrix elements. Derived class can provide faster implementations. </p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractRealMatrix implements RealMatrix, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3665653040524315561L;\n+\n+    /** Cached LU solver.\n+     * @deprecated as of release 2.0, since all methods using this are deprecated\n+     */\n+    private LUSolver lu;\n+\n+    /**\n+     * Creates a matrix with no data\n+     */\n+    protected AbstractRealMatrix() {\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"invalid row dimension {0}\" +\n+                                                                      \" (must be positive)\",\n+                                                                      new Object[] { rowDimension });\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"invalid column dimension {0}\" +\n+                                                                      \" (must be positive)\",\n+                                                                      new Object[] { columnDimension });\n+        }\n+        lu = null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException;\n+\n+    /** {@inheritDoc} */\n+    public abstract RealMatrix copy();\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n+                                                                      \" addition compatible\",\n+                                                                      new Object[] {\n+                                                                          getRowDimension(),\n+                                                                          getColumnDimension(),\n+                                                                          m.getRowDimension(),\n+                                                                          m.getColumnDimension()\n+                                                                      });\n+        }\n+\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix subtract(final RealMatrix m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n+                                                                      \" subtraction compatible\",\n+                                                                      new Object[] {\n+                                                                          getRowDimension(),\n+                                                                          getColumnDimension(),\n+                                                                          m.getRowDimension(),\n+                                                                          m.getColumnDimension()\n+                                                                      });\n+        }\n+\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarAdd(final double d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) + d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarMultiply(final double d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) * d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        if (getColumnDimension() != m.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n+                                                                      \" multiplication compatible\",\n+                                                                      new Object[] {\n+                                                                          getRowDimension(),\n+                                                                          getColumnDimension(),\n+                                                                          m.getRowDimension(),\n+                                                                          m.getColumnDimension()\n+                                                                      });\n+        }\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = getColumnDimension();\n+        final RealMatrix out = createMatrix(nRows, nCols);\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                double sum = 0;\n+                for (int i = 0; i < nSum; ++i) {\n+                    sum += getEntry(row, i) * m.getEntry(i, col);\n+                }\n+                out.setEntry(row, col, sum);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix preMultiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract double[][] getData();\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        double maxColSum = 0;\n+        for (int col = 0; col < columnCount; ++col) {\n+            double sum = 0;\n+            for (int row = 0; row < rowCount; ++row) {\n+                sum += Math.abs(getEntry(row, col));\n+            }\n+            maxColSum = Math.max(maxColSum, sum);\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           new Object[] { startRow, endRow });\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           new Object[] { startColumn, endColumn });\n+        }\n+\n+        final RealMatrix subMatrix =\n+            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n+            }\n+        }\n+\n+        return subMatrix;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+        throws MatrixIndexException {\n+\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\", null);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", null);\n+        }\n+\n+        final RealMatrix subMatrix =\n+            createMatrix(selectedRows.length, selectedColumns.length);\n+        try  {\n+            for (int i = 0; i < selectedRows.length; i++) {\n+                for (int j = 0; j < selectedColumns.length; j++) {\n+                    subMatrix.setEntry(i, j, getEntry(selectedRows[i], selectedColumns[j]));\n+                }\n+            }\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            // we redo the loop with checks enabled\n+            // in order to generate an appropriate message\n+            for (final int row : selectedRows) {\n+                checkRowIndex(row);\n+            }\n+            for (final int column : selectedColumns) {\n+                checkColumnIndex(column);\n+            }\n+        }\n+\n+        return subMatrix;\n+\n+    } \n+\n+    /** {@inheritDoc} */\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+        throws MatrixIndexException {\n+\n+        final int nRows = subMatrix.length;\n+        if (nRows == 0) {\n+            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+        }\n+\n+        final int nCols = subMatrix[0].length;\n+        if (nCols == 0) {\n+            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+        }\n+\n+        for (int r = 1; r < nRows; ++r) {\n+            if (subMatrix[r].length != nCols) {\n+                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+            }\n+        }\n+\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        checkRowIndex(nRows + row - 1);\n+        checkColumnIndex(nCols + column - 1);\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            for (int j = 0; j < nCols; ++j) {\n+                setEntry(row + i, column + j, subMatrix[i][j]);\n+            }\n+        } \n+\n+        lu = null;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        final RealMatrix out = createMatrix(1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            out.setEntry(0, i, getEntry(row, i));\n+        }\n+\n+        return out;\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        final RealMatrix out = createMatrix(nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            out.setEntry(i, 0, getEntry(i, column));\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getColumnVector(final int column)\n+        throws MatrixIndexException {\n+        return new RealVectorImpl(getColumn(column), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getRowVector(final int row)\n+        throws MatrixIndexException {\n+        return new RealVectorImpl(getRow(row), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        final double[] out = new double[nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            out[i] = getEntry(row, i);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        final double[] out = new double[nRows];\n+        for (int i = 0; i < nRows; ++i) {\n+            out[i] = getEntry(i, column);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract double getEntry(int row, int column)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, double value)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final RealMatrix out = createMatrix(nCols, nRows);\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                out.setEntry(col, row, getEntry(row, col));\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public RealMatrix inverse()\n+        throws InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.getInverse();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double getDeterminant()\n+        throws InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.getDeterminant();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSquare() {\n+        return (getColumnDimension() == getRowDimension());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public boolean isSingular() {\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+       }\n+        return !lu.isNonSingular();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract int getRowDimension();\n+\n+    /** {@inheritDoc} */\n+    public abstract int getColumnDimension();\n+\n+    /** {@inheritDoc} */\n+    public double getTrace()\n+        throws NonSquareMatrixException {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new NonSquareMatrixException(nRows, nCols);\n+       }\n+        double trace = 0;\n+        for (int i = 0; i < nRows; ++i) {\n+            trace += getEntry(i, i);\n+        }\n+        return trace;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.length, nCols\n+                                                                      });\n+        }\n+\n+        final double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; ++row) {\n+            double sum = 0;\n+            for (int i = 0; i < nCols; ++i) {\n+                sum += getEntry(row, i) * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector operate(final RealVector v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.getDimension() != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.getDimension(), nCols\n+                                                                      });\n+        }\n+\n+        final double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; ++row) {\n+            double sum = 0;\n+            for (int i = 0; i < nCols; ++i) {\n+                sum += getEntry(row, i) * v.getEntry(i);\n+            }\n+            out[row] = sum;\n+        }\n+\n+        return new RealVectorImpl(out, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.length, nRows\n+                                                                      });\n+        }\n+\n+        final double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; ++col) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; ++i) {\n+                sum += getEntry(i, col) * v[i];\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector preMultiply(final RealVector v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.getDimension() != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.getDimension(), nRows\n+                                                                      });\n+        }\n+\n+        final double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; ++col) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; ++i) {\n+                sum += getEntry(i, col) * v.getEntry(i);\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return new RealVectorImpl(out);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.solve(b);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException  {\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.solve(b);\n+    }\n+\n+    /**\n+     * Computes a new\n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algorithm</a>, with partial pivoting.</p>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.</p>\n+     *\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     * @deprecated as of release 2.0, replaced by {@link LUDecomposition}\n+     */\n+    @Deprecated\n+    public void luDecompose()\n+        throws InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+    }\n+\n+    /**\n+     * Get a string representation for this matrix.\n+     * @return a string representation for this matrix\n+     */\n+    public String toString() {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final StringBuffer res = new StringBuffer();\n+        res.append(\"RealMatrixImpl{\");\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            if (i > 0) {\n+                res.append(\",\");\n+            }\n+            res.append(\"{\");\n+            for (int j = 0; j < nCols; ++j) {\n+                if (j > 0) {\n+                    res.append(\",\");\n+                }\n+                res.append(getEntry(i, j));\n+            } \n+            res.append(\"}\");\n+        } \n+\n+        res.append(\"}\");\n+        return res.toString();\n+\n+    } \n+    \n+    /**\n+     * Returns true iff <code>object</code> is a\n+     * <code>RealMatrix</code> instance with the same dimensions as this\n+     * and all corresponding matrix entries are equal.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    public boolean equals(final Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof RealMatrix == false) {\n+            return false;\n+        }\n+        RealMatrix m = (RealMatrix) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n+            return false;\n+        }\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                if (getEntry(row, col) != m.getEntry(row, col)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Computes a hashcode for the matrix.\n+     * \n+     * @return hashcode for matrix\n+     */\n+    public int hashCode() {\n+        int ret = 7;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        ret = ret * 31 + nRows;\n+        ret = ret * 31 + nCols;\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n+                   MathUtils.hash(getEntry(row, col));\n+           }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { row, 0, getRowDimension() - 1});\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { column, 0, getColumnDimension() - 1});\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n  * @version $Revision$ $Date$\n  */\n public interface RealMatrix {\n+\n+    /**\n+     * Create a new RealMatrix of the same type as the instance with the supplied\n+     * row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @since 2.0\n+     */\n+    RealMatrix createMatrix(final int rowDimension, final int columnDimension);\n+\n     /**\n      * Returns a (deep) copy of this.\n      *\n     */\n    RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n    throws MatrixIndexException;\n-   \n+\n+   /**\n+    * Replace the submatrix starting at <code>row, column</code> using data in\n+    * the input <code>subMatrix</code> array. Indexes are 0-based.\n+    * <p> \n+    * Example:<br>\n+    * Starting with <pre>\n+    * 1  2  3  4\n+    * 5  6  7  8\n+    * 9  0  1  2\n+    * </pre>\n+    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+    * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n+    * 1  2  3  4\n+    * 5  3  4  8\n+    * 9  5  6  2\n+    * </pre></p>\n+    * \n+    * @param subMatrix  array containing the submatrix replacement data\n+    * @param row  row coordinate of the top, left element to be replaced\n+    * @param column  column coordinate of the top, left element to be replaced\n+    * @throws MatrixIndexException  if subMatrix does not fit into this \n+    *    matrix from element in (row, column) \n+    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n+    *  (not all rows have the same length) or empty\n+    * @throws NullPointerException if <code>subMatrix</code> is null\n+    * @since 2.0\n+    */\n+   void setSubMatrix(double[][] subMatrix, int row, int column) \n+       throws MatrixIndexException;\n+\n    /**\n     * Returns the entries in row number <code>row</code>\n     * as a row matrix.  Row indices start at 0.\n      * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n      * unless <code>0 <= column < columnDimension.</code></p>\n      *\n-     * @param col the column to be fetched\n+     * @param column the column to be fetched\n      * @return array of entries in the column\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n-    double[] getColumn(int col) throws MatrixIndexException;\n+    double[] getColumn(int column) throws MatrixIndexException;\n \n     /**\n      * Returns the entry in the specified row and column.\n     double getEntry(int row, int column) throws MatrixIndexException;\n \n     /**\n+     * Set the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param value matrix entry to be set in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void setEntry(int row, int column, double value) throws MatrixIndexException;\n+\n+    /**\n      * Returns the transpose of this matrix.\n      *\n      * @return transpose matrix\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      * @return trace\n-     */\n-    double getTrace();\n+     * @throws NonSquareMatrixException if the matrix is not square\n+     */\n+    double getTrace() throws NonSquareMatrixException;\n \n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.util.MathUtils;\n-\n \n /**\n  * Implementation of RealMatrix using a double[][] array to store entries and\n  *\n  * @version $Revision$ $Date$\n  */\n-public class RealMatrixImpl implements RealMatrix, Serializable {\n+public class RealMatrixImpl extends AbstractRealMatrix implements Serializable {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -391443069570048115L;\n+    private static final long serialVersionUID = -1067294169172445528L;\n \n     /** Entries of the matrix */\n     protected double data[][];\n-\n-    /** Cached LU solver.\n-     * @deprecated as of release 2.0, since all methods using this are deprecated\n-     */\n-    private LUSolver lu;\n \n     /**\n      * Creates a matrix with no data\n      * @throws IllegalArgumentException if row or column dimension is not\n      *  positive\n      */\n-    public RealMatrixImpl(int rowDimension, int columnDimension) {\n-        if (rowDimension <= 0 || columnDimension <= 0) {\n-            throw new IllegalArgumentException(\n-                    \"row and column dimensions must be postive\");\n-        }\n+    public RealMatrixImpl(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(rowDimension, columnDimension);\n         data = new double[rowDimension][columnDimension];\n-        lu = null;\n     }\n \n     /**\n      * @throws NullPointerException if <code>d</code> is null\n      * @see #RealMatrixImpl(double[][], boolean)\n      */\n-    public RealMatrixImpl(double[][] d) {\n+    public RealMatrixImpl(final double[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n         copyIn(d);\n-        lu = null;\n     }\n \n     /**\n      * @throws NullPointerException if <code>d</code> is null\n      * @see #RealMatrixImpl(double[][])\n      */\n-    public RealMatrixImpl(double[][] d, boolean copyArray) {\n+    public RealMatrixImpl(final double[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n         if (copyArray) {\n             copyIn(d);\n         } else {\n             }   \n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\",\n+                                                                          null); \n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n+                                                                          null); \n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n-                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                    throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while\" +\n+                                                                              \" others have length {1}\",\n+                                                                              new Object[] { nCols, d[r].length });\n                 }\n             }       \n             data = d;\n         }\n-        lu = null;\n     }\n \n     /**\n      *\n      * @param v column vector holding data for new matrix\n      */\n-    public RealMatrixImpl(double[] v) {\n+    public RealMatrixImpl(final double[] v) {\n         final int nRows = v.length;\n         data = new double[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n     }\n \n     /** {@inheritDoc} */\n+    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new RealMatrixImpl(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n     public RealMatrix copy() {\n         return new RealMatrixImpl(copyOut(), false);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n         try {\n             return add((RealMatrixImpl) m);\n         } catch (ClassCastException cce) {\n-            final int rowCount    = getRowDimension();\n-            final int columnCount = getColumnDimension();\n-            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                          \" addition compatible\",\n-                                                                          new Object[] {\n-                                                                              getRowDimension(), getColumnDimension(),\n-                                                                              m.getRowDimension(), m.getColumnDimension()\n-                                                                          });\n-            }\n-            final double[][] outData = new double[rowCount][columnCount];\n-            for (int row = 0; row < rowCount; row++) {\n-                final double[] dataRow    = data[row];\n-                final double[] outDataRow = outData[row];\n-                for (int col = 0; col < columnCount; col++) {\n-                    outDataRow[col] = dataRow[col] + m.getEntry(row, col);\n-                }  \n-            }\n-            return new RealMatrixImpl(outData, false);\n+            return super.add(m);\n         }\n     }\n \n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {\n+    public RealMatrixImpl add(final RealMatrixImpl m)\n+        throws IllegalArgumentException {\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n         try {\n             return subtract((RealMatrixImpl) m);\n         } catch (ClassCastException cce) {\n-            final int rowCount    = getRowDimension();\n-            final int columnCount = getColumnDimension();\n-            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                          \" subtraction compatible\",\n-                                                                          new Object[] {\n-                                                                              getRowDimension(), getColumnDimension(),\n-                                                                              m.getRowDimension(), m.getColumnDimension()\n-                                                                          });\n-            }\n-            final double[][] outData = new double[rowCount][columnCount];\n-            for (int row = 0; row < rowCount; row++) {\n-                final double[] dataRow    = data[row];\n-                final double[] outDataRow = outData[row];\n-                for (int col = 0; col < columnCount; col++) {\n-                    outDataRow[col] = dataRow[col] - m.getEntry(row, col);\n-                }  \n-            }\n-            return new RealMatrixImpl(outData, false);\n+            return super.subtract(m);\n         }\n     }\n \n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {\n+    public RealMatrixImpl subtract(final RealMatrixImpl m)\n+        throws IllegalArgumentException {\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix scalarAdd(double d) {\n-        final int rowCount    = getRowDimension();\n-        final int columnCount = getColumnDimension();\n-        final double[][] outData = new double[rowCount][columnCount];\n-        for (int row = 0; row < rowCount; row++) {\n-            final double[] dataRow    = data[row];\n-            final double[] outDataRow = outData[row];\n-            for (int col = 0; col < columnCount; col++) {\n-                outDataRow[col] = dataRow[col] + d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData, false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix scalarMultiply(double d) {\n-        final int rowCount    = getRowDimension();\n-        final int columnCount = getColumnDimension();\n-        final double[][] outData = new double[rowCount][columnCount];\n-        for (int row = 0; row < rowCount; row++) {\n-            final double[] dataRow    = data[row];\n-            final double[] outDataRow = outData[row];\n-            for (int col = 0; col < columnCount; col++) {\n-                outDataRow[col] = dataRow[col] * d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData, false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n         try {\n             return multiply((RealMatrixImpl) m);\n         } catch (ClassCastException cce) {\n-            if (this.getColumnDimension() != m.getRowDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                          \" multiplication compatible\",\n-                                                                          new Object[] {\n-                                                                              getRowDimension(), getColumnDimension(),\n-                                                                              m.getRowDimension(), m.getColumnDimension()\n-                                                                          });\n-            }\n-            final int nRows = this.getRowDimension();\n-            final int nCols = m.getColumnDimension();\n-            final int nSum = this.getColumnDimension();\n-            final double[][] outData = new double[nRows][nCols];\n-            for (int row = 0; row < nRows; row++) {\n-                final double[] dataRow    = data[row];\n-                final double[] outDataRow = outData[row];\n-                for (int col = 0; col < nCols; col++) {\n-                    double sum = 0;\n-                    for (int i = 0; i < nSum; i++) {\n-                        sum += dataRow[i] * m.getEntry(i, col);\n-                    }\n-                    outDataRow[col] = sum;\n-                }\n-            }\n-            return new RealMatrixImpl(outData, false);\n+            return super.multiply(m);\n         }\n     }\n \n      * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {\n+    public RealMatrixImpl multiply(final RealMatrixImpl m)\n+        throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getRowDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n                                                                       \" multiplication compatible\",\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n-        return m.multiply(this);\n-    }\n-\n-    /** {@inheritDoc} */\n     public double[][] getData() {\n         return copyOut();\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public double getNorm() {\n-        double maxColSum = 0;\n-        for (int col = 0; col < this.getColumnDimension(); col++) {\n-            double sum = 0;\n-            for (int row = 0; row < this.getRowDimension(); row++) {\n-                sum += Math.abs(data[row][col]);\n-            }\n-            maxColSum = Math.max(maxColSum, sum);\n-        }\n-        return maxColSum;\n-    }\n-    \n-    /** {@inheritDoc} */\n-    public RealMatrix getSubMatrix(int startRow, int endRow,\n-                                   int startColumn, int endColumn)\n-        throws MatrixIndexException {\n-\n-        checkRowIndex(startRow);\n-        checkRowIndex(endRow);\n-        if (startRow > endRow) {\n-            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n-                                           new Object[] { startRow, endRow });\n-        }\n-\n-        checkColumnIndex(startColumn);\n-        checkColumnIndex(endColumn);\n-        if (startColumn > endColumn) {\n-            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n-                                           new Object[] { startColumn, endColumn });\n-        }\n-\n-        final double[][] subMatrixData =\n-            new double[endRow - startRow + 1][endColumn - startColumn + 1];\n-        for (int i = startRow; i <= endRow; i++) {\n-            System.arraycopy(data[i], startColumn,\n-                             subMatrixData[i - startRow], 0,\n-                             endColumn - startColumn + 1);\n-        }\n-        return new RealMatrixImpl(subMatrixData, false);\n-    }\n-    \n-    /** {@inheritDoc} */\n-    public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-        throws MatrixIndexException {\n-\n-        if (selectedRows.length * selectedColumns.length == 0) {\n-            if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\", null);\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\", null);\n-        }\n-\n-        final double[][] subMatrixData =\n-            new double[selectedRows.length][selectedColumns.length];\n-        try  {\n-            for (int i = 0; i < selectedRows.length; i++) {\n-                final double[] subI = subMatrixData[i];\n-                final double[] dataSelectedI = data[selectedRows[i]];\n-                for (int j = 0; j < selectedColumns.length; j++) {\n-                    subI[j] = dataSelectedI[selectedColumns[j]];\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            // we redo the loop with checks enabled\n-            // in order to generate an appropriate message\n-            for (final int row : selectedRows) {\n-                checkRowIndex(row);\n-            }\n-            for (final int column : selectedColumns) {\n-                checkColumnIndex(column);\n-            }\n-        }\n-        return new RealMatrixImpl(subMatrixData, false);\n-    } \n-\n-    /**\n-     * Replace the submatrix starting at <code>row, column</code> using data in\n-     * the input <code>subMatrix</code> array. Indexes are 0-based.\n-     * <p> \n-     * Example:<br>\n-     * Starting with <pre>\n-     * 1  2  3  4\n-     * 5  6  7  8\n-     * 9  0  1  2\n-     * </pre>\n-     * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n-     * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n-     * 1  2  3  4\n-     * 5  3  4  8\n-     * 9  5  6  2\n-     * </pre></p>\n-     * \n-     * @param subMatrix  array containing the submatrix replacement data\n-     * @param row  row coordinate of the top, left element to be replaced\n-     * @param column  column coordinate of the top, left element to be replaced\n-     * @throws MatrixIndexException  if subMatrix does not fit into this \n-     *    matrix from element in (row, column) \n-     * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>subMatrix</code> is null\n-     * @since 1.1\n-     */\n-    public void setSubMatrix(double[][] subMatrix, int row, int column) \n-        throws MatrixIndexException {\n-\n-        final int nRows = subMatrix.length;\n-        if (nRows == 0) {\n-            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n-        }\n-\n-        final int nCols = subMatrix[0].length;\n-        if (nCols == 0) {\n-            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n-        }\n-\n-        for (int r = 1; r < nRows; r++) {\n-            if (subMatrix[r].length != nCols) {\n-                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n-            }\n-        }\n-\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\"first {0} rows are not initialized yet\",\n                 throw MathRuntimeException.createIllegalStateException(\"first {0} columns are not initialized yet\",\n                                                                        new Object[] { column });\n             }\n-            data = new double[nRows][nCols];\n-            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n+            data = new double[subMatrix.length][subMatrix[0].length];\n+            for (int i = 0; i < data.length; ++i) {\n+                System.arraycopy(subMatrix[i], 0, data[i], 0, subMatrix[i].length);\n+            }\n         } else {\n-            checkRowIndex(row);\n-            checkColumnIndex(column);\n-            checkRowIndex(nRows + row - 1);\n-            checkColumnIndex(nCols + column - 1);\n-        }\n-\n-        for (int i = 0; i < nRows; i++) {\n-            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n-        } \n-\n-        lu = null;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n-        checkRowIndex(row);\n-        final int ncols = this.getColumnDimension();\n-        final double[][] out = new double[1][ncols]; \n-        System.arraycopy(data[row], 0, out[0], 0, ncols);\n-        return new RealMatrixImpl(out, false);\n-    }\n-    \n-    /** {@inheritDoc} */\n-    public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n-        checkColumnIndex(column);\n-        final int nRows = this.getRowDimension();\n-        final double[][] out = new double[nRows][1]; \n-        for (int row = 0; row < nRows; row++) {\n-            out[row][0] = data[row][column];\n-        }\n-        return new RealMatrixImpl(out, false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector getColumnVector(int column) throws MatrixIndexException {\n-        return new RealVectorImpl(getColumn(column), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector getRowVector(int row) throws MatrixIndexException {\n-        return new RealVectorImpl(getRow(row), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] getRow(int row) throws MatrixIndexException {\n-        checkRowIndex(row);\n-        final int ncols = this.getColumnDimension();\n-        final double[] out = new double[ncols];\n-        System.arraycopy(data[row], 0, out, 0, ncols);\n-        return out;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] getColumn(int col) throws MatrixIndexException {\n-        checkColumnIndex(col);\n-        final int nRows = this.getRowDimension();\n-        final double[] out = new double[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            out[row] = data[row][col];\n-        }\n-        return out;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getEntry(int row, int column)\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(final int row, final int column)\n         throws MatrixIndexException {\n         try {\n             return data[row][column];\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix transpose() {\n-        final int nRows = getRowDimension();\n-        final int nCols = getColumnDimension();\n-        final double[][] outData = new double[nCols][nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            final double[] dataRow = data[row];\n-            for (int col = 0; col < nCols; col++) {\n-                outData[col][row] = dataRow[col];\n-            }\n-        }\n-        return new RealMatrixImpl(outData, false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public RealMatrix inverse() throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n-        }\n-        return lu.getInverse();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double getDeterminant() throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n-        }\n-        return lu.getDeterminant();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public boolean isSquare() {\n-        return (this.getColumnDimension() == this.getRowDimension());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public boolean isSingular() {\n-        if (lu == null) {\n-            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n-       }\n-        return !lu.isNonSingular();\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n     }\n \n     /** {@inheritDoc} */\n     public int getRowDimension() {\n-        return data.length;\n+        return (data == null) ? 0 : data.length;\n     }\n \n     /** {@inheritDoc} */\n     public int getColumnDimension() {\n-        return data[0].length;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getTrace() throws IllegalArgumentException {\n-        if (!isSquare()) {\n-            throw new IllegalArgumentException(\"matrix is not square\");\n-        }\n-        double trace = data[0][0];\n-        for (int i = 1; i < this.getRowDimension(); i++) {\n-            trace += data[i][i];\n-        }\n-        return trace;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] operate(double[] v) throws IllegalArgumentException {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector operate(RealVector v) throws IllegalArgumentException {\n+    public RealVector operate(final RealVector v)\n+        throws IllegalArgumentException {\n         try {\n             return operate((RealVectorImpl) v);\n         } catch (ClassCastException cce) {\n-            final int nRows = this.getRowDimension();\n-            final int nCols = this.getColumnDimension();\n-            if (v.getDimension() != nCols) {\n-                throw new IllegalArgumentException(\"vector has wrong length\");\n-            }\n-            final double[] out = new double[nRows];\n-            for (int row = 0; row < nRows; row++) {\n-                final double[] dataRow = data[row];\n-                double sum = 0;\n-                for (int i = 0; i < nCols; i++) {\n-                    sum += dataRow[i] * v.getEntry(i);\n-                }\n-                out[row] = sum;\n-            }\n-            return new RealVectorImpl(out, false);\n+            return super.operate(v);\n         }\n     }\n \n      * @return this*v\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n-    public RealVectorImpl operate(RealVectorImpl v) throws IllegalArgumentException {\n+    public RealVectorImpl operate(final RealVectorImpl v)\n+        throws IllegalArgumentException {\n         return new RealVectorImpl(operate(v.getDataRef()), false);\n     }\n-\n-    /** {@inheritDoc} */\n-    public double[] preMultiply(double[] v) throws IllegalArgumentException {\n-        final int nRows = this.getRowDimension();\n-        if (v.length != nRows) {\n-            throw new IllegalArgumentException(\"vector has wrong length\");\n-        }\n-        final int nCols = this.getColumnDimension();\n-        final double[] out = new double[nCols];\n-        for (int col = 0; col < nCols; col++) {\n-            double sum = 0;\n-            for (int i = 0; i < nRows; i++) {\n-                sum += data[i][col] * v[i];\n-            }\n-            out[col] = sum;\n-        }\n-        return out;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector preMultiply(RealVector v) throws IllegalArgumentException {\n-        try {\n-            return preMultiply((RealVectorImpl) v);\n-        } catch (ClassCastException cce) {\n-            final int nRows = this.getRowDimension();\n-            if (v.getDimension() != nRows) {\n-                throw new IllegalArgumentException(\"vector has wrong length\");\n-            }\n-            final int nCols = this.getColumnDimension();\n-            final double[] out = new double[nCols];\n-            for (int col = 0; col < nCols; col++) {\n-                double sum = 0;\n-                for (int i = 0; i < nRows; i++) {\n-                    sum += data[i][col] * v.getEntry(i);\n-                }\n-                out[col] = sum;\n-            }\n-            return new RealVectorImpl(out, false);\n-        }\n-    }\n-\n-    /**\n-     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n-     *\n-     * @param v the row vector to premultiply by\n-     * @return v*this\n-     * @throws IllegalArgumentException if rowDimension != v.size()\n-     */\n-    RealVectorImpl preMultiply(RealVectorImpl v) throws IllegalArgumentException {\n-        return new RealVectorImpl(preMultiply(v.getDataRef()), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n-        }\n-        return lu.solve(b);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-        if (lu == null) {\n-            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n-        }\n-        return lu.solve(b);\n-    }\n-\n-    /**\n-     * Computes a new\n-     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n-     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n-     * <p>\n-     * <strong>Implementation Note</strong>:<br>\n-     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n-     * Crout's algorithm</a>, with partial pivoting.</p>\n-     * <p>\n-     * <strong>Usage Note</strong>:<br>\n-     * This method should rarely be invoked directly. Its only use is\n-     * to force recomputation of the LU decomposition when changes have been\n-     * made to the underlying data using direct array references. Changes\n-     * made using setXxx methods will trigger recomputation when needed\n-     * automatically.</p>\n-     *\n-     * @throws InvalidMatrixException if the matrix is non-square or singular.\n-     * @deprecated as of release 2.0, replaced by {@link LUDecomposition}\n-     */\n-    @Deprecated\n-    public void luDecompose() throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n-        }\n-    }\n-\n-    /**\n-     * Get a string representation for this matrix.\n-     * @return a string representation for this matrix\n-     */\n-    public String toString() {\n-        StringBuffer res = new StringBuffer();\n-        res.append(\"RealMatrixImpl{\");\n-        if (data != null) {\n-            for (int i = 0; i < data.length; i++) {\n-                if (i > 0) {\n-                    res.append(\",\");\n-                }\n-                res.append(\"{\");\n-                for (int j = 0; j < data[0].length; j++) {\n-                    if (j > 0) {\n-                        res.append(\",\");\n-                    }\n-                    res.append(data[i][j]);\n-                } \n-                res.append(\"}\");\n-            } \n-        }\n-        res.append(\"}\");\n-        return res.toString();\n-    } \n-    \n-    /**\n-     * Returns true iff <code>object</code> is a \n-     * <code>RealMatrixImpl</code> instance with the same dimensions as this\n-     * and all corresponding matrix entries are equal.\n-     * \n-     * @param object the object to test equality against.\n-     * @return true if object equals this\n-     */\n-    public boolean equals(Object object) {\n-        if (object == this ) {\n-            return true;\n-        }\n-        if (object instanceof RealMatrixImpl == false) {\n-            return false;\n-        }\n-        RealMatrix m = (RealMatrix) object;\n-        final int nRows = getRowDimension();\n-        final int nCols = getColumnDimension();\n-        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n-            return false;\n-        }\n-        for (int row = 0; row < nRows; row++) {\n-            final double[] dataRow = data[row];\n-            for (int col = 0; col < nCols; col++) {\n-                if (dataRow[col] != m.getEntry(row, col)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-    \n-    /**\n-     * Computes a hashcode for the matrix.\n-     * \n-     * @return hashcode for matrix\n-     */\n-    public int hashCode() {\n-        int ret = 7;\n-        final int nRows = getRowDimension();\n-        final int nCols = getColumnDimension();\n-        ret = ret * 31 + nRows;\n-        ret = ret * 31 + nCols;\n-        for (int row = 0; row < nRows; row++) {\n-            final double[] dataRow = data[row];\n-            for (int col = 0; col < nCols; col++) {\n-               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n-                   MathUtils.hash(dataRow[col]);\n-           }\n-        }\n-        return ret;\n-    }\n-\n-    //------------------------ Private methods\n \n     /**\n      * Returns a fresh copy of the underlying data array.\n      *    rectangular\n      * @throws NullPointerException if input array is null\n      */\n-    private void copyIn(double[][] in) {\n+    private void copyIn(final double[][] in) {\n         setSubMatrix(in, 0, 0);\n     }\n \n-    /**\n-     * Check if a row index is valid.\n-     * @param row row index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    private void checkRowIndex(final int row) {\n-        if (row < 0 || row >= getRowDimension()) {\n-            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { row, 0, getRowDimension() - 1});\n-        }\n-    }\n-\n-    /**\n-     * Check if a column index is valid.\n-     * @param column column index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    private void checkColumnIndex(final int column)\n-        throws MatrixIndexException {\n-        if (column < 0 || column >= getColumnDimension()) {\n-            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { column, 0, getColumnDimension() - 1});\n-        }\n-    }\n-\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         m = new RealMatrixImpl(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n             ;\n         }      \n     }", "timestamp": 1228663263, "metainfo": ""}