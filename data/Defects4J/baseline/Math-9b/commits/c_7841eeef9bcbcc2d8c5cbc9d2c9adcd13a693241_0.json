{"sha": "7841eeef9bcbcc2d8c5cbc9d2c9adcd13a693241", "log": "Improved accuracy of Runge-Kutta based step interpolators near step start.  JIRA: MATH-705  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n  * <p>This interpolator allows to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n-\n- * <pre>\n- *   y(t_n + theta h) = y (t_n + h)\n- *                    + (1 - theta) (h/6) [ (-4 theta^2 + 5 theta - 1) y'_1\n- *                                          +(4 theta^2 - 2 theta - 2) (y'_2 + y'_3)\n- *                                          -(4 theta^2 +   theta + 1) y'_4\n+ * <ul>\n+ *   <li>Using reference point at step start:<br>\n+ *   y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub>)\n+ *                    + &theta; (h/6) [  (6 - 9 &theta; + 4 &theta;<sup>2</sup>) y'<sub>1</sub>\n+ *                                     + (    6 &theta; - 4 &theta;<sup>2</sup>) (y'<sub>2</sub> + y'<sub>3</sub>)\n+ *                                     + (   -3 &theta; + 4 &theta;<sup>2</sup>) y'<sub>4</sub>\n+ *                                    ]\n+ *   </li>\n+ *   <li>Using reference point at step end:<br>\n+ *   y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub> + h)\n+ *                    + (1 - &theta;) (h/6) [ (-4 &theta;^2 + 5 &theta; - 1) y'<sub>1</sub>\n+ *                                          +(4 &theta;^2 - 2 &theta; - 2) (y'<sub>2</sub> + y'<sub>3</sub>)\n+ *                                          -(4 &theta;^2 +   &theta; + 1) y'<sub>4</sub>\n  *                                        ]\n- * </pre>\n+ *   </li>\n+ * </ul>\n+ * </p>\n  *\n- * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * where &theta; belongs to [0 ; 1] and where y'<sub>1</sub> to y'<sub>4</sub> are the four\n  * evaluations of the derivatives already computed during the\n  * step.</p>\n  *\n     protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                             final double oneMinusThetaH) {\n \n-        final double fourTheta      = 4 * theta;\n         final double oneMinusTheta  = 1 - theta;\n         final double oneMinus2Theta = 1 - 2 * theta;\n-        final double s             = oneMinusThetaH / 6.0;\n-        final double coeff1        = s * ((-fourTheta + 5) * theta - 1);\n-        final double coeff23       = s * (( fourTheta - 2) * theta - 2);\n-        final double coeff4        = s * ((-fourTheta - 1) * theta - 1);\n         final double coeffDot1     = oneMinusTheta * oneMinus2Theta;\n         final double coeffDot23    = 2 * theta * oneMinusTheta;\n         final double coeffDot4     = -theta * oneMinus2Theta;\n-        for (int i = 0; i < interpolatedState.length; ++i) {\n-            final double yDot1  = yDotK[0][i];\n-            final double yDot23 = yDotK[1][i] + yDotK[2][i];\n-            final double yDot4  = yDotK[3][i];\n-            interpolatedState[i] =\n-                currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;\n-            interpolatedDerivatives[i] =\n-                coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;\n+        if ((previousState != null) && (theta <= 0.5)) {\n+            final double fourTheta2     = 4 * theta * theta;\n+            final double s             = theta * h / 6.0;\n+            final double coeff1        = s * ( 6 - 9 * theta + fourTheta2);\n+            final double coeff23       = s * ( 6 * theta - fourTheta2);\n+            final double coeff4        = s * (-3 * theta + fourTheta2);\n+            for (int i = 0; i < interpolatedState.length; ++i) {\n+                final double yDot1  = yDotK[0][i];\n+                final double yDot23 = yDotK[1][i] + yDotK[2][i];\n+                final double yDot4  = yDotK[3][i];\n+                interpolatedState[i] =\n+                        previousState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;\n+                interpolatedDerivatives[i] =\n+                        coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;\n+            }\n+        } else {\n+            final double fourTheta      = 4 * theta;\n+            final double s             = oneMinusThetaH / 6.0;\n+            final double coeff1        = s * ((-fourTheta + 5) * theta - 1);\n+            final double coeff23       = s * (( fourTheta - 2) * theta - 2);\n+            final double coeff4        = s * ((-fourTheta - 1) * theta - 1);\n+            for (int i = 0; i < interpolatedState.length; ++i) {\n+                final double yDot1  = yDotK[0][i];\n+                final double yDot23 = yDotK[1][i] + yDotK[2][i];\n+                final double yDot4  = yDotK[3][i];\n+                interpolatedState[i] =\n+                        currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;\n+                interpolatedDerivatives[i] =\n+                        coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;\n+            }\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n     final double dot2 = 1 - twoTheta;\n     final double dot3 = theta * (2 - 3 * theta);\n     final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n-    for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] =\n-          currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n-      interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n+    if ((previousState != null) && (theta <= 0.5)) {\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] =\n+                    previousState[i] + theta * h * (v1[i] + eta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n+            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n+        }\n+    } else {\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] =\n+                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n+            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n+        }\n     }\n \n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n  * <p>This interpolator computes dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n+ * <ul>\n+ *   <li>Using reference point at step start:<br>\n+ *     y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub>) + &theta; h y'\n+ *   </li>\n+ *   <li>Using reference point at step end:<br>\n+ *     y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub> + h) - (1-&theta;) h y'\n+ *   </li>\n+ * </ul>\n+ * </p>\n  *\n- * <pre>\n- *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n- * </pre>\n- *\n- * where theta belongs to [0 ; 1] and where y' is the evaluation of\n+ * where &theta; belongs to [0 ; 1] and where y' is the evaluation of\n  * the derivatives already computed during the step.</p>\n  *\n  * @see EulerIntegrator\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH) {\n-\n-    for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n-    }\n-    System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);\n+      if ((previousState != null) && (theta <= 0.5)) {\n+          for (int i = 0; i < interpolatedState.length; ++i) {\n+              interpolatedState[i] = previousState[i] + theta * h * yDotK[0][i];\n+          }\n+          System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);\n+      } else {\n+          for (int i = 0; i < interpolatedState.length; ++i) {\n+              interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n+          }\n+          System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);\n+      }\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n  * <p>This interpolator allows to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n- *\n- * <pre>\n- *   y(t_n + theta h) = y (t_n + h)\n- *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n- *                                        + (1 - theta) (1 + 2 theta) ((2-q) y'_2 + (2+q) y'_3)\n- *                                        + (1 + theta + 4 theta^2) y'_4\n- *                                        ]\n- * </pre>\n- * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n+ * <ul>\n+ *   <li>Using reference point at step start:<br>\n+ *   y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub>)\n+ *                    + &theta; (h/6) [ (6 - 9 &theta; + 4 &theta;<sup>2</sup>) y'<sub>1</sub>\n+ *                                    + (    6 &theta; - 4 &theta;<sup>2</sup>) ((1-1/&radic;2) y'<sub>2</sub> + (1+1/&radic;2)) y'<sub>3</sub>)\n+ *                                    + (  - 3 &theta; + 4 &theta;<sup>2</sup>) y'<sub>4</sub>\n+ *                                    ]\n+ *   </li>\n+ *   <li>Using reference point at step start:<br>\n+ *   y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub> + h)\n+ *                    - (1 - &theta;) (h/6) [ (1 - 5 &theta; + 4 &theta;<sup>2</sup>) y'<sub>1</sub>\n+ *                                          + (2 + 2 &theta; - 4 &theta;<sup>2</sup>) ((1-1/&radic;2) y'<sub>2</sub> + (1+1/&radic;2)) y'<sub>3</sub>)\n+ *                                          + (1 +   &theta; + 4 &theta;<sup>2</sup>) y'<sub>4</sub>\n+ *                                          ]\n+ *   </li>\n+ * </ul>\n+ * </p>\n+ * where &theta; belongs to [0 ; 1] and where y'<sub>1</sub> to y'<sub>4</sub>\n  * are the four evaluations of the derivatives already computed during\n  * the step.</p>\n  *\n   extends RungeKuttaStepInterpolator {\n \n     /** First Gill coefficient. */\n-    private static final double TWO_MINUS_SQRT_2 = 2 - FastMath.sqrt(2.0);\n+    private static final double ONE_MINUS_INV_SQRT_2 = 1 - FastMath.sqrt(0.5);\n \n     /** Second Gill coefficient. */\n-    private static final double TWO_PLUS_SQRT_2 = 2 + FastMath.sqrt(2.0);\n+    private static final double ONE_PLUS_INV_SQRT_2 = 1 + FastMath.sqrt(0.5);\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20111120L;\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH) {\n \n-    final double twoTheta  = 2 * theta;\n-    final double fourTheta = 4 * theta;\n-    final double s         = oneMinusThetaH / 6.0;\n-    final double oMt       = 1 - theta;\n-    final double soMt      = s * oMt;\n-    final double c23       = soMt * (1 + twoTheta);\n-    final double coeff1    = soMt * (1 - fourTheta);\n-    final double coeff2    = c23  * TWO_MINUS_SQRT_2;\n-    final double coeff3    = c23  * TWO_PLUS_SQRT_2;\n-    final double coeff4    = s * (1 + theta * (1 + fourTheta));\n-    final double coeffDot1 = theta * (twoTheta - 3) + 1;\n-    final double cDot23    = theta * oMt;\n-    final double coeffDot2 = cDot23  * TWO_MINUS_SQRT_2;\n-    final double coeffDot3 = cDot23  * TWO_PLUS_SQRT_2;\n-    final double coeffDot4 = theta * (twoTheta - 1);\n+    final double twoTheta   = 2 * theta;\n+    final double fourTheta2 = twoTheta * twoTheta;\n+    final double coeffDot1  = theta * (twoTheta - 3) + 1;\n+    final double cDot23     = twoTheta * (1 - theta);\n+    final double coeffDot2  = cDot23  * ONE_MINUS_INV_SQRT_2;\n+    final double coeffDot3  = cDot23  * ONE_PLUS_INV_SQRT_2;\n+    final double coeffDot4  = theta * (twoTheta - 1);\n \n-    for (int i = 0; i < interpolatedState.length; ++i) {\n-        final double yDot1 = yDotK[0][i];\n-        final double yDot2 = yDotK[1][i];\n-        final double yDot3 = yDotK[2][i];\n-        final double yDot4 = yDotK[3][i];\n-        interpolatedState[i] =\n-            currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n-        interpolatedDerivatives[i] =\n-            coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n-     }\n+    if ((previousState != null) && (theta <= 0.5)) {\n+        final double s         = theta * h / 6.0;\n+        final double c23       = s * (6 * theta - fourTheta2);\n+        final double coeff1    = s * (6 - 9 * theta + fourTheta2);\n+        final double coeff2    = c23  * ONE_MINUS_INV_SQRT_2;\n+        final double coeff3    = c23  * ONE_PLUS_INV_SQRT_2;\n+        final double coeff4    = s * (-3 * theta + fourTheta2);\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot1 = yDotK[0][i];\n+            final double yDot2 = yDotK[1][i];\n+            final double yDot3 = yDotK[2][i];\n+            final double yDot4 = yDotK[3][i];\n+            interpolatedState[i] =\n+                    previousState[i] + coeff1 * yDot1 + coeff2 * yDot2 + coeff3 * yDot3 + coeff4 * yDot4;\n+            interpolatedDerivatives[i] =\n+                    coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+        }\n+    } else {\n+        final double s      = oneMinusThetaH / 6.0;\n+        final double c23    = s * (2 + twoTheta - fourTheta2);\n+        final double coeff1 = s * (1 - 5 * theta + fourTheta2);\n+        final double coeff2 = c23  * ONE_MINUS_INV_SQRT_2;\n+        final double coeff3 = c23  * ONE_PLUS_INV_SQRT_2;\n+        final double coeff4 = s * (1 + theta + fourTheta2);\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot1 = yDotK[0][i];\n+            final double yDot2 = yDotK[1][i];\n+            final double yDot3 = yDotK[2][i];\n+            final double yDot4 = yDotK[3][i];\n+            interpolatedState[i] =\n+                    currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+            interpolatedDerivatives[i] =\n+                    coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+        }\n+    }\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH) {\n \n-    final double theta2 = theta * theta;\n-\n-    final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n-    final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n-    final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n-    final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n-    final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n     final double bDot0 = 1 + theta * (-15.0/2.0 + theta * (16.0 - 10.0 * theta));\n     final double bDot2 = theta * (459.0/16.0 + theta * (-729.0/8.0 + 135.0/2.0 * theta));\n     final double bDot3 = theta * (-44.0 + theta * (152.0 - 120.0 * theta));\n     final double bDot4 = theta * (375.0/16.0 + theta * (-625.0/8.0 + 125.0/2.0 * theta));\n     final double bDot5 = theta * 5.0/8.0 * (2 * theta - 1);\n \n-    for (int i = 0; i < interpolatedState.length; ++i) {\n-        final double yDot0 = yDotK[0][i];\n-        final double yDot2 = yDotK[2][i];\n-        final double yDot3 = yDotK[3][i];\n-        final double yDot4 = yDotK[4][i];\n-        final double yDot5 = yDotK[5][i];\n-        interpolatedState[i] =\n-            currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;\n-        interpolatedDerivatives[i] =\n-            bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;\n+    if ((previousState != null) && (theta <= 0.5)) {\n+        final double hTheta = h * theta;\n+        final double b0 = hTheta * (1.0 + theta * (-15.0/4.0  + theta * (16.0/3.0 - 5.0/2.0 * theta)));\n+        final double b2 = hTheta * (      theta * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+        final double b3 = hTheta * (      theta * (-22.0      + theta * (152.0/3.0  + theta * -30.0)));\n+        final double b4 = hTheta * (      theta * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+        final double b5 = hTheta * (      theta * (-5.0/16.0  + theta *  5.0/12.0));\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot0 = yDotK[0][i];\n+            final double yDot2 = yDotK[2][i];\n+            final double yDot3 = yDotK[3][i];\n+            final double yDot4 = yDotK[4][i];\n+            final double yDot5 = yDotK[5][i];\n+            interpolatedState[i] =\n+                    previousState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;\n+            interpolatedDerivatives[i] =\n+                    bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;\n+        }\n+    } else {\n+        final double theta2 = theta * theta;\n+        final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n+        final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+        final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n+        final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+        final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot0 = yDotK[0][i];\n+            final double yDot2 = yDotK[2][i];\n+            final double yDot3 = yDotK[3][i];\n+            final double yDot4 = yDotK[4][i];\n+            final double yDot5 = yDotK[5][i];\n+            interpolatedState[i] =\n+                    currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;\n+            interpolatedDerivatives[i] =\n+                    bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;\n+        }\n     }\n \n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n  * <p>This interpolator computes dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n+ * <ul>\n+ *   <li>Using reference point at step start:<br>\n+ *   y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub>) + &theta; h [(1 - &theta;) y'<sub>1</sub> + &theta; y'<sub>2</sub>]\n+ *   </li>\n+ *   <li>Using reference point at step end:<br>\n+ *   y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub> + h) + (1-&theta;) h [&theta; y'<sub>1</sub> - (1+&theta;) y'<sub>2</sub>]\n+ *   </li>\n+ * </ul>\n+ * </p>\n  *\n- * <pre>\n- *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n- * </pre>\n- *\n- * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n+ * where &theta; belongs to [0 ; 1] and where y'<sub>1</sub> and y'<sub>2</sub> are the two\n  * evaluations of the derivatives already computed during the\n  * step.</p>\n  *\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH) {\n \n-    final double coeff1    = oneMinusThetaH * theta;\n-    final double coeff2    = oneMinusThetaH * (1.0 + theta);\n     final double coeffDot2 = 2 * theta;\n     final double coeffDot1 = 1 - coeffDot2;\n \n-    for (int i = 0; i < interpolatedState.length; ++i) {\n-      final double yDot1 = yDotK[0][i];\n-      final double yDot2 = yDotK[1][i];\n-      interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;\n-      interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;\n+    if ((previousState != null) && (theta <= 0.5)) {\n+        final double coeff1    = theta * oneMinusThetaH;\n+        final double coeff2    = theta * theta * h;\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot1 = yDotK[0][i];\n+            final double yDot2 = yDotK[1][i];\n+            interpolatedState[i] = previousState[i] + coeff1 * yDot1 + coeff2 * yDot2;\n+            interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;\n+        }\n+    } else {\n+        final double coeff1    = oneMinusThetaH * theta;\n+        final double coeff2    = oneMinusThetaH * (1.0 + theta);\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot1 = yDotK[0][i];\n+            final double yDot2 = yDotK[1][i];\n+            interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;\n+            interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;\n+        }\n     }\n \n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n  * <p>This interpolator allows to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n+ * <ul>\n+ *   <li>Using reference point at step start:<br>\n+ *     y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub>)\n+ *                      + &theta; (h/8) [ (8 - 15 &theta; +  8 &theta;<sup>2</sup>) y'<sub>1</sub>\n+ *                                     +  3 * (15 &theta; - 12 &theta;<sup>2</sup>) y'<sub>2</sub>\n+ *                                     +        3 &theta;                           y'<sub>3</sub>\n+ *                                     +      (-3 &theta; +  4 &theta;<sup>2</sup>) y'<sub>4</sub>\n+ *                                    ]\n+ *   </li>\n+ *   <li>Using reference point at step end:<br>\n+ *     y(t<sub>n</sub> + &theta; h) = y (t<sub>n</sub> + h)\n+ *                      - (1 - &theta;) (h/8) [(1 - 7 &theta; + 8 &theta;<sup>2</sup>) y'<sub>1</sub>\n+ *                                         + 3 (1 +   &theta; - 4 &theta;<sup>2</sup>) y'<sub>2</sub>\n+ *                                         + 3 (1 +   &theta;)                         y'<sub>3</sub>\n+ *                                         +   (1 +   &theta; + 4 &theta;<sup>2</sup>) y'<sub>4</sub>\n+ *                                          ]\n+ *   </li>\n+ * </ul>\n+ * </p>\n  *\n- * <pre>\n- *   y(t_n + theta h) = y (t_n + h)\n- *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n- *                                      + 3 (1 +   theta - 4 theta^2) y'_2\n- *                                      + 3 (1 +   theta)             y'_3\n- *                                      +   (1 +   theta + 4 theta^2) y'_4\n- *                                        ]\n- * </pre>\n- *\n- * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * where &theta; belongs to [0 ; 1] and where y'<sub>1</sub> to y'<sub>4</sub> are the four\n  * evaluations of the derivatives already computed during the\n  * step.</p>\n  *\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH) {\n \n-      final double fourTheta2 = 4 * theta * theta;\n-      final double s          = oneMinusThetaH / 8.0;\n-      final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n-      final double coeff2     = 3 * s * (1 + theta - fourTheta2);\n-      final double coeff3     = 3 * s * (1 + theta);\n-      final double coeff4     = s * (1 + theta + fourTheta2);\n       final double coeffDot3  = 0.75 * theta;\n       final double coeffDot1  = coeffDot3 * (4 * theta - 5) + 1;\n       final double coeffDot2  = coeffDot3 * (5 - 6 * theta);\n       final double coeffDot4  = coeffDot3 * (2 * theta - 1);\n \n-      for (int i = 0; i < interpolatedState.length; ++i) {\n-          final double yDot1 = yDotK[0][i];\n-          final double yDot2 = yDotK[1][i];\n-          final double yDot3 = yDotK[2][i];\n-          final double yDot4 = yDotK[3][i];\n-          interpolatedState[i] =\n-              currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n-          interpolatedDerivatives[i] =\n-              coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+      if ((previousState != null) && (theta <= 0.5)) {\n+          final double s          = theta * h / 8.0;\n+          final double fourTheta2 = 4 * theta * theta;\n+          final double coeff1     = s * (8 - 15 * theta + 2 * fourTheta2);\n+          final double coeff2     = 3 * s * (5 * theta - fourTheta2);\n+          final double coeff3     = 3 * s * theta;\n+          final double coeff4     = s * (-3 * theta + fourTheta2);\n+          for (int i = 0; i < interpolatedState.length; ++i) {\n+              final double yDot1 = yDotK[0][i];\n+              final double yDot2 = yDotK[1][i];\n+              final double yDot3 = yDotK[2][i];\n+              final double yDot4 = yDotK[3][i];\n+              interpolatedState[i] =\n+                      previousState[i] + coeff1 * yDot1 + coeff2 * yDot2 + coeff3 * yDot3 + coeff4 * yDot4;\n+              interpolatedDerivatives[i] =\n+                      coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n \n+          }\n+      } else {\n+          final double s          = oneMinusThetaH / 8.0;\n+          final double fourTheta2 = 4 * theta * theta;\n+          final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n+          final double coeff2     = 3 * s * (1 + theta - fourTheta2);\n+          final double coeff3     = 3 * s * (1 + theta);\n+          final double coeff4     = s * (1 + theta + fourTheta2);\n+          for (int i = 0; i < interpolatedState.length; ++i) {\n+              final double yDot1 = yDotK[0][i];\n+              final double yDot2 = yDotK[1][i];\n+              final double yDot3 = yDotK[2][i];\n+              final double yDot4 = yDotK[3][i];\n+              interpolatedState[i] =\n+                      currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+              interpolatedDerivatives[i] =\n+                      coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+\n+          }\n       }\n \n   }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          Assert.assertTrue(error < FastMath.abs(previousValueError));\n+          Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));\n         }\n         previousValueError = error;\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n     interpolator.storeTime(t0);\n \n     double dt = 1.0;\n+    interpolator.shift();\n     y[0] =  1.0;\n     y[1] =  3.0;\n     y[2] = -4.0;\n     yDot[0][0] = (y[0] - y0[0]) / dt;\n     yDot[0][1] = (y[1] - y0[1]) / dt;\n     yDot[0][2] = (y[2] - y0[2]) / dt;\n-    interpolator.shift();\n     interpolator.storeTime(t0 + dt);\n \n     interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      Assert.assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);\n+        Assert.assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);\n     }\n \n     interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n   @Test\n   public void interpolationInside() {\n \n-    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n     interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,\n                               new EquationsMapper[0]);\n     interpolator.storeTime(0);\n     interpolator.shift();\n+    y[0] =  1.0;\n+    y[1] =  3.0;\n+    y[2] = -4.0;\n     interpolator.storeTime(1);\n \n     interpolator.setInterpolatedTime(0.1);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n \n         double valueError = handler.getMaximalValueError();\n         if (i > 5) {\n-          Assert.assertTrue(valueError < FastMath.abs(previousValueError));\n+          Assert.assertTrue(valueError < 1.01 * FastMath.abs(previousValueError));\n         }\n         previousValueError = valueError;\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          Assert.assertTrue(error < FastMath.abs(previousValueError));\n+          Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));\n         }\n         previousValueError = error;\n ", "timestamp": 1322404320, "metainfo": ""}