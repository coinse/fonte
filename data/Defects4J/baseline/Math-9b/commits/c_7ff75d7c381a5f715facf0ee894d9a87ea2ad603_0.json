{"sha": "7ff75d7c381a5f715facf0ee894d9a87ea2ad603", "log": "MATH-544 Matrix exception classes moved back to package \"linear\". Removed unnecessary \"import\" statements, fixed Javadoc and unit tests and upgraded them to JUnit 4 (MATH-423).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n      *\n      * @param m Matrix to be added.\n      * @return {@code this} + m.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if {@code m} is not the same size as this matrix.\n      */\n     public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m) {\n      *\n      * @param m Matrix to be subtracted.\n      * @return {@code this} + m.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if {@code m} is not the same size as this matrix.\n      */\n     public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m) {\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n      *\n      * @param m Matrix to be added.\n      * @return {@code this} + m.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if {@code m} is not the same size as this matrix.\n      */\n     public Array2DRowRealMatrix add(final Array2DRowRealMatrix m) {\n      *\n      * @param m Matrix to be subtracted.\n      * @return {@code this} - m.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if {@code m} is not the same size as this matrix.\n      */\n     public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m) {\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n  * <ul>\n  *   <li>a {@link #getLT() getLT} method has been added,</li>\n  *   <li>the <code>isspd</code> method has been removed, the constructors of\n- *   implementation classes being expected to throw {@link\n- *   org.apache.commons.math.exception.NonPositiveDefiniteMatrixException}\n+ *   implementation classes being expected to throw {@link NonPositiveDefiniteMatrixException}\n  *   when a matrix cannot be decomposed,</li>\n  *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n  *   <li>the <code>solve</code> method has been replaced by a {@link\n  * @since 2.0\n  */\n public interface CholeskyDecomposition {\n-\n     /**\n      * Returns the matrix L of the decomposition.\n      * <p>L is an lower-triangular matrix</p>\n      * @return a solver\n      */\n     DecompositionSolver getSolver();\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-import org.apache.commons.math.exception.NonSymmetricMatrixException;\n-import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n \n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X such that A &times; X = B\n          * @throws DimensionMismatchException if the matrices dimensions do not match.\n-         * @throws org.apache.commons.math.exception.SingularMatrixException if\n-         * the decomposed matrix is singular.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n--- a/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n      * @return a vector X that minimizes the two norm of A &times; X - B\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the matrices dimensions do not match.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     double[] solve(final double[] b);\n      * @return a vector X that minimizes the two norm of A &times; X - B\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the matrices dimensions do not match.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     RealVector solve(final RealVector b);\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the matrices dimensions do not match.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     RealMatrix solve(final RealMatrix b);\n \n     /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n      * @return inverse matrix\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     RealMatrix getInverse();\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n-import org.apache.commons.math.exception.NonSymmetricMatrixException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n--- a/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n      * @return a vector X that minimizes the two norm of A &times; X - B\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the matrices dimensions do not match.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     T[] solve(final T[] b);\n      * @return a vector X that minimizes the two norm of A &times; X - B\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the matrices dimensions do not match.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     FieldVector<T> solve(final FieldVector<T> b);\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the matrices dimensions do not match.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     FieldMatrix<T> solve(final FieldMatrix<T> b);\n \n     /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n      * @return inverse matrix\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n     FieldMatrix<T> getInverse();\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n      *\n      * @param m Matrix to be added.\n      * @return {@code this} + {@code m}.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if {@code m} is not the same size as this matrix.\n      */\n     FieldMatrix<T> add(FieldMatrix<T> m);\n      *\n      * @param m Matrix to be subtracted.\n      * @return {@code this} - {@code m}.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if {@code m} is not the same size as this matrix.\n      */\n     FieldMatrix<T> subtract(FieldMatrix<T> m);\n     * @param subMatrix Array containing the submatrix replacement data.\n     * @param row Row coordinate of the top-left element to be replaced.\n     * @param column Column coordinate of the top-left element to be replaced.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if {@code subMatrix} does not fit into this matrix from element in\n     * {@code (row, column)}.\n     * @throws org.apache.commons.math.exception.ZeroException if a row or column\n     * of columns as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException\n     * if the specified row index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance row.\n     */\n    void setRowMatrix(int row, FieldMatrix<T> matrix);\n     * number of rows as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException\n     * if the specified column index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance column.\n     */\n    void setColumnMatrix(int column, FieldMatrix<T> matrix);\n     * as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException\n     * if the specified row index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance row.\n     */\n    void setRowVector(int row, FieldVector<T> vector);\n     * as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException\n     * if the specified column index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance column.\n     */\n    void setColumnVector(int column, FieldVector<T> vector);\n      * the instance).\n      * @throws org.apache.commons.math.exception.OutOfRangeException\n      * if the specified row index is invalid.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if the array size does not match one instance row.\n      */\n     void setRow(int row, T[] array);\n      * @param array column array (must have the same number of rows as the instance)\n      * @throws org.apache.commons.math.exception.OutOfRangeException\n      * if the specified column index is invalid.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if the array size does not match one instance column.\n      */\n     void setColumn(int column, T[] array);\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      * @return trace\n-     * @throws org.apache.commons.math.exception.NonSquareMatrixException\n+     * @throws NonSquareMatrixException\n      * if the matrix is not square.\n      */\n     T getTrace();\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixDimensionMismatchException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MultiDimensionMismatchException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when either the number of rows or the number of\n+ * columns of a matrix do not match the expected values.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixDimensionMismatchException extends MultiDimensionMismatchException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -8415396756375798143L;\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param wrongRowDim Wrong row dimension.\n+     * @param wrongColDim Wrong column dimension.\n+     * @param expectedRowDim Expected row dimension.\n+     * @param expectedColDim Expected column dimension.\n+     */\n+    public MatrixDimensionMismatchException(int wrongRowDim,\n+                                            int wrongColDim,\n+                                            int expectedRowDim,\n+                                            int expectedColDim) {\n+        super(LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n+              new Integer[] { wrongRowDim, wrongColDim },\n+              new Integer[] { expectedRowDim, expectedColDim });\n+    }\n+\n+    /**\n+     * @return the expected row dimension.\n+     */\n+    public int getWrongRowDimension() {\n+        return getWrongDimension(0);\n+    }\n+    /**\n+     * @return the expected row dimension.\n+     */\n+    public int getExpectedRowDimension() {\n+        return getExpectedDimension(0);\n+    }\n+    /**\n+     * @return the wrong column dimension.\n+     */\n+    public int getWrongColumnDimension() {\n+        return getWrongDimension(1);\n+    }\n+    /**\n+     * @return the expected column dimension.\n+     */\n+    public int getExpectedColumnDimension() {\n+        return getExpectedDimension(1);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.fraction.BigFraction;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/NonPositiveDefiniteMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a symmetric matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NonPositiveDefiniteMatrixException extends MathIllegalArgumentException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = 1641613838113738061L;\n+    /** Index (diagonal element). */\n+    private final int index;\n+    /** Threshold. */\n+    private final double threshold;\n+\n+    /**\n+     * Construct an exception.\n+     *\n+     * @param index Row (and column) index.\n+     * @param threshold Absolute positivity threshold.\n+     */\n+    public NonPositiveDefiniteMatrixException(int index,\n+                                              double threshold) {\n+        super(LocalizedFormats.NON_POSITIVE_DEFINITE_MATRIX, index, threshold);\n+        this.index = index;\n+        this.threshold = threshold;\n+    }\n+\n+    /**\n+     * @return the row index.\n+     */\n+    public int getRow() {\n+        return index;\n+    }\n+    /**\n+     * @return the column index.\n+     */\n+    public int getColumn() {\n+        return index;\n+    }\n+    /**\n+     * @return the absolute positivity threshold.\n+     */\n+    public double getThreshold() {\n+        return threshold;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a square matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NonSquareMatrixException extends DimensionMismatchException {\n+\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -660069396594485772L;\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param wrong Row dimension.\n+     * @param expected Column dimension.\n+     */\n+    public NonSquareMatrixException(int wrong,\n+                                    int expected) {\n+        super(LocalizedFormats.NON_SQUARE_MATRIX, wrong, expected);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/NonSymmetricMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a symmetric matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NonSymmetricMatrixException extends MathIllegalArgumentException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -7518495577824189882L;\n+    /** Row. */\n+    private final int row;\n+    /** Column. */\n+    private final int column;\n+    /** Threshold. */\n+    private final double threshold;\n+\n+    /**\n+     * Construct an exception.\n+     *\n+     * @param row Row index.\n+     * @param column Column index.\n+     * @param threshold Relative symmetry threshold.\n+     */\n+    public NonSymmetricMatrixException(int row,\n+                                       int column,\n+                                       double threshold) {\n+        super(LocalizedFormats.NON_SYMMETRIC_MATRIX, row, column, threshold);\n+        this.row = row;\n+        this.column = column;\n+        this.threshold = threshold;\n+    }\n+\n+    /**\n+     * @return the row index of the entry.\n+     */\n+    public int getRow() {\n+        return row;\n+    }\n+    /**\n+     * @return the column index of the entry.\n+     */\n+    public int getColumn() {\n+        return column;\n+    }\n+    /**\n+     * @return the relative symmetry threshold.\n+     */\n+    public double getThreshold() {\n+        return threshold;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n      *\n      * @param m Matrix to postmultiply by.\n      * @return {@code this} * {@code m}.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if the number of rows of {@code m} differ from the number of columns\n      * of this matrix.\n      */\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n \n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n     * columns as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n     * specified row index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance row.\n     */\n     void setRowMatrix(int row, RealMatrix matrix);\n     * of rows as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException if\n     * the specified column index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the {@code matrix} dimensions do not match one instance column.\n     */\n     void setColumnMatrix(int column, RealMatrix matrix);\n     * as the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException if\n     * the specified row index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance row.\n     */\n     void setRowVector(int row, RealVector vector);\n     * the instance).\n     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n     * specified column index is invalid.\n-    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * @throws MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance column.\n     */\n     void setColumnVector(int column, RealVector vector);\n      * the instance)\n      * @throws org.apache.commons.math.exception.OutOfRangeException if the\n      * specified row index is invalid.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if the array size does not match one instance row.\n      */\n     void setRow(int row, double[] array);\n      * the instance).\n      * @throws org.apache.commons.math.exception.OutOfRangeException if the\n      * specified column index is invalid.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * @throws MatrixDimensionMismatchException\n      * if the array size does not match one instance column.\n      */\n     void setColumn(int column, double[] array);\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      * @return the trace.\n-     * @throws org.apache.commons.math.exception.NonSquareMatrixException\n+     * @throws NonSquareMatrixException\n      * if the matrix is not square.\n      */\n     double getTrace();\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SingularMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a non-singular matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class SingularMatrixException extends MathIllegalArgumentException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -4206514844735401070L;\n+\n+    /**\n+     * Construct an exception.\n+     */\n+    public SingularMatrixException() {\n+        super(LocalizedFormats.SINGULAR_MATRIX);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n \n      * Only the upper triangular part of the matrix is used.</p>\n      *\n      * @param matrix Symmetrical matrix to transform.\n-     * @exception NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSquareMatrixException if the matrix is not square.\n      */\n     public TriDiagonalTransformer(RealMatrix matrix) {\n         if (!matrix.isSquare()) {\n-            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n         }\n \n         final int m = matrix.getRowDimension();\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n      * Get the covariance matrix of the optimized parameters.\n      *\n      * @return the covariance matrix.\n-     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * @throws org.apache.commons.math.linear.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n-     * @throws org.apache.commons.math.exception.MathUserException if the jacobian\n-     * function throws one.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * jacobian function throws one.\n      */\n     public double[][] getCovariances() {\n         // set up the jacobian\n      * Guessing is covariance-based: It only gives a rough order of magnitude.\n      *\n      * @return errors in optimized parameters\n-     * @throws org.apache.commons.math.exception.SingularMatrixException if\n-     * the covariances matrix cannot be computed.\n+     * @throws org.apache.commons.math.linear.SingularMatrixException\n+     * if the covariances matrix cannot be computed.\n      * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n      * positive, i.e. the number of measurements is less or equal to the number of\n      * parameters.\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n--- a/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n+import org.apache.commons.math.linear.NonPositiveDefiniteMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.util.FastMath;\n     /** Rank of the covariance matrix. */\n     private int rank;\n \n-    /** Simple constructor.\n-     * <p>Build a correlated random vector generator from its mean\n-     * vector and covariance matrix.</p>\n-     * @param mean expected mean values for all components\n-     * @param covariance covariance matrix\n-     * @param small diagonal elements threshold under which  column are\n+    /**\n+     * Builds a correlated random vector generator from its mean\n+     * vector and covariance matrix.\n+     *\n+     * @param mean Expected mean values for all components.\n+     * @param covariance Covariance matrix.\n+     * @param small Diagonal elements threshold under which  column are\n      * considered to be dependent on previous ones and are discarded\n      * @param generator underlying generator for uncorrelated normalized\n-     * components\n-     * @throws NonPositiveDefiniteMatrixException if the\n-     * covariance matrix is not strictly positive definite\n+     * components.\n+     * @throws org.apache.commons.math.linear.NonPositiveDefiniteMatrixException\n+     * if the covariance matrix is not strictly positive definite.\n      * @throws DimensionMismatchException if the mean and covariance\n      * arrays dimensions do not match.\n      */\n \n         this.generator = generator;\n         normalized = new double[rank];\n-\n-    }\n-\n-    /** Simple constructor.\n-     * <p>Build a null mean random correlated vector generator from its\n-     * covariance matrix.</p>\n-     * @param covariance covariance matrix\n-     * @param small diagonal elements threshold under which  column are\n-     * considered to be dependent on previous ones and are discarded\n-     * @param generator underlying generator for uncorrelated normalized\n-     * components\n-     * @exception NonPositiveDefiniteMatrixException if the\n-     * covariance matrix is not strictly positive definite\n+    }\n+\n+    /**\n+     * Builds a null mean random correlated vector generator from its\n+     * covariance matrix.\n+     *\n+     * @param covariance Covariance matrix.\n+     * @param small Diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded.\n+     * @param generator Underlying generator for uncorrelated normalized\n+     * components.\n+     * @throws org.apache.commons.math.linear.NonPositiveDefiniteMatrixException\n+     * if the covariance matrix is not strictly positive definite.\n      */\n     public CorrelatedRandomVectorGenerator(RealMatrix covariance, double small,\n                                            NormalizedRandomGenerator generator) {\n \n         this.generator = generator;\n         normalized = new double[rank];\n-\n     }\n \n     /** Get the underlying normalized components generator.\n      * @param covariance covariance matrix\n      * @param small diagonal elements threshold under which  column are\n      * considered to be dependent on previous ones and are discarded\n-     * @throws NonPositiveDefiniteMatrixException if the\n-     * covariance matrix is not strictly positive definite.\n+     * @throws org.apache.commons.math.linear.NonPositiveDefiniteMatrixException\n+     * if the covariance matrix is not strictly positive definite.\n      */\n     private void decompose(RealMatrix covariance, double small) {\n         int order = covariance.getRowDimension();\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n  */\n package org.apache.commons.math.linear;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n \n  * @version $Revision$ $Date$\n  */\n \n-public final class Array2DRowRealMatrixTest extends TestCase {\n+public final class Array2DRowRealMatrixTest {\n \n     // 3 x 3 identity matrix\n     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    public Array2DRowRealMatrixTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n-        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n-        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n-        assertTrue(\"testData is square\",m.isSquare());\n-        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n-        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n-        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+        Assert.assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        Assert.assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        Assert.assertTrue(\"testData is square\",m.isSquare());\n+        Assert.assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        Assert.assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        Assert.assertTrue(\"testData2 is not square\",!m2.isSquare());\n     }\n \n     /** test copy functions */\n+    @Test\n     public void testCopyFunctions() {\n         Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());\n-        assertEquals(m2,m1);\n+        Assert.assertEquals(m2,m1);\n         Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);\n-        assertEquals(m4,m3);\n+        Assert.assertEquals(m4,m3);\n     }\n \n     /** test add */\n+    @Test\n     public void testAdd() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n         double[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(\"sum entry entry\",\n+                Assert.assertEquals(\"sum entry entry\",\n                     testDataPlusInv[row][col],sumEntries[row][col],\n                         entryTolerance);\n             }\n     }\n \n     /** test add failure */\n+    @Test\n     public void testAddFail() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test norm */\n+    @Test\n     public void testNorm() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n-        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n-        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+        Assert.assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        Assert.assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n     }\n \n     /** test Frobenius norm */\n+    @Test\n     public void testFrobeniusNorm() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n-        assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n-        assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+        Assert.assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        Assert.assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n \n      /** test m-n = m + -n */\n+    @Test\n     public void testPlusMinus() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);\n             m2.scalarMultiply(-1d).add(m),entryTolerance);\n         try {\n             m.subtract(new Array2DRowRealMatrix(testData2));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test multiply */\n-     public void testMultiply() {\n+    @Test\n+    public void testMultiply() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n         Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);\n             m2,entryTolerance);\n         try {\n             m.multiply(new Array2DRowRealMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n     private double[][] d5 = new double[][] {{30},{70}};\n \n+    @Test\n     public void testMultiply2() {\n        RealMatrix m3 = new Array2DRowRealMatrix(d3);\n        RealMatrix m4 = new Array2DRowRealMatrix(d4);\n    }\n \n     /** test trace */\n+    @Test\n     public void testTrace() {\n         RealMatrix m = new Array2DRowRealMatrix(id);\n-        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        Assert.assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n         m = new Array2DRowRealMatrix(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n         }\n     }\n \n     /** test sclarAdd */\n+    @Test\n     public void testScalarAdd() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         TestUtils.assertEquals(\"scalar add\",new Array2DRowRealMatrix(testDataPlus2),\n     }\n \n     /** test operate */\n+    @Test\n     public void testOperate() {\n         RealMatrix m = new Array2DRowRealMatrix(id);\n         TestUtils.assertEquals(\"identity operate\", testVector,\n         m = new Array2DRowRealMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test issue MATH-209 */\n+    @Test\n     public void testMath209() {\n         RealMatrix a = new Array2DRowRealMatrix(new double[][] {\n                 { 1, 2 }, { 3, 4 }, { 5, 6 }\n         }, false);\n         double[] b = a.operate(new double[] { 1, 1 });\n-        assertEquals(a.getRowDimension(), b.length);\n-        assertEquals( 3.0, b[0], 1.0e-12);\n-        assertEquals( 7.0, b[1], 1.0e-12);\n-        assertEquals(11.0, b[2], 1.0e-12);\n+        Assert.assertEquals(a.getRowDimension(), b.length);\n+        Assert.assertEquals( 3.0, b[0], 1.0e-12);\n+        Assert.assertEquals( 7.0, b[1], 1.0e-12);\n+        Assert.assertEquals(11.0, b[2], 1.0e-12);\n     }\n \n     /** test transpose */\n+    @Test\n     public void testTranspose() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n     }\n \n     /** test preMultiply by vector */\n+    @Test\n     public void testPremultiplyVector() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         TestUtils.assertEquals(\"premultiply\", m.preMultiply(testVector),\n         m = new Array2DRowRealMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testPremultiply() {\n         RealMatrix m3 = new Array2DRowRealMatrix(d3);\n         RealMatrix m4 = new Array2DRowRealMatrix(d4);\n                 mInv,entryTolerance);\n         try {\n             m.preMultiply(new Array2DRowRealMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetVectors() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         TestUtils.assertEquals(\"get row\",m.getRow(0),testDataRow1,entryTolerance);\n         TestUtils.assertEquals(\"get col\",m.getColumn(2),testDataCol3,entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetEntry() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n-        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        Assert.assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n     /** test examples in user guide */\n+    @Test\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n         RealMatrix n = new Array2DRowRealMatrix(matrixData2);\n         // Now multiply m by n\n         RealMatrix p = m.multiply(n);\n-        assertEquals(2, p.getRowDimension());\n-        assertEquals(2, p.getColumnDimension());\n+        Assert.assertEquals(2, p.getRowDimension());\n+        Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n         RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n-        assertEquals(2, pInverse.getRowDimension());\n-        assertEquals(2, pInverse.getColumnDimension());\n+        Assert.assertEquals(2, pInverse.getRowDimension());\n+        Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         // Solve example\n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);\n         double[] constants = {1, -2, 1};\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n-        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n-        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n-        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n+        Assert.assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        Assert.assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        Assert.assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n \n     }\n \n     // test submatrix accessors\n+    @Test\n     public void testGetSubMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n                                    boolean mustFail) {\n         try {\n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new Array2DRowRealMatrix(reference), sub);\n+            Assert.assertEquals(new Array2DRowRealMatrix(reference), sub);\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n                                    boolean mustFail) {\n         try {\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new Array2DRowRealMatrix(reference), sub);\n+            Assert.assertEquals(new Array2DRowRealMatrix(reference), sub);\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n         }\n     }\n \n+    @Test\n     public void testCopySubMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n                              new double[1][1] :\n                              new double[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n+            Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n                     new double[1][1] :\n                     new double[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n+            Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n         }\n     }\n \n+    @Test\n     public void testGetRowMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);\n         RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n-        assertEquals(\"Row0\", mRow0,\n+        Assert.assertEquals(\"Row0\", mRow0,\n                 m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3,\n+        Assert.assertEquals(\"Row3\", mRow3,\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n-        assertEquals(mRow3, m.getRowMatrix(0));\n+        Assert.assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetColumnMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);\n         RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n-        assertEquals(\"Column1\", mColumn1,\n+        Assert.assertEquals(\"Column1\", mColumn1,\n                 m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3,\n+        Assert.assertEquals(\"Column3\", mColumn3,\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetRowVector() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n         RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n-        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowVector() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n-        assertEquals(mRow3, m.getRowVector(0));\n+        Assert.assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetColumnVector() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n         RealVector mColumn3 = columnToVector(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n-        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        Assert.assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        Assert.assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnVector() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealVector mColumn3 = columnToVector(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnVector(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnVector(1));\n+        Assert.assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n         return new ArrayRealVector(data, false);\n     }\n \n+    @Test\n     public void testGetRow() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRow() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n-        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRow(0, new double[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetColumn() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         double[] mColumn1 = columnToArray(subColumn1);\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumn() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         double[] mColumn3 = columnToArray(subColumn3);\n-        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumn(0, new double[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n     private void checkArrays(double[] expected, double[] actual) {\n-        assertEquals(expected.length, actual.length);\n+        Assert.assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);\n-        }\n-    }\n-\n+            Assert.assertEquals(expected[i], actual[i], 0);\n+        }\n+    }\n+\n+    @Test\n     public void testEqualsAndHashCode() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();\n         Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();\n-        assertTrue(m.hashCode() != mt.hashCode());\n-        assertEquals(m.hashCode(), m1.hashCode());\n-        assertEquals(m, m);\n-        assertEquals(m, m1);\n-        assertFalse(m.equals(null));\n-        assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));\n-    }\n-\n+        Assert.assertTrue(m.hashCode() != mt.hashCode());\n+        Assert.assertEquals(m.hashCode(), m1.hashCode());\n+        Assert.assertEquals(m, m);\n+        Assert.assertEquals(m, m1);\n+        Assert.assertFalse(m.equals(null));\n+        Assert.assertFalse(m.equals(mt));\n+        Assert.assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));\n+    }\n+\n+    @Test\n     public void testToString() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n-        assertEquals(\"Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+        Assert.assertEquals(\"Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n                 m.toString());\n         m = new Array2DRowRealMatrix();\n-        assertEquals(\"Array2DRowRealMatrix{}\",\n+        Assert.assertEquals(\"Array2DRowRealMatrix{}\",\n                 m.toString());\n     }\n \n+    @Test\n     public void testSetSubMatrix() throws Exception {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         m.setSubMatrix(detData2,1,1);\n         RealMatrix expected = MatrixUtils.createRealMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(detData2,0,0);\n         expected = MatrixUtils.createRealMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(testDataPlus2,0,0);\n         expected = MatrixUtils.createRealMatrix\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n-            fail(\"expecting NullPointerException\");\n+            Assert.fail(\"expecting NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();\n         try {\n             m2.setSubMatrix(testData,0,1);\n-            fail(\"expecting MathIllegalStateException\");\n+            Assert.fail(\"expecting MathIllegalStateException\");\n         } catch (MathIllegalStateException e) {\n             // expected\n         }\n         try {\n             m2.setSubMatrix(testData,1,0);\n-            fail(\"expecting MathIllegalStateException\");\n+            Assert.fail(\"expecting MathIllegalStateException\");\n         } catch (MathIllegalStateException e) {\n             // expected\n         }\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n-\n-    }\n-\n+    }\n+\n+    @Test\n     public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+    }\n+\n+    @Test\n     public void testSerial()  {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n-        assertEquals(m,TestUtils.serializeAndRecover(m));\n+        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n \n         @Override\n         public void visit(int i, int j, double value) {\n             ++count;\n-            assertEquals(i + j / 1024.0, value, 0.0);\n+            Assert.assertEquals(i + j / 1024.0, value, 0.0);\n         }\n         public int getCount() {\n             return count;\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import java.util.Arrays;\n import java.util.Random;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * @version $Revision$ $Date$\n  */\n \n-public final class BlockFieldMatrixTest extends TestCase {\n+public final class BlockFieldMatrixTest {\n \n     // 3 x 3 identity matrix\n     protected Fraction[][] id = {\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    public BlockFieldMatrixTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n-        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n-        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n-        assertTrue(\"testData is square\",m.isSquare());\n-        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n-        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n-        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+        Assert.assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        Assert.assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        Assert.assertTrue(\"testData is square\",m.isSquare());\n+        Assert.assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        Assert.assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        Assert.assertTrue(\"testData2 is not square\",!m2.isSquare());\n     }\n \n     /** test copy functions */\n+    @Test\n     public void testCopyFunctions() {\n         Random r = new Random(66636328996002l);\n         BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);\n         BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());\n-        assertEquals(m1, m2);\n+        Assert.assertEquals(m1, m2);\n         BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());\n-        assertEquals(m3, m4);\n+        Assert.assertEquals(m3, m4);\n     }\n \n     /** test add */\n+    @Test\n     public void testAdd() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n         Fraction[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+                Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n             }\n         }\n     }\n \n     /** test add failure */\n+    @Test\n     public void testAddFail() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n         try {\n             m.add(m2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n      /** test m-n = m + -n */\n+    @Test\n     public void testPlusMinus() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);\n         TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));\n         try {\n             m.subtract(new BlockFieldMatrix<Fraction>(testData2));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test multiply */\n-     public void testMultiply() {\n+    @Test\n+    public void testMultiply() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n         BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(m2.multiply(identity), m2);\n         try {\n             m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testSeveralBlocks() {\n-\n         FieldMatrix<Fraction> m =\n             new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);\n         for (int i = 0; i < m.getRowDimension(); ++i) {\n         }\n \n         FieldMatrix<Fraction> mT = m.transpose();\n-        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n-        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension());\n         for (int i = 0; i < mT.getRowDimension(); ++i) {\n             for (int j = 0; j < mT.getColumnDimension(); ++j) {\n-                assertEquals(m.getEntry(j, i), mT.getEntry(i, j));\n+                Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j));\n             }\n         }\n \n         FieldMatrix<Fraction> mPm = m.add(m);\n         for (int i = 0; i < mPm.getRowDimension(); ++i) {\n             for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n-                assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));\n+                Assert.assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));\n             }\n         }\n \n         FieldMatrix<Fraction> mPmMm = mPm.subtract(m);\n         for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n             for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n-                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));\n+                Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));\n             }\n         }\n \n                 for (int k = 0; k < mT.getColumnDimension(); ++k) {\n                     sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));\n                 }\n-                assertEquals(sum, mTm.getEntry(i, j));\n+                Assert.assertEquals(sum, mTm.getEntry(i, j));\n             }\n         }\n \n                 for (int k = 0; k < m.getColumnDimension(); ++k) {\n                     sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));\n                 }\n-                assertEquals(sum, mmT.getEntry(i, j));\n+                Assert.assertEquals(sum, mmT.getEntry(i, j));\n             }\n         }\n \n         FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);\n         for (int i = 0; i < sub1.getRowDimension(); ++i) {\n             for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n-                assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));\n+                Assert.assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));\n             }\n         }\n \n         FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);\n         for (int i = 0; i < sub2.getRowDimension(); ++i) {\n             for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n-                assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));\n+                Assert.assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));\n             }\n         }\n \n         FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);\n         for (int i = 0; i < sub3.getRowDimension(); ++i) {\n             for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n-                assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));\n+                Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));\n             }\n         }\n \n         FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);\n         for (int i = 0; i < sub4.getRowDimension(); ++i) {\n             for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n-                assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));\n+                Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));\n             }\n         }\n \n     };\n     private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n \n+    @Test\n     public void testMultiply2() {\n        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);\n        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n    }\n \n     /** test trace */\n+    @Test\n     public void testTrace() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n-        assertEquals(new Fraction(3),m.getTrace());\n+        Assert.assertEquals(new Fraction(3),m.getTrace());\n         m = new BlockFieldMatrix<Fraction>(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n         }\n     }\n \n     /** test scalarAdd */\n+    @Test\n     public void testScalarAdd() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),\n     }\n \n     /** test operate */\n+    @Test\n     public void testOperate() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(testVector, m.operate(testVector));\n         m = new BlockFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.operate(testVector);\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testOperateLarge() {\n         int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n         int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n         }\n     }\n \n+    @Test\n     public void testOperatePremultiplyLarge() {\n         int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n         int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n     }\n \n     /** test issue MATH-209 */\n+    @Test\n     public void testMath209() {\n         FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2) },\n                 { new Fraction(5), new Fraction(6) }\n         });\n         Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n-        assertEquals(a.getRowDimension(), b.length);\n-        assertEquals( new Fraction(3), b[0]);\n-        assertEquals( new Fraction(7), b[1]);\n-        assertEquals(new Fraction(11), b[2]);\n+        Assert.assertEquals(a.getRowDimension(), b.length);\n+        Assert.assertEquals( new Fraction(3), b[0]);\n+        Assert.assertEquals( new Fraction(7), b[1]);\n+        Assert.assertEquals(new Fraction(11), b[2]);\n     }\n \n     /** test transpose */\n+    @Test\n     public void testTranspose() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n     }\n \n     /** test preMultiply by vector */\n+    @Test\n     public void testPremultiplyVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n         m = new BlockFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testPremultiply() {\n         FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);\n         FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n         TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n         try {\n             m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetVectors() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.getRow(0), testDataRow1);\n         TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n         try {\n             m.getRow(10);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetEntry() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n-        assertEquals(m.getEntry(0,1),new Fraction(2));\n+        Assert.assertEquals(m.getEntry(0,1),new Fraction(2));\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting OutOfRangeException\");\n+            Assert.fail (\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n     /** test examples in user guide */\n+    @Test\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         Fraction[][] matrixData = {\n         FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);\n         // Now multiply m by n\n         FieldMatrix<Fraction> p = m.multiply(n);\n-        assertEquals(2, p.getRowDimension());\n-        assertEquals(2, p.getColumnDimension());\n+        Assert.assertEquals(2, p.getRowDimension());\n+        Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n         FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n-        assertEquals(2, pInverse.getRowDimension());\n-        assertEquals(2, pInverse.getColumnDimension());\n+        Assert.assertEquals(2, pInverse.getRowDimension());\n+        Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         // Solve example\n         Fraction[][] coefficientsData = {\n         FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);\n         Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n         Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n-        assertEquals(new Fraction(2).multiply(solution[0]).\n+        Assert.assertEquals(new Fraction(2).multiply(solution[0]).\n                      add(new Fraction(3).multiply(solution[1])).\n                      subtract(new Fraction(2).multiply(solution[2])),\n                      constants[0]);\n-        assertEquals(new Fraction(-1).multiply(solution[0]).\n+        Assert.assertEquals(new Fraction(-1).multiply(solution[0]).\n                      add(new Fraction(7).multiply(solution[1])).\n                      add(new Fraction(6).multiply(solution[2])),\n                      constants[1]);\n-        assertEquals(new Fraction(4).multiply(solution[0]).\n+        Assert.assertEquals(new Fraction(4).multiply(solution[0]).\n                      subtract(new Fraction(3).multiply(solution[1])).\n                      subtract(new Fraction(5).multiply(solution[2])),\n                      constants[2]);\n     }\n \n     // test submatrix accessors\n+    @Test\n     public void testGetSubMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             if (reference != null) {\n-                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n+                Assert.fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n                      + \" or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n             if (reference != null) {\n-                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException\");\n+                Assert.fail(\"Expecting OutOfRangeException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n         }\n     }\n \n+    @Test\n     public void testGetSetMatrixLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n-        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+    }\n+\n+    @Test\n     public void testCopySubMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             if (reference != null) {\n-                assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             if (reference != null) {\n-                assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n         }\n     }\n \n+    @Test\n     public void testGetRowMatrix() {\n         FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);\n         FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n-        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n-        assertEquals(mRow3, m.getRowMatrix(0));\n+        Assert.assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetRowMatrixLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (i != 2) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n-        assertEquals(sub, m.getRowMatrix(2));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+\n+    @Test\n     public void testGetColumnMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);\n         FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n-        assertEquals(mColumn1, m.getColumnMatrix(1));\n-        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        Assert.assertEquals(mColumn1, m.getColumnMatrix(1));\n+        Assert.assertEquals(mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetColumnMatrixLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (j != 2) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n-        assertEquals(sub, m.getColumnMatrix(2));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+\n+    @Test\n     public void testGetRowVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n         FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n-        assertEquals(mRow0, m.getRowVector(0));\n-        assertEquals(mRow3, m.getRowVector(3));\n+        Assert.assertEquals(mRow0, m.getRowVector(0));\n+        Assert.assertEquals(mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n-        assertEquals(mRow3, m.getRowVector(0));\n+        Assert.assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetRowVectorLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (i != 2) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n-        assertEquals(sub, m.getRowVector(2));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+\n+    @Test\n     public void testGetColumnVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n-        assertEquals(mColumn1, m.getColumnVector(1));\n-        assertEquals(mColumn3, m.getColumnVector(3));\n+        Assert.assertEquals(mColumn1, m.getColumnVector(1));\n+        Assert.assertEquals(mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnVector(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnVector(1));\n+        Assert.assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetColumnVectorLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (j != 2) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n-        assertEquals(sub, m.getColumnVector(2));\n+        Assert.assertEquals(sub, m.getColumnVector(2));\n \n     }\n \n         return new ArrayFieldVector<Fraction>(data, false);\n     }\n \n+    @Test\n     public void testGetRow() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRow() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n-        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRow(0, new Fraction[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetRowLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (i != 2) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n \n     }\n \n+    @Test\n     public void testGetColumn() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn1 = columnToArray(subColumn1);\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumn() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn3 = columnToArray(subColumn3);\n-        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumn(0, new Fraction[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetColumnLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (j != 2) {\n-                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));\n                 } else {\n-                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));\n                 }\n             }\n         }\n     }\n \n     private void checkArrays(Fraction[] expected, Fraction[] actual) {\n-        assertEquals(expected.length, actual.length);\n+        Assert.assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);\n-        }\n-    }\n-\n+            Assert.assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n+    @Test\n     public void testEqualsAndHashCode() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();\n         BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();\n-        assertTrue(m.hashCode() != mt.hashCode());\n-        assertEquals(m.hashCode(), m1.hashCode());\n-        assertEquals(m, m);\n-        assertEquals(m, m1);\n-        assertFalse(m.equals(null));\n-        assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));\n-    }\n-\n+        Assert.assertTrue(m.hashCode() != mt.hashCode());\n+        Assert.assertEquals(m.hashCode(), m1.hashCode());\n+        Assert.assertEquals(m, m);\n+        Assert.assertEquals(m, m1);\n+        Assert.assertFalse(m.equals(null));\n+        Assert.assertFalse(m.equals(mt));\n+        Assert.assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));\n+    }\n+\n+    @Test\n     public void testToString() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n-        assertEquals(\"BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n-    }\n-\n+        Assert.assertEquals(\"BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+    }\n+\n+    @Test\n     public void testSetSubMatrix() throws Exception {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         m.setSubMatrix(detData2,1,1);\n         FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(detData2,0,0);\n         expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(testDataPlus2,0,0);\n         expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         // javadoc example\n         BlockFieldMatrix<Fraction> matrix =\n                     {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},\n                     {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}\n             });\n-        assertEquals(expected, matrix);\n+        Assert.assertEquals(expected, matrix);\n \n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n-            fail(\"expecting NullPointerException\");\n+            Assert.fail(\"expecting NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n-\n-    }\n-\n+    }\n+\n+    @Test\n     public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+    }\n+\n+    @Test\n     public void testSerial()  {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n-        assertEquals(m,TestUtils.serializeAndRecover(m));\n+        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n     private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n         @Override\n         public void visit(int i, int j, Fraction value) {\n             ++count;\n-            assertEquals(new Fraction(i * 11 + j, 11), value);\n+            Assert.assertEquals(new Fraction(i * 11 + j, 11), value);\n         }\n         public int getCount() {\n             return count;\n         }\n         return m;\n     }\n-\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import java.util.Arrays;\n import java.util.Random;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * @version $Revision$ $Date$\n  */\n \n-public final class BlockRealMatrixTest extends TestCase {\n+public final class BlockRealMatrixTest {\n \n     // 3 x 3 identity matrix\n     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    public BlockRealMatrixTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n-        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n-        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n-        assertTrue(\"testData is square\",m.isSquare());\n-        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n-        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n-        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+        Assert.assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        Assert.assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        Assert.assertTrue(\"testData is square\",m.isSquare());\n+        Assert.assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        Assert.assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        Assert.assertTrue(\"testData2 is not square\",!m2.isSquare());\n     }\n \n     /** test copy functions */\n+    @Test\n     public void testCopyFunctions() {\n         Random r = new Random(66636328996002l);\n         BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);\n         BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());\n-        assertEquals(m1, m2);\n+        Assert.assertEquals(m1, m2);\n         BlockRealMatrix m3 = new BlockRealMatrix(testData);\n         BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());\n-        assertEquals(m3, m4);\n+        Assert.assertEquals(m3, m4);\n     }\n \n     /** test add */\n+    @Test\n     public void testAdd() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n         double[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(\"sum entry entry\",\n+                Assert.assertEquals(\"sum entry entry\",\n                     testDataPlusInv[row][col],sumEntries[row][col],\n                         entryTolerance);\n             }\n     }\n \n     /** test add failure */\n+    @Test\n     public void testAddFail() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test norm */\n+    @Test\n     public void testNorm() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n-        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n-        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+        Assert.assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        Assert.assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n     }\n \n     /** test Frobenius norm */\n+    @Test\n     public void testFrobeniusNorm() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n-        assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n-        assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n-    }\n-\n-     /** test m-n = m + -n */\n+        Assert.assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        Assert.assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+\n+    /** test m-n = m + -n */\n+    @Test\n     public void testPlusMinus() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);\n         assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);\n         try {\n             m.subtract(new BlockRealMatrix(testData2));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test multiply */\n-     public void testMultiply() {\n+    @Test\n+    public void testMultiply() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n         BlockRealMatrix identity = new BlockRealMatrix(id);\n         assertClose(m2.multiply(identity), m2, entryTolerance);\n         try {\n             m.multiply(new BlockRealMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testSeveralBlocks() {\n-\n         RealMatrix m = new BlockRealMatrix(35, 71);\n         for (int i = 0; i < m.getRowDimension(); ++i) {\n             for (int j = 0; j < m.getColumnDimension(); ++j) {\n         }\n \n         RealMatrix mT = m.transpose();\n-        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n-        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension());\n         for (int i = 0; i < mT.getRowDimension(); ++i) {\n             for (int j = 0; j < mT.getColumnDimension(); ++j) {\n-                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);\n+                Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);\n             }\n         }\n \n         RealMatrix mPm = m.add(m);\n         for (int i = 0; i < mPm.getRowDimension(); ++i) {\n             for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n-                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);\n+                Assert.assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);\n             }\n         }\n \n         RealMatrix mPmMm = mPm.subtract(m);\n         for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n             for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n-                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);\n+                Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);\n             }\n         }\n \n                 for (int k = 0; k < mT.getColumnDimension(); ++k) {\n                     sum += (k + i / 1024.0) * (k + j / 1024.0);\n                 }\n-                assertEquals(sum, mTm.getEntry(i, j), 0);\n+                Assert.assertEquals(sum, mTm.getEntry(i, j), 0);\n             }\n         }\n \n                 for (int k = 0; k < m.getColumnDimension(); ++k) {\n                     sum += (i + k / 1024.0) * (j + k / 1024.0);\n                 }\n-                assertEquals(sum, mmT.getEntry(i, j), 0);\n+                Assert.assertEquals(sum, mmT.getEntry(i, j), 0);\n             }\n         }\n \n         RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);\n         for (int i = 0; i < sub1.getRowDimension(); ++i) {\n             for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n-                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);\n+                Assert.assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);\n             }\n         }\n \n         RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);\n         for (int i = 0; i < sub2.getRowDimension(); ++i) {\n             for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n-                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);\n+                Assert.assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);\n             }\n         }\n \n         RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);\n         for (int i = 0; i < sub3.getRowDimension(); ++i) {\n             for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n-                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);\n+                Assert.assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);\n             }\n         }\n \n         RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);\n         for (int i = 0; i < sub4.getRowDimension(); ++i) {\n             for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n-                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);\n+                Assert.assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);\n             }\n         }\n \n     private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n     private double[][] d5 = new double[][] {{30},{70}};\n \n+    @Test\n     public void testMultiply2() {\n-       RealMatrix m3 = new BlockRealMatrix(d3);\n-       RealMatrix m4 = new BlockRealMatrix(d4);\n-       RealMatrix m5 = new BlockRealMatrix(d5);\n-       assertClose(m3.multiply(m4), m5, entryTolerance);\n-   }\n+        RealMatrix m3 = new BlockRealMatrix(d3);\n+        RealMatrix m4 = new BlockRealMatrix(d4);\n+        RealMatrix m5 = new BlockRealMatrix(d5);\n+        assertClose(m3.multiply(m4), m5, entryTolerance);\n+    }\n \n     /** test trace */\n+    @Test\n     public void testTrace() {\n         RealMatrix m = new BlockRealMatrix(id);\n-        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        Assert.assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n         m = new BlockRealMatrix(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n         }\n     }\n \n     /** test scalarAdd */\n+    @Test\n     public void testScalarAdd() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n     }\n \n     /** test operate */\n+    @Test\n     public void testOperate() {\n         RealMatrix m = new BlockRealMatrix(id);\n         assertClose(testVector, m.operate(testVector), entryTolerance);\n         m = new BlockRealMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testOperateLarge() {\n         int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n         int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n         }\n     }\n \n+    @Test\n     public void testOperatePremultiplyLarge() {\n         int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n         int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n     }\n \n     /** test issue MATH-209 */\n+    @Test\n     public void testMath209() {\n         RealMatrix a = new BlockRealMatrix(new double[][] {\n                 { 1, 2 }, { 3, 4 }, { 5, 6 }\n         });\n         double[] b = a.operate(new double[] { 1, 1 });\n-        assertEquals(a.getRowDimension(), b.length);\n-        assertEquals( 3.0, b[0], 1.0e-12);\n-        assertEquals( 7.0, b[1], 1.0e-12);\n-        assertEquals(11.0, b[2], 1.0e-12);\n+        Assert.assertEquals(a.getRowDimension(), b.length);\n+        Assert.assertEquals( 3.0, b[0], 1.0e-12);\n+        Assert.assertEquals( 7.0, b[1], 1.0e-12);\n+        Assert.assertEquals(11.0, b[2], 1.0e-12);\n     }\n \n     /** test transpose */\n+    @Test\n     public void testTranspose() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n     }\n \n     /** test preMultiply by vector */\n+    @Test\n     public void testPremultiplyVector() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(m.preMultiply(testVector), preMultTest, normTolerance);\n         m = new BlockRealMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testPremultiply() {\n         RealMatrix m3 = new BlockRealMatrix(d3);\n         RealMatrix m4 = new BlockRealMatrix(d4);\n         assertClose(identity.preMultiply(mInv), mInv, entryTolerance);\n         try {\n             m.preMultiply(new BlockRealMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetVectors() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(m.getRow(0), testDataRow1, entryTolerance);\n         assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetEntry() {\n         RealMatrix m = new BlockRealMatrix(testData);\n-        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        Assert.assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting OutOfRangeException\");\n+            Assert.fail (\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n     /** test examples in user guide */\n+    @Test\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n         RealMatrix n = new BlockRealMatrix(matrixData2);\n         // Now multiply m by n\n         RealMatrix p = m.multiply(n);\n-        assertEquals(2, p.getRowDimension());\n-        assertEquals(2, p.getColumnDimension());\n+        Assert.assertEquals(2, p.getRowDimension());\n+        Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n         RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n-        assertEquals(2, pInverse.getRowDimension());\n-        assertEquals(2, pInverse.getColumnDimension());\n+        Assert.assertEquals(2, pInverse.getRowDimension());\n+        Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         // Solve example\n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new BlockRealMatrix(coefficientsData);\n         double[] constants = {1, -2, 1};\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n-        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n-        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n-        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n+        Assert.assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        Assert.assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        Assert.assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n \n     }\n \n     // test submatrix accessors\n+    @Test\n     public void testGetSubMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n         try {\n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             if (reference != null) {\n-                assertEquals(new BlockRealMatrix(reference), sub);\n+                Assert.assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n         try {\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n             if (reference != null) {\n-                assertEquals(new BlockRealMatrix(reference), sub);\n+                Assert.assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n         }\n     }\n \n+    @Test\n     public void testGetSetMatrixLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n-        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    @Test\n     public void testCopySubMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n                              new double[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             if (reference != null) {\n-                assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+                Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n                     new double[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             if (reference != null) {\n-                assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+                Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n         }\n     }\n \n+    @Test\n     public void testGetRowMatrix() {\n         RealMatrix m     = new BlockRealMatrix(subTestData);\n         RealMatrix mRow0 = new BlockRealMatrix(subRow0);\n         RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n-        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n-        assertEquals(mRow3, m.getRowMatrix(0));\n+        Assert.assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetRowMatrixLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (i != 2) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n-        assertEquals(sub, m.getRowMatrix(2));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getRowMatrix(2));\n+    }\n+\n+    @Test\n     public void testGetColumnMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);\n         RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n-        assertEquals(mColumn1, m.getColumnMatrix(1));\n-        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        Assert.assertEquals(mColumn1, m.getColumnMatrix(1));\n+        Assert.assertEquals(mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetColumnMatrixLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (j != 2) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n-        assertEquals(sub, m.getColumnMatrix(2));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+\n+    @Test\n     public void testGetRowVector() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n         RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n-        assertEquals(mRow0, m.getRowVector(0));\n-        assertEquals(mRow3, m.getRowVector(3));\n+        Assert.assertEquals(mRow0, m.getRowVector(0));\n+        Assert.assertEquals(mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowVector() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n-        assertEquals(mRow3, m.getRowVector(0));\n+        Assert.assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetRowVectorLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (i != 2) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n-        assertEquals(sub, m.getRowVector(2));\n-\n-    }\n-\n+        Assert.assertEquals(sub, m.getRowVector(2));\n+    }\n+\n+    @Test\n     public void testGetColumnVector() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n         RealVector mColumn3 = columnToVector(subColumn3);\n-        assertEquals(mColumn1, m.getColumnVector(1));\n-        assertEquals(mColumn3, m.getColumnVector(3));\n+        Assert.assertEquals(mColumn1, m.getColumnVector(1));\n+        Assert.assertEquals(mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnVector() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mColumn3 = columnToVector(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnVector(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnVector(1));\n+        Assert.assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetColumnVectorLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (j != 2) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n-        assertEquals(sub, m.getColumnVector(2));\n-\n+        Assert.assertEquals(sub, m.getColumnVector(2));\n     }\n \n     private RealVector columnToVector(double[][] column) {\n         return new ArrayRealVector(data, false);\n     }\n \n+    @Test\n     public void testGetRow() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRow() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n-        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRow(0, new double[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetRowLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (i != 2) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n         checkArrays(sub, m.getRow(2));\n-\n-    }\n-\n+    }\n+\n+    @Test\n     public void testGetColumn() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         double[] mColumn1 = columnToArray(subColumn1);\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumn() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         double[] mColumn3 = columnToArray(subColumn3);\n-        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumn(0, new double[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetSetColumnLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < n; ++j) {\n                 if (j != 2) {\n-                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);\n                 } else {\n-                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);\n                 }\n             }\n         }\n         checkArrays(sub, m.getColumn(2));\n-\n     }\n \n     private double[] columnToArray(double[][] column) {\n     }\n \n     private void checkArrays(double[] expected, double[] actual) {\n-        assertEquals(expected.length, actual.length);\n+        Assert.assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);\n-        }\n-    }\n-\n+            Assert.assertEquals(expected[i], actual[i], 0);\n+        }\n+    }\n+\n+    @Test\n     public void testEqualsAndHashCode() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m1 = m.copy();\n         BlockRealMatrix mt = m.transpose();\n-        assertTrue(m.hashCode() != mt.hashCode());\n-        assertEquals(m.hashCode(), m1.hashCode());\n-        assertEquals(m, m);\n-        assertEquals(m, m1);\n-        assertFalse(m.equals(null));\n-        assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new BlockRealMatrix(bigSingular)));\n-    }\n-\n+        Assert.assertTrue(m.hashCode() != mt.hashCode());\n+        Assert.assertEquals(m.hashCode(), m1.hashCode());\n+        Assert.assertEquals(m, m);\n+        Assert.assertEquals(m, m1);\n+        Assert.assertFalse(m.equals(null));\n+        Assert.assertFalse(m.equals(mt));\n+        Assert.assertFalse(m.equals(new BlockRealMatrix(bigSingular)));\n+    }\n+\n+    @Test\n     public void testToString() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n-        assertEquals(\"BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+        Assert.assertEquals(\"BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n                 m.toString());\n     }\n \n+    @Test\n     public void testSetSubMatrix() throws Exception {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         m.setSubMatrix(detData2,1,1);\n         RealMatrix expected = new BlockRealMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(detData2,0,0);\n         expected = new BlockRealMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(testDataPlus2,0,0);\n         expected = new BlockRealMatrix\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         // javadoc example\n         BlockRealMatrix matrix = new BlockRealMatrix\n         matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n         expected = new BlockRealMatrix\n             (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n-        assertEquals(expected, matrix);\n+        Assert.assertEquals(expected, matrix);\n \n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n-            fail(\"expecting NullPointerException\");\n+            Assert.fail(\"expecting NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n-\n-    }\n-\n+    }\n+\n+    @Test\n     public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);\n-            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);\n+            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);\n-            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(0.0, m.getEntry(0, j), 0);\n+            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+\n+    @Test\n     public void testSerial()  {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n-        assertEquals(m,TestUtils.serializeAndRecover(m));\n+        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n     private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n         @Override\n         public void visit(int i, int j, double value) {\n             ++count;\n-            assertEquals(i + j / 1024.0, value, 0.0);\n+            Assert.assertEquals(i + j / 1024.0, value, 0.0);\n         }\n         public int getCount() {\n             return count;\n \n     /** verifies that two matrices are close (1-norm) */\n     protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {\n-        assertTrue(m.subtract(n).getNorm() < tolerance);\n+        Assert.assertTrue(m.subtract(n).getNorm() < tolerance);\n     }\n \n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(double[] m, double[] n, double tolerance) {\n         if (m.length != n.length) {\n-            fail(\"vectors not same length\");\n+            Assert.fail(\"vectors not same length\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(m[i], n[i], tolerance);\n+            Assert.assertEquals(m[i], n[i], tolerance);\n         }\n     }\n \n         }\n         return m;\n     }\n-\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n-import org.apache.commons.math.exception.NonSymmetricMatrixException;\n import org.junit.Test;\n+import org.junit.Assert;\n \n public class CholeskyDecompositionImplTest {\n \n     public void testDimensions() {\n         CholeskyDecomposition llt =\n             new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n-        assertEquals(testData.length, llt.getL().getRowDimension());\n-        assertEquals(testData.length, llt.getL().getColumnDimension());\n-        assertEquals(testData.length, llt.getLT().getRowDimension());\n-        assertEquals(testData.length, llt.getLT().getColumnDimension());\n+        Assert.assertEquals(testData.length, llt.getL().getRowDimension());\n+        Assert.assertEquals(testData.length, llt.getL().getColumnDimension());\n+        Assert.assertEquals(testData.length, llt.getLT().getRowDimension());\n+        Assert.assertEquals(testData.length, llt.getLT().getColumnDimension());\n     }\n \n     /** test non-square matrix */\n         RealMatrix l  = llt.getL();\n         RealMatrix lt = llt.getLT();\n         double norm = l.multiply(lt).subtract(matrix).getNorm();\n-        assertEquals(0, norm, 1.0e-15);\n+        Assert.assertEquals(0, norm, 1.0e-15);\n     }\n \n     /** test that L is lower triangular */\n         RealMatrix l = new CholeskyDecompositionImpl(matrix).getL();\n         for (int i = 0; i < l.getRowDimension(); i++) {\n             for (int j = i + 1; j < l.getColumnDimension(); j++) {\n-                assertEquals(0.0, l.getEntry(i, j), 0.0);\n+                Assert.assertEquals(0.0, l.getEntry(i, j), 0.0);\n             }\n         }\n     }\n         RealMatrix l  = llt.getL();\n         RealMatrix lt = llt.getLT();\n         double norm = l.subtract(lt.transpose()).getNorm();\n-        assertEquals(0, norm, 1.0e-15);\n+        Assert.assertEquals(0, norm, 1.0e-15);\n     }\n \n     /** test matrices values */\n \n         // check values against known references\n         RealMatrix l = llt.getL();\n-        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n         RealMatrix lt = llt.getLT();\n-        assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);\n \n         // check the same cached instance is returned the second time\n-        assertTrue(l  == llt.getL());\n-        assertTrue(lt == llt.getLT());\n-\n+        Assert.assertTrue(l  == llt.getL());\n+        Assert.assertTrue(lt == llt.getLT());\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n import java.util.Random;\n \n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n-public class EigenSolverTest extends TestCase {\n-\n-    private double[] refValues;\n-    private RealMatrix matrix;\n-\n-    public EigenSolverTest(String name) {\n-        super(name);\n-    }\n+public class EigenSolverTest {\n \n     /** test non invertible matrix */\n+    @Test\n     public void testNonInvertible() {\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n             EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });\n         DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n-        assertFalse(es.isNonSingular());\n+        Assert.assertFalse(es.isNonSingular());\n         try {\n             es.getInverse();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n     }\n \n     /** test invertible matrix */\n+    @Test\n     public void testInvertible() {\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n             EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n         DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n-        assertTrue(es.isNonSingular());\n+        Assert.assertTrue(es.isNonSingular());\n         RealMatrix inverse = es.getInverse();\n         RealMatrix error =\n             m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));\n-        assertEquals(0, error.getNorm(), 4.0e-15);\n+        Assert.assertEquals(0, error.getNorm(), 4.0e-15);\n     }\n \n     /** test solve dimension errors */\n+    @Test\n     public void testSolveDimensionErrors() {\n+        final double[] refValues = new double[] {\n+            2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        final RealMatrix matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);\n+\n         DecompositionSolver es = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             es.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             es.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n \n     /** test solve */\n+    @Test\n     public void testSolve() {\n         RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {\n                 { 91,  5, 29, 32, 40, 14 },\n \n         // using RealMatrix\n         RealMatrix solution=es.solve(b);\n-        assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);\n+        Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          new ArrayRealVector(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n \n         // using Array2DRowRealMatrix\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             ArrayRealVectorTest.RealVectorTestImpl v =\n                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n-\n     }\n-\n-    @Override\n-    public void setUp() {\n-        refValues = new double[] {\n-                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n-        };\n-        matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);\n-    }\n-\n-    @Override\n-    public void tearDown() {\n-        refValues = null;\n-        matrix    = null;\n-    }\n-\n }\n--- a/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-\n-public class FieldLUDecompositionImplTest extends TestCase {\n+\n+public class FieldLUDecompositionImplTest {\n     private Fraction[][] testData = {\n             { new Fraction(1), new Fraction(2), new Fraction(3)},\n             { new Fraction(2), new Fraction(5), new Fraction(3)},\n             { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }\n     }; // 4th row = 1st + 2nd\n \n-    public FieldLUDecompositionImplTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);\n-        assertEquals(testData.length, LU.getL().getRowDimension());\n-        assertEquals(testData.length, LU.getL().getColumnDimension());\n-        assertEquals(testData.length, LU.getU().getRowDimension());\n-        assertEquals(testData.length, LU.getU().getColumnDimension());\n-        assertEquals(testData.length, LU.getP().getRowDimension());\n-        assertEquals(testData.length, LU.getP().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getL().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getL().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getColumnDimension());\n \n     }\n \n     /** test non-square matrix */\n+    @Test\n     public void testNonSquare() {\n         try {\n             new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                     { Fraction.ZERO, Fraction.ZERO },\n                     { Fraction.ZERO, Fraction.ZERO }\n             }));\n-            fail(\"Expected NonSquareMatrixException\");\n+            Assert.fail(\"Expected NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ime) {\n             // expected behavior\n         }\n     }\n \n     /** test PA = LU */\n+    @Test\n     public void testPAEqualLU() {\n         FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n \n         matrix = new Array2DRowFieldMatrix<Fraction>(singular);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n-        assertFalse(lu.getSolver().isNonSingular());\n-        assertNull(lu.getL());\n-        assertNull(lu.getU());\n-        assertNull(lu.getP());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n \n         matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n-        assertFalse(lu.getSolver().isNonSingular());\n-        assertNull(lu.getL());\n-        assertNull(lu.getU());\n-        assertNull(lu.getP());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n \n     }\n \n     /** test that L is lower triangular with unit diagonal */\n+    @Test\n     public void testLLowerTriangular() {\n         FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();\n         for (int i = 0; i < l.getRowDimension(); i++) {\n-            assertEquals(Fraction.ONE, l.getEntry(i, i));\n+            Assert.assertEquals(Fraction.ONE, l.getEntry(i, i));\n             for (int j = i + 1; j < l.getColumnDimension(); j++) {\n-                assertEquals(Fraction.ZERO, l.getEntry(i, j));\n+                Assert.assertEquals(Fraction.ZERO, l.getEntry(i, j));\n             }\n         }\n     }\n \n     /** test that U is upper triangular */\n+    @Test\n     public void testUUpperTriangular() {\n         FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();\n         for (int i = 0; i < u.getRowDimension(); i++) {\n             for (int j = 0; j < i; j++) {\n-                assertEquals(Fraction.ZERO, u.getEntry(i, j));\n+                Assert.assertEquals(Fraction.ZERO, u.getEntry(i, j));\n             }\n         }\n     }\n \n     /** test that P is a permutation matrix */\n+    @Test\n     public void testPPermutation() {\n         FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();\n                     ++otherCount;\n                 }\n             }\n-            assertEquals(p.getColumnDimension() - 1, zeroCount);\n-            assertEquals(1, oneCount);\n-            assertEquals(0, otherCount);\n+            Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n         }\n \n         for (int j = 0; j < p.getColumnDimension(); j++) {\n                     ++otherCount;\n                 }\n             }\n-            assertEquals(p.getRowDimension() - 1, zeroCount);\n-            assertEquals(1, oneCount);\n-            assertEquals(0, otherCount);\n+            Assert.assertEquals(p.getRowDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n         }\n \n     }\n \n \n     /** test singular */\n+    @Test\n     public void testSingular() {\n         FieldLUDecomposition<Fraction> lu =\n             new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n-        assertTrue(lu.getSolver().isNonSingular());\n+        Assert.assertTrue(lu.getSolver().isNonSingular());\n         lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));\n-        assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n         lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n-        assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n     }\n \n     /** test matrices values */\n+    @Test\n     public void testMatricesValues1() {\n        FieldLUDecomposition<Fraction> lu =\n             new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n         TestUtils.assertEquals(pRef, p);\n         int[] pivot = lu.getPivot();\n         for (int i = 0; i < pivotRef.length; ++i) {\n-            assertEquals(pivotRef[i], pivot[i]);\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n         }\n \n         // check the same cached instance is returned the second time\n-        assertTrue(l == lu.getL());\n-        assertTrue(u == lu.getU());\n-        assertTrue(p == lu.getP());\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n \n     }\n \n     /** test matrices values */\n+    @Test\n     public void testMatricesValues2() {\n        FieldLUDecomposition<Fraction> lu =\n             new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));\n         TestUtils.assertEquals(pRef, p);\n         int[] pivot = lu.getPivot();\n         for (int i = 0; i < pivotRef.length; ++i) {\n-            assertEquals(pivotRef[i], pivot[i]);\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n         }\n \n         // check the same cached instance is returned the second time\n-        assertTrue(l == lu.getL());\n-        assertTrue(u == lu.getU());\n-        assertTrue(p == lu.getP());\n-\n-    }\n-\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n  */\n package org.apache.commons.math.linear;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * @version $Revision$ $Date$\n  */\n \n-public final class FieldMatrixImplTest extends TestCase {\n+public final class FieldMatrixImplTest {\n \n     // 3 x 3 identity matrix\n     protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    public FieldMatrixImplTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n-        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n-        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n-        assertTrue(\"testData is square\",m.isSquare());\n-        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n-        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n-        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+        Assert.assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        Assert.assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        Assert.assertTrue(\"testData is square\",m.isSquare());\n+        Assert.assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        Assert.assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        Assert.assertTrue(\"testData2 is not square\",!m2.isSquare());\n     }\n \n     /** test copy functions */\n+    @Test\n     public void testCopyFunctions() {\n         Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData());\n-        assertEquals(m2,m1);\n+        Assert.assertEquals(m2,m1);\n         Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);\n-        assertEquals(m4,m3);\n+        Assert.assertEquals(m4,m3);\n     }\n \n     /** test add */\n+    @Test\n     public void testAdd() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n         Fraction[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+                Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n             }\n         }\n     }\n \n     /** test add failure */\n+    @Test\n     public void testAddFail() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n         try {\n             m.add(m2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n      /** test m-n = m + -n */\n+    @Test\n     public void testPlusMinus() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n         TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));\n         try {\n             m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test multiply */\n+    @Test\n      public void testMultiply() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n         TestUtils.assertEquals(m2.multiply(identity), m2);\n         try {\n             m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};\n     private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n \n+    @Test\n     public void testMultiply2() {\n        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);\n        FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n    }\n \n     /** test trace */\n+    @Test\n     public void testTrace() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n-        assertEquals(\"identity trace\",new Fraction(3),m.getTrace());\n+        Assert.assertEquals(\"identity trace\",new Fraction(3),m.getTrace());\n         m = new Array2DRowFieldMatrix<Fraction>(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n         }\n     }\n \n     /** test sclarAdd */\n+    @Test\n     public void testScalarAdd() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));\n     }\n \n     /** test operate */\n+    @Test\n     public void testOperate() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(testVector, m.operate(testVector));\n         m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.operate(testVector);\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test issue MATH-209 */\n+    @Test\n     public void testMath209() {\n         FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }\n         }, false);\n         Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n-        assertEquals(a.getRowDimension(), b.length);\n-        assertEquals( new Fraction(3), b[0]);\n-        assertEquals( new Fraction(7), b[1]);\n-        assertEquals(new Fraction(11), b[2]);\n+        Assert.assertEquals(a.getRowDimension(), b.length);\n+        Assert.assertEquals( new Fraction(3), b[0]);\n+        Assert.assertEquals( new Fraction(7), b[1]);\n+        Assert.assertEquals(new Fraction(11), b[2]);\n     }\n \n     /** test transpose */\n+    @Test\n     public void testTranspose() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n     }\n \n     /** test preMultiply by vector */\n+    @Test\n     public void testPremultiplyVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n         m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testPremultiply() {\n         FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);\n         FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n         TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n         try {\n             m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetVectors() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.getRow(0), testDataRow1);\n         TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n         try {\n             m.getRow(10);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetEntry() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n-        assertEquals(\"get entry\", m.getEntry(0,1), new Fraction(2));\n+        Assert.assertEquals(\"get entry\", m.getEntry(0,1), new Fraction(2));\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting OutOfRangeException\");\n+            Assert.fail (\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n     /** test examples in user guide */\n+    @Test\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         Fraction[][] matrixData = {\n         FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2);\n         // Now multiply m by n\n         FieldMatrix<Fraction> p = m.multiply(n);\n-        assertEquals(2, p.getRowDimension());\n-        assertEquals(2, p.getColumnDimension());\n+        Assert.assertEquals(2, p.getRowDimension());\n+        Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n         FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n-        assertEquals(2, pInverse.getRowDimension());\n-        assertEquals(2, pInverse.getColumnDimension());\n+        Assert.assertEquals(2, pInverse.getRowDimension());\n+        Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         // Solve example\n         Fraction[][] coefficientsData = {\n         FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData);\n         Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n         Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n-        assertEquals(new Fraction(2).multiply(solution[0]).\n+        Assert.assertEquals(new Fraction(2).multiply(solution[0]).\n                      add(new Fraction(3).multiply(solution[1])).\n                      subtract(new Fraction(2).multiply(solution[2])), constants[0]);\n-        assertEquals(new Fraction(-1).multiply(solution[0]).\n+        Assert.assertEquals(new Fraction(-1).multiply(solution[0]).\n                      add(new Fraction(7).multiply(solution[1])).\n                      add(new Fraction(6).multiply(solution[2])), constants[1]);\n-        assertEquals(new Fraction(4).multiply(solution[0]).\n+        Assert.assertEquals(new Fraction(4).multiply(solution[0]).\n                      subtract(new Fraction(3).multiply(solution[1])).\n                      subtract(new Fraction(5).multiply(solution[2])), constants[2]);\n \n     }\n \n     // test submatrix accessors\n+    @Test\n     public void testGetSubMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             if (reference != null) {\n-                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n+                Assert.fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n                      + \" or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n             if (reference != null) {\n-                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n+                Assert.fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n                      + \" or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n         }\n     }\n \n+    @Test\n     public void testCopySubMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             if (reference != null) {\n-                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             if (reference != null) {\n-                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+                Assert.fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n         }\n     }\n \n+    @Test\n     public void testGetRowMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);\n         FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n-        assertEquals(\"Row0\", mRow0,\n+        Assert.assertEquals(\"Row0\", mRow0,\n                 m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3,\n+        Assert.assertEquals(\"Row3\", mRow3,\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n-        assertEquals(mRow3, m.getRowMatrix(0));\n+        Assert.assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetColumnMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);\n         FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n-        assertEquals(\"Column1\", mColumn1,\n+        Assert.assertEquals(\"Column1\", mColumn1,\n                 m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3,\n+        Assert.assertEquals(\"Column3\", mColumn3,\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetRowVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n         FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n-        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRowVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n-        assertNotSame(mRow3, m.getRowMatrix(0));\n+        Assert.assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n-        assertEquals(mRow3, m.getRowVector(0));\n+        Assert.assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetColumnVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n-        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        Assert.assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        Assert.assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumnVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n-        assertNotSame(mColumn3, m.getColumnVector(1));\n+        Assert.assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n-        assertEquals(mColumn3, m.getColumnVector(1));\n+        Assert.assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n         return new ArrayFieldVector<Fraction>(data, false);\n     }\n \n+    @Test\n     public void testGetRow() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetRow() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n-        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setRow(0, new Fraction[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGetColumn() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn1 = columnToArray(subColumn1);\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testSetColumn() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn3 = columnToArray(subColumn3);\n-        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.setColumn(0, new Fraction[5]);\n-            fail(\"Expecting MatrixDimensionMismatchException\");\n+            Assert.fail(\"Expecting MatrixDimensionMismatchException\");\n         } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n \n     private void checkArrays(Fraction[] expected, Fraction[] actual) {\n-        assertEquals(expected.length, actual.length);\n+        Assert.assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);\n-        }\n-    }\n-\n+            Assert.assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n+    @Test\n     public void testEqualsAndHashCode() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();\n         Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose();\n-        assertTrue(m.hashCode() != mt.hashCode());\n-        assertEquals(m.hashCode(), m1.hashCode());\n-        assertEquals(m, m);\n-        assertEquals(m, m1);\n-        assertFalse(m.equals(null));\n-        assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));\n-    }\n-\n+        Assert.assertTrue(m.hashCode() != mt.hashCode());\n+        Assert.assertEquals(m.hashCode(), m1.hashCode());\n+        Assert.assertEquals(m, m);\n+        Assert.assertEquals(m, m1);\n+        Assert.assertFalse(m.equals(null));\n+        Assert.assertFalse(m.equals(mt));\n+        Assert.assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));\n+    }\n+\n+    @Test\n     public void testToString() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n-        assertEquals(\"Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+        Assert.assertEquals(\"Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n-        assertEquals(\"Array2DRowFieldMatrix{}\", m.toString());\n-    }\n-\n+        Assert.assertEquals(\"Array2DRowFieldMatrix{}\", m.toString());\n+    }\n+\n+    @Test\n     public void testSetSubMatrix() throws Exception {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         m.setSubMatrix(detData2,1,1);\n                     {new Fraction(2),new Fraction(1),new Fraction(3)},\n                     {new Fraction(1),new Fraction(2),new Fraction(4)}\n              });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(detData2,0,0);\n         expected = new Array2DRowFieldMatrix<Fraction>\n                     {new Fraction(2),new Fraction(4),new Fraction(3)},\n                     {new Fraction(1),new Fraction(2),new Fraction(4)}\n              });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(testDataPlus2,0,0);\n         expected = new Array2DRowFieldMatrix<Fraction>\n                     {new Fraction(4),new Fraction(7),new Fraction(5)},\n                     {new Fraction(3),new Fraction(2),new Fraction(10)}\n              });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // null\n         try {\n             m.setSubMatrix(null, 1, 1);\n-            fail(\"expecting NullArgumentException\");\n+            Assert.fail(\"expecting NullArgumentException\");\n         } catch (NullArgumentException e) {\n             // expected\n         }\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n         try {\n             m2.setSubMatrix(testData,0,1);\n-            fail(\"expecting MathIllegalStateException\");\n+            Assert.fail(\"expecting MathIllegalStateException\");\n         } catch (MathIllegalStateException e) {\n             // expected\n         }\n         try {\n             m2.setSubMatrix(testData,1,0);\n-            fail(\"expecting MathIllegalStateException\");\n+            Assert.fail(\"expecting MathIllegalStateException\");\n         } catch (MathIllegalStateException e) {\n             // expected\n         }\n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n     }\n \n+    @Test\n     public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n-        assertEquals(rows * columns, getVisitor.getCount());\n+        Assert.assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n-        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));\n-            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));\n-            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));\n+            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+    }\n+\n+    @Test\n     public void testSerial()  {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n-        assertEquals(m,TestUtils.serializeAndRecover(m));\n+        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n     private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n         @Override\n         public void visit(int i, int j, Fraction value) {\n             ++count;\n-            assertEquals(new Fraction(i * 1024 + j, 1024), value);\n+            Assert.assertEquals(new Fraction(i * 1024 + j, 1024), value);\n         }\n         public int getCount() {\n             return count;\n--- a/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.NonSquareMatrixException;\n-import junit.framework.TestCase;\n-\n-public class LUDecompositionImplTest extends TestCase {\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class LUDecompositionImplTest {\n     private double[][] testData = {\n             { 1.0, 2.0, 3.0},\n             { 2.0, 5.0, 3.0},\n \n     private static final double normTolerance = 10e-14;\n \n-    public LUDecompositionImplTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         LUDecomposition LU = new LUDecompositionImpl(matrix);\n-        assertEquals(testData.length, LU.getL().getRowDimension());\n-        assertEquals(testData.length, LU.getL().getColumnDimension());\n-        assertEquals(testData.length, LU.getU().getRowDimension());\n-        assertEquals(testData.length, LU.getU().getColumnDimension());\n-        assertEquals(testData.length, LU.getP().getRowDimension());\n-        assertEquals(testData.length, LU.getP().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getL().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getL().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getColumnDimension());\n \n     }\n \n     /** test non-square matrix */\n+    @Test\n     public void testNonSquare() {\n         try {\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ime) {\n             // expected behavior\n         }\n     }\n \n     /** test PA = LU */\n+    @Test\n     public void testPAEqualLU() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         LUDecomposition lu = new LUDecompositionImpl(matrix);\n         RealMatrix u = lu.getU();\n         RealMatrix p = lu.getP();\n         double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        Assert.assertEquals(0, norm, normTolerance);\n \n         matrix = MatrixUtils.createRealMatrix(testDataMinus);\n         lu = new LUDecompositionImpl(matrix);\n         u = lu.getU();\n         p = lu.getP();\n         norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        Assert.assertEquals(0, norm, normTolerance);\n \n         matrix = MatrixUtils.createRealIdentityMatrix(17);\n         lu = new LUDecompositionImpl(matrix);\n         u = lu.getU();\n         p = lu.getP();\n         norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        Assert.assertEquals(0, norm, normTolerance);\n \n         matrix = MatrixUtils.createRealMatrix(singular);\n         lu = new LUDecompositionImpl(matrix);\n-        assertFalse(lu.getSolver().isNonSingular());\n-        assertNull(lu.getL());\n-        assertNull(lu.getU());\n-        assertNull(lu.getP());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n \n         matrix = MatrixUtils.createRealMatrix(bigSingular);\n         lu = new LUDecompositionImpl(matrix);\n-        assertFalse(lu.getSolver().isNonSingular());\n-        assertNull(lu.getL());\n-        assertNull(lu.getU());\n-        assertNull(lu.getP());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n \n     }\n \n     /** test that L is lower triangular with unit diagonal */\n+    @Test\n     public void testLLowerTriangular() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         RealMatrix l = new LUDecompositionImpl(matrix).getL();\n         for (int i = 0; i < l.getRowDimension(); i++) {\n-            assertEquals(l.getEntry(i, i), 1, entryTolerance);\n+            Assert.assertEquals(l.getEntry(i, i), 1, entryTolerance);\n             for (int j = i + 1; j < l.getColumnDimension(); j++) {\n-                assertEquals(l.getEntry(i, j), 0, entryTolerance);\n+                Assert.assertEquals(l.getEntry(i, j), 0, entryTolerance);\n             }\n         }\n     }\n \n     /** test that U is upper triangular */\n+    @Test\n     public void testUUpperTriangular() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         RealMatrix u = new LUDecompositionImpl(matrix).getU();\n         for (int i = 0; i < u.getRowDimension(); i++) {\n             for (int j = 0; j < i; j++) {\n-                assertEquals(u.getEntry(i, j), 0, entryTolerance);\n+                Assert.assertEquals(u.getEntry(i, j), 0, entryTolerance);\n             }\n         }\n     }\n \n     /** test that P is a permutation matrix */\n+    @Test\n     public void testPPermutation() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         RealMatrix p   = new LUDecompositionImpl(matrix).getP();\n \n         RealMatrix ppT = p.multiply(p.transpose());\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());\n-        assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);\n+        Assert.assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);\n \n         for (int i = 0; i < p.getRowDimension(); i++) {\n             int zeroCount  = 0;\n                     ++otherCount;\n                 }\n             }\n-            assertEquals(p.getColumnDimension() - 1, zeroCount);\n-            assertEquals(1, oneCount);\n-            assertEquals(0, otherCount);\n+            Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n         }\n \n         for (int j = 0; j < p.getColumnDimension(); j++) {\n                     ++otherCount;\n                 }\n             }\n-            assertEquals(p.getRowDimension() - 1, zeroCount);\n-            assertEquals(1, oneCount);\n-            assertEquals(0, otherCount);\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(p.getRowDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n+        }\n+\n+    }\n \n     /** test singular */\n+    @Test\n     public void testSingular() {\n         LUDecomposition lu =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n-        assertTrue(lu.getSolver().isNonSingular());\n+        Assert.assertTrue(lu.getSolver().isNonSingular());\n         lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular));\n-        assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n         lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular));\n-        assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n     }\n \n     /** test matrices values */\n+    @Test\n     public void testMatricesValues1() {\n        LUDecomposition lu =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n \n         // check values against known references\n         RealMatrix l = lu.getL();\n-        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n         RealMatrix u = lu.getU();\n-        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n         RealMatrix p = lu.getP();\n-        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n         int[] pivot = lu.getPivot();\n         for (int i = 0; i < pivotRef.length; ++i) {\n-            assertEquals(pivotRef[i], pivot[i]);\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n         }\n \n         // check the same cached instance is returned the second time\n-        assertTrue(l == lu.getL());\n-        assertTrue(u == lu.getU());\n-        assertTrue(p == lu.getP());\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n \n     }\n \n     /** test matrices values */\n+    @Test\n     public void testMatricesValues2() {\n        LUDecomposition lu =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(luData));\n \n         // check values against known references\n         RealMatrix l = lu.getL();\n-        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n         RealMatrix u = lu.getU();\n-        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n         RealMatrix p = lu.getP();\n-        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n         int[] pivot = lu.getPivot();\n         for (int i = 0; i < pivotRef.length; ++i) {\n-            assertEquals(pivotRef[i], pivot[i]);\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n         }\n \n         // check the same cached instance is returned the second time\n-        assertTrue(l == lu.getL());\n-        assertTrue(u == lu.getU());\n-        assertTrue(p == lu.getP());\n-\n-    }\n-\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import junit.framework.TestCase;\n \n-public class LUSolverTest extends TestCase {\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class LUSolverTest {\n     private double[][] testData = {\n             { 1.0, 2.0, 3.0},\n             { 2.0, 5.0, 3.0},\n             { 3.0, 7.0,   6.0,    8.0 }\n     }; // 4th row = 1st + 2nd\n \n-    public LUSolverTest(String name) {\n-        super(name);\n-    }\n-\n     /** test threshold impact */\n+    @Test\n     public void testThreshold() {\n         final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {\n                                                        { 1.0, 2.0, 3.0},\n                                                        { 2.0, 5.0, 3.0},\n                                                        { 4.000001, 9.0, 9.0}\n                                                      });\n-        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());\n-        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());\n+        Assert.assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());\n+        Assert.assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());\n     }\n \n     /** test singular */\n+    @Test\n     public void testSingular() {\n         DecompositionSolver solver =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n-        assertTrue(solver.isNonSingular());\n+        Assert.assertTrue(solver.isNonSingular());\n         solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();\n-        assertFalse(solver.isNonSingular());\n+        Assert.assertFalse(solver.isNonSingular());\n         solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)).getSolver();\n-        assertFalse(solver.isNonSingular());\n+        Assert.assertFalse(solver.isNonSingular());\n     }\n \n     /** test solve dimension errors */\n+    @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n \n     /** test solve singularity errors */\n+    @Test\n     public void testSolveSingularityErrors() {\n         DecompositionSolver solver =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumnVector(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n     }\n \n     /** test solve */\n+    @Test\n     public void testSolve() {\n         DecompositionSolver solver =\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n         });\n \n         // using RealMatrix\n-        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         // using ArrayRealVector\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             ArrayRealVectorTest.RealVectorTestImpl v =\n                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n-\n     }\n \n     /** test determinant */\n+    @Test\n     public void testDeterminant() {\n-        assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n-        assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);\n-        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);\n-        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);\n+        Assert.assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n+        Assert.assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);\n+        Assert.assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);\n+        Assert.assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);\n     }\n \n     private double getDeterminant(RealMatrix m) {\n         return new LUDecompositionImpl(m).getDeterminant();\n     }\n-\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixDimensionMismatchExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link MatrixDimensionMismatchException}.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public class MatrixDimensionMismatchExceptionTest {\n+    @Test\n+    public void testAccessors() {\n+        final MatrixDimensionMismatchException e\n+            = new MatrixDimensionMismatchException(1, 2, 3, 4);\n+        Assert.assertEquals(1, e.getWrongRowDimension());\n+        Assert.assertEquals(2, e.getWrongColumnDimension());\n+        Assert.assertEquals(3, e.getExpectedRowDimension());\n+        Assert.assertEquals(4, e.getExpectedColumnDimension());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n import java.util.Random;\n \n import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n-import junit.framework.TestCase;\n-\n-public class QRSolverTest extends TestCase {\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class QRSolverTest {\n     double[][] testData3x3NonSingular = {\n             { 12, -51,   4 },\n             {  6, 167, -68 },\n             { -5,  34,   7 }\n     };\n \n-    public QRSolverTest(String name) {\n-        super(name);\n-    }\n-\n     /** test rank */\n+    @Test\n     public void testRank() {\n         DecompositionSolver solver =\n             new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n-        assertTrue(solver.isNonSingular());\n+        Assert.assertTrue(solver.isNonSingular());\n \n         solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n-        assertFalse(solver.isNonSingular());\n+        Assert.assertFalse(solver.isNonSingular());\n \n         solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();\n-        assertTrue(solver.isNonSingular());\n+        Assert.assertTrue(solver.isNonSingular());\n \n         solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();\n-        assertTrue(solver.isNonSingular());\n+        Assert.assertTrue(solver.isNonSingular());\n \n     }\n \n     /** test solve dimension errors */\n+    @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n             new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumnVector(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n \n     /** test solve rank errors */\n+    @Test\n     public void testSolveRankErrors() {\n         DecompositionSolver solver =\n             new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumnVector(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException iae) {\n             // expected behavior\n         }\n     }\n \n     /** test solve */\n+    @Test\n     public void testSolve() {\n         QRDecomposition decomposition =\n             new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n         });\n \n         // using RealMatrix\n-        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());\n+        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             final double[] x = solver.solve(b.getColumn(i));\n             final double error = new ArrayRealVector(x).subtract(xRef.getColumnVector(i)).getNorm();\n-            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n         }\n \n         // using ArrayRealVector\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             final RealVector x = solver.solve(b.getColumnVector(i));\n             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n-            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n         }\n \n         // using RealVector with an alternate implementation\n                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n             final RealVector x = solver.solve(v);\n             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n-            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+    }\n+\n+    @Test\n     public void testOverdetermined() throws MathUserException {\n         final Random r    = new Random(5559252868205245l);\n         int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n \n         // despite perturbation, the least square solution should be pretty good\n         RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);\n-        assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n-\n-    }\n-\n+        Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n+\n+    }\n+\n+    @Test\n     public void testUnderdetermined() throws MathUserException {\n         final Random r    = new Random(42185006424567123l);\n         int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);\n \n         // too many equations, the system cannot be solved at all\n-        assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);\n+        Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);\n \n         // the last unknown should have been set to 0\n-        assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm());\n-\n+        Assert.assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm(), 0);\n     }\n \n     private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n         RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n-        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n-            @Override\n-            public double visit(int row, int column, double value) {\n-                return 2.0 * r.nextDouble() - 1.0;\n-            }\n-        });\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+                @Override\n+                    public double visit(int row, int column, double value) {\n+                    return 2.0 * r.nextDouble() - 1.0;\n+                }\n+            });\n         return m;\n     }\n }\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n  */\n package org.apache.commons.math.linear;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  */\n-public class SparseFieldMatrixTest extends TestCase {\n+public class SparseFieldMatrixTest {\n     // 3 x 3 identity matrix\n     protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } };\n     // Test data for group operations\n     protected double normTolerance = 10E-14;\n     protected Field<Fraction> field = FractionField.getInstance();\n \n-    public SparseFieldMatrixTest(String name) {\n-        super(name);\n-        setupFractionArrays();\n-    }\n-\n-    private void setupFractionArrays() {\n+    public SparseFieldMatrixTest() {\n         try {\n             testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) },\n                     { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } };\n         } catch (FractionConversionException e) {\n             // ignore, can't happen\n         }\n-\n-\n     }\n \n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n-        assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n-        assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n-        assertTrue(\"testData is square\", m.isSquare());\n-        assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n-        assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n-        assertTrue(\"testData2 is not square\", !m2.isSquare());\n+        Assert.assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n+        Assert.assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n+        Assert.assertTrue(\"testData is square\", m.isSquare());\n+        Assert.assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n+        Assert.assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n+        Assert.assertTrue(\"testData2 is not square\", !m2.isSquare());\n     }\n \n     /** test copy functions */\n+    @Test\n     public void testCopyFunctions() {\n         SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);\n         FieldMatrix<Fraction> m2 = m1.copy();\n-        assertEquals(m1.getClass(), m2.getClass());\n-        assertEquals((m2), m1);\n+        Assert.assertEquals(m1.getClass(), m2.getClass());\n+        Assert.assertEquals((m2), m1);\n         SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);\n         FieldMatrix<Fraction> m4 = m3.copy();\n-        assertEquals(m3.getClass(), m4.getClass());\n-        assertEquals((m4), m3);\n+        Assert.assertEquals(m3.getClass(), m4.getClass());\n+        Assert.assertEquals((m4), m3);\n     }\n \n     /** test add */\n+    @Test\n     public void testAdd() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n         FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(\"sum entry entry\",\n+                Assert.assertEquals(\"sum entry entry\",\n                     mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(),\n                     entryTolerance);\n             }\n     }\n \n     /** test add failure */\n+    @Test\n     public void testAddFail() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n \n     /** test m-n = m + -n */\n+    @Test\n     public void testPlusMinus() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv);\n             n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance);\n         try {\n             m.subtract(createSparseMatrix(testData2));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test multiply */\n+    @Test\n     public void testMultiply() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n                 entryTolerance);\n         try {\n             m.multiply(createSparseMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };\n     private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } };\n \n+    @Test\n     public void testMultiply2() {\n         FieldMatrix<Fraction> m3 = createSparseMatrix(d3);\n         FieldMatrix<Fraction> m4 = createSparseMatrix(d4);\n     }\n \n     /** test trace */\n+    @Test\n     public void testTrace() {\n         FieldMatrix<Fraction> m = createSparseMatrix(id);\n-        assertEquals(\"identity trace\", 3d, m.getTrace().doubleValue(), entryTolerance);\n+        Assert.assertEquals(\"identity trace\", 3d, m.getTrace().doubleValue(), entryTolerance);\n         m = createSparseMatrix(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n         }\n     }\n \n     /** test sclarAdd */\n+    @Test\n     public void testScalarAdd() {\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n         assertClose(\"scalar add\", createSparseMatrix(testDataPlus2),\n     }\n \n     /** test operate */\n+    @Test\n     public void testOperate() {\n         FieldMatrix<Fraction> m = createSparseMatrix(id);\n         assertClose(\"identity operate\", testVector, m.operate(testVector),\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test issue MATH-209 */\n+    @Test\n     public void testMath209() {\n         FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } });\n         Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n-        assertEquals(a.getRowDimension(), b.length);\n-        assertEquals(3.0, b[0].doubleValue(), 1.0e-12);\n-        assertEquals(7.0, b[1].doubleValue(), 1.0e-12);\n-        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n+        Assert.assertEquals(a.getRowDimension(), b.length);\n+        Assert.assertEquals(3.0, b[0].doubleValue(), 1.0e-12);\n+        Assert.assertEquals(7.0, b[1].doubleValue(), 1.0e-12);\n+        Assert.assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n     }\n \n     /** test transpose */\n+    @Test\n     public void testTranspose() {\n-\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n         FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n     }\n \n     /** test preMultiply by vector */\n+    @Test\n     public void testPremultiplyVector() {\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n         assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testPremultiply() {\n         FieldMatrix<Fraction> m3 = createSparseMatrix(d3);\n         FieldMatrix<Fraction> m4 = createSparseMatrix(d4);\n                 entryTolerance);\n         try {\n             m.preMultiply(createSparseMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetVectors() {\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n         assertClose(\"get row\", m.getRow(0), testDataRow1, entryTolerance);\n         assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // ignored\n-        }\n-    }\n-\n+            Assert.fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    @Test\n     public void testGetEntry() {\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n-        assertEquals(\"get entry\", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);\n+        Assert.assertEquals(\"get entry\", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n     /** test examples in user guide */\n+    @Test\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };\n         FieldMatrix<Fraction> n = createSparseMatrix(matrixData2);\n         // Now multiply m by n\n         FieldMatrix<Fraction> p = m.multiply(n);\n-        assertEquals(2, p.getRowDimension());\n-        assertEquals(2, p.getColumnDimension());\n+        Assert.assertEquals(2, p.getRowDimension());\n+        Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n         FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n-        assertEquals(2, pInverse.getRowDimension());\n-        assertEquals(2, pInverse.getColumnDimension());\n+        Assert.assertEquals(2, pInverse.getRowDimension());\n+        Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         // Solve example\n         Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) },\n         FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);\n         Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };\n         Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n-        assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),\n+        Assert.assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),\n                 constants[0].doubleValue(), 1E-12);\n-        assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),\n+        Assert.assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),\n                 constants[1].doubleValue(), 1E-12);\n-        assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),\n+        Assert.assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),\n                 constants[2].doubleValue(), 1E-12);\n \n     }\n \n     // test submatrix accessors\n+    @Test\n     public void testSubMatrix() {\n         FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n         FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00);\n         FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123);\n         FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123);\n         FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31);\n-        assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n-        assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n-        assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n-        assertEquals(\"Rows02Cols13\", mRows02Cols13,\n+        Assert.assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n+        Assert.assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n+        Assert.assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n+        Assert.assertEquals(\"Rows02Cols13\", mRows02Cols13,\n             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n-        assertEquals(\"Rows03Cols12\", mRows03Cols12,\n+        Assert.assertEquals(\"Rows03Cols12\", mRows03Cols12,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n-        assertEquals(\"Rows03Cols123\", mRows03Cols123,\n+        Assert.assertEquals(\"Rows03Cols123\", mRows03Cols123,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows20Cols123\", mRows20Cols123,\n+        Assert.assertEquals(\"Rows20Cols123\", mRows20Cols123,\n             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n+        Assert.assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n+        Assert.assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n \n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting NumberIsTooSmallException\");\n+            Assert.fail(\"Expecting NumberIsTooSmallException\");\n         } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(-1, 1, 2, 2);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 2);\n-            fail(\"Expecting NumberIsTooSmallException\");\n+            Assert.fail(\"Expecting NumberIsTooSmallException\");\n         } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting NumberIsTooSmallException\");\n+            Assert.fail(\"Expecting NumberIsTooSmallException\");\n         } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] {}, new int[] { 0 });\n-            fail(\"Expecting NoDataException\");\n+            Assert.fail(\"Expecting NoDataException\");\n         } catch (NoDataException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetRowMatrix() {\n         FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n         FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0);\n         FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3);\n-        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetColumnMatrix() {\n         FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n         FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1);\n         FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n+        Assert.assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n+        Assert.assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetRowVector() {\n         FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n         FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n         FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n-        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetColumnVector() {\n         FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n-        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        Assert.assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        Assert.assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         return new ArrayFieldVector<Fraction>(data, false);\n     }\n \n+    @Test\n     public void testEqualsAndHashCode() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy();\n         SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose();\n-        assertTrue(m.hashCode() != mt.hashCode());\n-        assertEquals(m.hashCode(), m1.hashCode());\n-        assertEquals(m, m);\n-        assertEquals(m, m1);\n-        assertFalse(m.equals(null));\n-        assertFalse(m.equals(mt));\n-        assertFalse(m.equals(createSparseMatrix(bigSingular)));\n+        Assert.assertTrue(m.hashCode() != mt.hashCode());\n+        Assert.assertEquals(m.hashCode(), m1.hashCode());\n+        Assert.assertEquals(m, m);\n+        Assert.assertEquals(m, m1);\n+        Assert.assertFalse(m.equals(null));\n+        Assert.assertFalse(m.equals(mt));\n+        Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));\n     }\n \n     /* Disable for now\n     public void testToString() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n-        assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+        Assert.assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n             m.toString());\n         m = new SparseFieldMatrix<Fraction>(field, 1, 1);\n-        assertEquals(\"SparseFieldMatrix<Fraction>{{0.0}}\", m.toString());\n+        Assert.assertEquals(\"SparseFieldMatrix<Fraction>{{0.0}}\", m.toString());\n     }\n     */\n \n+    @Test\n     public void testSetSubMatrix() throws Exception {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         m.setSubMatrix(detData2, 1, 1);\n         FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(detData2, 0, 0);\n         expected = createSparseMatrix(new Fraction[][] {\n                 { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(testDataPlus2, 0, 0);\n         expected = createSparseMatrix(new Fraction[][] {\n                 { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         // javadoc example\n         SparseFieldMatrix<Fraction> matrix =\n         matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);\n         expected = createSparseMatrix(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } });\n-        assertEquals(expected, matrix);\n+        Assert.assertEquals(expected, matrix);\n \n         // dimension overflow\n         try {\n             m.setSubMatrix(testData, 1, 1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData, -1, 1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData, 1, -1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // null\n         try {\n             m.setSubMatrix(null, 1, 1);\n-            fail(\"expecting NullArgumentException\");\n+            Assert.fail(\"expecting NullArgumentException\");\n         } catch (NullArgumentException e) {\n             // expected\n         }\n         try {\n             new SparseFieldMatrix<Fraction>(field, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] { {} }, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n-\n     }\n \n     // --------------- -----------------Protected methods\n             double tolerance) {\n         for(int i=0; i < m.getRowDimension(); i++){\n             for(int j=0; j < m.getColumnDimension(); j++){\n-                assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);\n+                Assert.assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);\n             }\n \n         }\n     protected void assertClose(String msg, Fraction[] m, Fraction[] n,\n             double tolerance) {\n         if (m.length != n.length) {\n-            fail(\"vectors not same length\");\n+            Assert.fail(\"vectors not same length\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" + i + \" elements differ\", m[i].doubleValue(), n[i].doubleValue(),\n+            Assert.assertEquals(msg + \" \" + i + \" elements differ\", m[i].doubleValue(), n[i].doubleValue(),\n                     tolerance);\n         }\n     }\n         }\n         return matrix;\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n  */\n package org.apache.commons.math.linear;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * @version $Revision$ $Date: 2008-11-07 06:48:13 -0800 (Fri, 07 Nov\n  *          2008) $\n  */\n-public final class SparseRealMatrixTest extends TestCase {\n+public final class SparseRealMatrixTest {\n \n     // 3 x 3 identity matrix\n     protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    public SparseRealMatrixTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n-        assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n-        assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n-        assertTrue(\"testData is square\", m.isSquare());\n-        assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n-        assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n-        assertTrue(\"testData2 is not square\", !m2.isSquare());\n+        Assert.assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n+        Assert.assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n+        Assert.assertTrue(\"testData is square\", m.isSquare());\n+        Assert.assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n+        Assert.assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n+        Assert.assertTrue(\"testData2 is not square\", !m2.isSquare());\n     }\n \n     /** test copy functions */\n+    @Test\n     public void testCopyFunctions() {\n         OpenMapRealMatrix m1 = createSparseMatrix(testData);\n         RealMatrix m2 = m1.copy();\n-        assertEquals(m1.getClass(), m2.getClass());\n-        assertEquals((m2), m1);\n+        Assert.assertEquals(m1.getClass(), m2.getClass());\n+        Assert.assertEquals((m2), m1);\n         OpenMapRealMatrix m3 = createSparseMatrix(testData);\n         RealMatrix m4 = m3.copy();\n-        assertEquals(m3.getClass(), m4.getClass());\n-        assertEquals((m4), m3);\n+        Assert.assertEquals(m3.getClass(), m4.getClass());\n+        Assert.assertEquals((m4), m3);\n     }\n \n     /** test add */\n+    @Test\n     public void testAdd() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);\n         RealMatrix mPlusMInv = m.add(mInv);\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(\"sum entry entry\",\n+                Assert.assertEquals(\"sum entry entry\",\n                     mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col),\n                     entryTolerance);\n             }\n     }\n \n     /** test add failure */\n+    @Test\n     public void testAddFail() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test norm */\n+    @Test\n     public void testNorm() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n-        assertEquals(\"testData norm\", 14d, m.getNorm(), entryTolerance);\n-        assertEquals(\"testData2 norm\", 7d, m2.getNorm(), entryTolerance);\n+        Assert.assertEquals(\"testData norm\", 14d, m.getNorm(), entryTolerance);\n+        Assert.assertEquals(\"testData2 norm\", 7d, m2.getNorm(), entryTolerance);\n     }\n \n     /** test m-n = m + -n */\n+    @Test\n     public void testPlusMinus() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix n = createSparseMatrix(testDataInv);\n             n.scalarMultiply(-1d).add(m), entryTolerance);\n         try {\n             m.subtract(createSparseMatrix(testData2));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test multiply */\n+    @Test\n     public void testMultiply() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);\n                 entryTolerance);\n         try {\n             m.multiply(createSparseMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };\n     private double[][] d5 = new double[][] { { 30 }, { 70 } };\n \n+    @Test\n     public void testMultiply2() {\n         RealMatrix m3 = createSparseMatrix(d3);\n         RealMatrix m4 = createSparseMatrix(d4);\n     }\n \n     /** test trace */\n+    @Test\n     public void testTrace() {\n         RealMatrix m = createSparseMatrix(id);\n-        assertEquals(\"identity trace\", 3d, m.getTrace(), entryTolerance);\n+        Assert.assertEquals(\"identity trace\", 3d, m.getTrace(), entryTolerance);\n         m = createSparseMatrix(testData2);\n         try {\n             m.getTrace();\n-            fail(\"Expecting NonSquareMatrixException\");\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n         }\n     }\n \n     /** test sclarAdd */\n+    @Test\n     public void testScalarAdd() {\n         RealMatrix m = createSparseMatrix(testData);\n         assertClose(\"scalar add\", createSparseMatrix(testDataPlus2),\n     }\n \n     /** test operate */\n+    @Test\n     public void testOperate() {\n         RealMatrix m = createSparseMatrix(id);\n         assertClose(\"identity operate\", testVector, m.operate(testVector),\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n     /** test issue MATH-209 */\n+    @Test\n     public void testMath209() {\n         RealMatrix a = createSparseMatrix(new double[][] {\n                 { 1, 2 }, { 3, 4 }, { 5, 6 } });\n         double[] b = a.operate(new double[] { 1, 1 });\n-        assertEquals(a.getRowDimension(), b.length);\n-        assertEquals(3.0, b[0], 1.0e-12);\n-        assertEquals(7.0, b[1], 1.0e-12);\n-        assertEquals(11.0, b[2], 1.0e-12);\n+        Assert.assertEquals(a.getRowDimension(), b.length);\n+        Assert.assertEquals(3.0, b[0], 1.0e-12);\n+        Assert.assertEquals(7.0, b[1], 1.0e-12);\n+        Assert.assertEquals(11.0, b[2], 1.0e-12);\n     }\n \n     /** test transpose */\n+    @Test\n     public void testTranspose() {\n-\n         RealMatrix m = createSparseMatrix(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n         RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n     }\n \n     /** test preMultiply by vector */\n+    @Test\n     public void testPremultiplyVector() {\n         RealMatrix m = createSparseMatrix(testData);\n         assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testPremultiply() {\n         RealMatrix m3 = createSparseMatrix(d3);\n         RealMatrix m4 = createSparseMatrix(d4);\n                 entryTolerance);\n         try {\n             m.preMultiply(createSparseMatrix(bigSingular));\n-            fail(\"Expecting illegalArgumentException\");\n+            Assert.fail(\"Expecting illegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n \n+    @Test\n     public void testGetVectors() {\n         RealMatrix m = createSparseMatrix(testData);\n         assertClose(\"get row\", m.getRow(0), testDataRow1, entryTolerance);\n         assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // ignored\n-        }\n-    }\n-\n+            Assert.fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    @Test\n     public void testGetEntry() {\n         RealMatrix m = createSparseMatrix(testData);\n-        assertEquals(\"get entry\", m.getEntry(0, 1), 2d, entryTolerance);\n+        Assert.assertEquals(\"get entry\", m.getEntry(0, 1), 2d, entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n     /** test examples in user guide */\n+    @Test\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };\n         RealMatrix n = createSparseMatrix(matrixData2);\n         // Now multiply m by n\n         RealMatrix p = m.multiply(n);\n-        assertEquals(2, p.getRowDimension());\n-        assertEquals(2, p.getColumnDimension());\n+        Assert.assertEquals(2, p.getRowDimension());\n+        Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n         RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n-        assertEquals(2, pInverse.getRowDimension());\n-        assertEquals(2, pInverse.getColumnDimension());\n+        Assert.assertEquals(2, pInverse.getRowDimension());\n+        Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         // Solve example\n         double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },\n         RealMatrix coefficients = createSparseMatrix(coefficientsData);\n         double[] constants = { 1, -2, 1 };\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n-        assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],\n+        Assert.assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],\n                 constants[0], 1E-12);\n-        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],\n+        Assert.assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],\n                 constants[1], 1E-12);\n-        assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],\n+        Assert.assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],\n                 constants[2], 1E-12);\n \n     }\n \n     // test submatrix accessors\n+    @Test\n     public void testSubMatrix() {\n         RealMatrix m = createSparseMatrix(subTestData);\n         RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);\n         RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);\n         RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);\n         RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);\n-        assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n-        assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n-        assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n-        assertEquals(\"Rows02Cols13\", mRows02Cols13,\n+        Assert.assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n+        Assert.assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n+        Assert.assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n+        Assert.assertEquals(\"Rows02Cols13\", mRows02Cols13,\n             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n-        assertEquals(\"Rows03Cols12\", mRows03Cols12,\n+        Assert.assertEquals(\"Rows03Cols12\", mRows03Cols12,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n-        assertEquals(\"Rows03Cols123\", mRows03Cols123,\n+        Assert.assertEquals(\"Rows03Cols123\", mRows03Cols123,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows20Cols123\", mRows20Cols123,\n+        Assert.assertEquals(\"Rows20Cols123\", mRows20Cols123,\n             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n+        Assert.assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n+        Assert.assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n \n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting NumberIsTooSmallException\");\n+            Assert.fail(\"Expecting NumberIsTooSmallException\");\n         } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(-1, 1, 2, 2);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 2);\n-            fail(\"Expecting NumberIsTooSmallException\");\n+            Assert.fail(\"Expecting NumberIsTooSmallException\");\n         } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting NumberIsTooSmallException\");\n+            Assert.fail(\"Expecting NumberIsTooSmallException\");\n         } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] {}, new int[] { 0 });\n-            fail(\"Expecting NoDataException\");\n+            Assert.fail(\"Expecting NoDataException\");\n         } catch (NoDataException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetRowMatrix() {\n         RealMatrix m = createSparseMatrix(subTestData);\n         RealMatrix mRow0 = createSparseMatrix(subRow0);\n         RealMatrix mRow3 = createSparseMatrix(subRow3);\n-        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetColumnMatrix() {\n         RealMatrix m = createSparseMatrix(subTestData);\n         RealMatrix mColumn1 = createSparseMatrix(subColumn1);\n         RealMatrix mColumn3 = createSparseMatrix(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n+        Assert.assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n+        Assert.assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetRowVector() {\n         RealMatrix m = createSparseMatrix(subTestData);\n         RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n         RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n-        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n-        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        Assert.assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        Assert.assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n-        } catch (OutOfRangeException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGetColumnVector() {\n         RealMatrix m = createSparseMatrix(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n         RealVector mColumn3 = columnToVector(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n-        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        Assert.assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        Assert.assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n         return new ArrayRealVector(data, false);\n     }\n \n+    @Test\n     public void testEqualsAndHashCode() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         OpenMapRealMatrix m1 = m.copy();\n         OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose();\n-        assertTrue(m.hashCode() != mt.hashCode());\n-        assertEquals(m.hashCode(), m1.hashCode());\n-        assertEquals(m, m);\n-        assertEquals(m, m1);\n-        assertFalse(m.equals(null));\n-        assertFalse(m.equals(mt));\n-        assertFalse(m.equals(createSparseMatrix(bigSingular)));\n-    }\n-\n+        Assert.assertTrue(m.hashCode() != mt.hashCode());\n+        Assert.assertEquals(m.hashCode(), m1.hashCode());\n+        Assert.assertEquals(m, m);\n+        Assert.assertEquals(m, m1);\n+        Assert.assertFalse(m.equals(null));\n+        Assert.assertFalse(m.equals(mt));\n+        Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));\n+    }\n+\n+    @Test\n     public void testToString() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n-        assertEquals(\"OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+        Assert.assertEquals(\"OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n             m.toString());\n         m = new OpenMapRealMatrix(1, 1);\n-        assertEquals(\"OpenMapRealMatrix{{0.0}}\", m.toString());\n-    }\n-\n-    public void testSetSubMatrix() throws Exception {\n+        Assert.assertEquals(\"OpenMapRealMatrix{{0.0}}\", m.toString());\n+    }\n+\n+    @Test\n+    public void testSetSubMatrix() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n         m.setSubMatrix(detData2, 1, 1);\n         RealMatrix expected = createSparseMatrix(new double[][] {\n                 { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(detData2, 0, 0);\n         expected = createSparseMatrix(new double[][] {\n                 { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         m.setSubMatrix(testDataPlus2, 0, 0);\n         expected = createSparseMatrix(new double[][] {\n                 { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });\n-        assertEquals(expected, m);\n+        Assert.assertEquals(expected, m);\n \n         // javadoc example\n         OpenMapRealMatrix matrix =\n         matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);\n         expected = createSparseMatrix(new double[][] {\n                 { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });\n-        assertEquals(expected, matrix);\n+        Assert.assertEquals(expected, matrix);\n \n         // dimension overflow\n         try {\n             m.setSubMatrix(testData, 1, 1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData, -1, 1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData, 1, -1);\n-            fail(\"expecting OutOfRangeException\");\n+            Assert.fail(\"expecting OutOfRangeException\");\n         } catch (OutOfRangeException e) {\n             // expected\n         }\n         // null\n         try {\n             m.setSubMatrix(null, 1, 1);\n-            fail(\"expecting NullPointerException\");\n+            Assert.fail(\"expecting NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n         try {\n             new OpenMapRealMatrix(0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n         // empty\n         try {\n             m.setSubMatrix(new double[][] { {} }, 0, 0);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n     }\n \n+    @Test\n     public void testSerial()  {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n-        assertEquals(m,TestUtils.serializeAndRecover(m));\n+        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n     // --------------- -----------------Protected methods\n     /** verifies that two matrices are close (1-norm) */\n     protected void assertClose(String msg, RealMatrix m, RealMatrix n,\n             double tolerance) {\n-        assertTrue(msg, m.subtract(n).getNorm() < tolerance);\n+        Assert.assertTrue(msg, m.subtract(n).getNorm() < tolerance);\n     }\n \n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n             double tolerance) {\n         if (m.length != n.length) {\n-            fail(\"vectors not same length\");\n+            Assert.fail(\"vectors not same length\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" + i + \" elements differ\", m[i], n[i],\n+            Assert.assertEquals(msg + \" \" + i + \" elements differ\", m[i], n[i],\n                     tolerance);\n         }\n     }\n         }\n         return matrix;\n     }\n-\n-\n }\n--- a/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n import java.util.Arrays;\n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.NonSquareMatrixException;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n-public class TriDiagonalTransformerTest extends TestCase {\n+public class TriDiagonalTransformerTest {\n \n     private double[][] testSquare5 = {\n             { 1, 2, 3, 1, 1 },\n             { 4, 2, 0 }\n     };\n \n-    public TriDiagonalTransformerTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testNonSquare() {\n         try {\n             new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NonSquareMatrixException ime) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testAEqualQTQt() {\n         checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));\n         checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));\n         RealMatrix qT = transformer.getQT();\n         RealMatrix t  = transformer.getT();\n         double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();\n-        assertEquals(0, norm, 4.0e-15);\n+        Assert.assertEquals(0, norm, 4.0e-15);\n     }\n \n+    @Test\n     public void testNoAccessBelowDiagonal() {\n         checkNoAccessBelowDiagonal(testSquare5);\n         checkNoAccessBelowDiagonal(testSquare3);\n         RealMatrix qT = transformer.getQT();\n         RealMatrix t  = transformer.getT();\n         double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();\n-        assertEquals(0, norm, 4.0e-15);\n+        Assert.assertEquals(0, norm, 4.0e-15);\n     }\n \n+    @Test\n     public void testQOrthogonal() {\n         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());\n         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());\n     }\n \n+    @Test\n     public void testQTOrthogonal() {\n         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());\n         checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());\n     private void checkOrthogonal(RealMatrix m) {\n         RealMatrix mTm = m.transpose().multiply(m);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n-        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);\n+        Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);\n     }\n \n+    @Test\n     public void testTTriDiagonal() {\n         checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());\n         checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());\n         for (int i = 0; i < rows; ++i) {\n             for (int j = 0; j < cols; ++j) {\n                 if ((i < j - 1) || (i > j + 1)) {\n-                    assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);\n                 }\n             }\n         }\n     }\n \n+    @Test\n     public void testMatricesValues5() {\n         checkMatricesValues(testSquare5,\n                             new double[][] {\n                             new double[] { -FastMath.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });\n     }\n \n+    @Test\n     public void testMatricesValues3() {\n         checkMatricesValues(testSquare3,\n                             new double[][] {\n \n         // check values against known references\n         RealMatrix q = transformer.getQ();\n-        assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);\n+        Assert.assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);\n \n         RealMatrix t = transformer.getT();\n         double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];\n                 tData[i][i + 1] = secondaryDiagonal[i];\n             }\n         }\n-        assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);\n+        Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);\n \n         // check the same cached instance is returned the second time\n-        assertTrue(q == transformer.getQ());\n-        assertTrue(t == transformer.getT());\n-\n+        Assert.assertTrue(q == transformer.getQ());\n+        Assert.assertTrue(t == transformer.getT());\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.MathUtils;", "timestamp": 1299591736, "metainfo": ""}