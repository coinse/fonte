{"sha": "8d2eacf2084e23a27726c1aabb8371803895b47e", "log": "MATH-637 Replaced \"DescriptiveStatistics\" by \"StatisticalSummary\", as suggested by Phil. Added some \"randomness\" so that the timed code has a side-effect that cannot be optimized away by the JIT compiler.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math/PerfTestUtils.java\n+++ b/src/test/java/org/apache/commons/math/PerfTestUtils.java\n  */\n package org.apache.commons.math;\n \n+import java.util.Random;\n import java.util.concurrent.Callable;\n-import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math.exception.MathIllegalStateException;\n \n /**\n     private static final int DEFAULT_REPEAT_CHUNK = 1000;\n     /** Default number of code repeats for computing the average run time. */\n     private static final int DEFAULT_REPEAT_STAT = 10000;\n+    /** RNG. */\n+    private static Random rng = new Random();\n \n     /**\n      * Timing.\n      * @param runGC Call {@code System.gc()} between each timed block. When\n      * set to {@code true}, the test will run much slower.\n      * @param methods Codes being timed.\n-     * @return for each of the given {@code methods}, a statistics of the\n-     * average times (in milliseconds) taken by a single call to the\n-     * {@code call} method (i.e. the time taken by each timed block divided\n-     * by {@code repeatChunk}).\n-     */\n-    public static DescriptiveStatistics[] time(int repeatChunk,\n-                                               int repeatStat,\n-                                               boolean runGC,\n-                                               Callable<Double> ... methods) {\n+     * @return for each of the given {@code methods}, a\n+     * {@link StatisticalSummary} of the average times (in milliseconds)\n+     * taken by a single call to the {@code call} method (i.e. the time\n+     * taken by each timed block divided by {@code repeatChunk}).\n+     */\n+    public static StatisticalSummary[] time(int repeatChunk,\n+                                            int repeatStat,\n+                                            boolean runGC,\n+                                            Callable<Double> ... methods) {\n         final double[][][] times = timesAndResults(repeatChunk,\n                                                    repeatStat,\n                                                    runGC,\n                                                    methods);\n \n         final int len = methods.length;\n-        final DescriptiveStatistics[] stats = new DescriptiveStatistics[len];\n+        final StatisticalSummary[] stats = new StatisticalSummary[len];\n         for (int j = 0; j < len; j++) {\n-            final DescriptiveStatistics s = new DescriptiveStatistics();\n+            final SummaryStatistics s = new SummaryStatistics();\n             for (int k = 0; k < repeatStat; k++) {\n                 s.addValue(times[j][k][0]);\n             }\n-            stats[j] = s;\n+            stats[j] = s.getSummary();\n         }\n \n         return stats;\n                     }\n \n                     final Callable<Double> r = methods[j];\n-                    double result = 0;\n+                    final double[] result = new double[repeatChunk];\n \n                     // Timed block.\n                     final long start = System.nanoTime();\n                     for (int i = 0; i < repeatChunk; i++) {\n-                        result = r.call();\n+                        result[i] = r.call();\n                     }\n                     final long stop = System.nanoTime();\n \n-                    // Collect run time and results.\n+                    // Collect run time.\n                     timesAndResults[j][k][0] = (stop - start) * NANO_TO_MILLI;\n-                    timesAndResults[j][k][1] = result;\n+                    // Keep track of a randomly selected result.\n+                    timesAndResults[j][k][1] = result[rng.nextInt(repeatChunk)];\n                 }\n             }\n         } catch (Exception e) {\n     /**\n      * Timing and report (to standard output) the average time and standard\n      * deviation of a single call.\n+     * The timing is performed by calling the\n+     * {@link #time(int,int,boolean,Callable[]) time} method.\n      *\n      * @param title Title of the test (for the report).\n      * @param repeatChunk Each timing measurement will done done for that\n      * {@code call} method (i.e. the time taken by each timed block divided\n      * by {@code repeatChunk}).\n      */\n-    public static DescriptiveStatistics[] timeAndReport(String title,\n-                                                        int repeatChunk,\n-                                                        int repeatStat,\n-                                                        boolean runGC,\n-                                                        RunTest ... methods) {\n+    public static StatisticalSummary[] timeAndReport(String title,\n+                                                     int repeatChunk,\n+                                                     int repeatStat,\n+                                                     boolean runGC,\n+                                                     RunTest ... methods) {\n         // Header format.\n-        final String headerFormat = \"%s (runs per timed block: %d, timed blocks: %d)\";\n+        final String hFormat = \"%s (runs per timed block: %d, timed blocks: %d)\";\n         // Result format.\n         final String format = \"%15s: %e (%e) ms\";\n \n-        System.out.println(String.format(headerFormat,\n+        System.out.println(String.format(hFormat,\n                                          title,\n                                          repeatChunk,\n                                          repeatStat));\n-        final DescriptiveStatistics[] time = time(repeatChunk, repeatStat, runGC, methods);\n+        final StatisticalSummary[] time = time(repeatChunk,\n+                                               repeatStat,\n+                                               runGC,\n+                                               methods);\n         for (int i = 0, max = time.length; i < max; i++) {\n-            final DescriptiveStatistics s = time[i];\n+            final StatisticalSummary s = time[i];\n             System.out.println(String.format(format,\n                                              methods[i].getName(),\n                                              s.getMean(),\n      * {@code call} method (i.e. the time taken by each timed block divided\n      * by {@code repeatChunk}).\n      */\n-    public static DescriptiveStatistics[] timeAndReport(String title,\n-                                                        RunTest ... methods) {\n+    public static StatisticalSummary[] timeAndReport(String title,\n+                                                     RunTest ... methods) {\n         return timeAndReport(title,\n                              DEFAULT_REPEAT_CHUNK,\n                              DEFAULT_REPEAT_STAT,", "timestamp": 1312121081, "metainfo": ""}