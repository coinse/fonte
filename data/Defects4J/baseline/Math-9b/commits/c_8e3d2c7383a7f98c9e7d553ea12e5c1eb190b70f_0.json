{"sha": "8e3d2c7383a7f98c9e7d553ea12e5c1eb190b70f", "log": "Degegates to StatUtils now for \"window\" case. Implemented skew and kurt using recursive moments.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n  *\n  * 3. The end-user documentation included with the redistribution, if\n  *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n+ *       \"This sumLog includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n  *    Alternately, this acknowlegement may appear in the software itself,\n  *    if and wherever such third-party acknowlegements normally appear.\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n  * @author Brent Worden\n  * @author <a href=\"mailto:HotFusionMan@Yahoo.com\">Albert Davidson Chou</a>\n- * @version $Revision: 1.9 $ $Date: 2003/06/17 17:10:15 $\n+ * @version $Revision: 1.10 $ $Date: 2003/06/18 13:47:35 $\n  *\n */\n public class UnivariateImpl implements Univariate, Serializable {\n \n-    /** hold the window size **/\n-    private int windowSize = Univariate.INFINITE_WINDOW;\n-\n-    /** Just in case the windowSize is not infinite, we need to\n-     *  keep an array to remember values 0 to N\n-     */\n-    private DoubleArray doubleArray;\n-\n-    /** count of values that have been added */\n-    private int n = 0;\n-\n-    /** min of values that have been added */\n-    private double min = Double.MAX_VALUE;\n-\n-    /** max of values that have been added */\n-    private double max = Double.MIN_VALUE;\n-\n-    /** product of values that have been added */\n-    private double product = Double.NaN;\n-\n-    /** mean of values that have been added */\n-    private double mean = Double.NaN ;\n-\n-    /** running ( variance * (n - 1) ) of values that have been added */\n-    private double pre_variance = Double.NaN ;\n-\n-    /** variance of values that have been added */\n-    private double variance = Double.NaN ;\n-\n-    /** running sum of values that have been added */\n-    private double sum = 0.0;\n-\n-    /** running sum of squares that have been added */\n-    private double sumsq = 0.0;\n-\n-    /** running sum of 3rd powers that have been added */\n-    private double sumCube = 0.0;\n-\n-    /** running sum of 4th powers that have been added */\n-    private double sumQuad = 0.0;\n-\n-    /** Creates new univariate with an infinite window */\n-    public UnivariateImpl() {\n-        clear();\n-    }\n-\n-    /** Creates a new univariate with a fixed window **/\n-    public UnivariateImpl(int window) {\n-        windowSize = window;\n-        doubleArray = new FixedDoubleArray( window );\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n-     */\n-    public void addValue(double v) {\n-        insertValue(v);\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getMean()\n-     */\n-    public double getMean() {\n-        return mean ;\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-     */\n-    public double getGeometricMean() {\n-        if ((product <= 0.0) || (n == 0)) {\n-            return Double.NaN;\n-        } else {\n-            return Math.pow(product,( 1.0 / (double) n ) );\n-        }\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getProduct()\n-     */\n-    public double getProduct() {\n-        return product;\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n-     */\n-    public double getStandardDeviation() {\n-        double variance = getVariance();\n-\n-        if ((variance == 0.0) || (variance == Double.NaN)) {\n-            return variance;\n-        } else {\n-            return Math.sqrt(variance);\n-        }\n-    }\n-\n-    /**\n-     * Returns the variance of the values that have been added via West's\n-     * algorithm as described by\n-     * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n-     * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n-     * vol. 22 no. 9, pp. 526-531.</a>.\n-     *\n-     * @return The variance of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n-     */\n-    public double getVariance() {\n-        return variance ;\n-    }\n-\n-    /**\n-     * Returns the skewness of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n-     *\n-     * @return The skew of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n-     */\n-    public double getSkewness() {\n-\n-        if( n < 1) return Double.NaN;\n-        if( n <= 2 ) return 0.0;\n-\n-        return ( 2 * Math.pow(sum, 3) - 3 * sum * sumsq + ((double) (n * n)) * sumCube ) /\n-               ( (double) (n * (n - 1) * (n - 2)) ) ;\n-    }\n-\n-    /**\n-     * Returns the kurtosis of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n-     *\n-     * @return The kurtosis of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n-     */\n-    public double getKurtosis() {\n-\n-        if( n < 1) return Double.NaN;\n-        if( n <= 3 ) return 0.0;\n-\n-        double x1 = -6 * Math.pow(sum, 4);\n-        double x2 = 12 * ((double) n) * Math.pow(sum, 2) * sumsq;\n-        double x3 = -3 * ((double) (n * (n - 1))) * Math.pow(sumsq,2);\n-        double x4 = -4 * ((double) (n * (n + 1))) * sum * sumCube;\n-        double x5 = Math.pow(((double) n),2) * ((double) (n+1)) * sumQuad;\n-\n-        return (x1 + x2 + x3 + x4 + x5) /\n-               ( (double) (n * (n - 1) * (n - 2) * (n - 3)) );\n-    }\n-\n-    /**\n-     * Called in \"addValue\" to insert a new value into the statistic.\n-     * @param v The value to be added.\n-     */\n-    private void insertValue(double v) {\n-        // The default value of product is NaN, if you\n-        // try to retrieve the product for a univariate with\n-        // no values, we return NaN.\n-        //\n-        // If this is the first call to insertValue, we want\n-        // to set product to 1.0, so that our first element\n-        // is not \"cancelled\" out by the NaN.\n-        //\n-        // For the first value added, the mean is that value,\n-        // and the variance is zero.\n-        if( n == 0 ) {\n-            product = 1.0 ;\n-            mean = v ;\n-            pre_variance = 0.0 ;\n-            variance = 0.0 ;\n-        }\n-\n-        if( windowSize != Univariate.INFINITE_WINDOW ) {\n-            if( windowSize == n ) {\n-                double discarded = doubleArray.addElementRolling( v );\n-\n-                // Remove the influence of the discarded\n-                sum -= discarded;\n-                sumsq -= discarded * discarded;\n-                sumCube -= Math.pow(discarded, 3);\n-                sumQuad -= Math.pow(discarded, 4);\n-\n-                if(discarded == min) {\n-                    min = doubleArray.getMin();\n-                } else if(discarded == max){\n-                    max = doubleArray.getMax();\n-                }\n-\n-                if(product != 0.0){\n-                    // can safely remove discarded value\n-                    product *= v / discarded;\n-                } else if(discarded == 0.0){\n-                    // need to recompute product\n-                    product = 1.0;\n-                    double[] elements = doubleArray.getElements();\n-                    for( int i = 0; i < elements.length; i++ ) {\n-                        product *= elements[i];\n-                    }\n-                } // else product = 0 and will still be 0 after discard\n-\n-            } else {\n-                doubleArray.addElement( v );\n-                n += 1 ;\n-                if (v < min) {\n-                    min = v;\n-                }\n-                if (v > max) {\n-                    max = v;\n-                }\n-                product *= v;\n-            }\n-        } else {\n-            // If the windowSize is infinite please don't take the time to\n-            // worry about storing any values.  We don't need to discard the\n-            // influence of any single item.\n-            n += 1 ;\n-            if (v < min) {\n-                min = v;\n-            }\n-            if (v > max) {\n-                max = v;\n-            }\n-            product *= v;\n-\n-            if ( n > 1 )\n-            {\n-                double deviationFromMean = v - mean ;\n-                double deviationFromMean_overN = deviationFromMean / n ;\n-                mean += deviationFromMean_overN ;\n-                pre_variance += (n - 1) * deviationFromMean * deviationFromMean_overN ;\n-                variance = pre_variance / (n - 1) ;\n-            }\n-        }\n-\n-        sum += v;\n-        sumsq += v * v;\n-        sumCube += Math.pow(v,3);\n-        sumQuad += Math.pow(v,4);\n-    }\n-\n-    /** Getter for property max.\n-     * @return Value of property max.\n-     */\n-    public double getMax() {\n-        if (n == 0) {\n-            return Double.NaN;\n-        } else {\n-            return max;\n-        }\n-    }\n-\n-    /** Getter for property min.\n-     * @return Value of property min.\n-     */\n-    public double getMin() {\n-        if (n == 0) {\n-            return Double.NaN;\n-        } else {\n-            return min;\n-        }\n-    }\n-\n-    /** Getter for property n.\n-     * @return Value of property n.\n-     */\n-    public int getN() {\n-        return n;\n-    }\n-\n-    /** Getter for property sum.\n-     * @return Value of property sum.\n-     */\n-    public double getSum() {\n-        return sum;\n-    }\n-\n-    /** Getter for property sumsq.\n-     * @return Value of property sumsq.\n-     */\n-    public double getSumsq() {\n-        return sumsq;\n-    }\n-\n-    /** Getter for property sumCube.\n-     * @return Value of property sumCube.\n-     */\n-    public double getSumCube() {\n-        return sumCube;\n-    }\n-\n-    /** Getter for property sumQuad.\n-     * @return Value of property sumQuad.\n-     */\n-    public double getSumQuad() {\n-        return sumQuad;\n-    }\n-\n-    /**\n-     * Generates a text report displaying\n-     * univariate statistics from values that\n-     * have been added.\n-     * @return String with line feeds displaying statistics\n-     */\n-    public String toString() {\n-        StringBuffer outBuffer = new StringBuffer();\n-        outBuffer.append(\"UnivariateImpl:\\n\");\n-        outBuffer.append(\"n: \" + n + \"\\n\");\n-        outBuffer.append(\"min: \" + min + \"\\n\");\n-        outBuffer.append(\"max: \" + max + \"\\n\");\n-        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n-        outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n-        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n-        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n-        return outBuffer.toString();\n-    }\n-\n-    /**\n-     * Resets all sums, product, mean, and variance to 0; resets min and max.\n-     */\n-    public void clear() {\n-        this.sum = this.sumsq = this.sumCube = this.sumQuad = 0.0;\n-        this.n = 0;\n-        this.min = Double.MAX_VALUE;\n-        this.max = Double.MIN_VALUE;\n-        this.product = Double.NaN;\n-        this.mean = Double.NaN ;\n-        this.variance = this.pre_variance = Double.NaN ;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#getWindowSize()\n-     */\n-    public int getWindowSize() {\n-        return windowSize;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-     */\n-    public void setWindowSize(int windowSize) {\n-        String msg = \"A fixed window size must be set via the \" +\n-            \"UnivariateImpl constructor\";\n-        throw new RuntimeException( msg );\n-    }\n-}\n+\t/** hold the window size **/\n+\tprivate int windowSize = Univariate.INFINITE_WINDOW;\n+\n+\t/** Just in case the windowSize is not infinite, we need to\n+\t *  keep an array to remember values 0 to N\n+\t */\n+\tprivate DoubleArray doubleArray;\n+\n+\t/** count of values that have been added */\n+\tprivate int n = 0;\n+\n+\t/** sum of values that have been added */\n+\tprivate double sum = Double.NaN;\n+\n+\t/** sum of the square of each value that has been added */\n+\tprivate double sumsq = Double.NaN;\n+\n+\t/** min of values that have been added */\n+\tprivate double min = Double.NaN;\n+\n+\t/** max of values that have been added */\n+\tprivate double max = Double.NaN;\n+\n+\t/** sumLog of values that have been added */\n+\tprivate double sumLog = Double.NaN;\n+\n+\t/** mean of values that have been added */\n+\tprivate double mean = Double.NaN;\n+\n+\t/** second moment of values that have been added */\n+\tprivate double s2 = Double.NaN;\n+\n+\t/** third moment of values that have been added */\n+\tprivate double s3 = Double.NaN;\n+\n+\t/** fourth moment of values that have been added */\n+\tprivate double s4 = Double.NaN;\n+\n+\t/** variance of values that have been added */\n+\tprivate double variance = Double.NaN;\n+\n+\t/** skewness of values that have been added */\n+\tprivate double skewness = Double.NaN;\n+\n+\t/** kurtosis of values that have been added */\n+\tprivate double kurtosis = Double.NaN;\n+\n+\t/** Creates new univariate with an infinite window */\n+\tpublic UnivariateImpl() {\n+\t}\n+\n+\t/** Creates a new univariate with a fixed window **/\n+\tpublic UnivariateImpl(int window) {\n+\t\tsetWindowSize(window);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getN()\n+\t */\n+\tpublic int getN() {\n+\t\treturn n;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getSum()\n+\t */\n+\tpublic double getSum() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.sum(doubleArray.getElements());\n+\t\t}\n+\n+\t\treturn sum;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getSumsq()\n+\t */\n+\tpublic double getSumsq() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.sumSq(doubleArray.getElements());\n+\t\t}\n+\n+\t\treturn sumsq;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getMean()\n+\t */\n+\tpublic double getMean() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.mean(doubleArray.getElements());\n+\t\t}\n+\n+\t\treturn mean;\n+\t}\n+\n+\t/**\n+\t * Returns the standard deviation for this collection of values\n+\t * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n+\t */\n+\tpublic double getStandardDeviation() {\n+\t\tdouble stdDev = Double.NaN;\n+\t\tif (getN() != 0) {\n+\t\t\tstdDev = Math.sqrt(getVariance());\n+\t\t}\n+\t\treturn (stdDev);\n+\t}\n+\n+\t/**\n+\t * Returns the variance of the values that have been added via West's\n+\t * algorithm as described by\n+\t * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n+\t * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n+\t * vol. 22 no. 9, pp. 526-531.</a>.\n+\t *\n+\t * @return The variance of a set of values.  Double.NaN is returned for\n+\t *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n+\t */\n+\tpublic double getVariance() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\tvariance = StatUtils.variance(doubleArray.getElements());\n+\t\t}\n+\t\treturn variance;\n+\t}\n+\n+\t/**\n+\t * Returns the skewness of the values that have been added as described by\n+\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n+\t *\n+\t * @return The skew of a set of values.  Double.NaN is returned for\n+\t *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n+\t */\n+\tpublic double getSkewness() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.skewness(doubleArray.getElements());\n+\t\t}\n+\t\treturn skewness;\n+\t}\n+\n+\t/**\n+\t * Returns the kurtosis of the values that have been added as described by\n+\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n+\t *\n+\t * @return The kurtosis of a set of values.  Double.NaN is returned for\n+\t *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n+\t */\n+\tpublic double getKurtosis() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.kurtosis(doubleArray.getElements());\n+\t\t}\n+\t\treturn kurtosis;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getMax()\n+\t */\n+\tpublic double getMax() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.max(doubleArray.getElements());\n+\t\t}\n+\t\treturn max;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getMin()\n+\t */\n+\tpublic double getMin() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.min(doubleArray.getElements());\n+\t\t}\n+\t\treturn min;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.Univariate#getProduct()\n+\t */\n+\tpublic double getProduct() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.product(doubleArray.getElements());\n+\t\t}\n+\n+\t\treturn sumLog;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t* @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n+\t*/\n+\tpublic double getGeometricMean() {\n+\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn StatUtils.geometricMean(doubleArray.getElements());\n+\t\t}\n+\n+\t\tif (n == 0) {\n+\t\t\treturn Double.NaN;\n+\t\t} else {\n+\t\t\treturn Math.exp(sumLog / (double) n);\n+\t\t}\n+\t}\n+\n+\t/* If windowSize is set to Infinite, moments are calculated using the following \n+\t * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n+     * recursive strategy\n+     * </a>.\n+     * Otherwise, stat methods delegate to StatUtils.\n+\t * @see org.apache.commons.math.stat.Univariate#addValue(double)\n+\t */\n+\tpublic void addValue(double value) {\n+\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\t/* then all getters deligate to StatUtils\n+\t\t\t * and this clause simply adds/rolls a value in the storage array \n+\t\t\t */\n+\t\t\tif (windowSize == n) {\n+\t\t\t\tdoubleArray.addElementRolling(value);\n+\t\t\t} else {\n+\t\t\t\tn++;\n+\t\t\t\tdoubleArray.addElement(value);\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\t/* If the windowSize is infinite don't store any values and there \n+\t\t\t * is no need to discard the influence of any single item.\n+\t\t\t */\n+\t\t\tn++;\n+\n+\t\t\tif (n <= 1) {\n+\t\t\t\t/* if n <= 1, initialize the sumLog, min, max, mean, variance and pre-variance */\n+\t\t\t\tsumLog = 0.0;\n+\t\t\t\tsum = min = max = mean = value;\n+\t\t\t\tsumsq = Math.pow(value, 2);\n+\t\t\t\tvariance = s2 = 0.0;\n+\t\t\t\tskewness = kurtosis = 0.0;\n+\n+\t\t\t} else {\n+\t\t\t\t/* otherwise calc these values */\n+\t\t\t\tsumLog += Math.log(value);\n+\t\t\t\tsum += value;\n+\t\t\t\tsumsq += Math.pow(value, 2);\n+\t\t\t\tmin = Math.min(min, value);\n+\t\t\t\tmax = Math.max(max, value);\n+\n+\t\t\t\tdouble dev = value - mean;\n+\t\t\t\tdouble v = dev / ((double) n);\n+\t\t\t\tdouble v2 = Math.pow(v, 2);\n+\t\t\t\tdouble n1 = ((double) n - 1);\n+\n+\t\t\t\ts4 += v\n+\t\t\t\t\t* (\n+\t\t\t\t\t\t- 4.0 * s3\n+\t\t\t\t\t\t+ v * (6.0 * s2 + n1 * (1 + Math.pow((double) n, 3)) * v2));\n+\n+\t\t\t\ts3 += v * (-3.0 * s2 + (double) n * n1 * (n - 2) * Math.pow(v, 2));\n+\t\t\t\ts2 += n1 * dev * v;\n+\n+\t\t\t\tmean += v;\n+\t\t\t\tvariance = \n+                    (n <= 1) ? 0.0 : s2 / n1;\n+\t\t\t\tskewness =\n+\t\t\t\t\t(n <= 2) ? 0.0 : s3 / ((double) n * Math.sqrt(variance) * variance);\n+\t\t\t\tkurtosis =\n+\t\t\t\t\t(n <= 3) ? 0.0 : s4 / ((double) n * Math.pow(variance, 2)) - 3;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generates a text report displaying\n+\t * univariate statistics from values that\n+\t * have been added.\n+\t * @return String with line feeds displaying statistics\n+\t */\n+\tpublic String toString() {\n+\t\tStringBuffer outBuffer = new StringBuffer();\n+\t\toutBuffer.append(\"UnivariateImpl:\\n\");\n+\t\toutBuffer.append(\"n: \" + n + \"\\n\");\n+\t\toutBuffer.append(\"min: \" + min + \"\\n\");\n+\t\toutBuffer.append(\"max: \" + max + \"\\n\");\n+\t\toutBuffer.append(\"mean: \" + getMean() + \"\\n\");\n+\t\toutBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n+\t\toutBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n+\t\toutBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+\t\treturn outBuffer.toString();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#clear()\n+\t */\n+\tpublic void clear() {\n+\t\tthis.n = 0;\n+\t\tthis.min = this.max = Double.NaN;\n+\t\tthis.sumLog = this.mean = Double.NaN;\n+\t\tthis.variance = this.skewness = this.kurtosis = Double.NaN;\n+        this.s2 = this.s3 = this.s4 = Double.NaN;\n+\t\tif (doubleArray != null)\n+\t\t\tdoubleArray = new FixedDoubleArray(windowSize);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#getWindowSize()\n+\t */\n+\tpublic int getWindowSize() {\n+\t\treturn windowSize;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+\t */\n+\tpublic void setWindowSize(int windowSize) {\n+\t\tclear();\n+\t\tthis.windowSize = windowSize;\n+\t\tdoubleArray = new FixedDoubleArray(windowSize);\n+\t}\n+\n+}", "timestamp": 1055944055, "metainfo": ""}