{"sha": "0482f58cd0e23a19ad8ed8c0e0a686719141942f", "log": "Fixed localized exception messages according to review of Gilles JIRA: MATH-575  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     CONTRACTION_CRITERIA_SMALLER_THAN_ONE(\"contraction criteria smaller than one ({0}).  This would lead to a never ending loop of expansion and contraction as an internal storage array length equal to the number of elements would satisfy the contraction criteria.\"),\n     CONVERGENCE_FAILED(\"convergence failed\"), /* keep */\n     CROSSING_BOUNDARY_LOOPS(\"some outline boundary loops cross each other\"),\n+    CROSSOVER_RATE(\"crossover rate ({0})\"),\n     CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Cumulative probability function returned NaN for argument {0} p = {1}\"),\n     DIFFERENT_ROWS_LENGTHS(\"some rows have length {0} while others have length {1}\"),\n     DIFFERENT_ORIG_AND_PERMUTED_DATA(\"original and permuted data must contain the same elements\"),\n     DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Discrete cumulative probability function returned NaN for argument {0}\"),\n     DISTRIBUTION_NOT_LOADED(\"distribution not loaded\"),\n     DUPLICATED_ABSCISSA(\"Abscissa {0} is duplicated at both indices {1} and {2}\"),\n+    ELITISM_RATE(\"elitism rate ({0})\"),\n     EMPTY_CLUSTER_IN_K_MEANS(\"empty cluster in k-means\"),\n     EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY(\"empty polynomials coefficients array\"), /* keep */\n     EMPTY_SELECTED_COLUMN_INDEX_ARRAY(\"empty selected column index array\"),\n     INVALID_BINARY_DIGIT(\"invalid binary digit: {0}\"),\n     INVALID_BINARY_CHROMOSOME(\"binary mutation works on BinaryChromosome only\"),\n     INVALID_BRACKETING_PARAMETERS(\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\"),\n-    INVALID_CROSSOVER_CHROMOSOME_LENGTH(\"both chromosomes must have same lengths: ({0}) ({1})\"),\n-    INVALID_FIXED_LENGTH_CHROMOSOME(\"one-point crossover works only on instances of AbstractListChromosome\"),\n+    INVALID_FIXED_LENGTH_CHROMOSOME(\"one-point crossover only works with fixed-length chromosomes\"),\n     INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\"),\n     INVALID_ITERATIONS_LIMITS(\"invalid iteration limits: min={0}, max={1}\"),\n     INVALID_MAX_ITERATIONS(\"bad value for maximum iterations number: {0}\"),\n     MAX_ITERATIONS_EXCEEDED(\"maximal number of iterations ({0}) exceeded\"),\n     MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION(\"minimal step size ({1,number,0.00E00}) reached, integration needs {0,number,0.00E00}\"),\n     MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS(\"Loess expects the abscissa and ordinate arrays to be of the same size, but got {0} abscissae and {1} ordinatae\"),\n+    MUTATION_RATE(\"mutation rate ({0})\"),\n     NAN_ELEMENT_AT_INDEX(\"element {0} is NaN\"),\n     NAN_VALUE_CONVERSION(\"cannot convert NaN value\"),\n     NEGATIVE_BRIGHTNESS_EXPONENT(\"brightness exponent should be positive or null, but got {0}\"),\n     OUT_OF_BOUND_SIGNIFICANCE_LEVEL(\"out of bounds significance level {0}, must be between {1} and {2}\"),\n     SIGNIFICANCE_LEVEL(\"significance level ({0})\"), /* keep */\n     OUT_OF_ORDER_ABSCISSA_ARRAY(\"the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}\"),\n-    OUT_OF_RANGE_CROSSOVER_RATE(\"crossover rate ({0}) out of [{1}, {2}] range\"),\n-    OUT_OF_RANGE_ELITISM_RATE(\"elitism rate ({0}) out of [{1}, {2}] range\"),\n-    OUT_OF_RANGE_MUTATION_RATE(\"mutation rate ({0}) out of [{1}, {2}] range\"),\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n     OUT_OF_RANGE(\"out of range\"), /* keep */\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n     TOO_MUCH_CANCELLATION(\"too much cancellation in a denominator\"),\n     TOO_MANY_REGRESSORS(\"too many regressors ({0}) specified, only {1} in the model\"),\n     TOO_SMALL_COST_RELATIVE_TOLERANCE(\"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\"),\n-    TOO_SMALL_GENERATION_COUNT(\"number of generations ({0}) must be >= {1}\"),\n     TOO_SMALL_INTEGRATION_INTERVAL(\"too small integration interval: length = {0}\"),\n     TOO_SMALL_ORTHOGONALITY_TOLERANCE(\"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\"),\n     TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE(\"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\"),\n     WEIGHT_AT_LEAST_ONE_NON_ZERO(\"weigth array must contain at least one non-zero value\"),\n     WRONG_BLOCK_LENGTH(\"wrong array shape (block length = {0}, expected {1})\"),\n     WRONG_NUMBER_OF_POINTS(\"{0} points are required, got only {1}\"),\n-    WRONG_SEQUENCE_LENGTH_RANDOMKEY(\"length of sequence for decoding ({0}) has to be equal to the RandomKey length ({1})\"),\n-    WRONG_REPR_AND_SREPR_SIZE(\"size of representation and sorted representation must be equals: {0} != {1}\"),\n-    WRONG_ORIG_AND_PERMUTED_SIZE(\"original and permuted data must have same length: {0} != {1}\"),\n     NUMBER_OF_POINTS(\"number of points ({0})\"), /* keep */\n     ZERO_DENOMINATOR(\"denominator must be different from 0\"),\n     ZERO_DENOMINATOR_IN_FRACTION(\"zero denominator in fraction {0}/{1}\"),\n--- a/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n      */\n     public void setElitismRate(final double elitismRate) {\n         if (elitismRate < 0 || elitismRate > 1) {\n-            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_ELITISM_RATE, elitismRate, 0, 1);\n+            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n         }\n         this.elitismRate = elitismRate;\n     }\n--- a/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n+++ b/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n package org.apache.commons.math.genetics;\n \n import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * Stops after a fixed number of generations.  Each time\n      */\n     public FixedGenerationCount(final int maxGenerations) {\n         if (maxGenerations <= 0) {\n-            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_GENERATION_COUNT,\n-                                                maxGenerations, 1, true);\n+            throw new NumberIsTooSmallException(maxGenerations, 1, true);\n         }\n         this.maxGenerations = maxGenerations;\n     }\n--- a/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n                             final SelectionPolicy selectionPolicy) {\n \n         if (crossoverRate < 0 || crossoverRate > 1) {\n-            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_CROSSOVER_RATE,\n+            throw new OutOfRangeException(LocalizedFormats.CROSSOVER_RATE,\n                                           crossoverRate, 0, 1);\n         }\n         if (mutationRate < 0 || mutationRate > 1) {\n-            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_MUTATION_RATE,\n+            throw new OutOfRangeException(LocalizedFormats.MUTATION_RATE,\n                                           mutationRate, 0, 1);\n         }\n         this.crossoverPolicy = crossoverPolicy;\n--- a/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n      * @param second second parent (p2)\n      * @return pair of two children (c1,c2)\n      * @throws MathIllegalArgumentException iff one of the chromosomes is\n-     *         not an instance of {@link AbstractListChromosome} or the length\n-     *         of the two chromosomes is not equal\n+     *         not an instance of {@link AbstractListChromosome}\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n     public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n      * @param first the first chromosome.\n      * @param second the second chromosome.\n      * @return the pair of new chromosomes that resulted from the crossover.\n-     * @throws MathIllegalArgumentException if the length of the two chromosomes is different\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     private ChromosomePair crossover(final AbstractListChromosome<T> first,\n                                      final AbstractListChromosome<T> second) {\n         int length = first.getLength();\n         if (length != second.getLength()) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_CROSSOVER_CHROMOSOME_LENGTH,\n-                                                   length, second.getLength());\n+            throw new DimensionMismatchException(second.getLength(), length);\n         }\n \n         // array representations of the parents\n--- a/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n import java.util.Comparator;\n import java.util.List;\n \n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n      * @param representation representation of the permutation ([0,1] vector)\n      * @param sortedRepr sorted <code>representation</code>\n      * @return list with the sequence values permuted according to the representation\n+     * @throws DimensionMismatchException iff the length of the <code>sequence</code>,\n+     * <code>representation</code> or <code>sortedRepr</code> lists are not equal\n      */\n     private static <S> List<S> decodeGeneric(final List<S> sequence, List<Double> representation,\n                                              final List<Double> sortedRepr) {\n         int l = sequence.size();\n \n+        // the size of the three lists must be equal\n         if (representation.size() != l) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.WRONG_SEQUENCE_LENGTH_RANDOMKEY,\n-                                                   l, representation.size());\n-        }\n-        if (representation.size() != sortedRepr.size()) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.WRONG_REPR_AND_SREPR_SIZE,\n-                                                   representation.size(), sortedRepr.size());\n-        }\n-\n-        List<Double> reprCopy = new ArrayList<Double> (representation);// do not modify the orig. representation\n+            throw new DimensionMismatchException(representation.size(), l);\n+        }\n+        if (sortedRepr.size() != l) {\n+            throw new DimensionMismatchException(sortedRepr.size(), l);\n+        }\n+\n+        // do not modify the original representation\n+        List<Double> reprCopy = new ArrayList<Double> (representation);\n \n         // now find the indices in the original repr and use them for permuting\n         List<S> res = new ArrayList<S> (l);\n \n         for (double val : chromosomeRepresentation) {\n             if (val < 0 || val > 1) {\n-                throw new InvalidRepresentationException(LocalizedFormats.OUT_OF_RANGE_SIMPLE, val, 0, 1);\n+                throw new InvalidRepresentationException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                                                         val, 0, 1);\n             }\n         }\n     }\n      * @param permutedData the data, somehow permuted\n      * @return representation of a permutation corresponding to the permutation\n      * <code>originalData -> permutedData</code>\n-     * @throws IllegalArgumentException iff the <code>permutedData</code> and\n-     * <code>originalData</code> contains different data\n+     * @throws DimensionMismatchException iff the length of <code>originalData</code>\n+     * and <code>permutedData</code> lists are not equal\n+     * @throws MathIllegalArgumentException iff the <code>permutedData</code> and\n+     * <code>originalData</code> lists contain different data\n      */\n     public static <S> List<Double> inducedPermutation(final List<S> originalData,\n-                                                      final List<S> permutedData)\n-        throws IllegalArgumentException {\n+                                                      final List<S> permutedData) {\n \n         if (originalData.size() != permutedData.size()) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.WRONG_ORIG_AND_PERMUTED_SIZE,\n-                                                   originalData.size(), permutedData.size());\n+            throw new DimensionMismatchException(permutedData.size(), originalData.size());\n         }\n         int l = originalData.size();\n ", "timestamp": 1327400233, "metainfo": ""}