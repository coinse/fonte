{"sha": "74c289e6cc999fec27551b7e16fb6245b1352a37", "log": "Removed completely MathUserException.  JIRA: MATH-195  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      */\n     public double inverseCumulativeProbability(final double p)\n         throws MathException {\n+        try {\n+\n         if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         }\n         // subclasses can override if there is a better method.\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n-            public double value(double x) throws MathUserException {\n+            public double value(double x) {\n                 double ret = Double.NaN;\n                 try {\n                     ret = cumulativeProbability(x) - p;\n                 } catch (MathException ex) {\n-                    throw new MathUserException(ex);\n+                    throw new WrappingException(ex);\n                 }\n                 if (Double.isNaN(ret)) {\n-                    throw new MathUserException(LocalizedFormats.CUMULATIVE_PROBABILITY_RETURNED_NAN, x, p);\n+                    throw new WrappingException(new MathException(LocalizedFormats.CUMULATIVE_PROBABILITY_RETURNED_NAN, x, p));\n                 }\n                 return ret;\n             }\n                 // absolute accuracy different from the default.\n                 bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n         return root;\n+\n+        } catch (WrappingException we) {\n+            throw we.getWrapped();\n+        }\n+    }\n+\n+    /** Local exception wrapping a MathException. */\n+    private static class WrappingException extends RuntimeException {\n+\n+        /** Serializable UID. */\n+        private static final long serialVersionUID = -2102700399222815344L;\n+\n+        /** Wrapped exception. */\n+        private final MathException wrapped;\n+\n+        /** simple constructor.\n+         * @param wrapped exception to wrap\n+         */\n+        public WrappingException(final MathException wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        /** Get the wrapped exception.\n+         * @return wrapped exception\n+         */\n+        public MathException getWrapped() {\n+            return wrapped;\n+        }\n+\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.AbstractIntegrator;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n      * elements will be null if the {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n-     * optimize} method did throw a {@link MathUserException}).\n+     * optimize} method did throw an exception.\n      * This also means that if the first element is not {@code null}, it\n      * is the best point found across all starts.\n      *\n                                        final GoalType goal,\n                                        double[] startPoint) {\n         maxEvaluations = maxEval;\n-        MathUserException lastException = null;\n+        RuntimeException lastException = null;\n         optima = new RealPointValuePair[starts];\n         totalEvaluations = 0;\n \n             try {\n                 optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal,\n                                                i == 0 ? startPoint : generator.nextVector());\n-            } catch (MathUserException mue) {\n+            } catch (RuntimeException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n             }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n                                             double[] target, double[] weights,\n                                             double[] startPoint) {\n         maxEvaluations = maxEval;\n-        MathUserException lastException = null;\n+        RuntimeException lastException = null;\n         optima = new VectorialPointValuePair[starts];\n         totalEvaluations = 0;\n \n             try {\n                 optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, target, weights,\n                                                i == 0 ? startPoint : generator.nextVector());\n-            } catch (MathUserException mue) {\n+            } catch (ConvergenceException oe) {\n+                optima[i] = null;\n+            } catch (RuntimeException mue) {\n                 lastException = mue;\n-                optima[i] = null;\n-            } catch (ConvergenceException oe) {\n                 optima[i] = null;\n             }\n \n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * objective function throws one during search.\n      */\n     RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                 double[] startPoint);\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * function throws one during search.\n      */\n     VectorialPointValuePair optimize(int maxEval, FUNC f, double[] target,\n                                      double[] weight, double[] startPoint);\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.RealMatrix;\n \n /** This class converts {@link MultivariateVectorialFunction vectorial\n     }\n \n     /** {@inheritDoc} */\n-    public double value(final double[] point) throws MathUserException {\n+    public double value(final double[] point) {\n         // compute residuals\n         final double[] residuals = function.value(point);\n         if (residuals.length != observations.length) {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.ZeroException;\n      * to worst.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the algorithm fails to converge.\n-     * @throws MathUserException if evaluation function throws one\n      */\n     public abstract void iterate(final MultivariateRealFunction evaluationFunction,\n-                                 final Comparator<RealPointValuePair> comparator)\n-        throws MathUserException;\n+                                 final Comparator<RealPointValuePair> comparator);\n \n     /**\n      * Build an initial simplex.\n      * @param comparator Comparator to use to sort simplex vertices from best to worst.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n-     * @throws MathUserException if evaluation function throws one\n      */\n     public void evaluate(final MultivariateRealFunction evaluationFunction,\n-                         final Comparator<RealPointValuePair> comparator)\n-        throws MathUserException {\n+                         final Comparator<RealPointValuePair> comparator) {\n         // Evaluate the objective function at all non-evaluated simplex points.\n         for (int i = 0; i < simplex.length; i++) {\n             final RealPointValuePair vertex = simplex[i];\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n      * @return the objective function value at the specified point.\n      * @throws TooManyEvaluationsException if the maximal number of\n      * evaluations is exceeded.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * objective function throws one.\n      */\n     protected double computeObjectiveValue(double[] point) {\n         try {\n      *\n      * @return the point/value pair giving the optimal value for the\n      * objective function.\n-     * @throws org.apache.commons.math.exception.MathUserException if\n-     * the objective function throws one.\n      */\n     protected abstract RealPointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n      * @return the objective function value at the specified point.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * objective function throws one.\n      */\n     protected double[] computeObjectiveValue(double[] point) {\n         try {\n      *\n      * @return the point/value pair giving the optimal value for the\n      * objective function.\n-     * @throws org.apache.commons.math.exception.MathUserException if\n-     * the function throws one during search.\n      */\n     protected abstract VectorialPointValuePair doOptimize();\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateRealFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator)\n-        throws MathUserException {\n+                        final Comparator<RealPointValuePair> comparator) {\n         // Save the original simplex.\n         final RealPointValuePair[] original = getPoints();\n         final RealPointValuePair best = original[0];\n      * @return the best point in the transformed simplex.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n-     * @throws MathUserException if function cannot be evaluated at some points\n      */\n     private RealPointValuePair evaluateNewSimplex(final MultivariateRealFunction evaluationFunction,\n                                                   final RealPointValuePair[] original,\n                                                   final double coeff,\n-                                                  final Comparator<RealPointValuePair> comparator)\n-        throws MathUserException {\n+                                                  final Comparator<RealPointValuePair> comparator) {\n         final double[] xSmallest = original[0].getPointRef();\n         // Perform a linear transformation on all the simplex points,\n         // except the first one.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n \n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This class implements the Nelder-Mead simplex algorithm.\n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateRealFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator)\n-        throws MathUserException {\n+                        final Comparator<RealPointValuePair> comparator) {\n         // The simplex has n + 1 points if dimension is n.\n         final int n = getDimension();\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n          * @return the optimum.\n          * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n          * if the number of evaluations is exceeded.\n-         * @throws org.apache.commons.math.exception.MathUserException if the\n-         * objective function throws one.\n          */\n         public UnivariateRealPointValuePair search(final double[] p, final double[] d) {\n             final int n = p.length;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() throws MathUserException {\n+    protected RealPointValuePair doOptimize() {\n         if (simplex == null) {\n             throw new NullArgumentException();\n         }\n         // evaluations counter.\n         final MultivariateRealFunction evalFunc\n             = new MultivariateRealFunction() {\n-                public double value(double[] point) throws MathUserException {\n+                public double value(double[] point) {\n                     return computeObjectiveValue(point);\n                 }\n             };\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n      * @return the fitted parameters.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * parametric function throws one.\n      */\n     public double[] fit(final ParametricUnivariateRealFunction f, final double[] initialGuess) {\n         return fit(Integer.MAX_VALUE, f, initialGuess);\n      * if the number of allowed evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * parametric function throws one.\n      */\n     public double[] fit(int maxEval, final ParametricUnivariateRealFunction f,\n                         final double[] initialGuess) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n      *\n      * @throws DimensionMismatchException if the Jacobian dimension does not\n      * match problem dimension.\n-     * @throws org.apache.commons.math.exception.MathUserException if the jacobian\n-     * function throws one.\n      */\n     protected void updateJacobian() {\n         ++jacobianEvaluations;\n      * @return the covariance matrix.\n      * @throws org.apache.commons.math.linear.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * jacobian function throws one.\n      */\n     public double[][] getCovariances() {\n         // set up the jacobian\n      * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n      * positive, i.e. the number of measurements is less or equal to the number of\n      * parameters.\n-     * @throws org.apache.commons.math.exception.MathUserException if the jacobian\n-     * function throws one.\n      */\n     public double[] guessParametersErrors() {\n         if (rows <= cols) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n \n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n      * @return the gradient at the specified point.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the allowed number of evaluations is exceeded.\n-     * @throws MathUserException if objective function gradient throws one\n      */\n-    protected double[] computeObjectiveGradient(final double[] evaluationPoint)\n-        throws MathUserException {\n+    protected double[] computeObjectiveGradient(final double[] evaluationPoint) {\n         return gradient.value(evaluationPoint);\n     }\n \n     public RealPointValuePair optimize(int maxEval,\n                                        final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n-                                       final double[] startPoint) throws MathUserException {\n+                                       final double[] startPoint) {\n         // Store optimization problem characteristics.\n         gradient = f.gradient();\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.exception.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    public VectorialPointValuePair doOptimize() throws MathUserException {\n+    public VectorialPointValuePair doOptimize() {\n \n         final ConvergenceChecker<VectorialPointValuePair> checker\n             = getConvergenceChecker();\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected VectorialPointValuePair doOptimize() throws MathUserException {\n+    protected VectorialPointValuePair doOptimize() {\n         // arrays shared with the other private methods\n         solvedCols  = FastMath.min(rows, cols);\n         diagR       = new double[cols];\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n      * @param h initial step to try.\n      * @return b such that f(a) and f(b) have opposite signs.\n      * @throws MathIllegalStateException if no bracket can be found.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * function throws one.\n      */\n     private double findUpperBound(final UnivariateRealFunction f,\n                                   final double a, final double h) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n      * @return the objective function value at specified point.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * objective function throws one.\n      */\n     protected double computeObjectiveValue(double point) {\n         try {\n      * @return the optimum and its corresponding function value.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * function to optimize throws one during search.\n      */\n     protected abstract UnivariateRealPointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n      * if the optimizer detects a convergence problem.\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * function to optimize throws one during search.\n      */\n     UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                           double min, double max);\n      * do not satisfy the requirements specified by the optimizer.\n      * @throws org.apache.commons.math.exception.NullArgumentException if any\n      * argument is {@code null}.\n-     * @throws org.apache.commons.math.exception.MathUserException if the\n-     * function to optimize throws one during search.\n      */\n     UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                           double min, double max,\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n      * @param xB Initial point.\n      * @throws TooManyEvaluationsException if the maximum number of evaluations\n      * is exceeded.\n-     * @throws MathUserException if function throw one\n-     */\n-    public void search(UnivariateRealFunction func, GoalType goal, double xA, double xB)\n-        throws MathUserException {\n+     */\n+    public void search(UnivariateRealFunction func, GoalType goal, double xA, double xB) {\n         evaluations.resetCount();\n         final boolean isMinim = goal == GoalType.MINIMIZE;\n \n      * @return {@code f(x)}\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n-     * @throws MathUserException if f throws one.\n-     */\n-    private double eval(UnivariateRealFunction f, double x) throws MathUserException {\n+     */\n+    private double eval(UnivariateRealFunction f, double x) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n \n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealPointValuePair doOptimize() throws MathUserException {\n+    protected UnivariateRealPointValuePair doOptimize() {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final double lo = getMin();\n         final double mid = getStartValue();\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n      * corresponding to the runs that did not converge. This means all\n      * elements will be {@code null} if the {@link\n      * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n-     * method did throw a {@link MathUserException}).\n+     * method did throw an exception.\n      * This also means that if the first element is not {@code null}, it is\n      * the best point found across all starts.\n      *\n                                                  final GoalType goal,\n                                                  final double min, final double max,\n                                                  final double startValue) {\n-        MathUserException lastException = null;\n+        RuntimeException lastException = null;\n         optima = new UnivariateRealPointValuePair[starts];\n         totalEvaluations = 0;\n \n             try {\n                 final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n                 optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal, min, max, s);\n-            } catch (MathUserException mue) {\n+            } catch (RuntimeException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n             }\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.OutOfRangeException;\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.NoDataException;\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import org.junit.Assert;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.OutOfRangeException;\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n         Assert.assertEquals(100, optimizer.getMaxEvaluations());\n     }\n \n-    @Test(expected = MathUserException.class)\n+    @Test(expected = TestException.class)\n     public void testNoOptimum() {\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true);\n                     return null;\n                 }\n                 public double[] value(double[] point) {\n-                    throw new MathUserException();\n+                    throw new TestException();\n                 }\n             }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });\n+    }\n+\n+    private static class TestException extends RuntimeException {\n+        private static final long serialVersionUID = -7809988995389067683L;\n     }\n \n     private static class LinearProblem implements DifferentiableMultivariateVectorialFunction {\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n \n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.optimization.direct.NelderMeadSimplex;\n import org.apache.commons.math.optimization.direct.SimplexOptimizer;\n-import org.apache.commons.math.optimization.direct.NelderMeadSimplex;\n import org.apache.commons.math.random.GaussianRandomGenerator;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n public class MultiStartMultivariateRealOptimizerTest {\n     @Test\n-    public void testRosenbrock() throws MathUserException {\n+    public void testRosenbrock() {\n         Rosenbrock rosenbrock = new Rosenbrock();\n         SimplexOptimizer underlying = new SimplexOptimizer();\n         NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n public class CurveFitterTest {\n \n     @Test\n-    public void testMath303()\n-        throws MathUserException {\n+    public void testMath303() {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter fitter = new CurveFitter(optimizer);\n     }\n \n     @Test\n-    public void testMath304()\n-        throws MathUserException {\n+    public void testMath304() {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter fitter = new CurveFitter(optimizer);\n     }\n \n     @Test\n-    public void testMath372()\n-    throws MathUserException {\n+    public void testMath372() {\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter curveFitter = new CurveFitter(optimizer);\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import java.util.Arrays;\n \n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.SimpleVectorialPointChecker;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.FastMath;\n public class GaussNewtonOptimizerTest {\n \n     @Test\n-    public void testTrivial() throws MathUserException {\n+    public void testTrivial() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n \n     }\n \n     @Test\n-    public void testColumnsPermutation() throws MathUserException {\n+    public void testColumnsPermutation() {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n     }\n \n     @Test\n-    public void testNoDependency() throws MathUserException {\n+    public void testNoDependency() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n     }\n \n     @Test\n-    public void testOneSet() throws MathUserException {\n+    public void testOneSet() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n     }\n \n     @Test\n-    public void testTwoSets() throws MathUserException {\n+    public void testTwoSets() {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n     }\n \n     @Test\n-    public void testIllConditioned() throws MathUserException {\n+    public void testIllConditioned() {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n     }\n \n     @Test\n-    public void testRedundantEquations() throws MathUserException {\n+    public void testRedundantEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n     }\n \n     @Test\n-    public void testInconsistentEquations() throws MathUserException {\n+    public void testInconsistentEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n     }\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void testInconsistentSizes1() throws MathUserException {\n+    public void testInconsistentSizes1() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n \n     }\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void testInconsistentSizes2() throws MathUserException {\n+    public void testInconsistentSizes2() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n \n     }\n \n     @Test\n-    public void testCircleFitting() throws MathUserException {\n+    public void testCircleFitting() {\n         CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n     }\n \n     @Test(expected=ConvergenceException.class)\n-    public void testCircleFittingBadInit() throws MathUserException {\n+    public void testCircleFittingBadInit() {\n         CircleVectorial circle = new CircleVectorial();\n         double[][] points = circlePoints;\n         double[] target = new double[points.length];\n     }\n \n     @Test\n-    public void testCircleFittingGoodInit() throws MathUserException {\n+    public void testCircleFittingGoodInit() {\n         CircleVectorial circle = new CircleVectorial();\n         double[][] points = circlePoints;\n         double[] target = new double[points.length];\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n import java.util.Arrays;\n \n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n           function.checkTheoreticalMinParams(optimum);\n       } catch (TooManyEvaluationsException e) {\n           Assert.assertTrue(exceptionExpected);\n-      } catch (MathUserException fe) {\n-          Assert.assertTrue(exceptionExpected);\n       }\n   }\n \n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n         UnivariateRealFunction f = new UnivariateRealFunction() {\n                 public double value(double x) {\n                     if (x < 0) {\n-                        throw new MathUserException();\n+                        throw new LocalException();\n                     }\n                     return 0;\n                 }\n         try {\n             optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n             Assert.fail();\n-        } catch (MathUserException e) {\n+        } catch (LocalException e) {\n             // Expected.\n         }\n \n         // Ensure that the exception was thrown because no optimum was found.\n         Assert.assertTrue(optimizer.getOptima()[0] == null);\n     }\n+\n+    private static class LocalException extends RuntimeException {\n+        private static final long serialVersionUID = 1194682757034350629L;\n+    }\n+\n }", "timestamp": 1315421286, "metainfo": ""}