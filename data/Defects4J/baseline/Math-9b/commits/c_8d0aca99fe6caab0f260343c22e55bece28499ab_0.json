{"sha": "8d0aca99fe6caab0f260343c22e55bece28499ab", "log": "Bugzilla #22002: applied Brent W's patch which dealt with URSFactory and URSFImpl as well as numerous improvements to javadoc   ", "commit": "\n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n /**\n  * Signals a configuration problem with any of the factory methods.\n  * \n- * @version $Revision: 1.4 $ $Date: 2003/07/09 20:02:44 $\n+ * @version $Revision: 1.5 $ $Date: 2003/07/30 21:58:10 $\n  */\n public class MathConfigurationException extends MathException {\n \n     /**\n-     * \n+     * Default constructor.\n      */\n     public MathConfigurationException() {\n         super();\n     }\n \n     /**\n+     * Construct an exception with the given message.\n      * @param message message describing the problem\n      */\n     public MathConfigurationException(String message) {\n     }\n \n     /**\n+     * Construct an exception with the given message and root cause.\n      * @param message message describing the problem\n      * @param throwable caught exception causing this problem\n      */\n     }\n \n     /**\n+     * Construct an exception with the given root cause.\n      * @param throwable caught exception causing this problem\n      */\n     public MathConfigurationException(Throwable throwable) {\n         super(throwable);\n     }\n-\n }\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n /**\n  * Computes a natural spline interpolation for the data set.\n  *\n- * @version $Revision: 1.2 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.3 $ $Date: 2003/07/30 21:58:10 $\n  *\n  */\n public class SplineInterpolator implements UnivariateRealInterpolator {\n-    private double[][] c = null ;\n+    private double[][] c = null;\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealInterpolator#interpolate(double[], double[])\n+    /**\n+     * Computes an interpolating function for the data set.\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolationg algorithm\n      */\n     public UnivariateRealFunction interpolate(double[] xval, double[] yval) {\n         if (xval.length != yval.length) {\n-            throw new IllegalArgumentException(\"Dataset arrays must have same length.\");\n+            throw new IllegalArgumentException(\n+                \"Dataset arrays must have same length.\");\n         }\n \n-        if ( c == null )\n-        {\n+        if (c == null) {\n             // Number of intervals. The number of data points is N+1.\n             int n = xval.length - 1;\n             // Check whether the xval vector has ascending values.\n             // Separation should be checked too (not implemented: which criteria?).\n             for (int i = 0; i < n; i++) {\n-                if (xval[i]>=xval[i+1]) {\n-                    throw new IllegalArgumentException(\"Dataset must specify sorted, ascending x values.\");\n+                if (xval[i] >= xval[i + 1]) {\n+                    throw new IllegalArgumentException(\n+                        \"Dataset must specify sorted, ascending x values.\");\n                 }\n             }\n             // Vectors for the equation system. There are n-1 equations for the unknowns s[i] (1<=i<=N-1),\n                 //    (yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1])\n                 // take it from the previous loop pass. Note: the interesting part of performance\n                 // loss is the range check in the array access, not the computation itself.\n-                b[i] =\n-                    6.0\n-                        * ((yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1])\n-                            - (yval[i + 1] - yval[i]) / (xval[i + 1] - xval[i]));\n+                b[i] = 6.0 * ((yval[i + 2] - yval[i + 1]) / (xval[i + 2] - \n+                    xval[i + 1]) - (yval[i + 1] - yval[i]) / (xval[i + 1] -\n+                    xval[i]));\n                 d[i] = 2.0 * (xval[i + 2] - xval[i]);\n             }\n             // Set up upper and lower diagonal. Keep the offsets in mind.\n             c = new double[n][4];\n             c[0][3] = d[0] / (xval[1] - xval[0]) / 6.0;\n             c[0][2] = 0.0;\n-            c[0][1] =\n-                (yval[1] - yval[0]) / (xval[1] - xval[0])\n-                    - d[0] * (xval[1] - xval[0]) / 6.0;\n+            c[0][1] = (yval[1] - yval[0]) / (xval[1] - xval[0]) - d[0] * \n+                (xval[1] - xval[0]) / 6.0;\n             for (int i = 1; i < n - 2; i++) {\n                 // TODO: This relies on compiler for CSE of xval[i + 1] - xval[i]. Is this a reasonable assumption?\n                 c[i][3] = (d[i] - d[i - 1]) / (xval[i + 1] - xval[i]) / 6.0;\n                 c[i][2] = d[i - 1] / 2.0;\n-                c[i][1] =\n-                    (yval[i + 1] - yval[i]) / (xval[i + 1] - xval[i])\n-                        - d[i] * (xval[i + 1] - xval[i]) / 6.0\n-                        - d[i\n-                        - 1] * (xval[i + 1] - xval[i]) / 3.0;\n+                c[i][1] = (yval[i + 1] - yval[i]) / (xval[i + 1] - xval[i]) -\n+                    d[i] * (xval[i + 1] - xval[i]) / 6.0 - d[i - 1] * \n+                    (xval[i + 1] - xval[i]) / 3.0;\n             }\n             // TODO: again, CSE aspects.\n             c[n - 1][3] = -d[n - 2] / (xval[n] - xval[n - 1]) / 6.0;\n             c[n - 1][2] = d[n - 2] / 2.0;\n-            c[n - 1][1] =\n-                (yval[n] - yval[n - 1]) / (xval[n] - xval[n - 1])\n-                    - d[n\n-                    - 2] * (xval[n] - xval[n - 1]) / 3.0;\n+            c[n - 1][1] = (yval[n] - yval[n - 1]) / (xval[n] - xval[n - 1]) -\n+                d[n - 2] * (xval[n] - xval[n - 1]) / 3.0;\n             for (int i = 0; i < n; i++) {\n                 c[i][0] = yval[i];\n             }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  * that derivatives are evaluated after the value, the evaluation algorithm\n  * should throw an InvalidStateException if it can't cope with this.\n  *  \n- * @version $Revision: 1.3 $ $Date: 2003/07/11 15:59:14 $\n+ * @version $Revision: 1.4 $ $Date: 2003/07/30 21:58:10 $\n  */\n public interface UnivariateRealFunction {\n     /**\n      * @return the value\n      * @throws MathException if the function couldn't be computed due to\n      *  missing additional data or other environmental problems.\n-     * @throws RuntimeException if the operation isn't supported, the argument\n-     *  was outside the supported domain or any other problem.\n      */\n     public double value(double x) throws MathException;\n \n      * @param x the point for which the first derivative should be computed\n      * @return the value\n      * @throws MathException if the derivative couldn't be computed.\n-     * @throws RuntimeException if the operation isn't supported, the argument\n-     *  was outside the supported domain or any other problem.\n      */\n     public double firstDerivative(double x) throws MathException;\n \n      * @param x the point for which the first derivative should be computed\n      * @return the value\n      * @throws MathException if the second derivative couldn't be computed.\n-     * @throws RuntimeException if the operation isn't supported, the argument\n-     *  was outside the supported domain or any other problem.\n      */\n     public double secondDerivative(double x) throws MathException;\n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  */\n package org.apache.commons.math.analysis;\n \n-import java.lang.reflect.InvocationTargetException;\n-\n-import org.apache.commons.math.MathConfigurationException;\n-import org.apache.commons.math.MathException;\n-\n /**\n  * A factory to easily get a default solver and some convenience\n  * functions.\n  * (this may be controversial, because the configuration data\n  * may also be used for the default solver used by the static\n  * solve() method). \n- * @version $Revision: 1.3 $ $Date: 2003/07/11 15:59:14 $\n+ * @version $Revision: 1.4 $ $Date: 2003/07/30 21:58:10 $\n  */\n-public class UnivariateRealSolverFactory {\n+public abstract class UnivariateRealSolverFactory {\n     /**\n      * Default constructor.\n      */\n-    private UnivariateRealSolverFactory() {\n+    protected UnivariateRealSolverFactory() {\n     }\n \n     /**\n+     * @return a new factory.\n+     * @todo add comment\n+     * @todo for now, return the only concrete factory.  Later, allow for a\n+     *       plugable implementation, possibly using SPI and commons-discovery.\n+     */\n+    public static UnivariateRealSolverFactory newInstance() {\n+        return new UnivariateRealSolverFactoryImpl();\n+    }\n+    \n+    /**\n      * Create a new {@link UnivariateRealSolver} for the given function.  The\n-     * actual solver returned can be controlled by defining the\n-     * <code>org.apache.commons.math.analysis.UnivariateRealSolver</code>\n-     * property on the JVM command-line (<code>\n-     * -Dorg.apache.commons.math.analysis.UnivariateRealSolver=\n-     * <i>class name</i></code>).  The value of the property should be any,\n-     * fully qualified class name for a type that implements the\n-     * {@link UnivariateRealSolver} interface.  By default, an instance of\n-     * {@link BrentSolver} is returned.\n+     * actual solver returned is determined by the underlying factory.\n      * @param f the function.\n      * @return the new solver.\n-     * @throws MathConfigurationException if a\n      */\n-    public static UnivariateRealSolver newSolver(UnivariateRealFunction f)\n-        throws MathConfigurationException {\n-        String solverClassName =\n-            System.getProperty(\n-                \"org.apache.commons.math.analysis.UnivariateRealSolver\",\n-                \"org.apache.commons.math.analysis.BrentSolver\");\n-        try {\n-            Class clazz = Class.forName(solverClassName);\n-            Class paramClass[] = new Class[1];\n-            paramClass[0] = UnivariateRealFunction.class;\n-            Object param[] = new Object[1];\n-            param[0] = f;\n-            return (UnivariateRealSolver)clazz.getConstructor(\n-                paramClass).newInstance(\n-                param);\n-        } catch (IllegalArgumentException e) {\n-            throw new MathConfigurationException(e);\n-        } catch (SecurityException e) {\n-            throw new MathConfigurationException(\n-                \"Can't access \" + solverClassName,\n-                e);\n-        } catch (ClassNotFoundException e) {\n-            throw new MathConfigurationException(\n-                \"Class not found: \" + solverClassName,\n-                e);\n-        } catch (InstantiationException e) {\n-            throw new MathConfigurationException(\n-                \"Can't instantiate \" + solverClassName,\n-                e);\n-        } catch (IllegalAccessException e) {\n-            throw new MathConfigurationException(\n-                \"Can't access \" + solverClassName,\n-                e);\n-        } catch (InvocationTargetException e) {\n-            throw new MathConfigurationException(e);\n-        } catch (NoSuchMethodException e) {\n-            throw new MathConfigurationException(\n-                \"No constructor with UnivariateRealFunction in \" +\n-                solverClassName,\n-                e);\n-        }\n-    }\n-\n+    public abstract UnivariateRealSolver newDefaultSolver(\n+        UnivariateRealFunction f);\n+    \n     /**\n-     * Convience method to solve for zeros of real univariate functions.  A\n-     * default solver is created and used for solving. \n+     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * solver is an implementation of the bisection method.\n      * @param f the function.\n-     * @param x0 the lower bound for the interval.\n-     * @param x1 the upper bound for the interval.\n-     * @return a value where the function is zero.\n-     * @throws MathException if the iteration count was exceeded or the\n-     *         solver detects convergence problems otherwise.\n+     * @return the new solver.\n      */\n-    public static double solve(UnivariateRealFunction f, double x0, double x1)\n-        throws MathException {\n-        return newSolver(f).solve(x0, x1);\n-    }\n-\n+    public abstract UnivariateRealSolver newBisectionSolver(\n+        UnivariateRealFunction f);\n+    \n     /**\n-     * Convience method to solve for zeros of real univariate functions.  A\n-     * default solver is created and used for solving. \n+     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * solver is an implementation of the Brent method.\n      * @param f the function.\n-     * @param x0 the lower bound for the interval.\n-     * @param x1 the upper bound for the interval.\n-     * @param absoluteAccuracy the accuracy to be used by the solver.\n-     * @return a value where the function is zero.\n-     * @throws MathException if the iteration count was exceeded or the\n-     *         solver detects convergence problems otherwise.\n+     * @return the new solver.\n      */\n-    public static double solve(\n-        UnivariateRealFunction f,\n-        double x0,\n-        double x1,\n-        double absoluteAccuracy)\n-        throws MathException {\n-        UnivariateRealSolver solver = newSolver(f);\n-        solver.setAbsoluteAccuracy(absoluteAccuracy);\n-        return solver.solve(x0, x1);\n-    }\n+    public abstract UnivariateRealSolver newBrentSolver(\n+        UnivariateRealFunction f);\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * solver is an implementation of the secant method.\n+     * @param f the function.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newSecantSolver(\n+        UnivariateRealFunction f);\n }\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.RootFinding;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealSolverFactory;\n+import org.apache.commons.math.analysis.UnivariateRealSolverUtil;\n \n /**\n  * Base class for various continuous distributions.  It provides default\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.7 $ $Date: 2003/07/09 20:03:23 $\n+ * @version $Revision: 1.8 $ $Date: 2003/07/30 21:58:11 $\n  */\n public abstract class AbstractContinuousDistribution\n     implements ContinuousDistribution {\n                 getDomainUpperBound(p));\n             \n             // find root\n-            double root = UnivariateRealSolverFactory.solve(\n+            double root = UnivariateRealSolverUtil.solve(\n                 rootFindingFunction, bracket[0], bracket[1]);\n         \n             return root;\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n  * ChiSquaredDistribution chi = factory.createChiSquareDistribution(5.0);\n  * </pre>\n  * \n- * @version $Revision: 1.8 $ $Date: 2003/07/09 20:03:22 $\n+ * @version $Revision: 1.9 $ $Date: 2003/07/30 21:58:11 $\n  */\n public abstract class DistributionFactory {\n     /**\n     /**\n      * Create an instance of a <code>DistributionFactory</code>\n      * @return a new factory. \n+     * @todo for now, return the only concrete factory.  Later, allow for a\n+     *       plugable implementation, possibly using SPI and commons-discovery.\n      */\n     public static DistributionFactory newInstance() {\n-        // for now, return the only concrete factory.\n-        // later, allow for a plugable implementation, possible using SPI and\n-        // commons-discovery.\n         return new DistributionFactoryImpl();\n     }\n     \n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.\n  *\n- * @version $Revision: 1.3 $ $Date: 2003/07/07 23:19:22 $\n+ * @version $Revision: 1.4 $ $Date: 2003/07/30 21:58:10 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n \n      */\n     public double getEntry(int row, int column)\n     throws IllegalArgumentException {\n-        if (row < 1 || column < 1 || row > this.getRowDimension()\n-        || column > this.getColumnDimension()) {\n+        if (row < 1 || column < 1 || row > this.getRowDimension() ||\n+            column > this.getColumnDimension()) {\n+                \n             throw new IllegalArgumentException\n             (\"matrix entry does not exist\");\n         }\n      */\n     public void setEntry(int row, int column, double value)\n     throws IllegalArgumentException {\n-        if (row < 1 || column < 1 || row > this.getRowDimension()\n-        || column > this.getColumnDimension()) {\n+        if (row < 1 || column < 1 || row > this.getRowDimension() ||\n+            column > this.getColumnDimension()) {\n+                \n             throw new IllegalArgumentException\n             (\"matrix entry does not exist\");\n         }\n         }\n         \n         int nCol = this.getColumnDimension();\n-        int nRow = this.getRowDimension();\n         int nColB = b.getColumnDimension();\n         int nRowB = b.getRowDimension();\n         \n--- a/src/java/org/apache/commons/math/special/Beta.java\n+++ b/src/java/org/apache/commons/math/special/Beta.java\n  * This is a utility class that provides computation methods related to the\n  * Beta family of functions.\n  * \n- * @version $Revision: 1.7 $ $Date: 2003/07/09 20:03:09 $\n+ * @version $Revision: 1.8 $ $Date: 2003/07/30 21:58:10 $\n  */\n public class Beta {\n     /** Maximum allowed numerical error. */\n             \n         double ret;\n \n-        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0)\n-                || (x > 1) || (a <= 0.0) || (b <= 0.0)) {\n+        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||\n+            (x > 1) || (a <= 0.0) || (b <= 0.0)) {\n             ret = Double.NaN;\n         } else {\n             ContinuedFraction fraction = new ContinuedFraction() {\n                         default :\n                             if (n % 2 == 0) { // even\n                                 m = (n - 2.0) / 2.0;\n-                                ret =\n-                                    -((a + m) * (a + b + m) * x)\n-                                        / ((a + (2 * m))\n-                                        * (a + (2 * m) + 1.0));\n+                                ret = -((a + m) * (a + b + m) * x) /\n+                                    ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                             } else {\n                                 m = (n - 1.0) / 2.0;\n-                                ret =\n-                                    (m * (b - m) * x)\n-                                        / ((a + (2 * m) - 1) * (a + (2 * m)));\n+                                ret = (m * (b - m) * x) /\n+                                    ((a + (2 * m) - 1) * (a + (2 * m)));\n                             }\n                             break;\n                     }\n                     return ret;\n                 }\n             };\n-            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x))\n-                - Math.log(a) - logBeta(a, b, epsilon, maxIterations))\n-                * fraction.evaluate(x, epsilon, maxIterations);\n+            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -\n+                Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n+                fraction.evaluate(x, epsilon, maxIterations);\n         }\n \n         return ret;\n         if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n             ret = Double.NaN;\n         } else {\n-            ret = Gamma.logGamma(a) + Gamma.logGamma(b)\n-                - Gamma.logGamma(a + b);\n+            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n+                Gamma.logGamma(a + b);\n         }\n \n         return ret;\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n  * This is a utility class that provides computation methods related to the\n  * Gamma family of functions.\n  * \n- * @version $Revision: 1.9 $ $Date: 2003/07/09 20:03:09 $\n+ * @version $Revision: 1.10 $ $Date: 2003/07/30 21:58:10 $\n  */\n public class Gamma {\n     /** Maximum allowed numerical error. */\n                 throw new ConvergenceException(\n                     \"maximum number of iterations reached\");\n             } else {\n-                ret = Math.exp(-x + \n-                               (a * Math.log(x)) - \n-                               logGamma(a)) \n-                    * sum;\n+                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n             }\n         }\n \n             sum = sum + lanczos[0];\n \n             double tmp = x + g + .5;\n-            ret = ((x + .5) * Math.log(tmp)) - tmp\n-                + (.5 * Math.log(2.0 * Math.PI)) + Math.log(sum) - Math.log(x);\n+            ret = ((x + .5) * Math.log(tmp)) - tmp +\n+                (.5 * Math.log(2.0 * Math.PI)) + Math.log(sum) - Math.log(x);\n         }\n \n         return ret;\n--- a/src/java/org/apache/commons/math/stat/univariate/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/AbstractStorelessUnivariateStatistic.java\n  * Provides the ability to extend polymophically so that\n  * indiviual statistics do not need to implement these methods unless\n  * there are better algorithms for handling the calculation.\n- * @version $Revision: 1.5 $ $Date: 2003/07/15 03:37:10 $\n+ * @version $Revision: 1.6 $ $Date: 2003/07/30 21:58:11 $\n  */\n public abstract class AbstractStorelessUnivariateStatistic\n     extends AbstractUnivariateStatistic\n         if (this.test(values, begin, length)) {\n             this.clear();\n             int l = begin + length;\n-            for (int i = begin; i < begin + length; i++) {\n+            for (int i = begin; i < l; i++) {\n                 increment(values[i]);\n             }\n         }\n--- a/src/test/org/apache/commons/math/analysis/RealSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/RealSolverTest.java\n         // 14 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 15);\n         // Static solve method\n-        result = UnivariateRealSolverFactory.solve(f, -0.2, 0.2);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        result = UnivariateRealSolverFactory.solve(f, -0.1, 0.3);\n+        result = UnivariateRealSolverUtil.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        result = UnivariateRealSolverUtil.solve(f, -0.1, 0.3);\n         Assert.assertEquals(result, 0, 1E-8);\n-        result = UnivariateRealSolverFactory.solve(f, -0.3, 0.45);\n+        result = UnivariateRealSolverUtil.solve(f, -0.3, 0.45);\n         Assert.assertEquals(result, 0, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.3, 0.7);\n+        result = UnivariateRealSolverUtil.solve(f, 0.3, 0.7);\n         Assert.assertEquals(result, 0.5, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.2, 0.6);\n+        result = UnivariateRealSolverUtil.solve(f, 0.2, 0.6);\n         Assert.assertEquals(result, 0.5, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.05, 0.95);\n+        result = UnivariateRealSolverUtil.solve(f, 0.05, 0.95);\n         Assert.assertEquals(result, 0.5, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.85, 1.25);\n-        Assert.assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.8, 1.2);\n-        Assert.assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.85, 1.75);\n-        Assert.assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.55, 1.45);\n-        Assert.assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverFactory.solve(f, 0.85, 5);\n+        result = UnivariateRealSolverUtil.solve(f, 0.85, 1.25);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtil.solve(f, 0.8, 1.2);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtil.solve(f, 0.85, 1.75);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtil.solve(f, 0.55, 1.45);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtil.solve(f, 0.85, 5);\n         Assert.assertEquals(result, 1.0, 1E-6);\n     }\n }\n--- a/src/test/org/apache/commons/math/stat/BeanListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/BeanListUnivariateImplTest.java\n  * Test cases for the {@link BeanListUnivariateImpl} class.\n  *\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @version $Revision: 1.2 $ $Date: 2003/06/22 03:57:53 $\n+ * @version $Revision: 1.3 $ $Date: 2003/07/30 21:58:11 $\n  */\n \n public final class BeanListUnivariateImplTest extends TestCase {\n                       ageU.getMax(), 0.001 );\n \n     }\n-\n-    /*    public void testN0andN1Conditions() throws Exception {\n-    \tList list = new ArrayList();\n-    \t\n-    \tStoreUnivariate u = new ListUnivariateImpl( list );\n-    \t    \t\n-\t\tassertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n-\t\tassertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n-\t\tassertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n-\n-\t\tlist.add( new Double(one));\n-\n-\t\tassertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n-\t\tassertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n-\t\tassertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\t\n-    }\n-    \n-    public void testSkewAndKurtosis() {\n-    \tStoreUnivariate u = new StoreUnivariateImpl();\n-    \t\n-    \tdouble[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n-  \t  \t\t\t\t\t\t\t\t\t\t 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n-  \t  \tfor( int i = 0; i < testArray.length; i++) {\n-  \t  \t\tu.addValue( testArray[i]);\n-  \t  \t}\n-  \t  \t\n-\t\tassertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n-\t\tassertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n-\t\tassertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n-  \t  \tassertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n-    }\n-\n-    public void testProductAndGeometricMean() throws Exception {\n-    \tListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());\n-        u.setWindowSize(10);\n-    \t    \t\n-        u.addValue( 1.0 );\n-        u.addValue( 2.0 );\n-        u.addValue( 3.0 );\n-        u.addValue( 4.0 );\n-\n-        assertEquals( \"Product not expected\", 24.0, u.getProduct(), Double.MIN_VALUE );\n-        assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n-\n-        // Now test rolling - UnivariateImpl should discount the contribution\n-        // of a discarded element\n-        for( int i = 0; i < 10; i++ ) {\n-            u.addValue( i + 2 );\n-        }\n-        // Values should be (2,3,4,5,6,7,8,9,10,11)\n-        \n-        assertEquals( \"Product not expected\", 39916800.0, u.getProduct(), 0.00001 );\n-        assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n-\n-\n-        } */\n-\n }\n ", "timestamp": 1059602291, "metainfo": ""}