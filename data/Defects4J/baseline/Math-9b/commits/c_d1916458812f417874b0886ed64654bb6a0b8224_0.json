{"sha": "d1916458812f417874b0886ed64654bb6a0b8224", "log": "Exposed MathException handling in Distributions by adding thows MathException to methods where MathExceptions are caught and replaced with Double.NaN. Added Serialization Interface to Distributions, BivariateRegression and TestStatistic   ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.15 $ $Date: 2003/11/15 18:47:09 $\n+ * @version $Revision: 1.16 $ $Date: 2003/11/19 03:22:53 $\n  */\n public abstract class AbstractContinuousDistribution\n     implements ContinuousDistribution {\n-        \n+\n     /**\n      * Default constructor.\n      */\n      * @param x1 the upper bound\n      * @return the cummulative probability. \n      */\n-    public double cummulativeProbability(double x0, double x1) {\n+    public double cummulativeProbability(double x0, double x1)\n+        throws MathException {\n         return cummulativeProbability(x1) - cummulativeProbability(x0);\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public double inverseCummulativeProbability(final double p) {\n+    public double inverseCummulativeProbability(final double p)\n+        throws MathException {\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\n-                \"p must be between 0.0 and 1.0, inclusive.\");\n+            throw new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n         }\n-        \n+\n         // by default, do simple root finding using bracketing and bisection.\n         // subclasses can overide if there is a better method.\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n-                \n+\n             public double value(double x) throws MathException {\n                 return cummulativeProbability(x) - p;\n             }\n         };\n-        \n-        try {\n-            // bracket root\n-            double[] bracket = UnivariateRealSolverUtils.bracket(rootFindingFunction,\n-                getInitialDomain(p), getDomainLowerBound(p),\n+\n+        // bracket root\n+        double[] bracket =\n+            UnivariateRealSolverUtils.bracket(\n+                rootFindingFunction,\n+                getInitialDomain(p),\n+                getDomainLowerBound(p),\n                 getDomainUpperBound(p));\n-            \n-            // find root\n-            double root = UnivariateRealSolverUtils.solve(\n-                rootFindingFunction, bracket[0], bracket[1]);\n-        \n-            return root;\n-        } catch (MathException ex) {\n-            // this should never happen.\n-            return Double.NaN;\n-        }\n+\n+        // find root\n+        double root =\n+            UnivariateRealSolverUtils.solve(\n+                rootFindingFunction,\n+                bracket[0],\n+                bracket[1]);\n+\n+        return root;\n     }\n-    \n+\n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * @return initial domain value\n      */\n     protected abstract double getInitialDomain(double p);\n-    \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n     protected abstract double getDomainLowerBound(double p);\n-    \n+\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n--- a/src/java/org/apache/commons/math/distribution/AbstractDiscreteDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractDiscreteDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n \n /**\n  * Base class for various discrete distributions.  It provides default\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.7 $ $Date: 2003/11/15 16:01:35 $\n+ * @version $Revision: 1.8 $ $Date: 2003/11/19 03:22:53 $\n  */\n public abstract class AbstractDiscreteDistribution\n     implements DiscreteDistribution {\n      * @param x1 the inclusive, upper bound\n      * @return the cummulative probability. \n      */\n-    public double cummulativeProbability(int x0, int x1) {\n+    public double cummulativeProbability(int x0, int x1) throws MathException{\n         return cummulativeProbability(x1) - \n             cummulativeProbability(x0 - 1);\n     }\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public int inverseCummulativeProbability(final double p) {\n+    public int inverseCummulativeProbability(final double p) throws MathException{\n         if (p < 0.0 || p > 1.0) {\n             throw new IllegalArgumentException(\n                 \"p must be between 0.0 and 1.0, inclusive.\");\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.MathUtils;\n /**\n  * The default implementation of {@link BinomialDistribution}.\n  * \n- * @version $Revision: 1.7 $ $Date: 2003/11/15 18:59:10 $\n+ * @version $Revision: 1.8 $ $Date: 2003/11/19 03:22:53 $\n  */\n-public class BinomialDistributionImpl extends AbstractDiscreteDistribution\n-    implements BinomialDistribution {\n+public class BinomialDistributionImpl\n+    extends AbstractDiscreteDistribution\n+    implements BinomialDistribution, Serializable {\n \n     /** The number of trials. */\n     private int numberOfTrials;\n-    \n+\n     /** The probability of success. */\n     private double probabilityOfSuccess;\n-    \n+\n     /**\n      * Create a binomial distribution with the given number of trials and\n      * probability of success.\n         setNumberOfTrials(trials);\n         setProbabilityOfSuccess(p);\n     }\n-    \n+\n     /**\n      * Access the number of trials for this distribution.\n      * @return the number of trials.\n      */\n     public void setNumberOfTrials(int trials) {\n         if (trials < 0) {\n-            throw new IllegalArgumentException(\n-                \"number of trials must be non-negative.\");\n+            throw new IllegalArgumentException(\"number of trials must be non-negative.\");\n         }\n         numberOfTrials = trials;\n     }\n      */\n     public void setProbabilityOfSuccess(double p) {\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\n-                \"probability of success must be between 0.0 and 1.0, inclusive.\");\n+            throw new IllegalArgumentException(\"probability of success must be between 0.0 and 1.0, inclusive.\");\n         }\n         probabilityOfSuccess = p;\n     }\n-    \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n-    public double cummulativeProbability(int x) {\n+    public double cummulativeProbability(int x) throws MathException {\n         double ret;\n         if (x < 0) {\n             ret = 0.0;\n         } else if (x >= getNumberOfTrials()) {\n             ret = 1.0;\n         } else {\n-            try {\n-                ret = 1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),\n-                    x + 1.0, getNumberOfTrials() - x);\n-            } catch (MathException ex) {\n-                ret = Double.NaN;\n-            }\n+            ret =\n+                1.0\n+                    - Beta.regularizedBeta(\n+                        getProbabilityOfSuccess(),\n+                        x + 1.0,\n+                        getNumberOfTrials() - x);\n         }\n         return ret;\n     }\n         if (x < 0 || x > getNumberOfTrials()) {\n             ret = 0.0;\n         } else {\n-            ret = MathUtils.binomialCoefficientDouble(getNumberOfTrials(), x) *\n-                Math.pow(getProbabilityOfSuccess(), x) *\n-                Math.pow(1.0 - getProbabilityOfSuccess(),\n-                    getNumberOfTrials() - x);\n+            ret =\n+                MathUtils.binomialCoefficientDouble(getNumberOfTrials(), x)\n+                    * Math.pow(getProbabilityOfSuccess(), x)\n+                    * Math.pow(\n+                        1.0 - getProbabilityOfSuccess(),\n+                        getNumberOfTrials() - x);\n         }\n         return ret;\n     }\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n /**\n  * The default implementation of {@link ChiSquaredDistribution}\n  * \n- * @version $Revision: 1.10 $ $Date: 2003/11/15 16:01:35 $\n+ * @version $Revision: 1.11 $ $Date: 2003/11/19 03:22:53 $\n  */\n public class ChiSquaredDistributionImpl\n     extends AbstractContinuousDistribution\n-    implements ChiSquaredDistribution {\n+    implements ChiSquaredDistribution, Serializable  {\n     \n     /** Internal Gamma distribution. */    \n     private GammaDistribution gamma;\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    public double cummulativeProbability(double x) {\n+    public double cummulativeProbability(double x) throws MathException {\n         return getGamma().cummulativeProbability(x);\n     }\n         \n--- a/src/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n /**\n  * Base interface for various continuous distributions.\n  * \n- * @version $Revision: 1.8 $ $Date: 2003/11/15 16:01:35 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/19 03:22:53 $\n  */\n public interface ContinuousDistribution {\n     /**\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    double cummulativeProbability(double x);\n+    double cummulativeProbability(double x) throws MathException;\n \n     /**\n      * For this disbution, X, this method returns P(x0 &lt; X &lt; x1).\n      * @param x1 the upper bound\n      * @return the cummulative probability. \n      */\n-    double cummulativeProbability(double x0, double x1);\n+    double cummulativeProbability(double x0, double x1) throws MathException;\n     \n     /**\n      * For this disbution, X, this method returns x such that P(X &lt; x) = p.\n      * @param p the cummulative probability.\n      * @return x. \n      */\n-    double inverseCummulativeProbability(double p);\n+    double inverseCummulativeProbability(double p) throws MathException;\n }\n--- a/src/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n /**\n  * Base interface for various discrete distributions.\n  * \n- * @version $Revision: 1.6 $ $Date: 2003/11/15 16:01:35 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/19 03:22:53 $\n  */\n public interface DiscreteDistribution {\n     /**\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n-    double cummulativeProbability(int x);\n+    double cummulativeProbability(int x) throws MathException;\n \n     /**\n      * For this disbution, X, this method returns P(x0 &le; X &le; x1).\n      * @param x1 the inclusive, upper bound\n      * @return the cummulative probability. \n      */\n-    double cummulativeProbability(int x0, int x1);\n+    double cummulativeProbability(int x0, int x1) throws MathException;\n     \n     /**\n      * For this disbution, X, this method returns x such that P(X &le; x) <= p.\n      * @param p the cummulative probability.\n      * @return x. \n      */\n-    int inverseCummulativeProbability(double p);\n+    int inverseCummulativeProbability(double p) throws MathException;\n }\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n \n /**\n  * A concrete distribution factory.  This is the default factory used by\n  * Commons-Math.\n  *  \n- * @version $Revision: 1.15 $ $Date: 2003/11/15 16:01:36 $\n+ * @version $Revision: 1.16 $ $Date: 2003/11/19 03:22:53 $\n  */\n-public class DistributionFactoryImpl extends DistributionFactory {\n+public class DistributionFactoryImpl extends DistributionFactory implements Serializable  {\n     /**\n      * Default constructor.  Package scope to prevent unwanted instantiation. \n      */\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n /**\n  * The default implementation of {@link ExponentialDistribution}\n  * \n- * @version $Revision: 1.9 $ $Date: 2003/11/15 16:01:36 $\n+ * @version $Revision: 1.10 $ $Date: 2003/11/19 03:22:53 $\n  */\n public class ExponentialDistributionImpl\n-    implements ExponentialDistribution {\n+    implements ExponentialDistribution, Serializable  {\n \n     /** The mean of this distribution. */\n     private double mean;\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n      */\n-    public double cummulativeProbability(double x) {\n+    public double cummulativeProbability(double x) throws MathException{\n         double ret;\n         if (x <= 0.0) {\n             ret = 0.0;\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public double inverseCummulativeProbability(double p) {\n+    public double inverseCummulativeProbability(double p) throws MathException{\n         double ret;\n         \n         if (p < 0.0 || p > 1.0) {\n      * @param x1 the upper bound\n      * @return the cummulative probability. \n      */\n-    public double cummulativeProbability(double x0, double x1) {\n+    public double cummulativeProbability(double x0, double x1) throws MathException{\n         return cummulativeProbability(x1) - cummulativeProbability(x0);\n     }\n }\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.special.Beta;\n \n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.FDistribution}.\n  * \n- * @version $Revision: 1.10 $ $Date: 2003/11/15 18:59:10 $\n+ * @version $Revision: 1.11 $ $Date: 2003/11/19 03:22:53 $\n  */\n public class FDistributionImpl\n     extends AbstractContinuousDistribution\n-    implements FDistribution {\n+    implements FDistribution, Serializable  {\n \n     /** The numerator degrees of freedom*/\n     private double numeratorDegreesOfFreedom;\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    public double cummulativeProbability(double x) {\n+    public double cummulativeProbability(double x) throws MathException {\n         double ret;\n         if (x <= 0.0) {\n             ret = 0.0;\n             double n = getNumeratorDegreesOfFreedom();\n             double m = getDenominatorDegreesOfFreedom();\n             \n-            try {\n-                ret = Beta.regularizedBeta((n * x) / (m + n * x),\n-                    0.5 * n,\n-                    0.5 * m);\n-            } catch (MathException ex) {\n-                ret = Double.NaN;\n-            }\n+            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n+                0.5 * n,\n+                0.5 * m);\n         }\n         return ret;\n     }\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.special.Gamma;\n \n /**\n  * The default implementation of {@link GammaDistribution}\n  * \n- * @version $Revision: 1.13 $ $Date: 2003/11/15 18:59:10 $\n+ * @version $Revision: 1.14 $ $Date: 2003/11/19 03:22:53 $\n  */\n public class GammaDistributionImpl extends AbstractContinuousDistribution\n-    implements GammaDistribution {\n+    implements GammaDistribution, Serializable  {\n \n     /** The shape parameter. */\n     private double alpha;\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    public double cummulativeProbability(double x) {\n+    public double cummulativeProbability(double x) throws MathException{\n         double ret;\n     \n         if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n-            try {\n-                ret = Gamma.regularizedGammaP(getAlpha(), x / getBeta());\n-            } catch(MathException ex){\n-                ret = Double.NaN;\n-            }\n+            ret = Gamma.regularizedGammaP(getAlpha(), x / getBeta());\n         }\n     \n         return ret;\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n  * The default implementation of {@link HypergeometricDistribution}.\n  * \n- * @version $Revision: 1.6 $ $Date: 2003/11/15 16:01:36 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/19 03:22:53 $\n  */\n public class HypergeometricDistributionImpl extends AbstractDiscreteDistribution\n-    implements HypergeometricDistribution\n+    implements HypergeometricDistribution, Serializable \n {\n \n     /** The number of successes in the population. */\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n-    public double cummulativeProbability(int x) {\n+    public double cummulativeProbability(int x) throws MathException{\n         double ret;\n         \n         int n = getPopulationSize();\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.special.Beta;\n \n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.TDistribution}.\n  * \n- * @version $Revision: 1.10 $ $Date: 2003/11/15 18:59:10 $\n+ * @version $Revision: 1.11 $ $Date: 2003/11/19 03:22:53 $\n  */\n public class TDistributionImpl\n     extends AbstractContinuousDistribution\n-    implements TDistribution {\n+    implements TDistribution, Serializable  {\n \n     /** The degrees of freedom*/\n     private double degreesOfFreedom;\n-    \n+\n     /**\n      * Create a t distribution using the given degrees of freedom.\n      * @param degreesOfFreedom the degrees of freedom.\n      */\n     public void setDegreesOfFreedom(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"degrees of freedom must be positive.\");\n+            throw new IllegalArgumentException(\"degrees of freedom must be positive.\");\n         }\n         this.degreesOfFreedom = degreesOfFreedom;\n     }\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF evaluted at <code>x</code>. \n      */\n-    public double cummulativeProbability(double x) {\n+    public double cummulativeProbability(double x) throws MathException{\n         double ret;\n         if (x == 0.0) {\n             ret = 0.5;\n         } else {\n-            double t;\n-            try {\n-                t = Beta.regularizedBeta(\n+            double t =\n+                Beta.regularizedBeta(\n                     getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),\n                     0.5 * getDegreesOfFreedom(),\n                     0.5);\n-                if (x < 0.0) {\n-                    ret = 0.5 * t;\n-                } else {\n-                    ret = 1.0 - 0.5 * t;\n-                }\n-            } catch (MathException ex) {\n-                ret = Double.NaN;\n+            if (x < 0.0) {\n+                ret = 0.5 * t;\n+            } else {\n+                ret = 1.0 - 0.5 * t;\n             }\n         }\n-        \n+\n         return ret;\n     }\n-        \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n--- a/src/java/org/apache/commons/math/stat/BivariateRegression.java\n+++ b/src/java/org/apache/commons/math/stat/BivariateRegression.java\n  */\n \n package org.apache.commons.math.stat;\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.distribution.DistributionFactory;\n import org.apache.commons.math.distribution.TDistribution;\n \n  * the necessary computations to return the requested statistic.</li>\n  * </ul>\n  *\n- * @version $Revision: 1.10 $ $Date: 2003/11/18 15:07:12 $\n+ * @version $Revision: 1.11 $ $Date: 2003/11/19 03:22:54 $\n  */\n-public class BivariateRegression {\n-    \n+public class BivariateRegression implements Serializable {\n+\n+    static final long serialVersionUID = -3004689053607543335L;\n+\n     /** sum of x values */\n     private double sumX = 0d;\n-    \n+\n     /** total variation in x (sum of squared deviations from xbar) */\n     private double sumXX = 0d;\n-    \n+\n     /** sum of y values */\n     private double sumY = 0d;\n-    \n+\n     /** total variation in y (sum of squared deviations from ybar) */\n     private double sumYY = 0d;\n-    \n+\n     /** sum of products */\n     private double sumXY = 0d;\n-    \n+\n     /** number of observations */\n     private long n = 0;\n-    \n+\n     /** mean of accumulated x values, used in updating formulas */\n     private double xbar = 0;\n-    \n+\n     /** mean of accumulated y values, used in updating formulas */\n     private double ybar = 0;\n-    \n-    \n+\n     // ---------------------Public methods--------------------------------------\n-    \n+\n     /**\n      * Adds the observation (x,y) to the regression data set.\n      * <p>\n         sumX += x;\n         sumY += y;\n         n++;\n-    } \n-    \n+    }\n+\n     /**\n      * Adds the observations represented by the elements in \n      * <code>data</code>.\n      * @param data array of observations to be added\n      */\n     public void addData(double[][] data) {\n-       for (int i = 0; i < data.length; i++) {\n+        for (int i = 0; i < data.length; i++) {\n             addData(data[i][0], data[i][1]);\n-       }\n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Clears all data from the model.\n      */\n         sumXY = 0d;\n         n = 0;\n     }\n-          \n+\n     /**\n      * Returns the number of observations that have been added to the model.\n      *\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * Returns the \"predicted\" <code>y</code> value associated with the \n      * supplied <code>x</code> value.\n         double b1 = getSlope();\n         return getIntercept(b1) + b1 * x;\n     }\n-    \n+\n     /**\n      * Returns the intercept of the estimated regression line.\n      * <p>\n      *\n      * @return the intercept of the regression line\n      */\n-     public double getIntercept() {\n-         return getIntercept(getSlope());\n-     }\n-     \n-     /**\n-     * Returns the slope of the estimated regression line.  \n-     * <p>\n-     * The least squares estimate of the slope is computed using the \n-     * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n-     * The slope is sometimes denoted b1. \n+    public double getIntercept() {\n+        return getIntercept(getSlope());\n+    }\n+\n+    /**\n+    * Returns the slope of the estimated regression line.  \n+    * <p>\n+    * The least squares estimate of the slope is computed using the \n+    * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n+    * The slope is sometimes denoted b1. \n+    * <p>\n+    * <strong>Preconditions</strong>: <ul>\n+    * <li>At least two observations (with at least two different x values)\n+    * must have been added before invoking this method. If this method is \n+    * invoked before a model can be estimated, <code>Double.NaN</code> is\n+    * returned.\n+    * </li></ul>\n+    *\n+    * @return the slope of the regression line\n+    */\n+    public double getSlope() {\n+        if (n < 2) {\n+            return Double.NaN; //not enough data \n+        }\n+        if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n+            return Double.NaN; //not enough variation in x\n+        }\n+        return sumXY / sumXX;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n+     * sum of squared errors</a> (SSE) associated with the regression \n+     * model.\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n      * must have been added before invoking this method. If this method is \n-     * invoked before a model can be estimated, <code>Double.NaN</code> is\n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n      * returned.\n      * </li></ul>\n      *\n-     * @return the slope of the regression line\n-     */\n-     public double getSlope() {\n-         if (n < 2) {\n-             return Double.NaN;  //not enough data \n-         }\n-         if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) { \n-             return Double.NaN; //not enough variation in x\n-         }\n-         return sumXY / sumXX;\n-     }\n-     \n-     /**\n-      * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n-      * sum of squared errors</a> (SSE) associated with the regression \n-      * model.\n-      * <p>\n-      * <strong>Preconditions</strong>: <ul>\n-      * <li>At least two observations (with at least two different x values)\n-      * must have been added before invoking this method. If this method is \n-      * invoked before a model can be estimated, <code>Double,NaN</code> is\n-      * returned.\n-      * </li></ul>\n-      *\n-      * @return sum of squared errors associated with the regression model\n-      */\n-     public double getSumSquaredErrors() {\n-         return getSumSquaredErrors(getSlope());\n-     }\n-     \n-     /**\n-      * Returns the sum of squared deviations of the y values about their mean.\n-      * <p>\n-      * This is defined as SSTO \n-      * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.\n-      * <p>\n-      * If <code>n < 2</code>, this returns <code>Double.NaN</code>.\n-      *\n-      * @return sum of squared deviations of y values\n-      */\n-     public double getTotalSumSquares() {\n-         if (n < 2) {\n-             return Double.NaN;\n-         }\n-         return sumYY;\n-     }\n-         \n-     /**\n-      * Returns the sum of squared deviations of the predicted y values about \n-      * their mean (which equals the mean of y).\n-      * <p>\n-      * This is usually abbreviated SSR or SSM.  It is defined as SSM \n-      * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>\n-      * <p>\n-      * <strong>Preconditions</strong>: <ul>\n-      * <li>At least two observations (with at least two different x values)\n-      * must have been added before invoking this method. If this method is \n-      * invoked before a model can be estimated, <code>Double,NaN</code> is\n-      * returned.\n-      * </li></ul>\n-      *\n-      * @return sum of squared deviations of predicted y values\n-      */\n-     public double getRegressionSumSquares() {\n-         return getRegressionSumSquares(getSlope());\n-     }\n-     \n-     /**\n-      * Returns the sum of squared errors divided by the degrees of freedom,\n-      * usually abbreviated MSE. \n-      * <p>\n-      * If there are fewer than <strong>three</strong> data pairs in the model,\n-      * or if there is no variation in <code>x</code>, this returns \n-      * <code>Double.NaN</code>.\n-      *\n-      * @return sum of squared deviations of y values\n-      */\n-     public double getMeanSquareError() {\n-         if (n < 3) {\n-             return Double.NaN;\n-         }\n-         return getSumSquaredErrors() / (double) (n - 2);\n-     }\n-     \n-     /**\n-      * Returns <a href=\"http://www.stt.msu.edu/~xiaoyimi/STT200/Lecture5.pdf\">\n-      * Pearson's product moment correlation coefficient</a>,\n-      * usually denoted r. \n-      * <p>\n-      * <strong>Preconditions</strong>: <ul>\n-      * <li>At least two observations (with at least two different x values)\n-      * must have been added before invoking this method. If this method is \n-      * invoked before a model can be estimated, <code>Double,NaN</code> is\n-      * returned.\n-      * </li></ul>\n-      *\n-      * @return Pearson's r\n-      */\n-     public double getR() {\n-         double b1 = getSlope();\n-         double result = Math.sqrt(getRSquare(b1));\n-         if (b1 < 0) {\n-             result = -result;\n-         }\n-         return result;\n-     }\n-             \n-     /** \n-      * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\"> \n-      * coefficient of determination</a>,\n-      * usually denoted r-square. \n-      * <p>\n-      * <strong>Preconditions</strong>: <ul>\n-      * <li>At least two observations (with at least two different x values)\n-      * must have been added before invoking this method. If this method is \n-      * invoked before a model can be estimated, <code>Double,NaN</code> is\n-      * returned.\n-      * </li></ul>\n-      *\n-      * @return r-square\n-      */\n-     public double getRSquare() {\n-         return getRSquare(getSlope());\n-     }\n-     \n-         \n-     /**\n-      * Returns the <a href=\"http://www.xycoon.com/standarderrorb0.htm\">\n-      * standard error of the intercept estimate</a>, \n-      * usually denoted s(b0). \n-      * <p>\n-      * If there are fewer that <strong>three</strong> observations in the \n-      * model, or if there is no variation in x, this returns \n-      * <code>Double.NaN</code>.\n-      *\n-      * @return standard error associated with intercept estimate\n-      */\n-     public double getInterceptStdErr() {\n-         return Math.sqrt(getMeanSquareError() * ((1d / (double) n) +\n-            (xbar * xbar) / sumXX));\n-     }\n-             \n-     /**\n-      * Returns the <a href=\"http://www.xycoon.com/standerrorb(1).htm\">standard\n-      * error of the slope estimate</a>,\n-      * usually denoted s(b1). \n-      * <p>\n-      * If there are fewer that <strong>three</strong> data pairs in the model,\n-      * or if there is no variation in x, this returns <code>Double.NaN</code>.\n-      *\n-      * @return standard error associated with slope estimate\n-      */\n-     public double getSlopeStdErr() {\n-         return Math.sqrt(getMeanSquareError() / sumXX);\n-     }\n-     \n-     /**\n-      * Returns the half-width of a 95% confidence interval for the slope\n-      * estimate.\n-      * <p>\n-      * The 95% confidence interval is \n-      * <p>\n-      * <code>(getSlope() - getSlopeConfidenceInterval(), \n-      * getSlope() + getSlopeConfidenceInterval())</code>\n-      * <p>\n-      * If there are fewer that <strong>three</strong> observations in the \n-      * model, or if there is no variation in x, this returns \n-      * <code>Double.NaN</code>.\n-      * <p>\n-      * <strong>Usage Note</strong>:<br>\n-      * The validity of this statistic depends on the assumption that the \n-      * observations included in the model are drawn from a\n-      * <a href=\"http://mathworld.wolfram.com/\n-      * BivariateNormalDistribution.html\">Bivariate Normal Distribution</a>.\n-      *\n-      * @return half-width of 95% confidence interval for the slope estimate\n-      */\n-     public double getSlopeConfidenceInterval() {   \n-        return getSlopeConfidenceInterval(0.05d); \n-     }\n-     \n-     /**\n-      * Returns the half-width of a (100-100*alpha)% confidence interval for \n-      * the slope estimate.\n-      * <p>\n-      * The (100-100*alpha)% confidence interval is \n-      * <p>\n-      * <code>(getSlope() - getSlopeConfidenceInterval(), \n-      * getSlope() + getSlopeConfidenceInterval())</code>\n-      * <p>\n-      * To request, for example, a 99% confidence interval, use \n-      * <code>alpha = .01</code>\n-      * <p>\n-      * <strong>Usage Note</strong>:<br>\n-      * The validity of this statistic depends on the assumption that the \n-      * observations included in the model are drawn from a\n-      * <a href=\"http://mathworld.wolfram.com/\n-      * BivariateNormalDistribution.html\">Bivariate Normal Distribution</a>.\n-      * <p>\n-      * <strong> Preconditions:</strong><ul>\n-      * <li>If there are fewer that <strong>three</strong> observations in the \n-      * model, or if there is no variation in x, this returns \n-      * <code>Double.NaN</code>. \n-      * </li>\n-      * <li><code>(0 < alpha < 1)</code>; otherwise an \n-      * <code>IllegalArgumentException</code> is thrown.\n-      * </li></ul>    \n-      *\n-      * @param alpha the desired significance level \n-      * @return half-width of 95% confidence interval for the slope estimate\n-      */\n-     public double getSlopeConfidenceInterval(double alpha) { \n-         if (alpha >= 1 || alpha <= 0) {\n-             throw new IllegalArgumentException();\n-         }\n-         return getSlopeStdErr() * \n-            getTDistribution().inverseCummulativeProbability(1d - alpha / 2d); \n-     }\n-     \n-     /**\n-      * Returns the significance level of the slope (equiv) correlation. \n-      * <p>\n-      * Specifically, the returned value is the smallest <code>alpha</code>\n-      * such that the slope confidence interval with significance level\n-      * equal to <code>alpha</code> does not include <code>0</code>.\n-      * On regression output, this is often denoted <code>Prob(|t| > 0)</code>\n-      * <p>\n-      * <strong>Usage Note</strong>:<br>\n-      * The validity of this statistic depends on the assumption that the \n-      * observations included in the model are drawn from a\n-      * <a href=\"http://mathworld.wolfram.com/\n-      * BivariateNormalDistribution.html\">Bivariate Normal Distribution</a>.\n-      * <p>\n-      * If there are fewer that <strong>three</strong> observations in the \n-      * model, or if there is no variation in x, this returns \n-      * <code>Double.NaN</code>.\n-      *\n-      * @return significance level for slope/correlation\n-      */\n-     public double getSignificance() {\n-         return (1d - getTDistribution().cummulativeProbability(\n-                Math.abs(getSlope()) / getSlopeStdErr()));\n-     }\n-     \n-     // ---------------------Private methods-----------------------------------\n-     \n-     /**\n-     * Returns the intercept of the estimated regression line, given the slope.\n-     * <p>\n-     * Will return <code>NaN</code> if slope is <code>NaN</code>.\n-     *\n-     * @param slope current slope\n-     * @return the intercept of the regression line\n-     */\n-     private double getIntercept(double slope) {\n-         return (sumY - slope * sumX) / ((double) n);\n-     }\n-       \n-     /**\n-      * Returns the sum of squared errors associated with the regression \n-      * model, using the slope of the regression line. \n-      * <p> \n-      * Returns NaN if the slope is NaN.\n-      * \n-      * @param b1 current slope\n-      * @return sum of squared errors associated with the regression model\n-      */\n-     private double getSumSquaredErrors(double b1) {\n-         return sumYY - sumXY * sumXY / sumXX;\n-     } \n-     \n-     /** \n-      * Computes r-square from the slope.\n-      * <p>\n-      * will return NaN if slope is Nan.\n-      *\n-      * @param b1 current slope\n-      * @return r-square\n-      */\n-     private double getRSquare(double b1) {\n-         double ssto = getTotalSumSquares();\n-         return (ssto - getSumSquaredErrors(b1)) / ssto;\n-     }\n-     \n-     /**\n-      * Computes SSR from b1.\n-      * \n-      * @param slope regression slope estimate\n-      * @return sum of squared deviations of predicted y values\n-      */\n-     private double getRegressionSumSquares(double slope) {\n-         return slope * slope * sumXX;\n-     }\n-     \n-     /**\n-      * Uses distribution framework to get a t distribution instance \n-      * with df = n - 2\n-      *\n-      * @return t distribution with df = n - 2\n-      */\n-     private TDistribution getTDistribution() {\n-         return DistributionFactory.newInstance().createTDistribution(n - 2);\n-     }\n+     * @return sum of squared errors associated with the regression model\n+     */\n+    public double getSumSquaredErrors() {\n+        return getSumSquaredErrors(getSlope());\n+    }\n+\n+    /**\n+     * Returns the sum of squared deviations of the y values about their mean.\n+     * <p>\n+     * This is defined as SSTO \n+     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.\n+     * <p>\n+     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.\n+     *\n+     * @return sum of squared deviations of y values\n+     */\n+    public double getTotalSumSquares() {\n+        if (n < 2) {\n+            return Double.NaN;\n+        }\n+        return sumYY;\n+    }\n+\n+    /**\n+     * Returns the sum of squared deviations of the predicted y values about \n+     * their mean (which equals the mean of y).\n+     * <p>\n+     * This is usually abbreviated SSR or SSM.  It is defined as SSM \n+     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return sum of squared deviations of predicted y values\n+     */\n+    public double getRegressionSumSquares() {\n+        return getRegressionSumSquares(getSlope());\n+    }\n+\n+    /**\n+     * Returns the sum of squared errors divided by the degrees of freedom,\n+     * usually abbreviated MSE. \n+     * <p>\n+     * If there are fewer than <strong>three</strong> data pairs in the model,\n+     * or if there is no variation in <code>x</code>, this returns \n+     * <code>Double.NaN</code>.\n+     *\n+     * @return sum of squared deviations of y values\n+     */\n+    public double getMeanSquareError() {\n+        if (n < 3) {\n+            return Double.NaN;\n+        }\n+        return getSumSquaredErrors() / (double) (n - 2);\n+    }\n+\n+    /**\n+     * Returns <a href=\"http://www.stt.msu.edu/~xiaoyimi/STT200/Lecture5.pdf\">\n+     * Pearson's product moment correlation coefficient</a>,\n+     * usually denoted r. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return Pearson's r\n+     */\n+    public double getR() {\n+        double b1 = getSlope();\n+        double result = Math.sqrt(getRSquare(b1));\n+        if (b1 < 0) {\n+            result = -result;\n+        }\n+        return result;\n+    }\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\"> \n+     * coefficient of determination</a>,\n+     * usually denoted r-square. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return r-square\n+     */\n+    public double getRSquare() {\n+        return getRSquare(getSlope());\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/standarderrorb0.htm\">\n+     * standard error of the intercept estimate</a>, \n+     * usually denoted s(b0). \n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     *\n+     * @return standard error associated with intercept estimate\n+     */\n+    public double getInterceptStdErr() {\n+        return Math.sqrt(\n+            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/standerrorb(1).htm\">standard\n+     * error of the slope estimate</a>,\n+     * usually denoted s(b1). \n+     * <p>\n+     * If there are fewer that <strong>three</strong> data pairs in the model,\n+     * or if there is no variation in x, this returns <code>Double.NaN</code>.\n+     *\n+     * @return standard error associated with slope estimate\n+     */\n+    public double getSlopeStdErr() {\n+        return Math.sqrt(getMeanSquareError() / sumXX);\n+    }\n+\n+    /**\n+     * Returns the half-width of a 95% confidence interval for the slope\n+     * estimate.\n+     * <p>\n+     * The 95% confidence interval is \n+     * <p>\n+     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * getSlope() + getSlopeConfidenceInterval())</code>\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/\n+     * BivariateNormalDistribution.html\">Bivariate Normal Distribution</a>.\n+     *\n+     * @return half-width of 95% confidence interval for the slope estimate\n+     */\n+    public double getSlopeConfidenceInterval() throws MathException {\n+        return getSlopeConfidenceInterval(0.05d);\n+    }\n+\n+    /**\n+     * Returns the half-width of a (100-100*alpha)% confidence interval for \n+     * the slope estimate.\n+     * <p>\n+     * The (100-100*alpha)% confidence interval is \n+     * <p>\n+     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * getSlope() + getSlopeConfidenceInterval())</code>\n+     * <p>\n+     * To request, for example, a 99% confidence interval, use \n+     * <code>alpha = .01</code>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/\n+     * BivariateNormalDistribution.html\">Bivariate Normal Distribution</a>.\n+     * <p>\n+     * <strong> Preconditions:</strong><ul>\n+     * <li>If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>. \n+     * </li>\n+     * <li><code>(0 < alpha < 1)</code>; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * </li></ul>    \n+     *\n+     * @param alpha the desired significance level \n+     * @return half-width of 95% confidence interval for the slope estimate\n+     */\n+    public double getSlopeConfidenceInterval(double alpha)\n+        throws MathException {\n+        if (alpha >= 1 || alpha <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return getSlopeStdErr()\n+            * getTDistribution().inverseCummulativeProbability(1d - alpha / 2d);\n+    }\n+\n+    /**\n+     * Returns the significance level of the slope (equiv) correlation. \n+     * <p>\n+     * Specifically, the returned value is the smallest <code>alpha</code>\n+     * such that the slope confidence interval with significance level\n+     * equal to <code>alpha</code> does not include <code>0</code>.\n+     * On regression output, this is often denoted <code>Prob(|t| > 0)</code>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/\n+     * BivariateNormalDistribution.html\">Bivariate Normal Distribution</a>.\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     *\n+     * @return significance level for slope/correlation\n+     */\n+    public double getSignificance() throws MathException {\n+        return (\n+            1d\n+                - getTDistribution().cummulativeProbability(\n+                    Math.abs(getSlope()) / getSlopeStdErr()));\n+    }\n+\n+    // ---------------------Private methods-----------------------------------\n+\n+    /**\n+    * Returns the intercept of the estimated regression line, given the slope.\n+    * <p>\n+    * Will return <code>NaN</code> if slope is <code>NaN</code>.\n+    *\n+    * @param slope current slope\n+    * @return the intercept of the regression line\n+    */\n+    private double getIntercept(double slope) {\n+        return (sumY - slope * sumX) / ((double) n);\n+    }\n+\n+    /**\n+     * Returns the sum of squared errors associated with the regression \n+     * model, using the slope of the regression line. \n+     * <p> \n+     * Returns NaN if the slope is NaN.\n+     * \n+     * @param b1 current slope\n+     * @return sum of squared errors associated with the regression model\n+     */\n+    private double getSumSquaredErrors(double b1) {\n+        return sumYY - sumXY * sumXY / sumXX;\n+    }\n+\n+    /** \n+     * Computes r-square from the slope.\n+     * <p>\n+     * will return NaN if slope is Nan.\n+     *\n+     * @param b1 current slope\n+     * @return r-square\n+     */\n+    private double getRSquare(double b1) {\n+        double ssto = getTotalSumSquares();\n+        return (ssto - getSumSquaredErrors(b1)) / ssto;\n+    }\n+\n+    /**\n+     * Computes SSR from b1.\n+     * \n+     * @param slope regression slope estimate\n+     * @return sum of squared deviations of predicted y values\n+     */\n+    private double getRegressionSumSquares(double slope) {\n+        return slope * slope * sumXX;\n+    }\n+\n+    /**\n+     * Uses distribution framework to get a t distribution instance \n+     * with df = n - 2\n+     *\n+     * @return t distribution with df = n - 2\n+     */\n+    private TDistribution getTDistribution() {\n+        return DistributionFactory.newInstance().createTDistribution(n - 2);\n+    }\n }\n-\n--- a/src/java/org/apache/commons/math/stat/TestStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/TestStatistic.java\n  * <http://www.apache.org/>.\n  */\n package org.apache.commons.math.stat;\n+\n+import org.apache.commons.math.MathException;\n+\n /**\n  * A collection of commonly used test statistics and statistical tests.\n  * \n- * @version $Revision: 1.9 $ $Date: 2003/11/15 16:01:38 $ \n+ * @version $Revision: 1.10 $ $Date: 2003/11/19 03:22:54 $ \n  */\n public interface TestStatistic {\n     \n      * @throws IllegalArgumentException if preconditions are not met\n      */\n     double chiSquare(double[] expected, double[] observed) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n     double chiSquareTest(double[] expected, double[] observed) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n     boolean chiSquareTest(double[] expected, double[] observed, double alpha) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/\n      * @throws IllegalArgumentException if input array length is less than 2\n      */\n     double t(double mu, double[] observed) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double t(double[] sample1, double[] sample2) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double tTest(double[] sample1, double[] sample2)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/\n      * @throws IllegalArgumentException if the preconditions are not met\n      */\n     boolean tTest(double[] sample1, double[] sample2, double alpha)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     boolean tTest(double mu, double[] sample, double alpha)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double tTest(double mu, double[] sample)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double t(double mu, DescriptiveStatistics sampleStats) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double t(DescriptiveStatistics sampleStats1, DescriptiveStatistics sampleStats2) \n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double tTest(DescriptiveStatistics sampleStats1, DescriptiveStatistics sampleStats2)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/\n      */\n     boolean tTest(DescriptiveStatistics sampleStats1, DescriptiveStatistics sampleStats2, \n         double alpha)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     boolean tTest(double mu, DescriptiveStatistics sampleStats, double alpha)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n     \n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     double tTest(double mu, DescriptiveStatistics sampleStats)\n-        throws IllegalArgumentException;\n+        throws IllegalArgumentException, MathException;\n }\n \n--- a/src/java/org/apache/commons/math/stat/TestStatisticImpl.java\n+++ b/src/java/org/apache/commons/math/stat/TestStatisticImpl.java\n \n package org.apache.commons.math.stat;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.distribution.DistributionFactory;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n /**\n  * Implements test statistics defined in the TestStatistic interface.\n  *\n- * @version $Revision: 1.9 $ $Date: 2003/11/15 16:01:39 $\n+ * @version $Revision: 1.10 $ $Date: 2003/11/19 03:22:54 $\n  */\n-public class TestStatisticImpl implements TestStatistic {\n-    \n+public class TestStatisticImpl implements TestStatistic, Serializable {\n+\n+    static final long serialVersionUID = 3357444126133491679L;\n+\n     /**\n      * Default constructor\n      */\n     public TestStatisticImpl() {\n     }\n-    \n+\n     /**\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n         double sumSq = 0.0d;\n         double dev = 0.0d;\n         if ((expected.length < 2) || (expected.length != observed.length)) {\n-            throw new IllegalArgumentException\n-                (\"observed, expected array lengths incorrect\");\n+            throw new IllegalArgumentException(\"observed, expected array lengths incorrect\");\n         }\n         if ((StatUtils.min(expected) <= 0) || (StatUtils.min(observed) < 0)) {\n-            throw new IllegalArgumentException\n-                (\"observed counts must be non-negative,\" + \n-                    \" expected counts must be postive\");\n+            throw new IllegalArgumentException(\n+                \"observed counts must be non-negative,\"\n+                    + \" expected counts must be postive\");\n         }\n         for (int i = 0; i < observed.length; i++) {\n             dev = (observed[i] - expected[i]);\n             sumSq += dev * dev / expected[i];\n         }\n-        \n+\n         return sumSq;\n     }\n-    \n+\n     /**\n      * @param observed array of observed frequency counts\n      * @param expected array of exptected frequency counts\n      * @return p-value\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n-    public double chiSquareTest(double[] expected, double[] observed) \n-        throws IllegalArgumentException {\n-        ChiSquaredDistribution chiSquaredDistribution = \n-            DistributionFactory.newInstance().createChiSquareDistribution\n-                ((double) expected.length - 1);\n-        return 1 - chiSquaredDistribution.cummulativeProbability(\n-            chiSquare(expected, observed));     \n-    }\n-    \n+    public double chiSquareTest(double[] expected, double[] observed)\n+        throws IllegalArgumentException, MathException {\n+        ChiSquaredDistribution chiSquaredDistribution =\n+            DistributionFactory.newInstance().createChiSquareDistribution(\n+                (double) expected.length - 1);\n+        return 1\n+            - chiSquaredDistribution.cummulativeProbability(\n+                chiSquare(expected, observed));\n+    }\n+\n     /**\n      * @param observed array of observed frequency counts\n      * @param expected array of exptected frequency counts\n      * 1 - alpha\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n-    public boolean chiSquareTest(double[] expected, double[] observed, \n-        double alpha) \n-        throws IllegalArgumentException {\n+    public boolean chiSquareTest(\n+        double[] expected,\n+        double[] observed,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n-           throw new IllegalArgumentException\n-                (\"bad significance level: \" + alpha);\n+            throw new IllegalArgumentException(\n+                \"bad significance level: \" + alpha);\n         }\n         return (chiSquareTest(expected, observed) < alpha);\n     }\n      * @return t statistic\n      * @throws IllegalArgumentException if input array length is less than 5\n      */\n-    public double t(double mu, double[] observed) \n-    throws IllegalArgumentException {\n+    public double t(double mu, double[] observed)\n+        throws IllegalArgumentException {\n         if ((observed == null) || (observed.length < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-        return t(StatUtils.mean(observed), mu, StatUtils.variance(observed), \n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return t(\n+            StatUtils.mean(observed),\n+            mu,\n+            StatUtils.variance(observed),\n             observed.length);\n     }\n-    \n+\n     /**\n      * @param mu constant value to compare sample mean against\n      * @param sample array of sample data values\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     public boolean tTest(double mu, double[] sample, double alpha)\n-        throws IllegalArgumentException {\n+        throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n-           throw new IllegalArgumentException\n-                (\"bad significance level: \" + alpha);\n-        }   \n+            throw new IllegalArgumentException(\n+                \"bad significance level: \" + alpha);\n+        }\n         return (tTest(mu, sample) < alpha);\n     }\n-                       \n+\n     /**\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @return t-statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double t(double[] sample1, double[] sample2) \n+    public double t(double[] sample1, double[] sample2)\n         throws IllegalArgumentException {\n-        if ((sample1 == null) || (sample2 == null || \n-            Math.min(sample1.length, sample2.length) < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-        return t(StatUtils.mean(sample1), StatUtils.mean(sample2), \n-            StatUtils.variance(sample1), StatUtils.variance(sample2), \n-            (double) sample1.length, (double) sample2.length);\n-    }\n-    \n+        if ((sample1 == null)\n+            || (sample2 == null\n+                || Math.min(sample1.length, sample2.length) < 5)) {\n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return t(\n+            StatUtils.mean(sample1),\n+            StatUtils.mean(sample2),\n+            StatUtils.variance(sample1),\n+            StatUtils.variance(sample2),\n+            (double) sample1.length,\n+            (double) sample2.length);\n+    }\n+\n     /**\n      *\n      * @param sample1 array of sample data values\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     public double tTest(double[] sample1, double[] sample2)\n-        throws IllegalArgumentException  {\n-        if ((sample1 == null) || (sample2 == null ||\n-        Math.min(sample1.length, sample2.length) < 5)) {\n-            throw new IllegalArgumentException\n-            (\"insufficient data\");\n-        }\n-        return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2), \n-            StatUtils.variance(sample1), StatUtils.variance(sample2), \n-            (double) sample1.length, (double) sample2.length);      \n-    }\n-    \n+        throws IllegalArgumentException, MathException {\n+        if ((sample1 == null)\n+            || (sample2 == null\n+                || Math.min(sample1.length, sample2.length) < 5)) {\n+            throw new IllegalArgumentException(\"insufficient data\");\n+        }\n+        return tTest(\n+            StatUtils.mean(sample1),\n+            StatUtils.mean(sample2),\n+            StatUtils.variance(sample1),\n+            StatUtils.variance(sample2),\n+            (double) sample1.length,\n+            (double) sample2.length);\n+    }\n+\n     /**\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @throws IllegalArgumentException if the preconditions are not met\n      */\n     public boolean tTest(double[] sample1, double[] sample2, double alpha)\n-        throws IllegalArgumentException {\n-       if ((alpha <= 0) || (alpha > 0.5)) {\n-           throw new IllegalArgumentException\n-                (\"bad significance level: \" + alpha);\n-       }\n-       return (tTest(sample1, sample2) < alpha);\n-    }\n-    \n+        throws IllegalArgumentException, MathException {\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw new IllegalArgumentException(\n+                \"bad significance level: \" + alpha);\n+        }\n+        return (tTest(sample1, sample2) < alpha);\n+    }\n+\n     /**\n      * @param mu constant value to compare sample mean against\n      * @param sample array of sample data values\n      * @return p-value\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double tTest(double mu, double[] sample) \n-        throws IllegalArgumentException {\n+    public double tTest(double mu, double[] sample)\n+        throws IllegalArgumentException, MathException {\n         if ((sample == null) || (sample.length < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-        return tTest(StatUtils.mean(sample), mu, StatUtils.variance(sample),\n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return tTest(\n+            StatUtils.mean(sample),\n+            mu,\n+            StatUtils.variance(sample),\n             sample.length);\n     }\n-    \n+\n     /**\n      * @param mu comparison constant\n      * @param sampleStats DescriptiveStatistics holding sample summary statitstics\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double t(double mu, DescriptiveStatistics sampleStats) \n+    public double t(double mu, DescriptiveStatistics sampleStats)\n         throws IllegalArgumentException {\n         if ((sampleStats == null) || (sampleStats.getN() < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-        return t(sampleStats.getMean(), mu, sampleStats.getVariance(), \n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return t(\n+            sampleStats.getMean(),\n+            mu,\n+            sampleStats.getVariance(),\n             sampleStats.getN());\n     }\n-    \n+\n     /**\n      * @param sampleStats1 DescriptiveStatistics describing data from the first sample\n      * @param sampleStats2 DescriptiveStatistics describing data from the second sample\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double t(DescriptiveStatistics sampleStats1, DescriptiveStatistics sampleStats2) \n+    public double t(\n+        DescriptiveStatistics sampleStats1,\n+        DescriptiveStatistics sampleStats2)\n         throws IllegalArgumentException {\n-        if ((sampleStats1 == null) || (sampleStats2 == null || \n-            Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-        return t(sampleStats1.getMean(), sampleStats2.getMean(), \n-            sampleStats1.getVariance(), sampleStats2.getVariance(), \n-            (double) sampleStats1.getN(), (double) sampleStats2.getN());\n-    }\n-    \n+        if ((sampleStats1 == null)\n+            || (sampleStats2 == null\n+                || Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return t(\n+            sampleStats1.getMean(),\n+            sampleStats2.getMean(),\n+            sampleStats1.getVariance(),\n+            sampleStats2.getVariance(),\n+            (double) sampleStats1.getN(),\n+            (double) sampleStats2.getN());\n+    }\n+\n     /**\n      * @param sampleStats1 DescriptiveStatistics describing data from the first sample\n      * @param sampleStats2 DescriptiveStatistics describing data from the second sample\n      * @return p-value for t-test\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double tTest(DescriptiveStatistics sampleStats1, DescriptiveStatistics sampleStats2)\n-        throws IllegalArgumentException {\n-        if ((sampleStats1 == null) || (sampleStats2 == null || \n-            Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-         return tTest(sampleStats1.getMean(), sampleStats2.getMean(), \n-            sampleStats1.getVariance(), sampleStats2.getVariance(), \n-            (double) sampleStats1.getN(), (double) sampleStats2.getN());\n-    }\n-    \n+    public double tTest(\n+        DescriptiveStatistics sampleStats1,\n+        DescriptiveStatistics sampleStats2)\n+        throws IllegalArgumentException, MathException {\n+        if ((sampleStats1 == null)\n+            || (sampleStats2 == null\n+                || Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return tTest(\n+            sampleStats1.getMean(),\n+            sampleStats2.getMean(),\n+            sampleStats1.getVariance(),\n+            sampleStats2.getVariance(),\n+            (double) sampleStats1.getN(),\n+            (double) sampleStats2.getN());\n+    }\n+\n     /**\n      * @param sampleStats1 DescriptiveStatistics describing sample data values\n      * @param sampleStats2 DescriptiveStatistics describing sample data values\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      */\n-    public boolean tTest(DescriptiveStatistics sampleStats1, DescriptiveStatistics sampleStats2, \n-    double alpha) throws IllegalArgumentException {\n+    public boolean tTest(\n+        DescriptiveStatistics sampleStats1,\n+        DescriptiveStatistics sampleStats2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n-            throw new IllegalArgumentException\n-                (\"bad significance level: \" + alpha);\n+            throw new IllegalArgumentException(\n+                \"bad significance level: \" + alpha);\n         }\n         return (tTest(sampleStats1, sampleStats2) < alpha);\n     }\n-    \n+\n     /**\n      * @param mu constant value to compare sample mean against\n      * @param sampleStats DescriptiveStatistics describing sample data values\n      * @return p-value\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public boolean tTest(double mu, DescriptiveStatistics sampleStats, double alpha)\n-        throws IllegalArgumentException {\n+    public boolean tTest(\n+        double mu,\n+        DescriptiveStatistics sampleStats,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n-           throw new IllegalArgumentException\n-                (\"bad significance level: \" + alpha);\n-        }   \n+            throw new IllegalArgumentException(\n+                \"bad significance level: \" + alpha);\n+        }\n         return (tTest(mu, sampleStats) < alpha);\n     }\n-    \n+\n     /**\n      * @param mu constant value to compare sample mean against\n      * @param sampleStats DescriptiveStatistics describing sample data\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n     public double tTest(double mu, DescriptiveStatistics sampleStats)\n-        throws IllegalArgumentException {\n+        throws IllegalArgumentException, MathException {\n         if ((sampleStats == null) || (sampleStats.getN() < 5)) {\n-            throw new IllegalArgumentException\n-                (\"insufficient data for t statistic\");\n-        }\n-        return tTest(sampleStats.getMean(), mu, sampleStats.getVariance(),\n+            throw new IllegalArgumentException(\"insufficient data for t statistic\");\n+        }\n+        return tTest(\n+            sampleStats.getMean(),\n+            mu,\n+            sampleStats.getVariance(),\n             sampleStats.getN());\n     }\n-    \n+\n     //----------------------------------------------- Private methods \n-    \n+\n     /**\n      * Computes approximate degrees of freedom for 2-sample t-test.\n      * \n      * @return approximate degrees of freedom\n      */\n     private double df(double v1, double v2, double n1, double n2) {\n-        return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2))) /\n-            ((v1 * v1) / (n1 * n1 * (n1 - 1d)) + \n-                (v2 * v2) / (n2 * n2 * (n2 - 1d)));       \n-    }\n-    \n-     /**\n-     * Computes t test statistic for 2-sample t-test.\n-     * \n-     * @param m1 first sample mean\n-     * @param m2 second sample mean\n-     * @param v1 first sample variance\n-     * @param v2 second sample variance\n-     * @param n1 first sample n\n-     * @param n2 second sample n\n-     * @return t test statistic\n-     */\n-    private double t(double m1, double m2, double v1, double v2, double n1, \n+        return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2)))\n+            / ((v1 * v1) / (n1 * n1 * (n1 - 1d))\n+                + (v2 * v2) / (n2 * n2 * (n2 - 1d)));\n+    }\n+\n+    /**\n+    * Computes t test statistic for 2-sample t-test.\n+    * \n+    * @param m1 first sample mean\n+    * @param m2 second sample mean\n+    * @param v1 first sample variance\n+    * @param v2 second sample variance\n+    * @param n1 first sample n\n+    * @param n2 second sample n\n+    * @return t test statistic\n+    */\n+    private double t(\n+        double m1,\n+        double m2,\n+        double v1,\n+        double v2,\n+        double n1,\n         double n2) {\n         return (m1 - m2) / Math.sqrt((v1 / n1) + (v2 / n2));\n     }\n-    \n+\n     /**\n      * Computes t test statistic for 1-sample t-test.\n      * \n     private double t(double m, double mu, double v, double n) {\n         return (m - mu) / Math.sqrt(v / n);\n     }\n-    \n+\n     /**\n      * Computes p-value for 2-sided, 2-sample t-test.\n      * \n      * @param n2 second sample n\n      * @return p-value\n      */\n-    private double tTest(double m1, double m2, double v1, double v2, double n1, \n-        double n2) {\n+    private double tTest(\n+        double m1,\n+        double m2,\n+        double v1,\n+        double v2,\n+        double n1,\n+        double n2)\n+        throws MathException {\n         double t = Math.abs(t(m1, m2, v1, v2, n1, n2));\n-        TDistribution tDistribution = \n-            DistributionFactory.newInstance().createTDistribution\n-                (df(v1, v2, n1, n2));\n-        return 1.0 - tDistribution.cummulativeProbability(-t, t); \n-    }\n-    \n+        TDistribution tDistribution =\n+            DistributionFactory.newInstance().createTDistribution(\n+                df(v1, v2, n1, n2));\n+        return 1.0 - tDistribution.cummulativeProbability(-t, t);\n+    }\n+\n     /**\n      * Computes p-value for 2-sided, 1-sample t-test.\n      * \n      * @param n sample n\n      * @return p-value\n      */\n-    private double tTest(double m, double mu, double v, double n) {\n-    double t = Math.abs(t(m, mu, v, n)); \n-        TDistribution tDistribution = \n-            DistributionFactory.newInstance().createTDistribution\n-                (n - 1);\n+    private double tTest(double m, double mu, double v, double n)\n+        throws MathException {\n+        double t = Math.abs(t(m, mu, v, n));\n+        TDistribution tDistribution =\n+            DistributionFactory.newInstance().createTDistribution(n - 1);\n         return 1.0 - tDistribution.cummulativeProbability(-t, t);\n-    }          \n+    }\n }\n--- a/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.8 $ $Date: 2003/11/15 16:01:39 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class BinomialDistributionTest extends TestCase {\n     private BinomialDistribution b;\n-    \n+\n     /**\n      * Constructor for ChiSquareDistributionTest.\n      * @param name\n      */\n     protected void setUp() throws Exception {\n         super.setUp();\n-        b = DistributionFactory.newInstance().createBinomialDistribution(10, 0.70);\n+        b =\n+            DistributionFactory.newInstance().createBinomialDistribution(\n+                10,\n+                0.70);\n     }\n \n     /*\n     public void testInverseCummulativeProbability001() {\n         testValue(1, .001);\n     }\n-    \n+\n     public void testInverseCumulativeProbability010() {\n         testValue(2, .010);\n     }\n-    \n+\n     public void testInverseCumulativeProbability025() {\n         testValue(3, .025);\n     }\n     public void testInverseCumulativeProbability050() {\n         testValue(4, .050);\n     }\n-    \n+\n     public void testInverseCumulativeProbability100() {\n         testValue(4, .100);\n     }\n     public void testInverseCummulativeProbability999() {\n         testValue(9, .999);\n     }\n-    \n+\n     public void testInverseCumulativeProbability990() {\n         testValue(9, .990);\n     }\n-    \n+\n     public void testInverseCumulativeProbability975() {\n         testValue(9, .975);\n     }\n     public void testInverseCumulativeProbability950() {\n         testValue(8, .950);\n     }\n-    \n+\n     public void testInverseCumulativeProbability900() {\n         testValue(8, .900);\n     }\n     public void testCummulativeProbability1() {\n         testProbability(1, .00014);\n     }\n-    \n+\n     public void testCumulativeProbability2() {\n         testProbability(2, .00159);\n     }\n-    \n+\n     public void testCumulativeProbability3() {\n         testProbability(3, .01059);\n     }\n     public void testCumulativeProbability4() {\n         testProbability(4, .04735);\n     }\n-    \n+\n     public void testCumulativeProbability9() {\n         testProbability(9, .97175);\n     }\n     public void testCummulativeProbability8() {\n         testProbability(8, .85069);\n     }\n-    \n-    private void testProbability(int x, double expected){\n-        double actual = b.cummulativeProbability(x);\n-        assertEquals(expected, actual, 10e-4);\n+\n+    private void testProbability(int x, double expected) {\n+        try {\n+            double actual = b.cummulativeProbability(x);\n+            assertEquals(expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n     }\n-    \n-    private void testValue(int expected, double p){\n-        int actual = b.inverseCummulativeProbability(p);\n-        assertEquals(expected, actual);\n-        assertTrue(b.cummulativeProbability(actual) <= p);\n-        assertTrue(b.cummulativeProbability(actual + 1) >= p);\n+\n+    private void testValue(int expected, double p) {\n+        try {\n+            int actual = b.inverseCummulativeProbability(p);\n+            assertEquals(expected, actual);\n+            assertTrue(b.cummulativeProbability(actual) <= p);\n+            assertTrue(b.cummulativeProbability(actual + 1) >= p);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.9 $ $Date: 2003/11/15 16:01:39 $\n+ * @version $Revision: 1.10 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class ChiSquareDistributionTest extends TestCase {\n     private ChiSquaredDistribution chiSquare;\n     }\n     \n     private void testProbability(double x, double expected){\n-        double actual = chiSquare.cummulativeProbability(x);\n-        assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+        try {\n+            double actual = chiSquare.cummulativeProbability(x);\n+            assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            e.printStackTrace();\n+        }\n+        \n     }\n     \n     private void testValue(double p, double expected){\n-        double actual = chiSquare.inverseCummulativeProbability(p);\n-        assertEquals(\"value for \" + p, expected, actual, 10e-4);\n+        try {\n+            double actual = chiSquare.inverseCummulativeProbability(p);\n+            assertEquals(\"value for \" + p, expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            e.printStackTrace();\n+        }\n+        \n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n \n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.8 $ $Date: 2003/11/15 16:01:39 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class ExponentialDistributionTest extends TestCase {\n     private ExponentialDistribution exp;\n-    \n+\n     /**\n      * Constructor for ChiSquareDistributionTest.\n      * @param name\n      */\n     protected void setUp() throws Exception {\n         super.setUp();\n-        exp = DistributionFactory.newInstance().createExponentialDistribution(5.0);\n+        exp =\n+            DistributionFactory.newInstance().createExponentialDistribution(\n+                5.0);\n     }\n \n     /*\n     public void testInverseCummulativeProbability001() {\n         testValue(.005003, .001);\n     }\n-    \n+\n     public void testInverseCummulativeProbability010() {\n         testValue(0.050252, .010);\n     }\n-    \n+\n     public void testInverseCummulativeProbability025() {\n         testValue(0.126589, .025);\n     }\n     public void testInverseCummulativeProbability050() {\n         testValue(0.256566, .050);\n     }\n-    \n+\n     public void testInverseCummulativeProbability100() {\n         testValue(0.526803, .100);\n     }\n     public void testInverseCummulativeProbability999() {\n         testValue(34.5388, .999);\n     }\n-    \n+\n     public void testInverseCummulativeProbability990() {\n         testValue(23.0259, .990);\n     }\n-    \n+\n     public void testInverseCummulativeProbability975() {\n         testValue(18.4444, .975);\n     }\n     public void testInverseCummulativeProbability950() {\n         testValue(14.9787, .950);\n     }\n-    \n+\n     public void testInverseCummulativeProbability900() {\n         testValue(11.5129, .900);\n     }\n     public void testCummulativeProbability001() {\n         testProbability(0.005003, .001);\n     }\n-    \n+\n     public void testCummulativeProbability010() {\n         testProbability(0.050252, .010);\n     }\n-    \n+\n     public void testCummulativeProbability025() {\n         testProbability(0.126589, .025);\n     }\n     public void testCummulativeProbability050() {\n         testProbability(0.256566, .050);\n     }\n-    \n+\n     public void testCummulativeProbability100() {\n         testProbability(0.526803, .100);\n     }\n     public void testCummulativeProbability999() {\n         testProbability(34.5388, .999);\n     }\n-    \n+\n     public void testCummulativeProbability990() {\n         testProbability(23.0259, .990);\n     }\n-    \n+\n     public void testCummulativeProbability975() {\n         testProbability(18.4444, .975);\n     }\n     public void testCummulativeProbability950() {\n         testProbability(14.9787, .950);\n     }\n-    \n+\n     public void testCummulativeProbability900() {\n         testProbability(11.5129, .900);\n     }\n     public void testInverseCummulativeProbabilityPositive() {\n         testValue(Double.NaN, 2.0);\n     }\n-    \n+\n     public void testCummulativeProbability2() {\n-        double actual = exp.cummulativeProbability(0.25, 0.75);\n-        assertEquals(0.0905214, actual, 10e-4);\n-    }\n-    \n-    private void testProbability(double x, double expected){\n-        double actual = exp.cummulativeProbability(x);\n-        TestUtils.assertEquals(expected, actual, 10e-4);\n-    }\n-    \n-    private void testValue(double expected, double p){\n-        double actual = exp.inverseCummulativeProbability(p);\n-        TestUtils.assertEquals(expected, actual, 10e-4);\n+        try {\n+            double actual = exp.cummulativeProbability(0.25, 0.75);\n+            assertEquals(0.0905214, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+    }\n+\n+    private void testProbability(double x, double expected) {\n+        try {\n+            double actual = exp.cummulativeProbability(x);\n+            TestUtils.assertEquals(expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void testValue(double expected, double p) {\n+        try {\n+            double actual = exp.inverseCummulativeProbability(p);\n+            TestUtils.assertEquals(expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.7 $ $Date: 2003/11/15 16:01:40 $\n+ * @version $Revision: 1.8 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class FDistributionTest extends TestCase {\n     private FDistribution f;\n-    \n+\n     /**\n      * Constructor for ChiSquareDistributionTest.\n      * @param name\n         super.tearDown();\n     }\n \n-    public void testLowerTailProbability(){\n+    public void testLowerTailProbability() {\n         testProbability(1.0 / 10.67, .010);\n-        testProbability(1.0 /  6.98, .025);\n-        testProbability(1.0 /  4.95, .050);\n-        testProbability(1.0 /  3.40, .100);\n+        testProbability(1.0 / 6.98, .025);\n+        testProbability(1.0 / 4.95, .050);\n+        testProbability(1.0 / 3.40, .100);\n     }\n \n-    public void testUpperTailProbability(){\n+    public void testUpperTailProbability() {\n         testProbability(8.75, .990);\n         testProbability(5.99, .975);\n         testProbability(4.39, .950);\n         testProbability(3.11, .900);\n     }\n-    \n-    public void testLowerTailValues(){\n+\n+    public void testLowerTailValues() {\n         testValue(1.0 / 10.67, .010);\n-        testValue(1.0 /  6.98, .025);\n-        testValue(1.0 /  4.95, .050);\n-        testValue(1.0 /  3.40, .100);\n+        testValue(1.0 / 6.98, .025);\n+        testValue(1.0 / 4.95, .050);\n+        testValue(1.0 / 3.40, .100);\n     }\n-    \n-    public void testUpperTailValues(){\n+\n+    public void testUpperTailValues() {\n         testValue(8.75, .990);\n         testValue(5.99, .975);\n         testValue(4.39, .950);\n         testValue(3.11, .900);\n     }\n-    \n-    private void testProbability(double x, double expected){\n-        double actual = f.cummulativeProbability(x);\n-        assertEquals(\"probability for \" + x, expected, actual, 1e-3);\n+\n+    private void testProbability(double x, double expected) {\n+        try {\n+            double actual = f.cummulativeProbability(x);\n+            assertEquals(\"probability for \" + x, expected, actual, 1e-3);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n-    \n-    private void testValue(double expected, double p){\n-        double actual = f.inverseCummulativeProbability(p);\n-        assertEquals(\"value for \" + p, expected, actual, 1e-2);\n+\n+    private void testValue(double expected, double p) {\n+        try {\n+            double actual = f.inverseCummulativeProbability(p);\n+            assertEquals(\"value for \" + p, expected, actual, 1e-2);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.10 $ $Date: 2003/11/15 16:01:40 $\n+ * @version $Revision: 1.11 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class GammaDistributionTest extends TestCase {\n-    public void testProbabilities(){\n+    public void testProbabilities() {\n         testProbability(-1.000, 4.0, 2.0, .0000);\n         testProbability(15.501, 4.0, 2.0, .9499);\n-        testProbability( 0.504, 4.0, 1.0, .0018);\n+        testProbability(0.504, 4.0, 1.0, .0018);\n         testProbability(10.011, 1.0, 2.0, .9933);\n-        testProbability( 5.000, 2.0, 2.0, .7127);\n-    }\n-    \n-    public void testValues(){\n-        testValue(15.501, 4.0, 2.0, .9499);\n-        testValue( 0.504, 4.0, 1.0, .0018);\n-        testValue(10.011, 1.0, 2.0, .9933);\n-        testValue( 5.000, 2.0, 2.0, .7127);\n-    }\n-            \n-    private void testProbability(double x, double a, double b, double expected){\n-        double actual = DistributionFactory.newInstance().createGammaDistribution(a, b).cummulativeProbability(x);\n-        assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+        testProbability(5.000, 2.0, 2.0, .7127);\n     }\n \n-    private void testValue(double expected, double a, double b, double p){\n-        double actual = DistributionFactory.newInstance().createGammaDistribution(a, b).inverseCummulativeProbability(p);\n-        assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n+    public void testValues() {\n+        testValue(15.501, 4.0, 2.0, .9499);\n+        testValue(0.504, 4.0, 1.0, .0018);\n+        testValue(10.011, 1.0, 2.0, .9933);\n+        testValue(5.000, 2.0, 2.0, .7127);\n+    }\n+\n+    private void testProbability(\n+        double x,\n+        double a,\n+        double b,\n+        double expected) {\n+        try {\n+            double actual =\n+                DistributionFactory\n+                    .newInstance()\n+                    .createGammaDistribution(a, b)\n+                    .cummulativeProbability(x);\n+            assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void testValue(double expected, double a, double b, double p) {\n+        try {\n+            double actual =\n+                DistributionFactory\n+                    .newInstance()\n+                    .createGammaDistribution(a, b)\n+                    .inverseCummulativeProbability(p);\n+            assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/11/15 16:01:40 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class HypergeometricDistributionTest extends TestCase {\n     private HypergeometricDistribution h;\n-    \n+\n     /**\n      * Constructor for ChiSquareDistributionTest.\n      * @param name\n      */\n     protected void setUp() throws Exception {\n         super.setUp();\n-        h = DistributionFactory.newInstance().createHypergeometricDistribution(10, 5, 5);\n+        h =\n+            DistributionFactory.newInstance().createHypergeometricDistribution(\n+                10,\n+                5,\n+                5);\n     }\n \n     /*\n     public void testInverseCummulativeProbability001() {\n         testValue(-1, .001);\n     }\n-    \n+\n     public void testInverseCumulativeProbability010() {\n         testValue(0, .010);\n     }\n-    \n+\n     public void testInverseCumulativeProbability025() {\n         testValue(0, .025);\n     }\n     public void testInverseCumulativeProbability050() {\n         testValue(0, .050);\n     }\n-    \n+\n     public void testInverseCumulativeProbability100() {\n         testValue(0, .100);\n     }\n     public void testInverseCummulativeProbability999() {\n         testValue(4, .999);\n     }\n-    \n+\n     public void testInverseCumulativeProbability990() {\n         testValue(3, .990);\n     }\n-    \n+\n     public void testInverseCumulativeProbability975() {\n         testValue(3, .975);\n     }\n     public void testInverseCumulativeProbability950() {\n         testValue(3, .950);\n     }\n-    \n+\n     public void testInverseCumulativeProbability900() {\n         testValue(3, .900);\n     }\n     public void testCummulativeProbability1() {\n         testProbability(1, .10318);\n     }\n-    \n+\n     public void testCumulativeProbability2() {\n         testProbability(2, .50000);\n     }\n-    \n+\n     public void testCumulativeProbability3() {\n         testProbability(3, .89683);\n     }\n     public void testCumulativeProbability4() {\n         testProbability(4, .99603);\n     }\n-    \n+\n     public void testCumulativeProbability5() {\n         testProbability(5, 1.00000);\n     }\n \n-    private void testProbability(int x, double expected){\n-        double actual = h.cummulativeProbability(x);\n-        assertEquals(expected, actual, 10e-4);\n+    private void testProbability(int x, double expected) {\n+        try {\n+            double actual = h.cummulativeProbability(x);\n+            assertEquals(expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n-    \n-    private void testValue(int expected, double p){\n-        int actual = h.inverseCummulativeProbability(p);\n-        assertEquals(expected, actual);\n-        assertTrue(h.cummulativeProbability(actual) <= p);\n-        assertTrue(h.cummulativeProbability(actual + 1) >= p);\n+\n+    private void testValue(int expected, double p) {\n+        try {\n+            int actual = h.inverseCummulativeProbability(p);\n+            assertEquals(expected, actual);\n+            assertTrue(h.cummulativeProbability(actual) <= p);\n+            assertTrue(h.cummulativeProbability(actual + 1) >= p);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.8 $ $Date: 2003/11/15 16:01:40 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/19 03:22:54 $\n  */\n public class TDistributionTest extends TestCase {\n     private TDistribution t;\n-    \n+\n     /**\n      * Constructor for ChiSquareDistributionTest.\n      * @param name\n     public void testInverseCummulativeProbability001() {\n         testValue(-5.893, .001);\n     }\n-    \n+\n     public void testInverseCumulativeProbability010() {\n         testValue(-3.365, .010);\n     }\n-    \n+\n     public void testInverseCumulativeProbability025() {\n         testValue(-2.571, .025);\n     }\n     public void testInverseCumulativeProbability050() {\n         testValue(-2.015, .050);\n     }\n-    \n+\n     public void testInverseCumulativeProbability100() {\n         testValue(-1.476, .100);\n     }\n     public void testInverseCummulativeProbability999() {\n         testValue(5.893, .999);\n     }\n-    \n+\n     public void testInverseCumulativeProbability990() {\n         testValue(3.365, .990);\n     }\n-    \n+\n     public void testInverseCumulativeProbability975() {\n         testValue(2.571, .975);\n     }\n     public void testInverseCumulativeProbability950() {\n         testValue(2.015, .950);\n     }\n-    \n+\n     public void testInverseCumulativeProbability900() {\n         testValue(1.476, .900);\n     }\n     public void testCummulativeProbability001() {\n         testProbability(-5.893, .001);\n     }\n-    \n+\n     public void testCumulativeProbability010() {\n         testProbability(-3.365, .010);\n     }\n-    \n+\n     public void testCumulativeProbability025() {\n         testProbability(-2.571, .025);\n     }\n     public void testCumulativeProbability050() {\n         testProbability(-2.015, .050);\n     }\n-    \n+\n     public void testCumulativeProbability100() {\n         testProbability(-1.476, .100);\n     }\n     public void testCummulativeProbability999() {\n         testProbability(5.893, .999);\n     }\n-    \n+\n     public void testCumulativeProbability990() {\n         testProbability(3.365, .990);\n     }\n-    \n+\n     public void testCumulativeProbability975() {\n         testProbability(2.571, .975);\n     }\n     public void testCumulativeProbability950() {\n         testProbability(2.015, .950);\n     }\n-    \n+\n     public void testCumulativeProbability900() {\n         testProbability(1.476, .900);\n     }\n-    \n-    private void testProbability(double x, double expected){\n-        double actual = t.cummulativeProbability(x);\n-        assertEquals(expected, actual, 10e-4);\n+\n+    private void testProbability(double x, double expected) {\n+        try {\n+            double actual = t.cummulativeProbability(x);\n+            assertEquals(expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n-    \n-    private void testValue(double expected, double p){\n-        double actual = t.inverseCummulativeProbability(p);\n-        assertEquals(expected, actual, 10e-4);\n+\n+    private void testValue(double expected, double p) {\n+        try {\n+            double actual = t.inverseCummulativeProbability(p);\n+            assertEquals(expected, actual, 10e-4);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/stat/BivariateRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/BivariateRegressionTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math.MathException;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n /**\n  * Test cases for the TestStatistic class.\n  *\n- * @version $Revision: 1.9 $ $Date: 2003/11/18 15:07:12 $\n+ * @version $Revision: 1.10 $ $Date: 2003/11/19 03:22:54 $\n  */\n \n public final class BivariateRegressionTest extends TestCase {\n      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n      * Strangely, order is {y,x}\n      */\n-    private double[][] data = {{0.1,0.2},{338.8,337.4},{118.1,118.2},\n-        {888.0,884.6},{9.2,10.1},{228.1,226.5},{668.5,666.3},{998.5,996.3},\n-        {449.1,448.6},{778.9,777.0},{559.2,558.2},{0.3,0.4},{0.1,0.6},\n-        {778.1,775.5},{668.8,666.9},{339.3,338.0},{448.9,447.5},{10.8,11.6},\n-        {557.7,556.0},{228.3,228.1},{998.0,995.8},{888.8,887.6},{119.6,120.2},\n-        {0.3,0.3},{0.6,0.3},{557.6,556.8},{339.3,339.1},{888.0,887.2},\n-        {998.5,999.0},{778.9,779.0},{10.2,11.1},{117.6,118.3},{228.9,229.2},\n-        {668.4,669.1},{449.2,448.9},{0.2,0.5}}; \n-        \n+    private double[][] data = { { 0.1, 0.2 }, {\n+            338.8, 337.4 }, {\n+            118.1, 118.2 }, {\n+            888.0, 884.6 }, {\n+            9.2, 10.1 }, {\n+            228.1, 226.5 }, {\n+            668.5, 666.3 }, {\n+            998.5, 996.3 }, {\n+            449.1, 448.6 }, {\n+            778.9, 777.0 }, {\n+            559.2, 558.2 }, {\n+            0.3, 0.4 }, {\n+            0.1, 0.6 }, {\n+            778.1, 775.5 }, {\n+            668.8, 666.9 }, {\n+            339.3, 338.0 }, {\n+            448.9, 447.5 }, {\n+            10.8, 11.6 }, {\n+            557.7, 556.0 }, {\n+            228.3, 228.1 }, {\n+            998.0, 995.8 }, {\n+            888.8, 887.6 }, {\n+            119.6, 120.2 }, {\n+            0.3, 0.3 }, {\n+            0.6, 0.3 }, {\n+            557.6, 556.8 }, {\n+            339.3, 339.1 }, {\n+            888.0, 887.2 }, {\n+            998.5, 999.0 }, {\n+            778.9, 779.0 }, {\n+            10.2, 11.1 }, {\n+            117.6, 118.3 }, {\n+            228.9, 229.2 }, {\n+            668.4, 669.1 }, {\n+            449.2, 448.9 }, {\n+            0.2, 0.5 }\n+    };\n+\n     /* \n      * Correlation example from \n      * http://www.xycoon.com/correlation.htm\n      */\n-    private double[][] corrData = {{101.0,99.2},{100.1,99.0},{100.0,100.0},\n-        {90.6,111.6},{86.5,122.2},{89.7,117.6},{90.6,121.1},{82.8,136.0},\n-        {70.1,154.2},{65.4,153.6},{61.3,158.5},{62.5,140.6},{63.6,136.2},\n-        {52.6,168.0},{59.7,154.3},{59.5,149.0},{61.3,165.5}};\n-        \n+    private double[][] corrData = { { 101.0, 99.2 }, {\n+            100.1, 99.0 }, {\n+            100.0, 100.0 }, {\n+            90.6, 111.6 }, {\n+            86.5, 122.2 }, {\n+            89.7, 117.6 }, {\n+            90.6, 121.1 }, {\n+            82.8, 136.0 }, {\n+            70.1, 154.2 }, {\n+            65.4, 153.6 }, {\n+            61.3, 158.5 }, {\n+            62.5, 140.6 }, {\n+            63.6, 136.2 }, {\n+            52.6, 168.0 }, {\n+            59.7, 154.3 }, {\n+            59.5, 149.0 }, {\n+            61.3, 165.5 }\n+    };\n+\n     /*\n      * From Moore and Mcabe, \"Introduction to the Practice of Statistics\"\n      * Example 10.3 \n      */\n-    private double[][] infData = {{15.6,5.2},{26.8,6.1},{37.8,8.7},{36.4,8.5},\n-    {35.5,8.8},{18.6,4.9},{15.3,4.5},{7.9,2.5},{0.0,1.1}};\n-    \n+    private double[][] infData = { { 15.6, 5.2 }, {\n+            26.8, 6.1 }, {\n+            37.8, 8.7 }, {\n+            36.4, 8.5 }, {\n+            35.5, 8.8 }, {\n+            18.6, 4.9 }, {\n+            15.3, 4.5 }, {\n+            7.9, 2.5 }, {\n+            0.0, 1.1 }\n+    };\n+\n     /*\n      * From http://www.xycoon.com/simple_linear_regression.htm\n      */\n-    private double[][] infData2 = {{1,3},{2,5},{3,7},{4,14},{5,11}};\n-    \n+    private double[][] infData2 = { { 1, 3 }, {\n+            2, 5 }, {\n+            3, 7 }, {\n+            4, 14 }, {\n+            5, 11 }\n+    };\n+\n     public BivariateRegressionTest(String name) {\n         super(name);\n     }\n-    \n-    public void setUp() { \n+\n+    public void setUp() {\n     }\n \n     public static Test suite() {\n         suite.setName(\"BivariateRegression Tests\");\n         return suite;\n     }\n-    \n+\n     public void testNorris() {\n-       BivariateRegression regression = new BivariateRegression();\n-       for (int i = 0; i < data.length; i++) {\n-           regression.addData(data[i][1],data[i][0]);\n-       }\n-       assertEquals(\"slope\",1.00211681802045, \n-            regression.getSlope(),10E-12);\n-       assertEquals(\"slope std err\",0.429796848199937E-03, \n-            regression.getSlopeStdErr(),10E-12);\n-       assertEquals(\"number of observations\",36,regression.getN());\n-       assertEquals(\"intercept\", -0.262323073774029,\n-            regression.getIntercept(),10E-12);\n-       assertEquals(\"std err intercept\", 0.232818234301152, \n-            regression.getInterceptStdErr(),10E-12);\n-       assertEquals(\"r-square\",0.999993745883712,\n-            regression.getRSquare(),10E-12);\n-       assertEquals(\"SSR\",4255954.13232369, \n-            regression.getRegressionSumSquares(),10E-9);\n-       assertEquals(\"MSE\",0.782864662630069, \n-            regression.getMeanSquareError(),10E-10);\n-       assertEquals(\"SSE\",26.6173985294224, \n-            regression.getSumSquaredErrors(),10E-9);\n-       assertEquals(\"predict(0)\",-0.262323073774029,\n-            regression.predict(0),10E-12);\n-       assertEquals(\"predict(1)\",1.00211681802045-0.262323073774029,\n-            regression.predict(1),10E-12);\n-    }\n-    \n+        BivariateRegression regression = new BivariateRegression();\n+        for (int i = 0; i < data.length; i++) {\n+            regression.addData(data[i][1], data[i][0]);\n+        }\n+        assertEquals(\"slope\", 1.00211681802045, regression.getSlope(), 10E-12);\n+        assertEquals(\n+            \"slope std err\",\n+            0.429796848199937E-03,\n+            regression.getSlopeStdErr(),\n+            10E-12);\n+        assertEquals(\"number of observations\", 36, regression.getN());\n+        assertEquals(\n+            \"intercept\",\n+            -0.262323073774029,\n+            regression.getIntercept(),\n+            10E-12);\n+        assertEquals(\n+            \"std err intercept\",\n+            0.232818234301152,\n+            regression.getInterceptStdErr(),\n+            10E-12);\n+        assertEquals(\n+            \"r-square\",\n+            0.999993745883712,\n+            regression.getRSquare(),\n+            10E-12);\n+        assertEquals(\n+            \"SSR\",\n+            4255954.13232369,\n+            regression.getRegressionSumSquares(),\n+            10E-9);\n+        assertEquals(\n+            \"MSE\",\n+            0.782864662630069,\n+            regression.getMeanSquareError(),\n+            10E-10);\n+        assertEquals(\n+            \"SSE\",\n+            26.6173985294224,\n+            regression.getSumSquaredErrors(),\n+            10E-9);\n+        assertEquals(\n+            \"predict(0)\",\n+            -0.262323073774029,\n+            regression.predict(0),\n+            10E-12);\n+        assertEquals(\n+            \"predict(1)\",\n+            1.00211681802045 - 0.262323073774029,\n+            regression.predict(1),\n+            10E-12);\n+    }\n+\n     public void testCorr() {\n-       BivariateRegression regression = new BivariateRegression();\n-       regression.addData(corrData);\n-       assertEquals(\"number of observations\",17,regression.getN());\n-       assertEquals(\"r-square\",.896123,\n-            regression.getRSquare(),10E-6);\n-       assertEquals(\"r\",-.946638, \n-            regression.getR(),10E-6);\n-    }  \n-    \n+        BivariateRegression regression = new BivariateRegression();\n+        regression.addData(corrData);\n+        assertEquals(\"number of observations\", 17, regression.getN());\n+        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        assertEquals(\"r\", -.946638, regression.getR(), 10E-6);\n+    }\n+\n     public void testNaNs() {\n-        \n-        BivariateRegression regression = new BivariateRegression();\n-        \n-        assertTrue(\"intercept not NaN\",Double.isNaN(regression.getIntercept()));\n-        assertTrue(\"slope not NaN\",Double.isNaN(regression.getSlope()));\n-        assertTrue(\"slope std err not NaN\",\n+\n+        BivariateRegression regression = new BivariateRegression();\n+\n+        assertTrue(\n+            \"intercept not NaN\",\n+            Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        assertTrue(\n+            \"slope std err not NaN\",\n             Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err not NaN\",\n+        assertTrue(\n+            \"intercept std err not NaN\",\n             Double.isNaN(regression.getInterceptStdErr()));\n-        assertTrue(\"MSE not NaN\",Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"e not NaN\",Double.isNaN(regression.getR()));\n-        assertTrue(\"r-square not NaN\",Double.isNaN(regression.getRSquare()));\n-        assertTrue(\"RSS not NaN\",\n+        assertTrue(\n+            \"MSE not NaN\",\n+            Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        assertTrue(\n+            \"RSS not NaN\",\n             Double.isNaN(regression.getRegressionSumSquares()));\n-        assertTrue(\"SSE not NaN\",Double.isNaN(regression.getSumSquaredErrors()));\n-        assertTrue(\"SSTO not NaN\",Double.isNaN(regression.getTotalSumSquares()));\n-        assertTrue(\"predict not NaN\",Double.isNaN(regression.predict(0)));\n-        \n-        regression.addData(1,2);\n-        regression.addData(1,3);\n-        \n+        assertTrue(\n+            \"SSE not NaN\",\n+            Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\n+            \"SSTO not NaN\",\n+            Double.isNaN(regression.getTotalSumSquares()));\n+        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+\n+        regression.addData(1, 2);\n+        regression.addData(1, 3);\n+\n         // No x variation, so these should still blow...\n-        assertTrue(\"intercept not NaN\",Double.isNaN(regression.getIntercept()));\n-        assertTrue(\"slope not NaN\",Double.isNaN(regression.getSlope()));\n-        assertTrue(\"slope std err not NaN\",\n+        assertTrue(\n+            \"intercept not NaN\",\n+            Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        assertTrue(\n+            \"slope std err not NaN\",\n             Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err not NaN\",\n+        assertTrue(\n+            \"intercept std err not NaN\",\n             Double.isNaN(regression.getInterceptStdErr()));\n-        assertTrue(\"MSE not NaN\",Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"e not NaN\",Double.isNaN(regression.getR()));\n-        assertTrue(\"r-square not NaN\",Double.isNaN(regression.getRSquare()));\n-        assertTrue(\"RSS not NaN\",\n+        assertTrue(\n+            \"MSE not NaN\",\n+            Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        assertTrue(\n+            \"RSS not NaN\",\n             Double.isNaN(regression.getRegressionSumSquares()));\n-        assertTrue(\"SSE not NaN\",Double.isNaN(regression.getSumSquaredErrors()));\n-        assertTrue(\"predict not NaN\",Double.isNaN(regression.predict(0)));\n-        \n+        assertTrue(\n+            \"SSE not NaN\",\n+            Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+\n         // but SSTO should be OK\n-         assertTrue(\"SSTO NaN\",!Double.isNaN(regression.getTotalSumSquares()));\n-        \n+        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+\n         regression = new BivariateRegression();\n-        \n-        regression.addData(1,2);\n-        regression.addData(3,3);\n-        \n+\n+        regression.addData(1, 2);\n+        regression.addData(3, 3);\n+\n         // All should be OK except MSE, s(b0), s(b1) which need one more df \n-        assertTrue(\"interceptNaN\",!Double.isNaN(regression.getIntercept()));\n-        assertTrue(\"slope NaN\",!Double.isNaN(regression.getSlope()));\n-        assertTrue(\"slope std err not NaN\",\n+        assertTrue(\"interceptNaN\", !Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope NaN\", !Double.isNaN(regression.getSlope()));\n+        assertTrue(\n+            \"slope std err not NaN\",\n             Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err not NaN\",\n+        assertTrue(\n+            \"intercept std err not NaN\",\n             Double.isNaN(regression.getInterceptStdErr()));\n-        assertTrue(\"MSE not NaN\",Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"r NaN\",!Double.isNaN(regression.getR()));\n-        assertTrue(\"r-square NaN\",!Double.isNaN(regression.getRSquare()));\n-        assertTrue(\"RSS NaN\",\n+        assertTrue(\n+            \"MSE not NaN\",\n+            Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"r NaN\", !Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square NaN\", !Double.isNaN(regression.getRSquare()));\n+        assertTrue(\n+            \"RSS NaN\",\n             !Double.isNaN(regression.getRegressionSumSquares()));\n-        assertTrue(\"SSE NaN\",!Double.isNaN(regression.getSumSquaredErrors()));\n-        assertTrue(\"SSTO NaN\",!Double.isNaN(regression.getTotalSumSquares()));\n-        assertTrue(\"predict NaN\",!Double.isNaN(regression.predict(0)));\n-        \n-        regression.addData(1,4);\n-        \n+        assertTrue(\"SSE NaN\", !Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+        assertTrue(\"predict NaN\", !Double.isNaN(regression.predict(0)));\n+\n+        regression.addData(1, 4);\n+\n         // MSE, MSE, s(b0), s(b1) should all be OK now\n-        assertTrue(\"MSE NaN\",!Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"slope std err NaN\",\n+        assertTrue(\"MSE NaN\", !Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\n+            \"slope std err NaN\",\n             !Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err NaN\",\n+        assertTrue(\n+            \"intercept std err NaN\",\n             !Double.isNaN(regression.getInterceptStdErr()));\n     }\n-    \n+\n     public void testClear() {\n-       BivariateRegression regression = new BivariateRegression();\n-       regression.addData(corrData);\n-       assertEquals(\"number of observations\",17,regression.getN());\n-       regression.clear();\n-       assertEquals(\"number of observations\",0,regression.getN());\n-       regression.addData(corrData);\n-       assertEquals(\"r-square\",.896123,regression.getRSquare(),10E-6);\n-       regression.addData(data);\n-       assertEquals(\"number of observations\",53,regression.getN());\n-    }\n-    \n+        BivariateRegression regression = new BivariateRegression();\n+        regression.addData(corrData);\n+        assertEquals(\"number of observations\", 17, regression.getN());\n+        regression.clear();\n+        assertEquals(\"number of observations\", 0, regression.getN());\n+        regression.addData(corrData);\n+        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        regression.addData(data);\n+        assertEquals(\"number of observations\", 53, regression.getN());\n+    }\n+\n     public void testInference() {\n-       BivariateRegression regression = new BivariateRegression();\n-       regression.addData(infData);\n-       assertEquals(\"slope confidence interval\", 0.0271,\n-            regression.getSlopeConfidenceInterval(),0.0001);\n-       assertEquals(\"slope std err\",0.01146,\n-            regression.getSlopeStdErr(),0.0001);\n-       \n-       regression = new BivariateRegression();\n-       regression.addData(infData2);\n-       assertEquals(\"significance\", 0.023331,\n-            regression.getSignificance(),0.0001);\n-       \n-       //FIXME: get a real example to test against with alpha = .01\n-       assertTrue(\"tighter means wider\",\n-            regression.getSlopeConfidenceInterval() < \n-            regression.getSlopeConfidenceInterval(0.01));\n-       \n-       try {\n-           double x = regression.getSlopeConfidenceInterval(1);\n-           fail(\"expecting IllegalArgumentException for alpha = 1\");\n-       } catch (IllegalArgumentException ex) {\n-           ;\n-       }\n-       \n-    }\n-    \n+\n+        BivariateRegression regression = new BivariateRegression();\n+        regression.addData(infData);\n+\n+        try {\n+            assertEquals(\n+                \"slope confidence interval\",\n+                0.0271,\n+                regression.getSlopeConfidenceInterval(),\n+                0.0001);\n+            assertEquals(\n+                \"slope std err\",\n+                0.01146,\n+                regression.getSlopeStdErr(),\n+                0.0001);\n+\n+            regression = new BivariateRegression();\n+            regression.addData(infData2);\n+            assertEquals(\n+                \"significance\",\n+                0.023331,\n+                regression.getSignificance(),\n+                0.0001);\n+\n+            //FIXME: get a real example to test against with alpha = .01\n+            assertTrue(\n+                \"tighter means wider\",\n+                regression.getSlopeConfidenceInterval()\n+                    < regression.getSlopeConfidenceInterval(0.01));\n+\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+        try {\n+            double x = regression.getSlopeConfidenceInterval(1);\n+            fail(\"expecting IllegalArgumentException for alpha = 1\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+    }\n+\n     public void testPerfect() {\n         BivariateRegression regression = new BivariateRegression();\n         int n = 100;\n         for (int i = 0; i < n; i++) {\n             regression.addData(((double) i) / (n - 1), i);\n         }\n-        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n-        assertTrue(regression.getSlope() > 0.0);\n-    }\n-    \n+\n+        try {\n+            assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+            assertTrue(regression.getSlope() > 0.0);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+    }\n+\n     public void testPerfectNegative() {\n         BivariateRegression regression = new BivariateRegression();\n         int n = 100;\n         for (int i = 0; i < n; i++) {\n-            regression.addData(-((double) i) / (n - 1), i);\n-        }\n-        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n-        assertTrue(regression.getSlope() < 0.0);\n-    }\n-    \n+            regression.addData(- ((double) i) / (n - 1), i);\n+        }\n+        try {\n+            assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+            assertTrue(regression.getSlope() < 0.0);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+    }\n+\n     public void testRandom() {\n         BivariateRegression regression = new BivariateRegression();\n         Random random = new Random(1);\n         for (int i = 0; i < n; i++) {\n             regression.addData(((double) i) / (n - 1), random.nextDouble());\n         }\n-        assertTrue(0.0 < regression.getSignificance() && regression.getSignificance() < 1.0);\n+\n+        try {\n+            assertTrue(\n+                0.0 < regression.getSignificance()\n+                    && regression.getSignificance() < 1.0);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/stat/TestStatisticTest.java\n+++ b/src/test/org/apache/commons/math/stat/TestStatisticTest.java\n  */\n package org.apache.commons.math.stat;\n \n+import org.apache.commons.math.MathException;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n /**\n  * Test cases for the TestStatistic class.\n  *\n- * @version $Revision: 1.8 $ $Date: 2003/11/15 16:01:41 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/19 03:22:54 $\n  */\n \n public final class TestStatisticTest extends TestCase {\n \n     private TestStatisticImpl testStatistic = new TestStatisticImpl();\n-    \n+\n     public TestStatisticTest(String name) {\n         super(name);\n     }\n-    \n-    \n-    public void setUp() { \n+\n+    public void setUp() {\n     }\n \n     public static Test suite() {\n     }\n \n     public void testChiSquare() {\n-       double[] observed = {11,24,69,96};\n-       double[] expected = {8.2,25.2,65.8,100.8};\n-       assertEquals(\"chi-square statistic\", \n-           1.39743495,testStatistic.chiSquare(expected,observed),10E-5);\n-       \n-       double[] tooShortObs = {0};\n-       double[] tooShortEx = {1};\n-       try {\n-           testStatistic.chiSquare(tooShortObs,tooShortEx);\n-           fail(\"arguments too short, IllegalArgumentException expected\");\n-       } catch (IllegalArgumentException ex) {\n-           ;\n-       }\n-       \n-       try {\n-           testStatistic.chiSquareTest(tooShortObs,tooShortEx);\n-           fail(\"arguments too short, IllegalArgumentException expected\");\n-       } catch (IllegalArgumentException ex) {\n-           ;\n-       }\n-       \n-       double[] unMatchedObs = {0,1,2,3};\n-       double[] unMatchedEx = {1,1,2};\n-       try {\n-           testStatistic.chiSquare(unMatchedEx,unMatchedObs);\n-           fail(\"arrays have different lengths,\" + \n-                \" IllegalArgumentException expected\");\n-       } catch (IllegalArgumentException ex) {\n-           ;\n-       }       \n-       expected[0] = 0;\n-       try {\n-           testStatistic.chiSquareTest(expected, observed, .01);\n-           fail(\"bad expected count, IllegalArgumentException expected\");\n-       } catch (IllegalArgumentException ex) {\n-           ;\n-       }     \n-       /** from http://www.vsenvirginia.org/stat/classpractice/Voter_Preferences_CP.pdf */\n-       double[] observed1 = {504, 523, 72, 70, 31};\n-       double[] expected1 = {480, 540, 84, 60, 36};\n-       assertEquals(\"chi-square test statistic\", 5.81,\n-            testStatistic.chiSquare(expected1,observed1),10E-2);\n-       assertEquals(\"chi-square p-value\", 0.21, \n-        testStatistic.chiSquareTest(expected1, observed1),10E-2); \n-       assertTrue(\"chi-square test reject\", \n-        testStatistic.chiSquareTest(expected1, observed1, 0.3));\n-       assertTrue(\"chi-square test accept\", \n-        !testStatistic.chiSquareTest(expected1, observed1, 0.1));  \n-       try {\n-           testStatistic.chiSquareTest(expected1, observed1, 95);\n-           fail(\"alpha out of range, IllegalArgumentException expected\");\n-       } catch (IllegalArgumentException ex) {\n-           ;\n-       }\n+        double[] observed = { 11, 24, 69, 96 };\n+        double[] expected = { 8.2, 25.2, 65.8, 100.8 };\n+        assertEquals(\n+            \"chi-square statistic\",\n+            1.39743495,\n+            testStatistic.chiSquare(expected, observed),\n+            10E-5);\n+\n+        double[] tooShortObs = { 0 };\n+        double[] tooShortEx = { 1 };\n+        try {\n+            testStatistic.chiSquare(tooShortObs, tooShortEx);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+\n+        try {\n+            testStatistic.chiSquareTest(tooShortObs, tooShortEx);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+        double[] unMatchedObs = { 0, 1, 2, 3 };\n+        double[] unMatchedEx = { 1, 1, 2 };\n+        try {\n+            testStatistic.chiSquare(unMatchedEx, unMatchedObs);\n+            fail(\n+                \"arrays have different lengths,\"\n+                    + \" IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        expected[0] = 0;\n+        try {\n+            testStatistic.chiSquareTest(expected, observed, .01);\n+            fail(\"bad expected count, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        /** from http://www.vsenvirginia.org/stat/classpractice/Voter_Preferences_CP.pdf */\n+        double[] observed1 = { 504, 523, 72, 70, 31 };\n+        double[] expected1 = { 480, 540, 84, 60, 36 };\n+\n+        try {\n+            assertEquals(\n+                \"chi-square test statistic\",\n+                5.81,\n+                testStatistic.chiSquare(expected1, observed1),\n+                10E-2);\n+            assertEquals(\n+                \"chi-square p-value\",\n+                0.21,\n+                testStatistic.chiSquareTest(expected1, observed1),\n+                10E-2);\n+            assertTrue(\n+                \"chi-square test reject\",\n+                testStatistic.chiSquareTest(expected1, observed1, 0.3));\n+            assertTrue(\n+                \"chi-square test accept\",\n+                !testStatistic.chiSquareTest(expected1, observed1, 0.1));\n+\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+        try {\n+            testStatistic.chiSquareTest(expected1, observed1, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n     }\n-       \n-    public void testT(){\n-\tdouble[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0,\n-            94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0};\n+\n+    public void testT() {\n+        double[] observed =\n+            {\n+                93.0,\n+                103.0,\n+                95.0,\n+                101.0,\n+                91.0,\n+                105.0,\n+                96.0,\n+                94.0,\n+                101.0,\n+                88.0,\n+                98.0,\n+                94.0,\n+                101.0,\n+                92.0,\n+                95.0 };\n         double mu = 100.0;\n         DescriptiveStatistics sampleStats = null;\n-\t\ttry {\n-\t\t\tsampleStats = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e5) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te5.printStackTrace();\n-\t\t} catch (IllegalAccessException e5) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te5.printStackTrace();\n-\t\t}\n-\t\tfor (int i = 0; i < observed.length; i++) {\n+        try {\n+            sampleStats =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e5) {\n+            // TODO Auto-generated catch block\n+            e5.printStackTrace();\n+        } catch (IllegalAccessException e5) {\n+            // TODO Auto-generated catch block\n+            e5.printStackTrace();\n+        }\n+        for (int i = 0; i < observed.length; i++) {\n             sampleStats.addValue(observed[i]);\n         }\n-        \n-        assertEquals(\"t statistic\", -2.82, testStatistic.t(mu, observed),\n+\n+        assertEquals(\n+            \"t statistic\",\n+            -2.82,\n+            testStatistic.t(mu, observed),\n             10E-3);\n-        assertEquals(\"t statistic\", -2.82, testStatistic.t(mu, sampleStats),\n+        assertEquals(\n+            \"t statistic\",\n+            -2.82,\n+            testStatistic.t(mu, sampleStats),\n             10E-3);\n-        \n+\n         double[] nullObserved = null;\n         try {\n             testStatistic.t(mu, nullObserved);\n         } catch (IllegalArgumentException ex) {\n             ;\n         }\n-        \n-\t\tDescriptiveStatistics nullStats = null;\n-\t\ttry {\n-\t\t\tnullStats = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e6) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te6.printStackTrace();\n-\t\t} catch (IllegalAccessException e6) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te6.printStackTrace();\n-\t\t}\n-\t\ttry {\n+\n+        DescriptiveStatistics nullStats = null;\n+        try {\n+            nullStats =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e6) {\n+            // TODO Auto-generated catch block\n+            e6.printStackTrace();\n+        } catch (IllegalAccessException e6) {\n+            // TODO Auto-generated catch block\n+            e6.printStackTrace();\n+        }\n+        try {\n             testStatistic.t(mu, nullStats);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             ;\n         }\n-        \n-        double[] emptyObs = {};\n+\n+        double[] emptyObs = {\n+        };\n         try {\n             testStatistic.t(mu, emptyObs);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n             ;\n         }\n \n-\t\tDescriptiveStatistics emptyStats = null;\n-\t\ttry {\n-\t\t\temptyStats = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e4) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te4.printStackTrace();\n-\t\t} catch (IllegalAccessException e4) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te4.printStackTrace();\n-\t\t}\n-\t\ttry {\n+        DescriptiveStatistics emptyStats = null;\n+        try {\n+            emptyStats =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e4) {\n+            // TODO Auto-generated catch block\n+            e4.printStackTrace();\n+        } catch (IllegalAccessException e4) {\n+            // TODO Auto-generated catch block\n+            e4.printStackTrace();\n+        }\n+        try {\n             testStatistic.t(mu, emptyStats);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             ;\n         }\n-        \n-        double[] tooShortObs = {1.0};\n+\n+        double[] tooShortObs = { 1.0 };\n         try {\n             testStatistic.t(mu, tooShortObs);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n             fail(\"arguments too short, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             ;\n-        }\n-\n-\t\tDescriptiveStatistics tooShortStats = null;\n-\t\ttry {\n-\t\t\ttooShortStats = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e3) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te3.printStackTrace();\n-\t\t} catch (IllegalAccessException e3) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te3.printStackTrace();\n-\t\t}\n-\t\ttooShortStats.addValue(0d);\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+        DescriptiveStatistics tooShortStats = null;\n+        try {\n+            tooShortStats =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e3) {\n+            // TODO Auto-generated catch block\n+            e3.printStackTrace();\n+        } catch (IllegalAccessException e3) {\n+            // TODO Auto-generated catch block\n+            e3.printStackTrace();\n+        }\n+        tooShortStats.addValue(0d);\n         tooShortStats.addValue(2d);\n         try {\n             testStatistic.t(mu, tooShortStats);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             ;\n-        }\n-            \n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n         /** Moore and McCabe Example 8.3, p 516 */\n-        double[] oneSidedP = {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, \n-            6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d};\n-            \n-\n-\t\tDescriptiveStatistics oneSidedPStats = null;\n-\t\ttry {\n-\t\t\toneSidedPStats = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e2) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te2.printStackTrace();\n-\t\t} catch (IllegalAccessException e2) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te2.printStackTrace();\n-\t\t}\n-\t\tfor (int i = 0; i < oneSidedP.length; i++) {\n+        double[] oneSidedP =\n+            {\n+                2d,\n+                0d,\n+                6d,\n+                6d,\n+                3d,\n+                3d,\n+                2d,\n+                3d,\n+                -6d,\n+                6d,\n+                6d,\n+                6d,\n+                3d,\n+                0d,\n+                1d,\n+                1d,\n+                0d,\n+                2d,\n+                3d,\n+                3d };\n+\n+        DescriptiveStatistics oneSidedPStats = null;\n+        try {\n+            oneSidedPStats =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e2) {\n+            // TODO Auto-generated catch block\n+            e2.printStackTrace();\n+        } catch (IllegalAccessException e2) {\n+            // TODO Auto-generated catch block\n+            e2.printStackTrace();\n+        }\n+        for (int i = 0; i < oneSidedP.length; i++) {\n             oneSidedPStats.addValue(oneSidedP[i]);\n         }\n-        assertEquals(\"one sample t stat\",3.86,\n-            testStatistic.t(0d,oneSidedP),0.01);\n-        assertEquals(\"one sample t stat\",3.86,\n-            testStatistic.t(0d,oneSidedPStats),0.01);\n-        assertEquals(\"one sample p value\",0.00052,\n-            testStatistic.tTest(0d,oneSidedP)/2d,10E-5);\n-        assertEquals(\"one sample p value\",0.00052,\n-            testStatistic.tTest(0d,oneSidedPStats)/2d,10E-5);\n-        assertTrue(\"one sample t-test reject\",\n-            testStatistic.tTest(0d,oneSidedP,0.01));\n-        assertTrue(\"one sample t-test reject\",\n-            testStatistic.tTest(0d,oneSidedPStats,0.01));\n-        assertTrue(\"one sample t-test accept\",\n-            !testStatistic.tTest(0d,oneSidedP,0.0001));\n-        assertTrue(\"one sample t-test accept\",\n-            !testStatistic.tTest(0d,oneSidedPStats,0.0001));\n-        try {\n-           testStatistic.tTest(0d,oneSidedP, 95);\n-           fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.tTest(0d,oneSidedPStats, 95);\n-           fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }   \n-        \n+\n+        try {\n+            assertEquals(\n+                \"one sample t stat\",\n+                3.86,\n+                testStatistic.t(0d, oneSidedP),\n+                0.01);\n+            assertEquals(\n+                \"one sample t stat\",\n+                3.86,\n+                testStatistic.t(0d, oneSidedPStats),\n+                0.01);\n+            assertEquals(\n+                \"one sample p value\",\n+                0.00052,\n+                testStatistic.tTest(0d, oneSidedP) / 2d,\n+                10E-5);\n+            assertEquals(\n+                \"one sample p value\",\n+                0.00052,\n+                testStatistic.tTest(0d, oneSidedPStats) / 2d,\n+                10E-5);\n+            assertTrue(\n+                \"one sample t-test reject\",\n+                testStatistic.tTest(0d, oneSidedP, 0.01));\n+            assertTrue(\n+                \"one sample t-test reject\",\n+                testStatistic.tTest(0d, oneSidedPStats, 0.01));\n+            assertTrue(\n+                \"one sample t-test accept\",\n+                !testStatistic.tTest(0d, oneSidedP, 0.0001));\n+            assertTrue(\n+                \"one sample t-test accept\",\n+                !testStatistic.tTest(0d, oneSidedPStats, 0.0001));\n+\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n+        try {\n+            testStatistic.tTest(0d, oneSidedP, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(0d, oneSidedPStats, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+\n         /** Moore and McCabe Example 8.12, p 552 */\n-        double[] sample1 = {7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d};\n-        double[] sample2 = {-1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d};\n-\n-\t\tDescriptiveStatistics sampleStats1 = null;\n-\t\ttry {\n-\t\t\tsampleStats1 = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e1) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te1.printStackTrace();\n-\t\t} catch (IllegalAccessException e1) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te1.printStackTrace();\n-\t\t}\n-\t\tfor (int i = 0; i < sample1.length; i++) {\n+        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n+        double[] sample2 =\n+            { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n+\n+        DescriptiveStatistics sampleStats1 = null;\n+        try {\n+            sampleStats1 =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e1) {\n+            // TODO Auto-generated catch block\n+            e1.printStackTrace();\n+        } catch (IllegalAccessException e1) {\n+            // TODO Auto-generated catch block\n+            e1.printStackTrace();\n+        }\n+        for (int i = 0; i < sample1.length; i++) {\n             sampleStats1.addValue(sample1[i]);\n         }\n-        \n-\t\tDescriptiveStatistics sampleStats2 = null;\n-\t\ttry {\n-\t\t\tsampleStats2 = DescriptiveStatistics.newInstance(StorelessDescriptiveStatisticsImpl.class);\n-\t\t} catch (InstantiationException e) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te.printStackTrace();\n-\t\t} catch (IllegalAccessException e) {\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\tfor (int i = 0; i < sample2.length; i++) {\n+\n+        DescriptiveStatistics sampleStats2 = null;\n+        try {\n+            sampleStats2 =\n+                DescriptiveStatistics.newInstance(\n+                    StorelessDescriptiveStatisticsImpl.class);\n+        } catch (InstantiationException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        for (int i = 0; i < sample2.length; i++) {\n             sampleStats2.addValue(sample2[i]);\n         }\n-        //FIXME: textbook example reported t stat uses pooled variance\n-        // should replace with R-verified example\n-        assertEquals(\"two sample t stat\",1.634,\n-            testStatistic.t(sample1, sample2), 0.1); \n-        assertEquals(\"two sample t stat\",1.634,\n-            testStatistic.t(sampleStats1, sampleStats2), 0.1); \n-        // This test is OK, since book reports non-pooled exact p-value\n-        assertEquals(\"two sample p value\",0.059, \n-            testStatistic.tTest(sample1, sample2)/2d, 10E-3);\n-        assertEquals(\"two sample p value\",0.059, \n-            testStatistic.tTest(sampleStats1, sampleStats2)/2d, 10E-3);\n-        assertTrue(\"two sample t-test reject\",\n-            testStatistic.tTest(sample1, sample2, 0.2));\n-        assertTrue(\"two sample t-test reject\",\n-            testStatistic.tTest(sampleStats1, sampleStats2, 0.2));\n-        assertTrue(\"two sample t-test accept\",\n-            !testStatistic.tTest(sample1, sample2,0.1));  \n-        assertTrue(\"two sample t-test accept\",\n-            !testStatistic.tTest(sampleStats1, sampleStats2,0.1));  \n-        try {\n-           testStatistic.tTest(sample1, sample2, 95);\n-           fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.tTest(sampleStats1, sampleStats2, 95);\n-           fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.tTest(sample1, tooShortObs, .01);\n-           fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.tTest(sampleStats1, tooShortStats, .01);\n-           fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.tTest(sample1, tooShortObs);\n-           fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.tTest(sampleStats1, tooShortStats);\n-           fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.t(sample1, tooShortObs);\n-           fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n-        }\n-        try {\n-           testStatistic.t(sampleStats1, tooShortStats);\n-           fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-           ;\n+        try {\n+            //FIXME: textbook example reported t stat uses pooled variance\n+            // should replace with R-verified example\n+            assertEquals(\n+                \"two sample t stat\",\n+                1.634,\n+                testStatistic.t(sample1, sample2),\n+                0.1);\n+            assertEquals(\n+                \"two sample t stat\",\n+                1.634,\n+                testStatistic.t(sampleStats1, sampleStats2),\n+                0.1);\n+            // This test is OK, since book reports non-pooled exact p-value\n+            assertEquals(\n+                \"two sample p value\",\n+                0.059,\n+                testStatistic.tTest(sample1, sample2) / 2d,\n+                10E-3);\n+            assertEquals(\n+                \"two sample p value\",\n+                0.059,\n+                testStatistic.tTest(sampleStats1, sampleStats2) / 2d,\n+                10E-3);\n+            assertTrue(\n+                \"two sample t-test reject\",\n+                testStatistic.tTest(sample1, sample2, 0.2));\n+            assertTrue(\n+                \"two sample t-test reject\",\n+                testStatistic.tTest(sampleStats1, sampleStats2, 0.2));\n+            assertTrue(\n+                \"two sample t-test accept\",\n+                !testStatistic.tTest(sample1, sample2, 0.1));\n+            assertTrue(\n+                \"two sample t-test accept\",\n+                !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));\n+\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(sample1, sample2, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(sampleStats1, sampleStats2, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(sample1, tooShortObs, .01);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(sampleStats1, tooShortStats, .01);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(sample1, tooShortObs);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.tTest(sampleStats1, tooShortStats);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } catch (MathException e) {\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+        try {\n+            testStatistic.t(sample1, tooShortObs);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            testStatistic.t(sampleStats1, tooShortStats);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n         }\n     }\n }\n-", "timestamp": 1069212174, "metainfo": ""}