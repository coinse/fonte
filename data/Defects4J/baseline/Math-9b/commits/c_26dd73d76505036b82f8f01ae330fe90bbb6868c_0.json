{"sha": "26dd73d76505036b82f8f01ae330fe90bbb6868c", "log": "MATH-478 FastMath is not an exact replacement for StrictMath Add missing methods - TODO implement our own versions Document which methods are additional to StrictMath  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n \n /**\n  * Faster, more accurate, portable alternative to StrictMath.\n+ * <p>\n+ * Additionally implements the following methods:\n+ * <ul>\n+ * <li>{@link #asinh(double)}</li>\n+ * <li>{@link #acosh(double)}</li>\n+ * <li>{@link #atanh(double)}</li>\n+ * <li>{@link #nextAfter(float,float)}</li>\n+ * <li>{@link #nextAfter(double,double)}</li>\n+ * <li>{@link #nextUp(double)}</li>\n+ * <li>{@link #nextUp(float)}</li>\n+ * </ul>\n  * @version $Revision$ $Date$\n  * @since 2.2\n  */\n                                             1.2599210498948732,\n                                             1.5874010519681994 };\n \n-    /** \n+    /**\n      * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n      */\n     private static final double HEX_40000000 = 1073741824.0;\n       }\n \n       if (abs(r) < Double.MAX_VALUE/HEX_40000000){ // is it safe to split r ?\n-          temp = r * HEX_40000000;          \n+          temp = r * HEX_40000000;\n       } else {\n           temp = 0.0;\n       }\n         return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n     }\n \n+    /**\n+     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n+     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n+     * avoiding intermediate overflow or underflow.\n+     *\n+     * <ul>\n+     * <li> If either argument is infinite, then the result is positive infinity.</li>\n+     * <li> else, if either argument is NaN then the result is NaN.</li>\n+     * </ul>\n+     *\n+     * @param x a value\n+     * @param y a value\n+     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n+     */\n+    public static double hypot(double x, double y) {\n+        return StrictMath.hypot(x, y); // TODO provide our own implementation\n+    }\n+    /**\n+     * Computes the remainder as prescribed by the IEEE 754 standard.\n+     * The remainder value is mathematically equal to {@code x - y*n}\n+     * where {@code n} is the mathematical integer closest to the exact mathematical value\n+     * of the quotient {@code x/y}.\n+     * If two mathematical integers are equally close to {@code x/y} then\n+     * {@code n} is the integer that is even.\n+     * <p>\n+     * <ul>\n+     * <li>If either operand is NaN, the result is NaN.</li>\n+     * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\n+     * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\n+     * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\n+     * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\n+     * </ul>\n+     * @param dividend the number to be divided\n+     * @param divisor the number by which to divide\n+     * @return the remainder, rounded\n+     */\n+    public static double IEEEremainder(double dividend, double divisor) {\n+        return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation\n+    }\n+    \n }", "timestamp": 1295640297, "metainfo": ""}