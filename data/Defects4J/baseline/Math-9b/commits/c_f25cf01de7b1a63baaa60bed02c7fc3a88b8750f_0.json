{"sha": "f25cf01de7b1a63baaa60bed02c7fc3a88b8750f", "log": "MATH-795   - In RealVectorTest.TestVectorImpl, removed add(RealVector) and subtract(RealVector), as they prevented testing of default implementations (provided in the RealVector abstract class).   - In RealVectorAbstractTest, extracted unit tests for     + RealVector.add(RealVector),     + RealVector.subtract(RealVector),     + RealVector.ebeMultiply(RealVector),     + RealVector.ebeDivide(RealVector).  These tests fail with OpenMapRealVector. This is identified as a bug (see MATH-803).   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n \n import java.util.Arrays;\n import java.util.Random;\n-\n-import junit.framework.Assert;\n \n import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.analysis.function.Abs;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n+import org.junit.Assert;\n import org.junit.Test;\n \n \n public abstract class RealVectorAbstractTest {\n+\n+    private enum BinaryOperation {\n+        ADD, SUB, MUL, DIV\n+    };\n+\n     /**\n      * Creates a new instance of {@link RealVector}, with specified entries.\n      * The returned vector must be of the type currently tested. It should be\n         Assert.assertFalse(v.isInfinite());\n     }\n \n+    private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) {\n+        /*\n+         * Make sure that x, y, z are three different values. Also, x is the\n+         * preferred value (e.g. the value which is not stored in sparse\n+         * implementations).\n+         */\n+        final double x = getPreferredEntryValue();\n+        final double y = x + 1d;\n+        final double z = y + 1d;\n+\n+        /*\n+         * This is an attempt at covering most particular cases of combining\n+         * two values.\n+         *\n+         * 1. Addition\n+         *    --------\n+         * The following cases should be covered\n+         * (2 * x) + (-x)\n+         * (-x) + 2 * x\n+         * x + y\n+         * y + x\n+         * y + z\n+         * y + (x - y)\n+         * (y - x) + x\n+         *\n+         * The values to be considered are: x, y, z, 2 * x, -x, x - y, y - x.\n+         *\n+         * 2. Subtraction\n+         *    -----------\n+         * The following cases should be covered\n+         * (2 * x) - x\n+         * x - y\n+         * y - x\n+         * y - z\n+         * y - (y - x)\n+         * (y + x) - y\n+         *\n+         * The values to be considered are: x, y, z, x + y, y - x.\n+         *\n+         * 3. Multiplication\n+         *    --------------\n+         * (x * x) * (1 / x)\n+         * (1 / x) * (x * x)\n+         * x * y\n+         * y * x\n+         * y * z\n+         *\n+         * The values to be considered are: x, y, z, 1 / x, x * x.\n+         *\n+         * 4. Division\n+         *    --------\n+         * (x * x) / x\n+         * x / y\n+         * y / x\n+         * y / z\n+         *\n+         * The values to be considered are: x, y, z, x * x.\n+         *\n+         * Also to be considered NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY.\n+         */\n+        final double[] values = {x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x};\n+        final double[] data1 = new double[values.length * values.length];\n+        final double[] data2 = new double[values.length * values.length];\n+        int k = 0;\n+        for (int i = 0; i < values.length; i++) {\n+            for (int j = 0; j < values.length; j++) {\n+                data1[k] = values[i];\n+                data2[k] = values[j];\n+                ++k;\n+            }\n+        }\n+        final RealVector v1 = create(data1);\n+        final RealVector v2 = mixed ? createAlien(data2) : create(data2);\n+        final RealVector actual;\n+        switch (op) {\n+            case ADD:\n+                actual = v1.add(v2);\n+                break;\n+            case SUB:\n+                actual = v1.subtract(v2);\n+                break;\n+            case MUL:\n+                actual = v1.ebeMultiply(v2);\n+                break;\n+            case DIV:\n+                actual = v1.ebeDivide(v2);\n+                break;\n+            default:\n+                throw new AssertionError(\"unexpected value\");\n+        }\n+        final double[] expected = new double[data1.length];\n+        for (int i = 0; i < expected.length; i++) {\n+            switch (op) {\n+                case ADD:\n+                    expected[i] = data1[i] + data2[i];\n+                    break;\n+                case SUB:\n+                    expected[i] = data1[i] - data2[i];\n+                    break;\n+                case MUL:\n+                    expected[i] = data1[i] * data2[i];\n+                    break;\n+                case DIV:\n+                    expected[i] = data1[i] / data2[i];\n+                    break;\n+                default:\n+                    throw new AssertionError(\"unexpected value\");\n+            }\n+        }\n+        for (int i = 0; i < expected.length; i++) {\n+            final String msg = \"entry #\"+i+\", left = \"+data1[i]+\", right = \" + data2[i];\n+            Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\n+        }\n+    }\n+\n+    private void doTestEbeBinaryOperationDimensionMismatch(final BinaryOperation op) {\n+        final int n = 10;\n+        switch (op) {\n+            case ADD:\n+                create(new double[n]).add(create(new double[n + 1]));\n+                break;\n+            case SUB:\n+                create(new double[n]).subtract(create(new double[n + 1]));\n+                break;\n+            case MUL:\n+                create(new double[n]).ebeMultiply(create(new double[n + 1]));\n+                break;\n+            case DIV:\n+                create(new double[n]).ebeDivide(create(new double[n + 1]));\n+                break;\n+            default:\n+                throw new AssertionError(\"unexpected value\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAddSameType() {\n+        doTestEbeBinaryOperation(BinaryOperation.ADD, false);\n+    }\n+\n+    @Test\n+    public void testAddMixedTypes() {\n+        doTestEbeBinaryOperation(BinaryOperation.ADD, true);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testAddDimensionMismatch() {\n+        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.ADD);\n+    }\n+\n+    @Test\n+    public void testSubtractSameType() {\n+        doTestEbeBinaryOperation(BinaryOperation.SUB, false);\n+    }\n+\n+    @Test\n+    public void testSubtractMixedTypes() {\n+        doTestEbeBinaryOperation(BinaryOperation.SUB, true);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testSubtractDimensionMismatch() {\n+        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.SUB);\n+    }\n+\n+    @Test\n+    public void testEbeMultiplySameType() {\n+        doTestEbeBinaryOperation(BinaryOperation.MUL, false);\n+    }\n+\n+    @Test\n+    public void testEbeMultiplyMixedTypes() {\n+        doTestEbeBinaryOperation(BinaryOperation.MUL, true);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testEbeMultiplyDimensionMismatch() {\n+        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.MUL);\n+    }\n+\n+    @Test\n+    public void testEbeDivideSameType() {\n+        doTestEbeBinaryOperation(BinaryOperation.DIV, false);\n+    }\n+\n+    @Test\n+    public void testEbeDivideMixedTypes() {\n+        doTestEbeBinaryOperation(BinaryOperation.DIV, true);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testEbeDivideDimensionMismatch() {\n+        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.DIV);\n+    }\n+\n     @Test\n     public void testDataInOut() {\n         final RealVector v1 = create(vec1);\n         double d_getLInfDistance_2 = v1.getLInfDistance(v2_t);\n         Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance_2,\n                             normTolerance);\n-\n-        // octave = v1 + v2\n-        final RealVector v_add = v1.add(v2);\n-        double[] result_add = {\n-            5d, 7d, 9d\n-        };\n-        assertClose(\"compare vect\", v_add.toArray(), result_add, normTolerance);\n-\n-        final RealVector vt2 = createAlien(vec2);\n-        RealVector v_add_i = v1.add(vt2);\n-        double[] result_add_i = {\n-            5d, 7d, 9d\n-        };\n-        assertClose(\"compare vect\", v_add_i.toArray(), result_add_i,\n-                    normTolerance);\n-\n-        // octave = v1 - v2\n-        final RealVector v_subtract = v1.subtract(v2);\n-        double[] result_subtract = {\n-            -3d, -3d, -3d\n-        };\n-        assertClose(\"compare vect\", v_subtract.toArray(), result_subtract,\n-                    normTolerance);\n-\n-        final RealVector v_subtract_i = v1.subtract(vt2);\n-        double[] result_subtract_i = {\n-            -3d, -3d, -3d\n-        };\n-        assertClose(\"compare vect\", v_subtract_i.toArray(), result_subtract_i,\n-                    normTolerance);\n-\n-        // octave v1 .* v2\n-        final RealVector v_ebeMultiply = v1.ebeMultiply(v2);\n-        double[] result_ebeMultiply = {\n-            4d, 10d, 18d\n-        };\n-        assertClose(\"compare vect\", v_ebeMultiply.toArray(),\n-                    result_ebeMultiply, normTolerance);\n-\n-        final RealVector v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n-        double[] result_ebeMultiply_2 = {\n-            4d, 10d, 18d\n-        };\n-        assertClose(\"compare vect\", v_ebeMultiply_2.toArray(),\n-                    result_ebeMultiply_2, normTolerance);\n-\n-        // octave v1 ./ v2\n-        final RealVector v_ebeDivide = v1.ebeDivide(v2);\n-        double[] result_ebeDivide = {\n-            0.25d, 0.4d, 0.5d\n-        };\n-        assertClose(\"compare vect\", v_ebeDivide.toArray(), result_ebeDivide,\n-                    normTolerance);\n-\n-        final RealVector v_ebeDivide_2 = v1.ebeDivide(v2_t);\n-        double[] result_ebeDivide_2 = {\n-            0.25d, 0.4d, 0.5d\n-        };\n-        assertClose(\"compare vect\", v_ebeDivide_2.toArray(),\n-                    result_ebeDivide_2, normTolerance);\n \n         // octave dot(v1,v2)\n         double dot = v1.dotProduct(v2);\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorTest.java\n         }\n \n         @Override\n-        public RealVector add(RealVector v) {\n-            RealVector result = new ArrayRealVector(v);\n-            return result.add(this);\n-        }\n-\n-        @Override\n-        public RealVector subtract(RealVector v) {\n-            RealVector result = new ArrayRealVector(v);\n-            return result.subtract(this).mapMultiplyToSelf(-1);\n-        }\n-\n-        @Override\n         public RealVector mapAddToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n                 values[i] += d;\n     @Ignore(\"Abstract class RealVector does not implement isNaN()\")\n     @Override\n     public void testIsInfinite() {\n+        // Do nothing\n+    }\n+\n+    @Test\n+    @Ignore(\"Abstract class RealVector does not implement ebeMultiply(RealVector)\")\n+    @Override\n+    public void testEbeMultiplySameType() {\n+        // Do nothing\n+    }\n+\n+    @Test\n+    @Ignore(\"Abstract class RealVector does not implement ebeMultiply(RealVector)\")\n+    @Override\n+    public void testEbeMultiplyMixedTypes() {\n+        // Do nothing\n+    }\n+\n+    @Test\n+    @Ignore(\"Abstract class RealVector does not implement ebeMultiply(RealVector)\")\n+    @Override\n+    public void testEbeMultiplyDimensionMismatch() {\n+        // Do nothing\n+    }\n+\n+    @Test\n+    @Ignore(\"Abstract class RealVector does not implement ebeDivide(RealVector)\")\n+    @Override\n+    public void testEbeDivideSameType() {\n+        // Do nothing\n+    }\n+\n+    @Test\n+    @Ignore(\"Abstract class RealVector does not implement ebeDivide(RealVector)\")\n+    @Override\n+    public void testEbeDivideMixedTypes() {\n+        // Do nothing\n+    }\n+\n+    @Test\n+    @Ignore(\"Abstract class RealVector does not implement ebeDivide(RealVector)\")\n+    @Override\n+    public void testEbeDivideDimensionMismatch() {\n         // Do nothing\n     }\n ", "timestamp": 1339268384, "metainfo": ""}