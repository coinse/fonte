{"sha": "48c0c453043ecae1e3edc3f2fbad658fadb1dcfa", "log": "Rewritten SVD implementation based on JAMA code.  JIRA: MATH-327, MATH-383, MATH-465, MATH-583, MATH-611  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.NumberIsTooLargeException;\n  * @since 2.0\n  */\n public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n-    /** Number of rows of the initial matrix. */\n+\n+    /** Relative threshold for small singular values. */\n+    private static final double EPS = 0x1.0p-52;\n+\n+    /** Absolute threshold for small singular values. */\n+    private static final double TINY = 0x1.0p-966;\n+\n+    /** Computed singular values. */\n+    private double[] singularValues;\n+\n+    /** Row dimension. */\n     private int m;\n-    /** Number of columns of the initial matrix. */\n+\n+    /** Column dimension. */\n     private int n;\n-    /** Eigen decomposition of the tridiagonal matrix. */\n-    private EigenDecomposition eigenDecomposition;\n-    /** Singular values. */\n-    private double[] singularValues;\n-    /** Cached value of U. */\n+\n+    /** Indicator for transposed matrix. */\n+    private boolean transposed;\n+\n+    /** Cached value of U matrix. */\n     private RealMatrix cachedU;\n-    /** Cached value of U<sup>T</sup>. */\n+\n+    /** Cached value of transposed U matrix. */\n     private RealMatrix cachedUt;\n-    /** Cached value of S. */\n+\n+    /** Cached value of S (diagonal) matrix. */\n     private RealMatrix cachedS;\n-    /** Cached value of V. */\n+\n+    /** Cached value of V matrix. */\n     private RealMatrix cachedV;\n-    /** Cached value of V<sup>T</sup>. */\n+\n+    /** Cached value of transposed V matrix. */\n     private RealMatrix cachedVt;\n \n     /**\n      * @param matrix Matrix to decompose.\n      */\n     public SingularValueDecompositionImpl(final RealMatrix matrix) {\n+\n+        // Derived from LINPACK code.\n+        // Initialize.\n+        double[][] A;\n         m = matrix.getRowDimension();\n         n = matrix.getColumnDimension();\n-\n-        cachedU = null;\n-        cachedS = null;\n-        cachedV = null;\n-        cachedVt = null;\n-\n-        double[][] localcopy = matrix.getData();\n-        double[][] matATA = new double[n][n];\n-        //\n-        // create A^T*A\n-        //\n-        for (int i = 0; i < n; i++) {\n-            for (int j = i; j < n; j++) {\n-                matATA[i][j] = 0.0;\n-                for (int k = 0; k < m; k++) {\n-                    matATA[i][j] += localcopy[k][i] * localcopy[k][j];\n-                }\n-                matATA[j][i] = matATA[i][j];\n-            }\n-        }\n-\n-        double[][] matAAT = new double[m][m];\n-        //\n-        // create A*A^T\n-        //\n-        for (int i = 0; i < m; i++) {\n-            for (int j = i; j < m; j++) {\n-                matAAT[i][j] = 0.0;\n-                for (int k = 0; k < n; k++) {\n-                    matAAT[i][j] += localcopy[i][k] * localcopy[j][k];\n-                }\n-                 matAAT[j][i] = matAAT[i][j];\n-            }\n-        }\n-        int p;\n-        if (m >= n) {\n-            p = n;\n-            // compute eigen decomposition of A^T*A\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n-            singularValues = eigenDecomposition.getRealEigenvalues();\n-            cachedV = eigenDecomposition.getV();\n-            // compute eigen decomposition of A*A^T\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n-            cachedU = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n+            transposed = true;\n+            A = matrix.transpose().getData();\n+            m = matrix.getColumnDimension();\n+            n = matrix.getRowDimension();\n         } else {\n-            p = m;\n-            // compute eigen decomposition of A*A^T\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n-            singularValues = eigenDecomposition.getRealEigenvalues();\n-            cachedU = eigenDecomposition.getV();\n-\n-            // compute eigen decomposition of A^T*A\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n-            cachedV = eigenDecomposition.getV().getSubMatrix(0, n - 1 , 0, p - 1);\n-        }\n-        for (int i = 0; i < p; i++) {\n-            singularValues[i] = FastMath.sqrt(FastMath.abs(singularValues[i]));\n-        }\n-        // Up to this point, U and V are computed independently of each other.\n-        // There still a sign indetermination of each column of, say, U.\n-        // The sign is set such that A.V_i=sigma_i.U_i (i<=p)\n-        // The right sign corresponds to a positive dot product of A.V_i and U_i\n-        for (int i = 0; i < p; i++) {\n-            RealVector tmp = cachedU.getColumnVector(i);\n-            double product=matrix.operate(cachedV.getColumnVector(i)).dotProduct(tmp);\n-            if (product < 0) {\n-                cachedU.setColumnVector(i, tmp.mapMultiply(-1));\n-            }\n+            transposed = false;\n+            A = matrix.getData();\n+            m = matrix.getRowDimension();\n+            n = matrix.getColumnDimension();\n+        }\n+        int nu = FastMath.min(m, n);\n+        singularValues = new double[FastMath.min(m + 1, n)];\n+        double[][] U = new double[m][nu];\n+        double[][] V = new double[n][n];\n+        double[] e = new double[n];\n+        double[] work = new double[m];\n+        boolean wantu = true;\n+        boolean wantv = true;\n+        // Reduce A to bidiagonal form, storing the diagonal elements\n+        // in s and the super-diagonal elements in e.\n+        int nct = FastMath.min(m - 1, n);\n+        int nrt = FastMath.max(0, FastMath.min(n - 2, m));\n+        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n+            if (k < nct) {\n+                // Compute the transformation for the k-th column and\n+                // place the k-th diagonal in s[k].\n+                // Compute 2-norm of k-th column without under/overflow.\n+                singularValues[k] = 0;\n+                for (int i = k; i < m; i++) {\n+                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n+                }\n+                if (singularValues[k] != 0.0) {\n+                    if (A[k][k] < 0.0) {\n+                        singularValues[k] = -singularValues[k];\n+                    }\n+                    for (int i = k; i < m; i++) {\n+                        A[i][k] /= singularValues[k];\n+                    }\n+                    A[k][k] += 1.0;\n+                }\n+                singularValues[k] = -singularValues[k];\n+            }\n+            for (int j = k + 1; j < n; j++) {\n+                if ((k < nct) & (singularValues[k] != 0.0)) {\n+                    // Apply the transformation.\n+                    double t = 0;\n+                    for (int i = k; i < m; i++) {\n+                        t += A[i][k] * A[i][j];\n+                    }\n+                    t = -t / A[k][k];\n+                    for (int i = k; i < m; i++) {\n+                        A[i][j] += t * A[i][k];\n+                    }\n+                }\n+                // Place the k-th row of A into e for the\n+                // subsequent calculation of the row transformation.\n+                e[j] = A[k][j];\n+            }\n+            if (wantu & (k < nct)) {\n+                // Place the transformation in U for subsequent back\n+                // multiplication.\n+                for (int i = k; i < m; i++) {\n+                    U[i][k] = A[i][k];\n+                }\n+            }\n+            if (k < nrt) {\n+                // Compute the k-th row transformation and place the\n+                // k-th super-diagonal in e[k].\n+                // Compute 2-norm without under/overflow.\n+                e[k] = 0;\n+                for (int i = k + 1; i < n; i++) {\n+                    e[k] = FastMath.hypot(e[k], e[i]);\n+                }\n+                if (e[k] != 0.0) {\n+                    if (e[k + 1] < 0.0) {\n+                        e[k] = -e[k];\n+                    }\n+                    for (int i = k + 1; i < n; i++) {\n+                        e[i] /= e[k];\n+                    }\n+                    e[k + 1] += 1.0;\n+                }\n+                e[k] = -e[k];\n+                if ((k + 1 < m) & (e[k] != 0.0)) {\n+                    // Apply the transformation.\n+                    for (int i = k + 1; i < m; i++) {\n+                        work[i] = 0.0;\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        for (int i = k + 1; i < m; i++) {\n+                            work[i] += e[j] * A[i][j];\n+                        }\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        double t = -e[j] / e[k + 1];\n+                        for (int i = k + 1; i < m; i++) {\n+                            A[i][j] += t * work[i];\n+                        }\n+                    }\n+                }\n+                if (wantv) {\n+                    // Place the transformation in V for subsequent\n+                    // back multiplication.\n+                    for (int i = k + 1; i < n; i++) {\n+                        V[i][k] = e[i];\n+                    }\n+                }\n+            }\n+        }\n+        // Set up the final bidiagonal matrix or order p.\n+        int p = FastMath.min(n, m + 1);\n+        if (nct < n) {\n+            singularValues[nct] = A[nct][nct];\n+        }\n+        if (m < p) {\n+            singularValues[p - 1] = 0.0;\n+        }\n+        if (nrt + 1 < p) {\n+            e[nrt] = A[nrt][p - 1];\n+        }\n+        e[p - 1] = 0.0;\n+        // If required, generate U.\n+        if (wantu) {\n+            for (int j = nct; j < nu; j++) {\n+                for (int i = 0; i < m; i++) {\n+                    U[i][j] = 0.0;\n+                }\n+                U[j][j] = 1.0;\n+            }\n+            for (int k = nct - 1; k >= 0; k--) {\n+                if (singularValues[k] != 0.0) {\n+                    for (int j = k + 1; j < nu; j++) {\n+                        double t = 0;\n+                        for (int i = k; i < m; i++) {\n+                            t += U[i][k] * U[i][j];\n+                        }\n+                        t = -t / U[k][k];\n+                        for (int i = k; i < m; i++) {\n+                            U[i][j] += t * U[i][k];\n+                        }\n+                    }\n+                    for (int i = k; i < m; i++) {\n+                        U[i][k] = -U[i][k];\n+                    }\n+                    U[k][k] = 1.0 + U[k][k];\n+                    for (int i = 0; i < k - 1; i++) {\n+                        U[i][k] = 0.0;\n+                    }\n+                } else {\n+                    for (int i = 0; i < m; i++) {\n+                        U[i][k] = 0.0;\n+                    }\n+                    U[k][k] = 1.0;\n+                }\n+            }\n+        }\n+        // If required, generate V.\n+        if (wantv) {\n+            for (int k = n - 1; k >= 0; k--) {\n+                if ((k < nrt) & (e[k] != 0.0)) {\n+                    for (int j = k + 1; j < nu; j++) {\n+                        double t = 0;\n+                        for (int i = k + 1; i < n; i++) {\n+                            t += V[i][k] * V[i][j];\n+                        }\n+                        t = -t / V[k + 1][k];\n+                        for (int i = k + 1; i < n; i++) {\n+                            V[i][j] += t * V[i][k];\n+                        }\n+                    }\n+                }\n+                for (int i = 0; i < n; i++) {\n+                    V[i][k] = 0.0;\n+                }\n+                V[k][k] = 1.0;\n+            }\n+        }\n+        // Main iteration loop for the singular values.\n+        int pp = p - 1;\n+        int iter = 0;\n+        while (p > 0) {\n+            int k, kase;\n+            // Here is where a test for too many iterations would go.\n+            // This section of the program inspects for\n+            // negligible elements in the s and e arrays.  On\n+            // completion the variables kase and k are set as follows.\n+            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n+            // kase = 2     if s(k) is negligible and k<p\n+            // kase = 3     if e[k-1] is negligible, k<p, and\n+            //              s(k), ..., s(p) are not negligible (qr step).\n+            // kase = 4     if e(p-1) is negligible (convergence).\n+            for (k = p - 2; k >= -1; k--) {\n+                if (k == -1) {\n+                    break;\n+                }\n+                final double threshold =\n+                        TINY + EPS * (FastMath.abs(singularValues[k]) + FastMath.abs(singularValues[k + 1]));\n+                if (FastMath.abs(e[k]) <= threshold) {\n+                    e[k] = 0.0;\n+                    break;\n+                }\n+            }\n+            if (k == p - 2) {\n+                kase = 4;\n+            } else {\n+                int ks;\n+                for (ks = p - 1; ks >= k; ks--) {\n+                    if (ks == k) {\n+                        break;\n+                    }\n+                    double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +\n+                               (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);\n+                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n+                        singularValues[ks] = 0.0;\n+                        break;\n+                    }\n+                }\n+                if (ks == k) {\n+                    kase = 3;\n+                } else if (ks == p - 1) {\n+                    kase = 1;\n+                } else {\n+                    kase = 2;\n+                    k = ks;\n+                }\n+            }\n+            k++;\n+            // Perform the task indicated by kase.\n+            switch (kase) {\n+                // Deflate negligible s(p).\n+                case 1: {\n+                    double f = e[p - 2];\n+                    e[p - 2] = 0.0;\n+                    for (int j = p - 2; j >= k; j--) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        double cs = singularValues[j] / t;\n+                        double sn = f / t;\n+                        singularValues[j] = t;\n+                        if (j != k) {\n+                            f = -sn * e[j - 1];\n+                            e[j - 1] = cs * e[j - 1];\n+                        }\n+                        if (wantv) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = cs * V[i][j] + sn * V[i][p - 1];\n+                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n+                                V[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+                // Split at negligible s(k).\n+                case 2: {\n+                    double f = e[k - 1];\n+                    e[k - 1] = 0.0;\n+                    for (int j = k; j < p; j++) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        double cs = singularValues[j] / t;\n+                        double sn = f / t;\n+                        singularValues[j] = t;\n+                        f = -sn * e[j];\n+                        e[j] = cs * e[j];\n+                        if (wantu) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][k - 1];\n+                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+                // Perform one qr step.\n+                case 3: {\n+                    // Calculate the shift.\n+                    double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(\n+                            FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])), FastMath.abs(e[p - 2])),\n+                            FastMath.abs(singularValues[k])), FastMath.abs(e[k]));\n+                    double sp = singularValues[p - 1] / scale;\n+                    double spm1 = singularValues[p - 2] / scale;\n+                    double epm1 = e[p - 2] / scale;\n+                    double sk = singularValues[k] / scale;\n+                    double ek = e[k] / scale;\n+                    double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n+                    double c = (sp * epm1) * (sp * epm1);\n+                    double shift = 0.0;\n+                    if ((b != 0.0) | (c != 0.0)) {\n+                        shift = FastMath.sqrt(b * b + c);\n+                        if (b < 0.0) {\n+                            shift = -shift;\n+                        }\n+                        shift = c / (b + shift);\n+                    }\n+                    double f = (sk + sp) * (sk - sp) + shift;\n+                    double g = sk * ek;\n+                    // Chase zeros.\n+                    for (int j = k; j < p - 1; j++) {\n+                        double t = FastMath.hypot(f, g);\n+                        double cs = f / t;\n+                        double sn = g / t;\n+                        if (j != k) {\n+                            e[j - 1] = t;\n+                        }\n+                        f = cs * singularValues[j] + sn * e[j];\n+                        e[j] = cs * e[j] - sn * singularValues[j];\n+                        g = sn * singularValues[j + 1];\n+                        singularValues[j + 1] = cs * singularValues[j + 1];\n+                        if (wantv) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = cs * V[i][j] + sn * V[i][j + 1];\n+                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n+                                V[i][j] = t;\n+                            }\n+                        }\n+                        t = FastMath.hypot(f, g);\n+                        cs = f / t;\n+                        sn = g / t;\n+                        singularValues[j] = t;\n+                        f = cs * e[j] + sn * singularValues[j + 1];\n+                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n+                        g = sn * e[j + 1];\n+                        e[j + 1] = cs * e[j + 1];\n+                        if (wantu && (j < m - 1)) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][j + 1];\n+                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                    e[p - 2] = f;\n+                    iter = iter + 1;\n+                }\n+                break;\n+                // Convergence.\n+                default: {\n+                    // Make the singular values positive.\n+                    if (singularValues[k] <= 0.0) {\n+                        singularValues[k] = singularValues[k] < 0.0 ? -singularValues[k] : 0.0;\n+                        if (wantv) {\n+                            for (int i = 0; i <= pp; i++) {\n+                                V[i][k] = -V[i][k];\n+                            }\n+                        }\n+                    }\n+                    // Order the singular values.\n+                    while (k < pp) {\n+                        if (singularValues[k] >= singularValues[k + 1]) {\n+                            break;\n+                        }\n+                        double t = singularValues[k];\n+                        singularValues[k] = singularValues[k + 1];\n+                        singularValues[k + 1] = t;\n+                        if (wantv && (k < n - 1)) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = V[i][k + 1];\n+                                V[i][k + 1] = V[i][k];\n+                                V[i][k] = t;\n+                            }\n+                        }\n+                        if (wantu && (k < m - 1)) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = U[i][k + 1];\n+                                U[i][k + 1] = U[i][k];\n+                                U[i][k] = t;\n+                            }\n+                        }\n+                        k++;\n+                    }\n+                    iter = 0;\n+                    p--;\n+                }\n+                break;\n+            }\n+        }\n+\n+        if (!transposed) {\n+            cachedU = MatrixUtils.createRealMatrix(U);\n+            cachedV = MatrixUtils.createRealMatrix(V);\n+        } else {\n+            cachedU = MatrixUtils.createRealMatrix(V);\n+            cachedV = MatrixUtils.createRealMatrix(U);\n+\n         }\n     }\n \n \n         if (dimension == 0) {\n             throw new NumberIsTooLargeException(LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,\n-                                                minSingularValue, singularValues[0], true);\n+                    minSingularValue, singularValues[0], true);\n         }\n \n         final double[][] data = new double[dimension][p];\n \n     /** {@inheritDoc} */\n     public double getConditionNumber() {\n-        return singularValues[0] / singularValues[singularValues.length - 1];\n+        return singularValues[0] / singularValues[FastMath.min(m, n) - 1];\n     }\n \n     /** {@inheritDoc} */\n     public int getRank() {\n-        final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\n-\n-        for (int i = singularValues.length - 1; i >= 0; --i) {\n-            if (singularValues[i] > threshold) {\n-                return i + 1;\n-            }\n-        }\n-        return 0;\n+        double tol = FastMath.max(m, n) * singularValues[0] * EPS;\n+        int r = 0;\n+        for (int i = 0; i < singularValues.length; i++) {\n+            if (singularValues[i] > tol) {\n+                r++;\n+            }\n+        }\n+        return r;\n     }\n \n     /** {@inheritDoc} */\n          * @param nonSingular Singularity indicator.\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT,\n-                       final RealMatrix v, final boolean nonSingular) {\n+                final RealMatrix v, final boolean nonSingular) {\n             double[][] suT = uT.getData();\n             for (int i = 0; i < singularValues.length; ++i) {\n                 final double a;\n                 if (singularValues[i] > 0) {\n-                 a = 1 / singularValues[i];\n+                    a = 1 / singularValues[i];\n                 } else {\n-                 a = 0;\n+                    a = 0;\n                 }\n                 final double[] suTi = suT[i];\n                 for (int j = 0; j < suTi.length; ++j) {\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n+import java.io.BufferedReader;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n import java.util.Random;\n \n import org.junit.Assert;\n     }\n \n     /** test matrices values */\n-    @Test\n+    // This test is useless since whereas the columns of U and V are linked\n+    // together, the actual triplet (U,S,V) is not uniquely defined.\n     public void testMatricesValues1() {\n        SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n \n     }\n \n+     /** test MATH-465 */\n+    @Test\n+    public void testRank() {\n+        double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };\n+        RealMatrix m = new Array2DRowRealMatrix(d);\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl(m);        \n+        Assert.assertEquals(2, svd.getRank());        \n+    }\n+    \n+    /** test MATH-583 */\n+    @Test\n+    public void testStability1() {\n+        RealMatrix m = new Array2DRowRealMatrix(201, 201);\n+        loadRealMatrix(m,\"matrix1.csv\");\n+        try {\n+            new SingularValueDecompositionImpl(m);\n+        } catch (Exception e) {\n+            Assert.fail(\"Exception whilst constructing SVD\");\n+        }      \n+    }\n+    \n+    /** test MATH-327 */\n+    @Test\n+    public void testStability2() {\n+        RealMatrix m = new Array2DRowRealMatrix(7, 168);\n+        loadRealMatrix(m,\"matrix2.csv\");\n+        try {\n+            new SingularValueDecompositionImpl(m);\n+        } catch (Throwable e) {\n+            Assert.fail(\"Exception whilst constructing SVD\");\n+        }      \n+    }\n+    \n+    private void loadRealMatrix(RealMatrix m, String resourceName) {\n+        try {\n+            DataInputStream in = new DataInputStream(getClass().getResourceAsStream(resourceName));\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String strLine;\n+            int row = 0;\n+            while ((strLine = br.readLine()) != null) {\n+                int col = 0;\n+                for (String entry : strLine.split(\",\")) {\n+                    m.setEntry(row, col++, Double.parseDouble(entry));\n+                }\n+                row++;\n+            }\n+            in.close();\n+        } catch (IOException e) {}      \n+    }\n+    \n     /** test condition number */\n     @Test\n     public void testConditionNumber() {", "timestamp": 1311164100, "metainfo": ""}