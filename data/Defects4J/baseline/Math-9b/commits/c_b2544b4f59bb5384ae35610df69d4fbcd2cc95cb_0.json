{"sha": "b2544b4f59bb5384ae35610df69d4fbcd2cc95cb", "log": "Made a nubmer of change to the ExpandableDoubleArray.  * This class now supports the ability to move the starting index of the internal element array.  This allows one to move the beginning of the element array, and form a sort of \"window\", this will come into play when we want to provide moving averages, or \"rolling\".  * Added an addElementRolling(double v) - this will increment the startIndex and add the element to the end of the internal element array  * brought the Clover test cases up to 100% for this class  Added a class ContractableDoubleArray:  * This is an extension of ExpandableDoubleArray - it addes a configuration parameter contractionCriteria.  Essential if the contractionCriteria is 2.0f we commit to never having the internal storage array provide more than 2.0 times the storage capacity needed.  Once the internal storage array exceed this measurement, the internal storage array is pruned to the size of the internal element array.  Also, my IDE scolded me for some ununsed imports in ListUnivariateImpl, they have been removed.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ContractableDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An array of double primitives which can expand as needed.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ContractableDoubleArray extends ExpandableDoubleArray implements Serializable {\n+\n+\t// The contraction criteria is related to the expansion factor.  Since this array is allowed to contract\n+\t// \n+\tprotected float contractionCriteria = 2.5f;\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * default initial capactiy of 16, an expansion factor of 2.00, and a contractionCriteria of 2.5\n+\t */\n+\tpublic ContractableDoubleArray() {\n+\t\tsuper();\n+\t}\t\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * specified initial capacity, the defult expansion factor of 2.00, and a contractionCriteria of 2.5\n+\t * \n+\t * @param initialCapacity The initial size of the internal storage array\n+\t */\n+\tpublic ContractableDoubleArray(int initialCapacity) {\n+\t\tsuper( initialCapacity );\n+\t}\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * specificed initial capacity and expand factor, with a contractionCriteria of 2.5\n+\t * \n+\t * @param initialCapacity The initial size of the internal storage array\n+\t * @param expansionFactor the array will be expanded based on this parameter\n+\t */\n+\tpublic ContractableDoubleArray(int initialCapacity, float expansionFactor) {\n+\t\tthis.expansionFactor = expansionFactor;\n+\t\tthis.initialCapacity = initialCapacity;\n+\t\tinternalArray = new double[initialCapacity];\n+\t\tcheckContractExpand(getContractionCriteria(), expansionFactor);\n+\t}\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * specificed initial capacity, expand factor, and contractionCriteria\n+\t * \n+\t * @param initialCapacity The initial size of the internal storage array\n+\t * @param expansionFactor the array will be expanded based on this parameter\n+\t */\n+\tpublic ContractableDoubleArray(int initialCapacity, float expansionFactor, float contractionCriteria) {\n+\t\tthis.contractionCriteria = contractionCriteria;\n+\t\tthis.expansionFactor = expansionFactor;\n+\t\tthis.initialCapacity = initialCapacity;\n+\t\tinternalArray = new double[initialCapacity];\n+\t\tcheckContractExpand(contractionCriteria, expansionFactor);\n+\t}\n+\n+\t/**\n+\t * Contracts the storage array to the (size of the element set) + 1 - to avoid a zero length array.\n+\t * This function also resets the startIndex to zero \n+\t */\n+\tpublic synchronized void contract() {\n+\t\tdouble[] tempArray = new double[numElements + 1];\n+\n+\t\t// Copy and swap - copy only the element array from the src array.\n+\t\tSystem.arraycopy(internalArray,startIndex,tempArray,0,numElements);\n+\t\tinternalArray = tempArray;\n+\t\t\n+\t\t// Reset the start index to zero\n+\t\tstartIndex = 0;\n+\t}\n+\n+\t/**\n+\t * Adds an element to the end of this expandable array\n+\t * \n+\t * @return value to be added to end of array\n+\t */\n+\tpublic synchronized void addElement(double value) {\n+\t\tsuper.addElement( value );\n+\t\tif( shouldContract() ) {\n+\t\t\tcontract();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Adds an element to the end of this expandable array\n+\t * \n+\t * @return value to be added to end of array\n+\t */\n+\tpublic synchronized void addElementRolling(double value) {\n+\t\tsuper.addElementRolling(value);\n+\t\t// Check the contraction criteria\n+\t\tif( shouldContract() ) {\n+\t\t\tcontract();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Should contract returns true if the ratio of (internal storage length) to (number of elements)\n+\t * is larger than the contractionCriteria value.  In other words, using the default value\n+\t * of 2.5, if the internal storage array provides more than 2.5x the space needed to store\n+\t * numElements, then this function returns true\n+\t * \n+\t * @return true if array satisfies the contraction criteria\n+\t */\n+\tprivate synchronized boolean shouldContract() {\n+\t\tboolean shouldContract = false;\n+\t\tif( ( internalArray.length / numElements ) > contractionCriteria ) {\n+\t\t\tshouldContract = true;\n+\t\t}\n+\t\treturn shouldContract;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.ExpandableDoubleArray#setElement(int, double)\n+\t */\n+\tpublic synchronized void setElement(int index, double value) {\n+\t\tsuper.setElement(index, value);\n+\t\tif( shouldContract() ) {\n+\t\t\tcontract();\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.ExpandableDoubleArray#setExpansionFactor(float)\n+\t */\n+\tpublic void setExpansionFactor(float expansionFactor) {\n+\t\tcheckContractExpand(getContractionCriteria(), expansionFactor);\n+\t\tsuper.setExpansionFactor(expansionFactor);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.ExpandableDoubleArray#setStartIndex(int)\n+\t */\n+\tpublic synchronized void setStartIndex(int i) {\n+\t\tsuper.setStartIndex(i);\n+\t\tif( shouldContract() ) {\n+\t\t\tcontract();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The contraction criteria defines when the internal array will contract to store only the\n+\t * number of elements in the element array.  This contractionCriteria gaurantees that\n+\t * the internal storage array will never exceed this factor more than the space needed\n+\t * to store numElements.\n+\t * \n+\t * @return the contraction criteria used to reclaim memory when array is empty\n+\t */\n+\tpublic float getContractionCriteria() {\n+\t\treturn contractionCriteria;\n+\t}\n+\n+\t/**\n+\t * Sets the contraction criteria for this ExpandContractDoubleArray. \n+\t * \n+\t * @param new contraction criteria\n+\t */\n+\tpublic void setContractionCriteria(float contractionCriteria) {\n+\t\tcheckContractExpand( contractionCriteria, getExpansionFactor() );\n+\t\t\n+\t\tif( contractionCriteria <= 1.0 ) {\n+\t\t\tthrow new IllegalArgumentException( \"The contraction criteria must be a number larger than\" +\n+\t\t\t\t\" one.  If the contractionCriteria is less than or equal to one an endless loop of contraction \" +\n+\t\t\t\t\"and expansion would ensue as an internalArray.length == numElements would satisfy \" +\n+\t\t\t\t\"the contraction criteria\");\n+\t\t}\n+\t\tthis.contractionCriteria = contractionCriteria;\n+\t}\n+\t\n+\t/**\n+\t * Checks the expansion factor and the contraction criteria and throws an IllegalArgumentException\n+\t * if the contractionCriteria is less than the expansionCriteria\n+\t * \n+\t * @param expansionFactor \n+\t * @param contractionCriteria\n+\t */\n+\tpublic void checkContractExpand( float contractionCritera, float expansionFactor ) {\n+\t\t\n+\t\tif( contractionCritera < expansionFactor ) {\n+\t\t\tthrow new IllegalArgumentException( \"Contraction criteria can never be smaller than \" +\n+\t\t\t\t\"the expansion factor.  This would lead to a never ending loop of expansion and \" +\n+\t\t\t\t\"contraction as a newly expanded internal storage array would immediately \" +\n+\t\t\t\t\"satisfy the criteria for contraction\");\n+\t\t}\n+\t\t\n+\t}\n+\t\n+}\n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n public class ExpandableDoubleArray implements Serializable {\n \n \t// This is the internal storage array.\n-\tprivate double[] internalArray;\n+\tprotected double[] internalArray;\n \n \t// Number of elements in the array\n-\tprivate int numElements = 0;\n+\tprotected int numElements = 0;\n+\t\n+\t// Keeps track of a starting index\n+\tprotected int startIndex = 0;\n \n \t// The initial capacity of the array. \n \t// Initial capacity is not exposed as a property as it is only meaningful\n \t// when passed to a constructor.\n-\tprivate int initialCapacity = 16;\n+\tprotected int initialCapacity = 16;\n \n \t// The expand factor of the array.  When the array need to be expanded, the new array size\n \t// will be internalArray.length * expandFactor \n-\tprivate float expansionFactor = 2.0f;\n+\tprotected float expansionFactor = 2.0f;\n \n \t/**\n \t * Create an expandable double array with the\n \tpublic int getNumElements() {\n \t\treturn (numElements);\n \t}\n+\n+\t/**\n+\t * This function allows you to control the number of elements contained in this\n+\t * array, and can be used to \"throw\" out the last n values in an array.  This\n+\t * feature is mainly targetted at the subclasses of this array class.  Note\n+\t * that this function will also expand the internal array as needed.\n+\t * \n+\t * @param a new number of elements\n+\t */\n+\tpublic synchronized void setNumElements(int i) {\n+\t\t\n+\t\t// If index is negative thrown an error\n+\t\tif( i <  0 ) {\n+\t\t\tthrow new IllegalArgumentException( \"Number of elements must be zero or a positive integer\");\n+\t\t} \n+\t\t\n+\t\t// Test the new num elements, check to see if the array needs to be expanded to\n+\t\t// accomodate this new number of elements\n+\t\tif( (startIndex + i) > internalArray.length ) {\n+\t\t\texpandTo( startIndex + i );\n+\t\t}\n+\t\t\n+\t\t// Set the new number of elements to new value\n+\t\tnumElements = i;\n+\t}\n+\n \n \t/**\n \t * Returns the element at the specified index\n \t\t\t\t\t+ \" is larger than the \"\n \t\t\t\t\t+ \"current number of elements\");\n \t\t} else if (index >= 0) {\n-\t\t\tvalue = internalArray[index];\n+\t\t\tvalue = internalArray[startIndex + index];\n \t\t} else {\n \t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"Elements cannot be retrieved from negative array \" + \"index\");\n+\t\t\t\t\"Elements cannot be retrieved from a negative array index\");\n \t\t}\n \t\treturn value;\n \t}\n \t\t\tthrow new IllegalArgumentException( \"Cannot set an element at a negative index\");\n \t\t}\n \t\t\n-\t\tif (index >= internalArray.length) {\n-\t\t\texpandTo(index + 1);\n+\t\tif ( (startIndex + index) >= internalArray.length) {\n+\t\t\texpandTo( startIndex + (index + 1));\n \t\t\tnumElements = index + 1;\n \t\t}\n-\t\tinternalArray[index] = value;\n+\t\tinternalArray[startIndex + index] = value;\n \t}\n \n \t/**\n \t/**\n \t * Expands the internal storage array using the expansion factor\n \t */\n-\tprivate synchronized void expand() {\n+\tprotected synchronized void expand() {\n \n \t\t// notice the use of Math.ceil(), this gaurantees that we will always have an array of at least\n \t\t// currentSize + 1.   Assume that the current initial capacity is 1 and the expansion factor\n \t */\n \tpublic synchronized void addElement(double value) {\n \t\tnumElements++;\n-\t\tif (numElements > internalArray.length) {\n+\t\tif ( (startIndex + numElements) > internalArray.length) {\n \t\t\texpand();\n \t\t}\n-\t\tinternalArray[numElements - 1] = value;\n-\t}\n+\t\tinternalArray[startIndex + (numElements - 1)] = value;\n+\t}\n+\t\n+\t/**\n+\t * Adds an element and moves the window of elements up one.  This\n+\t * has the effect of a FIFO\n+\t */\n+\tpublic synchronized void addElementRolling(double value) {\n+\t\tif ( (startIndex + (numElements+1) ) > internalArray.length) {\n+\t\t\texpand();\n+\t\t}\n+\t\t// Increment the start index\n+\t\tstartIndex += 1;\n+\t\t\n+\t\t// Add the new value\n+\t\tinternalArray[startIndex + (numElements -1)] = value;\n+\t}\n+\n \n \t/**\n \t * Notice the package scope on this method.   This method is simply here for the JUnit\n \t\tinternalArray = new double[initialCapacity];\n \t}\n \n+\t/**\n+\t * Returns the starting index from the internal array.  This value should remain at\n+\t * zero in this implementation of ExpandableDoubleArray.\n+\t * \n+\t * @return the starting Index in the internal storage array, in this class it is always zero.\n+\t */\n+\tpublic int getStartIndex() {\n+\t\treturn startIndex;\n+\t}\n+\n+\t/**\n+\t * Sets the starting index of the element array in the internal array, and subtracts the difference\n+\t * between the original startIndex and the new startIndex from the number of elements.   This\n+\t * method should be used with care.\n+\t * \n+\t * @param Index relative to the internal array from which to start the element array\n+\t */\n+\tpublic synchronized void setStartIndex(int i) {\n+\t\t\n+\t\tif( i > (startIndex + numElements) ) {\n+\t\t\tthrow new IllegalArgumentException( \"Cannot start the element array outside of the \" +\n+\t\t\t\t\"current element array.\");\n+\t\t} else if( i < 0 ) {\n+\t\t\tthrow new IllegalArgumentException( \"The starting index cannot be set to a negative index\");\n+\t\t} else {\n+\t\t\t\n+\t\t \t// Calculat the difference between the original start index and the current start index\n+\t\t\tint difference = i - startIndex;\n+\t\t\t\n+\t\t\t// \"Subtract\" this difference from numElements - this works both ways.  If the\n+\t\t\t// new start index is lower than the current start index then numElements is\n+\t\t\t// incremenet by that differen\n+\t\t\tnumElements -= difference;\n+\t\t\t\n+\t\t\tstartIndex = i;\n+\t\t}\n+\t}\n+\n }\n--- a/src/java/org/apache/commons/math/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/StoreUnivariateImpl.java\n \t\teDA = new ExpandableDoubleArray();\n \t}\n \n-\n \t/* (non-Javadoc)\n \t * @see org.apache.commons.math.StoreUnivariate#getValues()\n \t */\n--- a/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n \t\tassertTrue( \"The 0th index should be 2.0, it isn't\", eDA.getElement(0) == 2.0);\t\t\n \t\t\n \t}\n+\t\n+\tpublic void testSetNumberOfElements() {\n+\t\t\n+\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\tassertTrue( \"Number of elements should equal 6\", eDA.getNumElements() == 6);\n+\t\t\n+\t\teDA.setNumElements( 3 );\n+\t\tassertTrue( \"Number of elements should equal 3\", eDA.getNumElements() == 3);\n+\t\t\n+\t\ttry {\n+\t\t\teDA.setNumElements( -3 );\n+\t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\n+\t\teDA.setNumElements(1024);\n+\t\tassertTrue( \"Number of elements should now be 1024\", eDA.getNumElements() == 1024);\n+\t\tassertTrue( \"Element 453 should be a default double\", eDA.getElement( 453 ) == 0.0);\n+\t\t\t\t\n+\t}\n+\t\n+\tpublic void testAddElementRolling() {\n+\t\t\n+\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n+\t\t\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElementRolling( 2.0 );\n+\t\t\n+\t\tassertTrue( \"There should be 6 elements in the eda\", eDA.getNumElements() == 6);\n+\t\tassertTrue( \"The last element should be 2.0\", eDA.getElement( eDA.getNumElements() -1 ) == 2.0);\n+\t\t\n+\t\tfor( int i = 0; i  < 1024; i++ ) {\n+\t\t\teDA.addElementRolling( i );\n+\t\t}\n+\t\t\n+\t\tassertTrue( \"We just inserted 1024 rolling elements, num elements should still be 6\", eDA.getNumElements() == 6);\n+\t\tassertTrue( \"Even though there are only 6 element, internal storage should be 2048\", eDA.getInternalLength() == 2048);\n+\t\tassertEquals( \"The start index should be 1025\", 1025, eDA.getStartIndex());\n+\t\t\n+\t\teDA.setStartIndex( 0 );\n+\t\t\n+\t\tassertEquals( \"There shoud now be 1031 elements in this array\", 1031, eDA.getNumElements(), 0.001);\n+\t\tassertEquals( \"The first element should be 1.0\",1.0,  eDA.getElement(0), 0.001);\n+\t\t\n+\t\ttry {\n+\t\t\teDA.setStartIndex( 100000 );\n+\t\t\tfail( \"TRying to set the start index outside of the current array should have caused an error\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\n+\t\ttry {\n+\t\t\teDA.setStartIndex( -1 );\n+\t\t\tfail( \"TRying to set the start index to a negative number should have caused an error\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t}\n \n \t/** TEST ERROR CONDITIONS **/\n \n--- a/src/test/org/apache/commons/math/ListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/ListUnivariateImplTest.java\n package org.apache.commons.math;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.List;\n \n import junit.framework.Test;\n  * Test cases for the {@link Univariate} class.\n  *\n  * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n- * @version $Revision: 1.1 $ $Date: 2003/05/15 06:33:19 $\n+ * @version $Revision: 1.2 $ $Date: 2003/05/15 15:38:48 $\n  */\n \n public final class ListUnivariateImplTest extends TestCase {", "timestamp": 1053013128, "metainfo": ""}