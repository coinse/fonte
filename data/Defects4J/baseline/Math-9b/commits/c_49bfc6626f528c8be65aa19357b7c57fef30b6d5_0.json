{"sha": "49bfc6626f528c8be65aa19357b7c57fef30b6d5", "log": "Small java application for the accuracy assessment of implementations of real functions in Commons Math. The accuracy is assessed through comparison with reference values computed with multi-precision softwares.   ", "commit": "\n--- /dev/null\n+++ b/src/test/maxima/special/RealFunctionValidation/RealFunctionValidation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.EOFException;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/*\n+ * plot 'logGamma.dat' binary format=\"%double%double\" endian=big u 1:2 w l\n+ */\n+public class RealFunctionValidation {\n+\n+    public static class MissingRequiredPropertyException\n+        extends IllegalArgumentException {\n+\n+        private static final long serialVersionUID = 20121017L;\n+\n+        public MissingRequiredPropertyException(final String key) {\n+\n+            super(\"missing required property \" + key);\n+        }\n+    }\n+\n+    public static class ApplicationProperties {\n+\n+        private static final int DOT = '.';\n+\n+        private static final String METHOD_KEY = \"method\";\n+\n+        private static final String SIGNATURE_KEY = \"signature\";\n+\n+        private static final String INPUT_FILE_MASK = \"inputFileMask\";\n+\n+        private static final String OUTPUT_FILE_MASK = \"outputFileMask\";\n+\n+        private static final String FROM_KEY = \"from\";\n+\n+        private static final String TO_KEY = \"to\";\n+\n+        private static final String BY_KEY = \"by\";\n+\n+        final Method method;\n+\n+        final String inputFileMask;\n+\n+        final String outputFileMask;\n+\n+        final int from;\n+\n+        final int to;\n+\n+        final int by;\n+\n+        /**\n+         * Returns a {@link Method} with specified signature.\n+         *\n+         * @param className The fully qualified name of the class to which the\n+         * method belongs.\n+         * @param methodName The name of the method.\n+         * @param signature The signature of the method, as a list of parameter\n+         * types.\n+         * @return the method\n+         * @throws SecurityException\n+         * @throws ClassNotFoundException\n+         */\n+        public static Method findStaticMethod(final String className,\n+                                              final String methodName,\n+                                              final List<Class<?>> signature)\n+            throws SecurityException, ClassNotFoundException {\n+\n+            final int n = signature.size();\n+            final Method[] methods = Class.forName(className).getMethods();\n+            for (Method method : methods) {\n+                if (method.getName().equals(methodName)) {\n+                    final Class<?>[] parameters = method.getParameterTypes();\n+                    boolean sameSignature = true;\n+                    if (parameters.length == n) {\n+                        for (int i = 0; i < n; i++) {\n+                            sameSignature &= signature.get(i)\n+                                .equals(parameters[i]);\n+                        }\n+                        if (sameSignature) {\n+                            final int modifiers = method.getModifiers();\n+                            if ((modifiers & Modifier.STATIC) != 0) {\n+                                return method;\n+                            } else {\n+                                final String msg = \"method must be static\";\n+                                throw new IllegalArgumentException(msg);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            throw new IllegalArgumentException(\"method not found\");\n+        }\n+\n+        public static Class<?> parsePrimitiveType(final String type) {\n+\n+            if (type.equals(\"boolean\")) {\n+                return Boolean.TYPE;\n+            } else if (type.equals(\"byte\")) {\n+                return Byte.TYPE;\n+            } else if (type.equals(\"char\")) {\n+                return Character.TYPE;\n+            } else if (type.equals(\"double\")) {\n+                return Double.TYPE;\n+            } else if (type.equals(\"float\")) {\n+                return Float.TYPE;\n+            } else if (type.equals(\"int\")) {\n+                return Integer.TYPE;\n+            } else if (type.equals(\"long\")) {\n+                return Long.TYPE;\n+            } else if (type.equals(\"short\")) {\n+                return Short.TYPE;\n+            } else {\n+                final StringBuilder builder = new StringBuilder();\n+                builder.append(type).append(\" is not a primitive type\");\n+                throw new IllegalArgumentException(builder.toString());\n+            }\n+        }\n+\n+        private static String getPropertyAsString(final Properties properties,\n+                                                  final String key) {\n+\n+            final String value = properties.getProperty(key);\n+            if (value == null) {\n+                throw new MissingRequiredPropertyException(key);\n+            } else {\n+                return value;\n+            }\n+        }\n+\n+        private static int getPropertyAsInteger(final Properties properties,\n+                                                final String key) {\n+\n+            final String value = properties.getProperty(key);\n+            if (value == null) {\n+                throw new MissingRequiredPropertyException(key);\n+            } else {\n+                return Integer.parseInt(value);\n+            }\n+        }\n+\n+        private ApplicationProperties(final String fullyQualifiedName,\n+                                      final String signature,\n+                                      final String inputFileMask,\n+                                      final String outputFileMask,\n+                                      final int from, final int to, final int by) {\n+\n+            this.inputFileMask = inputFileMask;\n+            this.outputFileMask = outputFileMask;\n+            this.from = from;\n+            this.to = to;\n+            this.by = by;\n+\n+            final String[] types = signature.split(\",\");\n+            final List<Class<?>> parameterTypes = new ArrayList<Class<?>>();\n+            for (String type : types) {\n+                parameterTypes.add(parsePrimitiveType(type.trim()));\n+            }\n+            final int index = fullyQualifiedName.lastIndexOf(DOT);\n+            try {\n+                final String className, methodName;\n+                className = fullyQualifiedName.substring(0, index);\n+                methodName = fullyQualifiedName.substring(index + 1);\n+                this.method = findStaticMethod(className, methodName,\n+                                               parameterTypes);\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalArgumentException(e);\n+            }\n+\n+        }\n+\n+        public static final ApplicationProperties create(final Properties properties) {\n+\n+            final String methodFullyQualifiedName;\n+            methodFullyQualifiedName = getPropertyAsString(properties,\n+                                                           METHOD_KEY);\n+\n+            final String signature;\n+            signature = getPropertyAsString(properties, SIGNATURE_KEY);\n+\n+            final String inputFileMask;\n+            inputFileMask = getPropertyAsString(properties, INPUT_FILE_MASK);\n+\n+            final String outputFileMask;\n+            outputFileMask = getPropertyAsString(properties, OUTPUT_FILE_MASK);\n+\n+            final int from = getPropertyAsInteger(properties, FROM_KEY);\n+            final int to = getPropertyAsInteger(properties, TO_KEY);\n+            final int by = getPropertyAsInteger(properties, BY_KEY);\n+\n+            return new ApplicationProperties(methodFullyQualifiedName,\n+                                             signature, inputFileMask,\n+                                             outputFileMask, from, to, by);\n+        }\n+    };\n+\n+    public static Object readAndWritePrimitiveValue(final DataInputStream in,\n+                                                    final DataOutputStream out,\n+                                                    final Class<?> type)\n+        throws IOException {\n+\n+        if (!type.isPrimitive()) {\n+            throw new IllegalArgumentException(\"type must be primitive\");\n+        }\n+        if (type.equals(Boolean.TYPE)) {\n+            final boolean x = in.readBoolean();\n+            out.writeBoolean(x);\n+            return Boolean.valueOf(x);\n+        } else if (type.equals(Byte.TYPE)) {\n+            final byte x = in.readByte();\n+            out.writeByte(x);\n+            return Byte.valueOf(x);\n+        } else if (type.equals(Character.TYPE)) {\n+            final char x = in.readChar();\n+            out.writeChar(x);\n+            return Character.valueOf(x);\n+        } else if (type.equals(Double.TYPE)) {\n+            final double x = in.readDouble();\n+            out.writeDouble(x);\n+            return Double.valueOf(x);\n+        } else if (type.equals(Float.TYPE)) {\n+            final float x = in.readFloat();\n+            out.writeFloat(x);\n+            return Float.valueOf(x);\n+        } else if (type.equals(Integer.TYPE)) {\n+            final int x = in.readInt();\n+            out.writeInt(x);\n+            return Integer.valueOf(x);\n+        } else if (type.equals(Long.TYPE)) {\n+            final long x = in.readLong();\n+            out.writeLong(x);\n+            return Long.valueOf(x);\n+        } else if (type.equals(Short.TYPE)) {\n+            final short x = in.readShort();\n+            out.writeShort(x);\n+            return Short.valueOf(x);\n+        } else {\n+            // This should never occur.\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    public static SummaryStatistics assessAccuracy(final Method method,\n+                                                   final DataInputStream in,\n+                                                   final DataOutputStream out)\n+        throws IOException, IllegalAccessException, IllegalArgumentException,\n+        InvocationTargetException {\n+\n+        if (method.getReturnType() != Double.TYPE) {\n+            throw new IllegalArgumentException(\"method must return a double\");\n+        }\n+\n+        final Class<?>[] types = method.getParameterTypes();\n+        for (int i = 0; i < types.length; i++) {\n+            if (!types[i].isPrimitive()) {\n+                final StringBuilder builder = new StringBuilder();\n+                builder.append(\"argument #\").append(i + 1)\n+                    .append(\" of method \").append(method.getName())\n+                    .append(\"must be of primitive of type\");\n+                throw new IllegalArgumentException(builder.toString());\n+            }\n+        }\n+\n+        final SummaryStatistics stat = new SummaryStatistics();\n+        final Object[] parameters = new Object[types.length];\n+        while (true) {\n+            try {\n+                for (int i = 0; i < parameters.length; i++) {\n+                    parameters[i] = readAndWritePrimitiveValue(in, out,\n+                                                               types[i]);\n+                }\n+                final double expected = in.readDouble();\n+                if (FastMath.abs(expected) > 1E-16) {\n+                    final Object value = method.invoke(null, parameters);\n+                    final double actual = ((Double) value).doubleValue();\n+                    final double err = FastMath.abs(actual - expected);\n+                    final double ulps = err / FastMath.ulp(expected);\n+                    out.writeDouble(expected);\n+                    out.writeDouble(actual);\n+                    out.writeDouble(ulps);\n+                    stat.addValue(ulps);\n+                }\n+            } catch (EOFException e) {\n+                break;\n+            }\n+        }\n+        return stat;\n+    }\n+\n+    public static void run(final ApplicationProperties properties)\n+        throws IllegalAccessException, IllegalArgumentException,\n+        InvocationTargetException, IOException {\n+\n+        for (int i = properties.from; i < properties.to; i += properties.by) {\n+            final String inputFileName;\n+            inputFileName = String.format(properties.inputFileMask, i);\n+            final String outputFileName;\n+            outputFileName = String.format(properties.outputFileMask, i);\n+\n+            final DataInputStream in;\n+            in = new DataInputStream(new FileInputStream(inputFileName));\n+            final DataOutputStream out;\n+            out = new DataOutputStream(new FileOutputStream(outputFileName));\n+\n+            final SummaryStatistics stats;\n+            stats = assessAccuracy(properties.method, in, out);\n+\n+            System.out.println(\"input file name = \" + inputFileName);\n+            System.out.println(\"output file name = \" + outputFileName);\n+            System.out.println(stats);\n+        }\n+    }\n+\n+    public static void main(final String[] args)\n+        throws IOException, IllegalAccessException, IllegalArgumentException,\n+        InvocationTargetException {\n+\n+        if (args.length == 0) {\n+            final String msg = \"missing required properties file\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        final FileInputStream in = new FileInputStream(args[0]);\n+        final Properties properties = new Properties();\n+        properties.load(in);\n+        in.close();\n+\n+        final ApplicationProperties p;\n+        p = ApplicationProperties.create(properties);\n+\n+        run(p);\n+    }\n+}", "timestamp": 1352448798, "metainfo": ""}