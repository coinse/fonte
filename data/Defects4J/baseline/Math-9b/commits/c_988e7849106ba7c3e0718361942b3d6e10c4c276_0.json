{"sha": "988e7849106ba7c3e0718361942b3d6e10c4c276", "log": "MATH-503 \"Logit\" function.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Logit.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * <a href=\"http://en.wikipedia.org/wiki/Logit\">\n+ *  logit</a> function.\n+ * It is the inverse of the {@link Sigmoid sigmoid} function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class Logit implements DifferentiableUnivariateRealFunction {\n+    /** Lower bound. */\n+    private final double lo;\n+    /** Higher bound. */\n+    private final double hi;\n+\n+    /**\n+     * Usual logit function, where the lower bound is 0 and the higher\n+     * bound is 1.\n+     */\n+    public Logit() {\n+        this(0, 1);\n+    }\n+\n+    /**\n+     * Logit function.\n+     *\n+     * @param lo Lower bound of the function domain.\n+     * @param hi Higher bound of the function domain.\n+     */\n+    public Logit(double lo,\n+                 double hi) {\n+        this.lo = lo;\n+        this.hi = hi;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return value(x, lo, hi);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            /** {@inheritDoc} */\n+            public double value(double x) {\n+                return (hi - lo) / ((x - lo) * (hi - x));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Parametric function where the input array contains the parameters of\n+     * the logit function, ordered as follows:\n+     * <ul>\n+     *  <li>Lower bound</li>\n+     *  <li>Higher bound</li>\n+     * </ul>\n+     */\n+    public static class Parametric implements ParametricUnivariateRealFunction {\n+        /**\n+         * Computes the value of the logit at {@code x}.\n+         *\n+         * @param x Value for which the function must be computed.\n+         * @param param Values of lower bound and higher bounds.\n+         * @return the value of the function.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 2.\n+         */\n+        public double value(double x,\n+                            double[] param) {\n+            validateParameters(param);\n+            return Logit.value(x, param[0], param[1]);\n+        }\n+\n+        /**\n+         * Computes the value of the gradient at {@code x}.\n+         * The components of the gradient vector are the partial\n+         * derivatives of the function with respect to each of the\n+         * <em>parameters</em> (lower bound and higher bound).\n+         *\n+         * @param x Value at which the gradient must be computed.\n+         * @param param Values for lower and higher bounds.\n+         * @return the gradient vector at {@code x}.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 2.\n+         */\n+        public double[] gradient(double x, double[] param) {\n+            validateParameters(param);\n+\n+            final double lo = param[0];\n+            final double hi = param[1];\n+\n+            return new double[] { 1 / (lo - x), 1 / (hi - x) };\n+        }\n+\n+        /**\n+         * Validates parameters to ensure they are appropriate for the evaluation of\n+         * the {@link #value(double,double[])} and {@link #gradient(double,double[])}\n+         * methods.\n+         *\n+         * @param param Values for lower and higher bounds.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 2.\n+         */\n+        private void validateParameters(double[] param) {\n+            if (param == null) {\n+                throw new NullArgumentException();\n+            }\n+            if (param.length != 2) {\n+                throw new DimensionMismatchException(param.length, 2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param x Value at which to compute the logit.\n+     * @param lo Lower bound.\n+     * @param hi Higher bound.\n+     * @return the value of the logit function at {@code x}.\n+     */\n+    private static double value(double x,\n+                                double lo,\n+                                double hi) {\n+        if (x < lo || x > hi) {\n+            throw new OutOfRangeException(x, lo, hi);\n+        }\n+        return FastMath.log((x - lo) / (hi - x));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/function/LogitTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.FunctionUtils;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for class {@link Logit}.\n+ */\n+public class LogitTest {\n+    private final double EPS = Math.ulp(1d);\n+\n+    @Test(expected=OutOfRangeException.class)\n+    public void testPreconditions1() {\n+        final double lo = -1;\n+        final double hi = 2;\n+        final UnivariateRealFunction f = new Logit(lo, hi);\n+\n+        f.value(lo - 1);\n+    }\n+    @Test(expected=OutOfRangeException.class)\n+    public void testPreconditions2() {\n+        final double lo = -1;\n+        final double hi = 2;\n+        final UnivariateRealFunction f = new Logit(lo, hi);\n+\n+        f.value(hi + 1);\n+    }\n+\n+    @Test\n+    public void testSomeValues() {\n+        final double lo = 1;\n+        final double hi = 2;\n+        final UnivariateRealFunction f = new Logit(lo, hi);\n+\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, f.value(1), EPS);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, f.value(2), EPS);\n+        Assert.assertEquals(0, f.value(1.5), EPS);\n+    }\n+\n+    @Test\n+    public void testDerivative() {\n+        final double lo = 1;\n+        final double hi = 2;\n+        final Logit f = new Logit(lo, hi);\n+        final UnivariateRealFunction dfdx = f.derivative();\n+\n+        Assert.assertEquals(4, dfdx.value(1.5), EPS);\n+    }\n+\n+    @Test\n+    public void testDerivativeLargeArguments() {\n+        final Logit f = new Logit(1, 2);\n+        final UnivariateRealFunction dfdx = f.derivative();\n+\n+        Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);\n+        Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);\n+        Assert.assertEquals(0, dfdx.value(-1e155), 0);\n+        Assert.assertEquals(0, dfdx.value(1e155), 0);\n+        Assert.assertEquals(0, dfdx.value(Double.MAX_VALUE), 0);\n+        Assert.assertEquals(0, dfdx.value(Double.POSITIVE_INFINITY), 0);        \n+    }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage1() {\n+        final Logit.Parametric g = new Logit.Parametric();\n+        g.value(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage2() {\n+        final Logit.Parametric g = new Logit.Parametric();\n+        g.value(0, new double[] {0});\n+    }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage3() {\n+        final Logit.Parametric g = new Logit.Parametric();\n+        g.gradient(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage4() {\n+        final Logit.Parametric g = new Logit.Parametric();\n+        g.gradient(0, new double[] {0});\n+    }\n+\n+    @Test(expected=OutOfRangeException.class)\n+    public void testParametricUsage5() {\n+        final Logit.Parametric g = new Logit.Parametric();\n+        g.value(-1, new double[] {0, 1});\n+    }\n+\n+    @Test(expected=OutOfRangeException.class)\n+    public void testParametricUsage6() {\n+        final Logit.Parametric g = new Logit.Parametric();\n+        g.value(2, new double[] {0, 1});\n+    }\n+\n+    @Test\n+    public void testParametricValue() {\n+        final double lo = 2;\n+        final double hi = 3;\n+        final Logit f = new Logit(lo, hi);\n+\n+        final Logit.Parametric g = new Logit.Parametric();\n+        Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0);\n+        Assert.assertEquals(f.value(2.34567), g.value(2.34567, new double[] {lo, hi}), 0);\n+        Assert.assertEquals(f.value(3), g.value(3, new double[] {lo, hi}), 0);\n+    }\n+\n+    @Test\n+    public void testValueWithInverseFunction() {\n+        final double lo = 2;\n+        final double hi = 3;\n+        final Logit f = new Logit(lo, hi);\n+        final Sigmoid g = new Sigmoid(lo, hi);\n+        final UnivariateRealFunction id = FunctionUtils.compose(g, f);\n+        \n+        for (int i = 0; i < 10; i++) {\n+            final double x = lo + Math.random() * (hi - lo);\n+            Assert.assertEquals(x, id.value(x), EPS);\n+        }\n+\n+        Assert.assertEquals(lo, id.value(lo), EPS);\n+        Assert.assertEquals(hi, id.value(hi), EPS);\n+    }\n+\n+    @Test\n+    public void testDerivativeWithInverseFunction() {\n+        final double lo = 2;\n+        final double hi = 3;\n+        final Logit f = new Logit(lo, hi);\n+        final UnivariateRealFunction dfdx = f.derivative();\n+        final Sigmoid g = new Sigmoid(lo, hi);\n+        final UnivariateRealFunction dgdx = g.derivative();\n+        final UnivariateRealFunction chain\n+            = FunctionUtils.compose(new Inverse(), FunctionUtils.compose(dgdx, f));\n+        \n+        for (int i = 0; i < 10; i++) {\n+            final double x = lo + Math.random() * (hi - lo);\n+            Assert.assertEquals(dfdx.value(x), chain.value(x), 1e-13);\n+        }\n+\n+        Assert.assertEquals(dfdx.value(lo), chain.value(lo), EPS);\n+        Assert.assertEquals(dfdx.value(hi), chain.value(hi), EPS);\n+    }\n+}", "timestamp": 1298761669, "metainfo": ""}