{"sha": "fa66d39996428ee44f52289ffd9833c87981b4f2", "log": "added methods to operate directly on double arrays  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/java/org/apache/commons/math/linear/RealVector.java\n         throws IllegalArgumentException;\n \n     /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector add(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n      * Compute this minus v.\n      * @param v vector to be subtracted\n      * @return this + v\n         throws IllegalArgumentException;\n \n     /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector subtract(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n      * Map an addition operation to each entry.\n      * @param d value to be added to each entry\n      * @return this + d\n         throws IllegalArgumentException;\n \n     /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @return a vector containing this[i] / v[i] for all i\n         throws IllegalArgumentException;\n \n     /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n      * Returns vector entries as a double array.\n      * @return double array of entries\n      */\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n     double dotProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    double dotProduct(double[] v)\n         throws IllegalArgumentException;\n \n     /**\n \n     /**\n      * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getNorm()\n+     */\n+    double getDistance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n      * <p>This method computes the distance consistent with\n      * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n      * elements differences.</p>\n      * @see #getL1Norm()\n      */\n     double getL1Distance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getL1Norm()\n+     */\n+    double getL1Distance(double[] v)\n         throws IllegalArgumentException;\n \n     /**\n     double getLInfDistance(RealVector v)\n         throws IllegalArgumentException;\n \n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infty;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(double[])\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfNorm()\n+     */\n+    double getLInfDistance(double[] v)\n+        throws IllegalArgumentException;\n+\n     /** Creates a unit vector pointing in the direction of this vector.\n      * <p>The instance is not changed by this method.</p>\n      * @return a unit vector pointing in direction of this vector\n     RealVector projection(RealVector v)\n         throws IllegalArgumentException;\n \n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector projection(double[] v)\n+        throws IllegalArgumentException;\n+\n     /**\n      * Compute the outer product.\n      * @param v vector with which outer product should be computed\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n     RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    RealMatrix outerProduct(double[] v)\n         throws IllegalArgumentException;\n \n     /**\n         throws MatrixIndexException;\n \n     /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    void set(int index, double[] v)\n+        throws MatrixIndexException;\n+\n+    /**\n      * Set all elements to a single value.\n      * @param value single value to set for all elements\n      */\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n public class RealVectorImpl implements RealVector, Serializable {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 7838747548772166404L;\n+    private static final long serialVersionUID = -1097961340710804027L;\n \n     /** Default format. */\n     private static final RealVectorFormat DEFAULT_FORMAT =\n         System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n     }\n \n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(RealVectorImpl v1, double[] v2) {\n+        data = new double[v1.data.length + v2.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(double[] v1, RealVectorImpl v2) {\n+        data = new double[v1.length + v2.data.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(double[] v1, double[] v2) {\n+        data = new double[v1.length + v2.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2, 0, data, v1.length, v2.length);\n+    }\n+\n     /** {@inheritDoc} */\n     public RealVector copy() {\n         return new RealVectorImpl(this, true);\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n     /**\n      * Compute the sum of this and v.\n      * @param v vector to be added\n      */\n     public RealVectorImpl add(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] + v.data[i];\n-        }\n-        return new RealVectorImpl(out);\n+        return (RealVectorImpl) add(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n     /**\n      * Compute this minus v.\n      * @param v vector to be subtracted\n      */\n     public RealVectorImpl subtract(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] - v.data[i];\n-        }\n-        return new RealVectorImpl(out);\n+        return (RealVectorImpl) subtract(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n     /**\n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      */\n     public RealVectorImpl ebeMultiply(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] * v.data[i];\n-        }\n-        return new RealVectorImpl(out);\n+        return (RealVectorImpl) ebeMultiply(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n     /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      */\n     public RealVectorImpl ebeDivide(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] / v.data[i];\n-        }\n-        return new RealVectorImpl(out);\n+        return (RealVectorImpl) ebeDivide(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double dot = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            dot += data[i] * v[i];\n+        }\n+        return dot;\n+    }\n+\n     /**\n      * Compute the dot product.\n      * @param v vector with which dot product should be computed\n      */\n     public double dotProduct(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double dot = 0;\n-        for (int i = 0; i < data.length; i++) {\n-            dot += data[i] * v.getEntry(i);\n-        }\n-        return dot;\n+        return dotProduct(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /**\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += delta * delta;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+   /**\n      * Distance between two vectors.\n      * <p>This method computes the distance consistent with the\n      * L<sub>2</sub> norm, i.e. the square root of the sum of\n      */\n     public double getDistance(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double sum = 0;\n-        for (int i = 0; i < data.length; ++i) {\n-            final double delta = data[i] - v.data[i];\n-            sum += delta * delta;\n-        }\n-        return Math.sqrt(sum);\n+        return getDistance(v.data);\n     }\n \n     /** {@inheritDoc} */\n             }\n             return sum;\n         }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += Math.abs(delta);\n+        }\n+        return sum;\n     }\n \n     /**\n      */\n     public double getL1Distance(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double sum = 0;\n-        for (int i = 0; i < data.length; ++i) {\n-            final double delta = data[i] - v.data[i];\n-            sum += Math.abs(delta);\n-        }\n-        return sum;\n+        return getL1Distance(v.data);\n     }\n \n     /** {@inheritDoc} */\n             }\n             return max;\n         }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            max = Math.max(max, Math.abs(delta));\n+        }\n+        return max;\n     }\n \n     /**\n      */\n     public double getLInfDistance(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double max = 0;\n-        for (int i = 0; i < data.length; ++i) {\n-            final double delta = data[i] - v.data[i];\n-            max = Math.max(max, Math.abs(delta));\n-        }\n-        return max;\n+        return getLInfDistance(v.data);\n     }\n \n     /** {@inheritDoc} */\n         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n     }\n \n-    /** Find the orthogonal projection of this vector onto another vector.\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) {\n+        return projection(new RealVectorImpl(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n      * @param v vector onto which instance must be projected\n      * @return projection of the instance onto v\n      * @throws IllegalArgumentException if v is not the same size as this\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[][] out = new double[data.length][data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out[i][j] = data[i] * v[j];\n+            }\n+        }\n+        return new RealMatrixImpl(out);\n+    }\n+\n     /**\n      * Compute the outer product.\n      * @param v vector with which outer product should be computed\n      */\n     public RealMatrixImpl outerProduct(RealVectorImpl v)\n         throws IllegalArgumentException {\n-        checkVectorDimensions(v);\n-        double[][] out = new double[data.length][data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            for (int j = 0; j < data.length; j++) {\n-                out[i][j] = data[i] * v.data[j];\n-            }\n-        }\n-        return new RealMatrixImpl(out);\n+        return (RealMatrixImpl) outerProduct(v.data);\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public RealVector append(double[] in) {\n-        final double[] out = new double[data.length + in.length];\n-        System.arraycopy(data, 0, out, 0, data.length);\n-        System.arraycopy(in, 0, out, data.length, in.length);\n-        return new RealVectorImpl(out);\n+        return new RealVectorImpl(this, in);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public void set(int index, double[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(e.getMessage());\n+        }\n+    }\n+\n     /**\n      * Set a set of consecutive elements.\n      * \n      */\n     public void set(int index, RealVectorImpl v)\n         throws MatrixIndexException {\n-        try {\n-            System.arraycopy(v.data, 0, data, index, v.data.length);\n-        } catch (IndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(e.getMessage());\n-        }\n+        set(index, v.data);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n     public static class RealVectorTestImpl implements RealVector, Serializable {\n \n         /** Serializable version identifier. */\n-        private static final long serialVersionUID = 8731816072271374422L;\n+        private static final long serialVersionUID = 4715341047369582908L;\n \n         /** Entries of the vector. */\n         protected double data[];\n             throw unsupported();\n         }\n \n+        public RealVector add(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n         public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n             throw unsupported();\n         }\n \n+        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n         public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n         }\n \n         public double dotProduct(RealVector v) throws IllegalArgumentException {\n-\n-            //\tcheckVectorDimensions(v);\n             double dot = 0;\n             for (int i = 0; i < data.length; i++) {\n                 dot += data[i] * v.getEntry(i);\n             return dot;\n         }\n \n+        public double dotProduct(double[] v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v[i];\n+            }\n+            return dot;\n+        }\n+\n         public double getNorm() {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        public double getDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n         public double getL1Distance(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        public double getL1Distance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n         public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n         public RealVector unitVector() {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        public RealVector projection(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n         public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n         }\n \n         public void set(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, double[] v) throws MatrixIndexException {\n             throw unsupported();\n         }\n ", "timestamp": 1223239035, "metainfo": ""}