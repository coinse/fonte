{"sha": "6de8034647875ef7ecce49f5ca9cad1a980636c2", "log": "MATH-413 Removed setters; convergence checker, line search solver and preconditioner set in contructor.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.util.FastMath;\n \n /**\n     /** Update formula for the beta parameter. */\n     private final ConjugateGradientFormula updateFormula;\n     /** Preconditioner (may be null). */\n-    private Preconditioner preconditioner;\n+    private final Preconditioner preconditioner;\n     /** solver to use in the line search (may be null). */\n-    private UnivariateRealSolver solver;\n+    private final UnivariateRealSolver solver;\n     /** Initial step used to bracket the optimum in line search. */\n     private double initialStep;\n     /** Current point. */\n     private double[] point;\n \n     /**\n-     * Simple constructor with default settings.\n-     * The convergence check is set to a {@link\n-     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}.\n+     * Constructor with default {@link SimpleScalarValueChecker checker},\n+     * {@link BrentSolver line search solver} and\n+     * {@link IdentityPreconditioner preconditioner}.\n      *\n      * @param updateFormula formula to use for updating the &beta; parameter,\n      * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n-     * ConjugateGradientFormula#POLAK_RIBIERE}\n+     * ConjugateGradientFormula#POLAK_RIBIERE}.\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula) {\n+        this(updateFormula,\n+             new SimpleScalarValueChecker());\n+    }\n+\n+    /**\n+     * Constructor with default {@link BrentSolver line search solver} and\n+     * {@link IdentityPreconditioner preconditioner}.\n+     *\n+     * @param updateFormula formula to use for updating the &beta; parameter,\n+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n+     * ConjugateGradientFormula#POLAK_RIBIERE}.\n+     * @param checker Convergence checker.\n+     */\n+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n+                                               ConvergenceChecker<RealPointValuePair> checker) {\n+        this(updateFormula,\n+             checker,\n+             new BrentSolver(),\n+             new IdentityPreconditioner());\n+    }\n+\n+\n+    /**\n+     * Constructor with default {@link IdentityPreconditioner preconditioner}.\n+     *\n+     * @param updateFormula formula to use for updating the &beta; parameter,\n+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n+     * ConjugateGradientFormula#POLAK_RIBIERE}.\n+     * @param checker Convergence checker.\n+     * @param lineSearchSolver Solver to use during line search.\n+     */\n+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n+                                               ConvergenceChecker<RealPointValuePair> checker,\n+                                               final UnivariateRealSolver lineSearchSolver) {\n+        this(updateFormula,\n+             checker,\n+             lineSearchSolver,\n+             new IdentityPreconditioner());\n+    }\n+\n+    /**\n+     * @param updateFormula formula to use for updating the &beta; parameter,\n+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n+     * ConjugateGradientFormula#POLAK_RIBIERE}.\n+     * @param checker Convergence checker.\n+     * @param lineSearchSolver Solver to use during line search.\n+     * @param preconditioner Preconditioner.\n+     */\n+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n+                                               ConvergenceChecker<RealPointValuePair> checker,\n+                                               final UnivariateRealSolver lineSearchSolver,\n+                                               final Preconditioner preconditioner) {\n+        super(checker);\n+\n         this.updateFormula = updateFormula;\n-        preconditioner     = null;\n-        solver             = null;\n-        initialStep        = 1.0;\n-    }\n-\n-    /**\n-     * Set the preconditioner.\n-     * @param preconditioner preconditioner to use for next optimization,\n-     * may be null to remove an already registered preconditioner\n-     */\n-    public void setPreconditioner(final Preconditioner preconditioner) {\n+        solver = lineSearchSolver;\n         this.preconditioner = preconditioner;\n-    }\n-\n-    /**\n-     * Set the solver to use during line search.\n-     * @param lineSearchSolver solver to use during line search, may be null\n-     * to remove an already registered solver and fall back to the\n-     * default {@link BrentSolver Brent solver}.\n-     */\n-    public void setLineSearchSolver(final UnivariateRealSolver lineSearchSolver) {\n-        solver = lineSearchSolver;\n+        initialStep = 1.0;\n     }\n \n     /**\n     /** {@inheritDoc} */\n     @Override\n     protected RealPointValuePair doOptimize() {\n-        // Initialization.\n-        if (preconditioner == null) {\n-            preconditioner = new IdentityPreconditioner();\n-        }\n-        if (solver == null) {\n-            solver = new BrentSolver();\n-        }\n+        final ConvergenceChecker checker = getConvergenceChecker();\n         point = getStartPoint();\n         final GoalType goal = getGoalType();\n         final int n = point.length;\n             RealPointValuePair previous = current;\n             current = new RealPointValuePair(point, objective);\n             if (previous != null) {\n-                if (getConvergenceChecker().converged(iter, previous, current)) {\n+                if (checker.converged(iter, previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n     }\n \n     /** Default identity preconditioner. */\n-    private static class IdentityPreconditioner implements Preconditioner {\n+    public static class IdentityPreconditioner implements Preconditioner {\n \n         /** {@inheritDoc} */\n         public double[] precondition(double[] variables, double[] r) {\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 });\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n                               new double[] { 4.0, 6.0, 1.0 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n                 { 0, 0, 0, 0, 0, 2 }\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         for (int i = 0; i < problem.target.length; ++i) {\n                 {  0, -1, 1 }\n         }, new double[] { 1, 1, 1});\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n                 {  0,  0,   0,  0,       1, 1 }\n         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n \n-        NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setPreconditioner(new Preconditioner() {\n-            public double[] precondition(double[] point, double[] r) {\n-                double[] d = r.clone();\n-                d[0] /=  72.0;\n-                d[1] /=  30.0;\n-                d[2] /= 314.0;\n-                d[3] /= 260.0;\n-                d[4] /= 2 * (1 + epsilon * epsilon);\n-                d[5] /= 4.0;\n-                return d;\n-            }\n-        });\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n-\n+        final Preconditioner preconditioner\n+            = new Preconditioner() {\n+                    public double[] precondition(double[] point, double[] r) {\n+                        double[] d = r.clone();\n+                        d[0] /=  72.0;\n+                        d[1] /=  30.0;\n+                        d[2] /= 314.0;\n+                        d[3] /= 260.0;\n+                        d[4] /= 2 * (1 + epsilon * epsilon);\n+                        d[5] /= 4.0;\n+                        return d;\n+                    }\n+                };\n+\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-13, 1e-13),\n+                                                    new BrentSolver(),\n+                                                    preconditioner);\n+                                                    \n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n                 { -3, 0, -9 }\n         }, new double[] { 1, 1, 1 });\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n                 optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertTrue(optimum.getValue() > 0.5);\n                 {  7.0, 5.0,  9.0, 10.0 }\n         }, new double[] { 32, 23, 33, 31 });\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n-        BrentSolver solver = new BrentSolver(1e-15, 1e-15);\n-        optimizer.setLineSearchSolver(solver);\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-13, 1e-13),\n+                                                    new BrentSolver(1e-15, 1e-15));\n         RealPointValuePair optimum1 =\n             optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);\n         }, new double[] { 7.0, 3.0, 5.0 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n                  { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n         }, new double[] { 3.0, 1.0, 5.0 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n         }, new double[] { 3.0, 1.0, 4.0 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertTrue(optimum.getValue() > 0.1);\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         NonLinearConjugateGradientOptimizer optimizer =\n-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));\n-        UnivariateRealSolver solver = new BrentSolver(1e-15, 1e-13);\n-        optimizer.setLineSearchSolver(solver);\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1e-30, 1e-30),\n+                                                    new BrentSolver(1e-15, 1e-13));\n         RealPointValuePair optimum =\n             optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);", "timestamp": 1314880250, "metainfo": ""}