{"sha": "5f4e953b58f3e35ae21481e4df93bf26eea0c573", "log": "Failed attempt to implement Strassen matrix multiplication on recursive layout as described in Siddhartha Chatterjee, Alvin R. Lebeck, Praveen K. Patnala and Mithuna Thottehodi paper \"Recursive Array Layout and Fast Matrix Multiplication\".  As of 2009-02-13, this implementation does not work! The padding at left and bottom sides of the matrix should be cleared after some operations like scalerAdd and is not. Also there is a limitation in the multiplication that can only process matrices with sizes similar enough to have the same power of two number of tiles in all three matrices A, B and C such that C = A*B. These parts have not been fixed since the performance gain with respect to DenseRealMatrix are not very important, and the numerical stability is poor.  This may well be due to a bad implementation.  This code has been put in the experimental directory for the record, putting it into production would require solving all these issues.   ", "commit": "\n--- /dev/null\n+++ b/src/experimental/org/apache/commons/math/linear/RecursiveLayoutRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Cache-friendly implementation of RealMatrix using recursive array layouts to store\n+ * the matrix elements.\n+ * <p>\n+ * As of 2009-02-13, this implementation does not work! The padding at left and bottom\n+ * sides of the matrix should be cleared after some operations like scalerAdd\n+ * and is not. Also there is a limitation in the multiplication that can only\n+ * process matrices with sizes similar enough to have the same power of two\n+ * number of tiles in all three matrices A, B and C such that C = A*B. These\n+ * parts have not been fixed since the performance gain with respect to\n+ * DenseRealMatrix are not very important, and the numerical stability is not\n+ * good. This may well be due to a bad implementation. This code has been put\n+ * in the experimental part for the record, putting it into production would\n+ * require solving all these issues.\n+ * </p>\n+ * <p>\n+ * This implementation is based on the 2002 paper: <a\n+ * href=\"http://www.cs.duke.edu/~alvy/papers/matrix-tpds.pdf\">Recursive Array Layouts\n+ * and Fast Matrix Multiplication</a> by Siddhartha Chatterjee, Alvin R. Lebeck,\n+ * Praveen K. Patnala and Mithuna Thottethodi.\n+ * </p>\n+ * <p>\n+ * The matrix is split into several rectangular tiles. The tiles are laid out using\n+ * a space-filling curve in a 2<sup>k</sup>&times;2<sup>k</sup> square. This\n+ * implementation uses the Gray-Morton layout which starts as follows for a three-level\n+ * recursion (i.e. an 8x8 matrix). The tiles size are adjusted in order to have the\n+ * 2<sup>k</sup>&times;2<sup>k</sup> square. This may require padding at the right and\n+ * bottom sides of the matrix (see above paper for a discussion of this padding feature).\n+ * </p>\n+ * <pre>\n+ *                    |\n+ *    00 01 | 06 07   |   24  25 | 30  31\n+ *    03 02 | 05 04   |   27  26 | 29  28\n+ *    ------+------   |   -------+-------\n+ *    12 13 | 10 11   |   20  21 | 18  19\n+ *    15 14 | 09 08   |   23  22 | 17  16\n+ *                    |\n+ * -------------------+--------------------\n+ *                    |\n+ *    48 49 | 54 55   |   40  41 | 46  47\n+ *    51 50 | 53 52   |   43  42 | 45  44\n+ *    ------+------   |   -------+-------\n+ *    60 61 | 58 59   |   36  37 | 34  35\n+ *    63 62 | 57 56   |   39  38 | 33  32\n+ *                    |\n+ * </pre>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RecursiveLayoutRealMatrix extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 1607919006739190004L;\n+\n+    /** Maximal allowed tile size in bytes.\n+     * <p>In order to avoid cache miss during multiplication,\n+     * a suggested value is cache_size/3.</p>\n+     */\n+    private static final int MAX_TILE_SIZE_BYTES = (64 * 1024) / 3;\n+    //private static final int MAX_TILE_SIZE_BYTES = 32;\n+\n+    /** Storage array for matrix elements. */\n+    private final double data[];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of terminal tiles along rows and columns (guaranteed to be a power of 2). */\n+    private final int tileNumber;\n+\n+    /** Number of rows in each terminal tile. */\n+    private final int tileSizeRows;\n+\n+    /** Number of columns in each terminal tile. */\n+    private final int tileSizeColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public RecursiveLayoutRealMatrix(final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // compute optimal layout\n+        tileNumber      = tilesNumber(rows, columns);\n+        tileSizeRows    = tileSize(rows, tileNumber);\n+        tileSizeColumns = tileSize(columns, tileNumber);\n+\n+        // create storage array\n+        data = new double[tileNumber * tileNumber * tileSizeRows * tileSizeColumns];\n+\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new RecursiveLayoutRealMatrix(rawData.length, rawData[0].length,\n+     *                                             toRecursiveLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n+     *\n+     * @exception IllegalArgumentException if <code>rawData</code> shape is\n+     * inconsistent with tile layout\n+     * @see #DenseRealMatrix(int, int, double[][], boolean)\n+     */\n+    public RecursiveLayoutRealMatrix(final double[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toRecursiveLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from recursive layout data.\n+     * <p>The input array <em>must</em> already be in recursive layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param data data for new matrix, in recursive layout\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>data</code> size is\n+     * inconsistent with matrix size\n+     * @see #toRecursiveLayout(double[][])\n+     * @see #RecursiveLayoutRealMatrix(double[][])\n+     */\n+    public RecursiveLayoutRealMatrix(final int rows, final int columns,\n+                                     final double[] data, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // compute optimal layout\n+        tileNumber      = tilesNumber(rows, columns);\n+        tileSizeRows    = tileSize(rows, tileNumber);\n+        tileSizeColumns = tileSize(columns, tileNumber);\n+\n+        // create storage array\n+        final int expectedLength = tileNumber * tileNumber * tileSizeRows * tileSizeColumns;\n+        if (data.length != expectedLength) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"wrong array size (got {0}, expected {1})\",\n+                                                                      new Object[] {\n+                                                                          data.length,\n+                                                                          expectedLength\n+                                                                      });\n+        }\n+\n+        if (copyArray) {\n+            // allocate storage array\n+            this.data = data.clone();\n+        } else {\n+            // reference existing array\n+            this.data = data;\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to recursive layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Recursive layout\n+     * is the layout used in {@link RecursiveLayoutRealMatrix} instances, where the matrix\n+     * is stored in a dimension 1 array using a space-filling curve to spread the matrix\n+     * elements along the array.\n+     * </p>\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in recursive layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n+     *  (not all rows have the same length)\n+     * @see #RecursiveLayoutRealMatrix(int, int, double[], boolean)\n+     */\n+    public static double[] toRecursiveLayout(final double[][] rawData)\n+        throws IllegalArgumentException {\n+\n+        final int rows    = rawData.length;\n+        final int columns = rawData[0].length;\n+\n+        // compute optimal layout\n+        final int tileNumber      = tilesNumber(rows, columns);\n+        final int tileSizeRows    = tileSize(rows, tileNumber);\n+        final int tileSizeColumns = tileSize(columns, tileNumber);\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        new Object[] { columns, length }); \n+            }\n+        }\n+\n+        // convert array row after row\n+        final double[] data = new double[tileNumber * tileNumber * tileSizeRows * tileSizeColumns];\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int iTile = i / tileSizeRows;\n+            final double[] rawDataI = rawData[i];\n+            for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+                final int tileStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns;\n+                final int dataStart = tileStart + (i - iTile * tileSizeRows) * tileSizeColumns;\n+                final int jStart    = jTile * tileSizeColumns;\n+                if (jStart < columns) {\n+                    final int jEnd      = Math.min(jStart + tileSizeColumns, columns);\n+                    System.arraycopy(rawDataI, jStart, data, dataStart, jEnd - jStart);\n+                }\n+            }\n+        }\n+\n+        return data;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new RecursiveLayoutRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix copy() {\n+        return new RecursiveLayoutRealMatrix(rows, columns, data, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((RecursiveLayoutRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkAdditionCompatible(m);\n+\n+            final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, columns);\n+\n+            // perform addition tile-wise, to ensure good cache behavior\n+            for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+\n+                // perform addition on the current tile\n+                final int tileStart = index * tileSizeRows * tileSizeColumns;\n+                final long indices  = tilesIndices(index);\n+                final int iTile     = (int) (indices >> 32);\n+                final int jTile     = (int) (indices & 0xffffffff);\n+                final int pStart    = iTile * tileSizeRows;\n+                final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+                final int qStart    = jTile * tileSizeColumns;\n+                final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    final int kStart = tileStart + (p - pStart) * tileSizeColumns;\n+                    for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                        out.data[k] = data[k] + m.getEntry(p, q);\n+                    }\n+                }\n+\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RecursiveLayoutRealMatrix add(final RecursiveLayoutRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, columns);\n+\n+        // streamlined addition\n+        for (int i = 0; i < data.length; ++i) {\n+            out.data[i] = data[i] + m.data[i];\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((RecursiveLayoutRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkSubtractionCompatible(m);\n+\n+            final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, columns);\n+\n+            // perform subtraction tile-wise, to ensure good cache behavior\n+            for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+\n+                // perform addition on the current tile\n+                final int tileStart = index * tileSizeRows * tileSizeColumns;\n+                final long indices  = tilesIndices(index);\n+                final int iTile     = (int) (indices >> 32);\n+                final int jTile     = (int) (indices & 0xffffffff);\n+                final int pStart    = iTile * tileSizeRows;\n+                final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+                final int qStart    = jTile * tileSizeColumns;\n+                final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    final int kStart = tileStart + (p - pStart) * tileSizeColumns;\n+                    for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                        out.data[k] = data[k] - m.getEntry(p, q);\n+                    }\n+                }\n+\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RecursiveLayoutRealMatrix subtract(final RecursiveLayoutRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, columns);\n+\n+        // streamlined subtraction\n+        for (int i = 0; i < data.length; ++i) {\n+            out.data[i] = data[i] - m.data[i];\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarAdd(final double d)\n+        throws IllegalArgumentException {\n+\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, columns);\n+\n+        // streamlined addition\n+        for (int i = 0; i < data.length; ++i) {\n+            out.data[i] = data[i] + d;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarMultiply(final double d)\n+        throws IllegalArgumentException {\n+\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, columns);\n+\n+        // streamlined multiplication\n+        for (int i = 0; i < data.length; ++i) {\n+            out.data[i] = data[i] * d;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((RecursiveLayoutRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkMultiplicationCompatible(m);\n+\n+            final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, m.getColumnDimension());\n+\n+            // perform multiplication tile-wise, to ensure good cache behavior\n+            for (int index = 0; index < out.tileNumber * out.tileNumber; ++index) {\n+                final int tileStart = index * out.tileSizeRows * out.tileSizeColumns;\n+                final long indices  = tilesIndices(index);\n+                final int iTile     = (int) (indices >> 32);\n+                final int jTile     = (int) (indices & 0xffffffff);\n+                final int iStart    = iTile * out.tileSizeRows;\n+                final int iEnd      = Math.min(iStart + out.tileSizeRows, out.rows);\n+                final int jStart    = jTile * out.tileSizeColumns;\n+                final int jEnd      = Math.min(jStart + out.tileSizeColumns, out.columns);\n+\n+                // perform multiplication for current tile\n+                for (int kTile = 0; kTile < tileNumber; ++kTile) {\n+                    final int kTileStart = tileIndex(iTile, kTile) * tileSizeRows * tileSizeColumns;\n+                    for (int i = iStart, lStart = kTileStart, oStart = tileStart;\n+                         i < iEnd;\n+                         ++i, lStart += tileSizeColumns, oStart += out.tileSizeColumns) {\n+                        final int lEnd = Math.min(lStart + tileSizeColumns, columns);\n+                        for (int j = jStart, o = oStart; j < jEnd; ++j, ++o) {\n+                            double sum = 0;\n+                            for (int l = lStart, k = kTile * tileSizeColumns; l < lEnd; ++l, ++k) {\n+                                sum += data[l] * m.getEntry(k, j);\n+                            }\n+                            out.data[o] += sum;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     * <p>The Strassen matrix multiplication method is used here. This\n+     * method computes C = A &times; B recursively by splitting all matrices\n+     * in four quadrants and computing:</p>\n+     * <pre>\n+     * P<sub>1</sub> = (A<sub>1,1</sub> + A<sub>2,2</sub>) &times; (B<sub>1,1</sub> + B<sub>2,2</sub>)\n+     * P<sub>2</sub> = (A<sub>2,1</sub> + A<sub>2,2</sub>) &times; (B<sub>1,1</sub>)\n+     * P<sub>3</sub> = (A<sub>1,1</sub>) &times; (B<sub>1,2</sub> - B<sub>2,2</sub>)\n+     * P<sub>4</sub> = (A<sub>2,2</sub>) &times; (B<sub>2,1</sub> - B<sub>1,1</sub>)\n+     * P<sub>5</sub> = (A<sub>1,1</sub> + A<sub>1,2</sub>) &times; B<sub>2,2</sub>\n+     * P<sub>6</sub> = (A<sub>2,1</sub> - A<sub>1,1</sub>) &times; (B<sub>1,1</sub> + B<sub>1,2</sub>)\n+     * P<sub>7</sub> = (A<sub>1,2</sub> - A<sub>2,2</sub>) &times; (B<sub>2,1</sub> + B<sub>2,2</sub>)\n+     *\n+     * C<sub>1,1</sub> = P<sub>1</sub> + P<sub>4</sub> - P<sub>5</sub> + P<sub>7</sub>\n+     * C<sub>1,2</sub> = P<sub>3</sub> + P<sub>5</sub>\n+     * C<sub>2,1</sub> = P<sub>2</sub> + P<sub>4</sub>\n+     * C<sub>2,2</sub> = P<sub>1</sub> + P<sub>3</sub> - P<sub>2</sub> + P<sub>6</sub>\n+     * </pre>\n+     * <p>\n+     * This implementation is based on the 2002 paper: <a\n+     * href=\"http://www.cs.duke.edu/~alvy/papers/matrix-tpds.pdf\">Recursive Array Layouts\n+     * and Fast Matrix Multiplication</a> by Siddhartha Chatterjee, Alvin R. Lebeck,\n+     * Praveen K. Patnala and Mithuna Thottethodi.\n+     * </p>\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public RecursiveLayoutRealMatrix multiply(RecursiveLayoutRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, m.columns);\n+        if ((tileNumber != m.tileNumber) || (tileNumber != out.tileNumber)) {\n+            // TODO get rid of this test\n+            throw new RuntimeException(\"multiplication \" + rows + \"x\" + columns + \" * \" +\n+                                       m.rows + \"x\" + m.columns + \" -> left matrix: \" + tileNumber +\n+                                       \" tiles, right matrix: \" + m.tileNumber + \" tiles, result matrix \" +\n+                                       out.tileNumber + \" tiles\");\n+        }\n+        strassenMultiply(data, 0, true, m.data, 0, true, out.data, 0, tileNumber,\n+                         tileSizeRows, m.tileSizeColumns, tileSizeColumns);\n+        \n+        return out;\n+\n+    }\n+\n+    /**\n+     * Perform recursive multiplication using Strassen's algorithm.\n+     * @param a left term of multiplication\n+     * @param aStart start index in a\n+     * @param aDirect direct/reversed orientation flag for a\n+     * @param b right term of multiplication\n+     * @param bStart start index in b\n+     * @param bDirect direct/reversed orientation flag for b\n+     * @param result result array (will have same orientation as b)\n+     * @param resultStart start index in result\n+     * @param nTiles number of elements to add\n+     * @param bsRows number of rows in result tiles\n+     * @param bsColumns number of columns in result tiles\n+     * @param bsMultiplicands number of rows/columns in multiplicands\n+     */\n+    private static void strassenMultiply(final double[] a, final int aStart, final boolean aDirect,\n+                                         final double[] b, final int bStart, final boolean bDirect,\n+                                         final double[] result, final int resultStart, final int nTiles,\n+                                         final int bsRows, final int bsColumns, final int bsMultiplicands) {\n+        if (nTiles == 1) {\n+            // leaf recursion tile: perform traditional multiplication\n+            final int bsColumns2 = 2 * bsColumns;\n+            final int bsColumns3 = 3 * bsColumns;\n+            final int bsColumns4 = 4 * bsColumns;\n+            for (int i = 0; i < bsRows; ++i) {\n+                for (int j = 0; j < bsColumns; ++j) {\n+                    double sum = 0;\n+                    int k  = 0;\n+                    int aK = aStart + i * bsMultiplicands;\n+                    int bK = bStart + j;\n+                    while (k < bsMultiplicands - 3) {\n+                        sum += a[aK]     * b[bK] +\n+                               a[aK + 1] * b[bK + bsColumns] +\n+                               a[aK + 2] * b[bK + bsColumns2] +\n+                               a[aK + 3] * b[bK + bsColumns3];\n+                        k  += 4;\n+                        aK += 4;\n+                        bK += bsColumns4;\n+                    }\n+                    while (k < bsMultiplicands) {\n+                        sum += a[aK] * b[bK];\n+                        k  += 1;\n+                        aK += 1;\n+                        bK += bsColumns;\n+                    }\n+                    result[resultStart + i * bsColumns + j] = sum;\n+                }\n+            }\n+        } else {\n+            // regular recursion node: use recursive Strassen implementation\n+            final int n2            = nTiles / 2;\n+            final int aQuadrantSize = bsRows          * n2 * bsMultiplicands * n2;\n+            final int bQuadrantSize = bsMultiplicands * n2 * bsColumns       * n2;\n+            final int cQuadrantSize = bsRows          * n2 * bsColumns       * n2;\n+            final double[] sA = new double[aQuadrantSize];\n+            final double[] sB = new double[bQuadrantSize];\n+            final boolean nonLeafQuadrants = n2 > 1;\n+\n+            // identify A quadrants start indices\n+            final int a11Start, a12Start, a21Start, a22Start;\n+            if (aDirect) {\n+                a11Start = aStart;\n+                a12Start = aStart +     aQuadrantSize;\n+                a21Start = aStart + 3 * aQuadrantSize;\n+                a22Start = aStart + 2 * aQuadrantSize;\n+            } else {\n+                a11Start = aStart + 2 * aQuadrantSize;\n+                a12Start = aStart + 3 * aQuadrantSize;\n+                a21Start = aStart +     aQuadrantSize;\n+                a22Start = aStart;\n+            }\n+\n+            // identify B and C quadrants start indices\n+            // (C is constructed with the same orientation as B)\n+            final int b11Start, b12Start, b21Start, b22Start;\n+            final int c11Start, c12Start, c21Start, c22Start;\n+            if (bDirect) {\n+                b11Start = bStart;\n+                b12Start = bStart +     bQuadrantSize;\n+                b21Start = bStart + 3 * bQuadrantSize;\n+                b22Start = bStart + 2 * bQuadrantSize;\n+                c11Start = resultStart;\n+                c12Start = resultStart +     cQuadrantSize;\n+                c21Start = resultStart + 3 * cQuadrantSize;\n+                c22Start = resultStart + 2 * cQuadrantSize;\n+            } else {\n+                b11Start = bStart + 2 * bQuadrantSize;\n+                b12Start = bStart + 3 * bQuadrantSize;\n+                b21Start = bStart +     bQuadrantSize;\n+                b22Start = bStart;\n+                c11Start = resultStart + 2 * cQuadrantSize;\n+                c12Start = resultStart + 3 * cQuadrantSize;\n+                c21Start = resultStart +     cQuadrantSize;\n+                c22Start = resultStart;\n+            }\n+\n+            // optimal order for cache efficiency: P3, P6, P2, P1, P5, P7, P4\n+\n+            // P3  = (A11)(B12 - B22)\n+            // C12 = P3 + ...\n+            tilesSubtract(b, b12Start, false, b, b22Start, false, sB, 0,\n+                          bQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(a, a11Start, true, sB, 0, false, result, c12Start,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+\n+            // P6  = (A21 - A11)(B11 + B12)\n+            // C22 = P3 + P6 + ...\n+            final double[] p67 = new double[cQuadrantSize];\n+            tilesSubtract(a, a21Start, true, a, a11Start, true, sA, 0,\n+                          aQuadrantSize, nonLeafQuadrants);\n+            tilesAdd(b, b11Start, true, b, b12Start, false, sB, 0,\n+                     bQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(sA, 0, true, sB, 0, true, p67, 0,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+            tilesAdd(result, c12Start, false, p67, 0, true, result, c22Start,\n+                     cQuadrantSize, nonLeafQuadrants);\n+\n+            // P2  = (A21 + A22)(B11)\n+            // C21 = P2 + ...\n+            // C22 = P3 + P6 - P2 + ...\n+            tilesAdd(a, a21Start, true, a, a22Start, false, sA, 0,\n+                     aQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(sA, 0, true, b, b11Start, true, result, c21Start,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+            tilesSelfSubtract(result, c22Start, false, result, c21Start, true,\n+                              cQuadrantSize, nonLeafQuadrants);\n+\n+            // P1  = (A11 + A22)(B11 + B22)\n+            // C11 = P1 + ...\n+            // C22 = P3 + P6 - P2 + P1\n+            tilesAdd(a, a11Start, true, a, a22Start, false, sA, 0,\n+                     aQuadrantSize, nonLeafQuadrants);\n+            tilesAdd(b, b11Start, true, b, b22Start, false, sB, 0,\n+                     bQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(sA, 0, true, sB, 0, true, result, c11Start,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+            tilesSelfAdd(result, c22Start, false, result, c11Start, true,\n+                         cQuadrantSize, nonLeafQuadrants);\n+\n+            // P5  = (A11 + A12)B22\n+            // beware: there is a sign error here in Chatterjee et al. paper\n+            // in figure 1, table b they subtract A12 from A11 instead of adding it\n+            // C12 = P3 + P5\n+            // C11 = P1 - P5 + ...\n+            final double[] p45 = new double[cQuadrantSize];\n+            tilesAdd(a, a11Start, true, a, a12Start, false, sA, 0,\n+                     aQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(sA, 0, true, b, b22Start, false, p45, 0,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+            tilesSelfAdd(result, c12Start, false, p45, 0, false,\n+                         cQuadrantSize, nonLeafQuadrants);\n+            tilesSelfSubtract(result, c11Start, true, p45, 0, false,\n+                              cQuadrantSize, nonLeafQuadrants);\n+\n+            // P7  = (A12 - A22)(B21 + B22)\n+            // C11 = P1 - P5 + P7 + ...\n+            tilesSubtract(a, a12Start, false, a, a22Start, false, sA, 0,\n+                          aQuadrantSize, nonLeafQuadrants);\n+            tilesAdd(b, b21Start, true, b, b22Start, false, sB, 0,\n+                     bQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(sA, 0, false, sB, 0, true, p67, 0,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+            tilesSelfAdd(result, c11Start, true, p67, 0, true,\n+                         cQuadrantSize, nonLeafQuadrants);\n+\n+            // P4  = (A22)(B21 - B11)\n+            // C11 = P1 - P5 + P7 + P4\n+            // C21 = P2 + P4\n+            tilesSubtract(b, b21Start, true, b, b11Start, true, sB, 0,\n+                          bQuadrantSize, nonLeafQuadrants);\n+            strassenMultiply(a, a22Start, false, sB, 0, true, p45, 0,\n+                             n2, bsRows, bsColumns, bsMultiplicands);\n+            tilesSelfAdd(result, c11Start, true, p45, 0, true,\n+                         cQuadrantSize, nonLeafQuadrants);\n+            tilesSelfAdd(result, c21Start, true, p45, 0, true,\n+                         cQuadrantSize, nonLeafQuadrants);\n+\n+        }\n+    }\n+\n+    /**\n+     * Perform an addition on a few tiles in arrays.\n+     * @param a left term of addition\n+     * @param aStart start index in a\n+     * @param aDirect direct/reversed orientation flag for a\n+     * @param b right term of addition\n+     * @param bStart start index in b\n+     * @param bDirect direct/reversed orientation flag for b\n+     * @param result result array (will have same orientation as a)\n+     * @param resultStart start index in result\n+     * @param n number of elements to add\n+     * @param nonLeafQuadrants if true the quadrant can be further decomposed\n+     */\n+    private static void tilesAdd(final double[] a, final int aStart, final boolean aDirect,\n+                                 final double[] b, final int bStart, final boolean bDirect,\n+                                 final double[] result, final int resultStart,\n+                                 final int n, final boolean nonLeafQuadrants) {\n+        if ((aDirect ^ bDirect) & nonLeafQuadrants) {\n+            // a and b have different orientations\n+            // perform addition in two half\n+            final int n2 = n / 2;\n+            addLoop(a, aStart,      b, bStart + n2, result, resultStart,      n2);\n+            addLoop(a, aStart + n2, b, bStart,      result, resultStart + n2, n2);\n+        } else {\n+            // a and b have same orientations\n+            // perform addition in one loop\n+            addLoop(a, aStart, b, bStart, result, resultStart, n);\n+        }\n+    }\n+\n+    /**\n+     * Perform an addition loop.\n+     * @param a left term of addition\n+     * @param aStart start index in a\n+     * @param b right term of addition\n+     * @param bStart start index in b\n+     * @param result result array (will have same orientation as a)\n+     * @param resultStart start index in result\n+     * @param n number of elements to add\n+     */\n+    private static void addLoop(final double[] a, final int aStart,\n+                                final double[] b, final int bStart,\n+                                final double[] result, final int resultStart,\n+                                final int n) {\n+        int i = 0;\n+        while (i < n - 3) {\n+            final int r0 = resultStart + i;\n+            final int a0 = aStart      + i;\n+            final int b0 = bStart      + i;\n+            result[r0]     = a[a0]     + b[b0];\n+            result[r0 + 1] = a[a0 + 1] + b[b0 + 1];\n+            result[r0 + 2] = a[a0 + 2] + b[b0 + 2];\n+            result[r0 + 3] = a[a0 + 3] + b[b0 + 3];\n+            i += 4;\n+        }\n+        while (i < n) {\n+            result[resultStart + i] = a[aStart + i] + b[bStart + i];\n+            ++i;\n+        }\n+    }\n+\n+    /**\n+     * Perform a subtraction on a few tiles in arrays.\n+     * @param a left term of subtraction\n+     * @param aStart start index in a\n+     * @param aDirect direct/reversed orientation flag for a\n+     * @param b right term of subtraction\n+     * @param bStart start index in b\n+     * @param bDirect direct/reversed orientation flag for b\n+     * @param result result array (will have same orientation as a)\n+     * @param resultStart start index in result\n+     * @param n number of elements to subtract\n+     * @param nonLeafQuadrants if true the quadrant can be further decomposed\n+     */\n+    private static void tilesSubtract(final double[] a, final int aStart, final boolean aDirect,\n+                                      final double[] b, final int bStart, final boolean bDirect,\n+                                      final double[] result, final int resultStart,\n+                                      final int n, final boolean nonLeafQuadrants) {\n+        if ((aDirect ^ bDirect) & nonLeafQuadrants) {\n+            // a and b have different orientations\n+            // perform subtraction in two half\n+            final int n2 = n / 2;\n+            subtractLoop(a, aStart,      b, bStart + n2, result, resultStart,      n2);\n+            subtractLoop(a, aStart + n2, b, bStart,      result, resultStart + n2, n2);\n+        } else {\n+            // a and b have same orientations\n+            // perform subtraction in one loop\n+            subtractLoop(a, aStart, b, bStart, result, resultStart, n);\n+        }\n+    }\n+\n+    /**\n+     * Perform a subtraction loop.\n+     * @param a left term of subtraction\n+     * @param aStart start index in a\n+     * @param b right term of subtraction\n+     * @param bStart start index in b\n+     * @param result result array (will have same orientation as a)\n+     * @param resultStart start index in result\n+     * @param n number of elements to subtract\n+     */\n+    private static void subtractLoop(final double[] a, final int aStart,\n+                                     final double[] b, final int bStart,\n+                                     final double[] result, final int resultStart,\n+                                     final int n) {\n+        int i = 0;\n+        while (i < n - 3) {\n+            final int r0 = resultStart + i;\n+            final int a0 = aStart      + i;\n+            final int b0 = bStart      + i;\n+            result[r0]     = a[a0]     - b[b0];\n+            result[r0 + 1] = a[a0 + 1] - b[b0 + 1];\n+            result[r0 + 2] = a[a0 + 2] - b[b0 + 2];\n+            result[r0 + 3] = a[a0 + 3] - b[b0 + 3];\n+            i += 4;\n+        }\n+        while (i < n) {\n+            result[resultStart + i] = a[aStart + i] - b[bStart + i];\n+            ++i;\n+        }\n+    }\n+\n+    /**\n+     * Perform a self-addition on a few tiles in arrays.\n+     * @param a left term of addition (will be overwritten with result)\n+     * @param aStart start index in a\n+     * @param aDirect direct/reversed orientation flag for a\n+     * @param b right term of addition\n+     * @param bStart start index in b\n+     * @param bDirect direct/reversed orientation flag for b\n+     * @param n number of elements to add\n+     * @param nonLeafQuadrants if true the quadrant can be further decomposed\n+     */\n+    private static void tilesSelfAdd(final double[] a, final int aStart, final boolean aDirect,\n+                                     final double[] b, final int bStart, final boolean bDirect,\n+                                     final int n, final boolean nonLeafQuadrants) {\n+        if ((aDirect ^ bDirect) & nonLeafQuadrants) {\n+            // a and b have different orientations\n+            // perform addition in two half\n+            final int n2 = n / 2;\n+            selfAddLoop(a, aStart,      b, bStart + n2, n2);\n+            selfAddLoop(a, aStart + n2, b, bStart,      n2);\n+        } else {\n+            // a and b have same orientations\n+            // perform addition in one loop\n+            selfAddLoop(a, aStart, b, bStart, n);\n+        }\n+    }\n+\n+    /**\n+     * Perform a self-addition loop.\n+     * @param a left term of addition (will be overwritten with result)\n+     * @param aStart start index in a\n+     * @param b right term of addition\n+     * @param bStart start index in b\n+     * @param n number of elements to add\n+     */\n+    private static void selfAddLoop(final double[] a, final int aStart,\n+                                    final double[] b, final int bStart,\n+                                    final int n) {\n+        int i = 0;\n+        while (i < n - 3) {\n+            final int a0 = aStart + i;\n+            final int b0 = bStart + i;\n+            a[a0]     += b[b0];\n+            a[a0 + 1] += b[b0 + 1];\n+            a[a0 + 2] += b[b0 + 2];\n+            a[a0 + 3] += b[b0 + 3];\n+            i += 4;\n+        }\n+        while (i < n) {\n+            a[aStart + i] += b[bStart + i];\n+            ++i;\n+        }\n+    }\n+\n+    /**\n+     * Perform a self-subtraction on a few tiles in arrays.\n+     * @param a left term of subtraction (will be overwritten with result)\n+     * @param aStart start index in a\n+     * @param aDirect direct/reversed orientation flag for a\n+     * @param b right term of subtraction\n+     * @param bStart start index in b\n+     * @param bDirect direct/reversed orientation flag for b\n+     * @param n number of elements to subtract\n+     * @param nonLeafQuadrants if true the quadrant can be further decomposed\n+     */\n+    private static void tilesSelfSubtract(final double[] a, final int aStart, final boolean aDirect,\n+                                          final double[] b, final int bStart, final boolean bDirect,\n+                                          final int n, final boolean nonLeafQuadrants) {\n+        if ((aDirect ^ bDirect) & nonLeafQuadrants) {\n+            // a and b have different orientations\n+            // perform subtraction in two half\n+            final int n2 = n / 2;\n+            selfSubtractLoop(a, aStart,      b, bStart + n2, n2);\n+            selfSubtractLoop(a, aStart + n2, b, bStart,      n2);\n+        } else {\n+            // a and b have same orientations\n+            // perform subtraction in one loop\n+            selfSubtractLoop(a, aStart, b, bStart, n);\n+        }\n+    }\n+\n+    /**\n+     * Perform a self-subtraction loop.\n+     * @param a left term of subtraction (will be overwritten with result)\n+     * @param aStart start index in a\n+     * @param b right term of subtraction\n+     * @param bStart start index in b\n+     * @param n number of elements to subtract\n+     */\n+    private static void selfSubtractLoop(final double[] a, final int aStart,\n+                                         final double[] b, final int bStart,\n+                                         final int n) {\n+        int i = 0;\n+        while (i < n - 3) {\n+            final int a0 = aStart + i;\n+            final int b0 = bStart + i;\n+            a[a0]     -= b[b0];\n+            a[a0 + 1] -= b[b0 + 1];\n+            a[a0 + 2] -= b[b0 + 2];\n+            a[a0 + 3] -= b[b0 + 3];\n+            i += 4;\n+        }\n+        while (i < n) {\n+            a[aStart + i] -= b[bStart + i];\n+            ++i;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[][] getData() {\n+\n+        final double[][] out = new double[rows][columns];\n+\n+        // perform extraction tile-wise, to ensure good cache behavior\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+\n+            // perform extraction on the current tile\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int pStart    = iTile * tileSizeRows;\n+            final int qStart    = jTile * tileSizeColumns;\n+            if (pStart < rows && qStart < columns) {\n+                final int pEnd = Math.min(pStart + tileSizeRows, rows);\n+                final int qEnd = Math.min(qStart + tileSizeColumns, columns);\n+                int tileRowStart = tileStart;\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    System.arraycopy(data, tileRowStart, out[p], qStart, qEnd - qStart);\n+                    tileRowStart += tileSizeColumns;\n+                }\n+            }\n+\n+        }\n+\n+        return out;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFrobeniusNorm() {\n+        double sum2 = 0;\n+        for (final double entry : data) {\n+            sum2 += entry * entry;\n+        }\n+        return Math.sqrt(sum2);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final RecursiveLayoutRealMatrix out =\n+            new RecursiveLayoutRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // perform extraction tile-wise, to ensure good cache behavior\n+        for (int iTile = 0; iTile < out.tileNumber; ++iTile) {\n+            final int iStart = startRow + iTile * out.tileSizeRows;\n+            final int iEnd   = Math.min(startRow + Math.min((iTile + 1) * out.tileSizeRows, out.rows),\n+                                        endRow + 1);\n+            for (int jTile = 0; jTile < out.tileNumber; ++jTile) {\n+                final int jStart = startColumn + jTile * out.tileSizeColumns;\n+                final int jEnd   = Math.min(startColumn + Math.min((jTile + 1) * out.tileSizeColumns, out.columns),\n+                                            endColumn + 1);\n+\n+                // the current output tile may expand on more than one instance tile\n+                for (int pTile = iStart / tileSizeRows; pTile * tileSizeRows < iEnd; ++pTile) {\n+                    final int p0     = pTile * tileSizeRows;\n+                    final int pStart = Math.max(p0, iStart);\n+                    final int pEnd   = Math.min(Math.min(p0 + tileSizeRows, endRow + 1), iEnd);\n+                    for (int qTile = jStart / tileSizeColumns; qTile * tileSizeColumns < jEnd; ++qTile) {\n+                        final int q0     = qTile * tileSizeColumns;\n+                        final int qStart = Math.max(q0, jStart);\n+                        final int qEnd   = Math.min(Math.min(q0 + tileSizeColumns, endColumn + 1), jEnd);\n+\n+                        // copy the overlapping part of instance and output tiles\n+                        int outIndex = tileIndex(iTile, jTile) * out.tileSizeRows * out.tileSizeColumns +\n+                                       (pStart - iStart) * out.tileSizeColumns + (qStart - jStart);\n+                        int index    = tileIndex(pTile, qTile) * tileSizeRows * tileSizeColumns +\n+                                       (pStart - p0) * tileSizeColumns + (qStart - q0);\n+                        for (int p = pStart; p < pEnd; ++p) {\n+                            System.arraycopy(data, index, out.data, outIndex, qEnd - qStart);\n+                            outIndex += out.tileSizeColumns;\n+                            index    += tileSizeColumns;\n+                        }\n+                        \n+\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n+                                                                      null);             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        checkSubMatrixIndex(row, endRow, column, endColumn);\n+        for (final double[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n+                                                                          new Object[] {\n+                                                                              refLength, subRow.length\n+                                                                          }); \n+            }\n+        }\n+\n+        // compute tiles bounds\n+        final int tileStartRow    = row / tileSizeRows;\n+        final int tileEndRow      = (endRow + tileSizeRows) / tileSizeRows;\n+        final int tileStartColumn = column / tileSizeColumns;\n+        final int tileEndColumn   = (endColumn + tileSizeColumns) / tileSizeColumns;\n+\n+        // perform copy tile-wise, to ensure good cache behavior\n+        for (int iTile = tileStartRow; iTile < tileEndRow; ++iTile) {\n+            final int firstRow = iTile * tileSizeRows;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + tileSizeRows);\n+\n+            for (int jTile = tileStartColumn; jTile < tileEndColumn; ++jTile) {\n+                final int firstColumn = jTile * tileSizeColumns;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + tileSizeColumns);\n+                final int jLength     = jEnd - jStart;\n+                final int tileStart   = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns;\n+\n+                // handle one tile, row by row\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     data, tileStart + (i - firstRow) * tileSizeColumns + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(1, columns);\n+\n+        // a row matrix has always only one large tile,\n+        // because a single row cannot be split into 2^k tiles\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int iTile     = row / tileSizeRows;\n+        final int rowOffset = row - iTile * tileSizeRows;\n+        int outIndex        = 0;\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               rowOffset * tileSizeColumns;\n+            final int length = Math.min(outIndex + tileSizeColumns, columns) - outIndex;\n+            System.arraycopy(data, kStart, out.data, outIndex, length);\n+            outIndex += length;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (RecursiveLayoutRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final RecursiveLayoutRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 matrix.getRowDimension(),\n+                                                 matrix.getColumnDimension(),\n+                                                 1, nCols\n+                                             });\n+        }\n+\n+        // a row matrix has always only one large tile,\n+        // because a single row cannot be split into 2^k tiles\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int iTile     = row / tileSizeRows;\n+        final int rowOffset = row - iTile * tileSizeRows;\n+        int outIndex        = 0;\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               rowOffset * tileSizeColumns;\n+            final int length = Math.min(outIndex + tileSizeColumns, columns) - outIndex;\n+            System.arraycopy(matrix.data, outIndex, data, kStart, length);\n+            outIndex += length;\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, 1);\n+\n+        // a column matrix has always only one large tile,\n+        // because a single column cannot be split into 2^k tiles\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int jTile        = column / tileSizeColumns;\n+        final int columnOffset = column - jTile * tileSizeColumns;\n+        for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+            final int pStart = iTile * tileSizeRows;\n+            final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               columnOffset;\n+            for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                out.data[p] = data[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (RecursiveLayoutRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final RecursiveLayoutRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 matrix.getRowDimension(),\n+                                                 matrix.getColumnDimension(),\n+                                                 nRows, 1\n+                                             });\n+        }\n+\n+        // a column matrix has always only one large tile,\n+        // because a single column cannot be split into 2^k tiles\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int jTile        = column / tileSizeColumns;\n+        final int columnOffset = column - jTile * tileSizeColumns;\n+        for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+            final int pStart = iTile * tileSizeRows;\n+            final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               columnOffset;\n+            for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                data[k] = matrix.data[p];\n+            }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((RealVectorImpl) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            checkRowIndex(row);\n+            if (vector.getDimension() != columns) {\n+                throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                                 new Object[] {\n+                                                     1, vector.getDimension(),\n+                                                     1, columns\n+                                                 });\n+            }\n+\n+            // perform copy tile-wise, to ensure good cache behavior\n+            final int iTile     = row / tileSizeRows;\n+            final int rowOffset = row - iTile * tileSizeRows;\n+            int outIndex        = 0;\n+            for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+                final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                                   rowOffset * tileSizeColumns;\n+                final int length = Math.min(outIndex + tileSizeColumns, columns) - outIndex;\n+                for (int l = 0; l < length; ++l) {\n+                    data[kStart + l] = vector.getEntry(outIndex + l);\n+                }\n+                outIndex += length;\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((RealVectorImpl) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            checkColumnIndex(column);\n+            if (vector.getDimension() != rows) {\n+                throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                                 new Object[] {\n+                                                     vector.getDimension(), 1,\n+                                                     rows, 1\n+                                                 });\n+            }\n+\n+            // perform copy tile-wise, to ensure good cache behavior\n+            final int jTile        = column / tileSizeColumns;\n+            final int columnOffset = column - jTile * tileSizeColumns;\n+            for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+                final int pStart = iTile * tileSizeRows;\n+                final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+                final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                                   columnOffset;\n+                for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                    data[k] = vector.getEntry(p);\n+                }\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final double[] out = new double[columns];\n+\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int iTile     = row / tileSizeRows;\n+        final int rowOffset = row - iTile * tileSizeRows;\n+        int outIndex        = 0;\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               rowOffset * tileSizeColumns;\n+            final int length = Math.min(outIndex + tileSizeColumns, columns) - outIndex;\n+            System.arraycopy(data, kStart, out, outIndex, length);\n+            outIndex += length;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRow(final int row, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        if (array.length != columns) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 1, array.length,\n+                                                 1, columns\n+                                             });\n+        }\n+\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int iTile     = row / tileSizeRows;\n+        final int rowOffset = row - iTile * tileSizeRows;\n+        int outIndex        = 0;\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               rowOffset * tileSizeColumns;\n+            final int length = Math.min(outIndex + tileSizeColumns, columns) - outIndex;\n+            System.arraycopy(array, outIndex, data, kStart, length);\n+            outIndex += length;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final double[] out = new double[rows];\n+\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int jTile        = column / tileSizeColumns;\n+        final int columnOffset = column - jTile * tileSizeColumns;\n+        for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+            final int pStart = iTile * tileSizeRows;\n+            final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               columnOffset;\n+            for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                out[p] = data[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumn(final int column, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        if (array.length != rows) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 array.length, 1,\n+                                                 rows, 1\n+                                             });\n+        }\n+\n+        // perform copy tile-wise, to ensure good cache behavior\n+        final int jTile        = column / tileSizeColumns;\n+        final int columnOffset = column - jTile * tileSizeColumns;\n+        for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+            final int pStart = iTile * tileSizeRows;\n+            final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+            final int kStart = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns +\n+                               columnOffset;\n+            for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                data[k] = array[p];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+        return data[index(row, column)];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+        data[index(row, column)] = value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+        data[index(row, column)] += increment;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+        data[index(row, column)] *= factor;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix transpose() {\n+\n+        final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(columns, rows);\n+\n+        // perform transpose tile-wise, to ensure good cache behavior\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart    = index * tileSizeRows * tileSizeColumns;\n+            final long indices     = tilesIndices(index);\n+            final int outJTile     = (int) (indices >> 32);        // iTile in the instance\n+            final int outITile     = (int) (indices & 0xffffffff); // jTile in the instance\n+            final int outIndex     = tileIndex(outITile, outJTile);\n+            final int outTileStart = outIndex * tileSizeRows * tileSizeColumns;\n+\n+            // transpose current tile\n+            final int outPStart = outITile * tileSizeColumns;\n+            final int outPEnd   = Math.min(outPStart + tileSizeColumns, columns);\n+            final int outQStart = outJTile * tileSizeRows;\n+            final int outQEnd   = Math.min(outQStart + tileSizeRows, rows);\n+            for (int outP = outPStart; outP < outPEnd; ++outP) {\n+                final int dP = outP - outPStart;\n+                int k = outTileStart + dP * tileSizeRows;\n+                int l = tileStart + dP;\n+                for (int outQ = outQStart; outQ < outQEnd; ++outQ) {\n+                    out.data[k++] = data[l];\n+                    l+= tileSizeColumns;\n+                }\n+            }\n+\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.length, columns\n+                                                                      });\n+        }\n+        final double[] out = new double[rows];\n+\n+        // perform multiplication tile-wise, to ensure good cache behavior\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int pStart    = iTile * tileSizeRows;\n+            final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+            final int qStart    = jTile * tileSizeColumns;\n+            final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+            for (int p = pStart, k = tileStart; p < pEnd; ++p) {\n+                double sum = 0;\n+                int    q   = qStart;\n+                while (q < qEnd - 3) {\n+                    sum += data[k]     * v[q]     +\n+                           data[k + 1] * v[q + 1] +\n+                           data[k + 2] * v[q + 2] +\n+                           data[k + 3] * v[q + 3];\n+                    k += 4;\n+                    q += 4;\n+                }\n+                while (q < qEnd) {\n+                    sum += data[k++] * v[q++];\n+                }\n+                out[p] += sum;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.length, rows\n+                                                                      });\n+        }\n+        final double[] out = new double[columns];\n+\n+        final int offset1 = tileSizeColumns;\n+        final int offset2 = offset1 + offset1;\n+        final int offset3 = offset2 + offset1;\n+        final int offset4 = offset3 + offset1;\n+\n+        // perform multiplication tile-wise, to ensure good cache behavior\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int pStart    = iTile * tileSizeRows;\n+            final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+            final int qStart    = jTile * tileSizeColumns;\n+            final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+            for (int q = qStart; q < qEnd; ++q) {\n+                int k = tileStart + q - qStart;\n+                double sum = 0;\n+                int p = pStart;\n+                while (p < pEnd - 3) {\n+                    sum += data[k]           * v[p]     +\n+                           data[k + offset1] * v[p + 1] +\n+                           data[k + offset2] * v[p + 2] +\n+                           data[k + offset3] * v[p + 3];\n+                    k += offset4;\n+                    p += 4;\n+                }\n+                while (p < pEnd) {\n+                    sum += data[k] * v[p++];\n+                    k   += offset1;\n+                }\n+                out[q] += sum;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+            final int pStart = iTile * tileSizeRows;\n+            final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+                    final int qStart    = jTile * tileSizeColumns;\n+                    final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart    = tileStart + (p - pStart) * tileSizeColumns;\n+                    for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                        data[k] = visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+            final int pStart = iTile * tileSizeRows;\n+            final int pEnd   = Math.min(pStart + tileSizeRows, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+                    final int qStart    = jTile * tileSizeColumns;\n+                    final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart    = tileStart + (p - pStart) * tileSizeColumns;\n+                    for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iTile = startRow / tileSizeRows; iTile < 1 + endRow / tileSizeRows; ++iTile) {\n+            final int p0     = iTile * tileSizeRows;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iTile + 1) * tileSizeRows, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jTile = startColumn / tileSizeColumns; jTile < 1 + endColumn / tileSizeColumns; ++jTile) {\n+                    final int q0        = jTile * tileSizeColumns;\n+                    final int qStart    = Math.max(startColumn, q0);\n+                    final int qEnd      = Math.min((jTile + 1) * tileSizeColumns, 1 + endColumn);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart    = tileStart + (p - p0) * tileSizeColumns + (qStart - q0);\n+                    for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                        data[k] = visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iTile = startRow / tileSizeRows; iTile < 1 + endRow / tileSizeRows; ++iTile) {\n+            final int p0     = iTile * tileSizeRows;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iTile + 1) * tileSizeRows, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jTile = startColumn / tileSizeColumns; jTile < 1 + endColumn / tileSizeColumns; ++jTile) {\n+                    final int q0        = jTile * tileSizeColumns;\n+                    final int qStart    = Math.max(startColumn, q0);\n+                    final int qEnd      = Math.min((jTile + 1) * tileSizeColumns, 1 + endColumn);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart    = tileStart + (p - p0) * tileSizeColumns + (qStart - q0);\n+                    for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int qStart = jTile * tileSizeColumns;\n+            final int qEnd   = Math.min(qStart + tileSizeColumns, columns);\n+            for (int q = qStart; q < qEnd; ++q) {\n+                for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+                    final int pStart    = iTile * tileSizeRows;\n+                    final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart    = tileStart + (q - qStart);\n+                    for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                        data[k] = visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int qStart = jTile * tileSizeColumns;\n+            final int qEnd   = Math.min(qStart + tileSizeColumns, columns);\n+            for (int q = qStart; q < qEnd; ++q) {\n+                for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+                    final int pStart    = iTile * tileSizeRows;\n+                    final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart    = tileStart + (q - qStart);\n+                    for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                        visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int q0     = jTile * tileSizeColumns;\n+            final int qStart = Math.max(startColumn, q0);\n+            final int qEnd   = Math.min((jTile + 1) * tileSizeColumns, 1 + endColumn);\n+            for (int q = qStart; q < qEnd; ++q) {\n+                for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+                    final int p0        = iTile * tileSizeRows;\n+                    final int pStart    = Math.max(startRow, p0);\n+                    final int pEnd      = Math.min((iTile + 1) * tileSizeRows, 1 + endRow);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                          tileSizeRows * tileSizeColumns;\n+                    final int kStart = tileStart + (pStart - p0) * tileSizeColumns + (q - q0);\n+                    for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                        data[k] = visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int jTile = 0; jTile < tileNumber; ++jTile) {\n+            final int q0     = jTile * tileSizeColumns;\n+            final int qStart = Math.max(startColumn, q0);\n+            final int qEnd   = Math.min((jTile + 1) * tileSizeColumns, 1 + endColumn);\n+            for (int q = qStart; q < qEnd; ++q) {\n+                for (int iTile = 0; iTile < tileNumber; ++iTile) {\n+                    final int p0        = iTile * tileSizeRows;\n+                    final int pStart    = Math.max(startRow, p0);\n+                    final int pEnd      = Math.min((iTile + 1) * tileSizeRows, 1 + endRow);\n+                    final int tileStart = tileIndex(iTile, jTile) *\n+                                           tileSizeRows * tileSizeColumns;\n+                    final int kStart = tileStart + (pStart - p0) * tileSizeColumns + (q - q0);\n+                    for (int p = pStart, k = kStart; p < pEnd; ++p, k += tileSizeColumns) {\n+                        visitor.visit(p, q, data[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int pStart    = iTile * tileSizeRows;\n+            final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+            final int qStart    = jTile * tileSizeColumns;\n+            final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final int kStart = tileStart + (p - pStart) * tileSizeColumns;\n+                for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                    data[k] = visitor.visit(p, q, data[k]);\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int pStart    = iTile * tileSizeRows;\n+            final int pEnd      = Math.min(pStart + tileSizeRows, rows);\n+            final int qStart    = jTile * tileSizeColumns;\n+            final int qEnd      = Math.min(qStart + tileSizeColumns, columns);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final int kStart = tileStart + (p - pStart) * tileSizeColumns;\n+                for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                    visitor.visit(p, q, data[k]);\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int p0        = iTile * tileSizeRows;\n+            final int pStart    = Math.max(startRow, p0);\n+            final int pEnd      = Math.min((iTile + 1) * tileSizeRows, 1 + endRow);\n+            final int q0        = jTile * tileSizeColumns;\n+            final int qStart    = Math.max(startColumn, q0);\n+            final int qEnd      = Math.min((jTile + 1) * tileSizeColumns, 1 + endColumn);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final int kStart = tileStart + (p - p0) * tileSizeColumns + (qStart - q0);\n+                for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                    data[k] = visitor.visit(p, q, data[k]);\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int index = 0; index < tileNumber * tileNumber; ++index) {\n+            final int tileStart = index * tileSizeRows * tileSizeColumns;\n+            final long indices  = tilesIndices(index);\n+            final int iTile     = (int) (indices >> 32);\n+            final int jTile     = (int) (indices & 0xffffffff);\n+            final int p0        = iTile * tileSizeRows;\n+            final int pStart    = Math.max(startRow, p0);\n+            final int pEnd      = Math.min((iTile + 1) * tileSizeRows, 1 + endRow);\n+            final int q0        = jTile * tileSizeColumns;\n+            final int qStart    = Math.max(startColumn, q0);\n+            final int qEnd      = Math.min((jTile + 1) * tileSizeColumns, 1 + endColumn);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final int kStart = tileStart + (p - p0) * tileSizeColumns + (qStart - q0);\n+                for (int q = qStart, k = kStart; q < qEnd; ++q, ++k) {\n+                    visitor.visit(p, q, data[k]);\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Get the index of an element.\n+     * @param row row index of the element\n+     * @param column column index of the element\n+     * @return index of the element\n+     */\n+    private int index(final int row, final int columns) {\n+        final int iTile       = row     / tileSizeRows;\n+        final int jTile       = columns / tileSizeColumns;\n+        final int tileStart   = tileIndex(iTile, jTile) * tileSizeRows * tileSizeColumns;\n+        final int indexInTile = (row % tileSizeRows) * tileSizeColumns +\n+                                (columns % tileSizeColumns);\n+        return tileStart + indexInTile;\n+    }\n+\n+    /**\n+     * Get the index of a tile.\n+     * @param iTile row index of the tile\n+     * @param jTile column index of the tile\n+     * @return index of the tile\n+     */\n+    private static int tileIndex(int iTile, int jTile) {\n+\n+        // compute n = 2^k such that a nxn square contains the indices\n+        int n = Integer.highestOneBit(Math.max(iTile, jTile)) << 1;\n+\n+        // start recursion by noting the index is somewhere in the nxn\n+        // square whose lowest index is 0 and which has direct orientation\n+        int lowIndex   = 0;\n+        boolean direct = true;\n+\n+        // the tail-recursion on the square size is replaced by an iteration here\n+        while (n > 1) {\n+\n+            // reduce square to 4 quadrants\n+            n >>= 1;\n+            final int n2 = n * n;\n+\n+            // check in which quadrant the element is,\n+            // updating the lowest index of the quadrant and its orientation\n+            if (iTile < n) {\n+                if (jTile < n) {\n+                    // the element is in the top-left quadrant\n+                    if (!direct) {\n+                        lowIndex += 2 * n2;\n+                        direct = true;\n+                    }\n+                } else {\n+                    // the element is in the top-right quadrant\n+                    jTile -= n;\n+                    if (direct) {\n+                        lowIndex += n2;\n+                        direct = false;\n+                    } else {\n+                        lowIndex += 3 * n2;\n+                    }\n+                }\n+            } else {\n+                iTile -= n;\n+                if (jTile < n) {\n+                    // the element is in the bottom-left quadrant\n+                    if (direct) {\n+                        lowIndex += 3 * n2;\n+                    } else {\n+                        lowIndex += n2;\n+                        direct = true;\n+                    }\n+                } else {\n+                    // the element is in the bottom-right quadrant\n+                    jTile -= n;\n+                    if (direct) {\n+                        lowIndex += 2 * n2;\n+                        direct = false;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // the lowest index of the remaining 1x1 quadrant is the requested index\n+        return lowIndex;\n+\n+    }\n+\n+    /**\n+     * Get the row and column tile indices of a tile.\n+     * @param index index of the tile in the layout\n+     * @return row and column indices packed in one long (row tile index\n+     * in 32 high order bits, column tile index in low order bits)\n+     */\n+    private static long tilesIndices(int index) {\n+\n+        // compute n = 2^k such that a nxn square contains the index\n+        int n = Integer.highestOneBit((int) Math.sqrt(index)) << 1;\n+\n+        // start recursion by noting the index is somewhere in the nxn\n+        // square whose lowest index is 0 and which has direct orientation\n+        int iLow       = 0;\n+        int jLow       = 0;\n+        boolean direct = true;\n+\n+        // the tail-recursion on the square size is replaced by an iteration here\n+        while (n > 1) {\n+\n+            // reduce square to 4 quadrants\n+            n >>= 1;\n+            final int n2 = n * n;\n+\n+            // check in which quadrant the element is,\n+            // updating the low indices of the quadrant and its orientation\n+            switch (index / n2) {\n+            case 0 :\n+                if (!direct) {\n+                    iLow += n;\n+                    jLow += n;\n+                }\n+                break;\n+            case 1 :\n+                if (direct) {\n+                    jLow += n;\n+                } else {\n+                    iLow += n;\n+                }\n+                index -= n2;\n+                direct = !direct;\n+                break;\n+            case 2 :\n+                if (direct) {\n+                    iLow += n;\n+                    jLow += n;\n+                }\n+                index -= 2 * n2;\n+                direct = !direct;\n+                break;\n+            default :\n+                if (direct) {\n+                    iLow += n;\n+                } else {\n+                    jLow += n;\n+                }\n+            index -= 3 * n2;\n+            }\n+\n+        }\n+\n+        // the lowest indices of the remaining 1x1 quadrant are the requested indices\n+        return (((long) iLow) << 32) | (long) jLow;\n+\n+    }\n+\n+    /**\n+     * Compute the power of two number of tiles for a matrix.\n+     * @param rows number of rows\n+     * @param columns number of columns\n+     * @return power of two number of tiles\n+     */\n+    private static int tilesNumber(final int rows, final int columns) {\n+\n+        // find the minimal number of tiles, given that one double variable is 8 bytes\n+        final int nbElements         = rows * columns;\n+        final int maxElementsPerTile = MAX_TILE_SIZE_BYTES / 8;\n+        final int minTiles           = nbElements / maxElementsPerTile;\n+\n+        // the number of tiles must be a 2^k x 2^k square\n+        int twoK = 1;\n+        for (int nTiles = minTiles; nTiles != 0; nTiles >>= 2) {\n+            twoK <<= 1;\n+        }\n+\n+        // make sure the tiles have at least one row and one column each\n+        // (this may lead to tile sizes greater than MAX_BLOCK_SIZE_BYTES,\n+        //  in degenerate cases like a 3000x1 matrix)\n+        while (twoK > Math.min(rows, columns)) {\n+            twoK >>= 1;\n+        }\n+\n+        return twoK;\n+\n+    }\n+\n+    /**\n+     * Compute optimal tile size for a row or column count.\n+     * @param count row or column count\n+     * @param twoK optimal tile number (must be a power of 2)\n+     * @return optimal tile size\n+     */\n+    private static int tileSize(final int count, final int twoK) {\n+        return (count + twoK - 1) / twoK;        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/experimental/org/apache/commons/math/linear/RecursiveLayoutRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link RecursiveLayoutRealMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class RecursiveLayoutRealMatrixTest extends TestCase {\n+\n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public RecursiveLayoutRealMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {\n+        \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RecursiveLayoutRealMatrixTest.class);\n+        suite.setName(\"RecursiveLayoutRealMatrix Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        RecursiveLayoutRealMatrix m1 = createRandomMatrix(r, 47, 83);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(m1.getData());\n+        assertEquals(m1, m2);\n+        RecursiveLayoutRealMatrix m3 = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m4 = new RecursiveLayoutRealMatrix(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix mInv = new RecursiveLayoutRealMatrix(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testDataInv);\n+        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        \n+        try {\n+            m.subtract(new RecursiveLayoutRealMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix mInv = new RecursiveLayoutRealMatrix(testDataInv);\n+        RecursiveLayoutRealMatrix identity = new RecursiveLayoutRealMatrix(id);\n+        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);\n+        assertClose(m.multiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.multiply(m), identity, entryTolerance);\n+        assertClose(m.multiply(identity), m, entryTolerance);\n+        assertClose(identity.multiply(mInv), mInv, entryTolerance);\n+        assertClose(m2.multiply(identity), m2, entryTolerance); \n+        try {\n+            m.multiply(new RecursiveLayoutRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        RealMatrix m = new RecursiveLayoutRealMatrix(35, 71);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, i + j / 1024.0);\n+            }\n+        }\n+\n+        RealMatrix mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum += (k + i / 1024.0) * (k + j / 1024.0);\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum += (i + k / 1024.0) * (j + k / 1024.0);\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for RecursiveLayoutRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new RecursiveLayoutRealMatrix(d3);   \n+       RealMatrix m4 = new RecursiveLayoutRealMatrix(d4);\n+       RealMatrix m5 = new RecursiveLayoutRealMatrix(d5);\n+       assertClose(m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new RecursiveLayoutRealMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        assertClose(new RecursiveLayoutRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(id);\n+        assertClose(testVector, m.operate(testVector), entryTolerance);\n+        assertClose(testVector, m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);\n+        m = new RecursiveLayoutRealMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+\n+    public void testMultiplyMedium() {\n+        RealMatrix m1 = new RecursiveLayoutRealMatrix(\n+                new double[][] {\n+                        {  80,  45,  13,  77, -82 },\n+                        { -90,  33,  98,  80,  74 },\n+                        {  24, -37,  36,  -8, -69 },\n+                        { -74,   2,  32, -67, -65 },\n+                        { -29, -81,  44,  54, -65 },\n+                        {  17,  58, -36, -98,  25 },\n+                        {  48, -64, -95, -75,  34 }\n+                });\n+        RealMatrix m2 = new RecursiveLayoutRealMatrix(\n+                new double[][] {\n+                        {  81,  58,  70,  18,   5, -57 },\n+                        { -54,  33,  87,  68, -22,  73 },\n+                        { -78,  -5,  34,  -7,  -3, -31 },\n+                        { -16, -82, -68,   7,  10, -47 },\n+                        {  51,   4,  92,  15,  32, -51 }\n+                });\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        RealMatrix reference = new RecursiveLayoutRealMatrix(\n+                new double[][]{\n+                        {  -2378,   -582,  -2823,  3718, -2483, -1115 },\n+                        { -14222, -10885,   1271,  1608,  1698, -3033 },\n+                        {  -2257,    371,  -6119, -3427, -1462, -1290 },\n+                        { -10841,    848,  -5342, -2864, -3260,  9836 },\n+                        {  -5586,  -9263, -17233, -6935,   -35, -4847 },\n+                        {   3896,  11216,  13976,  4191, -1263,  7712 },\n+                        {  17688,   7433,   2790, -2838,  2271, -2672 }\n+                 });\n+        assertEquals(0, m1m2.subtract(reference).getNorm(), 0.0);\n+    }\n+\n+    public void testOperateLarge() {\n+        int testBlockSize = 64;\n+        int p = (7 * testBlockSize) / 2;\n+        int q = (5 * testBlockSize) / 2;\n+        int r =  3 * testBlockSize;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int testBlockSize = 64;\n+        int p = (7 * testBlockSize) / 2;\n+        int q = (5 * testBlockSize) / 2;\n+        int r =  3 * testBlockSize;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new RecursiveLayoutRealMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        });\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        assertClose(mIT, mTI, normTolerance);\n+        m = new RecursiveLayoutRealMatrix(testData2);\n+        RealMatrix mt = new RecursiveLayoutRealMatrix(testData2T);\n+        assertClose(mt, m.transpose(), normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);\n+        assertClose(m.preMultiply(new RealVectorImpl(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new RecursiveLayoutRealMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new RecursiveLayoutRealMatrix(d3);   \n+        RealMatrix m4 = new RecursiveLayoutRealMatrix(d4);\n+        RealMatrix m5 = new RecursiveLayoutRealMatrix(d5);\n+        assertClose(m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix mInv = new RecursiveLayoutRealMatrix(testDataInv);\n+        RecursiveLayoutRealMatrix identity = new RecursiveLayoutRealMatrix(id);\n+        assertClose(m.preMultiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.preMultiply(m), identity, entryTolerance);\n+        assertClose(m.preMultiply(identity), m, entryTolerance);\n+        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);\n+        try {\n+            m.preMultiply(new RecursiveLayoutRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        assertClose(m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new RecursiveLayoutRealMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new RecursiveLayoutRealMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new RecursiveLayoutRealMatrix(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new RecursiveLayoutRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new RecursiveLayoutRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        RealMatrix sub = new RecursiveLayoutRealMatrix(n - 4, n - 4).scalarAdd(1);\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    public void testCopySubMatrix() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                             new double[1][1] :\n+                             new double[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new RecursiveLayoutRealMatrix(reference), new RecursiveLayoutRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                    new double[1][1] :\n+                    new double[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new RecursiveLayoutRealMatrix(reference), new RecursiveLayoutRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m     = new RecursiveLayoutRealMatrix(subTestData);\n+        RealMatrix mRow0 = new RecursiveLayoutRealMatrix(subRow0);\n+        RealMatrix mRow3 = new RecursiveLayoutRealMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowMatrix() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealMatrix mRow3 = new RecursiveLayoutRealMatrix(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        RealMatrix sub = new RecursiveLayoutRealMatrix(1, n).scalarAdd(1);\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new RecursiveLayoutRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new RecursiveLayoutRealMatrix(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new RecursiveLayoutRealMatrix(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        RealMatrix sub = new RecursiveLayoutRealMatrix(n, 1).scalarAdd(1);\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n+    public void testGetRowVector() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new RealVectorImpl(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        RealVector sub = new RealVectorImpl(n, 1.0);\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new RealVectorImpl(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        RealVector sub = new RealVectorImpl(n, 1.0);\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new RealVectorImpl(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnLarge() {\n+        int n = 3 * 64;\n+        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i], 1.0e-9 * Math.abs(expected[i]));            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        RecursiveLayoutRealMatrix m1 = (RecursiveLayoutRealMatrix) m.copy();\n+        RecursiveLayoutRealMatrix mt = (RecursiveLayoutRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new RecursiveLayoutRealMatrix(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        assertEquals(\"RecursiveLayoutRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = new RecursiveLayoutRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new RecursiveLayoutRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new RecursiveLayoutRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        RecursiveLayoutRealMatrix matrix = new RecursiveLayoutRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n+        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n+        expected = new RecursiveLayoutRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RecursiveLayoutRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+    \n+    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n+        private static final long serialVersionUID = 1773444180892369386L;\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n+        private static final long serialVersionUID = -7745543227178932689L;\n+        private int count = 0;\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    };\n+\n+    //--------------- -----------------Protected methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {\n+        assertTrue(m.subtract(n).getNorm() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(double[] m, double[] n, double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(m[i], n[i], tolerance);\n+        }\n+    }\n+\n+    private RecursiveLayoutRealMatrix createRandomMatrix(Random r, int rows, int columns) {\n+        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                m.setEntry(i, j, 200 * r.nextDouble() - 100);\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+", "timestamp": 1234535928, "metainfo": ""}