{"sha": "0e86e9253ee4b04e622ee0e63e891199cc00ad98", "log": "Removed trailing spaces.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n      * @return lower bound of the support (might be Double.NEGATIVE_INFINITY)\n      */\n     public abstract double getSupportLowerBound();\n-    \n+\n     /**\n      * Access the upper bound of the support.\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n \n     /** Cached numerical mean */\n     private double numericalMean = Double.NaN;\n-    \n+\n     /** Whether or not the numerical mean has been calculated */\n     private boolean numericalMeanIsCalculated = false;\n \n     /** Cached numerical variance */\n     private double numericalVariance = Double.NaN;\n-    \n+\n     /** Whether or not the numerical variance has been calculated */\n     private boolean numericalVarianceIsCalculated = false;\n-    \n+\n     /**\n      * Default constructor.\n      */\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n-    \n+\n     /**\n-     * Use this method to actually calculate the mean for the \n-     * specific distribution. Use {@link #getNumericalMean()} \n+     * Use this method to actually calculate the mean for the\n+     * specific distribution. Use {@link #getNumericalMean()}\n      * (which implements caching) to actually get the mean.\n-     * \n+     *\n      * @return the mean or Double.NaN if it's not defined\n      */\n     protected abstract double calculateNumericalMean();\n-    \n+\n     /**\n-     * Use this method to get the numerical value of the mean of this \n+     * Use this method to get the numerical value of the mean of this\n      * distribution.\n      *\n      * @return the mean or Double.NaN if it's not defined\n \n         return numericalMean;\n     }\n-    \n+\n     /**\n-     * Use this method to actually calculate the variance for the \n-     * specific distribution.  Use {@link #getNumericalVariance()} \n-     * (which implements caching) to actually get the variance. \n+     * Use this method to actually calculate the variance for the\n+     * specific distribution.  Use {@link #getNumericalVariance()}\n+     * (which implements caching) to actually get the variance.\n      *\n      * @return the variance or Double.NaN if it's not defined\n      */\n     protected abstract double calculateNumericalVariance();\n-    \n+\n     /**\n-     * Use this method to get the numerical value of the variance of this \n+     * Use this method to get the numerical value of the variance of this\n      * distribution.\n      *\n-     * @return the variance (possibly Double.POSITIVE_INFINITY as \n-     * for certain cases in {@link TDistributionImpl}) or \n+     * @return the variance (possibly Double.POSITIVE_INFINITY as\n+     * for certain cases in {@link TDistributionImpl}) or\n      * Double.NaN if it's not defined\n      */\n     public double getNumericalVariance() {\n             numericalVariance = calculateNumericalVariance();\n             numericalVarianceIsCalculated = true;\n         }\n-        \n+\n         return numericalVariance;\n-    }    \n-    \n+    }\n+\n     /**\n-     * Use this method to get information about whether the lower bound \n+     * Use this method to get information about whether the lower bound\n      * of the support is inclusive or not.\n      *\n      * @return whether the lower bound of the support is inclusive or not\n      */\n     public abstract boolean isSupportLowerBoundInclusive();\n-    \n+\n     /**\n-     * Use this method to get information about whether the upper bound \n+     * Use this method to get information about whether the upper bound\n      * of the support is inclusive or not.\n      *\n      * @return whether the upper bound of the support is inclusive or not\n      */\n-    public abstract boolean isSupportUpperBoundInclusive();    \n-    \n+    public abstract boolean isSupportUpperBoundInclusive();\n+\n     /**\n-     * Use this method to get information about whether the support is connected, \n+     * Use this method to get information about whether the support is connected,\n      * i.e. whether all values between the lower and upper bound of the support\n      * is included in the support.\n-     * \n+     *\n      * For {@link AbstractIntegerDistribution} the support is discrete, so\n-     * if this is true, then the support is \n+     * if this is true, then the support is\n      * {lower bound, lower bound + 1, ..., upper bound}.\n-     * \n+     *\n      * For {@link AbstractContinuousDistribution} the support is continuous, so\n      * if this is true, then the support is the interval\n      * [lower bound, upper bound]\n-     * where the limits are inclusive or not according to \n-     * {@link #isSupportLowerBoundInclusive()} and {@link #isSupportUpperBoundInclusive()} \n+     * where the limits are inclusive or not according to\n+     * {@link #isSupportLowerBoundInclusive()} and {@link #isSupportUpperBoundInclusive()}\n      * (in the example both are true). If both are false, then the support is the interval\n      * (lower bound, upper bound)\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n      * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     protected abstract int getDomainUpperBound(double p);\n-    \n+\n     /**\n      * Access the lower bound of the support.\n      *\n      * @return lower bound of the support (Integer.MIN_VALUE for negative infinity)\n      */\n     public abstract int getSupportLowerBound();\n-    \n+\n     /**\n      * Access the upper bound of the support.\n      *\n      * @return upper bound of the support (Integer.MAX_VALUE for positive infinity)\n      */\n     public abstract int getSupportUpperBound();\n-    \n-    /**\n-     * Use this method to get information about whether the lower bound \n+\n+    /**\n+     * Use this method to get information about whether the lower bound\n      * of the support is inclusive or not. For discrete support,\n      * only true here is meaningful.\n      *\n-     * @return true (always but at Integer.MIN_VALUE because of the nature of discrete support) \n+     * @return true (always but at Integer.MIN_VALUE because of the nature of discrete support)\n      */\n     @Override\n     public boolean isSupportLowerBoundInclusive() {\n         return true;\n     }\n-    \n-    /**\n-     * Use this method to get information about whether the upper bound \n+\n+    /**\n+     * Use this method to get information about whether the upper bound\n      * of the support is inclusive or not. For discrete support,\n      * only true here is meaningful.\n      *\n-     * @return true (always but at Integer.MAX_VALUE because of the nature of discrete support) \n+     * @return true (always but at Integer.MAX_VALUE because of the nature of discrete support)\n      */\n     @Override\n     public boolean isSupportUpperBoundInclusive() {\n         return true;\n-    }    \n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 0 no matter the parameters.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The upper bound of the support is always 1 no matter the parameters.\n      *\n      * @return upper bound of the support (always 1)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For first shape parameter <code>s1</code> and \n+     *\n+     * For first shape parameter <code>s1</code> and\n      * second shape parameter <code>s2</code>, the mean is\n      * <code>s1 / (s1 + s2)</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For first shape parameter <code>s1</code> and \n-     * second shape parameter <code>s2</code>, \n+     *\n+     * For first shape parameter <code>s1</code> and\n+     * second shape parameter <code>s2</code>,\n      * the variance is\n      * <code>[ s1 * s2 ] / [ (s1 + s2)^2 * (s1 + s2 + 1) ]</code>\n      *\n     @Override\n     protected double calculateNumericalVariance() {\n         final double a = getAlpha();\n-        final double b = getBeta();        \n+        final double b = getBeta();\n         final double alphabetasum = a + b;\n         return (a * b) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The lower bound of the support is always 0 no matter the number of trials \n+     *\n+     * The lower bound of the support is always 0 no matter the number of trials\n      * and probability parameter.\n      *\n      * @return lower bound of the support (always 0)\n     public int getSupportLowerBound() {\n         return 0;\n     }\n-    \n-    /**\n-     * {@inheritDoc}\n-     * \n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * The upper bound of the support is the number of trials.\n      *\n      * @return upper bound of the support (equal to number of trials)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For <code>n</code> number of trials and \n+     *\n+     * For <code>n</code> number of trials and\n      * probability parameter <code>p</code>, the mean is\n      * <code>n * p</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For <code>n</code> number of trials and \n+     *\n+     * For <code>n</code> number of trials and\n      * probability parameter <code>p</code>, the variance is\n      * <code>n * p * (1 - p)</code>\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n         }\n \n         return ret;\n-    }    \n+    }\n \n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The lower bound of the support is always negative infinity no matter \n+     *\n+     * The lower bound of the support is always negative infinity no matter\n      * the parameters.\n      *\n      * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity no matter \n+     *\n+     * The upper bound of the support is always positive infinity no matter\n      * the parameters.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The mean is always undefined no matter the parameters.\n      *\n      * @return mean (always Double.NaN)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The variance is always undefined no matter the parameters.\n      *\n      * @return variance (always Double.NaN)\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The lower bound of the support is always 0 no matter the \n+     *\n+     * The lower bound of the support is always 0 no matter the\n      * degrees of freedom.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity no matter the \n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n      * degrees of freedom.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For <code>k</code> degrees of freedom, the mean is\n      * <code>k</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For <code>k</code> degrees of freedom, the variance is\n      * <code>2 * k</code>\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n      * @throws IllegalArgumentException if <code>x0 > x1</code>\n      */\n     double cumulativeProbability(double x0, double x1) throws MathException;\n-    \n+\n     /**\n-     * Use this method to get the numerical value of the mean of this \n+     * Use this method to get the numerical value of the mean of this\n      * distribution.\n      *\n      * @return the mean or Double.NaN if it's not defined\n      */\n     double getNumericalMean();\n-    \n+\n     /**\n-     * Use this method to get the numerical value of the variance of this \n+     * Use this method to get the numerical value of the variance of this\n      * distribution.\n      *\n-     * @return the variance (possibly Double.POSITIVE_INFINITY as \n-     * for certain cases in {@link TDistributionImpl}) or \n+     * @return the variance (possibly Double.POSITIVE_INFINITY as\n+     * for certain cases in {@link TDistributionImpl}) or\n      * Double.NaN if it's not defined\n      */\n-    double getNumericalVariance(); \n-    \n+    double getNumericalVariance();\n+\n     /**\n-     * Use this method to get information about whether the lower bound \n+     * Use this method to get information about whether the lower bound\n      * of the support is inclusive or not.\n      *\n      * @return whether the lower bound of the support is inclusive or not\n      */\n     boolean isSupportLowerBoundInclusive();\n-    \n+\n     /**\n-     * Use this method to get information about whether the upper bound \n+     * Use this method to get information about whether the upper bound\n      * of the support is inclusive or not.\n      *\n      * @return whether the upper bound of the support is inclusive or not\n      */\n-    boolean isSupportUpperBoundInclusive();    \n-    \n+    boolean isSupportUpperBoundInclusive();\n+\n     /**\n-     * Use this method to get information about whether the support is connected, \n+     * Use this method to get information about whether the support is connected,\n      * i.e. whether all values between the lower and upper bound of the support\n      * is included in the support.\n-     * \n+     *\n      * For {@link AbstractIntegerDistribution} the support is discrete, so\n-     * if this is true, then the support is \n+     * if this is true, then the support is\n      * {lower bound, lower bound + 1, ..., upper bound}.\n-     * \n+     *\n      * For {@link AbstractContinuousDistribution} the support is continuous, so\n      * if this is true, then the support is the interval\n      * [lower bound, upper bound]\n-     * where the limits are inclusive or not according to \n-     * {@link #isSupportLowerBoundInclusive()} and {@link #isSupportUpperBoundInclusive()} \n+     * where the limits are inclusive or not according to\n+     * {@link #isSupportLowerBoundInclusive()} and {@link #isSupportUpperBoundInclusive()}\n      * (in the example both are true). If both are false, then the support is the interval\n      * (lower bound, upper bound)\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 0 no matter the mean parameter.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n+     *\n+     * The upper bound of the support is always positive infinity\n      * no matter the mean parameter.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For mean parameter <code>k</code>, the mean is\n      * <code>k</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For mean parameter <code>k</code>, the variance is\n      * <code>k^2</code>\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n-    \n-    /**\n-     * {@inheritDoc}\n-     * \n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * The lower bound of the support is always 0 no matter the parameters.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n+     *\n+     * The upper bound of the support is always positive infinity\n      * no matter the parameters.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For denominator degrees of freedom parameter <code>b</code>, \n+     *\n+     * For denominator degrees of freedom parameter <code>b</code>,\n      * the mean is\n      * <ul>\n      *  <li>if <code>b &gt; 2</code> then <code>b / (b - 2)</code></li>\n      * </ul>\n      *\n      * @return {@inheritDoc}\n-     */    \n-    @Override\n-    protected double calculateNumericalMean() {        \n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n         final double denominatorDF = getDenominatorDegreesOfFreedom();\n \n         if (denominatorDF > 2) {\n-            return denominatorDF / (denominatorDF - 2);     \n-        }\n-        \n+            return denominatorDF / (denominatorDF - 2);\n+        }\n+\n         return Double.NaN;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For numerator degrees of freedom parameter <code>a</code> \n-     * and denominator degrees of freedom parameter <code>b</code>, \n+     *\n+     * For numerator degrees of freedom parameter <code>a</code>\n+     * and denominator degrees of freedom parameter <code>b</code>,\n      * the variance is\n      * <ul>\n      *  <li>\n-     *    if <code>b &gt; 4</code> then \n+     *    if <code>b &gt; 4</code> then\n      *    <code>[ 2 * b^2 * (a + b - 2) ] / [ a * (b - 2)^2 * (b - 4) ]</code>\n      *  </li>\n      *  <li>else <code>undefined</code>\n         if (denominatorDF > 4) {\n             final double numeratorDF = getNumeratorDegreesOfFreedom();\n             final double denomDFMinusTwo = denominatorDF - 2;\n-            \n+\n             return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /\n                    ( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n         }\n-        \n-        return Double.NaN;        \n+\n+        return Double.NaN;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 0 no matter the parameters.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n+     *\n+     * The upper bound of the support is always positive infinity\n      * no matter the parameters.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For shape parameter <code>alpha</code> and scale \n+     *\n+     * For shape parameter <code>alpha</code> and scale\n      * parameter <code>beta</code>, the mean is\n      * <code>alpha * beta</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For shape parameter <code>alpha</code> and scale \n+     *\n+     * For shape parameter <code>alpha</code> and scale\n      * parameter <code>beta</code>, the variance is\n      * <code>alpha * beta^2</code>\n      *\n      */\n     @Override\n     protected double calculateNumericalVariance() {\n-        final double b = getBeta();        \n+        final double b = getBeta();\n         return getAlpha() * b * b;\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For population size <code>N</code>, \n-     * number of successes <code>m</code>, and \n-     * sample size <code>n</code>, \n+     *\n+     * For population size <code>N</code>,\n+     * number of successes <code>m</code>, and\n+     * sample size <code>n</code>,\n      * the lower bound of the support is\n      * <code>max(0, n + m - N)</code>\n      *\n      */\n     @Override\n     public int getSupportLowerBound() {\n-        return FastMath.max(0, \n+        return FastMath.max(0,\n                 getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For number of successes <code>m</code> and \n-     * sample size <code>n</code>, \n+     *\n+     * For number of successes <code>m</code> and\n+     * sample size <code>n</code>,\n      * the upper bound of the support is\n      * <code>min(m, n)</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For population size <code>N</code>, \n-     * number of successes <code>m</code>, and \n+     *\n+     * For population size <code>N</code>,\n+     * number of successes <code>m</code>, and\n      * sample size <code>n</code>, the mean is\n      * <code>n * m / N</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For population size <code>N</code>, \n-     * number of successes <code>m</code>, and \n+     *\n+     * For population size <code>N</code>,\n+     * number of successes <code>m</code>, and\n      * sample size <code>n</code>, the variance is\n      * <code>[ n * m * (N - n) * (N - m) ] / [ N^2 * (N - 1) ]</code>\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The lower bound of the support is always negative infinity \n+     *\n+     * The lower bound of the support is always negative infinity\n      * no matter the parameters.\n      *\n      * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n+     *\n+     * The upper bound of the support is always positive infinity\n      * no matter the parameters.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For mean parameter <code>mu</code>, the mean is <code>mu</code>\n      *\n      * @return {@inheritDoc}\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For standard deviation parameter <code>s</code>, \n+     *\n+     * For standard deviation parameter <code>s</code>,\n      * the variance is <code>s^2</code>\n      *\n      * @return {@inheritDoc}\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 0 no matter the parameters.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n-     * no matter the parameters. Positive infinity is symbolised \n-     * by <code>Integer.MAX_VALUE</code> together with \n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters. Positive infinity is symbolised\n+     * by <code>Integer.MAX_VALUE</code> together with\n      * {@link #isSupportUpperBoundInclusive()} being <code>false</code>\n      *\n      * @return upper bound of the support (always <code>Integer.MAX_VALUE</code> for positive infinity)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For number of successes <code>r</code> and \n+     *\n+     * For number of successes <code>r</code> and\n      * probability of success <code>p</code>, the mean is\n      * <code>( r * p ) / ( 1 - p )</code>\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * For number of successes <code>r</code> and \n+     *\n+     * For number of successes <code>r</code> and\n      * probability of success <code>p</code>, the mean is\n      * <code>( r * p ) / ( 1 - p )^2</code>\n      *\n         final double pInv = 1 - p;\n         return ( r * p ) / (pInv * pInv);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 0 no matter the mean parameter.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is positive infinity, \n-     * regardless of the parameter values. There is no integer infinity, \n+     *\n+     * The upper bound of the support is positive infinity,\n+     * regardless of the parameter values. There is no integer infinity,\n      * so this method returns <code>Integer.MAX_VALUE</code> and\n      * {@link #isSupportUpperBoundInclusive()} returns <code>true</code>.\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For mean parameter <code>p</code>, the mean is <code>p</code>\n      *\n      * @return {@inheritDoc}\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For mean parameter <code>p</code>, the variance is <code>p</code>\n      *\n      * @return {@inheritDoc}\n     protected double calculateNumericalVariance() {\n         return getMean();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The lower bound of the support is always negative infinity \n+     *\n+     * The lower bound of the support is always negative infinity\n      * no matter the parameters.\n      *\n      * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n+     *\n+     * The upper bound of the support is always positive infinity\n      * no matter the parameters.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For degrees of freedom parameter df, the mean is\n      * <ul>\n      *  <li>if <code>df &gt; 1</code> then <code>0</code></li>\n     @Override\n     protected double calculateNumericalMean() {\n         final double df = getDegreesOfFreedom();\n-        \n+\n         if (df > 1) {\n             return 0;\n         }\n-        \n-        return Double.NaN;        \n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     * \n+\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * For degrees of freedom parameter df, the variance is\n      * <ul>\n      *  <li>if <code>df &gt; 2</code> then <code>df / (df - 2)</code> </li>\n      */\n     @Override\n     protected double calculateNumericalVariance() {\n-        final double df = getDegreesOfFreedom();        \n+        final double df = getDegreesOfFreedom();\n \n         if (df > 2) {\n             return df / (df - 2);\n         if (df > 1 && df <= 2) {\n             return Double.POSITIVE_INFINITY;\n         }\n-        \n+\n         return Double.NaN;\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 0 no matter the parameters.\n      *\n      * @return lower bound of the support (always 0)\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The upper bound of the support is always positive infinity \n+     *\n+     * The upper bound of the support is always positive infinity\n      * no matter the parameters.\n      *\n      * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The mean is <code>scale * Gamma(1 + (1 / shape))</code>\n      * where <code>Gamma(...)</code> is the Gamma-function\n      *\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * The variance is \n-     * <code>scale^2 * Gamma(1 + (2 / shape)) - mean^2</code> \n+     *\n+     * The variance is\n+     * <code>scale^2 * Gamma(1 + (2 / shape)) - mean^2</code>\n      * where <code>Gamma(...)</code> is the Gamma-function\n      *\n      * @return {@inheritDoc}\n         final double sc = getScale();\n         final double mn = getNumericalMean();\n \n-        return (sc * sc) * \n+        return (sc * sc) *\n             FastMath.exp(Gamma.logGamma(1 + (2 / sh))) -\n             (mn * mn);\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The lower bound of the support is always 1 no matter the parameters.\n      *\n      * @return lower bound of the support (always 1)\n      */\n     @Override\n-    public int getSupportLowerBound() {        \n+    public int getSupportLowerBound() {\n         return 1;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The upper bound of the support is the number of elements\n      *\n      * @return upper bound of the support\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For number of elements N and exponent s, the mean is\n-     * <code>Hs1 / Hs</code> where \n+     * <code>Hs1 / Hs</code> where\n      * <ul>\n-     *  <li><code>Hs1 = generalizedHarmonic(N, s - 1)</code></li> \n+     *  <li><code>Hs1 = generalizedHarmonic(N, s - 1)</code></li>\n      *  <li><code>Hs = generalizedHarmonic(N, s)</code></li>\n      * </ul>\n      *\n     protected double calculateNumericalMean() {\n         final int N = getNumberOfElements();\n         final double s = getExponent();\n-        \n+\n         final double Hs1 = generalizedHarmonic(N, s - 1);\n         final double Hs = generalizedHarmonic(N, s);\n \n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * For number of elements N and exponent s, the mean is\n-     * <code>(Hs2 / Hs) - (Hs1^2 / Hs^2)</code> where \n+     * <code>(Hs2 / Hs) - (Hs1^2 / Hs^2)</code> where\n      * <ul>\n      *  <li><code>Hs2 = generalizedHarmonic(N, s - 2)</code></li>\n-     *  <li><code>Hs1 = generalizedHarmonic(N, s - 1)</code></li> \n+     *  <li><code>Hs1 = generalizedHarmonic(N, s - 1)</code></li>\n      *  <li><code>Hs = generalizedHarmonic(N, s)</code></li>\n      * </ul>\n-     * \n+     *\n      * @return {@inheritDoc}\n      */\n     @Override\n     protected double calculateNumericalVariance() {\n         final int N = getNumberOfElements();\n         final double s = getExponent();\n-        \n+\n         final double Hs2 = generalizedHarmonic(N, s - 2);\n         final double Hs1 = generalizedHarmonic(N, s - 1);\n         final double Hs = generalizedHarmonic(N, s);\n--- a/src/main/java/org/apache/commons/math/special/Erf.java\n+++ b/src/main/java/org/apache/commons/math/special/Erf.java\n      * <p>This implementation computes erf(x) using the\n      * {@link Gamma#regularizedGammaP(double, double, double, int) regularized gamma function},\n      * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3)</p>\n-     * \n+     *\n      * <p>The value returned is always between -1 and 1 (inclusive).  If {@code abs(x) > 40}, then\n      * {@code erf(x)} is indistinguishable from either 1 or -1 as a double, so the appropriate extreme\n      * value is returned.</p>\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * <p>Returns the complementary error function</p>\n      * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt <br/>\n      * <p>This implementation computes erfc(x) using the\n      * {@link Gamma#regularizedGammaQ(double, double, double, int) regularized gamma function},\n      * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3).</p>\n-     * \n+     *\n      * <p>The value returned is always between 0 and 2 (inclusive).  If {@code abs(x) > 40}, then\n      * {@code erf(x)} is indistinguishable from either 0 or 2 as a double, so the appropriate extreme\n      * value is returned.</p>\n-     * \n+     *\n      * @param x the value\n      * @return the complementary error function erfc(x)\n      * @throws MathException if the algorithm fails to converge\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n \n     /**\n      * Returns the number of values in the frequency table.\n-     * \n+     *\n      * @return the number of unique values that have been added to the frequency table.\n-     * @see #valuesIterator() \n+     * @see #valuesIterator()\n      */\n     public int getUniqueCount(){\n     \treturn freqTable.keySet().size();\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n     /**\n      * Construct a DescriptiveStatistics instance with an infinite window\n      * and the initial data values in double[] initialDoubleArray.\n-     * If initialDoubleArray is null, then this constructor corresponds to \n+     * If initialDoubleArray is null, then this constructor corresponds to\n      * DescriptiveStatistics()\n      *\n      * @param initialDoubleArray the initial double[].\n             eDA = new ResizableDoubleArray(initialDoubleArray);\n     \t}\n     }\n-    \n+\n     /**\n      * Copy constructor.  Construct a new DescriptiveStatistics instance that\n      * is a copy of original.\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n         result = result * 31 + MathUtils.hash(getVariance());\n         return result;\n     }\n-    \n+\n     /**\n      * Generates a text report displaying values of statistics.\n      * Each statistic is displayed on a separate line.\n--- a/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTest.java\n \n /**\n  * An interface for Mann-Whitney U test (also called Wilcoxon rank-sum test).\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface MannWhitneyUTest {\n      * <li>The observations are at least ordinal (continuous are also ordinal).</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n      * <li>The observations are at least ordinal (continuous are also ordinal).</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n--- a/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTestImpl.java\n /**\n  * An implementation of the Mann-Whitney U test (also called Wilcoxon rank-sum\n  * test).\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class MannWhitneyUTestImpl implements MannWhitneyUTest {\n     /**\n      * Create a test instance using the given strategies for NaN's and ties.\n      * Only use this if you are sure of what you are doing.\n-     * \n+     *\n      * @param nanStrategy\n      *            specifies the strategy that should be used for Double.NaN's\n      * @param tiesStrategy\n \n     /**\n      * Ensures that the provided arrays fulfills the assumptions.\n-     * \n+     *\n      * @param x\n      * @param y\n      * @throws IllegalArgumentException\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n      */\n     private double calculateAsymptoticPValue(final double Umin, final int n1,\n             final int n2) throws MathException {\n-        \n+\n         final int n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n      * Ties give rise to biased variance at the moment. See e.g. <a\n      * href=\"http://mlsc.lboro.ac.uk/resources/statistics/Mannwhitney.pdf\"\n      * >http://mlsc.lboro.ac.uk/resources/statistics/Mannwhitney.pdf</a>.\n-     * \n+     *\n      * {@inheritDoc}\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n             throws IllegalArgumentException, MathException {\n \n         ensureDataConformance(x, y);\n-        \n+\n         final double Umax = mannWhitneyU(x, y);\n-        \n+\n         /*\n          * It can be shown that U1 + U2 = n1 * n2\n          */\n-        final double Umin = x.length * y.length - Umax; \n+        final double Umin = x.length * y.length - Umax;\n \n         return calculateAsymptoticPValue(Umin, x.length, y.length);\n     }\n--- a/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTest.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTest.java\n \n /**\n  * An interface for Wilcoxon signed-rank test.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface WilcoxonSignedRankTest {\n      * meaningful.</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n      * meaningful.</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n--- a/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestImpl.java\n \n /**\n  * An implementation of the Wilcoxon signed-rank test.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class WilcoxonSignedRankTestImpl implements WilcoxonSignedRankTest {\n     /**\n      * Create a test instance using the given strategies for NaN's and ties.\n      * Only use this if you are sure of what you are doing.\n-     * \n+     *\n      * @param nanStrategy\n      *            specifies the strategy that should be used for Double.NaN's\n      * @param tiesStrategy\n \n     /**\n      * Ensures that the provided arrays fulfills the assumptions.\n-     * \n+     *\n      * @param x\n      * @param y\n      * @throws IllegalArgumentException\n \n     /**\n      * Calculates y[i] - x[i] for all i\n-     * \n+     *\n      * @param x\n      * @param y\n      * @throws IllegalArgumentException\n \n     /**\n      * Calculates |z[i]| for all i\n-     * \n+     *\n      * @param z\n      * @throws IllegalArgumentException\n      *             if assumptions are not met\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n      */\n     public double wilcoxonSignedRank(final double[] x, final double[] y)\n             throws IllegalArgumentException {\n-        \n+\n         ensureDataConformance(x, y);\n \n         // throws IllegalArgumentException if x and y are not correctly\n     /**\n      * Algorithm inspired by\n      * http://www.fon.hum.uva.nl/Service/Statistics/Signed_Rank_Algorihms.html#C\n-     * by Rob van Son, Institute of Phonetic Sciences & IFOTT, \n+     * by Rob van Son, Institute of Phonetic Sciences & IFOTT,\n      * University of Amsterdam\n-     * \n+     *\n      * @param Wmax largest Wilcoxon signed rank value\n      * @param N number of subjects (corresponding to x.length)\n-     * @return two-sided exact p-value \n+     * @return two-sided exact p-value\n      */\n     private double calculateExactPValue(final double Wmax, final int N) {\n \n          */\n         return 2 * ((double) largerRankSums) / ((double) m);\n     }\n-    \n+\n     /**\n      * @param Wmin smallest Wilcoxon signed rank value\n      * @param N number of subjects (corresponding to x.length)\n-     * @return two-sided asymptotic p-value \n+     * @return two-sided asymptotic p-value\n      * @throws MathException if an error occurs computing the p-value\n      */\n     private double calculateAsymptoticPValue(final double Wmin, final int N) throws MathException {\n-        \n+\n         final double ES = (double) (N * (N + 1)) / 4.0;\n-        \n-        /* Same as (but saves computations): \n+\n+        /* Same as (but saves computations):\n          * final double VarW = ((double) (N * (N + 1) * (2*N + 1))) / 24;\n          */\n         final double VarS = ES * ((double) (2 * N + 1) / 6.0);\n-        \n+\n         // - 0.5 is a continuity correction\n         final double z = (Wmin - ES - 0.5) / FastMath.sqrt(VarS);\n \n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * @param x\n      *            the first sample\n      * @param y\n     public double wilcoxonSignedRankTest(final double[] x, final double[] y,\n             boolean exactPValue) throws IllegalArgumentException,\n             MathException {\n-        \n+\n         ensureDataConformance(x, y);\n \n         final int N = x.length;\n         final double Wmax = wilcoxonSignedRank(x, y);\n-        \n+\n         if (exactPValue && N > 30) {\n             throw new IllegalArgumentException(\"Exact test can only be made for N <= 30.\");\n         }\n-        \n+\n         if (exactPValue) {\n             return calculateExactPValue(Wmax, N);\n         } else {\n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n             numElements = initialArray.length;\n         }\n     }\n-    \n+\n     /**\n      * <p>\n      * Create a ResizableArray with the specified initial capacity\n             contract();\n         }\n     }\n-    \n+\n     /**\n      * Adds several element to the end of this expandable array.\n      *", "timestamp": 1295367867, "metainfo": ""}