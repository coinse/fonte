{"sha": "d07f552a2b13801bdef5b5a0b8d213fba7342b0a", "log": "Add working equals to SparseRealVector.  hashCode implementation is minimal, but I can't see a use case for using a SparseRealVector as a key.  Remove unused imports from OpenInToDoubleHashMap.  Some cleanup for optimized methods, and javadoc fixes.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n \n /**\n- * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap}.\n+ * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n  * @version $Revision: 728186 $ $Date$\n  * @since 2.0\n */\n      * Optimized method to add two SparseRealVectors\n      * @param v Vector to add with\n      * @return The sum of <code>this</code> with <code>v</code>\n-     */\n-    public SparseRealVector add(SparseRealVector v) {\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public SparseRealVector add(SparseRealVector v) throws IllegalArgumentException{\n         checkVectorDimensions(v.getDimension());\n-        SparseRealVector res = (SparseRealVector) copy();\n-        Iterator iter = res.getEntries().iterator();\n+        SparseRealVector res = (SparseRealVector)copy();\n+        Iterator iter = v.getEntries().iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             int key = iter.key();\n-            if (v.getEntries().containsKey(key)) {\n-                res.setEntry(key, iter.value() + v.getEntry(key));\n-            }\n-        }\n-        iter = v.getEntries().iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            int key = iter.key();\n-            if (!entries.containsKey(key)) {\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key) + iter.value());\n+            } else {\n                 res.setEntry(key, iter.value());\n             }\n         }\n      * Optimized method to compute distance\n      * @param v The vector to compute distance to\n      * @return The distance from <code>this</code> and <code>v</code>\n-     */\n-    public double getDistance(SparseRealVector v) {\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public double getDistance(SparseRealVector v) throws IllegalArgumentException {\n         Iterator iter = entries.iterator();\n         double res = 0;\n         while (iter.hasNext()) {\n      * Optimized method to compute the outer product\n      * @param v The vector to comput the outer product on\n      * @return The outer product of <code>this</code> and <code>v</code>\n-     */\n-    public SparseRealMatrix outerproduct(SparseRealVector v){\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public SparseRealMatrix outerproduct(SparseRealVector v) throws IllegalArgumentException{\n         checkVectorDimensions(v.getDimension());\n         SparseRealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);\n         Iterator iter = entries.iterator();\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public SparseRealVector subtract(SparseRealVector v) {\n+    /**\n+     * Optimized method to subtract SparseRealVectors\n+     * @param v The vector to subtract from <code>this</code>\n+     * @return The difference of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public SparseRealVector subtract(SparseRealVector v) throws IllegalArgumentException{\n         checkVectorDimensions(v.getDimension());\n-        SparseRealVector res = new SparseRealVector(this);\n+        SparseRealVector res = (SparseRealVector)copy();\n         Iterator iter = v.getEntries().iterator();\n-        OpenIntToDoubleHashMap values = res.getEntries();\n         while (iter.hasNext()) {\n             iter.advance();\n             int key = iter.key();\n             if (entries.containsKey(key)) {\n-                values.put(key, entries.get(key) - iter.value());\n+                res.setEntry(key, entries.get(key) - iter.value());\n             } else {\n-                values.put(key, -iter.value());\n+                res.setEntry(key, -iter.value());\n             }\n         }\n         return res;\n         return getData();\n     }\n \n+    /* (non-Javadoc)\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        long temp;\n+        temp = Double.doubleToLongBits(epsilon);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        result = prime * result + virtualSize;\n+        return result;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (!(obj instanceof SparseRealVector))\n+            return false;\n+        SparseRealVector other = (SparseRealVector) obj;\n+        if (virtualSize != other.virtualSize)\n+            return false;\n+        if (Double.doubleToLongBits(epsilon) != Double\n+                .doubleToLongBits(other.epsilon))\n+            return false;\n+        Iterator iter = entries.iterator();\n+        while(iter.hasNext()){\n+            iter.advance();\n+            double test = iter.value() - other.getEntry(iter.key());\n+            if(Math.abs(test) > epsilon)\n+                return false;\n+        }\n+        iter = other.getEntries().iterator();\n+        while(iter.hasNext()){\n+            iter.advance();\n+            double test = iter.value() - getEntry(iter.key());\n+            if(!isZero(test))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.Serializable;\n-import java.util.Arrays;\n import java.util.ConcurrentModificationException;\n import java.util.NoSuchElementException;\n \n         return h ^ (h >>> 7) ^ (h >>> 4);\n     }\n \n+    \n     /** Iterator class for the map. */\n     public class Iterator {\n \n         count = 0;\n     }\n \n-    \n+            \n }\n--- a/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n         v.setEntry(1, 1);\n         assertTrue(v.isInfinite());\n \n-        //TODO: backing store doesn't implement equals\n         //TODO: differeciate from resetting to zero\n-        //v.setEntry(0, 0);\n-        //assertEquals(v, new SparseRealVector(new double[] { 0, 1, 2 }));\n-        //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n-        //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2, 3 }));\n+        v.setEntry(0, 0);\n+        assertEquals(v, new SparseRealVector(new double[] { 0, 1, 2 }));\n+        assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2, 3 }));\n \n         //assertEquals(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n         //              new SparseRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());", "timestamp": 1234680375, "metainfo": ""}