{"sha": "44a04a5f899b700ad664548ba36e1535516bc664", "log": "fixed checkstyle warnings  ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/BetaDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/BetaDistribution.java\n /**\n  * Computes the cumulative, inverse cumulative and density functions for the beta distribuiton.\n  *\n- * See http://en.wikipedia.org/wiki/Beta_distribution\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">Beta_distribution</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n  */\n public interface BetaDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n       * Return the probability density for a particular point.\n       * @param x  The point at which the density should be computed.\n       * @return  The pdf at point x.\n+      * @exception MathException if probability density cannot be computed\n       */\n      double density(Double x) throws MathException;\n \n--- a/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n  * Beta distribution</a></li>\n  * </ul>\n  * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n  */\n public class BetaDistributionImpl\n     extends AbstractContinuousDistribution implements BetaDistribution {\n         z = Double.NaN;\n     }\n \n-    /**\n-     * Modify the shape parameter, alpha.\n-     *\n-     * @param alpha the new shape parameter.\n-     */\n+    /** {@inheritDoc} */\n     public void setAlpha(double alpha) {\n         this.alpha = alpha;\n         z = Double.NaN;\n     }\n \n-    /**\n-     * Access the shape parameter, alpha\n-     *\n-     * @return alpha.\n-     */\n+    /** {@inheritDoc} */\n     public double getAlpha() {\n         return alpha;\n     }\n \n-    /**\n-     * Modify the shape parameter, beta.\n-     *\n-     * @param beta the new scale parameter.\n-     */\n+    /** {@inheritDoc} */\n     public void setBeta(double beta) {\n         this.beta = beta;\n         z = Double.NaN;\n     }\n \n-    /**\n-     * Access the shape parameter, beta\n-     *\n-     * @return beta.\n-     */\n+    /** {@inheritDoc} */\n     public double getBeta() {\n         return beta;\n     }\n         }\n     }\n \n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     */\n+    /** {@inheritDoc} */\n     public double density(Double x) throws MathException {\n         recomputeZ();\n         if (x < 0 || x > 1) {\n         }\n     }\n \n-    /**\n-     * For this distribution, X, this method returns x such that P(X &lt; x) = p.\n-     *\n-     * @param p the cumulative probability.\n-     * @return x.\n-     * @throws org.apache.commons.math.MathException\n-     *          if the inverse cumulative probability can not be\n-     *          computed due to convergence or other numerical errors.\n-     */\n+    /** {@inheritDoc} */\n     public double inverseCumulativeProbability(double p) throws MathException {\n         if (p == 0) {\n             return 0;\n         }\n     }\n \n-    /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n-     */\n+    /** {@inheritDoc} */\n     protected double getInitialDomain(double p) {\n         return p;\n     }\n \n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n-     */\n+    /** {@inheritDoc} */\n     protected double getDomainLowerBound(double p) {\n         return 0;\n     }\n \n-    /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n-     */\n+    /** {@inheritDoc} */\n     protected double getDomainUpperBound(double p) {\n         return 1;\n     }\n \n-    /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X &le; x).  In other words,\n-     * this method represents the  (cumulative) distribution function, or\n-     * CDF, for this distribution.\n-     *\n-     * @param x the value at which the distribution function is evaluated.\n-     * @return the probability that a random variable with this\n-     *         distribution takes a value less than or equal to <code>x</code>\n-     * @throws org.apache.commons.math.MathException\n-     *          if the cumulative probability can not be\n-     *          computed due to convergence or other numerical errors.\n-     */\n+    /** {@inheritDoc} */\n     public double cumulativeProbability(double x) throws MathException {\n         if (x <= 0) {\n             return 0;\n         }\n     }\n \n-    /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     *\n-     * @param x0 the (inclusive) lower bound\n-     * @param x1 the (inclusive) upper bound\n-     * @return the probability that a random variable with this distribution\n-     *         will take a value between <code>x0</code> and <code>x1</code>,\n-     *         including the endpoints\n-     * @throws org.apache.commons.math.MathException\n-     *                                  if the cumulative probability can not be\n-     *                                  computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>x0 > x1</code>\n-     */\n+    /** {@inheritDoc} */\n     public double cumulativeProbability(double x0, double x1) throws MathException {\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n--- a/src/java/org/apache/commons/math/distribution/HasDensity.java\n+++ b/src/java/org/apache/commons/math/distribution/HasDensity.java\n /**\n  * Interface that signals that a distribution can compute the probability density function\n  * for a particular point.\n+ * @param <P> the type of the point at which density is to be computed, this\n+ * may be for example <code>Double</code>\n  * @version $Revision$ $Date$\n  */\n public interface HasDensity<P> {\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n+    /** &sqrt;(2 &pi;) */\n+    private static final double SQRT2PI = Math.sqrt(2 * Math.PI);\n+\n     /** The mean of this distribution. */\n     private double mean = 0;\n     \n     /** The standard deviation of this distribution. */\n     private double standardDeviation = 1;\n-    private static final double SQRT2PI = Math.sqrt(2 * Math.PI);\n \n     /**\n      * Create a normal distribution using the given mean and standard deviation.\n--- a/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n \n     /**\n      * Decompose a matrix.\n-     * @param matrix\n+     * @param matrix matrix to decompose\n      * @exception InvalidMatrixException if matrix does not fulfill\n      * the decomposition requirements (for example non-square matrix\n      * for {@link LUDecomposition})\n--- a/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n \n     /**\n      * Returns the i<sup>th</sup> eigenvalue of the original matrix.\n+     * @param i index of the eigenvalue (counting from 0)\n      * @return i<sup>th</sup> eigenvalue of the original matrix\n      * @exception IllegalStateException if {@link\n      * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n \n     /**\n      * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n+     * @param i index of the eigenvector (counting from 0)\n      * @return copy of the i<sup>th</sup> eigenvector of the original matrix\n      * @exception IllegalStateException if {@link\n      * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n--- a/src/java/org/apache/commons/math/linear/GershgorinCirclesUnion.java\n+++ b/src/java/org/apache/commons/math/linear/GershgorinCirclesUnion.java\n      * either circles union. It is mainly intended for circles unions\n      * that {@link #intersects(GershgorinCirclesUnion) intersect}\n      * each other beforehand.</p>\n+     * @param other Gershgorin circles union to swallow\n      */\n     public void swallow(final GershgorinCirclesUnion other) {\n         low  = Math.min(low,  other.low);\n         high = Math.max(high, other.high);\n     }\n \n-    /** Comparator class for sorting intervals. */\n+    /** Compare another Gershgorin circles union in interval start order.\n+     * @param other Gershgorin circles union to compare to instance\n+     * @return a negative, zero or positive value depending on the other\n+     * union starting before, at same location or after instance\n+     */\n     public int compareTo(GershgorinCirclesUnion other) {\n         return Double.compare(low, other.low);\n     }\n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n      * <p>The A matrix is implicit here. It is </p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X such that A &times; X = B\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n     public RealVectorImpl solve(RealVectorImpl b)\n         throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n \n     /**\n      * Decompose a matrix to find its largest singular values.\n-     * @param matrix\n+     * @param matrix matrix to decompose\n      * @param maxSingularValues maximal number of singular values to compute\n      * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n      * if algorithm fails to converge\n--- a/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n     /** Inverse of covariance matrix. */\n     private RealMatrix OmegaInverse;\n \n+    /** Replace sample data, overriding any previous sample.\n+     * @param y y values of the sample\n+     * @param x x values of the sample\n+     * @param covariance array representing the covariance matrix\n+     */\n     public void newSampleData(double[] y, double[][] x, double[][] covariance) {\n         validateSampleData(x, y);\n         newYSampleData(y);\n--- a/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n     /** Cached QR decomposition of X matrix */\n     private QRDecomposition qr = null;\n \n-    /*\n+    /**\n      * {@inheritDoc}\n      * \n      * Computes and caches QR decomposition of the X matrix.", "timestamp": 1224163952, "metainfo": ""}