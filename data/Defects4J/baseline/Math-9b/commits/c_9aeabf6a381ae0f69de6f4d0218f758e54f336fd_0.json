{"sha": "9aeabf6a381ae0f69de6f4d0218f758e54f336fd", "log": "renamed the RungeKuttaFehlbergIntegrator base class to EmbeddedRungKuttaIntegrator since it is more general than the single method designed by Fehlberg renamed some misleading private fields in the corresponding derived classes  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n    * instance in order to initialize the internal arrays. This\n    * constructor is used only in order to delay the initialization in\n    * some cases. As an example, the {@link\n-   * RungeKuttaFehlbergIntegrator} uses the prototyping design pattern\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n    * to create the step interpolators by cloning an uninitialized\n    * model and latter initializing the copy.\n    */\n   /**\n    * Finalize the step.\n \n-   * <p>Some Runge-Kutta-Fehlberg integrators need fewer functions\n+   * <p>Some embedded Runge-Kutta integrators need fewer functions\n    * evaluations than their counterpart step interpolators. These\n    * interpolators should perform the last evaluations they need by\n    * themselves only if they need them. This method triggers these\n--- a/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n  * This class implements the 5(4) Dormand-Prince integrator for Ordinary\n  * Differential Equations.\n \n- * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n  * of order 5(4) used in local extrapolation mode (i.e. the solution\n  * is computed using the high order formula) with stepsize control\n  * (and automatic step initialization) and continuous output. This\n  */\n \n public class DormandPrince54Integrator\n-  extends RungeKuttaFehlbergIntegrator {\n+  extends EmbeddedRungeKuttaIntegrator {\n \n   private static final String methodName = \"Dormand-Prince 5(4)\";\n \n-  private static final double[] c = {\n+  private static final double[] staticC = {\n     1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n   };\n \n-  private static final double[][] a = {\n+  private static final double[][] staticA = {\n     {1.0/5.0},\n     {3.0/40.0, 9.0/40.0},\n     {44.0/45.0, -56.0/15.0, 32.0/9.0},\n     {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n   };\n \n-  private static final double[] b = {\n+  private static final double[] staticB = {\n     35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n   };\n \n   public DormandPrince54Integrator(double minStep, double maxStep,\n                                    double scalAbsoluteTolerance,\n                                    double scalRelativeTolerance) {\n-    super(true, c, a, b, new DormandPrince54StepInterpolator(),\n+    super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n \n   public DormandPrince54Integrator(double minStep, double maxStep,\n                                    double[] vecAbsoluteTolerance,\n                                    double[] vecRelativeTolerance) {\n-    super(true, c, a, b, new DormandPrince54StepInterpolator(),\n+    super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n   }\n \n--- a/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n    * {@link #reinitialize} method should be called before using the\n    * instance in order to initialize the internal arrays. This\n    * constructor is used only in order to delay the initialization in\n-   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n    * prototyping design pattern to create the step interpolators by\n    * cloning an uninitialized model and latter initializing the copy.\n    */\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n  * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n  * Differential Equations.\n \n- * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n  * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n  * is computed using the high order formula) with stepsize control\n  * (and automatic step initialization) and continuous output. This\n  */\n \n public class DormandPrince853Integrator\n-  extends RungeKuttaFehlbergIntegrator {\n+  extends EmbeddedRungeKuttaIntegrator {\n \n   private static final String methodName = \"Dormand-Prince 8 (5, 3)\";\n \n   private static final double sqrt6 = Math.sqrt(6.0);\n \n-  private static final double[] c = {\n+  private static final double[] staticC = {\n     (12.0 - 2.0 * sqrt6) / 135.0, (6.0 - sqrt6) / 45.0, (6.0 - sqrt6) / 30.0,\n     (6.0 + sqrt6) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n     6.0/7.0, 1.0, 1.0\n   };\n \n-  private static final double[][] a = {\n+  private static final double[][] staticA = {\n \n     // k2\n     {(12.0 - 2.0 * sqrt6) / 135.0},\n \n   };\n \n-  private static final double[] b = {\n+  private static final double[] staticB = {\n       104257.0/1920240.0,\n       0.0,\n       0.0,\n   public DormandPrince853Integrator(double minStep, double maxStep,\n                                     double scalAbsoluteTolerance,\n                                     double scalRelativeTolerance) {\n-    super(true, c, a, b,\n+    super(true, staticC, staticA, staticB,\n           new DormandPrince853StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n   public DormandPrince853Integrator(double minStep, double maxStep,\n                                     double[] vecAbsoluteTolerance,\n                                     double[] vecRelativeTolerance) {\n-    super(true, c, a, b,\n+    super(true, staticC, staticA, staticB,\n           new DormandPrince853StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n   }\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n    * {@link #reinitialize} method should be called before using the\n    * instance in order to initialize the internal arrays. This\n    * constructor is used only in order to delay the initialization in\n-   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n    * prototyping design pattern to create the step interpolators by\n    * cloning an uninitialized model and latter initializing the copy.\n    */\n   }\n \n   /** Reinitialize the instance\n-   * Some Runge-Kutta-Fehlberg integrators need fewer functions\n+   * Some embedded Runge-Kutta integrators need fewer functions\n    * evaluations than their counterpart step interpolators. So the\n    * interpolator should perform the last evaluations they need by\n-   * themselves. The {@link RungeKuttaFehlbergIntegrator\n-   * RungeKuttaFehlbergIntegrator} abstract class calls this method in\n+   * themselves. The {@link EmbeddedRungeKuttaIntegrator\n+   * EmbeddedRungeKuttaIntegrator} abstract class calls this method in\n    * order to let the step interpolator perform the evaluations it\n    * needs. These evaluations will be performed during the call to\n    * <code>doFinalize</code> if any, i.e. only if the step handler\n--- a/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n    * should be called before using the instance in order to initialize\n    * the internal arrays. This constructor is used only in order to delay\n    * the initialization in some cases. As an example, the {@link\n-   * RungeKuttaFehlbergIntegrator} uses the prototyping design pattern\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n    * to create the step interpolators by cloning an uninitialized\n    * model and latter initializing the copy.\n    */\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/EmbeddedRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the common part of all embedde Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+\n+ * <p>These methods are embedded explicit Runge-Kutta methods with two\n+ * sets of coefficients allowing to estimate the error, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ *       |  b'1  b'2 ...   b's-1 b's\n+ * </pre>\n+ * </p>\n+\n+ * <p>In fact, we rather use the array defined by ej = bj - b'j to\n+ * compute directly the error rather than computing two estimates and\n+ * then comparing them.</p>\n+\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+\n+ * @version $Id: EmbeddedRungeKuttaIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+\n+ */\n+\n+public abstract class EmbeddedRungeKuttaIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(boolean fsal,\n+                                         double[] c, double[][] a, double[] b,\n+                                         RungeKuttaStepInterpolator prototype,\n+                                         double minStep, double maxStep,\n+                                         double scalAbsoluteTolerance,\n+                                         double scalRelativeTolerance) {\n+\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(boolean fsal,\n+                                         double[] c, double[][] a, double[] b,\n+                                         RungeKuttaStepInterpolator prototype,\n+                                         double   minStep, double maxStep,\n+                                         double[] vecAbsoluteTolerance,\n+                                         double[] vecRelativeTolerance) {\n+\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public abstract String getName();\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public abstract int getOrder();\n+\n+  /** Get the safety factor for stepsize control.\n+   * @return safety factor\n+   */\n+  public double getSafety() {\n+    return safety;\n+  }\n+\n+  /** Set the safety factor for stepsize control.\n+   * @param safety safety factor\n+   */\n+  public void setSafety(double safety) {\n+    this.safety = safety;\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0,\n+                        double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    stepStart  = t0;\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    boolean lastStep;\n+    handler.reset();\n+    do {\n+\n+      interpolator.shift();\n+\n+      double error = 0;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(stepStart, y, yDotK[0]);\n+        }\n+\n+        if (firstTime) {\n+          double[] scale;\n+          if (vecAbsoluteTolerance != null) {\n+            scale = vecAbsoluteTolerance;\n+          } else {\n+            scale = new double[y0.length];\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = scalAbsoluteTolerance;\n+            }\n+          }\n+          hNew = initializeStep(equations, forward, getOrder(), scale,\n+                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+          firstTime = false;\n+        }\n+\n+        stepSize = hNew;\n+\n+        // step adjustment near bounds\n+        if ((forward && (stepStart + stepSize > t))\n+            || ((! forward) && (stepStart + stepSize < t))) {\n+          stepSize = t - stepStart;\n+        }\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n+        if (error <= 1.0) {\n+\n+          // Switching functions handling\n+          interpolator.storeTime(stepStart + stepSize);\n+          if (switchesHandler.evaluateStep(interpolator)) {\n+            // reject the step to match exactly the next switch time\n+            hNew = switchesHandler.getEventTime() - stepStart;\n+          } else {\n+            // accept the step\n+            loop = false;\n+          }\n+\n+        } else {\n+          // reject the step and attempt to reduce error by stepsize control\n+          double factor = Math.min(maxGrowth,\n+                                   Math.max(minReduction,\n+                                            safety * Math.pow(error, exp)));\n+          hNew = filterStep(stepSize * factor, false);\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      switchesHandler.stepAccepted(nextStep, y);\n+      if (switchesHandler.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = forward ? (nextStep >= t) : (nextStep <= t);\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      handler.handleStep(interpolator, lastStep);\n+      stepStart = nextStep;\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n+        // some switching function has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      if (! lastStep) {\n+        // stepsize control for next step\n+        double  factor     = Math.min(maxGrowth,\n+                                      Math.max(minReduction,\n+                                               safety * Math.pow(error, exp)));\n+        double  scaledH    = stepSize * factor;\n+        double  nextT      = stepStart + scaledH;\n+        boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+        hNew = filterStep(scaledH, nextIsLast);\n+      }\n+\n+    } while (! lastStep);\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Get the minimal reduction factor for stepsize control.\n+   * @return minimal reduction factor\n+   */\n+  public double getMinReduction() {\n+    return minReduction;\n+  }\n+\n+  /** Set the minimal reduction factor for stepsize control.\n+   * @param minReduction minimal reduction factor\n+   */\n+  public void setMinReduction(double minReduction) {\n+    this.minReduction = minReduction;\n+  }\n+\n+  /** Get the maximal growth factor for stepsize control.\n+   * @return maximal growth factor\n+   */\n+  public double getMaxGrowth() {\n+    return maxGrowth;\n+  }\n+\n+  /** Set the maximal growth factor for stepsize control.\n+   * @param maxGrowth maximal growth factor\n+   */\n+  public void setMaxGrowth(double maxGrowth) {\n+    this.maxGrowth = maxGrowth;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected abstract double estimateError(double[][] yDotK,\n+                                          double[] y0, double[] y1,\n+                                          double h);\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Stepsize control exponent. */\n+  private double exp;\n+\n+  /** Safety factor for stepsize control. */\n+  private double safety;\n+\n+  /** Minimal reduction factor for stepsize control. */\n+  private double minReduction;\n+\n+  /** Maximal growth factor for stepsize control. */\n+  private double maxGrowth;\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n  * integration, in order to minimize computation cost. It is\n  * particularly well suited when a very high precision is needed. The\n  * limit where this method becomes more efficient than high-order\n- * Runge-Kutta-Fehlberg methods like {@link DormandPrince853Integrator\n+ * embedded Runge-Kutta methods like {@link DormandPrince853Integrator\n  * Dormand-Prince 8(5,3)} depends on the problem. Results given in the\n  * Hairer, Norsett and Wanner book show for example that this limit\n  * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz\n--- a/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n  * This class implements the 5(4) Higham and Hall integrator for\n  * Ordinary Differential Equations.\n \n- * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n  * of order 5(4) used in local extrapolation mode (i.e. the solution\n  * is computed using the high order formula) with stepsize control\n  * (and automatic step initialization) and continuous output. This\n  */\n \n public class HighamHall54Integrator\n-  extends RungeKuttaFehlbergIntegrator {\n+  extends EmbeddedRungeKuttaIntegrator {\n \n   private static final String methodName = \"Higham-Hall 5(4)\";\n \n-  private static final double[] c = {\n+  private static final double[] staticC = {\n     2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n   };\n \n-  private static final double[][] a = {\n+  private static final double[][] staticA = {\n     {2.0/9.0},\n     {1.0/12.0, 1.0/4.0},\n     {1.0/8.0, 0.0, 3.0/8.0},\n     {1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0}\n   };\n \n-  private static final double[] b = {\n+  private static final double[] staticB = {\n     1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n   };\n \n-  private static final double[] e = {\n+  private static final double[] staticE = {\n     -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n   };\n \n   public HighamHall54Integrator(double minStep, double maxStep,\n                                 double scalAbsoluteTolerance,\n                                 double scalRelativeTolerance) {\n-    super(false, c, a, b, new HighamHall54StepInterpolator(),\n+    super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n \n   public HighamHall54Integrator(double minStep, double maxStep,\n                                 double[] vecAbsoluteTolerance,\n                                 double[] vecRelativeTolerance) {\n-    super(false, c, a, b, new HighamHall54StepInterpolator(),\n+    super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n   }\n \n     double error = 0;\n \n     for (int j = 0; j < y0.length; ++j) {\n-      double errSum = e[0] * yDotK[0][j];\n-      for (int l = 1; l < e.length; ++l) {\n-        errSum += e[l] * yDotK[l][j];\n+      double errSum = staticE[0] * yDotK[0][j];\n+      for (int l = 1; l < staticE.length; ++l) {\n+        errSum += staticE[l] * yDotK[l][j];\n       }\n \n       double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n--- a/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n    * {@link AbstractStepInterpolator#reinitialize} method should be called\n    * before using the instance in order to initialize the internal arrays. This\n    * constructor is used only in order to delay the initialization in\n-   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n    * prototyping design pattern to create the step interpolators by\n    * cloning an uninitialized model and latter initializing the copy.\n    */\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaStepInterpolator.java\n import java.io.IOException;\n \n /** This class represents an interpolator over the last step during an\n- * ODE integration for Runge-Kutta and Runge-Kutta-Fehlberg\n- * integrators.\n+ * ODE integration for Runge-Kutta and embedded Runge-Kutta integrators.\n  *\n  * @see RungeKuttaIntegrator\n- * @see RungeKuttaFehlbergIntegrator\n+ * @see EmbeddedRungeKuttaIntegrator\n  *\n  * @version $Id: RungeKuttaStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n  *\n    * instance in order to initialize the internal arrays. This\n    * constructor is used only in order to delay the initialization in\n    * some cases. The {@link RungeKuttaIntegrator} and {@link\n-   * RungeKuttaFehlbergIntegrator} classes uses the prototyping design\n+   * EmbeddedRungeKuttaIntegrator} classes uses the prototyping design\n    * pattern to create the step interpolators by cloning an\n    * uninitialized model and latter initializing the copy.\n    */\n    * than their counterpart step interpolators. So the interpolator\n    * should perform the last evaluations they need by themselves. The\n    * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n-   * RungeKuttaFehlbergIntegrator RungeKuttaFehlbergIntegrator}\n+   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n    * abstract classes call this method in order to let the step\n    * interpolator perform the evaluations it needs. These evaluations\n    * will be performed during the call to <code>doFinalize</code> if\n--- a/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n       double scalAbsoluteTolerance = Math.pow(10.0, i);\n       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n-      RungeKuttaFehlbergIntegrator integ =\n+      EmbeddedRungeKuttaIntegrator integ =\n           new DormandPrince54Integrator(minStep, maxStep,\n                                         scalAbsoluteTolerance, scalRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);", "timestamp": 1194468773, "metainfo": ""}