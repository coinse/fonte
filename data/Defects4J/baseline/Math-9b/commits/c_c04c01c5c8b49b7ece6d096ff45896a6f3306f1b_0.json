{"sha": "c04c01c5c8b49b7ece6d096ff45896a6f3306f1b", "log": "[MATH-578] Improve performance of quantile evaluation in Percentile for special cases.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\n             } else if (k < pivot) {\n                 // the element is in the left partition\n                 end  = pivot;\n-                node = Math.min(2 * node + 1, pivotsHeap.length); // the min is here to avoid integer overflow\n+                node = FastMath.min(2 * node + 1, pivotsHeap.length); // the min is here to avoid integer overflow\n             } else {\n                 // the element is in the right partition\n                 begin = pivot + 1;\n-                node  = Math.min(2 * node + 2, pivotsHeap.length); // the min is here to avoid integer overflow\n+                node  = FastMath.min(2 * node + 2, pivotsHeap.length); // the min is here to avoid integer overflow\n             }\n \n         }\n         int i = begin + 1;\n         int j = end - 1;\n         while (i < j) {\n-            while ((i < j) && (work[j] >= value)) {\n+            while ((i < j) && (work[j] > value)) {\n                 --j;\n             }\n-            while ((i < j) && (work[i] <= value)) {\n+            while ((i < j) && (work[i] < value)) {\n                 ++i;\n             }\n ", "timestamp": 1342969252, "metainfo": ""}