{"sha": "b551cacc3db5a6d659d9e92911eb602163306deb", "log": "recover performances lost with changes for r723496  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n      */\n     RealMatrix getH() throws IllegalStateException;\n \n+    /**\n+     * Get a solver for A &times; X = B.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n }\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n public class QRDecompositionImpl implements QRDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 3107050419319784520L;\n+    private static final long serialVersionUID = -2036131698031167221L;\n \n     /**\n      * A packed TRANSPOSED representation of the QR decomposition.\n \n     }\n \n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(qrt, rDiag);\n+    }\n+\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -6353105415121373022L;\n+\n+        /**\n+         * A packed TRANSPOSED representation of the QR decomposition.\n+         * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+         * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+         * from which an explicit form of Q can be recomputed if desired.</p>\n+         */\n+        private double[][] qrt;\n+\n+        /** The diagonal elements of R. */\n+        private double[] rDiag;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param qrt packed TRANSPOSED representation of the QR decomposition\n+         * @param rDiag diagonal elements of R\n+         */\n+        private Solver(final double[][] qrt, final double[] rDiag) {\n+            this.qrt   = qrt;\n+            this.rDiag = rDiag;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular()\n+        throws IllegalStateException {\n+\n+            for (double diag : rDiag) {\n+                if (diag == 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] solve(double[] b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            if (b.length != m) {\n+                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] x = new double[n];\n+            final double[] y = b.clone();\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+                final double[] qrtMinor = qrt[minor];\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qrtMinor[row];\n+                }\n+                dotProduct /= rDiag[minor] * qrtMinor[minor];\n+\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qrtMinor[row];\n+                }\n+\n+            }\n+\n+            // solve triangular system R.x = y\n+            for (int row = n - 1; row >= 0; --row) {\n+                y[row] /= rDiag[row];\n+                final double yRow   = y[row];\n+                final double[] qrtRow = qrt[row];\n+                x[row] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                    y[i] -= yRow * qrtRow[i];\n+                }\n+            }\n+\n+            return x;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((RealVectorImpl) b);\n+            } catch (ClassCastException cce) {\n+                return new RealVectorImpl(solve(b.getData()), false);\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+         * has not been called\n+         * @throws IllegalArgumentException if matrices dimensions don't match\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+            return new RealVectorImpl(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            if (b.getRowDimension() != m) {\n+                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int cols = b.getColumnDimension();\n+            final double[][] xData = new double[n][cols];\n+            final double[] y = new double[b.getRowDimension()];\n+\n+            for (int k = 0; k < cols; ++k) {\n+\n+                // get the right hand side vector\n+                for (int j = 0; j < y.length; ++j) {\n+                    y[j] = b.getEntry(j, k);\n+                }\n+\n+                // apply Householder transforms to solve Q.y = b\n+                for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+                    final double[] qrtMinor = qrt[minor];\n+                    double dotProduct = 0;\n+                    for (int row = minor; row < m; row++) {\n+                        dotProduct += y[row] * qrtMinor[row];\n+                    }\n+                    dotProduct /= rDiag[minor] * qrtMinor[minor];\n+\n+                    for (int row = minor; row < m; row++) {\n+                        y[row] += dotProduct * qrtMinor[row];\n+                    }\n+\n+                }\n+\n+                // solve triangular system R.x = y\n+                for (int row = n - 1; row >= 0; --row) {\n+                    y[row] /= rDiag[row];\n+                    final double yRow = y[row];\n+                    final double[] qrtRow = qrt[row];\n+                    xData[row][k] = yRow;\n+                    for (int i = 0; i < row; i++) {\n+                        y[i] -= yRow * qrtRow[i];\n+                    }\n+                }\n+\n+            }\n+\n+            return new RealMatrixImpl(xData, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+            return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n+        }\n+\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/linear/QRSolver.java\n+++ b/src/java/org/apache/commons/math/linear/QRSolver.java\n public class QRSolver implements DecompositionSolver {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -579465076068393818L;\n+    private static final long serialVersionUID = -446230688570372107L;\n \n     /** Underlying decomposition. */\n-    private final QRDecomposition decomposition;\n+    private final DecompositionSolver solver;\n \n     /**\n      * Simple constructor.\n      * @param decomposition decomposition to use\n      */\n     public QRSolver(final QRDecomposition decomposition) {\n-        this.decomposition = decomposition;\n+        this.solver = decomposition.getSolver();\n     }\n \n     /** Solve the linear equation A &times; X = B in least square sense.\n      */\n     public double[] solve(final double[] b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (decomposition.getR().getRowDimension() != b.length) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");            \n-        }\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        // solve Q.y = b, using the fact Q is orthogonal\n-        final double[] y = decomposition.getQT().operate(b);\n-\n-        // solve triangular system R.x = y\n-        final RealMatrix r = decomposition.getR();\n-        final double[] x = new double[r.getColumnDimension()];\n-        System.arraycopy(y, 0, x, 0, r.getRowDimension());\n-        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n-            x[i] /= r.getEntry(i, i);\n-            final double lastX = x[i];\n-            for (int j = i - 1; j >= 0; --j) {\n-                x[j] -= lastX * r.getEntry(j, i);\n-            }\n-        }\n-\n-        return x;\n-\n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B in least square sense.\n      */\n     public RealVector solve(final RealVector b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getData()), false);\n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B in least square sense.\n      */\n     public RealMatrix solve(final RealMatrix b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (decomposition.getR().getRowDimension() != b.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");            \n-        }\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        // solve Q.y = b, using the fact Q is orthogonal\n-        final RealMatrix y = decomposition.getQT().multiply(b);\n-\n-        // solve triangular system R.x = y\n-        final RealMatrix r = decomposition.getR();\n-        final double[][] xData =\n-            new double[r.getColumnDimension()][b.getColumnDimension()];\n-        for (int i = 0; i < r.getRowDimension(); ++i) {\n-            final double[] xi = xData[i];\n-            for (int k = 0; k < xi.length; ++k) {\n-                xi[k] = y.getEntry(i, k);\n-            }\n-        }\n-        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n-            final double rii = r.getEntry(i, i);\n-            final double[] xi = xData[i];\n-            for (int k = 0; k < xi.length; ++k) {\n-                xi[k] /= rii;\n-                final double lastX = xi[k];\n-                for (int j = i - 1; j >= 0; --j) {\n-                    xData[j][k] -= lastX * r.getEntry(j, i);\n-                }\n-            }\n-        }\n-\n-        return MatrixUtils.createRealMatrix(xData);\n-\n+        return solver.solve(b);\n     }\n \n     /**\n      * @return true if the decomposed matrix is non-singular\n      */\n     public boolean isNonSingular() {\n-        final RealMatrix r = decomposition.getR();\n-        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n-        for (int i = 0; i < p; ++i) {\n-            if (r.getEntry(i, i) == 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        return solver.isNonSingular();\n     }\n \n     /** Get the pseudo-inverse of the decomposed matrix.\n      */\n     public RealMatrix getInverse()\n         throws InvalidMatrixException {\n-        final RealMatrix r = decomposition.getR();\n-        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n-        return solve(MatrixUtils.createRealIdentityMatrix(p));\n+        return solver.getInverse();\n     }\n \n }\n--- a/src/test/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRSolverTest.java\n         assertFalse(solver.isNonSingular());\n \n         solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)));\n-        assertTrue(solver.isNonSingular());\n+        assertFalse(solver.isNonSingular());\n \n         solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)));\n         assertTrue(solver.isNonSingular());", "timestamp": 1229888159, "metainfo": ""}