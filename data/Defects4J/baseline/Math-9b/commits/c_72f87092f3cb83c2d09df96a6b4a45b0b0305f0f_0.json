{"sha": "72f87092f3cb83c2d09df96a6b4a45b0b0305f0f", "log": "MATH-894 Added new \"protected\" (and not \"synchronized\") methods to allow access to the internal array for subclasses only. Javadoc formatting.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n  * are added and removed.\n  * </p>\n  * <p>\n- *  The internal storage array starts with capacity determined by the\n- * <code>initialCapacity</code> property, which can be set by the constructor.\n+ * The internal storage array starts with capacity determined by the\n+ * {@code initialCapacity} property, which can be set by the constructor.\n  * The default initial capacity is 16.  Adding elements using\n- * {@link #addElement(double)} appends elements to the end of the array.  When\n- * there are no open entries at the end of the internal storage array, the\n- * array is expanded.  The size of the expanded array depends on the\n- * <code>expansionMode</code> and <code>expansionFactor</code> properties.\n- * The <code>expansionMode</code> determines whether the size of the array is\n- * multiplied by the <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if\n- * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n- * storage locations added).  The default <code>expansionMode</code> is\n- * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n- * is 2.0.\n+ * {@link #addElement(double)} appends elements to the end of the array.\n+ * When there are no open entries at the end of the internal storage array,\n+ * the array is expanded.  The size of the expanded array depends on the\n+ * {@code expansionMode} and {@code expansionFactor} properties.\n+ * The {@code expansionMode} determines whether the size of the array is\n+ * multiplied by the {@code expansionFactor}\n+ * ({@link ExpansionMode#MULTIPLICATIVE}) or if the expansion is additive\n+ * ({@link ExpansionMode#ADDITIVE} -- {@code expansionFactor} storage\n+ * locations added).\n+ * The default {@code expansionMode} is {@code MULTIPLICATIVE} and the default\n+ * {@code expansionFactor} is 2.\n  * </p>\n  * <p>\n  * The {@link #addElementRolling(double)} method adds a new element to the end\n  * the storage locations at the beginning of the internal storage array.  To\n  * reclaim this storage, each time one of these methods is activated, the size\n  * of the internal storage array is compared to the number of addressable\n- * elements (the <code>numElements</code> property) and if the difference\n+ * elements (the {@code numElements} property) and if the difference\n  * is too large, the internal array is contracted to size\n- * <code>numElements + 1.</code>  The determination of when the internal\n- * storage array is \"too large\" depends on the <code>expansionMode</code> and\n- * <code>contractionFactor</code> properties.  If  the <code>expansionMode</code>\n- * is <code>MULTIPLICATIVE</code>, contraction is triggered when the\n- * ratio between storage array length and <code>numElements</code> exceeds\n- * <code>contractionFactor.</code>  If the <code>expansionMode</code>\n- * is <code>ADDITIVE</code>, the number of excess storage locations\n- * is compared to <code>contractionFactor.</code>\n+ * {@code numElements + 1}.  The determination of when the internal\n+ * storage array is \"too large\" depends on the {@code expansionMode} and\n+ * {@code contractionFactor} properties.  If  the {@code expansionMode}\n+ * is {@code MULTIPLICATIVE}, contraction is triggered when the\n+ * ratio between storage array length and {@code numElements} exceeds\n+ * {@code contractionFactor.}  If the {@code expansionMode}\n+ * is {@code ADDITIVE}, the number of excess storage locations\n+ * is compared to {@code contractionFactor}.\n  * </p>\n  * <p>\n  * To avoid cycles of expansions and contractions, the\n- * <code>expansionFactor</code> must not exceed the\n- * <code>contractionFactor.</code> Constructors and mutators for both of these\n- * properties enforce this requirement, throwing IllegalArgumentException if it\n- * is violated.\n+ * {@code expansionFactor} must not exceed the {@code contractionFactor}.\n+ * Constructors and mutators for both of these properties enforce this\n+ * requirement, throwing a {@code MathIllegalArgumentException} if it is\n+ * violated.\n  * </p>\n  * @version $Id$\n  */\n     /**\n      * The expansion factor of the array.  When the array needs to be expanded,\n      * the new array size will be\n-     * <code>internalArray.length * expansionFactor</code>\n-     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE, or\n-     * <code>internalArray.length + expansionFactor</code> if\n-     * <code>expansionMode</code> is set to ADDITIVE_MODE.\n+     * {@code internalArray.length * expansionFactor}\n+     * if {@code expansionMode} is set to MULTIPLICATIVE_MODE, or\n+     * {@code internalArray.length + expansionFactor} if\n+     * {@code expansionMode} is set to ADDITIVE_MODE.\n      */\n     private float expansionFactor = 2.0f;\n \n     /**\n-     * Determines whether array expansion by <code>expansionFactor</code>\n+     * Determines whether array expansion by {@code expansionFactor}\n      * is additive or multiplicative.\n      */\n     private ExpansionMode expansionMode = ExpansionMode.MULTIPLICATIVE;\n \n     /**\n      * The position of the first addressable element in the internal storage\n-     * array.  The addressable elements in the array are <code>\n-     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n-     * </code>\n+     * array.  The addressable elements in the array are\n+     * {@code internalArray[startIndex],...,internalArray[startIndex + numElements - 1]}.\n      */\n     private int startIndex = 0;\n \n      *  <li>{@code contractionFactor = 2.5}</li>\n      * </ul>\n      */\n-    public ResizableDoubleArray()\n-        throws MathIllegalArgumentException {\n+    public ResizableDoubleArray() {\n         this(DEFAULT_INITIAL_CAPACITY);\n     }\n \n     @Deprecated\n     public synchronized double[] getInternalValues() {\n         return internalArray;\n+    }\n+\n+    /**\n+     * Provides <em>direct</em> access to the internal storage array.\n+     * Please note that this method returns a reference to this object's\n+     * storage array, not a copy.\n+     * <br/>\n+     * To correctly address elements of the array, the \"start index\" is\n+     * required (available via the {@link #getStartIndex() getStartIndex}\n+     * method.\n+     * <br/>\n+     * This method should only be used to avoid copying the internal array.\n+     * The returned value <em>must</em> be used for reading only; other\n+     * uses could lead to this object becoming inconsistent.\n+     * <br/>\n+     * The {@link #getElements} method has no such limitation since it\n+     * returns a copy of this array's addressable elements.\n+     *\n+     * @return the internal storage array used by this object.\n+     * @since 3.1\n+     */\n+    protected double[] getArrayRef() {\n+        return internalArray;\n+    }\n+\n+    /**\n+     * Returns the \"start index\" of the internal array.\n+     * This index is the position of the first addressable element in the\n+     * internal storage array.\n+     * The addressable elements in the array are at indices contained in\n+     * the interval [{@link #getStartIndex()},\n+     *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].\n+     *\n+     * @return the start index.\n+     * @since 3.1\n+     */\n+    protected int getStartIndex() {\n+        return startIndex;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math3/util/ResizableDoubleArrayTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/ResizableDoubleArrayTest.java\n \n     }\n \n+    @Test\n+    public void testGetArrayRef() {\n+        final ResizableDoubleArray a = new ResizableDoubleArray();\n+\n+        // Modify \"a\" through the public API.\n+        final int index = 20;\n+        final double v1 = 1.2;\n+        a.setElement(index, v1);\n+\n+        // Modify the internal storage through the protected API.\n+        final double v2 = v1 + 3.4;\n+        final double[] aInternalArray = a.getArrayRef();\n+        aInternalArray[a.getStartIndex() + index] = v2;\n+\n+        Assert.assertEquals(v2, a.getElement(index), 0d);\n+    }\n+\n     private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {\n         Assert.assertTrue(b.equals(a));\n         Assert.assertTrue(a.equals(b));", "timestamp": 1352931234, "metainfo": ""}