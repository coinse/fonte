{"sha": "bad616b685ec5bf1e2dce65d240d9cbeab834431", "log": "MATH-621 Several variables (passed around as function arguments but changed in-place) replaced by instance fields.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n      * Index of the interpolation point at the trust region center.\n      */\n     private int trustRegionCenterInterpolationPointIndex;\n+    /**\n+     * XXX \"bmat\" in the original code.\n+     */\n+    private Array2DRowRealMatrix bMatrix;\n+    /**\n+     * XXX \"zmat\" in the original code.\n+     */\n+    private Array2DRowRealMatrix zMatrix;\n+    /**\n+     * XXX \"xpt\" in the original code.\n+     */\n+    private Array2DRowRealMatrix interpolationPoints;\n+    /**\n+     * XXX \"xbase\" in the original code.\n+     */\n+    private ArrayRealVector originShift;\n+    /**\n+     * XXX \"fval\" in the original code.\n+     */\n+    private ArrayRealVector fAtInterpolationPoints;\n+    /**\n+     * XXX \"xopt\" in the original code.\n+     */\n+    private ArrayRealVector trustRegionCenterOffset;\n+    /**\n+     * XXX \"gopt\" in the original code.\n+     */\n+    private ArrayRealVector gradientAtTrustRegionCenter;\n+    /**\n+     * XXX \"sl\" in the original code.\n+     */\n+    private ArrayRealVector lowerDifference;\n+    /**\n+     * XXX \"su\" in the original code.\n+     */\n+    private ArrayRealVector upperDifference;\n+    /**\n+     * XXX \"pq\" in the original code.\n+     */\n+    private ArrayRealVector modelSecondDerivativesParameters;\n+    /**\n+     * XXX \"xnew\" in the original code.\n+     */\n+    private ArrayRealVector newPoint;\n+    /**\n+     * XXX \"xalt\" in the original code.\n+     */\n+    private ArrayRealVector alternativeNewPoint;\n+    /**\n+     * XXX \"d__\" in the original code.\n+     */\n+    private ArrayRealVector trialStepPoint;\n+    /**\n+     * XXX \"vlag\" in the original code.\n+     */\n+    private ArrayRealVector lagrangeValuesAtNewPoint;\n+    /**\n+     * XXX \"hq\" in the original code.\n+     */\n+    private ArrayRealVector modelSecondDerivativesValues;\n \n     /**\n      * @param numberOfInterpolationPoints Number of interpolation conditions.\n      * @return\n      */\n     private double bobyqa() {\n-        // System.out.println(\"bobyqa\"); // XXX\n+        printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n-        final int npt = numberOfInterpolationPoints;\n-\n-        final int np = n + 1;\n-        final int ndim = npt + n;\n-\n-        // Partition the working space array, so that different parts of it can\n-        // be treated separately during the calculation of BOBYQB. The partition\n-        // requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the\n-        // space that is taken by the last array in the argument list of BOBYQB.\n-\n-        final ArrayRealVector xbase = new ArrayRealVector(n);\n-        final Array2DRowRealMatrix xpt = new Array2DRowRealMatrix(npt, n);\n-        final ArrayRealVector fval = new ArrayRealVector(npt);\n-        final ArrayRealVector xopt = new ArrayRealVector(n);\n-        final ArrayRealVector gopt = new ArrayRealVector(n);\n-        final ArrayRealVector hq = new ArrayRealVector(n * np / 2);\n-        final ArrayRealVector pq = new ArrayRealVector(npt);\n-        final Array2DRowRealMatrix bmat = new Array2DRowRealMatrix(ndim, n);\n-        final Array2DRowRealMatrix zmat = new Array2DRowRealMatrix(npt, (npt - np));\n-        final ArrayRealVector sl = new ArrayRealVector(n);\n-        final ArrayRealVector su = new ArrayRealVector(n);\n-        final ArrayRealVector xnew = new ArrayRealVector(n);\n-        final ArrayRealVector xalt = new ArrayRealVector(n);\n-        final ArrayRealVector d__ = new ArrayRealVector(n);\n-        final ArrayRealVector vlag = new ArrayRealVector(ndim);\n \n         // Return if there is insufficient space between the bounds. Modify the\n         // initial X if necessary in order to avoid conflicts between the bounds\n \n         for (int j = 0; j < n; j++) {\n             final double boundDiff = boundDifference[j];\n-            sl.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n-            su.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n-            if (sl.getEntry(j) >= -initialTrustRegionRadius) {\n-                if (sl.getEntry(j) >= ZERO) {\n+            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n+            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n+            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n+                if (lowerDifference.getEntry(j) >= ZERO) {\n                     currentBest.setEntry(j, lowerBound[j]);\n-                    sl.setEntry(j, ZERO);\n-                    su.setEntry(j, boundDiff);\n+                    lowerDifference.setEntry(j, ZERO);\n+                    upperDifference.setEntry(j, boundDiff);\n                 } else {\n                     currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n-                    sl.setEntry(j, -initialTrustRegionRadius);\n+                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                     // Computing MAX\n                     final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n-                    su.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n-                }\n-            } else if (su.getEntry(j) <= initialTrustRegionRadius) {\n-                if (su.getEntry(j) <= ZERO) {\n+                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n+                }\n+            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n+                if (upperDifference.getEntry(j) <= ZERO) {\n                     currentBest.setEntry(j, upperBound[j]);\n-                    sl.setEntry(j, -boundDiff);\n-                    su.setEntry(j, ZERO);\n+                    lowerDifference.setEntry(j, -boundDiff);\n+                    upperDifference.setEntry(j, ZERO);\n                 } else {\n                     currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                     // Computing MIN\n                     final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                     final double deltaTwo = -initialTrustRegionRadius;\n-                    sl.setEntry(j, Math.min(deltaOne, deltaTwo));\n-                    su.setEntry(j, initialTrustRegionRadius);\n+                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n+                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                 }\n             }\n         }\n \n         // Make the call of BOBYQB.\n \n-        return bobyqb(xbase,\n-                      xpt,\n-                      fval,\n-                      xopt,\n-                      gopt,\n-                      hq,\n-                      pq,\n-                      bmat,\n-                      zmat,\n-                      sl,\n-                      su,\n-                      xnew,\n-                      xalt,\n-                      d__,\n-                      vlag);\n+        return bobyqb();\n     } // bobyqa\n \n     // ----------------------------------------------------------------------------------------\n      *     W is a one-dimensional array that is used for working space. Its length\n      *       must be at least 3*NDIM = 3*(NPT+N).\n      *\n-     * @param xbase\n-     * @param xpt\n-     * @param fval\n-     * @param xopt\n-     * @param gopt\n-     * @param hq\n-     * @param pq\n-     * @param bmat\n-     * @param zmat\n-     * @param sl\n-     * @param su\n-     * @param xnew\n-     * @param xalt\n-     * @param d__\n-     * @param vlag\n      * @return\n      */\n-    private double bobyqb(\n-            ArrayRealVector xbase,\n-            Array2DRowRealMatrix xpt,\n-            ArrayRealVector fval,\n-            ArrayRealVector xopt,\n-            ArrayRealVector gopt,\n-            ArrayRealVector hq,\n-            ArrayRealVector pq,\n-            Array2DRowRealMatrix bmat,\n-            Array2DRowRealMatrix zmat,\n-            ArrayRealVector sl,\n-            ArrayRealVector su,\n-            ArrayRealVector xnew,\n-            ArrayRealVector xalt,\n-            ArrayRealVector d__,\n-            ArrayRealVector vlag\n-    ) {\n-        // System.out.println(\"bobyqb\"); // XXX\n+    private double bobyqb() {\n+        printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n         final int npt = numberOfInterpolationPoints;\n \n         trustRegionCenterInterpolationPointIndex = 0;\n \n-        prelim(currentBest, xbase,\n-               xpt, fval, gopt, hq, pq, bmat,\n-               zmat, sl, su);\n+        prelim();\n         double xoptsq = ZERO;\n         for (int i = 0; i < n; i++) {\n-            xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n+            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n             // Computing 2nd power\n-            final double deltaOne = xopt.getEntry(i);\n+            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n             xoptsq += deltaOne * deltaOne;\n         }\n-        double fsave = fval.getEntry(0);\n+        double fsave = fAtInterpolationPoints.getEntry(0);\n         final int kbase = 0;\n \n         // Complete the settings that are required for the iterative procedure.\n         int state = 20;\n         for(;;) switch (state) {\n         case 20: {\n+            printState(20); // XXX\n             if (trustRegionCenterInterpolationPointIndex != kbase) {\n                 int ih = 0;\n                 for (int j = 0; j < n; j++) {\n                     for (int i = 0; i <= j; i++) {\n                         if (i < j) {\n-                            gopt.setEntry(j,  gopt.getEntry(j) + hq.getEntry(ih) * xopt.getEntry(i));\n+                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                         }\n-                        gopt.setEntry(i,  gopt.getEntry(i) + hq.getEntry(ih) * xopt.getEntry(j));\n+                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                         ih++;\n                     }\n                 }\n                     for (int k = 0; k < npt; k++) {\n                         double temp = ZERO;\n                         for (int j = 0; j < n; j++) {\n-                            temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n+                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                         }\n-                        temp *= pq.getEntry(k);\n+                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                         for (int i = 0; i < n; i++) {\n-                            gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n+                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                         }\n                     }\n                     throw new PathIsExploredException(); // XXX\n \n         }\n         case 60: {\n+            printState(60); // XXX\n             final ArrayRealVector gnew = new ArrayRealVector(n);\n             final ArrayRealVector xbdi = new ArrayRealVector(n);\n             final ArrayRealVector s = new ArrayRealVector(n);\n             final ArrayRealVector hs = new ArrayRealVector(n);\n             final ArrayRealVector hred = new ArrayRealVector(n);\n \n-            final double[] dsqCrvmin = trsbox(xpt, xopt, gopt, hq, pq, sl,\n-                                              su, delta, xnew, d__, gnew, xbdi, s,\n+            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                               hs, hred);\n             dsq = dsqCrvmin[0];\n             crvmin = dsqCrvmin[1];\n                 final double bdtol = errbig / rho;\n                 for (int j = 0; j < n; j++) {\n                     double bdtest = bdtol;\n-                    if (xnew.getEntry(j) == sl.getEntry(j)) {\n+                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                         bdtest = work1.getEntry(j);\n                     }\n-                    if (xnew.getEntry(j) == su.getEntry(j)) {\n+                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                         bdtest = -work1.getEntry(j);\n                     }\n                     if (bdtest < bdtol) {\n-                        double curv = hq.getEntry((j + j * j) / 2);\n+                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                         for (int k = 0; k < npt; k++) {\n                             // Computing 2nd power\n-                            final double d1 = xpt.getEntry(k, j);\n-                            curv += pq.getEntry(k) * (d1 * d1);\n+                            final double d1 = interpolationPoints.getEntry(k, j);\n+                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                         }\n                         bdtest += HALF * curv * rho;\n                         if (bdtest < bdtol) {\n \n         }\n         case 90: {\n+            printState(90); // XXX\n             if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                 final double fracsq = xoptsq * ONE_OVER_FOUR;\n                 double sumpq = ZERO;\n                 // final RealVector sumVector\n-                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(xpt.operate(xopt));\n+                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                 for (int k = 0; k < npt; k++) {\n-                    sumpq += pq.getEntry(k);\n+                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                     double sum = -HALF * xoptsq;\n                     for (int i = 0; i < n; i++) {\n-                        sum += xpt.getEntry(k, i) * xopt.getEntry(i);\n+                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                     }\n                     // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                     work2.setEntry(k, sum);\n                     final double temp = fracsq - HALF * sum;\n                     for (int i = 0; i < n; i++) {\n-                        work1.setEntry(i, bmat.getEntry(k, i));\n-                        vlag.setEntry(i, sum * xpt.getEntry(k, i) + temp * xopt.getEntry(i));\n+                        work1.setEntry(i, bMatrix.getEntry(k, i));\n+                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                         final int ip = npt + i;\n                         for (int j = 0; j <= i; j++) {\n-                            bmat.setEntry(ip, j,\n-                                          bmat.getEntry(ip, j)\n-                                          + work1.getEntry(i) * vlag.getEntry(j)\n-                                          + vlag.getEntry(i) * work1.getEntry(j));\n+                            bMatrix.setEntry(ip, j,\n+                                          bMatrix.getEntry(ip, j)\n+                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n+                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                         }\n                     }\n                 }\n                     double sumz = ZERO;\n                     double sumw = ZERO;\n                     for (int k = 0; k < npt; k++) {\n-                        sumz += zmat.getEntry(k, m);\n-                        vlag.setEntry(k, work2.getEntry(k) * zmat.getEntry(k, m));\n-                        sumw += vlag.getEntry(k);\n+                        sumz += zMatrix.getEntry(k, m);\n+                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n+                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                     }\n                     for (int j = 0; j < n; j++) {\n-                        double sum = (fracsq * sumz - HALF * sumw) * xopt.getEntry(j);\n+                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                         for (int k = 0; k < npt; k++) {\n-                            sum += vlag.getEntry(k) * xpt.getEntry(k, j);\n+                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                         }\n                         work1.setEntry(j, sum);\n                         for (int k = 0; k < npt; k++) {\n-                            bmat.setEntry(k, j,\n-                                          bmat.getEntry(k, j)\n-                                          + sum * zmat.getEntry(k, m));\n+                            bMatrix.setEntry(k, j,\n+                                          bMatrix.getEntry(k, j)\n+                                          + sum * zMatrix.getEntry(k, m));\n                         }\n                     }\n                     for (int i = 0; i < n; i++) {\n                         final int ip = i + npt;\n                         final double temp = work1.getEntry(i);\n                         for (int j = 0; j <= i; j++) {\n-                            bmat.setEntry(ip, j,\n-                                          bmat.getEntry(ip, j)\n+                            bMatrix.setEntry(ip, j,\n+                                          bMatrix.getEntry(ip, j)\n                                           + temp * work1.getEntry(j));\n                         }\n                     }\n \n                 int ih = 0;\n                 for (int j = 0; j < n; j++) {\n-                    work1.setEntry(j, -HALF * sumpq * xopt.getEntry(j));\n+                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                     for (int k = 0; k < npt; k++) {\n-                        work1.setEntry(j, work1.getEntry(j) + pq.getEntry(k) * xpt.getEntry(k, j));\n-                        xpt.setEntry(k, j, xpt.getEntry(k, j) - xopt.getEntry(j));\n+                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n+                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                     }\n                     for (int i = 0; i <= j; i++) {\n-                         hq.setEntry(ih,\n-                                    hq.getEntry(ih)\n-                                    + work1.getEntry(i) * xopt.getEntry(j)\n-                                    + xopt.getEntry(i) * work1.getEntry(j));\n-                        bmat.setEntry(npt + i, j, bmat.getEntry(npt + j, i));\n+                         modelSecondDerivativesValues.setEntry(ih,\n+                                    modelSecondDerivativesValues.getEntry(ih)\n+                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n+                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n+                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                         ih++;\n                     }\n                 }\n                 for (int i = 0; i < n; i++) {\n-                    xbase.setEntry(i, xbase.getEntry(i) + xopt.getEntry(i));\n-                    xnew.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n-                    sl.setEntry(i, sl.getEntry(i) - xopt.getEntry(i));\n-                    su.setEntry(i, su.getEntry(i) - xopt.getEntry(i));\n-                    xopt.setEntry(i, ZERO);\n+                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n+                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n+                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n+                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n+                    trustRegionCenterOffset.setEntry(i, ZERO);\n                 }\n                 xoptsq = ZERO;\n             }\n \n         }\n         case 210: {\n+            printState(210); // XXX\n             // Pick two alternative vectors of variables, relative to XBASE, that\n             // are suitable as new positions of the KNEW-th interpolation point.\n             // Firstly, XNEW is set to the point on a line through XOPT and another\n             // being returned in CAUCHY. The choice between these alternatives is\n             // going to be made when the denominator is calculated.\n \n-            final double[] alphaCauchy = altmov(xpt, xopt,\n-                                                bmat, zmat,\n-                                                sl, su, knew, adelt, xnew, xalt);\n+            final double[] alphaCauchy = altmov(knew, adelt);\n             alpha = alphaCauchy[0];\n             cauchy = alphaCauchy[1];\n \n             for (int i = 0; i < n; i++) {\n-                d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n+                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n             }\n \n             // Calculate VLAG and BETA for the current choice of D. The scalar\n \n         }\n         case 230: {\n+            printState(230); // XXX\n             for (int k = 0; k < npt; k++) {\n                 double suma = ZERO;\n                 double sumb = ZERO;\n                 double sum = ZERO;\n                 for (int j = 0; j < n; j++) {\n-                    suma += xpt.getEntry(k, j) * d__.getEntry(j);\n-                    sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n-                    sum += bmat.getEntry(k, j) * d__.getEntry(j);\n+                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n+                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n+                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                 }\n                 work3.setEntry(k, suma * (HALF * suma + sumb));\n-                vlag.setEntry(k, sum);\n+                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                 work2.setEntry(k, suma);\n             }\n             beta = ZERO;\n             for (int m = 0; m < nptm; m++) {\n                 double sum = ZERO;\n                 for (int k = 0; k < npt; k++) {\n-                    sum += zmat.getEntry(k, m) * work3.getEntry(k);\n+                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                 }\n                 beta -= sum * sum;\n                 for (int k = 0; k < npt; k++) {\n-                    vlag.setEntry(k, vlag.getEntry(k) + sum * zmat.getEntry(k, m));\n+                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                 }\n             }\n             dsq = ZERO;\n             double dx = ZERO;\n             for (int j = 0; j < n; j++) {\n                 // Computing 2nd power\n-                final double d1 = d__.getEntry(j);\n+                final double d1 = trialStepPoint.getEntry(j);\n                 dsq += d1 * d1;\n                 double sum = ZERO;\n                 for (int k = 0; k < npt; k++) {\n-                    sum += work3.getEntry(k) * bmat.getEntry(k, j);\n-                }\n-                bsum += sum * d__.getEntry(j);\n+                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n+                }\n+                bsum += sum * trialStepPoint.getEntry(j);\n                 final int jp = npt + j;\n                 for (int i = 0; i < n; i++) {\n-                    sum += bmat.getEntry(jp, i) * d__.getEntry(i);\n-                }\n-                vlag.setEntry(jp, sum);\n-                bsum += sum * d__.getEntry(j);\n-                dx += d__.getEntry(j) * xopt.getEntry(j);\n+                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n+                }\n+                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n+                bsum += sum * trialStepPoint.getEntry(j);\n+                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n             }\n \n             beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n             // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n             // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n \n-            vlag.setEntry(trustRegionCenterInterpolationPointIndex,\n-                          vlag.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n+            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n+                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n \n             // If NTRITS is zero, the denominator may be increased by replacing\n             // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n \n             if (ntrits == 0) {\n                 // Computing 2nd power\n-                final double d1 = vlag.getEntry(knew);\n+                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                 denom = d1 * d1 + alpha * beta;\n                 if (denom < cauchy && cauchy > ZERO) {\n                     for (int i = 0; i < n; i++) {\n-                        xnew.setEntry(i, xalt.getEntry(i));\n-                        d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n+                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n+                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                     }\n                     cauchy = ZERO; // XXX Useful statement?\n                     state = 230; break;\n                     double hdiag = ZERO;\n                     for (int m = 0; m < nptm; m++) {\n                         // Computing 2nd power\n-                        final double d1 = zmat.getEntry(k, m);\n+                        final double d1 = zMatrix.getEntry(k, m);\n                         hdiag += d1 * d1;\n                     }\n                     // Computing 2nd power\n-                    final double d2 = vlag.getEntry(k);\n+                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                     final double den = beta * hdiag + d2 * d2;\n                     distsq = ZERO;\n                     for (int j = 0; j < n; j++) {\n                         // Computing 2nd power\n-                        final double d3 = xpt.getEntry(k, j) - xopt.getEntry(j);\n+                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                         distsq += d3 * d3;\n                     }\n                     // Computing MAX\n                     }\n                     // Computing MAX\n                     // Computing 2nd power\n-                    final double d5 = vlag.getEntry(k);\n+                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                     biglsq = Math.max(biglsq, temp * (d5 * d5));\n                 }\n             }\n \n         }\n         case 360: {\n+            printState(360); // XXX\n             for (int i = 0; i < n; i++) {\n                 // Computing MIN\n                 // Computing MAX\n                 final double d3 = lowerBound[i];\n-                final double d4 = xbase.getEntry(i) + xnew.getEntry(i);\n+                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                 final double d1 = Math.max(d3, d4);\n                 final double d2 = upperBound[i];\n                 currentBest.setEntry(i, Math.min(d1, d2));\n-                if (xnew.getEntry(i) == sl.getEntry(i)) {\n+                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                     currentBest.setEntry(i, lowerBound[i]);\n                 }\n-                if (xnew.getEntry(i) == su.getEntry(i)) {\n+                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                     currentBest.setEntry(i, upperBound[i]);\n                 }\n             }\n             // Use the quadratic model to predict the change in F due to the step D,\n             //   and set DIFF to the error of this prediction.\n \n-            final double fopt = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n+            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n             double vquad = ZERO;\n             int ih = 0;\n             for (int j = 0; j < n; j++) {\n-                vquad += d__.getEntry(j) * gopt.getEntry(j);\n+                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                 for (int i = 0; i <= j; i++) {\n-                    double temp = d__.getEntry(i) * d__.getEntry(j);\n+                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                     if (i == j) {\n                         temp *= HALF;\n                     }\n-                    vquad += hq.getEntry(ih) * temp;\n+                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                     ih++;\n                }\n             }\n                 // Computing 2nd power\n                 final double d1 = work2.getEntry(k);\n                 final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n-                vquad += HALF * pq.getEntry(k) * d2;\n+                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n             }\n             final double diff = f - fopt - vquad;\n             diffc = diffb;\n                         double hdiag = ZERO;\n                         for (int m = 0; m < nptm; m++) {\n                             // Computing 2nd power\n-                            final double d1 = zmat.getEntry(k, m);\n+                            final double d1 = zMatrix.getEntry(k, m);\n                             hdiag += d1 * d1;\n                         }\n                         // Computing 2nd power\n-                        final double d1 = vlag.getEntry(k);\n+                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                         final double den = beta * hdiag + d1 * d1;\n                         distsq = ZERO;\n                         for (int j = 0; j < n; j++) {\n                             // Computing 2nd power\n-                            final double d2 = xpt.getEntry(k, j) - xnew.getEntry(j);\n+                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                             distsq += d2 * d2;\n                         }\n                         // Computing MAX\n                         }\n                         // Computing MAX\n                         // Computing 2nd power\n-                        final double d4 = vlag.getEntry(k);\n+                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                         final double d5 = temp * (d4 * d4);\n                         biglsq = Math.max(biglsq, d5);\n                     }\n             // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n             // moved. Also update the second derivative terms of the model.\n \n-            update(bmat, zmat, vlag,\n-                   beta, denom, knew);\n+            update(beta, denom, knew);\n \n             ih = 0;\n-            final double pqold = pq.getEntry(knew);\n-            pq.setEntry(knew, ZERO);\n+            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n+            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n             for (int i = 0; i < n; i++) {\n-                final double temp = pqold * xpt.getEntry(knew, i);\n+                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                 for (int j = 0; j <= i; j++) {\n-                    hq.setEntry(ih, hq.getEntry(ih) + temp * xpt.getEntry(knew, j));\n+                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                     ih++;\n                 }\n             }\n             for (int m = 0; m < nptm; m++) {\n-                final double temp = diff * zmat.getEntry(knew, m);\n+                final double temp = diff * zMatrix.getEntry(knew, m);\n                 for (int k = 0; k < npt; k++) {\n-                    pq.setEntry(k, pq.getEntry(k) + temp * zmat.getEntry(k, m));\n+                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                 }\n             }\n \n             // Include the new interpolation point, and make the changes to GOPT at\n             // the old XOPT that are caused by the updating of the quadratic model.\n \n-            fval.setEntry(knew,  f);\n+            fAtInterpolationPoints.setEntry(knew,  f);\n             for (int i = 0; i < n; i++) {\n-                xpt.setEntry(knew, i, xnew.getEntry(i));\n-                work1.setEntry(i, bmat.getEntry(knew, i));\n+                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n+                work1.setEntry(i, bMatrix.getEntry(knew, i));\n             }\n             for (int k = 0; k < npt; k++) {\n                 double suma = ZERO;\n                 for (int m = 0; m < nptm; m++) {\n-                    suma += zmat.getEntry(knew, m) * zmat.getEntry(k, m);\n+                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                 }\n                 double sumb = ZERO;\n                 for (int j = 0; j < n; j++) {\n-                    sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n+                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                 }\n                 final double temp = suma * sumb;\n                 for (int i = 0; i < n; i++) {\n-                    work1.setEntry(i, work1.getEntry(i) + temp * xpt.getEntry(k, i));\n+                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                 }\n             }\n             for (int i = 0; i < n; i++) {\n-                gopt.setEntry(i, gopt.getEntry(i) + diff * work1.getEntry(i));\n+                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n             }\n \n             // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n                 xoptsq = ZERO;\n                 ih = 0;\n                 for (int j = 0; j < n; j++) {\n-                    xopt.setEntry(j, xnew.getEntry(j));\n+                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                     // Computing 2nd power\n-                    final double d1 = xopt.getEntry(j);\n+                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                     xoptsq += d1 * d1;\n                     for (int i = 0; i <= j; i++) {\n                         if (i < j) {\n-                            gopt.setEntry(j, gopt.getEntry(j) + hq.getEntry(ih) * d__.getEntry(i));\n+                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                         }\n-                        gopt.setEntry(i, gopt.getEntry(i) + hq.getEntry(ih) * d__.getEntry(j));\n+                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                         ih++;\n                     }\n                 }\n                 for (int k = 0; k < npt; k++) {\n                     double temp = ZERO;\n                     for (int j = 0; j < n; j++) {\n-                        temp += xpt.getEntry(k, j) * d__.getEntry(j);\n-                    }\n-                    temp *= pq.getEntry(k);\n+                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n+                    }\n+                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                     for (int i = 0; i < n; i++) {\n-                        gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n+                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                     }\n                 }\n             }\n \n             if (ntrits > 0) {\n                 for (int k = 0; k < npt; k++) {\n-                    vlag.setEntry(k, fval.getEntry(k) - fval.getEntry(trustRegionCenterInterpolationPointIndex));\n+                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                     work3.setEntry(k, ZERO);\n                 }\n                 for (int j = 0; j < nptm; j++) {\n                     double sum = ZERO;\n                     for (int k = 0; k < npt; k++) {\n-                        sum += zmat.getEntry(k, j) * vlag.getEntry(k);\n+                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                     }\n                     for (int k = 0; k < npt; k++) {\n-                        work3.setEntry(k, work3.getEntry(k) + sum * zmat.getEntry(k, j));\n+                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                     }\n                 }\n                 for (int k = 0; k < npt; k++) {\n                     double sum = ZERO;\n                     for (int j = 0; j < n; j++) {\n-                        sum += xpt.getEntry(k, j) * xopt.getEntry(j);\n+                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                     }\n                     work2.setEntry(k, work3.getEntry(k));\n                     work3.setEntry(k, sum * work3.getEntry(k));\n                 for (int i = 0; i < n; i++) {\n                     double sum = ZERO;\n                     for (int k = 0; k < npt; k++) {\n-                        sum += bmat.getEntry(k, i) *\n-                            vlag.getEntry(k) + xpt.getEntry(k, i) * work3.getEntry(k);\n-                    }\n-                    if (xopt.getEntry(i) == sl.getEntry(i)) {\n+                        sum += bMatrix.getEntry(k, i) *\n+                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n+                    }\n+                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                         // Computing MIN\n                         // Computing 2nd power\n-                        final double d1 = Math.min(ZERO, gopt.getEntry(i));\n+                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                         gqsq += d1 * d1;\n                         // Computing 2nd power\n                         final double d2 = Math.min(ZERO, sum);\n                         gisq += d2 * d2;\n-                    } else if (xopt.getEntry(i) == su.getEntry(i)) {\n+                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                         // Computing MAX\n                         // Computing 2nd power\n-                        final double d1 = Math.max(ZERO, gopt.getEntry(i));\n+                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                         gqsq += d1 * d1;\n                         // Computing 2nd power\n                         final double d2 = Math.max(ZERO, sum);\n                         gisq += d2 * d2;\n                     } else {\n                         // Computing 2nd power\n-                        final double d1 = gopt.getEntry(i);\n+                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                         gqsq += d1 * d1;\n                         gisq += sum * sum;\n                     }\n-                    vlag.setEntry(npt + i, sum);\n+                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                 }\n \n                 // Test whether to replace the new quadratic model by the least Frobenius\n                 if (itest >= 3) {\n                     for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                         if (i < n) {\n-                            gopt.setEntry(i, vlag.getEntry(npt + i));\n+                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                         }\n                         if (i < npt) {\n-                            pq.setEntry(i, work2.getEntry(i));\n+                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                         }\n                         if (i < nh) {\n-                            hq.setEntry(i, ZERO);\n+                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                         }\n                         itest = 0;\n                     }\n             distsq = Math.max(d1 * d1, d2 * d2);\n         }\n         case 650: {\n+            printState(650); // XXX\n             knew = -1;\n             for (int k = 0; k < npt; k++) {\n                 double sum = ZERO;\n                 for (int j = 0; j < n; j++) {\n                     // Computing 2nd power\n-                    final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n+                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                     sum += d1 * d1;\n                 }\n                 if (sum > distsq) {\n             //   next values of RHO and DELTA.\n         }\n         case 680: {\n+            printState(680); // XXX\n             if (rho > stoppingTrustRegionRadius) {\n                 delta = HALF * rho;\n                 ratio = rho / stoppingTrustRegionRadius;\n             }\n         }\n         case 720: {\n-            if (fval.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n+            printState(720); // XXX\n+            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                 for (int i = 0; i < n; i++) {\n                     // Computing MIN\n                     // Computing MAX\n                     final double d3 = lowerBound[i];\n-                    final double d4 = xbase.getEntry(i) + xopt.getEntry(i);\n+                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                     final double d1 = Math.max(d3, d4);\n                     final double d2 = upperBound[i];\n                     currentBest.setEntry(i, Math.min(d1, d2));\n-                    if (xopt.getEntry(i) == sl.getEntry(i)) {\n+                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                         currentBest.setEntry(i, lowerBound[i]);\n                     }\n-                    if (xopt.getEntry(i) == su.getEntry(i)) {\n+                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                         currentBest.setEntry(i, upperBound[i]);\n                     }\n                 }\n-                f = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n+                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n             }\n             return f;\n         }\n      *\n      *     Set the first NPT components of W to the leading elements of the\n      *     KNEW-th column of the H matrix.\n-     * @param xpt\n-     * @param xopt\n-     * @param bmat\n-     * @param zmat\n-     * @param sl\n-     * @param su\n      * @param knew\n      * @param adelt\n-     * @param xnew\n-     * @param xalt\n      */\n     private double[] altmov(\n-            Array2DRowRealMatrix xpt,\n-            ArrayRealVector xopt,\n-            Array2DRowRealMatrix bmat,\n-            Array2DRowRealMatrix zmat,\n-            ArrayRealVector sl,\n-            ArrayRealVector su,\n             int knew,\n-            double adelt,\n-            ArrayRealVector xnew,\n-            ArrayRealVector xalt\n+            double adelt\n     ) {\n-        // System.out.println(\"altmov\"); // XXX\n+        printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n         final int npt = numberOfInterpolationPoints;\n             hcol.setEntry(k, ZERO);\n         }\n         for (int j = 0, max = npt - n - 1; j < max; j++) {\n-            final double tmp = zmat.getEntry(knew, j);\n+            final double tmp = zMatrix.getEntry(knew, j);\n             for (int k = 0; k < npt; k++) {\n-                hcol.setEntry(k, hcol.getEntry(k) + tmp * zmat.getEntry(k, j));\n+                hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));\n             }\n         }\n         final double alpha = hcol.getEntry(knew);\n         // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n \n         for (int i = 0; i < n; i++) {\n-            glag.setEntry(i, bmat.getEntry(knew, i));\n+            glag.setEntry(i, bMatrix.getEntry(knew, i));\n         }\n         for (int k = 0; k < npt; k++) {\n             double tmp = ZERO;\n             for (int j = 0; j < n; j++) {\n-                tmp += xpt.getEntry(k, j) * xopt.getEntry(j);\n+                tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n             }\n             tmp *= hcol.getEntry(k);\n             for (int i = 0; i < n; i++) {\n-                glag.setEntry(i, glag.getEntry(i) + tmp * xpt.getEntry(k, i));\n+                glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));\n             }\n         }\n \n             double dderiv = ZERO;\n             double distsq = ZERO;\n             for (int i = 0; i < n; i++) {\n-                final double tmp = xpt.getEntry(k, i) - xopt.getEntry(i);\n+                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                 dderiv += glag.getEntry(i) * tmp;\n                 distsq += tmp * tmp;\n             }\n             // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n \n             for (int i = 0; i < n; i++) {\n-                final double tmp = xpt.getEntry(k, i) - xopt.getEntry(i);\n+                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                 if (tmp > ZERO) {\n-                    if (slbd * tmp < sl.getEntry(i) - xopt.getEntry(i)) {\n-                        slbd = (sl.getEntry(i) - xopt.getEntry(i)) / tmp;\n+                    if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n+                        slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                         ilbd = -i - 1;\n                     }\n-                    if (subd * tmp > su.getEntry(i) - xopt.getEntry(i)) {\n+                    if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                         // Computing MAX\n                         subd = Math.max(sumin,\n-                                        (su.getEntry(i) - xopt.getEntry(i)) / tmp);\n+                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                         iubd = i + 1;\n                     }\n                 } else if (tmp < ZERO) {\n-                    if (slbd * tmp > su.getEntry(i) - xopt.getEntry(i)) {\n-                        slbd = (su.getEntry(i) - xopt.getEntry(i)) / tmp;\n+                    if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n+                        slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                         ilbd = i + 1;\n                     }\n-                    if (subd * tmp < sl.getEntry(i) - xopt.getEntry(i)) {\n+                    if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                         // Computing MAX\n                         subd = Math.max(sumin,\n-                                        (sl.getEntry(i) - xopt.getEntry(i)) / tmp);\n+                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                         iubd = -i - 1;\n                     }\n                 }\n         // Construct XNEW in a way that satisfies the bound constraints exactly.\n \n         for (int i = 0; i < n; i++) {\n-            final double tmp = xopt.getEntry(i) + stpsav * (xpt.getEntry(ksav, i) - xopt.getEntry(i));\n-            xnew.setEntry(i, Math.max(sl.getEntry(i),\n-                                      Math.min(su.getEntry(i), tmp)));\n+            final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));\n+            newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n+                                      Math.min(upperDifference.getEntry(i), tmp)));\n         }\n         if (ibdsav < 0) {\n-            xnew.setEntry(-ibdsav - 1, sl.getEntry(-ibdsav - 1));\n+            newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));\n         }\n         if (ibdsav > 0) {\n-            xnew.setEntry(ibdsav - 1, su.getEntry(ibdsav - 1));\n+            newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));\n         }\n \n         // Prepare for the iterative method that assembles the constrained Cauchy\n             for (int i = 0; i < n; i++) {\n                 final double glagValue = glag.getEntry(i);\n                 work1.setEntry(i, ZERO);\n-                if (Math.min(xopt.getEntry(i) - sl.getEntry(i), glagValue) > ZERO ||\n-                    Math.max(xopt.getEntry(i) - su.getEntry(i), glagValue) < ZERO) {\n+                if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n+                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO) {\n                     work1.setEntry(i, bigstp);\n                     // Computing 2nd power\n                     ggfree += glagValue * glagValue;\n                 ggfree = ZERO;\n                 for (int i = 0; i < n; i++) {\n                     if (work1.getEntry(i) == bigstp) {\n-                        final double tmp2 = xopt.getEntry(i) - step * glag.getEntry(i);\n-                        if (tmp2 <= sl.getEntry(i)) {\n-                            work1.setEntry(i, sl.getEntry(i) - xopt.getEntry(i));\n+                        final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);\n+                        if (tmp2 <= lowerDifference.getEntry(i)) {\n+                            work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                             // Computing 2nd power\n                             final double d1 = work1.getEntry(i);\n                             wfixsq += d1 * d1;\n-                        } else if (tmp2 >= su.getEntry(i)) {\n-                            work1.setEntry(i, su.getEntry(i) - xopt.getEntry(i));\n+                        } else if (tmp2 >= upperDifference.getEntry(i)) {\n+                            work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                             // Computing 2nd power\n                             final double d1 = work1.getEntry(i);\n                             wfixsq += d1 * d1;\n                 final double glagValue = glag.getEntry(i);\n                 if (work1.getEntry(i) == bigstp) {\n                     work1.setEntry(i, -step * glagValue);\n-                    final double min = Math.min(su.getEntry(i),\n-                                                xopt.getEntry(i) + work1.getEntry(i));\n-                    xalt.setEntry(i, Math.max(sl.getEntry(i), min));\n+                    final double min = Math.min(upperDifference.getEntry(i),\n+                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));\n+                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));\n                 } else if (work1.getEntry(i) == ZERO) {\n-                    xalt.setEntry(i, xopt.getEntry(i));\n+                    alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));\n                 } else if (glagValue > ZERO) {\n-                    xalt.setEntry(i, sl.getEntry(i));\n+                    alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));\n                 } else {\n-                    xalt.setEntry(i, su.getEntry(i));\n+                    alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));\n                 }\n                 gw += glagValue * work1.getEntry(i);\n             }\n             for (int k = 0; k < npt; k++) {\n                 double tmp = ZERO;\n                 for (int j = 0; j < n; j++) {\n-                    tmp += xpt.getEntry(k, j) * work1.getEntry(j);\n+                    tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);\n                 }\n                 curv += hcol.getEntry(k) * tmp * tmp;\n             }\n                 curv < -gw * (ONE + Math.sqrt(TWO))) {\n                 final double scale = -gw / curv;\n                 for (int i = 0; i < n; i++) {\n-                    final double tmp = xopt.getEntry(i) + scale * work1.getEntry(i);\n-                    xalt.setEntry(i, Math.max(sl.getEntry(i),\n-                                              Math.min(su.getEntry(i), tmp)));\n+                    final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);\n+                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n+                                              Math.min(upperDifference.getEntry(i), tmp)));\n                 }\n                 // Computing 2nd power\n                 final double d1 = HALF * gw * scale;\n             if (iflag == 0) {\n                 for (int i = 0; i < n; i++) {\n                     glag.setEntry(i, -glag.getEntry(i));\n-                    work2.setEntry(i, xalt.getEntry(i));\n+                    work2.setEntry(i, alternativeNewPoint.getEntry(i));\n                 }\n                 csave = cauchy;\n                 iflag = 1;\n         }\n         if (csave > cauchy) {\n             for (int i = 0; i < n; i++) {\n-                xalt.setEntry(i, work2.getEntry(i));\n+                alternativeNewPoint.setEntry(i, work2.getEntry(i));\n             }\n             cauchy = csave;\n         }\n      *     KOPT will be such that the least calculated value of F so far is at\n      *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n      *\n-     * @param currentBest\n-     * @param xbase\n-     * @param xpt\n-     * @param fval\n-     * @param gopt\n-     * @param hq\n-     * @param pq\n-     * @param bmat\n-     * @param zmat\n-     * @param sl\n-     * @param su\n-     */\n-    private void prelim(\n-            ArrayRealVector currentBest,\n-            ArrayRealVector xbase,\n-            Array2DRowRealMatrix xpt,\n-            ArrayRealVector fval,\n-            ArrayRealVector gopt,\n-            ArrayRealVector hq,\n-            ArrayRealVector pq,\n-            Array2DRowRealMatrix bmat,\n-            Array2DRowRealMatrix zmat,\n-            ArrayRealVector sl,\n-            ArrayRealVector su\n-    ) {\n-        // System.out.println(\"prelim\"); // XXX\n+     */\n+    private void prelim() {\n+        printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n         final int npt = numberOfInterpolationPoints;\n-        final int ndim = bmat.getRowDimension();\n+        final int ndim = bMatrix.getRowDimension();\n \n         final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n         final double recip = 1d / rhosq;\n         // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n \n         for (int j = 0; j < n; j++) {\n-            xbase.setEntry(j, currentBest.getEntry(j));\n+            originShift.setEntry(j, currentBest.getEntry(j));\n             for (int k = 0; k < npt; k++) {\n-                xpt.setEntry(k, j, ZERO);\n+                interpolationPoints.setEntry(k, j, ZERO);\n             }\n             for (int i = 0; i < ndim; i++) {\n-                bmat.setEntry(i, j, ZERO);\n+                bMatrix.setEntry(i, j, ZERO);\n             }\n         }\n         for (int i = 0, max = n * np / 2; i < max; i++) {\n-            hq.setEntry(i, ZERO);\n+            modelSecondDerivativesValues.setEntry(i, ZERO);\n         }\n         for (int k = 0; k < npt; k++) {\n-            pq.setEntry(k, ZERO);\n+            modelSecondDerivativesParameters.setEntry(k, ZERO);\n             for (int j = 0, max = npt - np; j < max; j++) {\n-                zmat.setEntry(k, j, ZERO);\n+                zMatrix.setEntry(k, j, ZERO);\n             }\n         }\n \n                 if (nfm >= 1 &&\n                     nfm <= n) {\n                     stepa = initialTrustRegionRadius;\n-                    if (su.getEntry(nfmm) == ZERO) {\n+                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                         stepa = -stepa;\n                         throw new PathIsExploredException(); // XXX\n                     }\n-                    xpt.setEntry(nfm, nfmm, stepa);\n+                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                 } else if (nfm > n) {\n-                    stepa = xpt.getEntry(nfx, nfxm);\n+                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                     stepb = -initialTrustRegionRadius;\n-                    if (sl.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.min(TWO * initialTrustRegionRadius, su.getEntry(nfxm));\n+                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n+                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                         throw new PathIsExploredException(); // XXX\n                     }\n-                    if (su.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.max(-TWO * initialTrustRegionRadius, sl.getEntry(nfxm));\n+                    if (upperDifference.getEntry(nfxm) == ZERO) {\n+                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                         throw new PathIsExploredException(); // XXX\n                     }\n-                    xpt.setEntry(nfm, nfxm, stepb);\n+                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                 }\n             } else {\n                 final int tmp1 = (nfm - np) / n;\n                     ipt = tmp2;\n                     throw new PathIsExploredException(); // XXX\n                 }\n-                xpt.setEntry(nfm, ipt, xpt.getEntry(ipt, ipt));\n-                xpt.setEntry(nfm, jpt, xpt.getEntry(jpt, jpt));\n+                interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));\n+                interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));\n             }\n \n             // Calculate the next value of F. The least function value so far and\n \n             for (int j = 0; j < n; j++) {\n                 currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n-                                                          xbase.getEntry(j) + xpt.getEntry(nfm, j)),\n+                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                  upperBound[j]));\n-                if (xpt.getEntry(nfm, j) == sl.getEntry(j)) {\n+                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                     currentBest.setEntry(j, lowerBound[j]);\n                 }\n-                if (xpt.getEntry(nfm, j) == su.getEntry(j)) {\n+                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                     currentBest.setEntry(j, upperBound[j]);\n                 }\n             }\n             final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n             final double f = isMinimize ? objectiveValue : -objectiveValue;\n             final int numEval = getEvaluations(); // nfm + 1\n-            fval.setEntry(nfm, f);\n+            fAtInterpolationPoints.setEntry(nfm, f);\n \n             if (numEval == 1) {\n                 fbeg = f;\n                 trustRegionCenterInterpolationPointIndex = 0;\n-            } else if (f < fval.getEntry(trustRegionCenterInterpolationPointIndex)) {\n+            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                 trustRegionCenterInterpolationPointIndex = nfm;\n             }\n \n             if (numEval <= 2 * n + 1) {\n                 if (numEval >= 2 &&\n                     numEval <= n + 1) {\n-                    gopt.setEntry(nfmm, (f - fbeg) / stepa);\n+                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                     if (npt < numEval + n) {\n                         final double oneOverStepA = ONE / stepa;\n-                        bmat.setEntry(0, nfmm, -oneOverStepA);\n-                        bmat.setEntry(nfm, nfmm, oneOverStepA);\n-                        bmat.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n+                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n+                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n+                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                         throw new PathIsExploredException(); // XXX\n                     }\n                 } else if (numEval >= n + 2) {\n                     final int ih = nfx * (nfx + 1) / 2 - 1;\n                     final double tmp = (f - fbeg) / stepb;\n                     final double diff = stepb - stepa;\n-                    hq.setEntry(ih, TWO * (tmp - gopt.getEntry(nfxm)) / diff);\n-                    gopt.setEntry(nfxm, (gopt.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n+                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n+                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                     if (stepa * stepb < ZERO) {\n-                        if (f < fval.getEntry(nfm - n)) {\n-                            fval.setEntry(nfm, fval.getEntry(nfm - n));\n-                            fval.setEntry(nfm - n, f);\n+                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n+                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n+                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                             if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                 trustRegionCenterInterpolationPointIndex = nfm - n;\n                             }\n-                            xpt.setEntry(nfm - n, nfxm, stepb);\n-                            xpt.setEntry(nfm, nfxm, stepa);\n+                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n+                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                         }\n                     }\n-                    bmat.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n-                    bmat.setEntry(nfm, nfxm, -HALF / xpt.getEntry(nfm - n, nfxm));\n-                    bmat.setEntry(nfm - n, nfxm,\n-                                  -bmat.getEntry(0, nfxm) - bmat.getEntry(nfm, nfxm));\n-                    zmat.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n-                    zmat.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n-                    // zmat.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n-                    zmat.setEntry(nfm - n, nfxm,\n-                                  -zmat.getEntry(0, nfxm) - zmat.getEntry(nfm, nfxm));\n+                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n+                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n+                    bMatrix.setEntry(nfm - n, nfxm,\n+                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n+                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n+                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n+                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n+                    zMatrix.setEntry(nfm - n, nfxm,\n+                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                 }\n \n                 // Set the off-diagonal second derivatives of the Lagrange functions and\n                 // the initial quadratic model.\n \n             } else {\n-                zmat.setEntry(0, nfxm, recip);\n-                zmat.setEntry(nfm, nfxm, recip);\n-                zmat.setEntry(ipt, nfxm, -recip);\n-                zmat.setEntry(jpt, nfxm, -recip);\n+                zMatrix.setEntry(0, nfxm, recip);\n+                zMatrix.setEntry(nfm, nfxm, recip);\n+                zMatrix.setEntry(ipt, nfxm, -recip);\n+                zMatrix.setEntry(jpt, nfxm, -recip);\n \n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n-                final double tmp = xpt.getEntry(nfm, ipt - 1) * xpt.getEntry(nfm, jpt - 1);\n-                hq.setEntry(ih, (fbeg - fval.getEntry(ipt) - fval.getEntry(jpt) + f) / tmp);\n+                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n+                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n                 throw new PathIsExploredException(); // XXX\n             }\n         } while (getEvaluations() < npt);\n      *       gradient searches that are not restricted by any constraints. The\n      *       value CRVMIN=-1.0D0 is set, however, if all of these searches are\n      *       constrained.\n-     * @param xpt\n-     * @param xopt\n-     * @param gopt\n-     * @param hq\n-     * @param pq\n-     * @param sl\n-     * @param su\n      * @param delta\n-     * @param xnew\n-     * @param d__\n      * @param gnew\n      * @param xbdi\n      * @param s\n      * @param hred\n      */\n     private double[] trsbox(\n-            Array2DRowRealMatrix xpt,\n-            ArrayRealVector xopt,\n-            ArrayRealVector gopt,\n-            ArrayRealVector hq,\n-            ArrayRealVector pq,\n-            ArrayRealVector sl,\n-            ArrayRealVector su,\n             double delta,\n-            ArrayRealVector xnew,\n-            ArrayRealVector d__,\n             ArrayRealVector gnew,\n             ArrayRealVector xbdi,\n             ArrayRealVector s,\n             ArrayRealVector hs,\n             ArrayRealVector hred\n     ) {\n-        // System.out.println(\"trsbox\"); // XXX\n+        printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n         final int npt = numberOfInterpolationPoints;\n         nact = 0;\n         for (int i = 0; i < n; i++) {\n             xbdi.setEntry(i, ZERO);\n-            if (xopt.getEntry(i) <= sl.getEntry(i)) {\n-                if (gopt.getEntry(i) >= ZERO) {\n+            if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i)) {\n+                if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) {\n                     xbdi.setEntry(i, MINUS_ONE);\n                 }\n-            } else if (xopt.getEntry(i) >= su.getEntry(i)) {\n-                if (gopt.getEntry(i) <= ZERO) {\n+            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i)) {\n+                if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n                     xbdi.setEntry(i, ONE);\n                 }\n             }\n             if (xbdi.getEntry(i) != ZERO) {\n                 ++nact;\n             }\n-            d__.setEntry(i, ZERO);\n-            gnew.setEntry(i, gopt.getEntry(i));\n+            trialStepPoint.setEntry(i, ZERO);\n+            gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));\n         }\n         delsq = delta * delta;\n         qred = ZERO;\n \n         int state = 20;\n         for(;;) {\n-            // System.out.println(\"loop in trsbox: state=\" + state); // XXX\n             switch (state) {\n         case 20: {\n+            printState(20); // XXX\n             beta = ZERO;\n         }\n         case 30: {\n+            printState(30); // XXX\n             stepsq = ZERO;\n             for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) != ZERO) {\n             state = 210; break;\n         }\n         case 50: {\n+            printState(50); // XXX\n             resid = delsq;\n             ds = ZERO;\n             shs = ZERO;\n             for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     // Computing 2nd power\n-                    final double d1 = d__.getEntry(i);\n+                    final double d1 = trialStepPoint.getEntry(i);\n                     resid -= d1 * d1;\n-                    ds += s.getEntry(i) * d__.getEntry(i);\n+                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                     shs += s.getEntry(i) * hs.getEntry(i);\n                 }\n             }\n             iact = -1;\n             for (int i = 0; i < n; i++) {\n                 if (s.getEntry(i) != ZERO) {\n-                    xsum = xopt.getEntry(i) + d__.getEntry(i);\n+                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                     if (s.getEntry(i) > ZERO) {\n-                        temp = (su.getEntry(i) - xsum) / s.getEntry(i);\n+                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                     } else {\n-                        temp = (sl.getEntry(i) - xsum) / s.getEntry(i);\n+                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                     }\n                     if (temp < stplen) {\n                         stplen = temp;\n                         final double d1 = gnew.getEntry(i);\n                         gredsq += d1 * d1;\n                     }\n-                    d__.setEntry(i, d__.getEntry(i) + stplen * s.getEntry(i));\n+                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                 }\n                 // Computing MAX\n                 final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                     xbdi.setEntry(iact, MINUS_ONE);\n                 }\n                 // Computing 2nd power\n-                final double d1 = d__.getEntry(iact);\n+                final double d1 = trialStepPoint.getEntry(iact);\n                 delsq -= d1 * d1;\n                 if (delsq <= ZERO) {\n                     state = 190; break;\n             }\n         }\n         case 90: {\n+            printState(90); // XXX\n             crvmin = ZERO;\n \n             // Prepare for the alternative iteration by calculating some scalars\n \n         }\n         case 100: {\n+            printState(100); // XXX\n             if (nact >= n - 1) {\n                 state = 190; break;\n             }\n             for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     // Computing 2nd power\n-                    double d1 = d__.getEntry(i);\n+                    double d1 = trialStepPoint.getEntry(i);\n                     dredsq += d1 * d1;\n-                    dredg += d__.getEntry(i) * gnew.getEntry(i);\n+                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                     // Computing 2nd power\n                     d1 = gnew.getEntry(i);\n                     gredsq += d1 * d1;\n-                    s.setEntry(i, d__.getEntry(i));\n+                    s.setEntry(i, trialStepPoint.getEntry(i));\n                 } else {\n                     s.setEntry(i, ZERO);\n                 }\n             // and the reduced G that is orthogonal to the reduced D.\n         }\n         case 120: {\n+            printState(120); // XXX\n             ++iterc;\n             temp = gredsq * dredsq - dredg * dredg;\n             if (temp <= qred * 1e-4 * qred) {\n             temp = Math.sqrt(temp);\n             for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n-                    s.setEntry(i, (dredg * d__.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n+                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                 } else {\n                     s.setEntry(i, ZERO);\n                 }\n             iact = -1;\n             for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n-                    tempa = xopt.getEntry(i) + d__.getEntry(i) - sl.getEntry(i);\n-                    tempb = su.getEntry(i) - xopt.getEntry(i) - d__.getEntry(i);\n+                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n+                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                     if (tempa <= ZERO) {\n                         ++nact;\n                         xbdi.setEntry(i, MINUS_ONE);\n                         state = 100; break;\n                     }\n                     // Computing 2nd power\n-                    double d1 = d__.getEntry(i);\n+                    double d1 = trialStepPoint.getEntry(i);\n                     // Computing 2nd power\n                     double d2 = s.getEntry(i);\n                     ssq = d1 * d1 + d2 * d2;\n                     // Computing 2nd power\n-                    d1 = xopt.getEntry(i) - sl.getEntry(i);\n+                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                     temp = ssq - d1 * d1;\n                     if (temp > ZERO) {\n                         temp = Math.sqrt(temp) - s.getEntry(i);\n                         }\n                     }\n                     // Computing 2nd power\n-                    d1 = su.getEntry(i) - xopt.getEntry(i);\n+                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                     temp = ssq - d1 * d1;\n                     if (temp > ZERO) {\n                         temp = Math.sqrt(temp) + s.getEntry(i);\n             state = 210; break;\n         }\n         case 150: {\n+            printState(150); // XXX\n             shs = ZERO;\n             dhs = ZERO;\n             dhd = ZERO;\n             for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     shs += s.getEntry(i) * hs.getEntry(i);\n-                    dhs += d__.getEntry(i) * hs.getEntry(i);\n-                    dhd += d__.getEntry(i) * hred.getEntry(i);\n+                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n+                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                 }\n             }\n \n             for (int i = 0; i < n; i++) {\n                 gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                 if (xbdi.getEntry(i) == ZERO) {\n-                    d__.setEntry(i, cth * d__.getEntry(i) + sth * s.getEntry(i));\n-                    dredg += d__.getEntry(i) * gnew.getEntry(i);\n+                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n+                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                     // Computing 2nd power\n                     final double d1 = gnew.getEntry(i);\n                     gredsq += d1 * d1;\n             }\n         }\n         case 190: {\n+            printState(190); // XXX\n             dsq = ZERO;\n             for (int i = 0; i < n; i++) {\n                 // Computing MAX\n                 // Computing MIN\n-                final double min = Math.min(xopt.getEntry(i) + d__.getEntry(i),\n-                                            su.getEntry(i));\n-                xnew.setEntry(i, Math.max(min, sl.getEntry(i)));\n+                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n+                                            upperDifference.getEntry(i));\n+                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                 if (xbdi.getEntry(i) == MINUS_ONE) {\n-                    xnew.setEntry(i, sl.getEntry(i));\n+                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                 }\n                 if (xbdi.getEntry(i) == ONE) {\n-                    xnew.setEntry(i, su.getEntry(i));\n-                }\n-                d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n+                    newPoint.setEntry(i, upperDifference.getEntry(i));\n+                }\n+                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                 // Computing 2nd power\n-                final double d1 = d__.getEntry(i);\n+                final double d1 = trialStepPoint.getEntry(i);\n                 dsq += d1 * d1;\n             }\n             return new double[] { dsq, crvmin };\n             // they can be regarded as an external subroutine.\n         }\n         case 210: {\n+            printState(210); // XXX\n             int ih = 0;\n             for (int j = 0; j < n; j++) {\n                 hs.setEntry(j, ZERO);\n                 for (int i = 0; i <= j; i++) {\n                     if (i < j) {\n-                        hs.setEntry(j, hs.getEntry(j) + hq.getEntry(ih) * s.getEntry(i));\n-                    }\n-                    hs.setEntry(i, hs.getEntry(i) + hq.getEntry(ih) * s.getEntry(j));\n+                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n+                    }\n+                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                     ih++;\n                 }\n             }\n-            final RealVector tmp = xpt.operate(s).ebeMultiply(pq);\n+            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n             for (int k = 0; k < npt; k++) {\n-                if (pq.getEntry(k) != ZERO) {\n+                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                     for (int i = 0; i < n; i++) {\n-                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * xpt.getEntry(k, i));\n+                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                     }\n                 }\n             }\n      *     with that name, and DENOM is set to the denominator of the updating\n      *     formula. Elements of ZMAT may be treated as zero if their moduli are\n      *     at most ZTEST. The first NDIM elements of W are used for working space.\n-     * @param bmat\n-     * @param zmat\n-     * @param vlag\n      * @param beta\n      * @param denom\n      * @param knew\n      */\n     private void update(\n-            Array2DRowRealMatrix bmat,\n-            Array2DRowRealMatrix zmat,\n-            ArrayRealVector vlag,\n             double beta,\n             double denom,\n             int knew\n     ) {\n-        // System.out.println(\"update\"); // XXX\n+        printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n         final int npt = numberOfInterpolationPoints;\n         for (int k = 0; k < npt; k++) {\n             for (int j = 0; j < nptm; j++) {\n                 // Computing MAX\n-                ztest = Math.max(ztest, Math.abs(zmat.getEntry(k, j)));\n+                ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));\n             }\n         }\n         ztest *= 1e-20;\n         // Apply the rotations that put zeros in the KNEW-th row of ZMAT.\n \n         for (int j = 1; j < nptm; j++) {\n-            final double d1 = zmat.getEntry(knew, j);\n+            final double d1 = zMatrix.getEntry(knew, j);\n             if (Math.abs(d1) > ztest) {\n                 // Computing 2nd power\n-                final double d2 = zmat.getEntry(knew, 0);\n+                final double d2 = zMatrix.getEntry(knew, 0);\n                 // Computing 2nd power\n-                final double d3 = zmat.getEntry(knew, j);\n+                final double d3 = zMatrix.getEntry(knew, j);\n                 final double d4 = Math.sqrt(d2 * d2 + d3 * d3);\n-                final double d5 = zmat.getEntry(knew, 0) / d4;\n-                final double d6 = zmat.getEntry(knew, j) / d4;\n+                final double d5 = zMatrix.getEntry(knew, 0) / d4;\n+                final double d6 = zMatrix.getEntry(knew, j) / d4;\n                 for (int i = 0; i < npt; i++) {\n-                    final double d7 = d5 * zmat.getEntry(i, 0) + d6 * zmat.getEntry(i, j);\n-                    zmat.setEntry(i, j, d5 * zmat.getEntry(i, j) - d6 * zmat.getEntry(i, 0));\n-                    zmat.setEntry(i, 0, d7);\n-                }\n-            }\n-            zmat.setEntry(knew, j, ZERO);\n+                    final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);\n+                    zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));\n+                    zMatrix.setEntry(i, 0, d7);\n+                }\n+            }\n+            zMatrix.setEntry(knew, j, ZERO);\n         }\n \n         // Put the first NPT components of the KNEW-th column of HLAG into W,\n         // and calculate the parameters of the updating formula.\n \n         for (int i = 0; i < npt; i++) {\n-            work.setEntry(i, zmat.getEntry(knew, 0) * zmat.getEntry(i, 0));\n+            work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));\n         }\n         final double alpha = work.getEntry(knew);\n-        final double tau = vlag.getEntry(knew);\n-        vlag.setEntry(knew, vlag.getEntry(knew) - ONE);\n+        final double tau = lagrangeValuesAtNewPoint.getEntry(knew);\n+        lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);\n \n         // Complete the updating of ZMAT.\n \n         final double sqrtDenom = Math.sqrt(denom);\n         final double d1 = tau / sqrtDenom;\n-        final double d2 = zmat.getEntry(knew, 0) / sqrtDenom;\n+        final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;\n         for (int i = 0; i < npt; i++) {\n-            zmat.setEntry(i, 0,\n-                          d1 * zmat.getEntry(i, 0) - d2 * vlag.getEntry(i));\n+            zMatrix.setEntry(i, 0,\n+                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));\n         }\n \n         // Finally, update the matrix BMAT.\n \n         for (int j = 0; j < n; j++) {\n             final int jp = npt + j;\n-            work.setEntry(jp, bmat.getEntry(knew, j));\n-            final double d3 = (alpha * vlag.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n-            final double d4 = (-beta * work.getEntry(jp) - tau * vlag.getEntry(jp)) / denom;\n+            work.setEntry(jp, bMatrix.getEntry(knew, j));\n+            final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n+            final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;\n             for (int i = 0; i <= jp; i++) {\n-                bmat.setEntry(i, j,\n-                              bmat.getEntry(i, j) + d3 * vlag.getEntry(i) + d4 * work.getEntry(i));\n+                bMatrix.setEntry(i, j,\n+                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));\n                 if (i >= npt) {\n-                    bmat.setEntry(jp, (i - npt), bmat.getEntry(i, j));\n+                    bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));\n                 }\n             }\n         }\n      * {@link #upperBound} array if no constraints were provided.\n      */\n     private void setup() {\n-        // System.out.println(\"setup\"); // XXX\n+        printMethod(); // XXX\n \n         double[] init = getStartPoint();\n         final int dimension = init.length;\n         if (minDiff < requiredMinDiff) {\n             initialTrustRegionRadius = minDiff / 3.0;\n         }\n+\n+        // Initialize the data structures used by the \"bobyqa\" method.\n+        bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n+                                           dimension);\n+        zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n+                                           numberOfInterpolationPoints - dimension - 1);\n+        interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n+                                                       dimension);\n+        originShift = new ArrayRealVector(dimension);\n+        fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\n+        trustRegionCenterOffset = new ArrayRealVector(dimension);\n+        gradientAtTrustRegionCenter = new ArrayRealVector(dimension);\n+        lowerDifference = new ArrayRealVector(dimension);\n+        upperDifference = new ArrayRealVector(dimension);\n+        modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\n+        newPoint = new ArrayRealVector(dimension);\n+        alternativeNewPoint = new ArrayRealVector(dimension);\n+        trialStepPoint = new ArrayRealVector(dimension);\n+        lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\n+        modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n     }\n \n     /**\n         double[] ds = new double[n];\n         Arrays.fill(ds, value);\n         return ds;\n+    }\n+\n+    // XXX utility for figuring out call sequence.\n+    private static String caller(int n) {\n+        final Throwable t = new Throwable();\n+        final StackTraceElement[] elements = t.getStackTrace();\n+        final StackTraceElement e = elements[n];\n+        return e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";\n+    }\n+    // XXX utility for figuring out call sequence.\n+    private static void printState(int s) {\n+        //        System.out.println(caller(2) + \": state \" + s);\n+    }\n+    // XXX utility for figuring out call sequence.\n+    private static void printMethod() {\n+        //        System.out.println(caller(2));\n     }\n }\n \n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.junit.Assert;\n import org.junit.Test;\n+import org.junit.Ignore;\n \n /**\n  * Test for {@link BOBYQAOptimizer}.", "timestamp": 1319490572, "metainfo": ""}