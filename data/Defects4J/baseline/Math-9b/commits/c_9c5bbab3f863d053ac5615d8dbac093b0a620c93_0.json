{"sha": "9c5bbab3f863d053ac5615d8dbac093b0a620c93", "log": "Added accurate linear combinations for DerivativeStructure instances.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n import java.util.Comparator;\n import java.util.Collections;\n \n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n         }\n \n         return result;\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     *\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)\n+        throws DimensionMismatchException {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double[] aDouble = new double[a.length];\n+        for (int i = 0; i < a.length; ++i) {\n+            aDouble[i] = a[i].getValue();\n+        }\n+        final double[] bDouble = new double[b.length];\n+        for (int i = 0; i < b.length; ++i) {\n+            bDouble[i] = b[i].getValue();\n+        }\n+        final double accurateValue = MathArrays.linearCombination(aDouble, bDouble);\n+\n+        // compute a simple value, with all partial derivatives\n+        DerivativeStructure simpleValue = a[0].getField().getZero();\n+        for (int i = 0; i < a.length; ++i) {\n+            simpleValue = simpleValue.add(a[i].multiply(b[i]));\n+        }\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     *\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     */\n+    public static DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)\n+        throws DimensionMismatchException {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double[] bDouble = new double[b.length];\n+        for (int i = 0; i < b.length; ++i) {\n+            bDouble[i] = b[i].getValue();\n+        }\n+        final double accurateValue = MathArrays.linearCombination(a, bDouble);\n+\n+        // compute a simple value, with all partial derivatives\n+        DerivativeStructure simpleValue = b[0].getField().getZero();\n+        for (int i = 0; i < a.length; ++i) {\n+            simpleValue = simpleValue.add(b[i].multiply(a[i]));\n+        }\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n+                                                        final DerivativeStructure a2, final DerivativeStructure b2) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n+                                                                  a2.getValue(), b2.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n+     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n+                                                        final double a2, final DerivativeStructure b2) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n+                                                                  a2, b2.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n+                                                        final DerivativeStructure a2, final DerivativeStructure b2,\n+                                                        final DerivativeStructure a3, final DerivativeStructure b3) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n+                                                                  a2.getValue(), b2.getValue(),\n+                                                                  a3.getValue(), b3.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure)\n+     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n+                                                        final double a2, final DerivativeStructure b2,\n+                                                        final double a3, final DerivativeStructure b3) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n+                                                                  a2, b2.getValue(),\n+                                                                  a3, b3.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n+                                                        final DerivativeStructure a2, final DerivativeStructure b2,\n+                                                        final DerivativeStructure a3, final DerivativeStructure b3,\n+                                                        final DerivativeStructure a4, final DerivativeStructure b4) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n+                                                                  a2.getValue(), b2.getValue(),\n+                                                                  a3.getValue(), b3.getValue(),\n+                                                                  a4.getValue(), b4.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure)\n+     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n+     * @since 3.2\n+     */\n+    public static DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n+                                                        final double a2, final DerivativeStructure b2,\n+                                                        final double a3, final DerivativeStructure b3,\n+                                                        final double a4, final DerivativeStructure b4) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n+                                                                  a2, b2.getValue(),\n+                                                                  a3, b3.getValue(),\n+                                                                  a4, b4.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math3/util/MathArraysTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/MathArraysTest.java\n package org.apache.commons.math3.util;\n \n import java.util.Arrays;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotPositiveException;\n         final double abSumArray = MathArrays.linearCombination(a, b);\n \n         Assert.assertEquals(abSumInline, abSumArray, 0);\n+        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline, 1.0e-15);\n+\n+        final double naive = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n+        Assert.assertTrue(FastMath.abs(naive - abSumInline) > 1.5);\n+\n     }\n \n     @Test\n     }\n \n     @Test\n+    public void testLinearCombination1DSDS() {\n+        final DerivativeStructure[] a = new DerivativeStructure[] {\n+            new DerivativeStructure(6, 1, 0, -1321008684645961.0 / 268435456.0),\n+            new DerivativeStructure(6, 1, 1, -5774608829631843.0 / 268435456.0),\n+            new DerivativeStructure(6, 1, 2, -7645843051051357.0 / 8589934592.0)\n+        };\n+        final DerivativeStructure[] b = new DerivativeStructure[] {\n+            new DerivativeStructure(6, 1, 3, -5712344449280879.0 / 2097152.0),\n+            new DerivativeStructure(6, 1, 4, -4550117129121957.0 / 2097152.0),\n+            new DerivativeStructure(6, 1, 5, 8846951984510141.0 / 131072.0)\n+        };\n+\n+        final DerivativeStructure abSumInline = MathArrays.linearCombination(a[0], b[0],\n+                                                                             a[1], b[1],\n+                                                                             a[2], b[2]);\n+        final DerivativeStructure abSumArray = MathArrays.linearCombination(a, b);\n+\n+        Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);\n+        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);\n+        Assert.assertEquals(b[0].getValue(), abSumInline.getPartialDerivative(1, 0, 0, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(b[1].getValue(), abSumInline.getPartialDerivative(0, 1, 0, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(b[2].getValue(), abSumInline.getPartialDerivative(0, 0, 1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(a[0].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(a[1].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(a[2].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 0, 1), 1.0e-15);\n+\n+    }\n+\n+    @Test\n+    public void testLinearCombination1DoubleDS() {\n+        final double[] a = new double[] {\n+            -1321008684645961.0 / 268435456.0,\n+            -5774608829631843.0 / 268435456.0,\n+            -7645843051051357.0 / 8589934592.0\n+        };\n+        final DerivativeStructure[] b = new DerivativeStructure[] {\n+            new DerivativeStructure(3, 1, 0, -5712344449280879.0 / 2097152.0),\n+            new DerivativeStructure(3, 1, 1, -4550117129121957.0 / 2097152.0),\n+            new DerivativeStructure(3, 1, 2, 8846951984510141.0 / 131072.0)\n+        };\n+\n+        final DerivativeStructure abSumInline = MathArrays.linearCombination(a[0], b[0],\n+                                                                             a[1], b[1],\n+                                                                             a[2], b[2]);\n+        final DerivativeStructure abSumArray = MathArrays.linearCombination(a, b);\n+\n+        Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);\n+        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);\n+        Assert.assertEquals(a[0], abSumInline.getPartialDerivative(1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(a[1], abSumInline.getPartialDerivative(0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(a[2], abSumInline.getPartialDerivative(0, 0, 1), 1.0e-15);\n+\n+    }\n+\n+    @Test\n+    public void testLinearCombination2DSDS() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(0xc6af886975069f11l);\n+\n+        for (int i = 0; i < 10000; ++i) {\n+            final DerivativeStructure[] u = new DerivativeStructure[4];\n+            final DerivativeStructure[] v = new DerivativeStructure[4];\n+            for (int j = 0; j < u.length; ++j) {\n+                u[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());\n+                v[j] = new DerivativeStructure(u.length, 1, 1e17 * random.nextDouble());\n+            }\n+\n+            DerivativeStructure lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1]);\n+            double ref = u[0].getValue() * v[0].getValue() +\n+                         u[1].getValue() * v[1].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+\n+            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);\n+            ref = u[0].getValue() * v[0].getValue() +\n+                  u[1].getValue() * v[1].getValue() +\n+                  u[2].getValue() * v[2].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+\n+            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);\n+            ref = u[0].getValue() * v[0].getValue() +\n+                  u[1].getValue() * v[1].getValue() +\n+                  u[2].getValue() * v[2].getValue() +\n+                  u[3].getValue() * v[3].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+            Assert.assertEquals(v[3].getValue(), lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombination2DoubleDS() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(0xc6af886975069f11l);\n+\n+        for (int i = 0; i < 10000; ++i) {\n+            final double[] u = new double[4];\n+            final DerivativeStructure[] v = new DerivativeStructure[4];\n+            for (int j = 0; j < u.length; ++j) {\n+                u[j] = 1e17 * random.nextDouble();\n+                v[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());\n+            }\n+\n+            DerivativeStructure lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1]);\n+            double ref = u[0] * v[0].getValue() +\n+                         u[1] * v[1].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+\n+            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);\n+            ref = u[0] * v[0].getValue() +\n+                  u[1] * v[1].getValue() +\n+                  u[2] * v[2].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+\n+            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);\n+            ref = u[0] * v[0].getValue() +\n+                  u[1] * v[1].getValue() +\n+                  u[2] * v[2].getValue() +\n+                  u[3] * v[3].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+            Assert.assertEquals(u[3], lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));\n+\n+        }\n+    }\n+\n+    @Test\n     public void testArrayEquals() {\n         Assert.assertFalse(MathArrays.equals(new double[] { 1d }, null));\n         Assert.assertFalse(MathArrays.equals(null, new double[] { 1d }));", "timestamp": 1360852995, "metainfo": ""}