{"sha": "3c384f846f49ba673a9805c8d03d6a2156770a70", "log": "fixed an infinite loop error that occurred when an event that reset the state occurs exactly at multistep initialisation start  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n         double stopTime = Double.NaN;\n         do {\n             resetTime = Double.NaN;\n+            final double dt = (n - 0.9999) * h;\n+            for (EventHandler handler : starter.getEventHandlers()) {\n+                ((ResetCheckingWrapper) handler).setRange(t, Math.abs(dt));\n+            }\n             store.restart();\n+\n             // we overshoot by 1/10000 step the end to make sure we don't miss the last point\n-            stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);\n+            stopTime = starter.integrate(equations, t, y, t + dt, y);\n+\n             if (!Double.isNaN(resetTime)) {\n                 // there was an intermediate reset, we restart\n                 t = resetTime;\n         /** Wrapped event handler. */\n         private final EventHandler handler;\n \n+        /** Range start. */\n+        private double rangeStart;\n+\n+        /** Range size. */\n+        private double rangeSize;\n+\n         /** Build a new instance.\n          * @param handler event handler to wrap\n          */\n         public ResetCheckingWrapper(final EventHandler handler) {\n             this.handler = handler;\n+        }\n+\n+        /** Set the range.\n+         * @param rangeStart range start\n+         * @param rangeSize range size\n+         */\n+        public void setRange(final double rangeStart, final double rangeSize) {\n+            this.rangeStart = rangeStart;\n+            this.rangeSize  = rangeSize;\n         }\n \n         /** {@inheritDoc} */\n         public int eventOccurred(double t, double[] y, boolean increasing)\n             throws EventException {\n             final int action = handler.eventOccurred(t, y, increasing);\n+            if (Math.abs(t - rangeStart) < 1.0e-10 * rangeSize) {\n+                // we have encountered again an already handled reset, don't stop here\n+                return action;\n+            }\n             if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {\n                 // a singularity has been encountered\n                 // we need to restart the start phase", "timestamp": 1243975181, "metainfo": ""}