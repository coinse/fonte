{"sha": "3bc3c15e2d33d7217aa3092f320d5f09774cc44a", "log": "In o.a.c.m.linear - Removed tagging interface ProvidesResidual - added double IterativeLinearSolverEvent.getNormOfResidual() - added RealVector IterativeLinearSolverEvent.getResidual() (optional operation) - added boolean IterativeLinearSolverEvent.providesResidual() - added default implementation DefaultIterativeLinearSolverEvent see MATH-735.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n public class ConjugateGradient\n     extends PreconditionedIterativeLinearSolver {\n \n-    /**\n-     * The type of all events fired by this implementation of the Conjugate\n-     * Gradient method.\n-     *\n-     * @version $Id: ConjugateGradient.java 1175404 2011-09-25 14:48:18Z\n-     * celestin $\n-     */\n-    public static class ConjugateGradientEvent\n-        extends IterativeLinearSolverEvent\n-        implements ProvidesResidual {\n-\n-        /** */\n-        private static final long serialVersionUID = 20120128L;\n-\n-        /** The right-hand side vector. */\n-        private final RealVector b;\n-\n-        /** The current estimate of the residual. */\n-        private final RealVector r;\n-\n-        /** The current estimate of the norm of the residual. */\n-        private final double rnorm;\n-\n-        /** The current estimate of the solution. */\n-        private final RealVector x;\n-\n-        /**\n-         * Creates a new instance of this class.\n-         *\n-         * @param source the iterative algorithm on which the event initially\n-         * occurred\n-         * @param iterations the number of iterations performed at the time\n-         * {@code this} event is created\n-         * @param x the current estimate of the solution\n-         * @param b the right-hand side vector\n-         * @param r the current estimate of the residual\n-         * @param rnorm the norm of the current estimate of the residual\n-         */\n-        public ConjugateGradientEvent(final Object source, final int iterations,\n-            final RealVector x, final RealVector b, final RealVector r,\n-            final double rnorm) {\n-            super(source, iterations);\n-            this.x = RealVector.unmodifiableRealVector(x);\n-            this.b = RealVector.unmodifiableRealVector(b);\n-            this.r = RealVector.unmodifiableRealVector(r);\n-            this.rnorm = rnorm;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public double getNormOfResidual() {\n-            return rnorm;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public RealVector getResidual() {\n-            return r;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public RealVector getRightHandSideVector() {\n-            return b;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public RealVector getSolution() {\n-            return x;\n-        }\n-    }\n-\n     /** Key for the <a href=\"#context\">exception context</a>. */\n     public static final String OPERATOR = \"operator\";\n \n         // Initialization of default stopping criterion\n         manager.resetIterationCount();\n         final double rmax = delta * b.getNorm();\n+        final RealVector bro = RealVector.unmodifiableRealVector(b);\n \n         // Initialization phase counts as one iteration.\n         manager.incrementIterationCount();\n         // of x is optimized for the calculation of the matrix-vector product\n         // A.x.\n         final RealVector x = x0;\n+        final RealVector xro = RealVector.unmodifiableRealVector(x);\n         final RealVector p = x.copy();\n         RealVector q = a.operate(p);\n \n         final RealVector r = b.combine(1, -1, q);\n+        final RealVector rro = RealVector.unmodifiableRealVector(r);\n         double rnorm = r.getNorm();\n         RealVector z;\n         if (minv == null) {\n             z = null;\n         }\n         IterativeLinearSolverEvent evt;\n-        evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n+        evt = new DefaultIterativeLinearSolverEvent(this,\n+            manager.getIterations(), xro, bro, rro, rnorm);\n         manager.fireInitializationEvent(evt);\n         if (rnorm <= rmax) {\n             manager.fireTerminationEvent(evt);\n         double rhoPrev = 0.;\n         while (true) {\n             manager.incrementIterationCount();\n-            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n+            evt = new DefaultIterativeLinearSolverEvent(this,\n+                manager.getIterations(), xro, bro, rro, rnorm);\n             manager.fireIterationStartedEvent(evt);\n             if (minv != null) {\n                 z = minv.operate(r);\n             r.combineToSelf(1., -alpha, q);\n             rhoPrev = rhoNext;\n             rnorm = r.getNorm();\n-            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n+            evt = new DefaultIterativeLinearSolverEvent(this,\n+                manager.getIterations(), xro, bro, rro, rnorm);\n             manager.fireIterationPerformedEvent(evt);\n             if (rnorm <= rmax) {\n                 manager.fireTerminationEvent(evt);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultIterativeLinearSolverEvent.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n+\n+/**\n+ * A default concrete implementation of the abstract class\n+ * {@link IterativeLinearSolverEvent}.\n+ *\n+ * @version $Id$\n+ */\n+public class DefaultIterativeLinearSolverEvent extends IterativeLinearSolverEvent {\n+\n+    /** */\n+    private static final long serialVersionUID = 20120129L;\n+\n+    /** The right-hand side vector. */\n+    private final RealVector b;\n+\n+    /** The current estimate of the residual. */\n+    private final RealVector r;\n+\n+    /** The current estimate of the norm of the residual. */\n+    private final double rnorm;\n+\n+    /** The current estimate of the solution. */\n+    private final RealVector x;\n+\n+    /**\n+     * Creates a new instance of this class. This implementation does\n+     * <em>not</em> deep copy the specified vectors {@code x}, {@code b},\n+     * {@code r}. Therefore the user must make sure that these vectors are\n+     * either unmodifiable views or deep copies of the same vectors actually\n+     * used by the {@code source}. Failure to do so may compromise subsequent\n+     * iterations of the {@code source}. If the residual vector {@code r} is\n+     * {@code null}, then {@link #getResidual()} throws a\n+     * {@link MathUnsupportedOperationException}, and\n+     * {@link #providesResidual()} returns {@code false}.\n+     *\n+     * @param source the iterative solver which fired this event\n+     * @param iterations the number of iterations performed at the time\n+     * {@code this} event is created\n+     * @param x the current estimate of the solution\n+     * @param b the right-hand side vector\n+     * @param r the current estimate of the residual (can be {@code null})\n+     * @param rnorm the norm of the current estimate of the residual\n+     */\n+    public DefaultIterativeLinearSolverEvent(final Object source, final int iterations,\n+        final RealVector x, final RealVector b, final RealVector r,\n+        final double rnorm) {\n+        super(source, iterations);\n+        this.x = x;\n+        this.b = b;\n+        this.r = r;\n+        this.rnorm = rnorm;\n+    }\n+\n+    /**\n+     * Creates a new instance of this class. This implementation does\n+     * <em>not</em> deep copy the specified vectors {@code x}, {@code b}.\n+     * Therefore the user must make sure that these vectors are either\n+     * unmodifiable views or deep copies of the same vectors actually used by\n+     * the {@code source}. Failure to do so may compromise subsequent iterations\n+     * of the {@code source}. Callling {@link #getResidual()} on instances\n+     * returned by this constructor throws a\n+     * {@link MathUnsupportedOperationException}, while\n+     * {@link #providesResidual()} returns {@code false}.\n+     *\n+     * @param source the iterative solver which fired this event\n+     * @param iterations the number of iterations performed at the time\n+     * {@code this} event is created\n+     * @param x the current estimate of the solution\n+     * @param b the right-hand side vector\n+     * @param rnorm the norm of the current estimate of the residual\n+     */\n+    public DefaultIterativeLinearSolverEvent(final Object source, final int iterations,\n+        final RealVector x, final RealVector b, final double rnorm) {\n+        super(source, iterations);\n+        this.x = x;\n+        this.b = b;\n+        this.r = null;\n+        this.rnorm = rnorm;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getNormOfResidual() {\n+        return rnorm;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * This implementation throws an {@link MathUnsupportedOperationException}\n+     * if no residual vector {@code r} was provided at construction time.\n+     */\n+    public RealVector getResidual() {\n+        if (r != null) {\n+            return r;\n+        }\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector getRightHandSideVector() {\n+        return b;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector getSolution() {\n+        return x;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * This implementation returns {@code true} if a non-{@code null} value was\n+     * specified for the residual vector {@code r} at construction time.\n+     *\n+     * @return {@code true} if {@code r != null}\n+     */\n+    @Override\n+    public boolean providesResidual() {\n+        return r != null;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n     extends IterationEvent {\n \n     /** */\n-    private static final long serialVersionUID = 20120128L;\n+    private static final long serialVersionUID = 20120129L;\n \n     /**\n      * Creates a new instance of this class.\n     public abstract double getNormOfResidual();\n \n     /**\n+     * <p>\n+     * Returns the residual. This is an optional operation, as all iterative\n+     * linear solvers do not provide cheap estimate of the updated residual\n+     * vector, in which case\n+     * </p>\n+     * <ul>\n+     * <li>this method should throw a\n+     * {@link MathUnsupportedOperationException},</li>\n+     * <li>{@link #providesResidual()} returns {@code false}.</li>\n+     * </ul>\n+     * <p>\n+     * The default implementation throws a\n+     * {@link MathUnsupportedOperationException}. If this method is overriden,\n+     * then {@link #providesResidual()} should be overriden as well.\n+     * </p>\n+     *\n+     * @return the updated residual, r\n+     */\n+    public RealVector getResidual() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n      * Returns the current estimate of the solution to the linear system to be\n      * solved. This method should return an unmodifiable view, or a deep copy of\n      * the actual current solution, in order not to compromise subsequent\n      * @return the solution, x\n      */\n     public abstract RealVector getSolution();\n+\n+    /**\n+     * Returns {@code true} if {@link #getResidual()} is supported. The default\n+     * implementation returns {@code false}.\n+     *\n+     * @return {@code false} if {@link #getResidual()} throws a\n+     * {@link MathUnsupportedOperationException}\n+     */\n+    public boolean providesResidual() {\n+        return false;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.IterationEvent;\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n-                RealVector v = ((ProvidesResidual) e).getResidual();\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                RealVector v = evt.getResidual();\n                 r.setSubVector(0, v);\n-                v = ((IterativeLinearSolverEvent) e).getSolution();\n+                v = evt.getSolution();\n                 x.setSubVector(0, v);\n             }\n \n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n-                RealVector v = ((ProvidesResidual)e).getResidual();\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                RealVector v = evt.getResidual();\n                 r.setSubVector(0, v);\n-                v = ((IterativeLinearSolverEvent) e).getSolution();\n+                v = evt.getSolution();\n                 x.setSubVector(0, v);\n             }\n \n          */\n         final int[] count = new int[] {0, 0, 0, 0};\n         final IterationListener listener = new IterationListener() {\n+            private void doTestVectorsAreUnmodifiable(final IterationEvent e) {\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                try {\n+                    evt.getResidual().set(0.0);\n+                    Assert.fail(\"r is modifiable\");\n+                } catch (MathUnsupportedOperationException exc){\n+                    // Expected behavior\n+                }\n+                try {\n+                    evt.getRightHandSideVector().set(0.0);\n+                    Assert.fail(\"b is modifiable\");\n+                } catch (MathUnsupportedOperationException exc){\n+                    // Expected behavior\n+                }\n+                try {\n+                    evt.getSolution().set(0.0);\n+                    Assert.fail(\"x is modifiable\");\n+                } catch (MathUnsupportedOperationException exc){\n+                    // Expected behavior\n+                }\n+            }\n+\n             public void initializationPerformed(final IterationEvent e) {\n                 ++count[0];\n+                doTestVectorsAreUnmodifiable(e);\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n                 ++count[2];\n                 Assert.assertEquals(\"iteration performed\",\n                     count[2], e.getIterations() - 1);\n+                doTestVectorsAreUnmodifiable(e);\n             }\n \n             public void iterationStarted(final IterationEvent e) {\n                 ++count[1];\n                 Assert.assertEquals(\"iteration started\",\n                     count[1], e.getIterations() - 1);\n+                doTestVectorsAreUnmodifiable(e);\n             }\n \n             public void terminationPerformed(final IterationEvent e) {\n                 ++count[3];\n+                doTestVectorsAreUnmodifiable(e);\n             }\n         };\n         solver = new ConjugateGradient(maxIterations, 1E-10, true);", "timestamp": 1328062920, "metainfo": ""}