{"sha": "671d5c1d5ecaac8943e16a7e9ba08c710a4d9ef3", "log": "This patch exposes the start index, internal double array of DOubleArray Implementations.  It adds a NumberTransformer framework for mapping Objects and Bean Properties to double primitives It also corrects some checkstyle and javadoc errors.   ", "commit": "\n--- a/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n-public class ContractableDoubleArray \n-    extends ExpandableDoubleArray \n+public class ContractableDoubleArray\n+    extends ExpandableDoubleArray\n     implements Serializable {\n \n-    // The contraction criteria defines the conditions under which this\n-    // object will \"resize\" the internal array to the number of elements\n-    // contained in the element array + 1\n-    protected float contractionCriteria = 2.5f;\n+    /** The contraction criteria defines the conditions under which this\n+     * object will \"resize\" the internal array to the number of elements\n+     * contained in the element array + 1\n+     */\n+    private float contractionCriteria = 2.5f;\n \n     /**\n      * Create an expandable double array with the default initial capacity of \n      * @param expansionFactor the array will be expanded based on this \n      *                        parameter\n      */\n-    public ContractableDoubleArray(int initialCapacity, \n-                                   float expansionFactor) {\n+    public ContractableDoubleArray(\n+        int initialCapacity,\n+        float expansionFactor) {\n         this.expansionFactor = expansionFactor;\n         setInitialCapacity(initialCapacity);\n         internalArray = new double[initialCapacity];\n      * @param initialCapacity The initial size of the internal storage array\n      * @param expansionFactor the array will be expanded based on this \n      *                        parameter\n-     */\n-    public ContractableDoubleArray(int initialCapacity, \n-                                   float expansionFactor, \n-                                   float contractionCriteria) {\n+     * @param contractionCriteria The contraction Criteria.\n+     */\n+    public ContractableDoubleArray(\n+        int initialCapacity,\n+        float expansionFactor,\n+        float contractionCriteria) {\n         this.contractionCriteria = contractionCriteria;\n         this.expansionFactor = expansionFactor;\n         setInitialCapacity(initialCapacity);\n         double[] tempArray = new double[numElements + 1];\n \n         // Copy and swap - copy only the element array from the src array.\n-        System.arraycopy(internalArray,startIndex,tempArray,0,numElements);\n+        System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n         internalArray = tempArray;\n \n         // Reset the start index to zero\n      * gradually push the internal storage vs. element storage to\n      * the contractionCriteria.\n      * </p>\n-     * \n-     * @return value to be added to end of array\n+     * @param value to be added to end of array\n+     * @return value added\n      */\n     public synchronized double addElementRolling(double value) {\n         double discarded = super.addElementRolling(value);\n         return shouldContract;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.ExpandableDoubleArray#setElement(int, double)\n+    /**\n+     * @see org.apache.commons.math.util.DoubleArray#setElement(int, double)\n      */\n     public synchronized void setElement(int index, double value) {\n         super.setElement(index, value);\n      * IllegalArgumentException if the contractionCriteria is less than the \n      * expansionCriteria\n      * \n-     * @param expansionFactor \n-     * @param contractionCritera\n-     */\n-    protected void checkContractExpand(float contractionCritera, \n-                                        float expansionFactor) {\n+     * @param expansionFactor factor to be checked\n+     * @param contractionCritera critera to be checked\n+     */\n+    protected void checkContractExpand(\n+        float contractionCritera,\n+        float expansionFactor) {\n \n         if (contractionCritera < expansionFactor) {\n-            String msg = \"Contraction criteria can never be smaller than \" +\n-                \"the expansion factor.  This would lead to a never ending \" +\n-                \"loop of expansion and contraction as a newly expanded \" +\n-                \"internal storage array would immediately satisfy the \" +\n-                \"criteria for contraction\";\n+            String msg =\n+                \"Contraction criteria can never be smaller than \"\n+                    + \"the expansion factor.  This would lead to a never \"\n+                    + \"ending loop of expansion and contraction as a newly \"\n+                    + \"expanded internal storage array would immediately \"\n+                    + \"satisfy the criteria for contraction\";\n             throw new IllegalArgumentException(msg);\n         }\n \n         if (contractionCriteria <= 1.0) {\n-            String msg = \"The contraction criteria must be a number larger \" +\n-                \"than one.  If the contractionCriteria is less than or \" +\n-                \"equal to one an endless loop of contraction and expansion \" +\n-                \"would ensue as an internalArray.length == numElements \" +\n-                \"would satisfy the contraction criteria\";\n-            throw new IllegalArgumentException(msg); \n+            String msg =\n+                \"The contraction criteria must be a number larger \"\n+                    + \"than one.  If the contractionCriteria is less than or \"\n+                    + \"equal to one an endless loop of contraction and \"\n+                    + \"expansion would ensue as an internalArray.length \"\n+                    + \"== numElements would satisfy the contraction criteria\";\n+            throw new IllegalArgumentException(msg);\n         }\n \n         if (expansionFactor < 1.0) {\n-            String msg = \"The expansion factor must be a number greater \" +\n-                \"than 1.0\";\n+            String msg =\n+                \"The expansion factor must be a number greater \" + \"than 1.0\";\n             throw new IllegalArgumentException(msg);\n         }\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.ExpandableDoubleArray#discardFrontElements(int)\n      */\n     public synchronized void discardFrontElements(int i) {\n--- a/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n     // should have flags for incremental growth - (i.e. when expanding, only\n     // increase storage by a constant size - 100, 200 ) ?\n \n-    // This is the internal storage array.\n+    /** \n+     * This is the internal storage array.\n+     */\n     protected double[] internalArray;\n \n-    // Number of elements in the array\n+    /** \n+     * Number of elements in the array\n+     */\n     protected int numElements = 0;\n \n-    // Keeps track of a starting index\n+    /** \n+     * Keeps track of a starting index\n+     */\n     protected int startIndex = 0;\n \n-    // The initial capacity of the array. \n-    // Initial capacity is not exposed as a property as it is only meaningful\n-    // when passed to a constructor.\n+    /**The initial capacity of the array. \n+     * Initial capacity is not exposed as a property as it is only meaningful\n+     * when passed to a constructor.\n+     */\n     protected int initialCapacity = 16;\n \n-    // The expand factor of the array.  When the array need to be expanded, \n-    // the new array size will be internalArray.length * expandFactor \n+    /** The expand factor of the array.  When the array need to be expanded, \n+     * the new array size will be internalArray.length * expandFactor \n+     */\n     protected float expansionFactor = 2.0f;\n \n     /**\n         if (expansionFactor > 1.0) {\n             this.expansionFactor = expansionFactor;\n         } else {\n-            String msg = \"The expansion factor must be a number greater \" +\n-                \"than 1.0\";\n+            String msg =\n+                \"The expansion factor must be a number greater \" + \"than 1.0\";\n             throw new IllegalArgumentException(msg);\n         }\n     }\n \n     /**\n      * Sets the initial capacity\n-     * \n-     * @param initialCapacity\n+     * @param initialCapacity of the array\n      */\n     public void setInitialCapacity(int initialCapacity) {\n         if (initialCapacity > 0) {\n             this.initialCapacity = initialCapacity;\n         } else {\n-            String msg = \"The initial capacity supplied: \" + initialCapacity +\n-                \"must be a positive integer\";\n+            String msg =\n+                \"The initial capacity supplied: \"\n+                    + initialCapacity\n+                    + \"must be a positive integer\";\n             throw new IllegalArgumentException(msg);\n         }\n     }\n      * \n      * @return the internal storage array used by this object\n      */\n-    protected double[] getValues() {\n+    public double[] getValues() {\n         return (internalArray);\n+    }\n+\n+    /**\n+     * Returns the starting index of the internal array.\n+     * @return starting index\n+     */\n+    public int start() {\n+        return startIndex;\n     }\n \n     /**\n     public synchronized void setNumElements(int i) {\n \n         // If index is negative thrown an error\n-        if (i <  0) {\n-            String msg = \"Number of elements must be zero or a positive \" +\n-                \"integer\";\n+        if (i < 0) {\n+            String msg =\n+                \"Number of elements must be zero or a positive \" + \"integer\";\n             throw new IllegalArgumentException(msg);\n         }\n \n     public double getElement(int index) {\n         double value = Double.NaN;\n         if (index >= numElements) {\n-            String msg = \"The index specified: \" + index + \n-                \" is larger than the current number of elements\";\n+            String msg =\n+                \"The index specified: \"\n+                    + index\n+                    + \" is larger than the current number of elements\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         } else if (index >= 0) {\n             value = internalArray[startIndex + index];\n         } else {\n-            String msg = \"Elements cannot be retrieved from a negative \" +\n-                \"array index\";\n+            String msg =\n+                \"Elements cannot be retrieved from a negative \" + \"array index\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         }\n         return value;\n      * @param value value to store at the specified index\n      */\n     public synchronized void setElement(int index, double value) {\n-\t\t\n-\t\tif (index < 0) {\n+\n+        if (index < 0) {\n             String msg = \"Cannot set an element at a negative index\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         }\n     private synchronized void expandTo(int size) {\n         double[] tempArray = new double[size];\n         // Copy and swap\n-        System.arraycopy(internalArray,0,tempArray,0,internalArray.length);\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n         internalArray = tempArray;\n     }\n \n      */\n     protected synchronized void expand() {\n \n-\t\t// notice the use of Math.ceil(), this gaurantees that we will always \n+        // notice the use of Math.ceil(), this gaurantees that we will always \n         // have an array of at least currentSize + 1.   Assume that the \n         // current initial capacity is 1 and the expansion factor\n-\t\t// is 1.000000000000000001.  The newly calculated size will be \n+        // is 1.000000000000000001.  The newly calculated size will be \n         // rounded up to 2 after the multiplication is performed.\n         int newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n         double[] tempArray = new double[newSize];\n      * has the effect of a FIFO.  when you \"roll\" the array an element is \n      * removed from the array.  The return value of this function is the \n      * discarded double.\n-     * \n-     * @return the value which has been discarded or \"pushed\" out of the array\n-     * \t  by this rolling insert.\n+     * @param value the value to add\n+     * @return the value which has been discarded or \"pushed\" out of the array \n+     * by this rolling insert.\n      */\n     public synchronized double addElementRolling(double value) {\n         double discarded = internalArray[startIndex];\n \n-        if ((startIndex + (numElements+1)) > internalArray.length) {\n+        if ((startIndex + (numElements + 1)) > internalArray.length) {\n             expand();\n         }\n         // Increment the start index\n     int getInternalLength() {\n         return (internalArray.length);\n     }\n-\t\n+\n     /**\n      * Clear the array, reset the size to the initialCapacity and the number \n      * of elements to zero.\n     public synchronized void discardFrontElements(int i) {\n \n         if (i > numElements) {\n-            String msg = \"Cannot discard more elements than are\" +\n-                \"contained in this array.\";\n+            String msg =\n+                \"Cannot discard more elements than are\"\n+                    + \"contained in this array.\";\n             throw new IllegalArgumentException(msg);\n         } else if (i < 0) {\n             String msg = \"Cannot discard a negative number of elements.\";\n         }\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.DoubleArray#getElements()\n      */\n     public double[] getElements() {\n         double[] elementArray = new double[numElements];\n-        System.arraycopy(internalArray, startIndex, \n-                         elementArray, 0, numElements);\n+        System.arraycopy(\n+            internalArray,\n+            startIndex,\n+            elementArray,\n+            0,\n+            numElements);\n         return elementArray;\n     }\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+/**\n+ * <p>\n+ * Provides an implementation of the DoubleArray with a maximum number of\n+ * elements.  Creating an array implementation with an upper limit on the\n+ * number of elements allows us to support a more efficient \"rolling\" \n+ * mechanism to support addElementRoling(double). Please note that this\n+ * implementation will not preserve the order of the values supplied to\n+ * this array, calling getValues() will return an array of indeterminate\n+ * order.\n+ * </p>\n+ * \n+ * <p>\n+ * Values are added to this array by calling addElement(double) or \n+ * addElementRolling(double).  If addElement(double) is called on \n+ * an array that already contains the maximum number of elements, an\n+ * ArrayIndexOutOfBoundsException will be thrown to reflect an attempt to\n+ * add a value beyond the boundaries of the fixed length array - in this\n+ * respect a FixedDoubleArray can be considered \"full\".  Calling \n+ * addElementRolling(double) on an array which contains the maximum\n+ * number of elements will cause the array to overwrite the \"oldest\"\n+ * value in the array.\n+ * </p>\n+ *\n+ * <p>\n+ * This class is called FixedDoubleArray not because it is of a fixed size.\n+ * The name is appropriate because the internal storage array remains \n+ * \"fixed\" in memory, this implementation will never allocate, or copy\n+ * the internal storage array to a new array instance.\n+ * </p>\n+ *\n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class FixedDoubleArray implements DoubleArray {\n+\n+    /**\n+     * This is the internal storage array.  This array is assigned\n+     * a known fixed size in the constructor\n+     */\n+    private double[] internalArray;\n+\n+    /**\n+     * Size determined the number of elements in the array at\n+     * any given time. When an array is created is maxElements\n+     * of 100, it is of size 0, and size increases as values are\n+     * added.\n+     */\n+    private int size = 0;\n+\n+    /**\n+     * This index points to the location of the next update.  Next\n+     * add, cycles from 0 to (maxElement-1)\n+     */\n+    private int nextAdd = 0;\n+ \n+    /**\n+     * The maximum number of elements in the FixedDoubleArray\n+     */\n+    private int maxElements = 0;\n+\n+    /**\n+     * Create a fixed array for double primitives which can hold up to\n+     * <code>maxElements</codec> doubles.  This implementation of \n+     * DoubleArray was created to provide a more \"performance-oriented\"\n+     * in-place rolling mechanism for calculations which need to\n+     * operate on a rolling window of values.\n+     *\n+     * @param maxElements the maximum number of elements this \n+     *        FixeddoubleArray may contain.\n+     */\n+    public FixedDoubleArray(int maxElements) {\n+        this.maxElements = maxElements;\n+        internalArray = new double[maxElements];\n+    }\n+\n+    /**\n+     * Create a fixed array backed by the provided double[] implementation. \n+     * the array should have all the elements occupied. the size and maxElements\n+     * are drawn from the array's length.\n+     * \n+     * This implementation of DoubleArray was created to provide a more \n+     * \"performance-oriented\" in-place rolling mechanism for calculations \n+     * which need to operate on a rolling window of values.\n+     * @param array the backing array\n+     */\n+    public FixedDoubleArray(double[] array) {\n+        this.maxElements = array.length;\n+        this.size = array.length;\n+        internalArray = array;\n+    }\n+\n+    /**\n+     * Retrieves the current size of the array.\n+     * @see org.apache.commons.math.DoubleArray#getNumElements()\n+     */\n+    public int getNumElements() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns the element value at the specified index.  Please note that\n+     * the size of the element array is not directly related to the \n+     * maximum number of elements which this array can contain.  One can\n+     * create an instance of FixedDoubleArray with a maximum of\n+     * ten elements, add three items, and get any items from index 0 to index\n+     * 2 - trying to retrieve an element outside of the current element\n+     * array will throw an ArrayIndexOutOfBoundsException.\n+     *\n+     * @see org.apache.commons.math.DoubleArray#getElement(int)\n+     */\n+    public double getElement(int index) {\n+        if (index > (size - 1)) {\n+            String msg =\n+                \"Attempted to retrieve an element outside of \"\n+                    + \"the element array\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else {\n+            // Return the element requested, if the index supplied\n+            // is negative this statement may also throw an\n+            // ArrayIndexOutOfBoundException.\n+            return internalArray[index];\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the element at the specified index to the value supplied.\n+     * </p>\n+     *\n+     * <p>Implementation Notes:\n+     * <ul>\n+     *  This implementation will not expand the array to the specified\n+     *  size.  Unlike the expandable double array implementation calling\n+     *  setElement(10, 3.0) on an array with 5 elements will throw an\n+     *  ArrayIndexOutOfBoundsException.\n+     * </ul>\n+     * <ul>\n+     *  The number of elements in an array corresponds to the number\n+     *  of elements that have been added to this FixedDoubleArray.  This\n+     *  is not the same as the maximum number of elements which can be\n+     *  contained in this array.  A FixedDoubleArray instance can be\n+     *  created with a maximum upper limit of 10 elements, until 10\n+     *  elements have been added to this array, the size of the array\n+     *  reflects the number of elements added.\n+     * </ul>\n+     * </p>\n+     *\n+     * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n+     */\n+    public void setElement(int index, double value) {\n+        if (index > (size - 1)) {\n+            String msg =\n+                \"Attempted to set an element outside of\" + \"the element array\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else {\n+            internalArray[index] = value;\n+        }\n+    }\n+\n+    /** \n+     * Add an element to the current array, testing to see if \n+     * this array has already met or exceeded the maximum number\n+     * of elements\n+     *\n+     * @see org.apache.commons.math.DoubleArray#addElement(double)\n+     */\n+    public void addElement(double value) {\n+        if (size < internalArray.length) {\n+            size++;\n+\n+            internalArray[nextAdd] = value;\n+\n+            // Incremenet nextAdd and then modulo it against maxElements\n+            // this has the effect of repeatedly \"cycling\" nextAdd\n+            // between 0 and (maxElements-1) endlessly.\n+            nextAdd++;\n+            nextAdd = nextAdd % (maxElements);\n+\n+        } else {\n+            // If the array has ALREADY reached the maximum size allowable,\n+            // we throw an ArrayIndexOutOfBoundsException - the end-user\n+            // is trying to add an element beyond the boundaries of the\n+            // fixed array.\n+            String msg =\n+                \"Attempted to add a value to an array of fixed \"\n+                    + \"size, please use addElementRolling \"\n+                    + \"to avoid this exception\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds an element by \"rolling\" the new value into the current array \n+     * while discarding the element which was added <code>maxElement</code>\n+     * add operations ago.  The value replaced is returned from this \n+     * method.  Until an array contains the maximum number of element, this\n+     * method has the same result as the addElement(double) operation.  Once\n+     * the maximum number of elements has been reached this implementation\n+     * inserts the new values starting at index 0 of the internal storage \n+     * array.  This allows for efficient rolling, but prevents us from \n+     * preserving the order of the added values.\n+     * </p>\n+     *\n+     * <p>\n+     * <b>Note:</b> This function will return <code>Double.NaN</code> if\n+     * no value has been discarded in this roll.  This can happen when\n+     * the array has not met the size limitation introduced in the \n+     * constructor.\n+     * </p>\n+     * @param value the value to be added to the array\n+     * @return Returns the value which a has been \"removed\" from the \n+     *         database.  <b>Important:</b> If the element array has\n+     *         not reached the maximum size, then it is possible that\n+     *         no element will be discarded from a given roll.  In this\n+     *         case this method will return a <code>Double.NaN</code> value.\n+     *\n+     * @see org.apache.commons.math.util.DoubleArray#addElementRolling(double)\n+     */\n+    public double addElementRolling(double value) {\n+\n+        // Create the discarded primitive.  If no element is\n+        // discarded by this roll, this method will return a\n+        // Double.NaN value.\n+        double discarded = Double.NaN;\n+\n+        if (size < internalArray.length) {\n+            size++;\n+        } else {\n+            // If we've reached the length of the internal\n+            // storage array, we have to start \"discarding\"\n+            // values from the original array.\n+\n+            // Obtain the value discarded by this overwrite\n+            discarded = internalArray[nextAdd];\n+        }\n+\n+        internalArray[nextAdd] = value;\n+\n+        // nextAdd cycles between 0 and (maxElements-1).\n+        nextAdd++;\n+        nextAdd = nextAdd % maxElements;\n+\n+        // but we return the value which was \"replaced\"\n+        return (discarded);\n+    }\n+\n+    /**\n+     * Provides an array of double[] which contain the\n+     * number of elements added to this array.  This  \n+     * method will return an array from zero to maxElements in length.\n+     * \n+     * @return The array of elements added to this DoubleArray\n+     *         implementation.\n+     * @see org.apache.commons.math.DoubleArray#getElements()\n+     */\n+    public double[] getElements() {\n+        double[] copy = new double[size];\n+        System.arraycopy(internalArray, 0, copy, 0, size);\n+        return copy;\n+    }\n+\n+    /**\n+     * Returns the internal storage array\n+     * \n+     * @return the internal storage array used by this object\n+     */\n+    public double[] getValues() {\n+        return (internalArray);\n+    }\n+\n+    /**\n+     * The starting index in the InternalArray.\n+     * @return starting index.\n+     */\n+    public int start() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Clear the array - drop all the data and start with a blank\n+     * internal array.  This implementation takes care of\n+     * setting the size of the array back to zero, and reinitializing\n+     * the internal storage array.\n+     *\n+     * @see org.apache.commons.math.DoubleArray#clear()\n+     */\n+    public void clear() {\n+        size = 0;\n+        nextAdd = 0;\n+        internalArray = new double[maxElements];\n+    }\n+\n+}", "timestamp": 1057429202, "metainfo": ""}