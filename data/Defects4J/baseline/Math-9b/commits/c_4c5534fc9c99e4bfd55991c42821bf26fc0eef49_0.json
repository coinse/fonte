{"sha": "4c5534fc9c99e4bfd55991c42821bf26fc0eef49", "log": "Fixed some issues in nth root derivatives at 0.  The current behavior is correct with respect to infinities and NaN being appropriately generated, but in some cases counter-intuitive.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n         double[] function = new double[1 + order];\n         double xk;\n         if (n == 2) {\n-            xk = FastMath.sqrt(operand[operandOffset]);\n+            function[0] = FastMath.sqrt(operand[operandOffset]);\n+            xk          = 0.5 / function[0];\n         } else if (n == 3) {\n-            xk = FastMath.cbrt(operand[operandOffset]);\n+            function[0] = FastMath.cbrt(operand[operandOffset]);\n+            xk          = 1.0 / (3.0 * function[0] * function[0]);\n         } else {\n-            xk = FastMath.pow(operand[operandOffset], 1.0 / n);\n+            function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);\n+            xk          = 1.0 / (n * FastMath.pow(function[0], n - 1));\n         }\n         final double nReciprocal = 1.0 / n;\n         final double xReciprocal = 1.0 / operand[operandOffset];\n-        for (int i = 0; i <= order; ++i) {\n+        for (int i = 1; i <= order; ++i) {\n             function[i] = xk;\n             xk *= xReciprocal * (nReciprocal - i);\n         }\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n     }\n \n     @Test\n+    public void testRootNSingularity() {\n+        for (int n = 2; n < 10; ++n) {\n+            for (int maxOrder = 0; maxOrder < 12; ++maxOrder) {\n+                DerivativeStructure dsZero = new DerivativeStructure(1, maxOrder, 0, 0.0);\n+                DerivativeStructure rootN  = dsZero.rootN(n);\n+                Assert.assertEquals(0.0, rootN.getValue(), 1.0e-20);\n+                if (maxOrder > 0) {\n+                    Assert.assertTrue(Double.isInfinite(rootN.getPartialDerivative(1)));\n+                    Assert.assertTrue(rootN.getPartialDerivative(1) > 0);\n+                    for (int order = 2; order <= maxOrder; ++order) {\n+                        // the following checks shows a LIMITATION of the current implementation\n+                        // we have no way to tell dsZero is a pure linear variable x = 0\n+                        // we only say: \"dsZero is a structure with value = 0.0,\n+                        // first derivative = 1.0, second and higher derivatives = 0.0\".\n+                        // Function composition rule for second derivatives is:\n+                        // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)\n+                        // when function f is the nth root and x = 0 we have:\n+                        // f(0) = 0, f'(0) = +infinity, f''(0) = -infinity (and higher\n+                        // derivatives keep switching between +infinity and -infinity)\n+                        // so given that in our case dsZero represents g, we have g(x) = 0,\n+                        // g'(x) = 1 and g''(x) = 0\n+                        // applying the composition rules gives:\n+                        // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x)\n+                        //                 = -infinity * 1^2 + +infinity * 0\n+                        //                 = -infinity + NaN\n+                        //                 = NaN\n+                        // if we knew dsZero is really the x variable and not the identity\n+                        // function applied to x, we would not have computed f'(g(x)) * g''(x)\n+                        // and we would have found that the result was -infinity and not NaN\n+                        Assert.assertTrue(Double.isNaN(rootN.getPartialDerivative(order)));\n+                    }\n+                }\n+\n+                // the following shows that the limitation explained above is NOT a bug...\n+                // if we set up the higher order derivatives for g appropriately, we do\n+                // compute the higher order derivatives of the composition correctly\n+                double[] gDerivatives = new double[ 1 + maxOrder];\n+                gDerivatives[0] = 0.0;\n+                for (int k = 1; k <= maxOrder; ++k) {\n+                    gDerivatives[k] = FastMath.pow(-1.0, k + 1);\n+                }\n+                DerivativeStructure correctRoot = new DerivativeStructure(1, maxOrder, gDerivatives).rootN(n);\n+                Assert.assertEquals(0.0, correctRoot.getValue(), 1.0e-20);\n+                if (maxOrder > 0) {\n+                    Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(1)));\n+                    Assert.assertTrue(correctRoot.getPartialDerivative(1) > 0);\n+                    for (int order = 2; order <= maxOrder; ++order) {\n+                        Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(order)));\n+                        if ((order % 2) == 0) {\n+                            Assert.assertTrue(correctRoot.getPartialDerivative(order) < 0);\n+                        } else {\n+                            Assert.assertTrue(correctRoot.getPartialDerivative(order) > 0);\n+                        }\n+                    }\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n     public void testSqrtPow2() {\n         double[] epsilon = new double[] { 1.0e-16, 3.0e-16, 2.0e-15, 6.0e-14, 6.0e-12 };\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n \n     @Test\n     public void testAtan2() {\n-        double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.0e-14, 1.0e-12, 8.0e-11 };\n+        double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.2e-14, 1.0e-12, 8.0e-11 };\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n             for (double x = -1.7; x < 2; x += 0.2) {\n                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);\n--- a/src/test/java/org/apache/commons/math3/analysis/function/SqrtTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/function/SqrtTest.java\n        Assert.assertEquals(-0.1901814435781826783,  s.getPartialDerivative(2), 1.0e-16);\n        Assert.assertEquals(0.23772680447272834785,  s.getPartialDerivative(3), 1.0e-16);\n        Assert.assertEquals(-0.49526417598485072465,   s.getPartialDerivative(4), 1.0e-16);\n-       Assert.assertEquals(1.4445205132891479465,  s.getPartialDerivative(5), 3.0e-16);\n+       Assert.assertEquals(1.4445205132891479465,  s.getPartialDerivative(5), 5.0e-16);\n    }\n \n }", "timestamp": 1348838922, "metainfo": ""}