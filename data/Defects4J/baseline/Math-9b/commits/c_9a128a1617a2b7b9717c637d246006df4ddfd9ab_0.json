{"sha": "9a128a1617a2b7b9717c637d246006df4ddfd9ab", "log": "populate throws declaration for ODE package  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n import org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;\n import org.apache.commons.math3.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.ode.events.EventHandler;\n                                 final double maxCheckInterval,\n                                 final double convergence,\n                                 final int maxIterationCount) {\n-        addEventHandler(handler, maxCheckInterval, convergence,\n-                        maxIterationCount,\n-                        new BracketingNthOrderBrentSolver(convergence, 5));\n+        try {\n+            addEventHandler(handler, maxCheckInterval, convergence,\n+                            maxIterationCount,\n+                            new BracketingNthOrderBrentSolver(convergence, 5));\n+        } catch (NumberIsTooSmallException ntse) {\n+            // this should never happen\n+            throw new MathInternalError();\n+        }\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public double integrate(final FirstOrderDifferentialEquations equations,\n                             final double t0, final double[] y0, final double t, final double[] y)\n-        throws MathIllegalStateException, MathIllegalArgumentException {\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n \n         if (y0.length != equations.getDimension()) {\n             throw new DimensionMismatchException(y0.length, equations.getDimension());\n      * @param equations complete set of differential equations to integrate\n      * @param t target time for the integration\n      * (can be set to a value smaller than <code>t0</code> for backward integration)\n-     * @throws MathIllegalStateException if the integrator cannot perform integration\n-     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n-     * too small integration span)\n+     * @exception NumberIsTooSmallException if integration step is too small\n+     * @throws DimensionMismatchException if the dimension of the complete state does not\n+     * match the complete equations sets dimension\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception NoBracketingException if the location of an event cannot be bracketed\n      */\n     public abstract void integrate(ExpandableStatefulODE equations, double t)\n-        throws MathIllegalStateException, MathIllegalArgumentException;\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException;\n \n     /** Compute the derivatives and check the number of evaluations.\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the state vector\n      * @param yDot placeholder array where to put the time derivative of the state vector\n      * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n      */\n     public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n-        throws MaxCountExceededException {\n+        throws MaxCountExceededException, DimensionMismatchException {\n         evaluations.incrementCount();\n         expandable.computeDerivatives(t, y, yDot);\n     }\n      * @param yDot placeholder array where to put the time derivative of the state vector\n      * @param tEnd final integration time\n      * @return time at end of step\n-     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n+     * @exception MaxCountExceededException if the interpolator throws one because\n+     * the number of functions evaluations is exceeded\n+     * @exception NoBracketingException if the location of an event cannot be bracketed\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n      * @since 2.2\n      */\n     protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                 final double[] y, final double[] yDot, final double tEnd)\n-        throws MathIllegalStateException {\n+        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n      * @param equations set of differential equations\n      * @param t target time for the integration\n      * @exception NumberIsTooSmallException if integration span is too small\n+     * @exception DimensionMismatchException if adaptive step size integrators\n+     * tolerance arrays dimensions are not compatible with equations settings\n      */\n     protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n-        throws NumberIsTooSmallException {\n+        throws NumberIsTooSmallException, DimensionMismatchException {\n \n         final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                   FastMath.abs(t)));\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractParameterizable.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractParameterizable.java\n \n import java.util.ArrayList;\n import java.util.Collection;\n-\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /** This abstract class provides boilerplate parameters list.\n  *\n \n     /** Check if a parameter is supported and throw an IllegalArgumentException if not.\n      * @param name name of the parameter to check\n-     * @exception MathIllegalArgumentException if the parameter is not supported\n+     * @exception UnknownParameterException if the parameter is not supported\n      * @see #isSupported(String)\n      */\n     public void complainIfNotSupported(final String name)\n-        throws MathIllegalArgumentException {\n+        throws UnknownParameterException {\n         if (!isSupported(name)) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, name);\n+            throw new UnknownParameterException(name);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math3/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ContinuousOutputModel.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n import org.apache.commons.math3.ode.sampling.StepInterpolator;\n    * @exception MathIllegalArgumentException if the model to append is not\n    * compatible with the instance (dimension of the state vector,\n    * propagation direction, hole between the dates)\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * during step finalization\n    */\n   public void append(final ContinuousOutputModel model)\n-    throws MathIllegalArgumentException {\n+    throws MathIllegalArgumentException, MaxCountExceededException {\n \n     if (model.steps.size() == 0) {\n       return;\n    * the instance for later use.\n    * @param interpolator interpolator for the last accepted step.\n    * @param isLast true if the step is the last one\n-   */\n-  public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * during step finalization\n+   */\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n+      throws MaxCountExceededException {\n \n     if (steps.size() == 0) {\n       initialTime = interpolator.getPreviousTime();\n   /**\n    * Get the state vector of the interpolated point.\n    * @return state vector at time {@link #getInterpolatedTime}\n-   */\n-  public double[] getInterpolatedState() {\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   */\n+  public double[] getInterpolatedState() throws MaxCountExceededException {\n     return steps.get(index).getInterpolatedState();\n   }\n \n--- a/src/main/java/org/apache/commons/math3/ode/ExpandableStatefulODE.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ExpandableStatefulODE.java\n import java.util.List;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n \n /**\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the complete state vector\n      * @param yDot placeholder array where to put the time derivative of the complete state vector\n-     */\n-    public void computeDerivatives(final double t, final double[] y, final double[] yDot) {\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n+     */\n+    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n+        throws MaxCountExceededException, DimensionMismatchException {\n \n         // compute derivatives of the primary equations\n         primaryMapper.extractEquationData(y, primaryState);\n      * @throws DimensionMismatchException if the dimension of the complete state does not\n      * match the complete equations sets dimension\n      */\n-    public double[] getCompleteState() {\n+    public double[] getCompleteState() throws DimensionMismatchException {\n \n         // allocate complete array\n         double[] completeState = new double[getTotalDimension()];\n--- a/src/main/java/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.java\n  */\n \n package org.apache.commons.math3.ode;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n \n \n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the state vector\n      * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n      */\n-    void computeDerivatives(double t, double[] y, double[] yDot);\n+    void computeDerivatives(double t, double[] y, double[] yDot)\n+        throws MaxCountExceededException, DimensionMismatchException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/FirstOrderIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/FirstOrderIntegrator.java\n \n package org.apache.commons.math3.ode;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n \n /** This interface represents a first order integrator for\n  * differential equations.\n    * @return stop time, will be the same as target time if integration reached its\n    * target, but may be different if some {@link\n    * org.apache.commons.math3.ode.events.EventHandler} stops it at some point.\n-   * @throws MathIllegalStateException if the integrator cannot perform integration\n-   * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n-   * too small integration span)\n+   * @exception DimensionMismatchException if arrays dimension do not match equations settings\n+   * @exception NumberIsTooSmallException if integration step is too small\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * @exception NoBracketingException if the location of an event cannot be bracketed\n    */\n   double integrate (FirstOrderDifferentialEquations equations,\n                     double t0, double[] y0, double t, double[] y)\n-      throws MathIllegalStateException, MathIllegalArgumentException;\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/JacobianMatrices.java\n+++ b/src/main/java/org/apache/commons/math3/ode/JacobianMatrices.java\n \n import java.lang.reflect.Array;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n      * @param hY step used for finite difference computation with respect to state vector\n      * @param parameters parameters to consider for Jacobian matrices processing\n      * (may be null if parameters Jacobians is not desired)\n-     * @exception MathIllegalArgumentException if one parameter is not supported\n-     * or there is a dimension mismatch with {@code hY}\n+     * @exception DimensionMismatchException if there is a dimension mismatch between\n+     * the steps array {@code hY} and the equation dimension\n      */\n     public JacobianMatrices(final FirstOrderDifferentialEquations fode, final double[] hY,\n                             final String... parameters)\n-        throws MathIllegalArgumentException {\n+        throws DimensionMismatchException {\n         this(new MainStateJacobianWrapper(fode, hY), parameters);\n     }\n \n      * @param jode the primary first order differential equations set to extend\n      * @param parameters parameters to consider for Jacobian matrices processing\n      * (may be null if parameters Jacobians is not desired)\n-     * @exception MathIllegalArgumentException if one parameter is not supported\n      */\n     public JacobianMatrices(final MainStateJacobianProvider jode,\n-                            final String... parameters)\n-        throws MathIllegalArgumentException {\n+                            final String... parameters) {\n \n         this.efode = null;\n         this.index = -1;\n \n     /** Register the variational equations for the Jacobians matrices to the expandable set.\n      * @param expandable expandable set into which variational equations should be registered\n-     * @exception MathIllegalArgumentException if the primary set of the expandable set does\n+     * @throws DimensionMismatchException if the dimension of the partial state does not\n+     * match the selected equations set dimension\n+     * @exception MismatchedEquations if the primary set of the expandable set does\n      * not match the one used to build the instance\n      * @see ExpandableStatefulODE#addSecondaryEquations(SecondaryEquations)\n      */\n     public void registerVariationalEquations(final ExpandableStatefulODE expandable)\n-        throws MathIllegalArgumentException {\n+        throws DimensionMismatchException, MismatchedEquations {\n \n         // safety checks\n         final FirstOrderDifferentialEquations ode = (jode instanceof MainStateJacobianWrapper) ?\n                                                     ((MainStateJacobianWrapper) jode).ode :\n                                                     jode;\n         if (expandable.getPrimary() != ode) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNMATCHED_ODE_IN_EXPANDED_SET);\n+            throw new MismatchedEquations();\n         }\n \n         efode = expandable;\n         jacobianProviders.add(provider);\n     }\n \n-    /** Add a parameter Jacobian provider.\n+    /** Set a parameter Jacobian provider.\n      * @param parameterizedOde the parameterized ODE to compute the parameter Jacobian matrix using finite differences\n      */\n     public void setParameterizedODE(final ParameterizedODE parameterizedOde) {\n      * @param parameter parameter to consider for Jacobian processing\n      * @param hP step for Jacobian finite difference computation w.r.t. the specified parameter\n      * @see ParameterizedODE\n-     * @exception IllegalArgumentException if the parameter is not supported\n-     */\n-    public void setParameterStep(final String parameter, final double hP) {\n+     * @exception UnknownParameterException if the parameter is not supported\n+     */\n+    public void setParameterStep(final String parameter, final double hP)\n+        throws UnknownParameterException {\n \n         for (ParameterConfiguration param: selectedParameters) {\n             if (parameter.equals(param.getParameterName())) {\n             }\n         }\n \n-        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, parameter);\n+        throw new UnknownParameterException(parameter);\n \n     }\n \n      * </p>\n      * @param pName parameter name\n      * @param dYdP initial Jacobian column vector with respect to the parameter\n-     * @exception MathIllegalArgumentException if a parameter is not supported\n+     * @exception UnknownParameterException if a parameter is not supported\n+     * @throws DimensionMismatchException if the column vector does not match state dimension\n      */\n     public void setInitialParameterJacobian(final String pName, final double[] dYdP)\n-        throws MathIllegalArgumentException {\n+        throws UnknownParameterException, DimensionMismatchException {\n \n         // Check dimensions\n         checkDimension(stateDim, dYdP);\n             i += stateDim;\n         }\n \n-        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, pName);\n+        throw new UnknownParameterException(pName);\n \n     }\n \n \n         /** {@inheritDoc} */\n         public void computeDerivatives(final double t, final double[] y, final double[] yDot,\n-                                       final double[] z, final double[] zDot) {\n+                                       final double[] z, final double[] zDot)\n+            throws MaxCountExceededException, DimensionMismatchException {\n \n             // Lazy initialization\n             if (dirtyParameter && (paramDim != 0)) {\n                 int startIndex = stateDim * stateDim;\n                 for (ParameterConfiguration param: selectedParameters) {\n                     boolean found = false;\n-                    for (ParameterJacobianProvider provider: jacobianProviders) {\n+                    for (int k = 0 ; (!found) && (k < jacobianProviders.size()); ++k) {\n+                        final ParameterJacobianProvider provider = jacobianProviders.get(k);\n                         if (provider.isSupported(param.getParameterName())) {\n                             try {\n-                                provider.computeParameterJacobian(t, y, yDot, param.getParameterName(), dFdP);\n-                                for (int i = 0; i < stateDim; ++i) {\n-                                    final double[] dFdYi = dFdY[i];\n-                                    int zIndex = startIndex;\n-                                    double s = dFdP[i];\n-                                    for (int l = 0; l < stateDim; ++l) {\n-                                        s += dFdYi[l] * z[zIndex];\n-                                        zIndex++;\n-                                    }\n-                                    zDot[startIndex + i] = s;\n+                                provider.computeParameterJacobian(t, y, yDot,\n+                                                                  param.getParameterName(), dFdP);\n+                            } catch (UnknownParameterException upe) {\n+                                // this should never happen as we have check support beforehand\n+                                throw new MathInternalError(upe);\n+                            }\n+                            for (int i = 0; i < stateDim; ++i) {\n+                                final double[] dFdYi = dFdY[i];\n+                                int zIndex = startIndex;\n+                                double s = dFdP[i];\n+                                for (int l = 0; l < stateDim; ++l) {\n+                                    s += dFdYi[l] * z[zIndex];\n+                                    zIndex++;\n                                 }\n-                                startIndex += stateDim;\n-                                found = true;\n-                                break;\n-                            } catch (IllegalArgumentException iae) {\n+                                zDot[startIndex + i] = s;\n                             }\n+                            found = true;\n                         }\n                     }\n                     if (! found) {\n-                        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n-                                                               param);\n+                        Arrays.fill(zDot, startIndex, startIndex + stateDim, 0.0);\n                     }\n+                    startIndex += stateDim;\n                 }\n             }\n \n          * @param ode original ODE problem, without jacobians computation skill\n          * @param hY step sizes to compute the jacobian df/dy\n          * @see JacobianMatrices#setMainStateSteps(double[])\n+         * @exception DimensionMismatchException if there is a dimension mismatch between\n+         * the steps array {@code hY} and the equation dimension\n          */\n         public MainStateJacobianWrapper(final FirstOrderDifferentialEquations ode,\n-                                        final double[] hY) {\n+                                        final double[] hY)\n+            throws DimensionMismatchException {\n             this.ode = ode;\n             this.hY = hY.clone();\n+            if (hY.length != ode.getDimension()) {\n+                throw new DimensionMismatchException(ode.getDimension(), hY.length);\n+            }\n         }\n \n         /** {@inheritDoc} */\n         }\n \n         /** {@inheritDoc} */\n-        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+        public void computeDerivatives(double t, double[] y, double[] yDot)\n+            throws MaxCountExceededException, DimensionMismatchException {\n             ode.computeDerivatives(t, y, yDot);\n         }\n \n         /** {@inheritDoc} */\n-        public void computeMainStateJacobian(double t, double[] y, double[] yDot,\n-                                             double[][] dFdY) {\n+        public void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY)\n+            throws MaxCountExceededException, DimensionMismatchException {\n \n             final int n = ode.getDimension();\n             final double[] tmpDot = new double[n];\n \n     }\n \n+    /** Special exception for equations mismatch. */\n+    public static class MismatchedEquations extends MathIllegalArgumentException {\n+\n+        /** Serializable UID. */\n+        private static final long serialVersionUID = 20120902L;\n+\n+        /** Simple constructor. */\n+        public MismatchedEquations() {\n+            super(LocalizedFormats.UNMATCHED_ODE_IN_EXPANDED_SET);\n+        }\n+\n+    }\n+\n }\n \n--- a/src/main/java/org/apache/commons/math3/ode/MainStateJacobianProvider.java\n+++ b/src/main/java/org/apache/commons/math3/ode/MainStateJacobianProvider.java\n  */\n package org.apache.commons.math3.ode;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+\n /** Interface expanding {@link FirstOrderDifferentialEquations first order\n  *  differential equations} in order to compute exactly the main state jacobian\n  *  matrix for {@link JacobianMatrices partial derivatives equations}.\n      * @param y array containing the current value of the main state vector\n      * @param yDot array containing the current value of the time derivative of the main state vector\n      * @param dFdY placeholder array where to put the jacobian matrix of the ODE w.r.t. the main state vector\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n      */\n-    void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY);\n+    void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY)\n+        throws MaxCountExceededException, DimensionMismatchException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/MultistepIntegrator.java\n \n package org.apache.commons.math3.ode;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator;\n      * integration)\n      * @param scalAbsoluteTolerance allowed absolute error\n      * @param scalRelativeTolerance allowed relative error\n+     * @exception NumberIsTooSmallException if number of steps is smaller than 2\n      */\n     protected MultistepIntegrator(final String name, final int nSteps,\n                                   final int order,\n                                   final double minStep, final double maxStep,\n                                   final double scalAbsoluteTolerance,\n-                                  final double scalRelativeTolerance) {\n+                                  final double scalRelativeTolerance)\n+        throws NumberIsTooSmallException {\n \n         super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n \n-        if (nSteps <= 1) {\n-            throw new MathIllegalArgumentException(\n+        if (nSteps < 2) {\n+            throw new NumberIsTooSmallException(\n                   LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS,\n-                  name);\n+                  nSteps, 2, true);\n         }\n \n         starter = new DormandPrince853Integrator(minStep, maxStep,\n      * @param y0 initial value of the state vector at t0\n      * @param t target time for the integration\n      * (can be set to a value smaller than <code>t0</code> for backward integration)\n-     * @throws MathIllegalStateException if the integrator cannot perform integration\n+     * @exception DimensionMismatchException if arrays dimension do not match equations settings\n+     * @exception NumberIsTooSmallException if integration step is too small\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception NoBracketingException if the location of an event cannot be bracketed\n      */\n     protected void start(final double t0, final double[] y0, final double t)\n-        throws MathIllegalStateException {\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n \n         // make sure NO user event nor user step handler is triggered,\n         // this is the task of the top level integrator, not the task\n         }\n \n         /** {@inheritDoc} */\n-        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+            throws MaxCountExceededException {\n \n             final double prev = interpolator.getPreviousTime();\n             final double curr = interpolator.getCurrentTime();\n         }\n \n         /** {@inheritDoc} */\n-        public void computeDerivatives(double t, double[] y, double[] dot) {\n+        public void computeDerivatives(double t, double[] y, double[] dot)\n+            throws MaxCountExceededException, DimensionMismatchException {\n             MultistepIntegrator.this.computeDerivatives(t, y, dot);\n         }\n \n--- a/src/main/java/org/apache/commons/math3/ode/ParameterJacobianProvider.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ParameterJacobianProvider.java\n  */\n package org.apache.commons.math3.ode;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n /** Interface to compute exactly Jacobian matrix for some parameter\n  *  when computing {@link JacobianMatrices partial derivatives equations}.\n public interface ParameterJacobianProvider extends Parameterizable {\n \n     /** Compute the Jacobian matrix of ODE with respect to one parameter.\n-     * <p>The parameter must be one given by {@link #getParametersNames()}.</p>\n+     * <p>If the parameter does not belong to the collection returned by\n+     * {@link #getParametersNames()}, the Jacobian will be set to 0,\n+     * but no errors will be triggered.</p>\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the main state vector\n      * @param yDot array containing the current value of the time derivative\n      * @param paramName name of the parameter to consider\n      * @param dFdP placeholder array where to put the Jacobian matrix of the\n      * ODE with respect to the parameter\n-     * @throws MathIllegalArgumentException if the parameter is not supported\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n+     * @exception UnknownParameterException if the parameter is not supported\n      */\n     void computeParameterJacobian(double t, double[] y, double[] yDot,\n                                   String paramName, double[] dFdP)\n-        throws MathIllegalArgumentException;\n+        throws DimensionMismatchException, MaxCountExceededException, UnknownParameterException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/ParameterJacobianWrapper.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ParameterJacobianWrapper.java\n  */\n package org.apache.commons.math3.ode;\n \n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n /** Wrapper class to compute Jacobian matrices by finite differences for ODE\n  *  which do not compute them by themselves.\n \n     /** {@inheritDoc} */\n     public void computeParameterJacobian(double t, double[] y, double[] yDot,\n-                                         String paramName, double[] dFdP) {\n+                                         String paramName, double[] dFdP)\n+        throws DimensionMismatchException, MaxCountExceededException {\n \n         final int n = fode.getDimension();\n-        final double[] tmpDot = new double[n];\n+        if (pode.isSupported(paramName)) {\n+            try {\n+                final double[] tmpDot = new double[n];\n \n-        // compute the jacobian df/dp w.r.t. parameter\n-        final double p  = pode.getParameter(paramName);\n-        final double hP = hParam.get(paramName);\n-        pode.setParameter(paramName, p + hP);\n-        fode.computeDerivatives(t, y, tmpDot);\n-        for (int i = 0; i < n; ++i) {\n-            dFdP[i] = (tmpDot[i] - yDot[i]) / hP;\n+                // compute the jacobian df/dp w.r.t. parameter\n+                final double p  = pode.getParameter(paramName);\n+                final double hP = hParam.get(paramName);\n+                pode.setParameter(paramName, p + hP);\n+                fode.computeDerivatives(t, y, tmpDot);\n+                for (int i = 0; i < n; ++i) {\n+                    dFdP[i] = (tmpDot[i] - yDot[i]) / hP;\n+                }\n+                pode.setParameter(paramName, p);\n+            } catch (MathIllegalArgumentException miae) {\n+                // this should never happen as we have checked the parameter is supported\n+                throw new MathInternalError(miae);\n+            }\n+        } else {\n+            Arrays.fill(dFdP, 0, n, 0.0);\n         }\n-        pode.setParameter(paramName, p);\n \n     }\n \n--- a/src/main/java/org/apache/commons/math3/ode/ParameterizedODE.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ParameterizedODE.java\n  */\n package org.apache.commons.math3.ode;\n \n+\n /** Interface to compute by finite difference Jacobian matrix for some parameter\n  *  when computing {@link JacobianMatrices partial derivatives equations}.\n  *\n     /** Get parameter value from its name.\n      * @param name parameter name\n      * @return parameter value\n-     * @exception IllegalArgumentException if parameter is not supported\n+     * @exception UnknownParameterException if parameter is not supported\n      */\n-    double getParameter(String name) throws IllegalArgumentException;\n+    double getParameter(String name) throws UnknownParameterException;\n \n     /** Set the value for a given parameter.\n      * @param name parameter name\n      * @param value parameter value\n-     * @exception IllegalArgumentException if parameter is not supported\n+     * @exception UnknownParameterException if parameter is not supported\n      */\n-    void setParameter(String name, double value) throws IllegalArgumentException;\n+    void setParameter(String name, double value) throws UnknownParameterException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/ParameterizedWrapper.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ParameterizedWrapper.java\n import java.util.ArrayList;\n import java.util.Collection;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n /** Wrapper class enabling {@link FirstOrderDifferentialEquations basic simple}\n  *  ODE instances to be used when processing {@link JacobianMatrices}.\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the state vector\n      * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n      */\n-    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    public void computeDerivatives(double t, double[] y, double[] yDot)\n+        throws MaxCountExceededException, DimensionMismatchException {\n         fode.computeDerivatives(t, y, yDot);\n     }\n \n \n     /** {@inheritDoc} */\n     public double getParameter(String name)\n-        throws MathIllegalArgumentException {\n+        throws UnknownParameterException {\n         if (!isSupported(name)) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, name);\n+            throw new UnknownParameterException(name);\n         }\n         return Double.NaN;\n     }\n--- a/src/main/java/org/apache/commons/math3/ode/SecondaryEquations.java\n+++ b/src/main/java/org/apache/commons/math3/ode/SecondaryEquations.java\n  */\n \n package org.apache.commons.math3.ode;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n /**\n  * This interface allows users to add secondary differential equations to a primary\n      * @param primaryDot array containing the derivative of the primary state vector\n      * @param secondary array containing the current value of the secondary state vector\n      * @param secondaryDot placeholder array where to put the derivative of the secondary state vector\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n      */\n     void computeDerivatives(double t, double[] primary, double[] primaryDot,\n-                            double[] secondary, double[] secondaryDot);\n+                            double[] secondary, double[] secondaryDot)\n+        throws MaxCountExceededException, DimensionMismatchException;\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ode/UnknownParameterException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.ode;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a parameter is unknown.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class UnknownParameterException extends MathIllegalArgumentException {\n+\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = 20120902L;\n+\n+    /** Parameter name. */\n+    private final String name;\n+\n+    /**\n+     * Construct an exception from the unknown parameter.\n+     *\n+     * @param name parameter name.\n+     */\n+    public UnknownParameterException(final String name) {\n+        super(LocalizedFormats.UNKNOWN_PARAMETER);\n+        this.name = name;\n+    }\n+\n+    /**\n+     * @return the name of the unknown parameter.\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math3/ode/events/EventState.java\n import org.apache.commons.math3.analysis.solvers.PegasusSolver;\n import org.apache.commons.math3.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils;\n-import org.apache.commons.math3.exception.ConvergenceException;\n-import org.apache.commons.math3.ode.events.EventHandler;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.ode.sampling.StepInterpolator;\n import org.apache.commons.math3.util.FastMath;\n \n \n     /** Reinitialize the beginning of the step.\n      * @param interpolator valid for the current step\n-     */\n-    public void reinitializeBegin(final StepInterpolator interpolator) {\n+     * @exception MaxCountExceededException if the interpolator throws one because\n+     * the number of functions evaluations is exceeded\n+     */\n+    public void reinitializeBegin(final StepInterpolator interpolator)\n+        throws MaxCountExceededException {\n \n         t0 = interpolator.getPreviousTime();\n         interpolator.setInterpolatedTime(t0);\n      * @param interpolator step interpolator for the proposed step\n      * @return true if the event handler triggers an event before\n      * the end of the proposed step\n-     * @exception ConvergenceException if an event cannot be located\n+     * @exception MaxCountExceededException if the interpolator throws one because\n+     * the number of functions evaluations is exceeded\n+     * @exception NoBracketingException if the event cannot be bracketed\n      */\n     public boolean evaluateStep(final StepInterpolator interpolator)\n-        throws ConvergenceException {\n-\n+        throws MaxCountExceededException, NoBracketingException {\n+\n+        try {\n             forward = interpolator.isForward();\n             final double t1 = interpolator.getCurrentTime();\n             final double dt = t1 - t0;\n             final double h = dt / n;\n \n             final UnivariateFunction f = new UnivariateFunction() {\n-                public double value(final double t) {\n-                    interpolator.setInterpolatedTime(t);\n-                    return handler.g(t, interpolator.getInterpolatedState());\n+                public double value(final double t) throws LocalMaxCountExceededException {\n+                    try {\n+                        interpolator.setInterpolatedTime(t);\n+                        return handler.g(t, interpolator.getInterpolatedState());\n+                    } catch (MaxCountExceededException mcee) {\n+                        throw new LocalMaxCountExceededException(mcee);\n+                    }\n                 }\n             };\n \n             pendingEventTime = Double.NaN;\n             return false;\n \n+        } catch (LocalMaxCountExceededException lmcee) {\n+            throw lmcee.getException();\n+        }\n+\n     }\n \n     /** Get the occurrence time of the event triggered in the current step.\n \n     }\n \n+    /** Local wrapper to propagate exceptions. */\n+    private static class LocalMaxCountExceededException extends RuntimeException {\n+\n+        /** Serializable UID. */\n+        private static final long serialVersionUID = 20120901L;\n+\n+        /** Wrapped exception. */\n+        private final MaxCountExceededException wrapped;\n+\n+        /** Simple constructor.\n+         * @param exception exception to wrap\n+         */\n+        public LocalMaxCountExceededException(final MaxCountExceededException exception) {\n+            wrapped = exception;\n+        }\n+\n+        /** Get the wrapped exception.\n+         * @return wrapped exception\n+         */\n+        public MaxCountExceededException getException() {\n+            return wrapped;\n+        }\n+\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegrator.java\n \n package org.apache.commons.math3.ode.nonstiff;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.sampling.NordsieckStepInterpolator;\n      * be smaller than this\n      * @param scalAbsoluteTolerance allowed absolute error\n      * @param scalRelativeTolerance allowed relative error\n-     * @exception IllegalArgumentException if order is 1 or less\n+     * @exception NumberIsTooSmallException if order is 1 or less\n      */\n     public AdamsBashforthIntegrator(final int nSteps,\n                                     final double minStep, final double maxStep,\n                                     final double scalAbsoluteTolerance,\n                                     final double scalRelativeTolerance)\n-        throws IllegalArgumentException {\n+        throws NumberIsTooSmallException {\n         super(METHOD_NAME, nSteps, nSteps, minStep, maxStep,\n               scalAbsoluteTolerance, scalRelativeTolerance);\n     }\n     /** {@inheritDoc} */\n     @Override\n     public void integrate(final ExpandableStatefulODE equations, final double t)\n-        throws MathIllegalStateException, MathIllegalArgumentException {\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException {\n \n         sanityChecks(equations, t);\n         setEquations(equations);\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsIntegrator.java\n \n package org.apache.commons.math3.ode.nonstiff;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.MultistepIntegrator;\n      * be smaller than this\n      * @param scalAbsoluteTolerance allowed absolute error\n      * @param scalRelativeTolerance allowed relative error\n-     * @exception IllegalArgumentException if order is 1 or less\n+     * @exception NumberIsTooSmallException if order is 1 or less\n      */\n     public AdamsIntegrator(final String name, final int nSteps, final int order,\n                            final double minStep, final double maxStep,\n                            final double scalAbsoluteTolerance,\n                            final double scalRelativeTolerance)\n-        throws IllegalArgumentException {\n+        throws NumberIsTooSmallException {\n         super(name, nSteps, order, minStep, maxStep,\n               scalAbsoluteTolerance, scalRelativeTolerance);\n         transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n     /** {@inheritDoc} */\n     @Override\n     public abstract void integrate(final ExpandableStatefulODE equations, final double t)\n-        throws MathIllegalStateException, MathIllegalArgumentException;\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException;\n \n     /** {@inheritDoc} */\n     @Override\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegrator.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.RealMatrixPreservingVisitor;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n      * be smaller than this\n      * @param scalAbsoluteTolerance allowed absolute error\n      * @param scalRelativeTolerance allowed relative error\n-     * @exception IllegalArgumentException if order is 1 or less\n+     * @exception NumberIsTooSmallException if order is 1 or less\n      */\n     public AdamsMoultonIntegrator(final int nSteps,\n                                   final double minStep, final double maxStep,\n                                   final double scalAbsoluteTolerance,\n                                   final double scalRelativeTolerance)\n-        throws IllegalArgumentException {\n+        throws NumberIsTooSmallException {\n         super(METHOD_NAME, nSteps, nSteps + 1, minStep, maxStep,\n               scalAbsoluteTolerance, scalRelativeTolerance);\n     }\n     /** {@inheritDoc} */\n     @Override\n     public void integrate(final ExpandableStatefulODE equations,final double t)\n-        throws MathIllegalStateException, MathIllegalArgumentException {\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException {\n \n         sanityChecks(equations, t);\n         setEquations(equations);\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n package org.apache.commons.math3.ode.nonstiff;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.ode.AbstractIntegrator;\n    * @param y1 work array for a state vector\n    * @param yDot1 work array for the first time derivative of y1\n    * @return first integration step\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n    */\n   public double initializeStep(final boolean forward, final int order, final double[] scale,\n                                final double t0, final double[] y0, final double[] yDot0,\n-                               final double[] y1, final double[] yDot1) {\n+                               final double[] y1, final double[] yDot1)\n+      throws MaxCountExceededException, DimensionMismatchException {\n \n     if (initialStep > 0) {\n       // use the user provided value\n   /** {@inheritDoc} */\n   @Override\n   public abstract void integrate (ExpandableStatefulODE equations, double t)\n-    throws MathIllegalStateException, MathIllegalArgumentException;\n+      throws NumberIsTooSmallException, DimensionMismatchException,\n+             MaxCountExceededException, NoBracketingException;\n \n   /** {@inheritDoc} */\n   @Override\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.ode.AbstractIntegrator;\n import org.apache.commons.math3.ode.EquationsMapper;\n import org.apache.commons.math3.ode.sampling.StepInterpolator;\n   /** {@inheritDoc} */\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n-                                          final double oneMinusThetaH) {\n+                                          final double oneMinusThetaH)\n+      throws MaxCountExceededException {\n \n     if (! vectorsInitialized) {\n \n \n   /** {@inheritDoc} */\n   @Override\n-  protected void doFinalize() {\n-\n-    if (currentState == null) {\n-      // we are finalizing an uninitialized instance\n-      return;\n-    }\n-\n-    double s;\n-    final double[] yTmp = new double[currentState.length];\n-    final double pT = getGlobalPreviousTime();\n-\n-    // k14\n-    for (int j = 0; j < currentState.length; ++j) {\n-      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n-          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n-          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n-      yTmp[j] = currentState[j] + h * s;\n-    }\n-    integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n-\n-    // k15\n-    for (int j = 0; j < currentState.length; ++j) {\n-     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n-         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n-         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n-         K15_14 * yDotKLast[0][j];\n-     yTmp[j] = currentState[j] + h * s;\n-    }\n-    integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n-\n-    // k16\n-    for (int j = 0; j < currentState.length; ++j) {\n-      s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n-          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n-          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n-          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n-      yTmp[j] = currentState[j] + h * s;\n-    }\n-    integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n+  protected void doFinalize() throws MaxCountExceededException {\n+\n+      try {\n+          if (currentState == null) {\n+              // we are finalizing an uninitialized instance\n+              return;\n+          }\n+\n+          double s;\n+          final double[] yTmp = new double[currentState.length];\n+          final double pT = getGlobalPreviousTime();\n+\n+          // k14\n+          for (int j = 0; j < currentState.length; ++j) {\n+              s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n+                      K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n+                      K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n+              yTmp[j] = currentState[j] + h * s;\n+          }\n+          integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n+\n+          // k15\n+          for (int j = 0; j < currentState.length; ++j) {\n+              s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n+                      K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n+                      K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n+                      K15_14 * yDotKLast[0][j];\n+              yTmp[j] = currentState[j] + h * s;\n+          }\n+          integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n+\n+          // k16\n+          for (int j = 0; j < currentState.length; ++j) {\n+              s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n+                      K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n+                      K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n+                      K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n+              yTmp[j] = currentState[j] + h * s;\n+          }\n+          integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n+      } catch (DimensionMismatchException dme) {\n+          throw new MathInternalError(dme);\n+      }\n \n   }\n \n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n-    // save the local attributes\n-    finalizeStep();\n+    try {\n+        // save the local attributes\n+        finalizeStep();\n+    } catch (MaxCountExceededException mcee) {\n+        final IOException ioe = new IOException(mcee.getLocalizedMessage());\n+        ioe.initCause(mcee);\n+        throw ioe;\n+    }\n \n     final int dimension = (currentState == null) ? -1 : currentState.length;\n     out.writeInt(dimension);\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n package org.apache.commons.math3.ode.nonstiff;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.util.FastMath;\n \n   /** {@inheritDoc} */\n   @Override\n   public void integrate(final ExpandableStatefulODE equations, final double t)\n-      throws MathIllegalStateException, MathIllegalArgumentException {\n+      throws NumberIsTooSmallException, DimensionMismatchException,\n+             MaxCountExceededException, NoBracketingException {\n \n     sanityChecks(equations, t);\n     setEquations(equations);\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerIntegrator.java\n package org.apache.commons.math3.ode.nonstiff;\n \n import org.apache.commons.math3.analysis.solvers.UnivariateSolver;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.events.EventHandler;\n import org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\n    * @param yTmp placeholder for one state vector\n    * @return true if computation was done properly,\n    *         false if stability check failed before end of computation\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n    */\n   private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                           final double[] scale, final double[][] f,\n                           final double[] yMiddle, final double[] yEnd,\n-                          final double[] yTmp) {\n+                          final double[] yTmp)\n+      throws MaxCountExceededException, DimensionMismatchException {\n \n     final int    n        = sequence[k];\n     final double subStep  = step / n;\n   /** {@inheritDoc} */\n   @Override\n   public void integrate(final ExpandableStatefulODE equations, final double t)\n-      throws MathIllegalStateException, MathIllegalArgumentException {\n+      throws NumberIsTooSmallException, DimensionMismatchException,\n+             MaxCountExceededException, NoBracketingException {\n \n     sanityChecks(equations, t);\n     setEquations(equations);\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\n package org.apache.commons.math3.ode.nonstiff;\n \n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.AbstractIntegrator;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.util.FastMath;\n   /** {@inheritDoc} */\n   @Override\n   public void integrate(final ExpandableStatefulODE equations, final double t)\n-      throws MathIllegalStateException, MathIllegalArgumentException {\n+      throws NumberIsTooSmallException, DimensionMismatchException,\n+             MaxCountExceededException, NoBracketingException {\n \n     sanityChecks(equations, t);\n     setEquations(equations);\n--- a/src/main/java/org/apache/commons/math3/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/sampling/AbstractStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.ode.EquationsMapper;\n \n /** This abstract class represents an interpolator over the last step\n   }\n \n   /** {@inheritDoc} */\n-   public StepInterpolator copy() {\n+   public StepInterpolator copy() throws MaxCountExceededException {\n \n      // finalize the step before performing copy\n      finalizeStep();\n    * (theta is zero at the previous time step and one at the current time step)\n    * @param oneMinusThetaH time gap between the interpolated time and\n    * the current time\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n    */\n   protected abstract void computeInterpolatedStateAndDerivatives(double theta,\n-                                                                 double oneMinusThetaH);\n+                                                                 double oneMinusThetaH)\n+      throws MaxCountExceededException;\n \n   /** Lazy evaluation of complete interpolated state.\n-   */\n-  private void evaluateCompleteInterpolatedState() {\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   */\n+  private void evaluateCompleteInterpolatedState()\n+      throws MaxCountExceededException {\n       // lazy evaluation of the state\n       if (dirtyState) {\n           final double oneMinusThetaH = globalCurrentTime - interpolatedTime;\n   }\n \n   /** {@inheritDoc} */\n-  public double[] getInterpolatedState() {\n+  public double[] getInterpolatedState() throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      primaryMapper.extractEquationData(interpolatedState,\n-                                        interpolatedPrimaryState);\n+      try {\n+          primaryMapper.extractEquationData(interpolatedState,\n+                                            interpolatedPrimaryState);\n+      } catch (DimensionMismatchException dme) {\n+          // this should never happen\n+          throw new MathInternalError(dme);\n+      }\n       return interpolatedPrimaryState;\n   }\n \n   /** {@inheritDoc} */\n-  public double[] getInterpolatedDerivatives() {\n+  public double[] getInterpolatedDerivatives() throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      primaryMapper.extractEquationData(interpolatedDerivatives,\n-                                        interpolatedPrimaryDerivatives);\n+      try {\n+          primaryMapper.extractEquationData(interpolatedDerivatives,\n+                                            interpolatedPrimaryDerivatives);\n+      } catch (DimensionMismatchException dme) {\n+          // this should never happen\n+          throw new MathInternalError(dme);\n+      }\n       return interpolatedPrimaryDerivatives;\n   }\n \n   /** {@inheritDoc} */\n-  public double[] getInterpolatedSecondaryState(final int index) {\n+  public double[] getInterpolatedSecondaryState(final int index) throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      secondaryMappers[index].extractEquationData(interpolatedState,\n-                                                  interpolatedSecondaryState[index]);\n+      try {\n+          secondaryMappers[index].extractEquationData(interpolatedState,\n+                                                      interpolatedSecondaryState[index]);\n+      } catch (DimensionMismatchException dme) {\n+          // this should never happen\n+          throw new MathInternalError(dme);\n+      }\n       return interpolatedSecondaryState[index];\n   }\n \n   /** {@inheritDoc} */\n-  public double[] getInterpolatedSecondaryDerivatives(final int index) {\n+  public double[] getInterpolatedSecondaryDerivatives(final int index) throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      secondaryMappers[index].extractEquationData(interpolatedDerivatives,\n-                                                  interpolatedSecondaryDerivatives[index]);\n+      try {\n+          secondaryMappers[index].extractEquationData(interpolatedDerivatives,\n+                                                      interpolatedSecondaryDerivatives[index]);\n+      } catch (DimensionMismatchException dme) {\n+          // this should never happen\n+          throw new MathInternalError(dme);\n+      }\n       return interpolatedSecondaryDerivatives[index];\n   }\n \n    * Therefore, subclasses are not allowed not reimplement it, they\n    * should rather reimplement <code>doFinalize</code>.</p>\n \n-   */\n-  public final void finalizeStep() {\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+\n+   */\n+  public final void finalizeStep() throws MaxCountExceededException {\n     if (! finalized) {\n       doFinalize();\n       finalized = true;\n   /**\n    * Really finalize the step.\n    * The default implementation of this method does nothing.\n-   */\n-  protected void doFinalize() {\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   */\n+  protected void doFinalize() throws MaxCountExceededException {\n   }\n \n   /** {@inheritDoc} */\n     // we do not store the interpolated state,\n     // it will be recomputed as needed after reading\n \n-    // finalize the step (and don't bother saving the now true flag)\n-    finalizeStep();\n+    try {\n+        // finalize the step (and don't bother saving the now true flag)\n+        finalizeStep();\n+    } catch (MaxCountExceededException mcee) {\n+        final IOException ioe = new IOException(mcee.getLocalizedMessage());\n+        ioe.initCause(mcee);\n+        throw ioe;\n+    }\n \n   }\n \n--- a/src/main/java/org/apache/commons/math3/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/sampling/NordsieckStepInterpolator.java\n import java.io.ObjectOutput;\n import java.util.Arrays;\n \n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.ode.EquationsMapper;\n import org.apache.commons.math3.util.FastMath;\n      * to be preserved across several calls.</p>\n      * @return state vector at time {@link #getInterpolatedTime}\n      * @see #getInterpolatedDerivatives()\n-     */\n-    public double[] getInterpolatedStateVariation() {\n+     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+     */\n+    public double[] getInterpolatedStateVariation() throws MaxCountExceededException {\n         // compute and ignore interpolated state\n         // to make sure state variation is computed as a side effect\n         getInterpolatedState();\n--- a/src/main/java/org/apache/commons/math3/ode/sampling/StepHandler.java\n+++ b/src/main/java/org/apache/commons/math3/ode/sampling/StepHandler.java\n  */\n \n package org.apache.commons.math3.ode.sampling;\n+\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n \n /**\n      * Keeping only a reference to the interpolator and reusing it will\n      * result in unpredictable behavior (potentially crashing the application).\n      * @param isLast true if the step is the last one\n+     * @exception MaxCountExceededException if the interpolator throws one because\n+     * the number of functions evaluations is exceeded\n      */\n-    void handleStep(StepInterpolator interpolator, boolean isLast);\n+    void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/sampling/StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/sampling/StepInterpolator.java\n package org.apache.commons.math3.ode.sampling;\n \n import java.io.Externalizable;\n+\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n \n /** This interface represents an interpolator over the last step\n  * during an ODE integration.\n    * to be preserved across several calls.</p>\n    * @return state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedDerivatives()\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n    */\n-  double[] getInterpolatedState();\n+  double[] getInterpolatedState() throws MaxCountExceededException;\n \n   /**\n    * Get the derivatives of the state vector of the interpolated point.\n    * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedState()\n    * @since 2.0\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n    */\n-  double[] getInterpolatedDerivatives();\n+  double[] getInterpolatedDerivatives() throws MaxCountExceededException;\n \n   /** Get the interpolated secondary state corresponding to the secondary equations.\n    * <p>The returned vector is a reference to a reused array, so\n    * @see #getInterpolatedSecondaryDerivatives(int)\n    * @see #setInterpolatedTime(double)\n    * @since 3.0\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n    */\n-  double[] getInterpolatedSecondaryState(int index);\n+  double[] getInterpolatedSecondaryState(int index) throws MaxCountExceededException;\n \n   /** Get the interpolated secondary derivatives corresponding to the secondary equations.\n    * <p>The returned vector is a reference to a reused array, so\n    * @see #getInterpolatedSecondaryState(int)\n    * @see #setInterpolatedTime(double)\n    * @since 3.0\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n    */\n-  double[] getInterpolatedSecondaryDerivatives(int index);\n+  double[] getInterpolatedSecondaryDerivatives(int index) throws MaxCountExceededException;\n \n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by\n    * interpolated time without any side effect.</p>\n    * @return a deep copy of the instance, which can be used independently.\n    * @see #setInterpolatedTime(double)\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * during step finalization\n    */\n-   StepInterpolator copy();\n+   StepInterpolator copy() throws MaxCountExceededException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math3/ode/sampling/StepNormalizer.java\n \n package org.apache.commons.math3.ode.sampling;\n \n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Precision;\n \n      * should build a local copy using the clone method and store this\n      * copy.\n      * @param isLast true if the step is the last one\n-     */\n-    public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+     * @exception MaxCountExceededException if the interpolator throws one because\n+     * the number of functions evaluations is exceeded\n+     */\n+    public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n+        throws MaxCountExceededException {\n         // The first time, update the last state with the start information.\n         if (lastState == null) {\n             firstTime = interpolator.getPreviousTime();\n      * @param interpolator interpolator for the last accepted step, to use to\n      * get the interpolated information\n      * @param t the time for which to store the interpolated information\n-     */\n-    private void storeStep(StepInterpolator interpolator, double t) {\n+     * @exception MaxCountExceededException if the interpolator throws one because\n+     * the number of functions evaluations is exceeded\n+     */\n+    private void storeStep(StepInterpolator interpolator, double t)\n+        throws MaxCountExceededException {\n         lastTime = t;\n         interpolator.setInterpolatedTime(lastTime);\n         System.arraycopy(interpolator.getInterpolatedState(), 0,\n--- a/src/test/java/org/apache/commons/math3/ode/ContinuousOutputModelTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/ContinuousOutputModelTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince54Integrator;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math3.ode.sampling.DummyStepInterpolator;\n   }\n \n   @Test\n-  public void testBoundaries() {\n+  public void testBoundaries() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n     integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n   }\n \n   @Test\n-  public void testRandomAccess() {\n+  public void testRandomAccess() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n \n     ContinuousOutputModel cm = new ContinuousOutputModel();\n     integ.addStepHandler(cm);\n   }\n \n   @Test\n-  public void testModelsMerging() {\n+  public void testModelsMerging() throws MaxCountExceededException, MathIllegalArgumentException {\n \n       // theoretical solution: y[0] = cos(t), y[1] = sin(t)\n       FirstOrderDifferentialEquations problem =\n   }\n \n   @Test\n-  public void testErrorConditions() {\n+  public void testErrorConditions() throws MaxCountExceededException, MathIllegalArgumentException {\n \n       ContinuousOutputModel cm = new ContinuousOutputModel();\n       cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);\n   }\n \n   private boolean checkAppendError(ContinuousOutputModel cm,\n-                                   double t0, double[] y0, double t1) {\n+                                   double t0, double[] y0, double t1)\n+      throws MaxCountExceededException, MathIllegalArgumentException {\n       try {\n           ContinuousOutputModel otherCm = new ContinuousOutputModel();\n           otherCm.handleStep(buildInterpolator(t0, y0, t1), true);\n--- a/src/test/java/org/apache/commons/math3/ode/FirstOrderConverterTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/FirstOrderConverterTest.java\n \n package org.apache.commons.math3.ode;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n   }\n \n   @Test\n-  public void testDecreasingSteps() {\n+  public void testDecreasingSteps()\n+      throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n \n     double previousError = Double.NaN;\n     for (int i = 0; i < 10; ++i) {\n   }\n \n   @Test\n-  public void testSmallStep() {\n+  public void testSmallStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n                    - FastMath.sin(4.0);\n     Assert.assertTrue(FastMath.abs(error) < 1.0e-10);\n   }\n \n   @Test\n-  public void testBigStep() {\n+  public void testBigStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n                    - FastMath.sin(4.0);\n     Assert.assertTrue(FastMath.abs(error) > 0.1);\n \n   private double integrateWithSpecifiedStep(double omega,\n                                             double t0, double t,\n-                                            double step)\n-  throws MathIllegalStateException, MathIllegalArgumentException {\n+                                            double step) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n     double[] y0 = new double[2];\n     y0[0] = FastMath.sin(omega * t0);\n     y0[1] = omega * FastMath.cos(omega * t0);\n--- a/src/test/java/org/apache/commons/math3/ode/JacobianMatricesTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/JacobianMatricesTest.java\n \n package org.apache.commons.math3.ode;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.ode.JacobianMatrices.MismatchedEquations;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince54Integrator;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math3.util.FastMath;\n public class JacobianMatricesTest {\n \n     @Test\n-    public void testLowAccuracyExternalDifferentiation() {\n-        // this test does not really test FirstOrderIntegratorWithJacobians,\n+    public void testLowAccuracyExternalDifferentiation()\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException {\n+        // this test does not really test JacobianMatrices,\n         // it only shows that WITHOUT this class, attempting to recover\n         // the jacobians from external differentiation on simple integration\n         // results with low accuracy gives very poor results. In fact,\n     }\n \n     @Test\n-    public void testHighAccuracyExternalDifferentiation() {\n+    public void testHighAccuracyExternalDifferentiation()\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException, UnknownParameterException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double hP = 1.0e-12;\n     }\n \n     @Test\n-    public void testInternalDifferentiation() {\n+    public void testInternalDifferentiation()\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException,\n+               UnknownParameterException, MismatchedEquations {\n         AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         double hP = 1.0e-12;\n     }\n \n     @Test\n-    public void testAnalyticalDifferentiation() {\n+    public void testAnalyticalDifferentiation()\n+        throws MaxCountExceededException, DimensionMismatchException,\n+               NumberIsTooSmallException, NoBracketingException,\n+               UnknownParameterException, MismatchedEquations {\n         AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n     }\n \n     @Test\n-    public void testFinalResult() {\n+    public void testFinalResult()\n+        throws MaxCountExceededException, DimensionMismatchException,\n+               NumberIsTooSmallException, NoBracketingException,\n+               UnknownParameterException, MismatchedEquations {\n \n         AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n     }\n \n     @Test\n-    public void testParameterizable() {\n+    public void testParameterizable()\n+        throws MaxCountExceededException, DimensionMismatchException,\n+               NumberIsTooSmallException, NoBracketingException,\n+               UnknownParameterException, MismatchedEquations {\n \n         AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n         ParameterizedCircle pcircle = new ParameterizedCircle(y, 1.0, 1.0, 0.1);\n-//        pcircle.setParameter(ParameterizedCircle.CX, 1.0);\n-//        pcircle.setParameter(ParameterizedCircle.CY, 1.0);\n-//        pcircle.setParameter(ParameterizedCircle.OMEGA, 0.1);\n \n         double hP = 1.0e-12;\n         double hY = 1.0e-12;\n \n         JacobianMatrices jacob = new JacobianMatrices(pcircle, new double[] { hY, hY },\n-                                                      Circle.CX, Circle.OMEGA);\n-        jacob.addParameterJacobianProvider(pcircle);\n+                                                      ParameterizedCircle.CX, ParameterizedCircle.CY,\n+                                                      ParameterizedCircle.OMEGA);\n         jacob.setParameterizedODE(pcircle);\n-        jacob.setParameterStep(Circle.OMEGA, hP);\n+        jacob.setParameterStep(ParameterizedCircle.CX,    hP);\n+        jacob.setParameterStep(ParameterizedCircle.CY,    hP);\n+        jacob.setParameterStep(ParameterizedCircle.OMEGA, hP);\n         jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0));\n-        jacob.setInitialParameterJacobian(Circle.CX, pcircle.exactDyDcx(0));\n-//        jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0));\n-        jacob.setInitialParameterJacobian(Circle.OMEGA, pcircle.exactDyDom(0));\n+        jacob.setInitialParameterJacobian(ParameterizedCircle.CX, pcircle.exactDyDcx(0));\n+        jacob.setInitialParameterJacobian(ParameterizedCircle.CY, pcircle.exactDyDcy(0));\n+        jacob.setInitialParameterJacobian(ParameterizedCircle.OMEGA, pcircle.exactDyDom(0));\n \n         ExpandableStatefulODE efode = new ExpandableStatefulODE(pcircle);\n         efode.setTime(0);\n         }\n \n         double[] dydp0 = new double[2];\n-        jacob.getCurrentParameterJacobian(Circle.CX, dydp0);\n+        jacob.getCurrentParameterJacobian(ParameterizedCircle.CX, dydp0);\n         for (int i = 0; i < dydp0.length; ++i) {\n             Assert.assertEquals(pcircle.exactDyDcx(t)[i], dydp0[i], 5.0e-4);\n         }\n \n         double[] dydp1 = new double[2];\n-        jacob.getCurrentParameterJacobian(Circle.OMEGA, dydp1);\n+        jacob.getCurrentParameterJacobian(ParameterizedCircle.OMEGA, dydp1);\n         for (int i = 0; i < dydp1.length; ++i) {\n             Assert.assertEquals(pcircle.exactDyDom(t)[i], dydp1[i], 1.0e-2);\n         }\n \n         public void computeParameterJacobian(double t, double[] y, double[] yDot,\n                                              String paramName, double[] dFdP) {\n-            complainIfNotSupported(paramName);\n-            dFdP[0] = -y[0];\n-            dFdP[1] = y[0];\n+            if (isSupported(paramName)) {\n+                dFdP[0] = -y[0];\n+                dFdP[1] = y[0];\n+            } else {\n+                dFdP[0] = 0;\n+                dFdP[1] = 0;\n+            }\n         }\n \n         public double dYdP0() {\n \n         /** {@inheritDoc} */\n         public double getParameter(final String name)\n-            throws IllegalArgumentException {\n+            throws UnknownParameterException {\n             complainIfNotSupported(name);\n             return b;\n         }\n \n         /** {@inheritDoc} */\n         public void setParameter(final String name, final double value)\n-            throws IllegalArgumentException {\n+            throws UnknownParameterException {\n             complainIfNotSupported(name);\n             b = value;\n         }\n         }\n \n         public void computeParameterJacobian(double t, double[] y, double[] yDot,\n-                                             String paramName, double[] dFdP) {\n+                                             String paramName, double[] dFdP)\n+            throws UnknownParameterException {\n             complainIfNotSupported(paramName);\n             if (paramName.equals(CX)) {\n                 dFdP[0] = 0;\n             return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) };\n         }\n \n-        public double[][] exactDyDp(double t) {\n-            double cos = FastMath.cos(omega * t);\n-            double sin = FastMath.sin(omega * t);\n-            double dx0 = y0[0] - cx;\n-            double dy0 = y0[1] - cy;\n-            return new double[][] {\n-                { 1 - cos, sin,    -t * (sin * dx0 + cos * dy0) },\n-                { -sin,    1 - cos, t * (cos * dx0 - sin * dy0) }\n-            };\n-        }\n-\n-        public double[] exactYDot(double t) {\n-            double oCos = omega * FastMath.cos(omega * t);\n-            double oSin = omega * FastMath.sin(omega * t);\n-            double dx0 = y0[0] - cx;\n-            double dy0 = y0[1] - cy;\n-            return new double[] {\n-                -oSin * dx0 - oCos * dy0,\n-                 oCos * dx0 - oSin * dy0\n-            };\n-        }\n-\n-        public double[][] exactDyDy0Dot(double t) {\n-            double oCos = omega * FastMath.cos(omega * t);\n-            double oSin = omega * FastMath.sin(omega * t);\n-            return new double[][] {\n-                { -oSin, -oCos },\n-                {  oCos, -oSin }\n-            };\n-        }\n-\n-        public double[][] exactDyDpDot(double t) {\n-            double cos  = FastMath.cos(omega * t);\n-            double sin  = FastMath.sin(omega * t);\n-            double oCos = omega * cos;\n-            double oSin = omega * sin;\n-            double dx0  = y0[0] - cx;\n-            double dy0  = y0[1] - cy;\n-            return new double[][] {\n-                {  oSin, oCos, -sin * dx0 - cos * dy0 - t * ( oCos * dx0 - oSin * dy0) },\n-                { -oCos, oSin,  cos * dx0 - sin * dy0 + t * (-oSin * dx0 - oCos * dy0) }\n-            };\n-        }\n-\n     }\n \n     /** ODE representing a point moving on a circle with provided center and angular rate. */\n     private static class ParameterizedCircle extends AbstractParameterizable\n-        implements FirstOrderDifferentialEquations, ParameterJacobianProvider, ParameterizedODE {\n+        implements FirstOrderDifferentialEquations, ParameterizedODE {\n \n         public static final String CX = \"cx\";\n         public static final String CY = \"cy\";\n             yDot[1] = omega * (y[0] - cx);\n         }\n \n-        public void computeParameterJacobian(double t, double[] y, double[] yDot,\n-                                             String paramName, double[] dFdP)\n-            throws IllegalArgumentException {\n-            if (paramName.equals(CX)) {\n-                dFdP[0] = 0;\n-                dFdP[1] = -omega;\n-            } else {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n         public double getParameter(final String name)\n-            throws IllegalArgumentException {\n-            if (name.equals(CY)) {\n-                return cy;\n+            throws UnknownParameterException {\n+            if (name.equals(CX)) {\n+                return cx;\n+            } else if (name.equals(CY)) {\n+                    return cy;\n             } else if (name.equals(OMEGA)) {\n                 return omega;\n             } else {\n-                throw new IllegalArgumentException();\n+                throw new UnknownParameterException(name);\n             }\n         }\n \n         public void setParameter(final String name, final double value)\n-            throws IllegalArgumentException {\n-            if (name.equals(CY)) {\n+            throws UnknownParameterException {\n+            if (name.equals(CX)) {\n+                cx = value;\n+            } else if (name.equals(CY)) {\n                 cy = value;\n             } else if (name.equals(OMEGA)) {\n                 omega = value;\n             } else {\n-                throw new IllegalArgumentException();\n+                throw new UnknownParameterException(name);\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math3/ode/TestProblemHandler.java\n+++ b/src/test/java/org/apache/commons/math3/ode/TestProblemHandler.java\n \n package org.apache.commons.math3.ode;\n \n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n import org.apache.commons.math3.ode.sampling.StepInterpolator;\n import org.apache.commons.math3.util.FastMath;\n     expectedStepStart = Double.NaN;\n   }\n \n-  public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+  public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException {\n \n     double start = integrator.getCurrentStepStart();\n     if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {\n--- a/src/test/java/org/apache/commons/math3/ode/events/EventStateTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/events/EventStateTest.java\n \n \n import org.apache.commons.math3.analysis.solvers.BrentSolver;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\n \n     // JIRA: MATH-322\n     @Test\n-    public void closeEvents() {\n+    public void closeEvents() throws MaxCountExceededException, NoBracketingException {\n \n         final double r1  = 90.0;\n         final double r2  = 135.0;\n \n     // Jira: MATH-695\n     @Test\n-    public void testIssue695() {\n+    public void testIssue695()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n \n         FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n             \n--- a/src/test/java/org/apache/commons/math3/ode/events/OverlappingEventsTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/events/OverlappingEventsTest.java\n \n import org.apache.commons.math3.analysis.solvers.BaseSecantSolver;\n import org.apache.commons.math3.analysis.solvers.PegasusSolver;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\n      * EventHandler.g(double, double[])}.\n      */\n     @Test\n-    public void testOverlappingEvents0() {\n+    public void testOverlappingEvents0()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         test(0);\n     }\n \n      * EventHandler.g(double, double[])}.\n      */\n     @Test\n-    public void testOverlappingEvents1() {\n+    public void testOverlappingEvents1()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         test(1);\n     }\n \n      * {@link org.apache.commons.math3.ode.events.EventHandler#g(double, double[])\n      * EventHandler.g(double, double[])}.\n      */\n-    public void test(int eventType) {\n+    public void test(int eventType)\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double e = 1e-15;\n         FirstOrderIntegrator integrator = new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7);\n         BaseSecantSolver rootSolver = new PegasusSolver(e, e);\n--- a/src/test/java/org/apache/commons/math3/ode/events/ReappearingEventTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/events/ReappearingEventTest.java\n import java.util.Arrays;\n \n import org.apache.commons.math3.analysis.solvers.PegasusSolver;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.events.EventHandler;\n \n public class ReappearingEventTest {\n     @Test\n-    public void testDormandPrince() {\n+    public void testDormandPrince()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double tEnd = test(1);\n         assertEquals(10.0, tEnd, 1e-7);\n     }\n \n     @Test\n-    public void testGragg() {\n+    public void testGragg()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double tEnd = test(2);\n         assertEquals(10.0, tEnd, 1e-7);\n     }\n \n-    public double test(int integratorType) {\n+    public double test(int integratorType)\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double e = 1e-15;\n         FirstOrderIntegrator integrator;\n         integrator = (integratorType == 1)\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegratorTest.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class AdamsBashforthIntegratorTest {\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void dimensionCheck() {\n+    public void dimensionCheck() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\n         TestProblem1 pb = new TestProblem1();\n         FirstOrderIntegrator integ =\n             new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n     }\n \n     @Test(expected=NumberIsTooSmallException.class)\n-    public void testMinStep() {\n+    public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n \n           TestProblem1 pb = new TestProblem1();\n           double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n     }\n \n     @Test\n-    public void testIncreasingTolerance()\n+    public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException\n         {\n \n         int previousCalls = Integer.MAX_VALUE;\n     }\n \n     @Test(expected = MaxCountExceededException.class)\n-    public void exceedMaxEvaluations() {\n+    public void exceedMaxEvaluations() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n \n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n     }\n \n     @Test\n-    public void backward() {\n+    public void backward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n \n         TestProblem5 pb = new TestProblem5();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n     }\n \n     @Test\n-    public void polynomial() {\n+    public void polynomial() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n         TestProblem6 pb = new TestProblem6();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegratorTest.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class AdamsMoultonIntegratorTest {\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void dimensionCheck() {\n+    public void dimensionCheck()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         TestProblem1 pb = new TestProblem1();\n         FirstOrderIntegrator integ =\n             new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n     }\n \n     @Test(expected=NumberIsTooSmallException.class)\n-    public void testMinStep() {\n+    public void testMinStep()\n+            throws DimensionMismatchException, NumberIsTooSmallException,\n+            MaxCountExceededException, NoBracketingException {\n \n           TestProblem1 pb = new TestProblem1();\n           double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n \n     @Test\n     public void testIncreasingTolerance()\n-        {\n+            throws DimensionMismatchException, NumberIsTooSmallException,\n+            MaxCountExceededException, NoBracketingException {\n \n         int previousCalls = Integer.MAX_VALUE;\n         for (int i = -12; i < -2; ++i) {\n     }\n \n     @Test(expected = MaxCountExceededException.class)\n-    public void exceedMaxEvaluations() {\n+    public void exceedMaxEvaluations()\n+            throws DimensionMismatchException, NumberIsTooSmallException,\n+            MaxCountExceededException, NoBracketingException {\n \n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n     }\n \n     @Test\n-    public void backward() {\n+    public void backward()\n+            throws DimensionMismatchException, NumberIsTooSmallException,\n+            MaxCountExceededException, NoBracketingException {\n \n         TestProblem5 pb = new TestProblem5();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n     }\n \n     @Test\n-    public void polynomial() {\n+    public void polynomial()\n+            throws DimensionMismatchException, NumberIsTooSmallException,\n+            MaxCountExceededException, NoBracketingException {\n         TestProblem6 pb = new TestProblem6();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n \n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n public class ClassicalRungeKuttaIntegratorTest {\n \n   @Test\n-  public void testMissedEndEvent() {\n+  public void testMissedEndEvent()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double   t0     = 1878250320.0000029;\n       final double   tEvent = 1878250379.9999986;\n       final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n   }\n \n   @Test\n-  public void testSanityChecks() {\n+  public void testSanityChecks()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n \n   @Test\n   public void testDecreasingSteps()\n-     {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n   @Test\n   public void testSmallStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testBigStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n   @Test\n   public void testBackward()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem5 pb = new TestProblem5();\n     double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n     public void init(double t0, double[] y0, double t) {\n       maxError = 0;\n     }\n-    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+    public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException {\n \n       double[] interpolatedY = interpolator.getInterpolatedState ();\n       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n \n   @Test\n   public void testStepSize()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException  {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54IntegratorTest.java\n package org.apache.commons.math3.ode.nonstiff;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class DormandPrince54IntegratorTest {\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,\n                                                                            1.0e-10, 1.0e-10);\n   }\n \n   @Test(expected=NumberIsTooSmallException.class)\n-  public void testMinStep() {\n+  public void testMinStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem1 pb = new TestProblem1();\n       double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n \n   @Test\n   public void testSmallLastStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblemAbstract pb = new TestProblem5();\n     double minStep = 1.25;\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n \n   @Test\n   public void testIncreasingTolerance()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -2; ++i) {\n \n   @Test\n   public void testEvents()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n \n   @Test\n   public void testVariableSteps()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n       nbSteps = 0;\n       maxError = 0;\n     }\n-    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+    public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException {\n \n       ++nbSteps;\n       for (int a = 1; a < 10; ++a) {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.1);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException  {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n \n   @Test\n   public void checkClone()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem3 pb = new TestProblem3(0.9);\n       double minStep = 0;\n       double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                                       scalAbsoluteTolerance,\n                                                                       scalRelativeTolerance);\n       integ.addStepHandler(new StepHandler() {\n-          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast)\n+              throws MaxCountExceededException {\n               StepInterpolator cloned = interpolator.copy();\n               double tA = cloned.getPreviousTime();\n               double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853IntegratorTest.java\n package org.apache.commons.math3.ode.nonstiff;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n public class DormandPrince853IntegratorTest {\n \n   @Test\n-  public void testMissedEndEvent() {\n+  public void testMissedEndEvent()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double   t0     = 1878250320.0000029;\n       final double   tEvent = 1878250379.9999986;\n       final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n   }\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n                                                                              1.0e-10, 1.0e-10);\n   }\n \n   @Test(expected=NumberIsTooSmallException.class)\n-  public void testNullIntervalCheck() {\n+  public void testNullIntervalCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n                                                                              1.0e-10, 1.0e-10);\n   }\n \n   @Test(expected=NumberIsTooSmallException.class)\n-  public void testMinStep() {\n+  public void testMinStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem1 pb = new TestProblem1();\n       double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n \n   @Test\n   public void testIncreasingTolerance()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     AdaptiveStepsizeIntegrator integ =\n   }\n \n   @Test\n-  public void testTooLargeFirstStep() {\n+  public void testTooLargeFirstStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       AdaptiveStepsizeIntegrator integ =\n               new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n \n   @Test\n   public void testEvents()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n \n   @Test\n   public void testVariableSteps()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n \n   @Test\n   public void testUnstableDerivative()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n       nbSteps = 0;\n       maxError = 0;\n     }\n-    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+    public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException {\n \n       ++nbSteps;\n       for (int a = 1; a < 10; ++a) {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.1);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n \n   @Test\n   public void checklone()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                                       scalAbsoluteTolerance,\n                                                                       scalRelativeTolerance);\n     integ.addStepHandler(new StepHandler() {\n-        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+            throws MaxCountExceededException {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/EulerIntegratorTest.java\n \n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class EulerIntegratorTest {\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       new EulerIntegrator(0.01).integrate(pb,\n                                           0.0, new double[pb.getDimension()+10],\n \n   @Test\n   public void testDecreasingSteps()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n   @Test\n   public void testSmallStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testBigStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testStepSize()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new EulerIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/EulerStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.EquationsMapper;\n import org.apache.commons.math3.ode.TestProblem1;\n public class EulerStepInterpolatorTest {\n \n   @Test\n-  public void noReset() {\n+  public void noReset() throws MaxCountExceededException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n   }\n \n   @Test\n-  public void interpolationAtBounds() {\n+  public void interpolationAtBounds() throws MaxCountExceededException {\n \n     double   t0 = 0;\n     double[] y0 = {0.0, 1.0, -2.0};\n   }\n \n   @Test\n-  public void interpolationInside() {\n+  public void interpolationInside() throws MaxCountExceededException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     EulerIntegrator integ = new EulerIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/GillIntegratorTest.java\n \n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class GillIntegratorTest {\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       new GillIntegrator(0.01).integrate(pb,\n                                          0.0, new double[pb.getDimension()+10],\n \n   @Test\n   public void testDecreasingSteps()\n-     {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n   @Test\n   public void testSmallStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testBigStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n   @Test\n   public void testUnstableDerivative()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ = new GillIntegrator(0.3);\n     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n     public void init(double t0, double[] y0, double t) {\n       maxError = 0;\n     }\n-    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+    public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException {\n \n       double[] interpolatedY = interpolator.getInterpolatedState();\n       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n \n   @Test\n   public void testStepSize()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new GillIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/GillStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void testDerivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     GillIntegrator integ = new GillIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n package org.apache.commons.math3.ode.nonstiff;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n public class GraggBulirschStoerIntegratorTest {\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       AdaptiveStepsizeIntegrator integrator =\n         new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n   }\n \n   @Test(expected=NumberIsTooSmallException.class)\n-  public void testNullIntervalCheck() {\n+  public void testNullIntervalCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       GraggBulirschStoerIntegrator integrator =\n         new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n   }\n \n   @Test(expected=NumberIsTooSmallException.class)\n-  public void testMinStep() {\n+  public void testMinStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb  = new TestProblem5();\n       double minStep   = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n \n   @Test\n   public void testIncreasingTolerance()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -4; ++i) {\n \n   @Test\n   public void testIntegratorControls()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem3 pb = new TestProblem3(0.999);\n     GraggBulirschStoerIntegrator integ =\n   }\n \n   private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n       integrator.addStepHandler(handler);\n       integrator.integrate(pb,\n \n   @Test\n   public void testEvents()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb = new TestProblem3(0.9);\n     double minStep        = 0;\n \n   @Test\n   public void testVariableSteps()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb = new TestProblem3(0.9);\n     double minStep        = 0;\n   }\n \n   @Test\n-  public void testTooLargeFirstStep() {\n+  public void testTooLargeFirstStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       AdaptiveStepsizeIntegrator integ =\n               new GraggBulirschStoerIntegrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);\n   }\n \n   @Test\n-  public void testUnstableDerivative() {\n+  public void testUnstableDerivative()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n   }\n \n   @Test\n-  public void testIssue596() {\n+  public void testIssue596()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(1e-10, 100.0, 1e-7, 1e-7);\n       integ.addStepHandler(new StepHandler() {\n \n           public void init(double t0, double[] y0, double t) {\n           }\n \n-          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast)\n+              throws MaxCountExceededException {\n               double t = interpolator.getCurrentTime();\n               interpolator.setInterpolatedTime(t);\n               double[] y = interpolator.getInterpolatedState();\n       nbSteps = 0;\n       maxError = 0;\n     }\n-    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+    public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException {\n \n       ++nbSteps;\n       for (int a = 1; a < 100; ++a) {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep   = 0;\n     double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep   = 0;\n \n   @Test\n   public void checklone()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                                           scalAbsoluteTolerance,\n                                                                           scalRelativeTolerance);\n     integ.addStepHandler(new StepHandler() {\n-        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+            throws MaxCountExceededException {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/HighamHall54IntegratorTest.java\n \n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathIllegalNumberException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class HighamHall54IntegratorTest {\n \n   @Test\n-  public void testWrongDerivative() {\n+  public void testWrongDerivative()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       HighamHall54Integrator integrator =\n           new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n       FirstOrderDifferentialEquations equations =\n           new FirstOrderDifferentialEquations() {\n             public void computeDerivatives(double t, double[] y, double[] dot) {\n             if (t < -0.5) {\n-                throw new LocalException(t);\n+                throw new LocalException();\n             } else {\n                 throw new RuntimeException(\"oops\");\n            }\n   }\n \n   @Test(expected=NumberIsTooSmallException.class)\n-  public void testMinStep() {\n+  public void testMinStep()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem1 pb = new TestProblem1();\n       double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n \n   @Test\n   public void testIncreasingTolerance()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -2; ++i) {\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n \n   @Test\n   public void testEvents()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n   }\n \n   @Test(expected=LocalException.class)\n-  public void testEventsErrors() {\n+  public void testEventsErrors()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       final TestProblem1 pb = new TestProblem1();\n       double minStep = 0;\n           double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n           double offset = t - middle;\n           if (offset > 0) {\n-            throw new LocalException(t);\n+            throw new LocalException();\n           }\n           return offset;\n         }\n \n   }\n \n-  private static class LocalException extends MathIllegalNumberException {\n+  private static class LocalException extends RuntimeException {\n     private static final long serialVersionUID = 3041292643919807960L;\n-    protected LocalException(Number wrong) {\n-        super(LocalizedFormats.SIMPLE_MESSAGE, wrong);\n-    }\n-  }\n-\n-  @Test\n-  public void testEventsNoConvergence() {\n+  }\n+\n+  @Test\n+  public void testEventsNoConvergence()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem1 pb = new TestProblem1();\n     double minStep = 0;\n }\n \n   @Test\n-  public void testSanityChecks() {\n+  public void testSanityChecks()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final TestProblem3 pb  = new TestProblem3(0.9);\n       double minStep = 0;\n       double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.1);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n \n   @Test\n   public void checkClone()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                               scalAbsoluteTolerance,\n                                                               scalRelativeTolerance);\n     integ.addStepHandler(new StepHandler() {\n-        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+            throws MaxCountExceededException {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/MidpointIntegratorTest.java\n \n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class MidpointIntegratorTest {\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       new MidpointIntegrator(0.01).integrate(pb,\n                                              0.0, new double[pb.getDimension()+10],\n \n   @Test\n   public void testDecreasingSteps()\n-     {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n   @Test\n   public void testSmallStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testBigStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testStepSize()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new MidpointIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/MidpointStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem1;\n import org.apache.commons.math3.ode.TestProblem3;\n \n   @Test\n   public void testDerivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     MidpointIntegrator integ = new MidpointIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesIntegratorTest.java\n \n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem1;\n public class ThreeEighthesIntegratorTest {\n \n   @Test(expected=DimensionMismatchException.class)\n-  public void testDimensionCheck() {\n+  public void testDimensionCheck()\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       TestProblem1 pb = new TestProblem1();\n       new ThreeEighthesIntegrator(0.01).integrate(pb,\n                                                   0.0, new double[pb.getDimension()+10],\n \n   @Test\n   public void testDecreasingSteps()\n-     {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n  @Test\n  public void testSmallStep()\n-    {\n+     throws DimensionMismatchException, NumberIsTooSmallException,\n+            MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testBigStep()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n   @Test\n   public void testBackward()\n-      {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n   @Test\n   public void testKepler()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n       maxError = 0;\n     }\n \n-    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+    public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws MaxCountExceededException {\n \n       double[] interpolatedY = interpolator.getInterpolatedState();\n       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n \n   @Test\n   public void testStepSize()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           DimensionMismatchException, NumberIsTooSmallException,\n+           MaxCountExceededException, NoBracketingException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n--- a/src/test/java/org/apache/commons/math3/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/sampling/DummyStepInterpolatorTest.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n \n-import org.apache.commons.math3.exception.MathIllegalStateException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n public class DummyStepInterpolatorTest {\n \n   @Test\n-  public void testNoReset() {\n+  public void testNoReset() throws MaxCountExceededException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);\n   }\n \n   @Test\n-  public void testFixedState() {\n+  public void testFixedState() throws MaxCountExceededException {\n \n     double[]   y    =   { 1.0, 3.0, -4.0 };\n     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);\n \n   @Test\n   public void testSerialization()\n-  throws IOException, ClassNotFoundException {\n+  throws IOException, ClassNotFoundException, MaxCountExceededException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);\n     try {\n         oos.writeObject(interpolator);\n         Assert.fail(\"an exception should have been thrown\");\n-    } catch (MathIllegalStateException mise) {\n+    } catch (LocalException le) {\n         // expected behavior\n-        Assert.assertEquals(0, mise.getMessage().length());\n     }\n   }\n \n       }\n       @Override\n       protected void doFinalize() {\n-          throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"\");\n+          throw new LocalException();\n       }\n   }\n+\n+  private static class LocalException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+  }\n+\n }\n--- a/src/test/java/org/apache/commons/math3/ode/sampling/NordsieckStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/sampling/NordsieckStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.ContinuousOutputModel;\n import org.apache.commons.math3.ode.TestProblem1;\n import org.apache.commons.math3.ode.TestProblem3;\n public class NordsieckStepInterpolatorTest {\n \n     @Test\n-    public void derivativesConsistency() {\n+    public void derivativesConsistency()\n+        throws NumberIsTooSmallException, DimensionMismatchException,\n+               MaxCountExceededException, NoBracketingException {\n         TestProblem3 pb = new TestProblem3();\n         AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);\n         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 5e-9);\n \n     @Test\n     public void serialization()\n-    throws IOException, ClassNotFoundException {\n+    throws IOException, ClassNotFoundException,\n+           NumberIsTooSmallException, DimensionMismatchException,\n+           MaxCountExceededException, NoBracketingException {\n \n         TestProblem1 pb = new TestProblem1();\n         AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);\n--- a/src/test/java/org/apache/commons/math3/ode/sampling/StepInterpolatorTestUtils.java\n+++ b/src/test/java/org/apache/commons/math3/ode/sampling/StepInterpolatorTestUtils.java\n package org.apache.commons.math3.ode.sampling;\n \n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblemAbstract;\n import org.apache.commons.math3.util.FastMath;\n \n     public static void checkDerivativesConsistency(final FirstOrderIntegrator integrator,\n                                                    final TestProblemAbstract problem,\n-                                                   final double threshold) {\n+                                                   final double threshold)\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         integrator.addStepHandler(new StepHandler() {\n \n-            public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+            public void handleStep(StepInterpolator interpolator, boolean isLast)\n+                throws MaxCountExceededException {\n \n                 final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());\n                 final double t = interpolator.getCurrentTime() - 300 * h;\n--- a/src/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerOutputTestBase.java\n+++ b/src/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerOutputTestBase.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.nonstiff.GraggBulirschStoerIntegrator;\n     }\n \n     @Test\n-    public void testIncNeither() {\n+    public void testIncNeither()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpInc(), getO()[0][0], getO()[0][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.NEITHER, exp, false);\n     }\n \n     @Test\n-    public void testIncNeitherRev() {\n+    public void testIncNeitherRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpIncRev(), getO()[1][0], getO()[1][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.NEITHER, exp, true);\n     }\n \n     @Test\n-    public void testIncFirst() {\n+    public void testIncFirst()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpInc(), getO()[2][0], getO()[2][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST, exp, false);\n     }\n \n     @Test\n-    public void testIncFirstRev() {\n+    public void testIncFirstRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpIncRev(), getO()[3][0], getO()[3][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST, exp, true);\n     }\n \n     @Test\n-    public void testIncLast() {\n+    public void testIncLast()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpInc(), getO()[4][0], getO()[4][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.LAST, exp, false);\n     }\n \n     @Test\n-    public void testIncLastRev() {\n+    public void testIncLastRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpIncRev(), getO()[5][0], getO()[5][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.LAST, exp, true);\n     }\n \n     @Test\n-    public void testIncBoth() {\n+    public void testIncBoth()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpInc(), getO()[6][0], getO()[6][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.BOTH, exp, false);\n     }\n \n     @Test\n-    public void testIncBothRev() {\n+    public void testIncBothRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpIncRev(), getO()[7][0], getO()[7][1]);\n         doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.BOTH, exp, true);\n     }\n \n     @Test\n-    public void testMulNeither() {\n+    public void testMulNeither()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMul(), getO()[8][0], getO()[8][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.NEITHER, exp, false);\n     }\n \n     @Test\n-    public void testMulNeitherRev() {\n+    public void testMulNeitherRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMulRev(), getO()[9][0], getO()[9][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.NEITHER, exp, true);\n     }\n \n     @Test\n-    public void testMulFirst() {\n+    public void testMulFirst()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMul(), getO()[10][0], getO()[10][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.FIRST, exp, false);\n     }\n \n     @Test\n-    public void testMulFirstRev() {\n+    public void testMulFirstRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMulRev(), getO()[11][0], getO()[11][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.FIRST, exp, true);\n     }\n \n     @Test\n-    public void testMulLast() {\n+    public void testMulLast()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMul(), getO()[12][0], getO()[12][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.LAST, exp, false);\n     }\n \n     @Test\n-    public void testMulLastRev() {\n+    public void testMulLastRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMulRev(), getO()[13][0], getO()[13][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.LAST, exp, true);\n     }\n \n     @Test\n-    public void testMulBoth() {\n+    public void testMulBoth()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMul(), getO()[14][0], getO()[14][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.BOTH, exp, false);\n     }\n \n     @Test\n-    public void testMulBothRev() {\n+    public void testMulBothRev()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         double[] exp = getArray(getExpMulRev(), getO()[15][0], getO()[15][1]);\n         doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.BOTH, exp, true);\n     }\n      * @param bounds the step normalizer bounds setting to use\n      * @param expected the expected output (normalized time points)\n      * @param reverse whether to reverse the integration direction\n+     * @throws NoBracketingException \n+     * @throws MaxCountExceededException \n+     * @throws NumberIsTooSmallException \n+     * @throws DimensionMismatchException \n      */\n     private void doTest(StepNormalizerMode mode, StepNormalizerBounds bounds,\n-                        double[] expected, boolean reverse) {\n+                        double[] expected, boolean reverse)\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n         // Forward test.\n         FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(\n                                                         1e-8, 1.0, 1e-5, 1e-5);\n--- a/src/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/sampling/StepNormalizerTest.java\n \n package org.apache.commons.math3.ode.sampling;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.ode.FirstOrderIntegrator;\n import org.apache.commons.math3.ode.TestProblem3;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince54Integrator;\n \n   @Test\n   public void testBoundaries()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     double range = pb.getFinalTime() - pb.getInitialTime();\n     setLastSeen(false);\n     integ.addStepHandler(new StepNormalizer(range / 10.0,\n \n   @Test\n   public void testBeforeEnd()\n-    {\n+      throws DimensionMismatchException, NumberIsTooSmallException,\n+             MaxCountExceededException, NoBracketingException {\n     final double range = pb.getFinalTime() - pb.getInitialTime();\n     setLastSeen(false);\n     integ.addStepHandler(new StepNormalizer(range / 10.5,", "timestamp": 1346595660, "metainfo": ""}