{"sha": "49931ff7f2d112e3b48a9d72315dd695fbc00e7a", "log": "Check all FastMath methods against StrictMath results  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/FastMathStrictComparisonTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test to compare FastMath results against StrictMath results for boundary values.\n+ */\n+@RunWith(Parameterized.class)\n+public class FastMathStrictComparisonTest {\n+\n+    // Values which often need special handling\n+    private static final Double[] DOUBLE_SPECIAL_VALUES = {\n+        -0.0, +0.0,                                         // 1,2\n+        Double.NaN,                                         // 3\n+        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5\n+        -Double.MAX_VALUE, Double.MAX_VALUE,                // 6,7\n+        // decreasing order of absolute value to help catch first failure\n+        -MathUtils.EPSILON, MathUtils.EPSILON,              // 8,9\n+        -MathUtils.SAFE_MIN, MathUtils.SAFE_MIN,            // 10,11\n+        -Double.MIN_VALUE, Double.MIN_VALUE,                // 12,13\n+    };\n+\n+    private static final Float [] FLOAT_SPECIAL_VALUES = {\n+        -0.0f, +0.0f,                                       // 1,2\n+        Float.NaN,                                          // 3\n+        Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,   // 4,5\n+        Float.MIN_VALUE, Float.MAX_VALUE,                   // 6,7\n+        -Float.MIN_VALUE, -Float.MAX_VALUE,                 // 8,9\n+    };\n+    \n+    private static final Object [] LONG_SPECIAL_VALUES = {\n+        -1,0,1,\n+        Long.MIN_VALUE, Long.MAX_VALUE,\n+    };\n+    \n+    private static final Object[] INT_SPECIAL_VALUES = {\n+        -1,0,1,\n+        Integer.MIN_VALUE, Integer.MAX_VALUE,\n+    };\n+    \n+    private final Method mathMethod;\n+    private final Method fastMethod;\n+    private final Type[] types;\n+    private final Object[][] valueArrays;\n+    \n+    public FastMathStrictComparisonTest(Method m, Method f, Type[] types, Object[][] data) throws Exception{\n+        this.mathMethod=m;\n+        this.fastMethod=f;\n+        this.types=types;\n+        this.valueArrays=data;\n+    }\n+    \n+    @Test\n+    public void test1() throws Exception{\n+        setupMethodCall(mathMethod, fastMethod, types, valueArrays);\n+    }\n+    private static boolean isNumber(Double d) {\n+        return !(d.isInfinite() || d.isNaN());\n+    }\n+\n+    private static boolean isNumber(Float f) {\n+        return !(f.isInfinite() || f.isNaN());\n+    }\n+\n+    private static void reportFailedResults(Method mathMethod, Object[] params, Object expected, Object actual, int[] entries){\n+        String format = null;\n+        long actL=0;\n+        long expL=0;\n+        if (expected instanceof Double) {\n+            Double exp = (Double) expected;\n+            Double act = (Double) actual;\n+            if (isNumber(exp) && isNumber(act)) { // show difference as hex\n+                actL = Double.doubleToLongBits(act);\n+                expL = Double.doubleToLongBits(exp);\n+                format = \"%016x\";\n+            }\n+        } else if (expected instanceof Float ){\n+            Float exp = (Float) expected;\n+            Float act = (Float) actual;\n+            if (isNumber(exp) && isNumber(act)) { // show difference as hex\n+                actL = Float.floatToIntBits(act);\n+                expL = Float.floatToIntBits(exp);\n+                format = \"%08x\";\n+            }\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(mathMethod.getReturnType().getSimpleName());\n+        sb.append(\" \");\n+        sb.append(mathMethod.getName());\n+        sb.append(\"(\");\n+        String sep = \"\";\n+        for(Object o : params){\n+            sb.append(sep);\n+            sb.append(o);\n+            sep=\", \";\n+        }\n+        sb.append(\") expected \");\n+        if (format != null){\n+            sb.append(String.format(format, expL));                \n+        } else {\n+            sb.append(expected);\n+        }\n+        sb.append(\" actual \");\n+        if (format != null){\n+            sb.append(String.format(format, actL));                \n+        } else {\n+            sb.append(actual);\n+        }\n+        sb.append(\" entries \");\n+        sb.append(Arrays.toString(entries));\n+        String message = sb.toString();\n+        final boolean fatal = false;\n+        if (fatal) {\n+            Assert.fail(message);\n+        } else {\n+            System.out.println(message);\n+        }\n+    }            \n+\n+    private static void callMethods(Method mathMethod, Method fastMethod,\n+            Object[] params, int[] entries) throws IllegalAccessException,\n+            InvocationTargetException {\n+        try {\n+            Object expected = mathMethod.invoke(mathMethod, params);\n+            Object actual = fastMethod.invoke(mathMethod, params);\n+            if (!expected.equals(actual)) {\n+                reportFailedResults(mathMethod, params, expected, actual, entries);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            Assert.fail(mathMethod+\" \"+e);\n+        }\n+    }\n+    \n+    private static void setupMethodCall(Method mathMethod, Method fastMethod, \n+            Type[] types, Object[][] valueArrays) throws Exception {\n+        Object[] params = new Object[types.length];\n+        int entry1 = 0;\n+        int[] entries = new int[types.length];\n+        for(Object d : valueArrays[0]) {\n+            entry1++;\n+            params[0] = d;\n+            entries[0] = entry1;\n+            if (params.length > 1){\n+                int entry2 = 0;\n+                for(Object d1 : valueArrays[1]) {\n+                    entry2++;\n+                    params[1] = d1;                    \n+                    entries[1] = entry2;\n+                    callMethods(mathMethod, fastMethod, params, entries);                    \n+                }\n+            } else {\n+                callMethods(mathMethod, fastMethod, params, entries);\n+            }\n+        }\n+    }\n+\n+    @Parameters\n+    public static List<Object[]> data() throws Exception {\n+        List<Object[]> list = new ArrayList<Object[]>();\n+        for(Method mathMethod : StrictMath.class.getDeclaredMethods()) {\n+            method:\n+            if (Modifier.isPublic(mathMethod.getModifiers())){// Only test public methods\n+                Type []types = mathMethod.getGenericParameterTypes();\n+                if (types.length >=1) { // Only check methods with at least one parameter\n+                    try {\n+                        // Get the corresponding FastMath method\n+                        Method fastMethod = FastMath.class.getDeclaredMethod(mathMethod.getName(), (Class[]) types);\n+                        if (Modifier.isPublic(fastMethod.getModifiers())) { // It must be public too\n+                            Object [][] values = new Object[types.length][];\n+                            int index = 0;\n+                            for(Type t : types) {\n+                                if (t.equals(double.class)){\n+                                    values[index]=DOUBLE_SPECIAL_VALUES;\n+                                } else if (t.equals(float.class)) {\n+                                    values[index]=FLOAT_SPECIAL_VALUES;\n+                                } else if (t.equals(long.class)) {\n+                                    values[index]=LONG_SPECIAL_VALUES;\n+                                } else if (t.equals(int.class)) {\n+                                    values[index]=INT_SPECIAL_VALUES;\n+                                } else {\n+                                    System.out.println(\"Cannot handle class \"+t+\" for \"+mathMethod);\n+                                    break method;\n+                                }\n+                                index++;\n+                            }\n+//                            System.out.println(fastMethod);\n+                            /*\n+                             * The current implementation runs each method as a separate test.\n+                             * Could be amended to run each value as a separate test\n+                             */\n+                            list.add(new Object[]{mathMethod, fastMethod, types, values});\n+//                            setupMethodCall(mathMethod, fastMethod, params, data);\n+                        } else {\n+                            System.out.println(\"Cannot find public FastMath method corresponding to: \"+mathMethod);                            \n+                        }\n+                    } catch (NoSuchMethodException e) {\n+                        System.out.println(\"Cannot find FastMath method corresponding to: \"+mathMethod);\n+                    }\n+                }\n+            }\n+        }\n+        return list;\n+    }\n+\n+}", "timestamp": 1295890413, "metainfo": ""}