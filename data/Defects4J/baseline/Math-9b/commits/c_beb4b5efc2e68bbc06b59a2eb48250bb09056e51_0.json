{"sha": "beb4b5efc2e68bbc06b59a2eb48250bb09056e51", "log": "MATH-707 Changed \"...UnivariateRealFunction\" to \"...UnivariateFunction\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Extension of {@link UnivariateFunction} representing a differentiable univariate real function.\n+ *\n+ * @version $Id$\n+ */\n+public interface DifferentiableUnivariateFunction\n+    extends UnivariateFunction {\n+\n+    /**\n+     * Returns the derivative of the function\n+     *\n+     * @return  the derivative function\n+     */\n+    UnivariateFunction derivative();\n+\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n      * @param f List of functions.\n      * @return the composite function.\n      */\n-    public static UnivariateRealFunction compose(final UnivariateRealFunction ... f) {\n-        return new UnivariateRealFunction() {\n+    public static UnivariateFunction compose(final UnivariateFunction ... f) {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 double r = x;\n      * @param f List of functions.\n      * @return the composite function.\n      */\n-    public static DifferentiableUnivariateRealFunction compose(final DifferentiableUnivariateRealFunction ... f) {\n-        return new DifferentiableUnivariateRealFunction() {\n+    public static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction ... f) {\n+        return new DifferentiableUnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 double r = x;\n             }\n \n             /** {@inheritDoc} */\n-            public UnivariateRealFunction derivative() {\n-                return new UnivariateRealFunction() {\n+            public UnivariateFunction derivative() {\n+                return new UnivariateFunction() {\n                     /** {@inheritDoc} */\n                     public double value(double x) {\n                         double p = 1;\n      * @param f List of functions.\n      * @return a function that computes the sum of the functions.\n      */\n-    public static UnivariateRealFunction add(final UnivariateRealFunction ... f) {\n-        return new UnivariateRealFunction() {\n+    public static UnivariateFunction add(final UnivariateFunction ... f) {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 double r = f[0].value(x);\n      * @param f List of functions.\n      * @return a function that computes the sum of the functions.\n      */\n-    public static DifferentiableUnivariateRealFunction add(final DifferentiableUnivariateRealFunction ... f) {\n-        return new DifferentiableUnivariateRealFunction() {\n+    public static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction ... f) {\n+        return new DifferentiableUnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 double r = f[0].value(x);\n             }\n \n             /** {@inheritDoc} */\n-            public UnivariateRealFunction derivative() {\n-                return new UnivariateRealFunction() {\n+            public UnivariateFunction derivative() {\n+                return new UnivariateFunction() {\n                     /** {@inheritDoc} */\n                     public double value(double x) {\n                         double r = f[0].derivative().value(x);\n      * @param f List of functions.\n      * @return a function that computes the product of the functions.\n      */\n-    public static UnivariateRealFunction multiply(final UnivariateRealFunction ... f) {\n-        return new UnivariateRealFunction() {\n+    public static UnivariateFunction multiply(final UnivariateFunction ... f) {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 double r = f[0].value(x);\n      * @param f List of functions.\n      * @return a function that computes the product of the functions.\n      */\n-    public static DifferentiableUnivariateRealFunction multiply(final DifferentiableUnivariateRealFunction ... f) {\n-        return new DifferentiableUnivariateRealFunction() {\n+    public static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction ... f) {\n+        return new DifferentiableUnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 double r = f[0].value(x);\n             }\n \n             /** {@inheritDoc} */\n-            public UnivariateRealFunction derivative() {\n-                return new UnivariateRealFunction() {\n+            public UnivariateFunction derivative() {\n+                return new UnivariateFunction() {\n                     /** {@inheritDoc} */\n                     public double value(double x) {\n                         double sum = 0;\n      * @param g Function.\n      * @return the composite function.\n      */\n-    public static UnivariateRealFunction combine(final BivariateRealFunction combiner,\n-                                                 final UnivariateRealFunction f,\n-                                                 final UnivariateRealFunction g) {\n-        return new UnivariateRealFunction() {\n+    public static UnivariateFunction combine(final BivariateRealFunction combiner,\n+                                                 final UnivariateFunction f,\n+                                                 final UnivariateFunction g) {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return combiner.value(f.value(x), g.value(x));\n      * @return a collector function.\n      */\n     public static MultivariateRealFunction collector(final BivariateRealFunction combiner,\n-                                                     final UnivariateRealFunction f,\n+                                                     final UnivariateFunction f,\n                                                      final double initialValue) {\n         return new MultivariateRealFunction() {\n             /** {@inheritDoc} */\n      * @param fixed Value to which the first argument of {@code f} is set.\n      * @return the unary function h(x) = f(fixed, x)\n      */\n-    public static UnivariateRealFunction fix1stArgument(final BivariateRealFunction f,\n+    public static UnivariateFunction fix1stArgument(final BivariateRealFunction f,\n                                                         final double fixed) {\n-        return new UnivariateRealFunction() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return f.value(fixed, x);\n      * @param fixed Value to which the second argument of {@code f} is set.\n      * @return the unary function h(x) = f(x, fixed)\n      */\n-    public static UnivariateRealFunction fix2ndArgument(final BivariateRealFunction f,\n+    public static UnivariateFunction fix2ndArgument(final BivariateRealFunction f,\n                                                         final double fixed) {\n-        return new UnivariateRealFunction() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return f.value(x, fixed);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/ParametricUnivariateFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * An interface representing a real function that depends on one independent\n+ * variable plus some extra parameters.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface ParametricUnivariateFunction {\n+    /**\n+     * Compute the value of the function.\n+     *\n+     * @param x Point for which the function value should be computed.\n+     * @param parameters Function parameters.\n+     * @return the value.\n+     */\n+    double value(double x, double ... parameters);\n+\n+    /**\n+     * Compute the gradient of the function with respect to its parameters.\n+     *\n+     * @param x Point for which the function value should be computed.\n+     * @param parameters Function parameters.\n+     * @return the value.\n+     */\n+    double[] gradient(double x, double ... parameters);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * An interface representing a univariate real function.\n+ * <br/>\n+ * When a <em>user-defined</em> function encounters an error during\n+ * evaluation, the {@link #value(double) value} method should throw a\n+ * <em>user-defined</em> unchecked exception.\n+ * <br/>\n+ * The following code excerpt shows the recommended way to do that using\n+ * a root solver as an example, but the same construct is applicable to\n+ * ODE integrators or optimizers.\n+ *\n+ * <pre>\n+ * private static class LocalException extends RuntimeException {\n+ *     // The x value that caused the problem.\n+ *     private final double x;\n+ *\n+ *     public LocalException(double x) {\n+ *         this.x = x;\n+ *     }\n+ *\n+ *     public double getX() {\n+ *         return x;\n+ *     }\n+ * }\n+ *\n+ * private static class MyFunction implements UnivariateFunction {\n+ *     public double value(double x) {\n+ *         double y = hugeFormula(x);\n+ *         if (somethingBadHappens) {\n+ *           throw new LocalException(x);\n+ *         }\n+ *         return y;\n+ *     }\n+ * }\n+ *\n+ * public void compute() {\n+ *     try {\n+ *         solver.solve(maxEval, new MyFunction(a, b, c), min, max);\n+ *     } catch (LocalException le) {\n+ *         // Retrieve the x value.\n+ *     }\n+ * }\n+ * </pre>\n+ *\n+ * As shown, the exception is local to the user's code and it is guaranteed\n+ * that Apache Commons Math will not catch it.\n+ *\n+ * @version $Id$\n+ */\n+public interface UnivariateFunction {\n+    /**\n+     * Compute the value of the function.\n+     *\n+     * @param x Point at which the function value should be computed.\n+     * @return the value of the function.\n+     * @throws IllegalArgumentException when the activated method itself can\n+     * ascertain that a precondition, specified in the API expressed at the\n+     * level of the activated method, has been violated.\n+     * When Commons Math throws an {@code IllegalArgumentException}, it is\n+     * usually the consequence of checking the actual parameters passed to\n+     * the method.\n+     */\n+    double value(double x);\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/function/Abs.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Abs.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Abs implements UnivariateRealFunction {\n+public class Abs implements UnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.abs(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Acos.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Acos.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Acos implements DifferentiableUnivariateRealFunction {\n+public class Acos implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.acos(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return -1 / FastMath.sqrt(1 - x * x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Acosh.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Acosh.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Acosh implements DifferentiableUnivariateRealFunction {\n+public class Acosh implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.acosh(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / FastMath.sqrt(x * x - 1);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Asin.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Asin.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Asin implements DifferentiableUnivariateRealFunction {\n+public class Asin implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.asin(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / FastMath.sqrt(1 - x * x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Asinh.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Asinh.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Asinh implements DifferentiableUnivariateRealFunction {\n+public class Asinh implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.asinh(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / FastMath.sqrt(1 + x * x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Atan.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Atan.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Atan implements DifferentiableUnivariateRealFunction {\n+public class Atan implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.atan(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / (1 + x * x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Atanh.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Atanh.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Atanh implements DifferentiableUnivariateRealFunction {\n+public class Atanh implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.atanh(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / (1 - x * x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Cbrt.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Cbrt.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Cbrt implements DifferentiableUnivariateRealFunction {\n+public class Cbrt implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.cbrt(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / (3 * FastMath.cbrt(x * x));\n--- a/src/main/java/org/apache/commons/math/analysis/function/Ceil.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Ceil.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Ceil implements UnivariateRealFunction {\n+public class Ceil implements UnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.ceil(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Constant.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Constant.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n \n /**\n  * Constant function.\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Constant implements DifferentiableUnivariateRealFunction {\n+public class Constant implements DifferentiableUnivariateFunction {\n     /** Constant. */\n     private final double c;\n \n     }\n \n     /** {@inheritDoc} */\n-    public DifferentiableUnivariateRealFunction derivative() {\n+    public DifferentiableUnivariateFunction derivative() {\n         return new Constant(0);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/function/Cos.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Cos.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Cos implements DifferentiableUnivariateRealFunction {\n+public class Cos implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.cos(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return -FastMath.sin(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Cosh.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Cosh.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Cosh implements DifferentiableUnivariateRealFunction {\n+public class Cosh implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.cosh(x);\n     }\n \n     /** {@inheritDoc} */\n-    public DifferentiableUnivariateRealFunction derivative() {\n+    public DifferentiableUnivariateFunction derivative() {\n         return new Sinh();\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/function/Exp.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Exp.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Exp implements DifferentiableUnivariateRealFunction {\n+public class Exp implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.exp(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return FastMath.exp(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Expm1.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Expm1.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Expm1 implements DifferentiableUnivariateRealFunction {\n+public class Expm1 implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.expm1(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return FastMath.exp(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Floor.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Floor.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Floor implements UnivariateRealFunction {\n+public class Floor implements UnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.floor(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Gaussian.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Gaussian.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Gaussian implements DifferentiableUnivariateRealFunction {\n+public class Gaussian implements DifferentiableUnivariateFunction {\n     /** Mean. */\n     private final double mean;\n     /** Inverse of twice the square of the standard deviation. */\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 final double diff = x - mean;\n      *  <li>Standard deviation</li>\n      * </ul>\n      */\n-    public static class Parametric implements ParametricUnivariateRealFunction {\n+    public static class Parametric implements ParametricUnivariateFunction {\n         /**\n          * Computes the value of the Gaussian at {@code x}.\n          *\n--- a/src/main/java/org/apache/commons/math/analysis/function/HarmonicOscillator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/HarmonicOscillator.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class HarmonicOscillator implements DifferentiableUnivariateRealFunction {\n+public class HarmonicOscillator implements DifferentiableUnivariateFunction {\n     /** Amplitude. */\n     private final double amplitude;\n     /** Angular frequency. */\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return -amplitude * omega * FastMath.sin(omega * x + phase);\n      *  <li>Phase</li>\n      * </ul>\n      */\n-    public static class Parametric implements ParametricUnivariateRealFunction {\n+    public static class Parametric implements ParametricUnivariateFunction {\n         /**\n          * Computes the value of the harmonic oscillator at {@code x}.\n          *\n--- a/src/main/java/org/apache/commons/math/analysis/function/Identity.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Identity.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n \n /**\n  * Identity function.\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Identity implements DifferentiableUnivariateRealFunction {\n+public class Identity implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return x;\n     }\n \n     /** {@inheritDoc} */\n-    public DifferentiableUnivariateRealFunction derivative() {\n+    public DifferentiableUnivariateFunction derivative() {\n         return new Constant(1);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/function/Inverse.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Inverse.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n \n /**\n  * Inverse function.\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Inverse implements DifferentiableUnivariateRealFunction {\n+public class Inverse implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return 1 / x;\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return -1 / (x * x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Log.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Log.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Log implements DifferentiableUnivariateRealFunction {\n+public class Log implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.log(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / x;\n--- a/src/main/java/org/apache/commons/math/analysis/function/Log10.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Log10.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Log10 implements DifferentiableUnivariateRealFunction {\n+public class Log10 implements DifferentiableUnivariateFunction {\n     /** ln(10) = {@value}.*/\n     private static final double LN_10 = FastMath.log(10);\n \n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / (x * LN_10);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Log1p.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Log1p.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Log1p implements DifferentiableUnivariateRealFunction {\n+public class Log1p implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.log1p(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / (1 + x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Logistic.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Logistic.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Logistic implements DifferentiableUnivariateRealFunction {\n+public class Logistic implements DifferentiableUnivariateFunction {\n     /** Lower asymptote. */\n     private final double a;\n     /** Upper asymptote. */\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 final double exp = q * FastMath.exp(b * (m - x));\n      *  <li>Higher asymptote</li>\n      * </ul>\n      */\n-    public static class Parametric implements ParametricUnivariateRealFunction {\n+    public static class Parametric implements ParametricUnivariateFunction {\n         /**\n          * Computes the value of the sigmoid at {@code x}.\n          *\n--- a/src/main/java/org/apache/commons/math/analysis/function/Logit.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Logit.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Logit implements DifferentiableUnivariateRealFunction {\n+public class Logit implements DifferentiableUnivariateFunction {\n     /** Lower bound. */\n     private final double lo;\n     /** Higher bound. */\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return (hi - lo) / ((x - lo) * (hi - x));\n      *  <li>Higher bound</li>\n      * </ul>\n      */\n-    public static class Parametric implements ParametricUnivariateRealFunction {\n+    public static class Parametric implements ParametricUnivariateFunction {\n         /**\n          * Computes the value of the logit at {@code x}.\n          *\n--- a/src/main/java/org/apache/commons/math/analysis/function/Minus.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Minus.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n \n /**\n  * Minus function.\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Minus implements DifferentiableUnivariateRealFunction {\n+public class Minus implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return -x;\n     }\n \n     /** {@inheritDoc} */\n-    public DifferentiableUnivariateRealFunction derivative() {\n+    public DifferentiableUnivariateFunction derivative() {\n         return new Constant(-1);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/function/Power.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Power.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Power implements DifferentiableUnivariateRealFunction {\n+public class Power implements DifferentiableUnivariateFunction {\n     /** Power. */\n     private final double p;\n \n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return p * FastMath.pow(x, p - 1);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Rint.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Rint.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Rint implements UnivariateRealFunction {\n+public class Rint implements UnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.rint(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Sigmoid.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Sigmoid.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Sigmoid implements DifferentiableUnivariateRealFunction {\n+public class Sigmoid implements DifferentiableUnivariateFunction {\n     /** Lower asymptote. */\n     private final double lo;\n     /** Higher asymptote. */\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 final double exp = FastMath.exp(-x);\n      *  <li>Higher asymptote</li>\n      * </ul>\n      */\n-    public static class Parametric implements ParametricUnivariateRealFunction {\n+    public static class Parametric implements ParametricUnivariateFunction {\n         /**\n          * Computes the value of the sigmoid at {@code x}.\n          *\n--- a/src/main/java/org/apache/commons/math/analysis/function/Signum.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Signum.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Signum implements UnivariateRealFunction {\n+public class Signum implements UnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.signum(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Sin.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Sin.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Sin implements DifferentiableUnivariateRealFunction {\n+public class Sin implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.sin(x);\n     }\n \n     /** {@inheritDoc} */\n-    public DifferentiableUnivariateRealFunction derivative() {\n+    public DifferentiableUnivariateFunction derivative() {\n         return new Cos();\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/function/Sinc.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Sinc.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Sinc implements DifferentiableUnivariateRealFunction {\n+public class Sinc implements DifferentiableUnivariateFunction {\n     /**\n      * Value below which the result of the computation will not change\n      * anymore due to the finite precision of the \"double\" representation\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n+    public UnivariateFunction derivative() {\n         if (normalized) {\n-            return new UnivariateRealFunction() {\n+            return new UnivariateFunction() {\n                 /** {@inheritDoc} */\n                 public double value(double x) {\n                     final double piTimesX = Math.PI * x;\n                 }\n             };\n         } else {\n-            return new UnivariateRealFunction() {\n+            return new UnivariateFunction() {\n                 /** {@inheritDoc} */\n                 public double value(double x) {\n                     return sincDerivative(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Sinh.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Sinh.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Sinh implements DifferentiableUnivariateRealFunction {\n+public class Sinh implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.sinh(x);\n     }\n \n     /** {@inheritDoc} */\n-    public DifferentiableUnivariateRealFunction derivative() {\n+    public DifferentiableUnivariateFunction derivative() {\n         return new Cosh();\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/function/Sqrt.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Sqrt.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Sqrt implements DifferentiableUnivariateRealFunction {\n+public class Sqrt implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.sqrt(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 return 1 / (2 * FastMath.sqrt(x));\n--- a/src/main/java/org/apache/commons/math/analysis/function/StepFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/StepFunction.java\n package org.apache.commons.math.analysis.function;\n \n import java.util.Arrays;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NoDataException;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class StepFunction implements UnivariateRealFunction {\n+public class StepFunction implements UnivariateFunction {\n     /** Abscissae. */\n     private final double[] abscissa;\n     /** Ordinates. */\n--- a/src/main/java/org/apache/commons/math/analysis/function/Tan.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Tan.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Tan implements DifferentiableUnivariateRealFunction {\n+public class Tan implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.tan(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 final double tanX = FastMath.tan(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Tanh.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Tanh.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Tanh implements DifferentiableUnivariateRealFunction {\n+public class Tanh implements DifferentiableUnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.tanh(x);\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 final double tanhX = FastMath.tanh(x);\n--- a/src/main/java/org/apache/commons/math/analysis/function/Ulp.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Ulp.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Id$\n  * @since 3.0\n  */\n-public class Ulp implements UnivariateRealFunction {\n+public class Ulp implements UnivariateFunction {\n     /** {@inheritDoc} */\n     public double value(double x) {\n         return FastMath.ulp(x);\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.NullArgumentException;\n      * satisfy the requirements specified by the integrator\n      * @throws NullArgumentException if {@code f} is {@code null}.\n      */\n-    double integrate(int maxEval, UnivariateRealFunction f, double min,\n+    double integrate(int maxEval, UnivariateFunction f, double min,\n                      double max)\n         throws TooManyEvaluationsException, MaxCountExceededException,\n                MathIllegalArgumentException, NullArgumentException;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n     protected Incrementor evaluations;\n \n     /** Function to integrate. */\n-    protected UnivariateRealFunction function;\n+    protected UnivariateFunction function;\n \n     /** Lower bound for the interval. */\n     protected double min;\n      * @throws MathIllegalArgumentException if {@code min >= max}.\n      */\n     protected void setup(final int maxEval,\n-                         final UnivariateRealFunction f,\n+                         final UnivariateFunction f,\n                          final double lower, final double upper)\n         throws NullArgumentException, MathIllegalArgumentException {\n \n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final int maxEval, final UnivariateRealFunction f,\n+    public double integrate(final int maxEval, final UnivariateFunction f,\n                             final double lower, final double upper)\n         throws TooManyEvaluationsException, MaxCountExceededException,\n                MathIllegalArgumentException, NullArgumentException {\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n         // Partial derivatives with respect to x at the grid knots\n         final double[][] dFdX = new double[xLen][yLen];\n         for (int j = 0; j < yLen; j++) {\n-            final UnivariateRealFunction f = ySplineX[j].derivative();\n+            final UnivariateFunction f = ySplineX[j].derivative();\n             for (int i = 0; i < xLen; i++) {\n                 dFdX[i][j] = f.value(xval[i]);\n             }\n         // Partial derivatives with respect to y at the grid knots\n         final double[][] dFdY = new double[xLen][yLen];\n         for (int i = 0; i < xLen; i++) {\n-            final UnivariateRealFunction f = xSplineY[i].derivative();\n+            final UnivariateFunction f = xSplineY[i].derivative();\n             for (int j = 0; j < yLen; j++) {\n                 dFdY[i][j] = f.value(yval[j]);\n             }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /**\n  * Interface representing a univariate real interpolating function.\n      * if the arguments violate assumptions made by the interpolation\n      * algorithm.\n      */\n-    UnivariateRealFunction interpolate(double xval[], double yval[]);\n+    UnivariateFunction interpolate(double xval[], double yval[]);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n      * @throws NumberIsTooSmallException if the number of extension points\n      * iss larger then the size of {@code xval}.\n      */\n-    public UnivariateRealFunction interpolate(double[] xval,\n+    public UnivariateFunction interpolate(double[] xval,\n                                               double[] yval) {\n         if (xval.length < extend) {\n             throw new NumberIsTooSmallException(xval.length, extend, true);\n \n         MathArrays.sortInPlace(x, y);\n \n-        final UnivariateRealFunction f = interpolator.interpolate(x, y);\n-        return new UnivariateRealFunction() {\n+        final UnivariateFunction f = interpolator.interpolate(x, y);\n+        return new UnivariateFunction() {\n             public double value(final double x) {\n                 return f.value(MathUtils.reduce(x, period, offset));\n             }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n  *\n  * @version $Id$\n  */\n-public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n+public class PolynomialFunction implements DifferentiableUnivariateFunction, Serializable {\n     /**\n      * Serialization identifier\n      */\n      *\n      * @param x Argument for which the function value should be computed.\n      * @return the value of the polynomial at the given point.\n-     * @see UnivariateRealFunction#value(double)\n+     * @see UnivariateFunction#value(double)\n      */\n     public double value(double x) {\n        return evaluate(coefficients, x);\n     }\n \n     /**\n-     * Returns the derivative as a {@link UnivariateRealFunction}.\n+     * Returns the derivative as a {@link UnivariateFunction}.\n      *\n      * @return the derivative function.\n      */\n-    public UnivariateRealFunction derivative() {\n+    public UnivariateFunction derivative() {\n         return polynomialDerivative();\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static class Parametric implements ParametricUnivariateRealFunction {\n+    public static class Parametric implements ParametricUnivariateFunction {\n         /** {@inheritDoc} */\n         public double[] gradient(double x, double ... parameters) {\n             final double[] gradient = new double[parameters.length];\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.exception.DimensionMismatchException;\n  * @version $Id$\n  * @since 1.2\n  */\n-public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction {\n+public class PolynomialFunctionLagrangeForm implements UnivariateFunction {\n     /**\n      * The coefficients of the polynomial, ordered by degree -- i.e.\n      * coefficients[0] is the constant term and coefficients[n] is the\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n \n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * @version $Id$\n  * @since 1.2\n  */\n-public class PolynomialFunctionNewtonForm implements UnivariateRealFunction {\n+public class PolynomialFunctionNewtonForm implements UnivariateFunction {\n \n     /**\n      * The coefficients of the polynomial, ordered by degree -- i.e.\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n import java.util.Arrays;\n \n import org.apache.commons.math.util.MathArrays;\n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n  *\n  * @version $Id$\n  */\n-public class PolynomialSplineFunction implements DifferentiableUnivariateRealFunction {\n+public class PolynomialSplineFunction implements DifferentiableUnivariateFunction {\n     /**\n      * Spline segment interval delimiters (knots).\n      * Size is n + 1 for n segments.\n      *\n      * @return the derivative function.\n      */\n-    public UnivariateRealFunction derivative() {\n+    public UnivariateFunction derivative() {\n         return polynomialSplineDerivative();\n     }\n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AbstractDifferentiableUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractDifferentiableUnivariateRealSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n  * @since 3.0\n  */\n public abstract class AbstractDifferentiableUnivariateRealSolver\n-    extends BaseAbstractUnivariateRealSolver<DifferentiableUnivariateRealFunction>\n+    extends BaseAbstractUnivariateRealSolver<DifferentiableUnivariateFunction>\n     implements DifferentiableUnivariateRealSolver {\n     /** Derivative of the function to solve. */\n-    private UnivariateRealFunction functionDerivative;\n+    private UnivariateFunction functionDerivative;\n \n     /**\n      * Construct a solver with given absolute accuracy.\n      * {@inheritDoc}\n      */\n     @Override\n-    protected void setup(int maxEval, DifferentiableUnivariateRealFunction f,\n+    protected void setup(int maxEval, DifferentiableUnivariateFunction f,\n                          double min, double max, double startValue) {\n         super.setup(maxEval, f, min, max, startValue);\n         functionDerivative = f.derivative();\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateRealSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /**\n  * Base class for solvers.\n  * @since 3.0\n  */\n public abstract class AbstractUnivariateRealSolver\n-    extends BaseAbstractUnivariateRealSolver<UnivariateRealFunction>\n+    extends BaseAbstractUnivariateRealSolver<UnivariateFunction>\n     implements UnivariateRealSolver {\n     /**\n      * Construct a solver with given absolute accuracy.\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n  * @version $Id$\n  * @since 2.0\n  */\n-public abstract class BaseAbstractUnivariateRealSolver<FUNC extends UnivariateRealFunction>\n+public abstract class BaseAbstractUnivariateRealSolver<FUNC extends UnivariateFunction>\n     implements BaseUnivariateRealSolver<FUNC> {\n     /** Default relative accuracy. */\n     private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.MathInternalError;\n \n  */\n public abstract class BaseSecantSolver\n     extends AbstractUnivariateRealSolver\n-    implements BracketedUnivariateRealSolver<UnivariateRealFunction> {\n+    implements BracketedUnivariateRealSolver<UnivariateFunction> {\n \n     /** Default absolute accuracy. */\n     protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(final int maxEval, final UnivariateRealFunction f,\n+    public double solve(final int maxEval, final UnivariateFunction f,\n                         final double min, final double max,\n                         final AllowedSolution allowedSolution) {\n         return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(final int maxEval, final UnivariateRealFunction f,\n+    public double solve(final int maxEval, final UnivariateFunction f,\n                         final double min, final double max, final double startValue,\n                         final AllowedSolution allowedSolution) {\n         this.allowed = allowedSolution;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double solve(final int maxEval, final UnivariateRealFunction f,\n+    public double solve(final int maxEval, final UnivariateFunction f,\n                         final double min, final double max, final double startValue) {\n         return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n \n /**\n  * @see PolynomialSolver\n  * @see DifferentiableUnivariateRealSolver\n  */\n-public interface BaseUnivariateRealSolver<FUNC extends UnivariateRealFunction> {\n+public interface BaseUnivariateRealSolver<FUNC extends UnivariateFunction> {\n     /**\n      * Get the maximum number of function evaluations.\n      *\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /** Interface for {@link UnivariateRealSolver (univariate real) root-finding\n  * algorithms} that maintain a bracketed solution. There are several advantages\n  * @since 3.0\n  * @version $Id$\n  */\n-public interface BracketedUnivariateRealSolver<FUNC extends UnivariateRealFunction>\n+public interface BracketedUnivariateRealSolver<FUNC extends UnivariateFunction>\n     extends BaseUnivariateRealSolver<FUNC> {\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n  */\n public class BracketingNthOrderBrentSolver\n     extends AbstractUnivariateRealSolver\n-    implements BracketedUnivariateRealSolver<UnivariateRealFunction> {\n+    implements BracketedUnivariateRealSolver<UnivariateFunction> {\n \n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(int maxEval, UnivariateRealFunction f, double min,\n+    public double solve(int maxEval, UnivariateFunction f, double min,\n                         double max, AllowedSolution allowedSolution) {\n         this.allowed = allowedSolution;\n         return super.solve(maxEval, f, min, max);\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(int maxEval, UnivariateRealFunction f, double min,\n+    public double solve(int maxEval, UnivariateFunction f, double min,\n                         double max, double startValue,\n                         AllowedSolution allowedSolution) {\n         this.allowed = allowedSolution;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/DifferentiableUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/DifferentiableUnivariateRealSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n \n \n /**\n  * @version $Id$\n  */\n public interface DifferentiableUnivariateRealSolver\n-    extends BaseUnivariateRealSolver<DifferentiableUnivariateRealFunction> {}\n+    extends BaseUnivariateRealSolver<DifferentiableUnivariateFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n      * if {@code min >= max}.\n      */\n     @Override\n-    public double solve(int maxEval, final DifferentiableUnivariateRealFunction f,\n+    public double solve(int maxEval, final DifferentiableUnivariateFunction f,\n                         final double min, final double max) {\n         return super.solve(maxEval, f, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n \n /**\n  * @version $Id$\n  */\n public interface UnivariateRealSolver\n-    extends BaseUnivariateRealSolver<UnivariateRealFunction> {}\n+    extends BaseUnivariateRealSolver<UnivariateFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n      * @throws IllegalArgumentException if f is null or the endpoints do not\n      * specify a valid interval.\n      */\n-    public static double solve(UnivariateRealFunction function, double x0, double x1) {\n+    public static double solve(UnivariateFunction function, double x0, double x1) {\n         if (function == null) {\n             throw new NullArgumentException(LocalizedFormats.FUNCTION);\n         }\n      * the endpoints do not specify a valid interval, or the absolute accuracy\n      * is not valid for the default solver.\n      */\n-    public static double solve(UnivariateRealFunction function,\n+    public static double solve(UnivariateFunction function,\n                                double x0, double x1,\n                                double absoluteAccuracy) {\n         if (function == null) {\n      * accept as solutions.\n      * @return a root approximation, on the specified side of the exact root\n      */\n-    public static double forceSide(final int maxEval, final UnivariateRealFunction f,\n-                                   final BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing,\n+    public static double forceSide(final int maxEval, final UnivariateFunction f,\n+                                   final BracketedUnivariateRealSolver<UnivariateFunction> bracketing,\n                                    final double baseRoot, final double min, final double max,\n                                    final AllowedSolution allowedSolution) {\n \n      * <code>ConvergenceException.</code>  Unless you are confident that there\n      * is a root between <code>lowerBound</code> and <code>upperBound</code>\n      * near <code>initial,</code> it is better to use\n-     * {@link #bracket(UnivariateRealFunction, double, double, double, int)},\n+     * {@link #bracket(UnivariateFunction, double, double, double, int)},\n      * explicitly specifying the maximum number of iterations.</p>\n      *\n      * @param function Function.\n      * @throws IllegalArgumentException if function is null, maximumIterations\n      * is not positive, or initial is not between lowerBound and upperBound.\n      */\n-    public static double[] bracket(UnivariateRealFunction function,\n+    public static double[] bracket(UnivariateFunction function,\n                                    double initial,\n                                    double lowerBound, double upperBound) {\n         return bracket(function, initial, lowerBound, upperBound, Integer.MAX_VALUE);\n      * @throws IllegalArgumentException if function is null, maximumIterations\n      * is not positive, or initial is not between lowerBound and upperBound.\n      */\n-    public static double[] bracket(UnivariateRealFunction function,\n+    public static double[] bracket(UnivariateFunction function,\n                                    double initial,\n                                    double lowerBound, double upperBound,\n                                    int maximumIterations)  {\n      * @return {@code true} if the function values have opposite signs at the\n      * given points.\n      */\n-    public static boolean isBracketing(UnivariateRealFunction function,\n+    public static boolean isBracketing(UnivariateFunction function,\n                                        final double lower,\n                                        final double upper) {\n         if (function == null) {\n      * @throws NoBracketingException if function has the same sign at the\n      * endpoints.\n      */\n-    public static void verifyBracketing(UnivariateRealFunction function,\n+    public static void verifyBracketing(UnivariateFunction function,\n                                         final double lower,\n                                         final double upper) {\n         if (function == null) {\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n         // by default, do simple root finding using bracketing and default solver.\n         // subclasses can override if there is a better method.\n-        UnivariateRealFunction rootFindingFunction =\n-            new UnivariateRealFunction() {\n+        UnivariateFunction rootFindingFunction =\n+            new UnivariateFunction() {\n             public double value(double x) {\n                 return cumulativeProbability(x) - p;\n             }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n import java.util.Arrays;\n import java.util.Iterator;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n \n     /** {@inheritDoc} */\n     @Override\n-    public ArrayRealVector map(UnivariateRealFunction function) {\n+    public ArrayRealVector map(UnivariateFunction function) {\n         return copy().mapToSelf(function);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public ArrayRealVector mapToSelf(UnivariateRealFunction function) {\n+    public ArrayRealVector mapToSelf(UnivariateFunction function) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = function.value(data[i]);\n         }\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n import org.apache.commons.math.analysis.function.Add;\n import org.apache.commons.math.analysis.function.Multiply;\n import org.apache.commons.math.analysis.function.Divide;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n      * @param function Function to apply to each entry.\n      * @return a new vector.\n      */\n-    public RealVector map(UnivariateRealFunction function) {\n+    public RealVector map(UnivariateFunction function) {\n         return copy().mapToSelf(function);\n     }\n \n      * @param function Function to apply to each entry.\n      * @return a reference to this vector.\n      */\n-    public RealVector mapToSelf(UnivariateRealFunction function) {\n+    public RealVector mapToSelf(UnivariateFunction function) {\n         Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n         return new RealVector() {\n             /** {@inheritDoc} */\n             @Override\n-            public RealVector mapToSelf(UnivariateRealFunction function) {\n+            public RealVector mapToSelf(UnivariateFunction function) {\n                 throw new MathUnsupportedOperationException();\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector map(UnivariateRealFunction function) {\n+            public RealVector map(UnivariateFunction function) {\n                 return v.map(function);\n             }\n \n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n \n package org.apache.commons.math.ode.events;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.AllowedSolution;\n import org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver;\n import org.apache.commons.math.analysis.solvers.PegasusSolver;\n             final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n             final double h = dt / n;\n \n-            final UnivariateRealFunction f = new UnivariateRealFunction() {\n+            final UnivariateFunction f = new UnivariateFunction() {\n                 public double value(final double t) {\n                     interpolator.setInterpolatedTime(t);\n                     return handler.g(t, interpolator.getInterpolatedState());\n                     final double root;\n                     if (solver instanceof BracketedUnivariateRealSolver<?>) {\n                         @SuppressWarnings(\"unchecked\")\n-                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n-                                (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n+                        BracketedUnivariateRealSolver<UnivariateFunction> bracketing =\n+                                (BracketedUnivariateRealSolver<UnivariateFunction>) solver;\n                         root = forward ?\n                                bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                                bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                                                 solver.solve(maxIterationCount, f, ta, tb) :\n                                                 solver.solve(maxIterationCount, f, tb, ta);\n                         final int remainingEval = maxIterationCount - solver.getEvaluations();\n-                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n+                        BracketedUnivariateRealSolver<UnivariateFunction> bracketing =\n                                 new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                         root = forward ?\n                                UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionMappingAdapter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionMappingAdapter.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.function.Logit;\n import org.apache.commons.math.analysis.function.Sigmoid;\n import org.apache.commons.math.exception.DimensionMismatchException;\n     private static class LowerUpperBoundMapper implements Mapper {\n \n         /** Function from unbounded to bounded. */\n-        private final UnivariateRealFunction boundingFunction;\n+        private final UnivariateFunction boundingFunction;\n \n         /** Function from bounded to unbounded. */\n-        private final UnivariateRealFunction unboundingFunction;\n+        private final UnivariateFunction unboundingFunction;\n \n         /** Simple constructor.\n          * @param lower lower bound\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathArrays;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n          */\n         public UnivariateRealPointValuePair search(final double[] p, final double[] d) {\n             final int n = p.length;\n-            final UnivariateRealFunction f = new UnivariateRealFunction() {\n+            final UnivariateFunction f = new UnivariateFunction() {\n                     public double value(double alpha) {\n                         final double[] x = new double[n];\n                         for (int i = 0; i < n; i++) {\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n import java.util.List;\n \n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n      */\n-    public double[] fit(final ParametricUnivariateRealFunction f, final double[] initialGuess) {\n+    public double[] fit(final ParametricUnivariateFunction f, final double[] initialGuess) {\n         return fit(Integer.MAX_VALUE, f, initialGuess);\n     }\n \n      * if the start point dimension is wrong.\n      * @since 3.0\n      */\n-    public double[] fit(int maxEval, final ParametricUnivariateRealFunction f,\n+    public double[] fit(int maxEval, final ParametricUnivariateFunction f,\n                         final double[] initialGuess) {\n         // prepare least squares problem\n         double[] target  = new double[observations.size()];\n     private class TheoreticalValuesFunction\n         implements DifferentiableMultivariateVectorialFunction {\n         /** Function to fit. */\n-        private final ParametricUnivariateRealFunction f;\n+        private final ParametricUnivariateFunction f;\n \n         /** Simple constructor.\n          * @param f function to fit.\n          */\n-        public TheoreticalValuesFunction(final ParametricUnivariateRealFunction f) {\n+        public TheoreticalValuesFunction(final ParametricUnivariateFunction f) {\n             this.f = f;\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.function.Gaussian;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n      * @since 3.0\n      */\n     public double[] fit(double[] initialGuess) {\n-        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n-                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n+        final ParametricUnivariateFunction f = new ParametricUnivariateFunction() {\n+                private final ParametricUnivariateFunction g = new Gaussian.Parametric();\n \n                 public double value(double x, double ... p) {\n                     double v = Double.POSITIVE_INFINITY;\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n             }\n \n             // Find the optimal step in the search direction.\n-            final UnivariateRealFunction lsf = new LineSearchFunction(searchDirection);\n+            final UnivariateFunction lsf = new LineSearchFunction(searchDirection);\n             final double uB = findUpperBound(lsf, 0, initialStep);\n             // XXX Last parameters is set to a value close to zero in order to\n             // work around the divergence problem in the \"testCircleFitting\"\n      * @return b such that f(a) and f(b) have opposite signs.\n      * @throws MathIllegalStateException if no bracket can be found.\n      */\n-    private double findUpperBound(final UnivariateRealFunction f,\n+    private double findUpperBound(final UnivariateFunction f,\n                                   final double a, final double h) {\n         final double yA = f.value(a);\n         double yB = yA;\n      * extremum along the search direction.\n      * </p>\n      */\n-    private class LineSearchFunction implements UnivariateRealFunction {\n+    private class LineSearchFunction implements UnivariateFunction {\n         /** Search direction. */\n         private final double[] searchDirection;\n \n--- a/src/main/java/org/apache/commons/math/optimization/package-info.java\n+++ b/src/main/java/org/apache/commons/math/optimization/package-info.java\n  * function:\n  * <ul>\n  *  <li>{@link org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer\n- *      UnivariateRealOptimizer} for {@link org.apache.commons.math.analysis.UnivariateRealFunction\n+ *      UnivariateRealOptimizer} for {@link org.apache.commons.math.analysis.UnivariateFunction\n  *      univariate real functions}</li>\n  *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer\n  *      MultivariateRealOptimizer} for {@link org.apache.commons.math.analysis.MultivariateRealFunction\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** Initial guess . */\n     private double searchStart;\n     /** Function to optimize. */\n-    private UnivariateRealFunction function;\n+    private UnivariateFunction function;\n \n     /**\n      * @param checker Convergence checking procedure.\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(int maxEval, UnivariateRealFunction f,\n+    public UnivariateRealPointValuePair optimize(int maxEval, UnivariateFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max,\n                                                  double startValue) {\n \n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(int maxEval,\n-                                                 UnivariateRealFunction f,\n+                                                 UnivariateFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max){\n         return optimize(maxEval, f, goalType, min, max, min + 0.5 * (max - min));\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.optimization.BaseOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n \n  * @version $Id$\n  * @since 3.0\n  */\n-public interface BaseUnivariateRealOptimizer<FUNC extends UnivariateRealFunction>\n+public interface BaseUnivariateRealOptimizer<FUNC extends UnivariateFunction>\n     extends BaseOptimizer<UnivariateRealPointValuePair> {\n     /**\n      * Find an optimum in the given interval.\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n /**\n      * @throws TooManyEvaluationsException if the maximum number of evaluations\n      * is exceeded.\n      */\n-    public void search(UnivariateRealFunction func, GoalType goal, double xA, double xB) {\n+    public void search(UnivariateFunction func, GoalType goal, double xA, double xB) {\n         evaluations.resetCount();\n         final boolean isMinim = goal == GoalType.MINIMIZE;\n \n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n      */\n-    private double eval(UnivariateRealFunction f, double x) {\n+    private double eval(UnivariateFunction f, double x) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFunction>\n+public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateFunction>\n     implements BaseUnivariateRealOptimizer<FUNC> {\n     /** Underlying classical optimizer. */\n     private final BaseUnivariateRealOptimizer<FUNC> optimizer;\n \n     /**\n      * Get all the optima found during the last call to {@link\n-     * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}.\n+     * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}.\n      * The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n+     * restarts. The {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n      * method returns the best point only. This method returns all the points\n      * found at the end of each starts, including the best one already\n-     * returned by the {@link #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n+     * returned by the {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n      * method.\n      * <br/>\n      * The returned array as one element for each start as specified\n      * descending order if maximizing), followed by {@code null} elements\n      * corresponding to the runs that did not converge. This means all\n      * elements will be {@code null} if the {@link\n-     * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n+     * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n      * method did throw an exception.\n      * This also means that if the first element is not {@code null}, it is\n      * the best point found across all starts.\n      *\n      * @return an array containing the optima.\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n+     * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n      * has not been called.\n      */\n     public UnivariateRealPointValuePair[] getOptima() {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /**\n  * Interface for univariate optimization algorithms.\n  * @since 3.0\n  */\n public interface UnivariateRealOptimizer\n-    extends BaseUnivariateRealOptimizer<UnivariateRealFunction> {}\n+    extends BaseUnivariateRealOptimizer<UnivariateFunction> {}\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n package org.apache.commons.math.transform;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] transform(UnivariateRealFunction f,\n+    public double[] transform(UnivariateFunction f,\n                               double min, double max, int n)\n         throws IllegalArgumentException {\n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] transform2(UnivariateRealFunction f,\n+    public double[] transform2(UnivariateFunction f,\n                                double min, double max, int n)\n         throws IllegalArgumentException {\n \n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] inversetransform(UnivariateRealFunction f,\n+    public double[] inversetransform(UnivariateFunction f,\n                                      double min, double max, int n)\n         throws IllegalArgumentException {\n \n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] inversetransform2(UnivariateRealFunction f,\n+    public double[] inversetransform2(UnivariateFunction f,\n                                       double min, double max, int n)\n         throws IllegalArgumentException {\n \n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import java.lang.reflect.Array;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] transform(UnivariateRealFunction f,\n+    public Complex[] transform(UnivariateFunction f,\n                                double min, double max, int n)\n         throws IllegalArgumentException {\n         double data[] = sample(f, min, max, n);\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] transform2(UnivariateRealFunction f,\n+    public Complex[] transform2(UnivariateFunction f,\n                                 double min, double max, int n)\n         throws IllegalArgumentException {\n \n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] inversetransform(UnivariateRealFunction f,\n+    public Complex[] inversetransform(UnivariateFunction f,\n                                       double min, double max, int n)\n         throws IllegalArgumentException {\n \n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] inversetransform2(UnivariateRealFunction f,\n+    public Complex[] inversetransform2(UnivariateFunction f,\n                                        double min, double max, int n)\n         throws IllegalArgumentException {\n \n      * @return the samples array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public static double[] sample(UnivariateRealFunction f, double min, double max, int n)\n+    public static double[] sample(UnivariateFunction f, double min, double max, int n)\n         throws IllegalArgumentException {\n \n         if (n <= 0) {\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n package org.apache.commons.math.transform;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n     }\n \n     /** {@inheritDoc} */\n-    public double[] transform(UnivariateRealFunction f,\n+    public double[] transform(UnivariateFunction f,\n                               double min, double max, int n)\n         throws IllegalArgumentException {\n         return fht(FastFourierTransformer.sample(f, min, max, n));\n    }\n \n     /** {@inheritDoc} */\n-    public double[] inversetransform(UnivariateRealFunction f,\n+    public double[] inversetransform(UnivariateFunction f,\n                                      double min, double max, int n)\n         throws IllegalArgumentException {\n         final double[] unscaled =\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n package org.apache.commons.math.transform;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] transform(UnivariateRealFunction f,\n+    public double[] transform(UnivariateFunction f,\n                               double min, double max, int n)\n         throws IllegalArgumentException {\n \n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform2(\n-        UnivariateRealFunction f, double min, double max, int n)\n+        UnivariateFunction f, double min, double max, int n)\n         throws IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n+    public double[] inversetransform(UnivariateFunction f, double min, double max, int n)\n         throws IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double[] inversetransform2(UnivariateRealFunction f, double min, double max, int n)\n+    public double[] inversetransform2(UnivariateFunction f, double min, double max, int n)\n         throws IllegalArgumentException {\n \n         return transform2(f, min, max, n);\n--- a/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /**\n  * Interface for one-dimensional data sets transformations producing real results.\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    double[] transform(UnivariateRealFunction f, double min, double max, int n)\n+    double[] transform(UnivariateFunction f, double min, double max, int n)\n         throws IllegalArgumentException;\n \n     /**\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n+    double[] inversetransform(UnivariateFunction f, double min, double max, int n)\n         throws IllegalArgumentException;\n \n }\n--- a/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n+++ b/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n  *\n  * @version $Id$\n  */\n-public class Expm1Function implements DifferentiableUnivariateRealFunction {\n+public class Expm1Function implements DifferentiableUnivariateFunction {\n \n     public double value(double x) {\n         return FastMath.expm1(x);\n     }\n \n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             public double value(double x) {\n                 return FastMath.exp(x);\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/FunctionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/FunctionUtilsTest.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.function.Identity;\n import org.apache.commons.math.analysis.function.Constant;\n import org.apache.commons.math.analysis.function.Minus;\n \n     @Test\n     public void testCompose() {\n-        UnivariateRealFunction id = new Identity();\n+        UnivariateFunction id = new Identity();\n         Assert.assertEquals(3, FunctionUtils.compose(id, id, id).value(3), EPS);\n \n-        UnivariateRealFunction c = new Constant(4);\n+        UnivariateFunction c = new Constant(4);\n         Assert.assertEquals(4, FunctionUtils.compose(id, c).value(3), EPS);\n         Assert.assertEquals(4, FunctionUtils.compose(c, id).value(3), EPS);\n \n-        UnivariateRealFunction m = new Minus();\n+        UnivariateFunction m = new Minus();\n         Assert.assertEquals(-3, FunctionUtils.compose(m).value(3), EPS);\n         Assert.assertEquals(3, FunctionUtils.compose(m, m).value(3), EPS);\n \n-        UnivariateRealFunction inv = new Inverse();\n+        UnivariateFunction inv = new Inverse();\n         Assert.assertEquals(-0.25, FunctionUtils.compose(inv, m, c, id).value(3), EPS);\n \n-        UnivariateRealFunction pow = new Power(2);\n+        UnivariateFunction pow = new Power(2);\n         Assert.assertEquals(81, FunctionUtils.compose(pow, pow).value(3), EPS);\n     }\n \n     @Test\n     public void testComposeDifferentiable() {\n-        DifferentiableUnivariateRealFunction id = new Identity();\n+        DifferentiableUnivariateFunction id = new Identity();\n         Assert.assertEquals(1, FunctionUtils.compose(id, id, id).derivative().value(3), EPS);\n \n-        DifferentiableUnivariateRealFunction c = new Constant(4);\n+        DifferentiableUnivariateFunction c = new Constant(4);\n         Assert.assertEquals(0, FunctionUtils.compose(id, c).derivative().value(3), EPS);\n         Assert.assertEquals(0, FunctionUtils.compose(c, id).derivative().value(3), EPS);\n \n-        DifferentiableUnivariateRealFunction m = new Minus();\n+        DifferentiableUnivariateFunction m = new Minus();\n         Assert.assertEquals(-1, FunctionUtils.compose(m).derivative().value(3), EPS);\n         Assert.assertEquals(1, FunctionUtils.compose(m, m).derivative().value(3), EPS);\n \n-        DifferentiableUnivariateRealFunction inv = new Inverse();\n+        DifferentiableUnivariateFunction inv = new Inverse();\n         Assert.assertEquals(0.25, FunctionUtils.compose(inv, m, id).derivative().value(2), EPS);\n \n-        DifferentiableUnivariateRealFunction pow = new Power(2);\n+        DifferentiableUnivariateFunction pow = new Power(2);\n         Assert.assertEquals(108, FunctionUtils.compose(pow, pow).derivative().value(3), EPS);\n \n-        DifferentiableUnivariateRealFunction log = new Log();\n+        DifferentiableUnivariateFunction log = new Log();\n         double a = 9876.54321;\n         Assert.assertEquals(pow.derivative().value(a) / pow.value(a),\n                             FunctionUtils.compose(log, pow).derivative().value(a), EPS);\n \n     @Test\n     public void testAdd() {\n-        UnivariateRealFunction id = new Identity();\n-        UnivariateRealFunction c = new Constant(4);\n-        UnivariateRealFunction m = new Minus();\n-        UnivariateRealFunction inv = new Inverse();\n+        UnivariateFunction id = new Identity();\n+        UnivariateFunction c = new Constant(4);\n+        UnivariateFunction m = new Minus();\n+        UnivariateFunction inv = new Inverse();\n \n         Assert.assertEquals(4.5, FunctionUtils.add(inv, m, c, id).value(2), EPS);\n         Assert.assertEquals(4 + 2, FunctionUtils.add(c, id).value(2), EPS);\n \n     @Test\n     public void testAddDifferentiable() {\n-        DifferentiableUnivariateRealFunction sin = new Sin();\n-        DifferentiableUnivariateRealFunction c = new Constant(4);\n-        DifferentiableUnivariateRealFunction m = new Minus();\n-        DifferentiableUnivariateRealFunction inv = new Inverse();\n+        DifferentiableUnivariateFunction sin = new Sin();\n+        DifferentiableUnivariateFunction c = new Constant(4);\n+        DifferentiableUnivariateFunction m = new Minus();\n+        DifferentiableUnivariateFunction inv = new Inverse();\n \n         final double a = 123.456;\n         Assert.assertEquals(- 1 / (a * a) -1 + Math.cos(a),\n \n     @Test\n     public void testMultiply() {\n-        UnivariateRealFunction c = new Constant(4);\n+        UnivariateFunction c = new Constant(4);\n         Assert.assertEquals(16, FunctionUtils.multiply(c, c).value(12345), EPS);\n \n-        UnivariateRealFunction inv = new Inverse();\n-        UnivariateRealFunction pow = new Power(2);\n+        UnivariateFunction inv = new Inverse();\n+        UnivariateFunction pow = new Power(2);\n         Assert.assertEquals(1, FunctionUtils.multiply(FunctionUtils.compose(inv, pow), pow).value(3.5), EPS);\n     }\n \n     @Test\n     public void testMultiplyDifferentiable() {\n-        DifferentiableUnivariateRealFunction c = new Constant(4);\n-        DifferentiableUnivariateRealFunction id = new Identity();\n+        DifferentiableUnivariateFunction c = new Constant(4);\n+        DifferentiableUnivariateFunction id = new Identity();\n         final double a = 1.2345678;\n         Assert.assertEquals(8 * a, FunctionUtils.multiply(c, id, id).derivative().value(a), EPS);\n \n-        DifferentiableUnivariateRealFunction inv = new Inverse();\n-        DifferentiableUnivariateRealFunction pow = new Power(2.5);\n-        DifferentiableUnivariateRealFunction cos = new Cos();\n+        DifferentiableUnivariateFunction inv = new Inverse();\n+        DifferentiableUnivariateFunction pow = new Power(2.5);\n+        DifferentiableUnivariateFunction cos = new Cos();\n         Assert.assertEquals(1.5 * Math.sqrt(a) * Math.cos(a) - Math.pow(a, 1.5) * Math.sin(a),\n                             FunctionUtils.multiply(inv, pow, cos).derivative().value(a), EPS);\n \n-        DifferentiableUnivariateRealFunction cosh = new Cosh();\n+        DifferentiableUnivariateFunction cosh = new Cosh();\n         Assert.assertEquals(1.5 * Math.sqrt(a) * Math.cosh(a) + Math.pow(a, 1.5) * Math.sinh(a),\n                             FunctionUtils.multiply(inv, pow, cosh).derivative().value(a), 8 * EPS);\n     }\n     @Test\n     public void testCombine() {\n         BivariateRealFunction bi = new Add();\n-        UnivariateRealFunction id = new Identity();\n-        UnivariateRealFunction m = new Minus();\n-        UnivariateRealFunction c = FunctionUtils.combine(bi, id, m);\n+        UnivariateFunction id = new Identity();\n+        UnivariateFunction m = new Minus();\n+        UnivariateFunction c = FunctionUtils.combine(bi, id, m);\n         Assert.assertEquals(0, c.value(2.3456), EPS);\n \n         bi = new Multiply();\n-        UnivariateRealFunction inv = new Inverse();\n+        UnivariateFunction inv = new Inverse();\n         c = FunctionUtils.combine(bi, id, inv);\n         Assert.assertEquals(1, c.value(2.3456), EPS);\n     }\n     @Test\n     public void testSinc() {\n         BivariateRealFunction div = new Divide();\n-        UnivariateRealFunction sin = new Sin();\n-        UnivariateRealFunction id = new Identity();\n-        UnivariateRealFunction sinc1 = FunctionUtils.combine(div, sin, id);\n-        UnivariateRealFunction sinc2 = new Sinc();\n+        UnivariateFunction sin = new Sin();\n+        UnivariateFunction id = new Identity();\n+        UnivariateFunction sinc1 = FunctionUtils.combine(div, sin, id);\n+        UnivariateFunction sinc2 = new Sinc();\n \n         for (int i = 0; i < 10; i++) {\n             double x = Math.random();\n \n     @Test\n     public void testFixingArguments() {\n-        UnivariateRealFunction scaler = FunctionUtils.fix1stArgument(new Multiply(), 10);\n+        UnivariateFunction scaler = FunctionUtils.fix1stArgument(new Multiply(), 10);\n         Assert.assertEquals(1.23456, scaler.value(0.123456), EPS);\n \n-        UnivariateRealFunction pow1 = new Power(2);\n-        UnivariateRealFunction pow2 = FunctionUtils.fix2ndArgument(new Pow(), 2);\n+        UnivariateFunction pow1 = new Power(2);\n+        UnivariateFunction pow2 = FunctionUtils.fix2ndArgument(new Pow(), 2);\n \n         for (int i = 0; i < 10; i++) {\n             double x = Math.random() * 10;\n--- a/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n  *\n  * @version $Id$\n  */\n-public class MonitoredFunction implements UnivariateRealFunction {\n+public class MonitoredFunction implements UnivariateFunction {\n \n-    public MonitoredFunction(UnivariateRealFunction f) {\n+    public MonitoredFunction(UnivariateFunction f) {\n         callsCount = 0;\n         this.f = f;\n     }\n     }\n \n     private int callsCount;\n-    private UnivariateRealFunction f;\n+    private UnivariateFunction f;\n \n }\n--- a/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n  *\n  * @version $Id$\n  */\n-public class QuinticFunction implements DifferentiableUnivariateRealFunction {\n+public class QuinticFunction implements DifferentiableUnivariateFunction {\n \n     /* Evaluate quintic.\n-     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     * @see org.apache.commons.math.UnivariateFunction#value(double)\n      */\n     public double value(double x) {\n         return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);\n     }\n \n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             public double value(double x) {\n                 return (5*x*x-3.75)*x*x+0.25;\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n  *\n  * @version $Id$\n  */\n-public class SinFunction implements DifferentiableUnivariateRealFunction {\n+public class SinFunction implements DifferentiableUnivariateFunction {\n \n     /* Evaluate sinus fuction.\n-     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     * @see org.apache.commons.math.UnivariateFunction#value(double)\n      */\n     public double value(double x) {\n         return FastMath.sin(x);\n \n     /* First derivative of sinus function\n      */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             public double value(double x) {\n                 return FastMath.cos(x);\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/SincFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SincFunction.java\n  *\n  * @version $Id$\n  */\n-public class SincFunction implements DifferentiableUnivariateRealFunction {\n+public class SincFunction implements DifferentiableUnivariateFunction {\n     private static final double EPS = 1e-12;\n \n     /**\n     /**\n      * {@inheritDoc}\n      */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             public double value(double x) {\n                 return (Math.abs(x) < EPS ?\n                         0 :\n--- a/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n  * @version $Id$\n  */\n public class SumSincFunction implements DifferentiableMultivariateRealFunction {\n-    private static final DifferentiableUnivariateRealFunction sinc = new SincFunction();\n-    private static final UnivariateRealFunction sincDeriv = sinc.derivative();\n+    private static final DifferentiableUnivariateFunction sinc = new SincFunction();\n+    private static final UnivariateFunction sincDeriv = sinc.derivative();\n \n     /**\n      * Factor that will multiply each term of the sum.\n--- a/src/test/java/org/apache/commons/math/analysis/XMinus5Function.java\n+++ b/src/test/java/org/apache/commons/math/analysis/XMinus5Function.java\n  *\n  * @version $Id$\n  */\n-public class XMinus5Function implements DifferentiableUnivariateRealFunction {\n+public class XMinus5Function implements DifferentiableUnivariateFunction {\n \n     /* Evaluate x - 5 fuction.\n-     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     * @see org.apache.commons.math.UnivariateFunction#value(double)\n      */\n     public double value(double x) {\n         return x - 5;\n \n     /* First derivative of x - 5 function\n      */\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n+    public UnivariateFunction derivative() {\n+        return new UnivariateFunction() {\n             public double value(double x) {\n                 return 1.0;\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/function/GaussianTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/GaussianTest.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n \n     @Test\n     public void testSomeValues() {\n-        final UnivariateRealFunction f = new Gaussian();\n+        final UnivariateFunction f = new Gaussian();\n \n         Assert.assertEquals(1 / FastMath.sqrt(2 * Math.PI), f.value(0), EPS);\n     }\n \n     @Test\n     public void testLargeArguments() {\n-        final UnivariateRealFunction f = new Gaussian();\n+        final UnivariateFunction f = new Gaussian();\n \n         Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), 0);\n         Assert.assertEquals(0, f.value(-Double.MAX_VALUE), 0);\n     @Test\n     public void testDerivative() {\n         final Gaussian f = new Gaussian();\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertEquals(0, dfdx.value(0), 0);\n     }\n     @Test\n     public void testDerivativeLargeArguments() {\n         final Gaussian f = new Gaussian(0, 1e-50);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);\n         Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);\n     @Test\n     public void testDerivativeNaN() {\n         final Gaussian f = new Gaussian(0, 1e-50);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertTrue(Double.isNaN(dfdx.value(Double.NaN)));\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/function/HarmonicOscillatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/HarmonicOscillatorTest.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n         final double a = -1.2;\n         final double w = 0.34;\n         final double p = 5.6;\n-        final UnivariateRealFunction f = new HarmonicOscillator(a, w, p);\n+        final UnivariateFunction f = new HarmonicOscillator(a, w, p);\n \n         final double d = 0.12345;\n         for (int i = 0; i < 10; i++) {\n         final double w = 0.34;\n         final double p = 5.6;\n         final HarmonicOscillator f = new HarmonicOscillator(a, w, p);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         final double d = 0.12345;\n         for (int i = 0; i < 10; i++) {\n--- a/src/test/java/org/apache/commons/math/analysis/function/LogisticTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/LogisticTest.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n \n     @Test\n     public void testCompareSigmoid() {\n-        final UnivariateRealFunction sig = new Sigmoid();\n-        final UnivariateRealFunction sigL = new Logistic(1, 0, 1, 1, 0, 1);\n+        final UnivariateFunction sig = new Sigmoid();\n+        final UnivariateFunction sigL = new Logistic(1, 0, 1, 1, 0, 1);\n \n         final double min = -2;\n         final double max = 2;\n         final double a = -1;\n         final double n = 2;\n \n-        final UnivariateRealFunction f = new Logistic(k, m, b, q, a, n);\n+        final UnivariateFunction f = new Logistic(k, m, b, q, a, n);\n \n         double x;\n         x = m;\n         final Logistic f = new Logistic(k, 0, 1, 1, a, 1);\n         final Sigmoid g = new Sigmoid(a, k);\n         \n-        final UnivariateRealFunction dfdx = f.derivative();\n-        final UnivariateRealFunction dgdx = g.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n+        final UnivariateFunction dgdx = g.derivative();\n \n         final double min = -10;\n         final double max = 10;\n--- a/src/test/java/org/apache/commons/math/analysis/function/LogitTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/LogitTest.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n     public void testPreconditions1() {\n         final double lo = -1;\n         final double hi = 2;\n-        final UnivariateRealFunction f = new Logit(lo, hi);\n+        final UnivariateFunction f = new Logit(lo, hi);\n \n         f.value(lo - 1);\n     }\n     public void testPreconditions2() {\n         final double lo = -1;\n         final double hi = 2;\n-        final UnivariateRealFunction f = new Logit(lo, hi);\n+        final UnivariateFunction f = new Logit(lo, hi);\n \n         f.value(hi + 1);\n     }\n     public void testSomeValues() {\n         final double lo = 1;\n         final double hi = 2;\n-        final UnivariateRealFunction f = new Logit(lo, hi);\n+        final UnivariateFunction f = new Logit(lo, hi);\n \n         Assert.assertEquals(Double.NEGATIVE_INFINITY, f.value(1), EPS);\n         Assert.assertEquals(Double.POSITIVE_INFINITY, f.value(2), EPS);\n         final double lo = 1;\n         final double hi = 2;\n         final Logit f = new Logit(lo, hi);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertEquals(4, dfdx.value(1.5), EPS);\n     }\n     @Test\n     public void testDerivativeLargeArguments() {\n         final Logit f = new Logit(1, 2);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);\n         Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);\n         final double hi = 3;\n         final Logit f = new Logit(lo, hi);\n         final Sigmoid g = new Sigmoid(lo, hi);\n-        final UnivariateRealFunction id = FunctionUtils.compose(g, f);\n+        final UnivariateFunction id = FunctionUtils.compose(g, f);\n         \n         for (int i = 0; i < 10; i++) {\n             final double x = lo + Math.random() * (hi - lo);\n         final double lo = 2;\n         final double hi = 3;\n         final Logit f = new Logit(lo, hi);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n         final Sigmoid g = new Sigmoid(lo, hi);\n-        final UnivariateRealFunction dgdx = g.derivative();\n-        final UnivariateRealFunction chain\n+        final UnivariateFunction dgdx = g.derivative();\n+        final UnivariateFunction chain\n             = FunctionUtils.compose(new Inverse(), FunctionUtils.compose(dgdx, f));\n         \n         for (int i = 0; i < 10; i++) {\n--- a/src/test/java/org/apache/commons/math/analysis/function/SigmoidTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/SigmoidTest.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n \n \n     @Test\n     public void testSomeValues() {\n-        final UnivariateRealFunction f = new Sigmoid();\n+        final UnivariateFunction f = new Sigmoid();\n \n         Assert.assertEquals(0.5, f.value(0), EPS);\n         Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), EPS);\n     @Test\n     public void testDerivative() {\n         final Sigmoid f = new Sigmoid();\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertEquals(0.25, dfdx.value(0), 0);\n     }\n     @Test\n     public void testDerivativeLargeArguments() {\n         final Sigmoid f = new Sigmoid(1, 2);\n-        final UnivariateRealFunction dfdx = f.derivative();\n+        final UnivariateFunction dfdx = f.derivative();\n \n         Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);\n         Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);\n--- a/src/test/java/org/apache/commons/math/analysis/function/SincTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/SincTest.java\n  */\n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n import org.junit.Assert;\n    @Test\n    public void testShortcut() {\n        final Sinc s = new Sinc();\n-       final UnivariateRealFunction f = new UnivariateRealFunction() {\n+       final UnivariateFunction f = new UnivariateFunction() {\n                public double value(double x) {\n                    return FastMath.sin(x) / x;\n                }\n \n    @Test\n    public void testDerivativeZero() {\n-       final UnivariateRealFunction sPrime = (new Sinc(true)).derivative();\n+       final UnivariateFunction sPrime = (new Sinc(true)).derivative();\n \n        Assert.assertEquals(0, sPrime.value(0), 0);\n    }\n \n    @Test\n    public void testDerivativeShortcut() {\n-       final UnivariateRealFunction sPrime = (new Sinc()).derivative();\n-       final UnivariateRealFunction f = new UnivariateRealFunction() {\n+       final UnivariateFunction sPrime = (new Sinc()).derivative();\n+       final UnivariateFunction f = new UnivariateFunction() {\n                public double value(double x) {\n                    return (FastMath.cos(x) - FastMath.sin(x) / x) / x;\n                }\n--- a/src/test/java/org/apache/commons/math/analysis/function/SqrtTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/SqrtTest.java\n  */\n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n import org.junit.Test;\n import org.junit.Assert;\n    @Test\n    public void testComparison() {\n        final Sqrt s = new Sqrt();\n-       final UnivariateRealFunction f = new UnivariateRealFunction() {\n+       final UnivariateFunction f = new UnivariateFunction() {\n                public double value(double x) {\n                    return Math.sqrt(x);\n                }\n \n    @Test\n    public void testDerivativeComparison() {\n-       final UnivariateRealFunction sPrime = (new Sqrt()).derivative();\n-       final UnivariateRealFunction f = new UnivariateRealFunction() {\n+       final UnivariateFunction sPrime = (new Sqrt()).derivative();\n+       final UnivariateFunction f = new UnivariateFunction() {\n                public double value(double x) {\n                    return 1 / (2 * Math.sqrt(x));\n                }\n--- a/src/test/java/org/apache/commons/math/analysis/function/StepFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/StepFunctionTest.java\n \n package org.apache.commons.math.analysis.function;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NullArgumentException;\n         final double[] x = { -2, -0.5, 0, 1.9, 7.4, 21.3 };\n         final double[] y = { 4, -1, -5.5, 0.4, 5.8, 51.2 };\n \n-        final UnivariateRealFunction f = new StepFunction(x, y);\n+        final UnivariateFunction f = new StepFunction(x, y);\n \n         Assert.assertEquals(4, f.value(Double.NEGATIVE_INFINITY), EPS);\n         Assert.assertEquals(4, f.value(-10), EPS);\n         final double[] x = {0, 1, 2, 3};\n         final double[] xp = {-8, 1, 2, 3};\n         final double[] y = {1, 2, 3, 4};\n-        final UnivariateRealFunction f = new StepFunction(x, y);\n-        final UnivariateRealFunction fp = new StepFunction(xp, y);\n+        final UnivariateFunction f = new StepFunction(x, y);\n+        final UnivariateFunction fp = new StepFunction(xp, y);\n         Assert.assertEquals(f.value(-8), fp.value(-8), EPS);\n         Assert.assertEquals(f.value(-10), fp.value(-10), EPS);\n         Assert.assertEquals(f.value(0), fp.value(0), EPS);\n \n     @Test\n     public void testHeaviside() {   \n-        final UnivariateRealFunction h = new StepFunction(new double[] {-1, 0},\n+        final UnivariateFunction h = new StepFunction(new double[] {-1, 0},\n                                                           new double[] {0, 1});\n \n         Assert.assertEquals(0, h.value(Double.NEGATIVE_INFINITY), 0);\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n \n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);\n         double min, max, expected, result, tolerance;\n \n \n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator =\n                 new LegendreGaussIntegrator(3,\n                                             UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,\n     @Test\n     public void testIssue464() {\n         final double value = 0.2;\n-        UnivariateRealFunction f = new UnivariateRealFunction() {\n+        UnivariateFunction f = new UnivariateFunction() {\n             public double value(double x) {\n                 return (x >= 0 && x <= 5) ? value : 0.0;\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new RombergIntegrator();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new RombergIntegrator();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n \n         try {\n             // bad interval\n--- a/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         try {\n             // bad interval\n             new SimpsonIntegrator().integrate(1000, f, 1, -1);\n--- a/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n \n         try {\n             // bad interval\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n             y[i] = f.value(x[i]);\n         }\n         double derivativebound = 1.0;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+        UnivariateFunction p = interpolator.interpolate(x, y);\n \n         z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n      */\n     @Test\n     public void testExpm1Function() {\n-        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateFunction f = new Expm1Function();\n         UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n             y[i] = f.value(x[i]);\n         }\n         double derivativebound = FastMath.E;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+        UnivariateFunction p = interpolator.interpolate(x, y);\n \n         z = 0.0; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n             // bad abscissas array\n             double x[] = { 1.0, 2.0, 2.0, 4.0 };\n             double y[] = { 0.0, 4.0, 4.0, 2.5 };\n-            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            UnivariateFunction p = interpolator.interpolate(x, y);\n             p.value(0.0);\n             Assert.fail(\"Expecting NonMonotonicSequenceException - bad abscissas array\");\n         } catch (NonMonotonicSequenceException ex) {\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LinearInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LinearInterpolatorTest.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n import org.junit.Assert;\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 1.0 };\n         UnivariateRealInterpolator i = new LinearInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n         // Verify coefficients using analytical values\n         double x[] = { 0.0, 0.5, 1.0, 1.5 };\n         double y[] = { 0.0, 0.5, 1.0, 1.5 };\n         UnivariateRealInterpolator i = new LinearInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n         // Verify coefficients using analytical values\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 0.0 };\n         UnivariateRealInterpolator i = new LinearInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n         // Verify coefficients using analytical values\n     /**\n      * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.\n      */\n-    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])\n+    protected void verifyInterpolation(UnivariateFunction f, double x[], double y[])\n         throws Exception{\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n             y[i] = f.value(x[i]);\n         }\n         double derivativebound = 1.0;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+        UnivariateFunction p = interpolator.interpolate(x, y);\n \n         z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n      */\n     @Test\n     public void testExpm1Function() {\n-        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateFunction f = new Expm1Function();\n         UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n             y[i] = f.value(x[i]);\n         }\n         double derivativebound = FastMath.E;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+        UnivariateFunction p = interpolator.interpolate(x, y);\n \n         z = 0.0; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n             // bad abscissas array\n             double x[] = { 1.0, 2.0, 2.0, 4.0 };\n             double y[] = { 0.0, 4.0, 4.0, 2.5 };\n-            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            UnivariateFunction p = interpolator.interpolate(x, y);\n             p.value(0.0);\n             Assert.fail(\"Expecting NonMonotonicSequenceException - bad abscissas array\");\n         } catch (NonMonotonicSequenceException ex) {\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n import org.junit.Assert;\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 1.0 };\n         UnivariateRealInterpolator i = new SplineInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n \n         double x[] = { 0.0, 0.5, 1.0, 1.5 };\n         double y[] = { 0.0, 0.5, 1.0, 1.5 };\n         UnivariateRealInterpolator i = new SplineInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n         // Verify coefficients using analytical values\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 0.0 };\n         UnivariateRealInterpolator i = new SplineInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n \n                 2.d * FastMath.PI };\n         double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };\n         UnivariateRealInterpolator i = new SplineInterpolator();\n-        UnivariateRealFunction f = i.interpolate(x, y);\n+        UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n \n     /**\n      * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.\n      */\n-    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])\n+    protected void verifyInterpolation(UnivariateFunction f, double x[], double y[])\n         throws Exception{\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import java.util.Random;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n         }\n \n         final UnivariateRealInterpolator inter = new LinearInterpolator();\n-        final UnivariateRealFunction f = inter.interpolate(xval, yval);\n+        final UnivariateFunction f = inter.interpolate(xval, yval);\n \n         final UnivariateRealInterpolator interP\n             = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),\n                                                      period, 1);\n-        final UnivariateRealFunction fP = interP.interpolate(xval, yval);\n+        final UnivariateFunction fP = interP.interpolate(xval, yval);\n \n         // Comparing with original interpolation algorithm.\n         final double xMin = xval[0];\n         final UnivariateRealInterpolator interP\n             = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),\n                                                      period, 1);\n-        final UnivariateRealFunction fP = interP.interpolate(xval, yval);\n+        final UnivariateFunction fP = interP.interpolate(xval, yval);\n \n         // Test interpolation outside the sample data interval.\n         for (int i = 0; i < n; i++) {\n         final UnivariateRealInterpolator interP\n             = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),\n                                                      period, 1);\n-        final UnivariateRealFunction fP = interP.interpolate(xval, yval);\n+        final UnivariateFunction fP = interP.interpolate(xval, yval);\n \n         // Test interpolation outside the sample data interval.\n         for (int i = 0; i < n; i++) {\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n import org.junit.Assert;\n \n /**\n- * Tests the PolynomialFunction implementation of a UnivariateRealFunction.\n+ * Tests the PolynomialFunction implementation of a UnivariateFunction.\n  *\n  * @version $Id$\n  */\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.junit.Assert;\n     public void testValues() throws Exception {\n         PolynomialSplineFunction spline =\n             new PolynomialSplineFunction(knots, polynomials);\n-        UnivariateRealFunction dSpline = spline.derivative();\n+        UnivariateFunction dSpline = spline.derivative();\n \n         /**\n          * interior points -- spline value at x should equal p(x - knot)\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.integration.LegendreGaussIntegrator;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n     @Test\n     public void testChebyshevOrthogonality() {\n-        UnivariateRealFunction weight = new UnivariateRealFunction() {\n+        UnivariateFunction weight = new UnivariateFunction() {\n             public double value(double x) {\n                 return 1 / FastMath.sqrt(1 - x * x);\n             }\n \n     @Test\n     public void testHermiteOrthogonality() {\n-        UnivariateRealFunction weight = new UnivariateRealFunction() {\n+        UnivariateFunction weight = new UnivariateFunction() {\n             public double value(double x) {\n                 return FastMath.exp(-x * x);\n             }\n \n     @Test\n     public void testLaguerreOrthogonality() {\n-        UnivariateRealFunction weight = new UnivariateRealFunction() {\n+        UnivariateFunction weight = new UnivariateFunction() {\n             public double value(double x) {\n                 return FastMath.exp(-x);\n             }\n \n     @Test\n     public void testLegendreOrthogonality() {\n-        UnivariateRealFunction weight = new UnivariateRealFunction() {\n+        UnivariateFunction weight = new UnivariateFunction() {\n             public double value(double x) {\n                 return 1;\n             }\n             for (int w = v; w < 5; ++w) {\n                 final int vv = v;\n                 final int ww = w;\n-                UnivariateRealFunction weight = new UnivariateRealFunction() {\n+                UnivariateFunction weight = new UnivariateFunction() {\n                     public double value(double x) {\n                         return FastMath.pow(1 - x, vv) * FastMath.pow(1 + x, ww);\n                     }\n \n     private void checkOrthogonality(final PolynomialFunction p1,\n                                     final PolynomialFunction p2,\n-                                    final UnivariateRealFunction weight,\n+                                    final UnivariateFunction weight,\n                                     final double a, final double b,\n                                     final double nonZeroThreshold,\n                                     final double zeroThreshold) {\n-        UnivariateRealFunction f = new UnivariateRealFunction() {\n+        UnivariateFunction f = new UnivariateFunction() {\n             public double value(double x) {\n                 return weight.value(x) * p1.value(x) * p2.value(x);\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.XMinus5Function;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NoBracketingException;\n         // The sinus function is behaved well around the root at pi. The second\n         // order derivative is zero, which means linear approximating methods\n         // still converge quadratically.\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = getSolver();\n \n         // The function has extrema (first derivative is zero) at 0.27195613\n         // and 0.82221643, intervals containing these values are harder for\n         // the solvers.\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         double result;\n         UnivariateRealSolver solver = getSolver();\n         double atol = solver.getAbsoluteAccuracy();\n \n     @Test\n     public void testRootEndpoints() {\n-        UnivariateRealFunction f = new XMinus5Function();\n+        UnivariateFunction f = new XMinus5Function();\n         UnivariateRealSolver solver = getSolver();\n \n         // End-point is root. This should be a special case in the solver, and\n \n     @Test\n     public void testBadEndpoints() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n         try {  // bad interval\n             solver.solve(100, f, 1, -1);\n \n     @Test\n     public void testSolutionLeftSide() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n \n     @Test\n     public void testSolutionRightSide() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n     }\n     @Test\n     public void testSolutionBelowSide() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n \n     @Test\n     public void testSolutionAboveSide() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n         }\n     }\n \n-    private double getSolution(UnivariateRealSolver solver, int maxEval, UnivariateRealFunction f,\n+    private double getSolution(UnivariateRealSolver solver, int maxEval, UnivariateFunction f,\n                                double left, double right, AllowedSolution allowedSolution) {\n         try {\n             @SuppressWarnings(\"unchecked\")\n-            BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n-            (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n+            BracketedUnivariateRealSolver<UnivariateFunction> bracketing =\n+            (BracketedUnivariateRealSolver<UnivariateFunction>) solver;\n             return bracketing.solve(100, f, left, right, allowedSolution);\n         } catch (ClassCastException cce) {\n             double baseRoot = solver.solve(maxEval, f, left, right);\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n public final class BisectionSolverTest {\n     @Test\n     public void testSinZero() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         double result;\n \n         BisectionSolver solver = new BisectionSolver();\n \n     @Test\n     public void testQuinticZero() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         double result;\n \n         BisectionSolver solver = new BisectionSolver();\n \n     @Test\n     public void testMath369() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         BisectionSolver solver = new BisectionSolver();\n         Assert.assertEquals(FastMath.PI, solver.solve(100, f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n         compare(f, f.getRoot(), f.getMin(), f.getMax());\n     }\n \n-    private void compare(DifferentiableUnivariateRealFunction f,\n+    private void compare(DifferentiableUnivariateFunction f,\n                          double root, double min, double max) {\n         NewtonSolver newton = new NewtonSolver(1.0e-12);\n         BracketingNthOrderBrentSolver bracketing =\n         Assert.assertTrue(bracketing.getEvaluations() < newton.getEvaluations());\n     }\n \n-    private static abstract class TestFunction implements DifferentiableUnivariateRealFunction {\n+    private static abstract class TestFunction implements DifferentiableUnivariateFunction {\n \n         private final double root;\n         private final double min;\n \n         public abstract double derivative(double x);\n \n-        public UnivariateRealFunction derivative() {\n-            return new UnivariateRealFunction() {\n+        public UnivariateFunction derivative() {\n+            return new UnivariateFunction() {\n                 public double value(double x) {\n                      return derivative(x);\n                 }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n import org.apache.commons.math.analysis.MonitoredFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NoBracketingException;\n         // The sinus function is behaved well around the root at pi. The second\n         // order derivative is zero, which means linar approximating methods will\n         // still converge quadratically.\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = new BrentSolver();\n         // Somewhat benign interval. The function is monotone.\n         // the function grows fast for x>1.\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         // intervals containing these values are harder for the solvers.\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         double result;\n         // Brent-Dekker solver.\n         UnivariateRealSolver solver = new BrentSolver();\n \n     @Test\n     public void testRootEndpoints() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         BrentSolver solver = new BrentSolver();\n \n         // endpoint is root\n \n     @Test\n     public void testBadEndpoints() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         BrentSolver solver = new BrentSolver();\n         try {  // bad interval\n             solver.solve(100, f, 1, -1);\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver2();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new MullerSolver2();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testExpm1Function() {\n-        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new MullerSolver2();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver2();\n \n         try {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testExpm1Function() {\n-        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n \n         try {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.util.FastMath;\n      */\n     @Test\n     public void testSinZero() {\n-        DifferentiableUnivariateRealFunction f = new SinFunction();\n+        DifferentiableUnivariateFunction f = new SinFunction();\n         double result;\n \n         NewtonSolver solver = new NewtonSolver();\n      */\n     @Test\n     public void testQuinticZero() {\n-        DifferentiableUnivariateRealFunction f = new QuinticFunction();\n+        DifferentiableUnivariateFunction f = new QuinticFunction();\n         double result;\n \n         NewtonSolver solver = new NewtonSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.junit.Test;\n import org.junit.Assert;\n \n     @Test(expected=ConvergenceException.class)\n     public void testIssue631() {\n-        final UnivariateRealFunction f = new UnivariateRealFunction() {\n+        final UnivariateFunction f = new UnivariateFunction() {\n                 /** {@inheritDoc} */\n                 public double value(double x) {\n                     return Math.exp(x) - Math.pow(Math.PI, 3.0);\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testQuinticFunction() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testExpm1Function() {\n-        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n      */\n     @Test\n     public void testParameters() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n \n         try {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n  */\n public class UnivariateRealSolverUtilsTest {\n \n-    protected UnivariateRealFunction sin = new SinFunction();\n+    protected UnivariateFunction sin = new SinFunction();\n \n     @Test(expected=MathIllegalArgumentException.class)\n     public void testSolveNull() {\n \n     @Test\n     public void testMisc() {\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         double result;\n         // Static solve method\n         result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n import java.util.Random;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.function.Abs;\n import org.apache.commons.math.analysis.function.Acos;\n import org.apache.commons.math.analysis.function.Asin;\n         }\n \n         @Override\n-        public RealVector map(UnivariateRealFunction function) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapToSelf(UnivariateRealFunction function) {\n+        public RealVector map(UnivariateFunction function) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public RealVector mapToSelf(UnivariateFunction function) {\n             throw unsupported();\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/RealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorTest.java\n \n import org.junit.Test;\n import org.junit.Assert;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.RealVector.Entry;\n import java.util.Iterator;\n     public void testMap() throws Exception {\n         double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };\n         RealVector v = new TestVectorImpl(vec1.clone());\n-        RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });\n+        RealVector w = v.map(new UnivariateFunction() { public double value(double x) { return x * x; } });\n         double[] d2 = w.toArray();\n         Assert.assertEquals(vec1Squared.length, d2.length);\n         for(int i=0; i<vec1Squared.length; i++) {\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n import org.junit.Test;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathArithmeticException;\n         }\n \n         @Override\n-        public RealVector map(UnivariateRealFunction function) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapToSelf(UnivariateRealFunction function) {\n+        public RealVector map(UnivariateFunction function) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public RealVector mapToSelf(UnivariateFunction function) {\n             throw unsupported();\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/UnmodifiableRealVectorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/UnmodifiableRealVectorAbstractTest.java\n \n import junit.framework.Assert;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.function.Sin;\n import org.apache.commons.math.exception.MathUnsupportedOperationException;\n import org.apache.commons.math.linear.RealVector.Entry;\n             return v;\n         } else if (c.isAssignableFrom(RealVector.class)) {\n             return createVector();\n-        } else if (c.isAssignableFrom(UnivariateRealFunction.class)) {\n+        } else if (c.isAssignableFrom(UnivariateFunction.class)) {\n             return new Sin();\n         } else {\n             throw new IllegalArgumentException(\"could not create \" + c);\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n         fitter.addObservedPoint(1.655d, 0.9474675497289684);\n         fitter.addObservedPoint(1.725d, 0.9013594835804194d);\n \n-        ParametricUnivariateRealFunction sif = new SimpleInverseFunction();\n+        ParametricUnivariateFunction sif = new SimpleInverseFunction();\n \n         double[] initialguess1 = new double[1];\n         initialguess1[0] = 1.0d;\n         fitter.addObservedPoint(1.655d, 0.9474675497289684);\n         fitter.addObservedPoint(1.725d, 0.9013594835804194d);\n \n-        ParametricUnivariateRealFunction sif = new SimpleInverseFunction();\n+        ParametricUnivariateFunction sif = new SimpleInverseFunction();\n \n         double[] initialguess1 = new double[1];\n         initialguess1[0] = 1.0d;\n         curveFitter.addObservedPoint(250, 45087);\n         curveFitter.addObservedPoint(500, 50683);\n \n-        ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n+        ParametricUnivariateFunction f = new ParametricUnivariateFunction() {\n \n             public double value(double x, double ... parameters) {\n \n \n     }\n \n-    private static class SimpleInverseFunction implements ParametricUnivariateRealFunction {\n+    private static class SimpleInverseFunction implements ParametricUnivariateFunction {\n \n         public double value(double x, double ... parameters) {\n             return parameters[0] / x + (parameters.length < 2 ? 0 : parameters[1]);\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n import org.junit.Assert;\n     @Test\n     public void testCubicMin() {\n         final BracketFinder bFind = new BracketFinder();\n-        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+        final UnivariateFunction func = new UnivariateFunction() {\n                 public double value(double x) {\n                     if (x < -2) {\n                         return value(-2);\n     @Test\n     public void testCubicMax() {\n         final BracketFinder bFind = new BracketFinder();\n-        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+        final UnivariateFunction func = new UnivariateFunction() {\n                 public double value(double x) {\n                     if (x < -2) {\n                         return value(-2);\n \n     @Test\n     public void testMinimumIsOnIntervalBoundary() {\n-        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+        final UnivariateFunction func = new UnivariateFunction() {\n                 public double value(double x) {\n                     return x * x;\n                 }\n \n     @Test\n     public void testIntervalBoundsOrdering() {\n-        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+        final UnivariateFunction func = new UnivariateFunction() {\n                 public double value(double x) {\n                     return x * x;\n                 }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.junit.Assert;\n \n     @Test\n     public void testSinMin() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n         Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n         Assert.assertTrue(optimizer.getEvaluations() <= 50);\n     @Test\n     public void testQuinticMin() {\n         // The function has local minima at -0.27195613 and 0.82221643.\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n         Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n         Assert.assertEquals( 0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n     @Test\n     public void testQuinticMinStatistics() {\n         // The function has local minima at -0.27195613 and 0.82221643.\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14);\n \n         final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];\n     public void testQuinticMax() {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has a local maximum at 0.27195613.\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);\n         Assert.assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n         try {\n \n     @Test\n     public void testMinEndpoints() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14);\n \n         // endpoint is minimum\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n \n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.random.JDKRandomGenerator;\n \n     @Test\n     public void testSinMin() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(44428400075l);\n-        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n-            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 10, g);\n+        MultiStartUnivariateRealOptimizer<UnivariateFunction> optimizer =\n+            new MultiStartUnivariateRealOptimizer<UnivariateFunction>(underlying, 10, g);\n         optimizer.optimize(300, f, GoalType.MINIMIZE, -100.0, 100.0);\n         UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n         for (int i = 1; i < optima.length; ++i) {\n     public void testQuinticMin() {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n-        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateFunction f = new QuinticFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(4312000053L);\n-        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n-            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);\n+        MultiStartUnivariateRealOptimizer<UnivariateFunction> optimizer =\n+            new MultiStartUnivariateRealOptimizer<UnivariateFunction>(underlying, 5, g);\n \n         UnivariateRealPointValuePair optimum\n             = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n \n     @Test\n     public void testBadFunction() {\n-        UnivariateRealFunction f = new UnivariateRealFunction() {\n+        UnivariateFunction f = new UnivariateFunction() {\n                 public double value(double x) {\n                     if (x < 0) {\n                         throw new LocalException();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(4312000053L);\n-        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n-            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);\n+        MultiStartUnivariateRealOptimizer<UnivariateFunction> optimizer =\n+            new MultiStartUnivariateRealOptimizer<UnivariateFunction>(underlying, 5, g);\n  \n         try {\n             optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         FastCosineTransformer transformer = new FastCosineTransformer();\n         double min, max, result[], tolerance = 1E-12; int N = 9;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         FastCosineTransformer transformer = new FastCosineTransformer();\n \n         try {\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         Complex result[]; int N = 1 << 8;\n         double min, max, tolerance = 1E-12;\n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         FastFourierTransformer transformer = new FastFourierTransformer();\n \n         try {\n--- a/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n      */\n     @Test\n     public void testSinFunction() {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         FastSineTransformer transformer = new FastSineTransformer();\n         double min, max, result[], tolerance = 1E-12; int N = 1 << 8;\n \n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n+        UnivariateFunction f = new SinFunction();\n         FastSineTransformer transformer = new FastSineTransformer();\n \n         try {", "timestamp": 1322432310, "metainfo": ""}