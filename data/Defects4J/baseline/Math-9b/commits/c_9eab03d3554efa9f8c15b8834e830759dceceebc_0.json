{"sha": "9eab03d3554efa9f8c15b8834e830759dceceebc", "log": "Javadoc cleanup of transform package, removed unnecessary paragraph tags.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/transform/DctNormalization.java\n+++ b/src/main/java/org/apache/commons/math3/transform/DctNormalization.java\n  */\n public enum DctNormalization {\n     /**\n-     * <p>\n      * Should be passed to the constructor of {@link FastCosineTransformer}\n      * to use the <em>standard</em> normalization convention.  The standard\n      * DCT-I normalization convention is defined as follows\n      * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n      * </ul>\n      * where N is the size of the data sample.\n-     * </p>\n      */\n     STANDARD_DCT_I,\n \n     /**\n-     * <p>\n      * Should be passed to the constructor of {@link FastCosineTransformer}\n      * to use the <em>orthogonal</em> normalization convention. The orthogonal\n      * DCT-I normalization convention is defined as follows\n--- a/src/main/java/org/apache/commons/math3/transform/DftNormalization.java\n+++ b/src/main/java/org/apache/commons/math3/transform/DftNormalization.java\n  */\n public enum DftNormalization {\n     /**\n-     * <p>\n      * Should be passed to the constructor of {@link FastFourierTransformer}\n      * to use the <em>standard</em> normalization convention. This normalization\n      * convention is defined as follows\n      * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n      * </ul>\n      * where N is the size of the data sample.\n-     * </p>\n      */\n     STANDARD,\n \n     /**\n-     * <p>\n      * Should be passed to the constructor of {@link FastFourierTransformer}\n      * to use the <em>unitary</em> normalization convention. This normalization\n      * convention is defined as follows\n      * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n      * </ul>\n      * which makes the transform unitary. N is the size of the data sample.\n-     * </p>\n      */\n     UNITARY;\n }\n--- a/src/main/java/org/apache/commons/math3/transform/DstNormalization.java\n+++ b/src/main/java/org/apache/commons/math3/transform/DstNormalization.java\n  */\n public enum DstNormalization {\n     /**\n-     * <p>\n      * Should be passed to the constructor of {@link FastSineTransformer} to\n      * use the <em>standard</em> normalization convention. The standard DST-I\n      * normalization convention is defined as follows\n      * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n      * </ul>\n      * where N is the size of the data sample, and x<sub>0</sub> = 0.\n-     * </p>\n      */\n     STANDARD_DST_I,\n \n     /**\n-     * <p>\n      * Should be passed to the constructor of {@link FastSineTransformer} to\n      * use the <em>orthogonal</em> normalization convention. The orthogonal\n      * DCT-I normalization convention is defined as follows\n      * </ul>\n      * which makes the transform orthogonal. N is the size of the data sample,\n      * and x<sub>0</sub> = 0.\n-     * </p>\n      */\n     ORTHOGONAL_DST_I\n }\n--- a/src/main/java/org/apache/commons/math3/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/FastCosineTransformer.java\n import org.apache.commons.math3.util.FastMath;\n \n /**\n- * <p>\n  * Implements the Fast Cosine Transform for transformation of one-dimensional\n  * real data sets. For reference, see James S. Walker, <em>Fast Fourier\n  * Transforms</em>, chapter 3 (ISBN 0849371635).\n- * </p>\n  * <p>\n  * There are several variants of the discrete cosine transform. The present\n  * implementation corresponds to DCT-I, with various normalization conventions,\n  * which are specified by the parameter {@link DctNormalization}.\n- * </p>\n  * <p>\n  * DCT-I is equivalent to DFT of an <em>even extension</em> of the data series.\n  * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set\n  * <li>x<sub>k</sub><sup>&#35;</sup> = x<sub>2N-2-k</sub>\n  * if N &le; k &lt; 2N - 2.</li>\n  * </ul>\n- * </p>\n  * <p>\n  * Then, the standard DCT-I y<sub>0</sub>, &hellip;, y<sub>N-1</sub> of the real\n  * data set x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is equal to <em>half</em>\n  * y<sub>n</sub> = (1 / 2) &sum;<sub>k=0</sub><sup>2N-3</sup>\n  * x<sub>k</sub><sup>&#35;</sup> exp[-2&pi;i nk / (2N - 2)]\n  * &nbsp;&nbsp;&nbsp;&nbsp;k = 0, &hellip;, N-1.\n- * </p>\n  * <p>\n  * The present implementation of the discrete cosine transform as a fast cosine\n  * transform requires the length of the data set to be a power of two plus one\n  * (N&nbsp;=&nbsp;2<sup>n</sup>&nbsp;+&nbsp;1). Besides, it implicitly assumes\n  * that the sampled function is even.\n- * </p>\n  *\n  * @version $Id$\n  * @since 1.2\n--- a/src/main/java/org/apache/commons/math3/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/FastFourierTransformer.java\n import org.apache.commons.math3.util.MathArrays;\n \n /**\n- * <p>\n  * Implements the Fast Fourier Transform for transformation of one-dimensional\n  * real or complex data sets. For reference, see <em>Applied Numerical Linear\n  * Algebra</em>, ISBN 0898713897, chapter 6.\n- * </p>\n  * <p>\n  * There are several variants of the discrete Fourier transform, with various\n  * normalization conventions, which are specified by the parameter\n  * {@link DftNormalization}.\n- * </p>\n  * <p>\n  * The current implementation of the discrete Fourier transform as a fast\n  * Fourier transform requires the length of the data set to be a power of 2.\n  * reference, see S. Winograd,\n  * <i>On computing the discrete Fourier transform</i>, Mathematics of\n  * Computation, 32 (1978), 175 - 199.\n- * </p>\n  *\n  * @see DftNormalization\n  * @version $Id$\n      *\n      * @param dataRI the unscaled transformed data\n      * @param normalization the normalization to be applied\n-     * @param type the type of transform (forward, inverse) which resulted in the\n-     * specified data\n+     * @param type the type of transform (forward, inverse) which resulted in the specified data\n      */\n     private static void normalizeTransformedData(final double[][] dataRI,\n         final DftNormalization normalization, final TransformType type) {\n      * Computes the standard transform of the specified complex data. The\n      * computation is done in place. The input data is laid out as follows\n      * <ul>\n-     * <li>{@code dataRI[0][i]} is the real part of the {@code i}-th data point,\n-     * </li>\n-     * <li>{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data\n-     * point.</li>\n+     *   <li>{@code dataRI[0][i]} is the real part of the {@code i}-th data point,</li>\n+     *   <li>{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data point.</li>\n      * </ul>\n      *\n-     * @param dataRI the two dimensional array of real and imaginary parts of\n-     * the data\n-     * @param normalization the normalization to be applied to the transformed\n-     * data\n+     * @param dataRI the two dimensional array of real and imaginary parts of the data\n+     * @param normalization the normalization to be applied to the transformed data\n      * @param type the type of transform (forward, inverse) to be performed\n      * @throws DimensionMismatchException if the number of rows of the specified\n-     * array is not two, or the array is not rectangular\n+     *   array is not two, or the array is not rectangular\n      * @throws MathIllegalArgumentException if the number of data points is not\n-     * a power of two\n+     *   a power of two\n      */\n     public static void transformInPlace(final double[][] dataRI,\n         final DftNormalization normalization, final TransformType type) {\n      * @param f the real data array to be transformed\n      * @param type the type of transform (forward, inverse) to be performed\n      * @return the complex transformed array\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n+     * @throws MathIllegalArgumentException if the length of the data array is not a power of two\n      */\n     public Complex[] transform(final double[] f, final TransformType type) {\n         final double[][] dataRI = new double[][] {\n      * @param type the type of transform (forward, inverse) to be performed\n      * @return the complex transformed array\n      * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if the lower bound is greater than, or equal to the upper bound\n+     *   if the lower bound is greater than, or equal to the upper bound\n      * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if the number of sample points {@code n} is negative\n+     *   if the number of sample points {@code n} is negative\n      * @throws MathIllegalArgumentException if the number of sample points\n-     * {@code n} is not a power of two\n+     *   {@code n} is not a power of two\n      */\n     public Complex[] transform(final UnivariateFunction f,\n-            final double min, final double max, final int n,\n-            final TransformType type) {\n+                               final double min, final double max, final int n,\n+                               final TransformType type) {\n \n         final double[] data = FunctionUtils.sample(f, min, max, n);\n         return transform(data, type);\n     }\n \n     /**\n-     * Returns the (forward, inverse) transform of the specified complex data\n-     * set.\n+     * Returns the (forward, inverse) transform of the specified complex data set.\n      *\n      * @param f the complex data array to be transformed\n      * @param type the type of transform (forward, inverse) to be performed\n      * @return the complex transformed array\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n+     * @throws MathIllegalArgumentException if the length of the data array is not a power of two\n      */\n     public Complex[] transform(final Complex[] f, final TransformType type) {\n         final double[][] dataRI = TransformUtils.createRealImaginaryArray(f);\n      * &times; n<sub>d</sub>, where n<sub>k</sub> is the number of elements in\n      * dimension k, and d is the total number of dimensions.\n      *\n-     * @param mdca Multi-Dimensional Complex Array id est\n-     * {@code Complex[][][][]}\n+     * @param mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}\n      * @param type the type of transform (forward, inverse) to be performed\n-     * @return transform of {@code mdca} as a Multi-Dimensional Complex Array\n-     * id est {@code Complex[][][][]}\n+     * @return transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}\n      * @throws IllegalArgumentException if any dimension is not a power of two\n      * @deprecated see MATH-736\n      */\n--- a/src/main/java/org/apache/commons/math3/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/FastHadamardTransformer.java\n /**\n  * Implements the <a href=\"http://www.archive.chipcenter.com/dsp/DSP000517F1.html\">Fast Hadamard Transform</a> (FHT).\n  * Transformation of an input vector x to the output vector y.\n- * <p>In addition to transformation of real vectors, the Hadamard transform can\n+ * <p>\n+ * In addition to transformation of real vectors, the Hadamard transform can\n  * transform integer vectors into integer vectors. However, this integer transform\n  * cannot be inverted directly. Due to a scaling factor it may lead to rational results.\n  * As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational\n- * vector (1/2, -1/2, 0, 0).</p>\n+ * vector (1/2, -1/2, 0, 0).\n+ *\n  * @version $Id$\n  * @since 2.0\n  */\n      * {@inheritDoc}\n      *\n      * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n-     * if the lower bound is greater than, or equal to the upper bound\n+     *   if the lower bound is greater than, or equal to the upper bound\n      * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if the number of sample points is negative\n-     * @throws MathIllegalArgumentException if the number of sample points is\n-     * not a power of two\n+     *   if the number of sample points is negative\n+     * @throws MathIllegalArgumentException if the number of sample points is not a power of two\n      */\n     public double[] transform(final UnivariateFunction f,\n         final double min, final double max, final int n,\n      *\n      * @param f the integer data array to be transformed (signal)\n      * @return the integer transformed array (spectrum)\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n+     * @throws MathIllegalArgumentException if the length of the data array is not a power of two\n      */\n     public int[] transform(final int[] f) {\n         return fht(f);\n      *\n      * @param x the real data array to be transformed\n      * @return the real transformed array, {@code y}\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n+     * @throws MathIllegalArgumentException if the length of the data array is not a power of two\n      */\n     protected double[] fht(double[] x) throws MathIllegalArgumentException {\n \n      *\n      * @param x the integer data array to be transformed\n      * @return the integer transformed array, {@code y}\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n+     * @throws MathIllegalArgumentException if the length of the data array is not a power of two\n      */\n     protected int[] fht(int[] x) throws MathIllegalArgumentException {\n \n--- a/src/main/java/org/apache/commons/math3/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/FastSineTransformer.java\n import org.apache.commons.math3.util.FastMath;\n \n /**\n- * <p>\n  * Implements the Fast Sine Transform for transformation of one-dimensional real\n  * data sets. For reference, see James S. Walker, <em>Fast Fourier\n  * Transforms</em>, chapter 3 (ISBN 0849371635).\n- * </p>\n  * <p>\n  * There are several variants of the discrete sine transform. The present\n  * implementation corresponds to DST-I, with various normalization conventions,\n  * which are specified by the parameter {@link DstNormalization}.\n  * <strong>It should be noted that regardless to the convention, the first\n  * element of the dataset to be transformed must be zero.</strong>\n- * </p>\n  * <p>\n  * DST-I is equivalent to DFT of an <em>odd extension</em> of the data series.\n  * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set\n  * <li>x<sub>k</sub><sup>&#35;</sup> = -x<sub>2N-k</sub> if N + 1 &le; k &lt;\n  * 2N.</li>\n  * </ul>\n- * </p>\n  * <p>\n  * Then, the standard DST-I y<sub>0</sub>, &hellip;, y<sub>N-1</sub> of the real\n  * data set x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is equal to <em>half</em>\n  * y<sub>n</sub> = (i / 2) &sum;<sub>k=0</sub><sup>2N-1</sup>\n  * x<sub>k</sub><sup>&#35;</sup> exp[-2&pi;i nk / (2N)]\n  * &nbsp;&nbsp;&nbsp;&nbsp;k = 0, &hellip;, N-1.\n- * </p>\n  * <p>\n  * The present implementation of the discrete sine transform as a fast sine\n  * transform requires the length of the data to be a power of two. Besides,\n  * first element of the data set must be 0, which is enforced in\n  * {@link #transform(UnivariateFunction, double, double, int, TransformType)},\n  * after sampling.\n- * </p>\n  *\n  * @version $Id$\n  * @since 1.2\n     private final DstNormalization normalization;\n \n     /**\n-     * Creates a new instance of this class, with various normalization\n-     * conventions.\n+     * Creates a new instance of this class, with various normalization conventions.\n      *\n-     * @param normalization the type of normalization to be applied to the\n-     * transformed data\n+     * @param normalization the type of normalization to be applied to the transformed data\n      */\n     public FastSineTransformer(final DstNormalization normalization) {\n         this.normalization = normalization;\n      * The first element of the specified data set is required to be {@code 0}.\n      *\n      * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two, or the first element of the data array is not zero\n+     *   not a power of two, or the first element of the data array is not zero\n      */\n     public double[] transform(final double[] f, final TransformType type) {\n         if (normalization == DstNormalization.ORTHOGONAL_DST_I) {\n      * This implementation enforces {@code f(x) = 0.0} at {@code x = 0.0}.\n      *\n      * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n-     * if the lower bound is greater than, or equal to the upper bound\n+     *   if the lower bound is greater than, or equal to the upper bound\n      * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if the number of sample points is negative\n-     * @throws MathIllegalArgumentException if the number of sample points is\n-     * not a power of two\n+     *   if the number of sample points is negative\n+     * @throws MathIllegalArgumentException if the number of sample points is not a power of two\n      */\n     public double[] transform(final UnivariateFunction f,\n         final double min, final double max, final int n,\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n      * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two, or the first element of the data array is not zero\n+     *   not a power of two, or the first element of the data array is not zero\n      */\n     protected double[] fst(double[] f) throws MathIllegalArgumentException {\n \n--- a/src/main/java/org/apache/commons/math3/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/RealTransformer.java\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n \n /**\n- * <p>Interface for one-dimensional data sets transformations producing real\n- * results.</p>\n- * <p>Such transforms include {@link FastSineTransformer sine transform},\n+ * Interface for one-dimensional data sets transformations producing real results.\n+ * <p>\n+ * Such transforms include {@link FastSineTransformer sine transform},\n  * {@link FastCosineTransformer cosine transform} or {@link\n  * FastHadamardTransformer Hadamard transform}. {@link FastFourierTransformer\n  * Fourier transform} is of a different kind and does not implement this\n  * interface since it produces {@link org.apache.commons.math3.complex.Complex}\n- * results instead of real ones.</p>\n+ * results instead of real ones.\n  *\n  * @version $Id$\n  * @since 2.0\n      * @param type the type of transform (forward, inverse) to be performed\n      * @return the real transformed array (spectrum)\n      * @throws MathIllegalArgumentException if the array cannot be transformed\n-     * with the given type (this may be for example due to array size, which is\n-     * constrained in some transforms)\n+     *   with the given type (this may be for example due to array size, which is\n+     *   constrained in some transforms)\n      */\n     double[] transform(double[] f, TransformType type) throws MathIllegalArgumentException;\n \n      * @param n the number of sample points\n      * @param type the type of transform (forward, inverse) to be performed\n      * @return the real transformed array\n-     * @throws NonMonotonicSequenceException if the lower bound is greater than,\n-     * or equal to the upper bound\n+     * @throws NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound\n      * @throws NotStrictlyPositiveException if the number of sample points is negative\n      * @throws MathIllegalArgumentException if the sample cannot be transformed\n-     * with the given type (this may be for example due to sample size, which is\n-     * constrained in some transforms)\n+     *   with the given type (this may be for example due to sample size, which is\n+     *   constrained in some transforms)\n      */\n     double[] transform(UnivariateFunction f, double min, double max, int n,\n                        TransformType type)\n--- a/src/main/java/org/apache/commons/math3/transform/TransformUtils.java\n+++ b/src/main/java/org/apache/commons/math3/transform/TransformUtils.java\n      *\n      * @param dataC the array of {@link Complex} data to be transformed\n      * @return a two dimensional array filled with the real and imaginary parts\n-     * of the specified complex input\n+     *   of the specified complex input\n      */\n     public static double[][] createRealImaginaryArray(final Complex[] dataC) {\n         final double[][] dataRI = new double[2][dataC.length];\n      * </ul>\n      *\n      * @param dataRI the array of real and imaginary parts to be transformed\n-     * @return an array of {@link Complex} with specified real and imaginary\n-     * parts.\n+     * @return an array of {@link Complex} with specified real and imaginary parts.\n      * @throws DimensionMismatchException if the number of rows of the specified\n-     * array is not two, or the array is not rectangular\n+     *   array is not two, or the array is not rectangular\n      */\n     public static Complex[] createComplexArray(final double[][] dataRI)\n         throws DimensionMismatchException{", "timestamp": 1347813130, "metainfo": ""}