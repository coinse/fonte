{"sha": "e3366a9d3a539fd2c3003f64416edbe1c5d60473", "log": "Completed reversion of r1164756 changes (for now).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n     private final transient boolean isNaN;\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n-    /** Record whether this complex number is zero. */\n-    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n-        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n      *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n      *   in either part, {@link #NaN} is returned.\n      *  </li>\n-     *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\n-     *   {@link #NaN} is returned.\n-     *  </li>\n-     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\n+     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n      *  </li>\n      *  <li>If {@code this} and {@code divisor} are both infinite,\n      *   {@link #NaN} is returned.\n             return NaN;\n         }\n \n-        if (divisor.isZero) {\n-            // return isZero ? NaN : INF; // See MATH-657\n+        final double c = divisor.getReal();\n+        final double d = divisor.getImaginary();\n+        if (c == 0.0 && d == 0.0) {\n             return NaN;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n-\n-        final double c = divisor.getReal();\n-        final double d = divisor.getImaginary();\n \n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            // return isZero ? NaN : INF; // See MATH-657\n             return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n     public void testDivideZero() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.divide(Complex.ZERO);\n-        // Assert.assertEquals(z, Complex.INF); // See MATH-657\n-        Assert.assertEquals(z, Complex.NaN);\n-    }\n-\n-    @Test\n-    public void testDivideZeroZero() {\n-        Complex x = new Complex(0.0, 0.0);\n-        Complex z = x.divide(Complex.ZERO);\n         Assert.assertEquals(z, Complex.NaN);\n     }\n \n \n     @Test\n     public void testScalarMultiplyInf() {\n-        Complex x = new Complex(1, 1);\n+        Complex x = new Complex(1,1);\n         double yDouble = Double.POSITIVE_INFINITY;\n         Complex yComplex = new Complex(yDouble);\n         Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n         \n         yDouble = Double.NEGATIVE_INFINITY;\n-        yComplex = new Complex(yDouble);\n+         yComplex = new Complex(yDouble);\n         Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n     }\n \n     }\n \n     @Test\n-    public void testAtanI() {\n-        Assert.assertTrue(Complex.I.atan().isNaN());\n-    }\n-\n-    @Test\n     public void testAtanNaN() {\n         Assert.assertTrue(Complex.NaN.atan().isNaN());\n+        Assert.assertTrue(Complex.I.atan().isNaN());\n     }\n \n     @Test", "timestamp": 1315080384, "metainfo": ""}