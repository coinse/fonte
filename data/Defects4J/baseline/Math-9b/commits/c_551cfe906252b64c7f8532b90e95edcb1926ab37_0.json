{"sha": "551cfe906252b64c7f8532b90e95edcb1926ab37", "log": "added a step interpolator for multistep methods in Nordsieck form  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.nonstiff.AdamsIntegrator;\n+\n+/**\n+ * This class implements an interpolator for integrators using Nordsieck representation.\n+ *\n+ * <p>This interpolator computes dense output around the current point.\n+ * The interpolation equation is based on Taylor series formulas.\n+ *\n+ * @see AdamsIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public class NordsieckStepInterpolator extends AbstractStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7179861704951334960L;\n+\n+    /** Step size used in the first scaled derivative and Nordsieck vector. */\n+    private double scalingH;\n+\n+    /** First scaled derivative. */\n+    private double[] scaled;\n+\n+    /** Nordsieck vector. */\n+    private RealMatrix nordsieck;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link AbstractStepInterpolator#reinitialize} method should be called\n+     * before using the instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases.\n+     */\n+    public NordsieckStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public NordsieckStepInterpolator(final NordsieckStepInterpolator interpolator) {\n+        super(interpolator);\n+        scalingH = interpolator.scalingH;\n+        if (interpolator.scaled != null) {\n+            scaled = interpolator.scaled.clone();\n+        }\n+        if (interpolator.nordsieck != null) {\n+            nordsieck = interpolator.nordsieck.copy();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected StepInterpolator doCopy() {\n+        return new NordsieckStepInterpolator(this);\n+    }\n+\n+    /** Reinitialize the instance\n+     * <p>Beware that all arrays <em>must</em> be references to integrator\n+     * arrays, in order to ensure proper update without copy.</p>\n+     * @param y reference to the integrator array holding the state at\n+     * the end of the step\n+     * @param forward integration direction indicator\n+     */\n+    @Override\n+    public void reinitialize(final double[] y, final boolean forward) {\n+        super.reinitialize(y, forward);\n+    }\n+\n+    /** Reinitialize the instance\n+     * <p>Beware that all arrays <em>must</em> be references to integrator\n+     * arrays, in order to ensure proper update without copy.</p>\n+     * @param scalingH step size used in the scaled and nordsieck arrays\n+     * @param scaled reference to the integrator array holding the first\n+     * scaled derivative\n+     * @param nordsieck reference to the integrator matrix holding the\n+     * nordsieck vector\n+     */\n+    public void reinitialize(final double scalingH, final double[] scaled,\n+                             final RealMatrix nordsieck) {\n+        this.scalingH  = scalingH;\n+        this.scaled    = scaled;\n+        this.nordsieck = nordsieck;\n+    }\n+\n+    /** Store the current step time.\n+     * @param t current time\n+     */\n+    @Override\n+    public void storeTime(final double t) {\n+      currentTime      = t;\n+      h                = currentTime - previousTime;\n+      interpolatedTime = t;\n+      computeInterpolatedState(1.0, 0.0);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n+        final double x = theta * h;\n+        nordsieck.walkInOptimizedOrder(new StateEstimator(x, x / scalingH));\n+    }\n+\n+    /** State estimator. */\n+    private class StateEstimator implements RealMatrixPreservingVisitor {\n+\n+        /** Scaling factor for derivative. */\n+        private final double scale;\n+\n+        /** First order power. */\n+        private final double lowPower;\n+\n+        /** High order powers. */\n+        private final double[] highPowers;\n+\n+        /** Simple constructor.\n+         * @param scale scaling factor for derivative\n+         * @param theta normalized interpolation abscissa within the step\n+         */\n+        public StateEstimator(final double scale, final double theta) {\n+            this.scale  = scale;\n+            lowPower   = theta;\n+            highPowers = new double[nordsieck.getRowDimension()];\n+            double thetaN = theta;\n+            for (int i = 0; i < highPowers.length; ++i) {\n+                thetaN *= theta;\n+                highPowers[i] = thetaN;\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            Arrays.fill(interpolatedState, 0.0);\n+            Arrays.fill(interpolatedDerivatives, 0.0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visit(int row, int column, double value) {\n+            final double d = value * highPowers[row];\n+            interpolatedState[column]       += d;\n+            interpolatedDerivatives[column] += (row + 2) * d;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double end() {\n+            for (int j = 0; j < currentState.length; ++j) {\n+                interpolatedState[j] += currentState[j] + scaled[j] * lowPower;\n+                interpolatedDerivatives[j] =\n+                    (interpolatedDerivatives[j] + scaled[j] * lowPower) / scale;\n+            }\n+            return 0;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void writeExternal(final ObjectOutput out)\n+        throws IOException {\n+\n+        // save the state of the base class\n+        writeBaseExternal(out);\n+\n+        // save the local attributes\n+        final int n = (currentState == null) ? -1 : currentState.length;\n+        if (scaled == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            for (int j = 0; j < n; ++j) {\n+                out.writeDouble(scaled[j]);\n+            }\n+        }\n+\n+        if (nordsieck == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            final int rows = nordsieck.getRowDimension();\n+            out.writeInt(rows);\n+            for (int i = 0; i < rows; ++i) {\n+                for (int j = 0; j < n; ++j) {\n+                    out.writeDouble(nordsieck.getEntry(i, j));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void readExternal(final ObjectInput in)\n+        throws IOException {\n+\n+        // read the base class \n+        final double t = readBaseExternal(in);\n+\n+        // read the local attributes\n+        final int n = (currentState == null) ? -1 : currentState.length;\n+        final boolean hasScaled = in.readBoolean();\n+        if (hasScaled) {\n+            scaled = new double[n];\n+            for (int j = 0; j < n; ++j) {\n+                scaled[j] = in.readDouble();\n+            }\n+        } else {\n+            scaled = null;\n+        }\n+\n+        final boolean hasNordsieck = in.readBoolean();\n+        if (hasNordsieck) {\n+            final int rows = in.readInt();\n+            final double[][] nData = new double[rows][n];\n+            for (int i = 0; i < rows; ++i) {\n+                final double[] nI = nData[i];\n+                for (int j = 0; j < n; ++j) {\n+                    nI[j] = in.readDouble();\n+                }\n+            }\n+            nordsieck = new RealMatrixImpl(nData, false);\n+        } else {\n+            nordsieck = null;\n+        }\n+\n+        try {\n+            if (hasScaled && hasNordsieck) {\n+                // we can now set the interpolated time and state\n+                setInterpolatedTime(t);\n+            }\n+        } catch (DerivativeException e) {\n+            throw MathRuntimeException.createIOException(e);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.AdamsIntegrator;\n+import org.apache.commons.math.ode.nonstiff.TestProblem1;\n+import org.apache.commons.math.ode.nonstiff.TestProblem3;\n+import org.junit.Test;\n+\n+public class NordsieckStepInterpolatorTest {\n+\n+    @Test\n+    public void derivativesConsistency()\n+    throws DerivativeException, IntegratorException {\n+        TestProblem3 pb = new TestProblem3();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+        AdamsIntegrator integ = new AdamsIntegrator(5, false, step);\n+        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+    }\n+\n+    @Test\n+    public void serialization()\n+    throws DerivativeException, IntegratorException,\n+    IOException, ClassNotFoundException {\n+\n+        TestProblem1 pb = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+        AdamsIntegrator integ = new AdamsIntegrator(5, false, step);\n+        integ.addStepHandler(new ContinuousOutputModel());\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+        for (StepHandler handler : integ.getStepHandlers()) {\n+            oos.writeObject(handler);\n+        }\n+\n+        assertTrue(bos.size () > 148000);\n+        assertTrue(bos.size () < 149000);\n+\n+        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+        ObjectInputStream     ois = new ObjectInputStream(bis);\n+        ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+        Random random = new Random(347588535632l);\n+        double maxError = 0.0;\n+        for (int i = 0; i < 1000; ++i) {\n+            double r = random.nextDouble();\n+            double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+            cm.setInterpolatedTime(time);\n+            double[] interpolatedY = cm.getInterpolatedState ();\n+            double[] theoreticalY  = pb.computeTheoreticalState(time);\n+            double dx = interpolatedY[0] - theoreticalY[0];\n+            double dy = interpolatedY[1] - theoreticalY[1];\n+            double error = dx * dx + dy * dy;\n+            if (error > maxError) {\n+                maxError = error;\n+            }\n+        }\n+\n+        assertTrue(maxError < 1.0e-6);\n+\n+    }\n+\n+}", "timestamp": 1243807350, "metainfo": ""}