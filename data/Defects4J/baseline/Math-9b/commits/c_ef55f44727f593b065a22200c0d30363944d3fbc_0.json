{"sha": "ef55f44727f593b065a22200c0d30363944d3fbc", "log": "Added RandomDataGenerator to replace RandomDataImpl and deprecated RandomData interface and RandomDataImpl class. Deprecated nextInversionDeviate methods from RandomDataImpl class. Ensured that all nextXxx methods in RandomDataImpl/RandomDataGenerator use the configured RandomGenerator.  JIRA: MATH-850  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/random/RandomData.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomData.java\n \n /**\n  * Random data generation utilities.\n+ * @deprecated to be removed in 4.0.  Use {@link RandomDataGenerator} directly\n  * @version $Id$\n  */\n public interface RandomData {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.random;\n+\n+import java.io.Serializable;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.SecureRandom;\n+import java.util.Collection;\n+\n+import org.apache.commons.math3.distribution.BetaDistribution;\n+import org.apache.commons.math3.distribution.BinomialDistribution;\n+import org.apache.commons.math3.distribution.CauchyDistribution;\n+import org.apache.commons.math3.distribution.ChiSquaredDistribution;\n+import org.apache.commons.math3.distribution.ExponentialDistribution;\n+import org.apache.commons.math3.distribution.FDistribution;\n+import org.apache.commons.math3.distribution.GammaDistribution;\n+import org.apache.commons.math3.distribution.HypergeometricDistribution;\n+import org.apache.commons.math3.distribution.PascalDistribution;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.distribution.TDistribution;\n+import org.apache.commons.math3.distribution.WeibullDistribution;\n+import org.apache.commons.math3.distribution.ZipfDistribution;\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n+ * instance to generate non-secure data and a {@link java.security.SecureRandom}\n+ * instance to provide data for the <code>nextSecureXxx</code> methods. If no\n+ * <code>RandomGenerator</code> is provided in the constructor, the default is\n+ * to use a {@link Well19937c} generator. To plug in a different\n+ * implementation, either implement <code>RandomGenerator</code> directly or\n+ * extend {@link AbstractRandomGenerator}.\n+ * <p>\n+ * Supports reseeding the underlying pseudo-random number generator (PRNG). The\n+ * <code>SecurityProvider</code> and <code>Algorithm</code> used by the\n+ * <code>SecureRandom</code> instance can also be reset.\n+ * </p>\n+ * <p>\n+ * For details on the default PRNGs, see {@link java.util.Random} and\n+ * {@link java.security.SecureRandom}.\n+ * </p>\n+ * <p>\n+ * <strong>Usage Notes</strong>:\n+ * <ul>\n+ * <li>\n+ * Instance variables are used to maintain <code>RandomGenerator</code> and\n+ * <code>SecureRandom</code> instances used in data generation. Therefore, to\n+ * generate a random sequence of values or strings, you should use just\n+ * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n+ * <li>\n+ * The \"secure\" methods are *much* slower. These should be used only when a\n+ * cryptographically secure random sequence is required. A secure random\n+ * sequence is a sequence of pseudo-random values which, in addition to being\n+ * well-dispersed (so no subsequence of values is an any more likely than other\n+ * subsequence of the the same length), also has the additional property that\n+ * knowledge of values generated up to any point in the sequence does not make\n+ * it any easier to predict subsequent values.</li>\n+ * <li>\n+ * When a new <code>RandomDataImpl</code> is created, the underlying random\n+ * number generators are <strong>not</strong> initialized. If you do not\n+ * explicitly seed the default non-secure generator, it is seeded with the\n+ * current time in milliseconds plus the system identity hash code on first use.\n+ * The same holds for the secure generator. If you provide a <code>RandomGenerator</code>\n+ * to the constructor, however, this generator is not reseeded by the constructor\n+ * nor is it reseeded on first use.</li>\n+ * <li>\n+ * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate to the\n+ * corresponding methods on the underlying <code>RandomGenerator</code> and\n+ * <code>SecureRandom</code> instances. Therefore, <code>reSeed(long)</code>\n+ * fully resets the initial state of the non-secure random number generator (so\n+ * that reseeding with a specific value always results in the same subsequent\n+ * random sequence); whereas reSeedSecure(long) does <strong>not</strong>\n+ * reinitialize the secure random number generator (so secure sequences started\n+ * with calls to reseedSecure(long) won't be identical).</li>\n+ * <li>\n+ * This implementation is not synchronized. The underlying <code>RandomGenerator</code>\n+ * or <code>SecureRandom</code> instances are not protected by synchronization and\n+ * are not guaranteed to be thread-safe.  Therefore, if an instance of this class\n+ * is concurrently utilized by multiple threads, it is the responsibility of\n+ * client code to synchronize access to seeding and data generation methods.\n+ * </li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Id$\n+ */\n+public class RandomDataGenerator implements RandomData, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -626730818244969716L;\n+\n+    /** underlying random number generator */\n+    private RandomGenerator rand = null;\n+\n+    /** underlying secure random number generator */\n+    private SecureRandom secRand = null;\n+\n+    /**\n+     * Construct a RandomDataGenerator, using a default random generator as the source\n+     * of randomness.\n+     *\n+     * <p>The default generator is a {@link Well19937c} seeded\n+     * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n+     * The generator is initialized and seeded on first use.</p>\n+     */\n+    public RandomDataGenerator() {\n+    }\n+\n+    /**\n+     * Construct a RandomDataGenerator using the supplied {@link RandomGenerator} as\n+     * the source of (non-secure) random data.\n+     *\n+     * @param rand the source of (non-secure) random data\n+     * (may be null, resulting in the default generator)\n+     */\n+    public RandomDataGenerator(RandomGenerator rand) {\n+        this.rand = rand;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description:</strong> hex strings are generated using a\n+     * 2-step process.\n+     * <ol>\n+     * <li>{@code len / 2 + 1} binary bytes are generated using the underlying\n+     * Random</li>\n+     * <li>Each binary byte is translated into 2 hex digits</li>\n+     * </ol>\n+     * </p>\n+     *\n+     * @param len the desired string length.\n+     * @return the random string.\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}.\n+     */\n+    public String nextHexString(int len) {\n+        if (len <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n+        }\n+\n+        // Get a random number generator\n+        RandomGenerator ran = getRan();\n+\n+        // Initialize output buffer\n+        StringBuilder outBuffer = new StringBuilder();\n+\n+        // Get int(len/2)+1 random bytes\n+        byte[] randomBytes = new byte[(len / 2) + 1];\n+        ran.nextBytes(randomBytes);\n+\n+        // Convert each byte to 2 hex digits\n+        for (int i = 0; i < randomBytes.length; i++) {\n+            Integer c = Integer.valueOf(randomBytes[i]);\n+\n+            /*\n+             * Add 128 to byte value to make interval 0-255 before doing hex\n+             * conversion. This guarantees <= 2 hex digits from toHexString()\n+             * toHexString would otherwise add 2^32 to negative arguments.\n+             */\n+            String hex = Integer.toHexString(c.intValue() + 128);\n+\n+            // Make sure we add 2 hex digits for each byte\n+            if (hex.length() == 1) {\n+                hex = \"0\" + hex;\n+            }\n+            outBuffer.append(hex);\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int nextInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n+        }\n+        double r = getRan().nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int) FastMath.floor(scaled);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public long nextLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n+        }\n+        double r = getRan().nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description:</strong> hex strings are generated in\n+     * 40-byte segments using a 3-step process.\n+     * <ol>\n+     * <li>\n+     * 20 random bytes are generated using the underlying\n+     * <code>SecureRandom</code>.</li>\n+     * <li>\n+     * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n+     * <li>\n+     * Each byte of the binary digest is converted to 2 hex digits.</li>\n+     * </ol>\n+     * </p>\n+     */\n+    public String nextSecureHexString(int len) {\n+        if (len <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n+        }\n+\n+        // Get SecureRandom and setup Digest provider\n+        SecureRandom secRan = getSecRan();\n+        MessageDigest alg = null;\n+        try {\n+            alg = MessageDigest.getInstance(\"SHA-1\");\n+        } catch (NoSuchAlgorithmException ex) {\n+            // this should never happen\n+            throw new MathInternalError(ex);\n+        }\n+        alg.reset();\n+\n+        // Compute number of iterations required (40 bytes each)\n+        int numIter = (len / 40) + 1;\n+\n+        StringBuilder outBuffer = new StringBuilder();\n+        for (int iter = 1; iter < numIter + 1; iter++) {\n+            byte[] randomBytes = new byte[40];\n+            secRan.nextBytes(randomBytes);\n+            alg.update(randomBytes);\n+\n+            // Compute hash -- will create 20-byte binary hash\n+            byte[] hash = alg.digest();\n+\n+            // Loop over the hash, converting each byte to 2 hex digits\n+            for (int i = 0; i < hash.length; i++) {\n+                Integer c = Integer.valueOf(hash[i]);\n+\n+                /*\n+                 * Add 128 to byte value to make interval 0-255 This guarantees\n+                 * <= 2 hex digits from toHexString() toHexString would\n+                 * otherwise add 2^32 to negative arguments\n+                 */\n+                String hex = Integer.toHexString(c.intValue() + 128);\n+\n+                // Keep strings uniform length -- guarantees 40 bytes\n+                if (hex.length() == 1) {\n+                    hex = \"0\" + hex;\n+                }\n+                outBuffer.append(hex);\n+            }\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+\n+    /**  {@inheritDoc} */\n+    public int nextSecureInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n+        }\n+        SecureRandom sec = getSecRan();\n+        final double r = sec.nextDouble();\n+        final double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public long nextSecureLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n+        }\n+        SecureRandom sec = getSecRan();\n+        final double r = sec.nextDouble();\n+        final double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description</strong>:\n+     * <ul><li> For small means, uses simulation of a Poisson process\n+     * using Uniform deviates, as described\n+     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li>\n+     *\n+     * <li> For large means, uses the rejection algorithm described in <br/>\n+     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n+     */\n+    public long nextPoisson(double mean) {\n+        return new PoissonDistribution(getRan(), mean,\n+                PoissonDistribution.DEFAULT_EPSILON,\n+                PoissonDistribution.DEFAULT_MAX_ITERATIONS).sample();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double nextGaussian(double mu, double sigma) {\n+        if (sigma <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);\n+        }\n+        return sigma * getRan().nextGaussian() + mu;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>\n+     * <strong>Algorithm Description</strong>: Uses the Algorithm SA (Ahrens)\n+     * from p. 876 in:\n+     * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for\n+     * sampling from the exponential and normal distributions.\n+     * Communications of the ACM, 15, 873-882.\n+     * </p>\n+     */\n+    public double nextExponential(double mean) {\n+        return new ExponentialDistribution(getRan(), mean,\n+                ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * <p>Generates a random value from the\n+     * {@link org.apache.commons.math3.distribution.GammaDistribution Gamma Distribution}.</p>\n+     *\n+     * <p>This implementation uses the following algorithms: </p>\n+     *\n+     * <p>For 0 < shape < 1: <br/>\n+     * Ahrens, J. H. and Dieter, U., <i>Computer methods for\n+     * sampling from gamma, beta, Poisson and binomial distributions.</i>\n+     * Computing, 12, 223-246, 1974.</p>\n+     *\n+     * <p>For shape >= 1: <br/>\n+     * Marsaglia and Tsang, <i>A Simple Method for Generating\n+     * Gamma Variables.</i> ACM Transactions on Mathematical Software,\n+     * Volume 26 Issue 3, September, 2000.</p>\n+     *\n+     * @param shape the median of the Gamma distribution\n+     * @param scale the scale parameter of the Gamma distribution\n+     * @return random value sampled from the Gamma(shape, scale) distribution\n+     */\n+    public double nextGamma(double shape, double scale) {\n+        return new GammaDistribution(getRan(),shape, scale,\n+                GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link HypergeometricDistribution Hypergeometric Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param populationSize the population size of the Hypergeometric distribution\n+     * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution\n+     * @param sampleSize the sample size of the Hypergeometric distribution\n+     * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution\n+     */\n+    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {\n+        return new HypergeometricDistribution(getRan(),populationSize,\n+                numberOfSuccesses, sampleSize).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link PascalDistribution Pascal Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param r the number of successes of the Pascal distribution\n+     * @param p the probability of success of the Pascal distribution\n+     * @return random value sampled from the Pascal(r, p) distribution\n+     */\n+    public int nextPascal(int r, double p) {\n+        return new PascalDistribution(getRan(), r, p).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link TDistribution T Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param df the degrees of freedom of the T distribution\n+     * @return random value from the T(df) distribution\n+     */\n+    public double nextT(double df) {\n+        return new TDistribution(getRan(), df,\n+                TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link WeibullDistribution Weibull Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param shape the shape parameter of the Weibull distribution\n+     * @param scale the scale parameter of the Weibull distribution\n+     * @return random value sampled from the Weibull(shape, size) distribution\n+     */\n+    public double nextWeibull(double shape, double scale) {\n+        return new WeibullDistribution(getRan(), shape, scale,\n+                WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link ZipfDistribution Zipf Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param numberOfElements the number of elements of the ZipfDistribution\n+     * @param exponent the exponent of the ZipfDistribution\n+     * @return random value sampled from the Zipf(numberOfElements, exponent) distribution\n+     */\n+    public int nextZipf(int numberOfElements, double exponent) {\n+        return new ZipfDistribution(getRan(), numberOfElements, exponent).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link BetaDistribution Beta Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param alpha first distribution shape parameter\n+     * @param beta second distribution shape parameter\n+     * @return random value sampled from the beta(alpha, beta) distribution\n+     */\n+    public double nextBeta(double alpha, double beta) {\n+        return new BetaDistribution(getRan(), alpha, beta,\n+                BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link BinomialDistribution Binomial Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param numberOfTrials number of trials of the Binomial distribution\n+     * @param probabilityOfSuccess probability of success of the Binomial distribution\n+     * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution\n+     */\n+    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {\n+        return new BinomialDistribution(getRan(), numberOfTrials, probabilityOfSuccess).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param median the median of the Cauchy distribution\n+     * @param scale the scale parameter of the Cauchy distribution\n+     * @return random value sampled from the Cauchy(median, scale) distribution\n+     */\n+    public double nextCauchy(double median, double scale) {\n+        return new CauchyDistribution(getRan(), median, scale,\n+                CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param df the degrees of freedom of the ChiSquare distribution\n+     * @return random value sampled from the ChiSquare(df) distribution\n+     */\n+    public double nextChiSquare(double df) {\n+        return new ChiSquaredDistribution(getRan(), df,\n+                ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link FDistribution F Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(RealDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param numeratorDf the numerator degrees of freedom of the F distribution\n+     * @param denominatorDf the denominator degrees of freedom of the F distribution\n+     * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n+     */\n+    public double nextF(double numeratorDf, double denominatorDf) {\n+        return new FDistribution(getRan(), numeratorDf, denominatorDf,\n+                FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>\n+     * <strong>Algorithm Description</strong>: scales the output of\n+     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n+     * random double if Random.nextDouble() returns 0). This is necessary to\n+     * provide a symmetric output interval (both endpoints excluded).\n+     * </p>\n+     *\n+     * @throws MathIllegalArgumentException if one of the bounds is infinite or\n+     * {@code NaN} or either bound is infinite or NaN\n+     */\n+    public double nextUniform(double lower, double upper) {\n+        return nextUniform(lower, upper, false);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>\n+     * <strong>Algorithm Description</strong>: if the lower bound is excluded,\n+     * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,\n+     * will generate another random double if Random.nextDouble() returns 0).\n+     * This is necessary to provide a symmetric output interval (both\n+     * endpoints excluded).\n+     * </p>\n+     *\n+     * @throws MathIllegalArgumentException if one of the bounds is infinite or\n+     * {@code NaN}\n+     */\n+    public double nextUniform(double lower, double upper,\n+        boolean lowerInclusive) {\n+\n+        if (lower >= upper) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n+        }\n+\n+        if (Double.isInfinite(lower) || Double.isInfinite(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);\n+        }\n+\n+        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n+        }\n+\n+        final RandomGenerator generator = getRan();\n+\n+        // ensure nextDouble() isn't 0.0\n+        double u = generator.nextDouble();\n+        while (!lowerInclusive && u <= 0.0) {\n+            u = generator.nextDouble();\n+        }\n+\n+        return u * upper + (1.0 - u) * lower;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>\n+     * Uses a 2-cycle permutation shuffle. The shuffling process is described <a\n+     * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>.\n+     * </p>\n+     */\n+    public int[] nextPermutation(int n, int k) {\n+        if (k > n) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n+                                                k, n, true);\n+        }\n+        if (k <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n+                                                   k);\n+        }\n+\n+        int[] index = getNatural(n);\n+        shuffle(index, n - k);\n+        int[] result = new int[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = index[n - i - 1];\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>\n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n+     * shuffle to generate a random permutation of <code>c.size()</code> and\n+     * then returns the elements whose indexes correspond to the elements of the\n+     * generated permutation. This technique is described, and proven to\n+     * generate random samples <a\n+     * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>\n+     * </p>\n+     */\n+    public Object[] nextSample(Collection<?> c, int k) {\n+\n+        int len = c.size();\n+        if (k > len) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n+                                                k, len, true);\n+        }\n+        if (k <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n+        }\n+\n+        Object[] objects = c.toArray();\n+        int[] index = nextPermutation(len, k);\n+        Object[] result = new Object[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = objects[index[i]];\n+        }\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Reseeds the random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     *\n+     * @param seed the seed value to use\n+     */\n+    public void reSeed(long seed) {\n+       getRan().setSeed(seed);\n+    }\n+\n+    /**\n+     * Reseeds the secure random number generator with the current time in\n+     * milliseconds.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     */\n+    public void reSeedSecure() {\n+        getSecRan().setSeed(System.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Reseeds the secure random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     *\n+     * @param seed the seed value to use\n+     */\n+    public void reSeedSecure(long seed) {\n+        getSecRan().setSeed(seed);\n+    }\n+\n+    /**\n+     * Reseeds the random number generator with\n+     * {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n+     */\n+    public void reSeed() {\n+        getRan().setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n+    }\n+\n+    /**\n+     * Sets the PRNG algorithm for the underlying SecureRandom instance using\n+     * the Security Provider API. The Security Provider API is defined in <a\n+     * href =\n+     * \"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n+     * Java Cryptography Architecture API Specification & Reference.</a>\n+     * <p>\n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n+     * overhead and may take several seconds to execute.\n+     * </p>\n+     *\n+     * @param algorithm the name of the PRNG algorithm\n+     * @param provider the name of the provider\n+     * @throws NoSuchAlgorithmException if the specified algorithm is not available\n+     * @throws NoSuchProviderException if the specified provider is not installed\n+     */\n+    public void setSecureAlgorithm(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        secRand = SecureRandom.getInstance(algorithm, provider);\n+    }\n+\n+    /**\n+     * Returns the RandomGenerator used to generate non-secure random data.\n+     * <p>\n+     * Creates and initializes a default generator if null. Uses a {@link Well19937c}\n+     * generator with {@code System.currentTimeMillis() + System.identityHashCode(this))}\n+     * as the default seed.\n+     * </p>\n+     *\n+     * @return the Random used to generate random data\n+     */\n+    private RandomGenerator getRan() {\n+        if (rand == null) {\n+            initRan();\n+        }\n+        return rand;\n+    }\n+\n+    /**\n+     * Sets the default generator to a {@link Well19937c} generator seeded with\n+     * {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n+     */\n+    private void initRan() {\n+        rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this));\n+    }\n+\n+    /**\n+     * Returns the SecureRandom used to generate secure random data.\n+     * <p>\n+     * Creates and initializes if null.  Uses\n+     * {@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.\n+     * </p>\n+     *\n+     * @return the SecureRandom used to generate secure random data\n+     */\n+    private SecureRandom getSecRan() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+            secRand.setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n+        }\n+        return secRand;\n+    }\n+\n+    /**\n+     * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n+     * of list.\n+     *\n+     * @param list list to be shuffled\n+     * @param end element past which shuffling begins\n+     */\n+    private void shuffle(int[] list, int end) {\n+        int target = 0;\n+        for (int i = list.length - 1; i >= end; i--) {\n+            if (i == 0) {\n+                target = 0;\n+            } else {\n+                target = nextInt(0, i);\n+            }\n+            int temp = list[target];\n+            list[target] = list[i];\n+            list[i] = temp;\n+        }\n+    }\n+\n+    /**\n+     * Returns an array representing n.\n+     *\n+     * @param n the natural number to represent\n+     * @return array with entries = elements of n\n+     */\n+    private int[] getNatural(int n) {\n+        int[] natural = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            natural[i] = i;\n+        }\n+        return natural;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataImpl.java\n package org.apache.commons.math3.random;\n \n import java.io.Serializable;\n-import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n-import java.security.SecureRandom;\n import java.util.Collection;\n \n-import org.apache.commons.math3.distribution.BetaDistribution;\n-import org.apache.commons.math3.distribution.BinomialDistribution;\n-import org.apache.commons.math3.distribution.CauchyDistribution;\n-import org.apache.commons.math3.distribution.ChiSquaredDistribution;\n+import org.apache.commons.math3.distribution.IntegerDistribution;\n import org.apache.commons.math3.distribution.RealDistribution;\n-import org.apache.commons.math3.distribution.FDistribution;\n-import org.apache.commons.math3.distribution.HypergeometricDistribution;\n-import org.apache.commons.math3.distribution.IntegerDistribution;\n-import org.apache.commons.math3.distribution.PascalDistribution;\n-import org.apache.commons.math3.distribution.TDistribution;\n-import org.apache.commons.math3.distribution.WeibullDistribution;\n-import org.apache.commons.math3.distribution.ZipfDistribution;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n-import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math3.exception.NumberIsTooLargeException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.util.ArithmeticUtils;\n-import org.apache.commons.math3.util.FastMath;\n-import org.apache.commons.math3.util.ResizableDoubleArray;\n \n /**\n- * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n+ * Generates random deviates and other random data using a {@link RandomGenerator}\n  * instance to generate non-secure data and a {@link java.security.SecureRandom}\n  * instance to provide data for the <code>nextSecureXxx</code> methods. If no\n  * <code>RandomGenerator</code> is provided in the constructor, the default is\n  * Instance variables are used to maintain <code>RandomGenerator</code> and\n  * <code>SecureRandom</code> instances used in data generation. Therefore, to\n  * generate a random sequence of values or strings, you should use just\n- * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n+ * <strong>one</strong> <code>RandomDataGenerator</code> instance repeatedly.</li>\n  * <li>\n  * The \"secure\" methods are *much* slower. These should be used only when a\n  * cryptographically secure random sequence is required. A secure random\n  * knowledge of values generated up to any point in the sequence does not make\n  * it any easier to predict subsequent values.</li>\n  * <li>\n- * When a new <code>RandomDataImpl</code> is created, the underlying random\n+ * When a new <code>RandomDataGenerator</code> is created, the underlying random\n  * number generators are <strong>not</strong> initialized. If you do not\n  * explicitly seed the default non-secure generator, it is seeded with the\n  * current time in milliseconds plus the system identity hash code on first use.\n  * reinitialize the secure random number generator (so secure sequences started\n  * with calls to reseedSecure(long) won't be identical).</li>\n  * <li>\n- * This implementation is not synchronized.\n+ * This implementation is not synchronized. The underlying <code>RandomGenerator</code>\n+ * or <code>SecureRandom</code> instances are not protected by synchronization and\n+ * are not guaranteed to be thread-safe.  Therefore, if an instance of this class\n+ * is concurrently utilized by multiple threads, it is the responsibility of\n+ * client code to synchronize access to seeding and data generation methods.\n+ * </li>\n  * </ul>\n  * </p>\n  *\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -626730818244969716L;\n \n-    /**\n-     * Used when generating Exponential samples.\n-     * Table containing the constants\n-     * q_i = sum_{j=1}^i (ln 2)^j/j! = ln 2 + (ln 2)^2/2 + ... + (ln 2)^i/i!\n-     * until the largest representable fraction below 1 is exceeded.\n-     *\n-     * Note that\n-     * 1 = 2 - 1 = exp(ln 2) - 1 = sum_{n=1}^infty (ln 2)^n / n!\n-     * thus q_i -> 1 as i -> infty,\n-     * so the higher i, the closer to one we get (the series is not alternating).\n-     *\n-     * By trying, n = 16 in Java is enough to reach 1.0.\n-     */\n-    private static final double[] EXPONENTIAL_SA_QI;\n-\n-    /** underlying random number generator */\n-    private RandomGenerator rand = null;\n-\n-    /** underlying secure random number generator */\n-    private SecureRandom secRand = null;\n-\n-    /**\n-     * Initialize tables\n-     */\n-    static {\n-        /**\n-         * Filling EXPONENTIAL_SA_QI table.\n-         * Note that we don't want qi = 0 in the table.\n-         */\n-        final double LN2 = FastMath.log(2);\n-        double qi = 0;\n-        int i = 1;\n-\n-        /**\n-         * MathUtils provides factorials up to 20, so let's use that limit together\n-         * with Precision.EPSILON to generate the following code (a priori, we know that\n-         * there will be 16 elements, but instead of hardcoding that, this is\n-         * prettier):\n-         */\n-        final ResizableDoubleArray ra = new ResizableDoubleArray(20);\n-\n-        while (qi < 1) {\n-            qi += FastMath.pow(LN2, i) / ArithmeticUtils.factorial(i);\n-            ra.addElement(qi);\n-            ++i;\n-        }\n-\n-        EXPONENTIAL_SA_QI = ra.getElements();\n-    }\n+    /** RandomDataGenerator delegate */\n+    private RandomDataGenerator delegate;\n \n     /**\n      * Construct a RandomDataImpl, using a default random generator as the source\n      * The generator is initialized and seeded on first use.</p>\n      */\n     public RandomDataImpl() {\n+        delegate = new RandomDataGenerator();\n     }\n \n     /**\n      * @since 1.1\n      */\n     public RandomDataImpl(RandomGenerator rand) {\n-        super();\n-        this.rand = rand;\n+        delegate = new RandomDataGenerator(rand);\n     }\n \n     /**\n      * @throws NotStrictlyPositiveException if {@code len <= 0}.\n      */\n     public String nextHexString(int len) {\n-        if (len <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n-        }\n-\n-        // Get a random number generator\n-        RandomGenerator ran = getRan();\n-\n-        // Initialize output buffer\n-        StringBuilder outBuffer = new StringBuilder();\n-\n-        // Get int(len/2)+1 random bytes\n-        byte[] randomBytes = new byte[(len / 2) + 1];\n-        ran.nextBytes(randomBytes);\n-\n-        // Convert each byte to 2 hex digits\n-        for (int i = 0; i < randomBytes.length; i++) {\n-            Integer c = Integer.valueOf(randomBytes[i]);\n-\n-            /*\n-             * Add 128 to byte value to make interval 0-255 before doing hex\n-             * conversion. This guarantees <= 2 hex digits from toHexString()\n-             * toHexString would otherwise add 2^32 to negative arguments.\n-             */\n-            String hex = Integer.toHexString(c.intValue() + 128);\n-\n-            // Make sure we add 2 hex digits for each byte\n-            if (hex.length() == 1) {\n-                hex = \"0\" + hex;\n-            }\n-            outBuffer.append(hex);\n-        }\n-        return outBuffer.toString().substring(0, len);\n+        return delegate.nextHexString(len);\n     }\n \n     /** {@inheritDoc} */\n     public int nextInt(int lower, int upper) {\n-        if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n-        double r = getRan().nextDouble();\n-        double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (int) FastMath.floor(scaled);\n+       return delegate.nextInt(lower, upper);\n     }\n \n     /** {@inheritDoc} */\n     public long nextLong(long lower, long upper) {\n-        if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n-        double r = getRan().nextDouble();\n-        double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (long)FastMath.floor(scaled);\n+        return delegate.nextLong(lower, upper);\n     }\n \n     /**\n      * </p>\n      */\n     public String nextSecureHexString(int len) {\n-        if (len <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n-        }\n-\n-        // Get SecureRandom and setup Digest provider\n-        SecureRandom secRan = getSecRan();\n-        MessageDigest alg = null;\n-        try {\n-            alg = MessageDigest.getInstance(\"SHA-1\");\n-        } catch (NoSuchAlgorithmException ex) {\n-            // this should never happen\n-            throw new MathInternalError(ex);\n-        }\n-        alg.reset();\n-\n-        // Compute number of iterations required (40 bytes each)\n-        int numIter = (len / 40) + 1;\n-\n-        StringBuilder outBuffer = new StringBuilder();\n-        for (int iter = 1; iter < numIter + 1; iter++) {\n-            byte[] randomBytes = new byte[40];\n-            secRan.nextBytes(randomBytes);\n-            alg.update(randomBytes);\n-\n-            // Compute hash -- will create 20-byte binary hash\n-            byte[] hash = alg.digest();\n-\n-            // Loop over the hash, converting each byte to 2 hex digits\n-            for (int i = 0; i < hash.length; i++) {\n-                Integer c = Integer.valueOf(hash[i]);\n-\n-                /*\n-                 * Add 128 to byte value to make interval 0-255 This guarantees\n-                 * <= 2 hex digits from toHexString() toHexString would\n-                 * otherwise add 2^32 to negative arguments\n-                 */\n-                String hex = Integer.toHexString(c.intValue() + 128);\n-\n-                // Keep strings uniform length -- guarantees 40 bytes\n-                if (hex.length() == 1) {\n-                    hex = \"0\" + hex;\n-                }\n-                outBuffer.append(hex);\n-            }\n-        }\n-        return outBuffer.toString().substring(0, len);\n+        return delegate.nextSecureHexString(len);\n     }\n \n     /**  {@inheritDoc} */\n     public int nextSecureInt(int lower, int upper) {\n-        if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n-        SecureRandom sec = getSecRan();\n-        double r = sec.nextDouble();\n-        double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (int)FastMath.floor(scaled);\n+        return delegate.nextSecureInt(lower, upper);\n     }\n \n     /** {@inheritDoc} */\n     public long nextSecureLong(long lower, long upper) {\n-\n-        if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n-        SecureRandom sec = getSecRan();\n-        double r = sec.nextDouble();\n-        double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (long)FastMath.floor(scaled);\n+        return delegate.nextSecureLong(lower,upper);\n     }\n \n     /**\n      * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n      */\n     public long nextPoisson(double mean) {\n-        if (mean <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n-        }\n-\n-        final double pivot = 40.0d;\n-        if (mean < pivot) {\n-            final RandomGenerator generator = getRan();\n-            double p = FastMath.exp(-mean);\n-            long n = 0;\n-            double r = 1.0d;\n-            double rnd = 1.0d;\n-\n-            while (n < 1000 * mean) {\n-                rnd = generator.nextDouble();\n-                r = r * rnd;\n-                if (r >= p) {\n-                    n++;\n-                } else {\n-                    return n;\n-                }\n-            }\n-            return n;\n-        } else {\n-            final double lambda = FastMath.floor(mean);\n-            final double lambdaFractional = mean - lambda;\n-            final double logLambda = FastMath.log(lambda);\n-            final double logLambdaFactorial = ArithmeticUtils.factorialLog((int) lambda);\n-            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n-            final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));\n-            final double halfDelta = delta / 2;\n-            final double twolpd = 2 * lambda + delta;\n-            final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / 8 * lambda);\n-            final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd);\n-            final double aSum = a1 + a2 + 1;\n-            final double p1 = a1 / aSum;\n-            final double p2 = a2 / aSum;\n-            final double c1 = 1 / (8 * lambda);\n-\n-            double x = 0;\n-            double y = 0;\n-            double v = 0;\n-            int a = 0;\n-            double t = 0;\n-            double qr = 0;\n-            double qa = 0;\n-            for (;;) {\n-                final double u = nextUniform(0.0, 1);\n-                if (u <= p1) {\n-                    final double n = nextGaussian(0d, 1d);\n-                    x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d;\n-                    if (x > delta || x < -lambda) {\n-                        continue;\n-                    }\n-                    y = x < 0 ? FastMath.floor(x) : FastMath.ceil(x);\n-                    final double e = nextExponential(1d);\n-                    v = -e - (n * n / 2) + c1;\n-                } else {\n-                    if (u > p1 + p2) {\n-                        y = lambda;\n-                        break;\n-                    } else {\n-                        x = delta + (twolpd / delta) * nextExponential(1d);\n-                        y = FastMath.ceil(x);\n-                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;\n-                    }\n-                }\n-                a = x < 0 ? 1 : 0;\n-                t = y * (y + 1) / (2 * lambda);\n-                if (v < -t && a == 0) {\n-                    y = lambda + y;\n-                    break;\n-                }\n-                qr = t * ((2 * y + 1) / (6 * lambda) - 1);\n-                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));\n-                if (v < qa) {\n-                    y = lambda + y;\n-                    break;\n-                }\n-                if (v > qr) {\n-                    continue;\n-                }\n-                if (v < y * logLambda - ArithmeticUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n-                    y = lambda + y;\n-                    break;\n-                }\n-            }\n-            return y2 + (long) y;\n-        }\n+        return delegate.nextPoisson(mean);\n     }\n \n     /** {@inheritDoc} */\n     public double nextGaussian(double mu, double sigma) {\n-\n-        if (sigma <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);\n-        }\n-        return sigma * getRan().nextGaussian() + mu;\n+        return delegate.nextGaussian(mu,sigma);\n     }\n \n     /**\n      * </p>\n      */\n     public double nextExponential(double mean) {\n-\n-        if (mean <= 0.0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n-        }\n-\n-        // Step 1:\n-        double a = 0;\n-        double u = this.nextUniform(0, 1);\n-\n-        // Step 2 and 3:\n-        while (u < 0.5) {\n-            a += EXPONENTIAL_SA_QI[0];\n-            u *= 2;\n-        }\n-\n-        // Step 4 (now u >= 0.5):\n-        u += u - 1;\n-\n-        // Step 5:\n-        if (u <= EXPONENTIAL_SA_QI[0]) {\n-            return mean * (a + u);\n-        }\n-\n-        // Step 6:\n-        int i = 0; // Should be 1, be we iterate before it in while using 0\n-        double u2 = this.nextUniform(0, 1);\n-        double umin = u2;\n-\n-        // Step 7 and 8:\n-        do {\n-            ++i;\n-            u2 = this.nextUniform(0, 1);\n-\n-            if (u2 < umin) {\n-                umin = u2;\n-            }\n-\n-            // Step 8:\n-        } while (u > EXPONENTIAL_SA_QI[i]); // Ensured to exit since EXPONENTIAL_SA_QI[MAX] = 1\n-\n-        return mean * (a + umin * EXPONENTIAL_SA_QI[0]);\n+        return delegate.nextExponential(mean);\n     }\n \n     /**\n      * {@code NaN} or either bound is infinite or NaN\n      */\n     public double nextUniform(double lower, double upper) {\n-\n-        return nextUniform(lower, upper, false);\n+        return delegate.nextUniform(lower, upper);\n     }\n \n     /**\n      */\n     public double nextUniform(double lower, double upper,\n         boolean lowerInclusive) {\n-\n-        if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n-\n-        if (Double.isInfinite(lower) || Double.isInfinite(upper)) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);\n-        }\n-\n-        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n-        }\n-\n-        final RandomGenerator generator = getRan();\n-\n-        // ensure nextDouble() isn't 0.0\n-        double u = generator.nextDouble();\n-        while (!lowerInclusive && u <= 0.0) {\n-            u = generator.nextDouble();\n-        }\n-\n-        return u * upper + (1.0 - u) * lower;\n+        return delegate.nextUniform(lower, upper, lowerInclusive);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextBeta(double alpha, double beta) {\n-        return nextInversionDeviate(new BetaDistribution(alpha, beta));\n+        return delegate.nextBeta(alpha, beta);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {\n-        return nextInversionDeviate(new BinomialDistribution(numberOfTrials, probabilityOfSuccess));\n+        return delegate.nextBinomial(numberOfTrials, probabilityOfSuccess);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextCauchy(double median, double scale) {\n-        return nextInversionDeviate(new CauchyDistribution(median, scale));\n+        return delegate.nextCauchy(median, scale);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextChiSquare(double df) {\n-        return nextInversionDeviate(new ChiSquaredDistribution(df));\n+       return delegate.nextChiSquare(df);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextF(double numeratorDf, double denominatorDf) {\n-        return nextInversionDeviate(new FDistribution(numeratorDf, denominatorDf));\n+        return delegate.nextF(numeratorDf, denominatorDf);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextGamma(double shape, double scale) {\n-        if (shape < 1) {\n-            // [1]: p. 228, Algorithm GS\n-\n-            while (true) {\n-                // Step 1:\n-                final double u = this.nextUniform(0, 1);\n-                final double bGS = 1 + shape/FastMath.E;\n-                final double p = bGS*u;\n-\n-                if (p <= 1) {\n-                    // Step 2:\n-\n-                    final double x = FastMath.pow(p, 1/shape);\n-                    final double u2 = this.nextUniform(0.0, 1);\n-\n-                    if (u2 > FastMath.exp(-x)) {\n-                        // Reject\n-                        continue;\n-                    } else {\n-                        return scale*x;\n-                    }\n-                } else {\n-                    // Step 3:\n-\n-                    final double x = -1 * FastMath.log((bGS-p)/shape);\n-                    final double u2 = this.nextUniform(0, 1);\n-\n-                    if (u2 > FastMath.pow(x, shape - 1)) {\n-                        // Reject\n-                        continue;\n-                    } else {\n-                        return scale*x;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Now shape >= 1\n-\n-        final RandomGenerator generator = this.getRan();\n-        final double d = shape - 0.333333333333333333;\n-        final double c = 1.0 / (3*FastMath.sqrt(d));\n-\n-        while (true) {\n-            final double x = generator.nextGaussian();\n-            final double v = (1+c*x)*(1+c*x)*(1+c*x);\n-\n-            if (v <= 0) {\n-                continue;\n-            }\n-\n-            final double xx = x*x;\n-            final double u = this.nextUniform(0, 1);\n-\n-            // Squeeze\n-            if (u < 1 - 0.0331*xx*xx) {\n-                return scale*d*v;\n-            }\n-\n-            if (FastMath.log(u) < 0.5*xx + d*(1 - v + FastMath.log(v))) {\n-                return scale*d*v;\n-            }\n-        }\n+        return delegate.nextGamma(shape, scale);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {\n-        return nextInversionDeviate(new HypergeometricDistribution(populationSize, numberOfSuccesses, sampleSize));\n+        return delegate.nextHypergeometric(populationSize, numberOfSuccesses, sampleSize);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public int nextPascal(int r, double p) {\n-        return nextInversionDeviate(new PascalDistribution(r, p));\n+        return delegate.nextPascal(r, p);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextT(double df) {\n-        return nextInversionDeviate(new TDistribution(df));\n+        return delegate.nextT(df);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public double nextWeibull(double shape, double scale) {\n-        return nextInversionDeviate(new WeibullDistribution(shape, scale));\n+        return delegate.nextWeibull(shape, scale);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public int nextZipf(int numberOfElements, double exponent) {\n-        return nextInversionDeviate(new ZipfDistribution(numberOfElements, exponent));\n-    }\n-\n-    /**\n-     * Returns the RandomGenerator used to generate non-secure random data.\n-     * <p>\n-     * Creates and initializes a default generator if null. Uses a {@link Well19937c}\n-     * generator with {@code System.currentTimeMillis() + System.identityHashCode(this))} as the default seed.\n-     * </p>\n-     *\n-     * @return the Random used to generate random data\n-     * @since 1.1\n-     */\n-    private RandomGenerator getRan() {\n-        if (rand == null) {\n-            initRan();\n-        }\n-        return rand;\n-    }\n-\n-    /**\n-     * Sets the default generator to a {@link Well19937c} generator seeded with\n-     * {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n-     */\n-    private void initRan() {\n-        rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this));\n-    }\n-\n-    /**\n-     * Returns the SecureRandom used to generate secure random data.\n-     * <p>\n-     * Creates and initializes if null.  Uses\n-     * {@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.\n-     * </p>\n-     *\n-     * @return the SecureRandom used to generate secure random data\n-     */\n-    private SecureRandom getSecRan() {\n-        if (secRand == null) {\n-            secRand = new SecureRandom();\n-            secRand.setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n-        }\n-        return secRand;\n-    }\n+        return delegate.nextZipf(numberOfElements, exponent);\n+    }\n+\n \n     /**\n      * Reseeds the random number generator with the supplied seed.\n      *            the seed value to use\n      */\n     public void reSeed(long seed) {\n-        if (rand == null) {\n-            initRan();\n-        }\n-        rand.setSeed(seed);\n+        delegate.reSeed(seed);\n     }\n \n     /**\n      * </p>\n      */\n     public void reSeedSecure() {\n-        if (secRand == null) {\n-            secRand = new SecureRandom();\n-        }\n-        secRand.setSeed(System.currentTimeMillis());\n+        delegate.reSeedSecure();\n     }\n \n     /**\n      *            the seed value to use\n      */\n     public void reSeedSecure(long seed) {\n-        if (secRand == null) {\n-            secRand = new SecureRandom();\n-        }\n-        secRand.setSeed(seed);\n+        delegate.reSeedSecure(seed);\n     }\n \n     /**\n      * {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n      */\n     public void reSeed() {\n-        if (rand == null) {\n-            initRan();\n-        }\n-        rand.setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n+        delegate.reSeed();\n     }\n \n     /**\n      */\n     public void setSecureAlgorithm(String algorithm, String provider)\n             throws NoSuchAlgorithmException, NoSuchProviderException {\n-        secRand = SecureRandom.getInstance(algorithm, provider);\n+       delegate.setSecureAlgorithm(algorithm, provider);\n     }\n \n     /**\n      * </p>\n      */\n     public int[] nextPermutation(int n, int k) {\n-        if (k > n) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n-                                                k, n, true);\n-        }\n-        if (k <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n-                                                   k);\n-        }\n-\n-        int[] index = getNatural(n);\n-        shuffle(index, n - k);\n-        int[] result = new int[k];\n-        for (int i = 0; i < k; i++) {\n-            result[i] = index[n - i - 1];\n-        }\n-\n-        return result;\n+        return delegate.nextPermutation(n, k);\n     }\n \n     /**\n      * </p>\n      */\n     public Object[] nextSample(Collection<?> c, int k) {\n-\n-        int len = c.size();\n-        if (k > len) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n-                                                k, len, true);\n-        }\n-        if (k <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n-        }\n-\n-        Object[] objects = c.toArray();\n-        int[] index = nextPermutation(len, k);\n-        Object[] result = new Object[k];\n-        for (int i = 0; i < k; i++) {\n-            result[i] = objects[index[i]];\n-        }\n-        return result;\n+        return delegate.nextSample(c, k);\n     }\n \n     /**\n      * @param distribution Continuous distribution to generate a random value from\n      * @return a random value sampled from the given distribution\n      * @since 2.2\n+     * @deprecated use the distribution's sample() method\n      */\n     public double nextInversionDeviate(RealDistribution distribution) {\n         return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n      * @param distribution Integer distribution to generate a random value from\n      * @return a random value sampled from the given distribution\n      * @since 2.2\n+     * @deprecated use the distribution's sample() method\n      */\n     public int nextInversionDeviate(IntegerDistribution distribution) {\n         return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n     }\n \n-    // ------------------------Private methods----------------------------------\n-\n-    /**\n-     * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n-     * of list.\n-     *\n-     * @param list\n-     *            list to be shuffled\n-     * @param end\n-     *            element past which shuffling begins\n-     */\n-    private void shuffle(int[] list, int end) {\n-        int target = 0;\n-        for (int i = list.length - 1; i >= end; i--) {\n-            if (i == 0) {\n-                target = 0;\n-            } else {\n-                target = nextInt(0, i);\n-            }\n-            int temp = list[target];\n-            list[target] = list[i];\n-            list[i] = temp;\n-        }\n-    }\n-\n-    /**\n-     * Returns an array representing n.\n-     *\n-     * @param n\n-     *            the natural number to represent\n-     * @return array with entries = elements of n\n-     */\n-    private int[] getNatural(int n) {\n-        int[] natural = new int[n];\n-        for (int i = 0; i < n; i++) {\n-            natural[i] = i;\n-        }\n-        return natural;\n-    }\n-\n }", "timestamp": 1345492437, "metainfo": ""}