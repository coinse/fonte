{"sha": "5462eca5e4bbdecbfdb73999f3c93a700e57f797", "log": "MATH-797 Modified test to be Java5 compatible. Corrected a bug in the (dummy) rule computation.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactoryTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactoryTest.java\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.Callable;\n import java.util.concurrent.Future;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.atomic.AtomicInteger;\n import org.apache.commons.math3.util.Pair;\n import org.junit.Test;\n      * whatever the number of times this rule is called concurrently.\n      */\n     @Test\n-    public void testConcurrentCreation() throws InterruptedException {\n+        public void testConcurrentCreation() throws InterruptedException,\n+                                                    ExecutionException {\n         // Number of times the same rule will be called.\n         final int numTasks = 20;\n \n             = new ThreadPoolExecutor(3, numTasks, 1, TimeUnit.SECONDS,\n                                      new ArrayBlockingQueue<Runnable>(2));\n \n-        final List<RuleBuilder> tasks = new ArrayList<RuleBuilder>();\n+        final List<Future<Pair<double[], double[]>>> results\n+            = new ArrayList<Future<Pair<double[], double[]>>>();\n         for (int i = 0; i < numTasks; i++) {\n-            tasks.add(new RuleBuilder());\n+            results.add(exec.submit(new RuleBuilder()));\n         }\n \n-        List<Future<Pair<double[], double[]>>> results = exec.invokeAll(tasks);\n+        // Ensure that all computations have completed.\n+        for (Future<Pair<double[], double[]>> f : results) {\n+            f.get();\n+        }\n \n         // Assertion would fail if \"getRuleInternal\" were not \"synchronized\".\n         final int n = RuleBuilder.getNumberOfCalls();\n         }\n \n          // Dummy rule (but contents must exist).\n-        return new Pair<Double[], Double[]>(new Double[order],\n-                                            new Double[order]);\n+        final Double[] p = new Double[order];\n+        final Double[] w = new Double[order];\n+        for (int i = 0; i < order; i++) {\n+            p[i] = new Double(i);\n+            w[i] = new Double(i);\n+        }\n+        return new Pair<Double[], Double[]>(p, w);\n     }\n \n     public int getNumberOfCalls() {", "timestamp": 1342894466, "metainfo": ""}