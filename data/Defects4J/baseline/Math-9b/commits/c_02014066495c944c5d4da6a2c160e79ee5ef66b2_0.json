{"sha": "02014066495c944c5d4da6a2c160e79ee5ef66b2", "log": "fixed step size handling in borderline cases. When an even occurred at step start, the step size dropped to zero which put integration in an infinite loop  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n \n   /** Filter the integration step.\n    * @param h signed step\n+   * @param forward forward integration indicator\n    * @param acceptSmall if true, steps smaller than the minimal value\n    * are silently increased up to this value, if false such small\n    * steps generate an exception\n    * @return a bounded integration step (h if no bound is reach, or a bounded value)\n    * @exception IntegratorException if the step is too small and acceptSmall is false\n    */\n-  protected double filterStep(final double h, final boolean acceptSmall)\n+  protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n     throws IntegratorException {\n \n       double filteredH = h;\n       if (Math.abs(h) < minStep) {\n           if (acceptSmall) {\n-              filteredH = (filteredH < 0) ? -minStep : minStep;\n+              filteredH = forward ? minStep : -minStep;\n           } else {\n               throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n                                             \" integration needs {1}\",\n \n       if (filteredH > maxStep) {\n           filteredH = maxStep;\n-      } else if (h < -maxStep) {\n+      } else if (filteredH < -maxStep) {\n           filteredH = -maxStep;\n       }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n           final double factor =\n               Math.min(maxGrowth,\n                        Math.max(minReduction, safety * Math.pow(error, exp)));\n-          hNew = filterStep(stepSize * factor, false);\n+          hNew = filterStep(stepSize * factor, forward, false);\n         }\n \n       }\n       }\n \n       if (! lastStep) {\n+        // in some rare cases we may get here with stepSize = 0, for example\n+        // when an event occurs at integration start, reducing the first step\n+        // to zero; we have to reset the step to some safe non zero value\n+          stepSize = filterStep(stepSize, forward, true);\n+\n         // stepsize control for next step\n         final double factor = Math.min(maxGrowth,\n                                        Math.max(minReduction,\n         final double  scaledH    = stepSize * factor;\n         final double  nextT      = stepStart + scaledH;\n         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n-        hNew = filterStep(scaledH, nextIsLast);\n+        hNew = filterStep(scaledH, forward, nextIsLast);\n       }\n \n     }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n                        yTmp)) {\n \n           // the stability check failed, we reduce the global step\n-          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));\n+          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n           reject = true;\n           loop   = false;\n \n \n             if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n               // error is too big, we reduce the global step\n-              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));\n+              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n               reject = true;\n               loop   = false;\n             } else {\n               double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n               final double pow = Math.pow(stepControl3, exp);\n               fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n-              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, true));\n+              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, forward, true));\n               costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n \n               // check convergence\n           } else {\n             if ((k < targetIter) &&\n                 (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n-              hNew = filterStep(optimalStep[k] *\n-                                costPerStep[optimalIter+1] / costPerStep[k],\n-                                false);\n+              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n+                               forward, false);\n             } else {\n-              hNew = filterStep(optimalStep[k] *\n-                                costPerStep[optimalIter] / costPerStep[k],\n-                                false);\n+              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n+                                forward, false);\n             }\n           }\n ", "timestamp": 1216048131, "metainfo": ""}