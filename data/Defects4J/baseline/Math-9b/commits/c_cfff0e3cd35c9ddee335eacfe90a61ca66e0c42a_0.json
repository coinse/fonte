{"sha": "cfff0e3cd35c9ddee335eacfe90a61ca66e0c42a", "log": "Added a feature allowing error estimation to be computed only on a subset of Ordinary Differential Equations, considered as the main set, the remaining equations being considered only as an extension set that should not influence the ODE integration algorithm  JIRA: MATH-388  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ExtendedFirstOrderDifferentialEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+\n+/** This interface represents a first order differential equations set\n+ * with a main set of equations and an extension set.\n+ *\n+ * <p>\n+ * This interface is a simple extension on the {@link\n+ * FirstOrderDifferentialEquations} that allows to identify which part\n+ * of a complete set of differential equations correspond to the main\n+ * set and which part correspond to the extension set.\n+ * </p>\n+ * <p>\n+ * One typical use case is the computation of Jacobians. The main\n+ * set of equations correspond to the raw ode, and we add to this set\n+ * another bunch of equations which represent the jacobians of the\n+ * main set. In that case, we want the integrator to use <em>only</em>\n+ * the main set to estimate the errors and hence the step sizes. It should\n+ * <em>not</em> use the additional equations in this computation. If the\n+ * complete ode implements this interface, the {@link FirstOrderIntegrator\n+ * integrator} will be able to know where the main set ends and where the\n+ * extended set begins.\n+ * </p>\n+ * <p>\n+ * We consider that the main set always corresponds to the first equations\n+ * and the extended set to the last equations.\n+ * </p>\n+ *\n+ * @see FirstOrderDifferentialEquations\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+\n+public interface ExtendedFirstOrderDifferentialEquations extends FirstOrderDifferentialEquations {\n+\n+    /** Return the dimension of the main set of equations.\n+     * <p>\n+     * The main set of equations represent the first part of an ODE state.\n+     * The error estimations and adaptive step size computation should be\n+     * done on this first part only, not on the final part of the state\n+     * which represent an extension set of equations which are considered\n+     * secondary.\n+     * </p>\n+     * @return dimension of the main set of equations, must be lesser than or\n+     * equal to the {@link #getDimension() total dimension}\n+     */\n+    int getMainSetDimension();\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n     }\n \n     /** Wrapper for differential equations, ensuring start evaluations are counted. */\n-    private class CountingDifferentialEquations implements FirstOrderDifferentialEquations {\n+    private class CountingDifferentialEquations implements ExtendedFirstOrderDifferentialEquations {\n \n         /** Dimension of the problem. */\n         private final int dimension;\n         public int getDimension() {\n             return dimension;\n         }\n+\n+        /** {@inheritDoc} */\n+        public int getMainSetDimension() {\n+            return mainSetDimension;\n+        }\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n     }\n \n     /** Wrapper class used to map state and jacobians into compound state. */\n-    private class MappingWrapper implements  FirstOrderDifferentialEquations {\n+    private class MappingWrapper implements  ExtendedFirstOrderDifferentialEquations {\n \n         /** Current state. */\n         private final double[]   y;\n             final int n = y.length;\n             final int k = dFdP[0].length;\n             return n * (1 + n + k);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getMainSetDimension() {\n+            return ode.getDimension();\n         }\n \n         /** {@inheritDoc} */\n     }\n \n     /** Wrapper class to compute jacobians by finite differences for ODE which do not compute them themselves. */\n-    private class FiniteDifferencesWrapper\n-        implements ODEWithJacobians {\n+    private class FiniteDifferencesWrapper implements ODEWithJacobians {\n \n         /** Raw ODE without jacobians computation. */\n         private final ParameterizedODE ode;\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/ParameterizedODE.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/ParameterizedODE.java\n  * @since 2.1\n  */\n \n-public interface ParameterizedODE\n-    extends FirstOrderDifferentialEquations {\n+public interface ParameterizedODE extends FirstOrderDifferentialEquations {\n \n     /** Get the number of parameters.\n      * @return number of parameters\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n \n                 // evaluate error using the last term of the Taylor expansion\n                 error = 0;\n-                for (int i = 0; i < y0.length; ++i) {\n+                for (int i = 0; i < mainSetDimension; ++i) {\n                     final double yScale = Math.abs(y[i]);\n                     final double tol = (vecAbsoluteTolerance == null) ?\n                                        (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                     final double ratio  = nordsieck.getEntry(lastRow, i) / tol;\n                     error += ratio * ratio;\n                 }\n-                error = Math.sqrt(error / y0.length);\n+                error = Math.sqrt(error / mainSetDimension);\n \n                 if (error <= 1.0) {\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n         }\n \n         /**\n-         * End visiting te Nordsieck vector.\n+         * End visiting the Nordsieck vector.\n          * <p>The correction is used to control stepsize. So its amplitude is\n          * considered to be an error, which must be normalized according to\n          * error control settings. If the normalized value is greater than 1,\n             double error = 0;\n             for (int i = 0; i < after.length; ++i) {\n                 after[i] += previous[i] + scaled[i];\n-                final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n-                final double tol = (vecAbsoluteTolerance == null) ?\n-                                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n-                                   (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n-                final double ratio  = (after[i] - before[i]) / tol;\n-                error += ratio * ratio;\n-            }\n-\n-            return Math.sqrt(error / after.length);\n+                if (i < mainSetDimension) {\n+                    final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n+                    final double tol = (vecAbsoluteTolerance == null) ?\n+                                       (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                                       (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n+                    final double ratio  = (after[i] - before[i]) / tol;\n+                    error += ratio * ratio;\n+                }\n+            }\n+\n+            return Math.sqrt(error / mainSetDimension);\n \n         }\n     }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n \n import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.util.LocalizedFormats;\n  * where absTol_i is the absolute tolerance for component i of the\n  * state vector and relTol_i is the relative tolerance for the same\n  * component. The user can also use only two scalar values absTol and\n- * relTol which will be used for all components.</p>\n+ * relTol which will be used for all components.\n+ * </p>\n+ *\n+ * <p>If the Ordinary Differential Equations is an {@link ExtendedFirstOrderDifferentialEquations\n+ * extended ODE} rather than a {@link FirstOrderDifferentialEquations basic ODE},\n+ * then <em>only</em> the {@link ExtendedFirstOrderDifferentialEquations#getMainSetDimension()\n+ * main set} part of the state vector is used for stepsize control, not the complete\n+ * state vector.\n+ * </p>\n  *\n  * <p>If the estimated error for ym+1 is such that\n  * <pre>\n  * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n  * </pre>\n  *\n- * (where n is the state vector dimension) then the step is accepted,\n+ * (where n is the main set dimension) then the step is accepted,\n  * otherwise the step is rejected and a new attempt is made with a new\n  * stepsize.</p>\n  *\n \n     /** Maximal step. */\n     private final double maxStep;\n+\n+    /** Main set dimension. */\n+    protected int mainSetDimension;\n \n   /** Build an integrator with the given stepsize bounds.\n    * The default step handler does nothing.\n \n       super.sanityChecks(equations, t0, y0, t, y);\n \n-      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n+      if (equations instanceof ExtendedFirstOrderDifferentialEquations) {\n+          mainSetDimension = ((ExtendedFirstOrderDifferentialEquations) equations).getMainSetDimension();\n+      } else {\n+          mainSetDimension = equations.getDimension();\n+      }\n+\n+      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != mainSetDimension)) {\n           throw new IntegratorException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, y0.length, vecAbsoluteTolerance.length);\n-      }\n-\n-      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, mainSetDimension, vecAbsoluteTolerance.length);\n+      }\n+\n+      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != mainSetDimension)) {\n           throw new IntegratorException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, y0.length, vecRelativeTolerance.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, mainSetDimension, vecRelativeTolerance.length);\n       }\n \n   }\n    * @param equations differential equations set\n    * @param forward forward integration indicator\n    * @param order order of the method\n-   * @param scale scaling vector for the state vector\n+   * @param scale scaling vector for the state vector (can be shorter than state vector)\n    * @param t0 start time\n    * @param y0 state vector at t0\n    * @param yDot0 first time derivative of y0\n     double ratio;\n     double yOnScale2 = 0;\n     double yDotOnScale2 = 0;\n-    for (int j = 0; j < y0.length; ++j) {\n+    for (int j = 0; j < scale.length; ++j) {\n       ratio         = y0[j] / scale[j];\n       yOnScale2    += ratio * ratio;\n       ratio         = yDot0[j] / scale[j];\n \n     // estimate the second derivative of the solution\n     double yDDotOnScale = 0;\n-    for (int j = 0; j < y0.length; ++j) {\n+    for (int j = 0; j < scale.length; ++j) {\n       ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n       yDDotOnScale += ratio * ratio;\n     }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n \n     double error = 0;\n \n-    for (int j = 0; j < y0.length; ++j) {\n+    for (int j = 0; j < mainSetDimension; ++j) {\n         final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +\n                               E4 * yDotK[3][j] +  E5 * yDotK[4][j] +\n                               E6 * yDotK[5][j] +  E7 * yDotK[6][j];\n \n     }\n \n-    return Math.sqrt(error / y0.length);\n+    return Math.sqrt(error / mainSetDimension);\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n     double error1 = 0;\n     double error2 = 0;\n \n-    for (int j = 0; j < y0.length; ++j) {\n+    for (int j = 0; j < mainSetDimension; ++j) {\n       final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\n                              E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\n                              E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\n       den = 1.0;\n     }\n \n-    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n+    return Math.abs(h) * error1 / Math.sqrt(mainSetDimension * den);\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n         }\n \n         if (firstTime) {\n-          final double[] scale = new double[y0.length];\n+          final double[] scale = new double[mainSetDimension];\n           if (vecAbsoluteTolerance == null) {\n               for (int i = 0; i < scale.length; ++i) {\n                 scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n   /** Update scaling array.\n    * @param y1 first state vector to use for scaling\n    * @param y2 second state vector to use for scaling\n-   * @param scale scaling array to update\n+   * @param scale scaling array to update (can be shorter than state)\n    */\n   private void rescale(final double[] y1, final double[] y2, final double[] scale) {\n     if (vecAbsoluteTolerance == null) {\n    * @param y0 initial value of the state vector at t0\n    * @param step global step\n    * @param k iteration number (from 0 to sequence.length - 1)\n-   * @param scale scaling array\n+   * @param scale scaling array (can be shorter than state)\n    * @param f placeholder where to put the state vector derivatives at each substep\n    *          (element 0 already contains initial derivative)\n    * @param yMiddle placeholder where to put the state vector at the middle of the step\n       // stability check\n       if (performTest && (j <= maxChecks) && (k < maxIter)) {\n         double initialNorm = 0.0;\n-        for (int l = 0; l < y0.length; ++l) {\n+        for (int l = 0; l < scale.length; ++l) {\n           final double ratio = f[0][l] / scale[l];\n           initialNorm += ratio * ratio;\n         }\n         double deltaNorm = 0.0;\n-        for (int l = 0; l < y0.length; ++l) {\n+        for (int l = 0; l < scale.length; ++l) {\n           final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n           deltaNorm += ratio * ratio;\n         }\n     }\n \n     // initial scaling\n-    final double[] scale = new double[y0.length];\n+    final double[] scale = new double[mainSetDimension];\n     rescale(y, y, scale);\n \n     // initial order selection\n \n             // estimate the error at the end of the step.\n             error = 0;\n-            for (int j = 0; j < y0.length; ++j) {\n+            for (int j = 0; j < mainSetDimension; ++j) {\n               final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n               error += e * e;\n             }\n-            error = Math.sqrt(error / y0.length);\n+            error = Math.sqrt(error / mainSetDimension);\n \n             if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n               // error is too big, we reduce the global step\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n   public double estimateError(final double[] scale) {\n     double error = 0;\n     if (currentDegree >= 5) {\n-      for (int i = 0; i < currentState.length; ++i) {\n+      for (int i = 0; i < scale.length; ++i) {\n         final double e = polynoms[currentDegree][i] / scale[i];\n         error += e * e;\n       }\n-      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];\n+      error = Math.sqrt(error / scale.length) * errfac[currentDegree - 5];\n     }\n     return error;\n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n \n     double error = 0;\n \n-    for (int j = 0; j < y0.length; ++j) {\n+    for (int j = 0; j < mainSetDimension; ++j) {\n       double errSum = STATIC_E[0] * yDotK[0][j];\n       for (int l = 1; l < STATIC_E.length; ++l) {\n         errSum += STATIC_E[l] * yDotK[l][j];\n \n     }\n \n-    return Math.sqrt(error / y0.length);\n+    return Math.sqrt(error / mainSetDimension);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n         // Solving Ordinary Differential Equations I (Nonstiff problems),\n         // the curves dy/dp = g(b) are in figure 6.5\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         double hP = 1.0e-12;\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         SummaryStatistics residualsP1 = new SummaryStatistics();\n     public void testHighAccuracyExternalDifferentiation()\n         throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double hP = 1.0e-12;\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         SummaryStatistics residualsP1 = new SummaryStatistics();\n     public void testInternalDifferentiation()\n         throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         double hP = 1.0e-12;\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         SummaryStatistics residualsP1 = new SummaryStatistics();\n             extInt.setMaxEvaluations(5000);\n             extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n             Assert.assertEquals(5000, extInt.getMaxEvaluations());\n-            Assert.assertTrue(extInt.getEvaluations() > 2000);\n-            Assert.assertTrue(extInt.getEvaluations() < 2500);\n+            Assert.assertTrue(extInt.getEvaluations() > 1500);\n+            Assert.assertTrue(extInt.getEvaluations() < 2100);\n             Assert.assertEquals(4 * integ.getEvaluations(), extInt.getEvaluations());\n             residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());\n             residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());\n         }\n-        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.006);\n-        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.0009);\n-        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.009);\n-        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.0014);\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.02);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);\n     }\n \n     @Test\n     public void testAnalyticalDifferentiation()\n         throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         SummaryStatistics residualsP1 = new SummaryStatistics();\n         for (double b = 2.88; b < 3.08; b += 0.001) {\n             extInt.setMaxEvaluations(5000);\n             extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n             Assert.assertEquals(5000, extInt.getMaxEvaluations());\n-            Assert.assertTrue(extInt.getEvaluations() > 510);\n-            Assert.assertTrue(extInt.getEvaluations() < 610);\n+            Assert.assertTrue(extInt.getEvaluations() > 350);\n+            Assert.assertTrue(extInt.getEvaluations() < 510);\n             Assert.assertEquals(integ.getEvaluations(), extInt.getEvaluations());\n             residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());\n             residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());\n         }\n-        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.004);\n-        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.0008);\n-        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.005);\n-        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.0010);\n+        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.014);\n+        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);\n+        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);\n     }\n \n     @Test\n     public void testFinalResult() throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n         Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n         double[][] dydy0 = new double[2][2];\n             new FirstOrderIntegratorWithJacobians(integ, circle);\n         extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n         for (int i = 0; i < y.length; ++i) {\n-            Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-10);\n+            Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);\n         }\n         for (int i = 0; i < dydy0.length; ++i) {\n             for (int j = 0; j < dydy0[i].length; ++j) {\n-                Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-10);\n+                Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9);\n             }\n         }\n         for (int i = 0; i < dydp.length; ++i) {\n             for (int j = 0; j < dydp[i].length; ++j) {\n-                Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 1.0e-8);\n+                Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 1.0e-7);\n             }\n         }\n     }\n     @Test\n     public void testStepHandlerResult() throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n         final Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n         double[][] dydy0 = new double[2][2];\n                 Assert.assertEquals(interpolator.getPreviousTime(), extInt.getCurrentStepStart(), 1.0e-10);\n                 Assert.assertTrue(extInt.getCurrentSignedStepsize() < 0.5);\n                 for (int i = 0; i < y.length; ++i) {\n-                    Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-10);\n+                    Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);\n                 }\n                 for (int i = 0; i < dydy0.length; ++i) {\n                     for (int j = 0; j < dydy0[i].length; ++j) {\n-                        Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-10);\n+                        Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9);\n                     }\n                 }\n                 for (int i = 0; i < dydp.length; ++i) {\n                     for (int j = 0; j < dydp[i].length; ++j) {\n-                        Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 1.0e-8);\n+                        Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 3.0e-8);\n                     }\n                 }\n \n                 double[][] dydpDot  = interpolator.getInterpolatedDyDpDot();\n \n                 for (int i = 0; i < yDot.length; ++i) {\n-                    Assert.assertEquals(circle.exactYDot(t)[i], yDot[i], 1.0e-11);\n+                    Assert.assertEquals(circle.exactYDot(t)[i], yDot[i], 1.0e-10);\n                 }\n                 for (int i = 0; i < dydy0Dot.length; ++i) {\n                     for (int j = 0; j < dydy0Dot[i].length; ++j) {\n-                        Assert.assertEquals(circle.exactDyDy0Dot(t)[i][j], dydy0Dot[i][j], 1.0e-11);\n+                        Assert.assertEquals(circle.exactDyDy0Dot(t)[i][j], dydy0Dot[i][j], 1.0e-10);\n                     }\n                 }\n                 for (int i = 0; i < dydpDot.length; ++i) {\n                     for (int j = 0; j < dydpDot[i].length; ++j) {\n-                        Assert.assertEquals(circle.exactDyDpDot(t)[i][j], dydpDot[i][j], 1.0e-9);\n+                        Assert.assertEquals(circle.exactDyDpDot(t)[i][j], dydpDot[i][j], 3.0e-9);\n                     }\n                 }\n             }\n     @Test\n     public void testEventHandler() throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n         final Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n         double[][] dydy0 = new double[2][2];", "timestamp": 1279875577, "metainfo": ""}