{"sha": "e3a2f146dc12711654ddb08bf55fafdd63a7563e", "log": "[MATH-627] avoid superfluous null checks in (Array)RealVector, thanks to Arno Ploese.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n             checkVectorDimensions(v);\n             double[] out = data.clone();\n             Iterator<Entry> it = v.sparseIterator();\n-            Entry e;\n-            while (it.hasNext() && (e = it.next()) != null) {\n+            while (it.hasNext()) {\n+                final Entry e = it.next();\n                 out[e.getIndex()] += e.getValue();\n             }\n             return new ArrayRealVector(out, false);\n             checkVectorDimensions(v);\n             double[] out = data.clone();\n             Iterator<Entry> it = v.sparseIterator();\n-            Entry e;\n-            while(it.hasNext() && (e = it.next()) != null) {\n+            while (it.hasNext()) {\n+                final Entry e = it.next();\n                 out[e.getIndex()] -= e.getValue();\n             }\n             return new ArrayRealVector(out, false);\n             checkVectorDimensions(v);\n             double dot = 0;\n             Iterator<Entry> it = v.sparseIterator();\n-            Entry e;\n-            while(it.hasNext() && (e = it.next()) != null) {\n+            while (it.hasNext()) {\n+                final Entry e = it.next();\n                 dot += data[e.getIndex()] * e.getValue();\n             }\n             return dot;\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n     public RealVector add(RealVector v) {\n         RealVector result = v.copy();\n         Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             final int index = e.getIndex();\n             result.setEntry(index, e.getValue() + result.getEntry(index));\n         }\n     public RealVector subtract(RealVector v) {\n         RealVector result = v.copy();\n         Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             final int index = e.getIndex();\n             result.setEntry(index, e.getValue() - result.getEntry(index));\n         }\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             d += e.getValue() * v.getEntry(e.getIndex());\n         }\n         return d;\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             final double diff = e.getValue() - v.getEntry(e.getIndex());\n             d += diff * diff;\n         }\n     public double getNorm() {\n         double sum = 0;\n         Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             final double value = e.getValue();\n             sum += value * value;\n         }\n     public double getL1Norm() {\n         double norm = 0;\n         Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             norm += FastMath.abs(e.getValue());\n         }\n         return norm;\n     public double getLInfNorm() {\n         double norm = 0;\n         Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             norm = FastMath.max(norm, FastMath.abs(e.getValue()));\n         }\n         return norm;\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex()));\n         }\n         return d;\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             d = FastMath.max(FastMath.abs(e.getValue() - v.getEntry(e.getIndex())), d);\n         }\n         return d;\n                                                v.getDimension());\n         }\n         Iterator<Entry> thisIt = sparseIterator();\n-        Entry thisE = null;\n-        while (thisIt.hasNext() && (thisE = thisIt.next()) != null) {\n+        while (thisIt.hasNext()) {\n+            final Entry thisE = thisIt.next();\n             Iterator<Entry> otherIt = v.sparseIterator();\n-            Entry otherE = null;\n-            while (otherIt.hasNext() && (otherE = otherIt.next()) != null) {\n+            while (otherIt.hasNext()) {\n+                final Entry otherE = otherIt.next();\n                 product.setEntry(thisE.getIndex(), otherE.getIndex(),\n                                  thisE.getValue() * otherE.getValue());\n             }\n      */\n     public void set(double value) {\n         Iterator<Entry> it = iterator();\n-        Entry e = null;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             e.setValue(value);\n         }\n     }\n      * In dense implementations, this method will often delegate to\n      * {@link #iterator()}.\n      *\n+     * <p>Note: derived classes are required to return an {@link Iterator} that\n+     * returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}\n+     * returns {@code true}.</p>\n+     *\n      * @return a sparse iterator.\n      */\n     public Iterator<Entry> sparseIterator() {\n     /**\n      * Generic dense iterator. Iteration is in increasing order\n      * of the vector index.\n+     *\n+     * <p>Note: derived classes are required to return an {@link Iterator} that\n+     * returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}\n+     * returns {@code true}.</p>\n      *\n      * @return a dense iterator.\n      */\n      */\n     public RealVector mapToSelf(UnivariateFunction function) {\n         Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n+        while (it.hasNext()) {\n+            final Entry e = it.next();\n             e.setValue(function.value(e.getValue()));\n         }\n         return this;", "timestamp": 1336167736, "metainfo": ""}