{"sha": "6e60dc76cbdb619c871b1282eb33fa284ba48b4e", "log": "Improved test coverage.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/AbstractExtendedFieldElementTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well1024a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public abstract class AbstractExtendedFieldElementTest<T extends ExtendedFieldElement<T>> {\n+\n+    protected abstract T build(double x);\n+\n+    @Test\n+    public void testAddField() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x + y, build(x).add(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAddDouble() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x + y, build(x).add(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSubtractField() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x - y, build(x).subtract(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSubtractDouble() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x - y, build(x).subtract(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiplyField() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x * y, build(x).multiply(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiplyDouble() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x * y, build(x).multiply(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiplyInt() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (int y = -10; y < 10; y += 1) {\n+                checkRelative(x * y, build(x).multiply(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDivideField() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(x / y, build(x).divide(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDivideDouble() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                    checkRelative(x / y, build(x).divide(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testRemainderField() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(FastMath.IEEEremainder(x, y), build(x).remainder(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testRemainderDouble() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3.2; y < 3.2; y += 0.25) {\n+                System.out.println(x + \" \" + y + \" \" + (x % y));\n+                checkRelative(FastMath.IEEEremainder(x, y), build(x).remainder(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCos() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.cos(x), build(x).cos());\n+        }\n+    }\n+\n+    @Test\n+    public void testAcos() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.acos(x), build(x).acos());\n+        }\n+    }\n+\n+    @Test\n+    public void testSin() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.sin(x), build(x).sin());\n+        }\n+    }\n+\n+    @Test\n+    public void testAsin() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.asin(x), build(x).asin());\n+        }\n+    }\n+\n+    @Test\n+    public void testTan() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.tan(x), build(x).tan());\n+        }\n+    }\n+\n+    @Test\n+    public void testAtan() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.atan(x), build(x).atan());\n+        }\n+    }\n+\n+    @Test\n+    public void testAtan2() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(FastMath.atan2(x, y), build(x).atan2(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCosh() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.cosh(x), build(x).cosh());\n+        }\n+    }\n+\n+    @Test\n+    public void testAcosh() {\n+        for (double x = 1.1; x < 5.0; x += 0.05) {\n+            checkRelative(FastMath.acosh(x), build(x).acosh());\n+        }\n+    }\n+\n+    @Test\n+    public void testSinh() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.sinh(x), build(x).sinh());\n+        }\n+    }\n+\n+    @Test\n+    public void testAsinh() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.asinh(x), build(x).asinh());\n+        }\n+    }\n+\n+    @Test\n+    public void testTanh() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.tanh(x), build(x).tanh());\n+        }\n+    }\n+\n+    @Test\n+    public void testAtanh() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.atanh(x), build(x).atanh());\n+        }\n+    }\n+\n+    @Test\n+    public void testSqrt() {\n+        for (double x = 0.01; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.sqrt(x), build(x).sqrt());\n+        }\n+    }\n+\n+    @Test\n+    public void testCbrt() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.cbrt(x), build(x).cbrt());\n+        }\n+    }\n+\n+    @Test\n+    public void testHypot() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(FastMath.hypot(x, y), build(x).hypot(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testRootN() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            for (int n = 1; n < 5; ++n) {\n+                if (x < 0) {\n+                    if (n % 2 == 1) {\n+                        checkRelative(-FastMath.pow(-x, 1.0 / n), build(x).rootN(n));\n+                    }\n+                } else {\n+                    checkRelative(FastMath.pow(x, 1.0 / n), build(x).rootN(n));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPowField() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            for (double y = 0.1; y < 4; y += 0.2) {\n+                checkRelative(FastMath.pow(x, y), build(x).pow(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPowDouble() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            for (double y = 0.1; y < 4; y += 0.2) {\n+                checkRelative(FastMath.pow(x, y), build(x).pow(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPowInt() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            for (int n = 0; n < 5; ++n) {\n+                checkRelative(FastMath.pow(x, n), build(x).pow(n));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExp() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.exp(x), build(x).exp());\n+        }\n+    }\n+\n+    @Test\n+    public void testExpm1() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.expm1(x), build(x).expm1());\n+        }\n+    }\n+\n+    @Test\n+    public void testLog() {\n+        for (double x = 0.01; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.log(x), build(x).log());\n+        }\n+    }\n+\n+    @Test\n+    public void testLog1p() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.log1p(x), build(x).log1p());\n+        }\n+    }\n+\n+    @Test\n+    public void testLog10() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.log10(x), build(x).log10());\n+        }\n+    }\n+\n+    @Test\n+    public void testAbs() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.abs(x), build(x).abs());\n+        }\n+    }\n+\n+    @Test\n+    public void testCeil() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.ceil(x), build(x).ceil());\n+        }\n+    }\n+\n+    @Test\n+    public void testFloor() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.floor(x), build(x).floor());\n+        }\n+    }\n+\n+    @Test\n+    public void testRint() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.rint(x), build(x).rint());\n+        }\n+    }\n+\n+    @Test\n+    public void testRound() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            Assert.assertEquals(FastMath.round(x), build(x).round());\n+        }\n+    }\n+\n+    @Test\n+    public void testSignum() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            checkRelative(FastMath.signum(x), build(x).signum());\n+        }\n+    }\n+\n+    @Test\n+    public void testCopySignField() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(FastMath.copySign(x, y), build(x).copySign(build(y)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCopySignDouble() {\n+        for (double x = -3; x < 3; x += 0.2) {\n+            for (double y = -3; y < 3; y += 0.2) {\n+                checkRelative(FastMath.copySign(x, y), build(x).copySign(y));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testScalb() {\n+        for (double x = -0.9; x < 0.9; x += 0.05) {\n+            for (int n = -100; n < 100; ++n) {\n+                checkRelative(FastMath.scalb(x, n), build(x).scalb(n));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationFaFa() {\n+        RandomGenerator r = new Well1024a(0xfafal);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 10);\n+            double[] bD = generateDouble(r, 10);\n+            T[] aF      = toFieldArray(aD);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD, bD),\n+                          aF[0].linearCombination(aF, bF));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationDaFa() {\n+        RandomGenerator r = new Well1024a(0xdafal);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 10);\n+            double[] bD = generateDouble(r, 10);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD, bD),\n+                          bF[0].linearCombination(aD, bF));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationFF2() {\n+        RandomGenerator r = new Well1024a(0xff2l);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 2);\n+            double[] bD = generateDouble(r, 2);\n+            T[] aF      = toFieldArray(aD);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD[0], bD[0], aD[1], bD[1]),\n+                          aF[0].linearCombination(aF[0], bF[0], aF[1], bF[1]));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationDF2() {\n+        RandomGenerator r = new Well1024a(0xdf2l);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 2);\n+            double[] bD = generateDouble(r, 2);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD[0], bD[0], aD[1], bD[1]),\n+                          bF[0].linearCombination(aD[0], bF[0], aD[1], bF[1]));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationFF3() {\n+        RandomGenerator r = new Well1024a(0xff3l);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 3);\n+            double[] bD = generateDouble(r, 3);\n+            T[] aF      = toFieldArray(aD);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2]),\n+                          aF[0].linearCombination(aF[0], bF[0], aF[1], bF[1], aF[2], bF[2]));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationDF3() {\n+        RandomGenerator r = new Well1024a(0xdf3l);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 3);\n+            double[] bD = generateDouble(r, 3);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2]),\n+                          bF[0].linearCombination(aD[0], bF[0], aD[1], bF[1], aD[2], bF[2]));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationFF4() {\n+        RandomGenerator r = new Well1024a(0xff4l);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 4);\n+            double[] bD = generateDouble(r, 4);\n+            T[] aF      = toFieldArray(aD);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2], aD[3], bD[3]),\n+                          aF[0].linearCombination(aF[0], bF[0], aF[1], bF[1], aF[2], bF[2], aF[3], bF[3]));\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationDF4() {\n+        RandomGenerator r = new Well1024a(0xdf4l);\n+        for (int i = 0; i < 50; ++i) {\n+            double[] aD = generateDouble(r, 4);\n+            double[] bD = generateDouble(r, 4);\n+            T[] bF      = toFieldArray(bD);\n+            checkRelative(MathArrays.linearCombination(aD[0], bD[0], aD[1], bD[1], aD[2], bD[2], aD[3], bD[3]),\n+                          bF[0].linearCombination(aD[0], bF[0], aD[1], bF[1], aD[2], bF[2], aD[3], bF[3]));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetField() {\n+        checkRelative(1.0, build(-10).getField().getOne());\n+        checkRelative(0.0, build(-10).getField().getZero());\n+    }\n+\n+    private void checkRelative(double expected, T obtained) {\n+        Assert.assertEquals(expected, obtained.getReal(), 1.0e-15 * (1 + FastMath.abs(expected)));\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        T t1a = build(1.0);\n+        T t1b = build(1.0);\n+        T t2  = build(2.0);\n+        Assert.assertTrue(t1a.equals(t1a));\n+        Assert.assertTrue(t1a.equals(t1b));\n+        Assert.assertFalse(t1a.equals(t2));\n+        Assert.assertFalse(t1a.equals(new Object()));\n+    }\n+\n+    @Test\n+    public void testHash() {\n+        T t1a = build(1.0);\n+        T t1b = build(1.0);\n+        T t2  = build(2.0);\n+        Assert.assertEquals(t1a.hashCode(), t1b.hashCode());\n+        Assert.assertTrue(t1a.hashCode() != t2.hashCode());\n+    }\n+\n+    private double[] generateDouble (final RandomGenerator r, int n) {\n+        double[] a = new double[n];\n+        for (int i = 0; i < n; ++i) {\n+            a[i] = r.nextDouble();\n+        }\n+        return a;\n+    }\n+\n+    private T[] toFieldArray (double[] a) {\n+        T[] f = MathArrays.buildArray(build(0).getField(), a.length);\n+        for (int i = 0; i < a.length; ++i) {\n+            f[i] = build(a[i]);\n+        }\n+        return f;\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n import java.util.Arrays;\n import java.util.List;\n \n+import org.apache.commons.math3.AbstractExtendedFieldElementTest;\n import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n /**\n  * Test for class {@link DerivativeStructure}.\n  */\n-public class DerivativeStructureTest {\n+public class DerivativeStructureTest extends AbstractExtendedFieldElementTest<DerivativeStructure> {\n+\n+    protected DerivativeStructure build(final double x) {\n+        return new DerivativeStructure(2, 1, 0, x);\n+    }\n \n     @Test(expected=NumberIsTooLargeException.class)\n     public void testWrongVariableIndex() {\n                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);\n                 for (double y = -1.7; y < 2; y += 0.2) {\n                     DerivativeStructure remainder = dsX.remainder(y);\n-                    DerivativeStructure ref = dsX.subtract(x - (x % y));\n+                    DerivativeStructure ref = dsX.subtract(x - FastMath.IEEEremainder(x, y));\n                     DerivativeStructure zero = remainder.subtract(ref);\n                     for (int n = 0; n <= maxOrder; ++n) {\n                         for (int m = 0; m <= maxOrder; ++m) {\n \n     @Test\n     public void testRemainder() {\n-        double epsilon = 1.0e-15;\n+        double epsilon = 2.0e-15;\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n             for (double x = -1.7; x < 2; x += 0.2) {\n                 DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);\n                 for (double y = -1.7; y < 2; y += 0.2) {\n                     DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);\n                     DerivativeStructure remainder = dsX.remainder(dsY);\n-                    DerivativeStructure ref = dsX.subtract(dsY.multiply((x - (x % y)) / y));\n+                    DerivativeStructure ref = dsX.subtract(dsY.multiply((x - FastMath.IEEEremainder(x, y)) / y));\n                     DerivativeStructure zero = remainder.subtract(ref);\n                     for (int n = 0; n <= maxOrder; ++n) {\n                         for (int m = 0; m <= maxOrder; ++m) {\n--- a/src/test/java/org/apache/commons/math3/dfp/DfpTest.java\n+++ b/src/test/java/org/apache/commons/math3/dfp/DfpTest.java\n \n package org.apache.commons.math3.dfp;\n \n+import org.apache.commons.math3.AbstractExtendedFieldElementTest;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Precision;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n-public class DfpTest {\n+public class DfpTest extends AbstractExtendedFieldElementTest<Dfp> {\n+\n+    protected Dfp build(final double x) {\n+        return field.newDfp(x);\n+    }\n \n     private DfpField field;\n     private Dfp pinf;\n--- a/src/test/java/org/apache/commons/math3/util/Decimal64Test.java\n+++ b/src/test/java/org/apache/commons/math3/util/Decimal64Test.java\n  */\n package org.apache.commons.math3.util;\n \n+import org.apache.commons.math3.AbstractExtendedFieldElementTest;\n import org.junit.Assert;\n \n import org.junit.Test;\n \n-public class Decimal64Test {\n+public class Decimal64Test extends AbstractExtendedFieldElementTest<Decimal64> {\n     public static final double X = 1.2345;\n \n     public static final Decimal64 PLUS_X = new Decimal64(X);\n     public static final Decimal64 PLUS_ZERO = new Decimal64(0.0);\n \n     public static final Decimal64 MINUS_ZERO = new Decimal64(-0.0);\n+\n+    protected Decimal64 build(final double x) {\n+        return new Decimal64(x);\n+    }\n \n     @Test\n     public void testAdd() {", "timestamp": 1361802877, "metainfo": ""}