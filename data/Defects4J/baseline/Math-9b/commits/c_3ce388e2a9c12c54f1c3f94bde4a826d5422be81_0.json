{"sha": "3ce388e2a9c12c54f1c3f94bde4a826d5422be81", "log": "Added a unit test.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n         }\n     }\n \n+    /**\n+     * Non-linear test case: fitting of decay curve (from Chapter 8 of\n+     * Bevington's textbook, \"Data reduction and analysis for the physical sciences\").\n+     * XXX The expected (\"reference\") values may not be accurate and the tolerance too\n+     * relaxed for this test to be currently really useful (the issue is under\n+     * investigation).\n+     */\n+    @Test\n+    public void testBevington() {\n+        final double[][] dataPoints = {\n+            // column 1 = times\n+            { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150,\n+              165, 180, 195, 210, 225, 240, 255, 270, 285, 300,\n+              315, 330, 345, 360, 375, 390, 405, 420, 435, 450,\n+              465, 480, 495, 510, 525, 540, 555, 570, 585, 600,\n+              615, 630, 645, 660, 675, 690, 705, 720, 735, 750,\n+              765, 780, 795, 810, 825, 840, 855, 870, 885, },\n+            // column 2 = measured counts\n+            { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89,\n+              74, 61, 66, 68, 48, 54, 51, 46, 55, 29,\n+              28, 37, 49, 26, 35, 29, 31, 24, 25, 35,\n+              24, 30, 26, 28, 21, 18, 20, 27, 17, 17,\n+              14, 17, 24, 11, 22, 17, 12, 10, 13, 16,\n+              9, 9, 14, 21, 17, 13, 12, 18, 10, },\n+        };\n+\n+        final BevingtonProblem problem = new BevingtonProblem();\n+\n+        final int len = dataPoints[0].length;\n+        final double[] weights = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            problem.addPoint(dataPoints[0][i],\n+                             dataPoints[1][i]);\n+\n+            weights[i] = 1 / dataPoints[1][i];\n+        }\n+\n+        final LevenbergMarquardtOptimizer optimizer\n+            = new LevenbergMarquardtOptimizer();\n+        \n+        final PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, dataPoints[1], weights,\n+                               new double[] { 10, 900, 80, 27, 225 });\n+        \n+        final double chi2 = optimizer.getChiSquare();\n+        final double[] solution = optimum.getPoint();\n+        final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 };\n+\n+        final double[][] covarMatrix = optimizer.getCovariances();\n+        final double[][] expectedCovarMatrix = {\n+            { 3.38, -3.69, 27.98, -2.34, -49.24 },\n+            { -3.69, 2492.26, 81.89, -69.21, -8.9 },\n+            { 27.98, 81.89, 468.99, -44.22, -615.44 },\n+            { -2.34, -69.21, -44.22, 6.39, 53.80 },\n+            { -49.24, -8.9, -615.44, 53.8, 929.45 }\n+        };\n+\n+        final int numParams = expectedSolution.length;\n+\n+        // Check that the computed solution is within the reference error range.\n+        for (int i = 0; i < numParams; i++) {\n+            final double error = FastMath.sqrt(expectedCovarMatrix[i][i]);\n+            Assert.assertEquals(\"Parameter \" + i, expectedSolution[i], solution[i], error);\n+        }\n+\n+        // Check that each entry of the computed covariance matrix is within 10%\n+        // of the reference matrix entry.\n+        for (int i = 0; i < numParams; i++) {\n+            for (int j = 0; j < numParams; j++) {\n+                Assert.assertEquals(\"Covariance matrix [\" + i + \"][\" + j + \"]\",\n+                                    expectedCovarMatrix[i][j],\n+                                    covarMatrix[i][j],\n+                                    FastMath.abs(0.1 * expectedCovarMatrix[i][j]));\n+            }\n+        }\n+    }\n+\n     private static class LinearProblem implements DifferentiableMultivariateVectorFunction, Serializable {\n \n         private static final long serialVersionUID = 703247177355019415L;\n             };\n         }\n     }\n+\n+    private static class BevingtonProblem\n+        implements DifferentiableMultivariateVectorFunction {\n+        private List<Double> time;\n+        private List<Double> count;\n+\n+        public BevingtonProblem() {\n+            time = new ArrayList<Double>();\n+            count = new ArrayList<Double>();\n+        }\n+\n+        public void addPoint(double t, double c) {\n+            time.add(t);\n+            count.add(c);\n+        }\n+\n+        private double[][] jacobian(double[] params) {\n+            double[][] jacobian = new double[time.size()][5];\n+\n+            for (int i = 0; i < jacobian.length; ++i) {\n+                final double t = time.get(i);\n+                jacobian[i][0] = 1;\n+                \n+                final double p3 =  params[3];\n+                final double p4 =  params[4];\n+                final double tOp3 = t / p3;\n+                final double tOp4 = t / p4;\n+                jacobian[i][1] = Math.exp(-tOp3);\n+                jacobian[i][2] = Math.exp(-tOp4);\n+                jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3;\n+                jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4;\n+            }\n+            return jacobian;\n+        }\n+\n+        public double[] value(double[] params) {\n+            double[] values = new double[time.size()];\n+            for (int i = 0; i < values.length; ++i) {\n+                final double t = time.get(i);\n+                values[i] = params[0]\n+                    + params[1] * Math.exp(-t / params[3])\n+                    + params[2] * Math.exp(-t / params[4]);\n+            }\n+            return values;\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+    }\n }", "timestamp": 1334760133, "metainfo": ""}