{"sha": "5908f8a7ae04be852b45b66ef6b12562b832cba8", "log": "Eliminated trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n                 public double value(double x, double y)  {\n                     final double x2 = x * x;\n                     final double[] pX = {0, 1, x, x2};\n-                    \n+\n                     final double y2 = y * y;\n                     final double y3 = y2 * y;\n                     final double[] pY = {1, y, y2, y3};\n                     final double x2 = x * x;\n                     final double x3 = x2 * x;\n                     final double[] pX = {1, x, x2, x3};\n-                    \n+\n                     final double y2 = y * y;\n                     final double[] pY = {0, 1, y, y2};\n \n         partialDerivativeXX = new BivariateRealFunction() {\n                 public double value(double x, double y)  {\n                     final double[] pX = {0, 0, 1, x};\n-                    \n+\n                     final double y2 = y * y;\n                     final double y3 = y2 * y;\n                     final double[] pY = {1, y, y2, y3};\n                     final double x2 = x * x;\n                     final double x3 = x2 * x;\n                     final double[] pX = {1, x, x2, x3};\n-                    \n+\n                     final double[] pY = {0, 0, 1, y};\n \n                     return apply(pX, pY, aYY);\n                 public double value(double x, double y)  {\n                     final double x2 = x * x;\n                     final double[] pX = {0, 1, x, x2};\n-                    \n+\n                     final double y2 = y * y;\n                     final double[] pY = {0, 1, y, y2};\n \n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n                         dFdZ[i][jp1][k], dFdZ[ip1][jp1][k],\n                         dFdZ[i][j][kp1], dFdZ[ip1][j][kp1],\n                         dFdZ[i][jp1][kp1], dFdZ[ip1][jp1][kp1],\n-                        \n+\n                         d2FdXdY[i][j][k], d2FdXdY[ip1][j][k],\n                         d2FdXdY[i][jp1][k], d2FdXdY[ip1][jp1][k],\n                         d2FdXdY[i][j][kp1], d2FdXdY[ip1][j][kp1],\n \n         return result;\n     }\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n                 if (fval[i][j].length != zLen) {\n                     throw new DimensionMismatchException(fval[i][j].length, zLen);\n                 }\n-                \n+\n                 for (int k = 0; k < zLen; k++) {\n                     final double v = fval[i][j][k];\n                     fvalXY[k][i][j] = v;\n                 for (int k = 0; k < zLen; k++) {\n                     final int nK = nextIndex(k, zLen);\n                     final int pK = previousIndex(k);\n-                    \n+\n                     // XXX Not sure about this formula\n                     d3FdXdYdZ[i][j][k] = (fval[nI][nJ][nK] - fval[nI][pJ][nK] -\n                                           fval[pI][nJ][nK] + fval[pI][pJ][nK] -\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n     public double getSparcity() {\n         return getSparsity();\n     }\n-    \n+\n     /**\n     *\n     * @return the percentage of none zero elements as a decimal percent.\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n                 if (checker != null) {\n                     // we use the vectorial convergence checker\n                     if (checker.converged(getIterations(), previous, current)) {\n-                        return current;                        \n+                        return current;\n                     }\n                 } else {\n                     // we use the Levenberg-Marquardt specific convergence parameters", "timestamp": 1275244474, "metainfo": ""}