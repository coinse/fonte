{"sha": "c95811b0a49700c8503e9e7dfc5532f728b4344e", "log": "added new cache-friendly specializations of get/set/operate/premultiply methods  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n     private static final long serialVersionUID = 4991895511313664478L;\n \n     /** Block size. */\n-    private static final int BLOCK_SIZE = 52;\n+    public static final int BLOCK_SIZE = 52;\n \n     /** Blocks of matrix entries. */\n     private final double blocks[][];\n     }\n \n     /** {@inheritDoc} */\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n+                                                                      null);             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        checkSubMatrixIndex(row, endRow, column, endColumn);\n+        for (final double[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n+                                                                          new Object[] {\n+                                                                              refLength, subRow.length\n+                                                                          }); \n+            }\n+        }\n+\n+        // compute blocks bounds\n+        final int blockStartRow    = row / BLOCK_SIZE;\n+        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartColumn = column / BLOCK_SIZE;\n+        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n+            final int iHeight  = blockHeight(iBlock);\n+            final int firstRow = iBlock * BLOCK_SIZE;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+\n+            for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n+                final int jWidth      = blockWidth(jBlock);\n+                final int firstColumn = jBlock * BLOCK_SIZE;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength     = jEnd - jStart;\n+\n+                // handle one block, row by row\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final DenseRealMatrix out = new DenseRealMatrix(1, columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        double[] outBlock = out.blocks[outBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = outBlock.length - outIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n+                outBlock = out.blocks[++outBlockIndex];\n+                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n+                outIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n+                outIndex += jWidth;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (DenseRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final DenseRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 matrix.getRowDimension(),\n+                                                 matrix.getColumnDimension(),\n+                                                 1, nCols\n+                                             });\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow   = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex  = 0;\n+        int mIndex       = 0;\n+        double[] mBlock  = matrix.blocks[mBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = mBlock.length - mIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n+                mBlock = matrix.blocks[++mBlockIndex];\n+                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n+                mIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n+                mIndex += jWidth;\n+           }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final DenseRealMatrix out = new DenseRealMatrix(rows, 1);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        double[] outBlock = out.blocks[outBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (outIndex >= outBlock.length) {\n+                    outBlock = out.blocks[++outBlockIndex];\n+                    outIndex = 0;\n+                }\n+                outBlock[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (DenseRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final DenseRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 matrix.getRowDimension(),\n+                                                 matrix.getColumnDimension(),\n+                                                 nRows, 1\n+                                             });\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int mBlockIndex = 0;\n+        int mIndex      = 0;\n+        double[] mBlock = matrix.blocks[mBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (mIndex >= mBlock.length) {\n+                    mBlock = matrix.blocks[++mBlockIndex];\n+                    mIndex = 0;\n+                }\n+                block[i * jWidth + jColumn] = mBlock[mIndex++];\n+            }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealVector getRowVector(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final RealVectorImpl out = new RealVectorImpl(columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        double[] outData  = out.getDataRef();\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((RealVectorImpl) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setRowVector(row, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getColumnVector(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final RealVectorImpl out = new RealVectorImpl(rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        double[] outData = out.getDataRef();\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                outData[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((RealVectorImpl) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setColumnVector(column, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final double[] out = new double[columns];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRow(final int row, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 1, array.length,\n+                                                 1, nCols\n+                                             });\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final double[] out = new double[rows];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                out[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumn(final int column, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                             new Object[] {\n+                                                 array.length, 1,\n+                                                 nRows, 1\n+                                             });\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                block[i * jWidth + jColumn] = array[outIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n     public double getEntry(final int row, final int column)\n         throws MatrixIndexException {\n         try {\n     public double[] operate(final double[] v)\n         throws IllegalArgumentException {\n \n-        final int nRows = this.getRowDimension();\n-        final int nCols = this.getColumnDimension();\n-        if (v.length != nCols) {\n-            throw new IllegalArgumentException(\"vector has wrong length\");\n-        }\n-        final double[] out = new double[nRows];\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.length, columns\n+                                                                      });\n+        }\n+        final double[] out = new double[rows];\n \n         // perform multiplication block-wise, to ensure good cache behavior\n-        int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n-                final double[] block  = blocks[blockIndex];\n-                final int      pStart = iBlock * BLOCK_SIZE;\n-                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      qStart = jBlock * BLOCK_SIZE;\n                 final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 for (int p = pStart, k = 0; p < pEnd; ++p) {\n                     }\n                     out[p] += sum;\n                 }\n-                ++blockIndex;\n-            }\n-        }\n-\n-        return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector operate(final RealVector v)\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] preMultiply(final double[] v)\n         throws IllegalArgumentException {\n-        try {\n-            return operate((RealVectorImpl) v);\n-        } catch (ClassCastException cce) {\n-            return super.operate(v);\n-        }\n-    }\n-\n-    /**\n-     * Returns the result of multiplying this by the vector <code>v</code>.\n-     *\n-     * @param v the vector to operate on\n-     * @return this*v\n-     * @throws IllegalArgumentException if columnDimension != v.size()\n-     */\n-    public RealVectorImpl operate(final RealVectorImpl v)\n-        throws IllegalArgumentException {\n-        return new RealVectorImpl(operate(v.getDataRef()), false);\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n+                                                                      \" got {0} but expected {1}\",\n+                                                                      new Object[] {\n+                                                                          v.length, rows\n+                                                                      });\n+        }\n+        final double[] out = new double[columns];\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth  = blockWidth(jBlock);\n+            final int jWidth2 = jWidth  + jWidth;\n+            final int jWidth3 = jWidth2 + jWidth;\n+            final int jWidth4 = jWidth3 + jWidth;\n+            final int qStart = jBlock * BLOCK_SIZE;\n+            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                for (int q = qStart; q < qEnd; ++q) {\n+                    int k = q - qStart;\n+                    double sum = 0;\n+                    int p = pStart;\n+                    while (p < pEnd - 3) {\n+                        sum += block[k]           * v[p]     +\n+                               block[k + jWidth]  * v[p + 1] +\n+                               block[k + jWidth2] * v[p + 2] +\n+                               block[k + jWidth3] * v[p + 3];\n+                        k += jWidth4;\n+                        p += 4;\n+                    }\n+                    while (p < pEnd) {\n+                        sum += block[k] * v[p++];\n+                        k += jWidth;\n+                    }\n+                    out[q] += sum;\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n  */\n package org.apache.commons.math.linear;\n \n+import java.util.Arrays;\n import java.util.Random;\n \n import junit.framework.Test;\n         }      \n     }\n \n+    public void testOperateLarge() {\n+        int p = (7 * DenseRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * DenseRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * DenseRealMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int p = (7 * DenseRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * DenseRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * DenseRealMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n     /** test issue MATH-209 */\n     public void testMath209() {\n         RealMatrix a = new DenseRealMatrix(new double[][] {\n         }\n     }\n     \n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        RealMatrix sub = new DenseRealMatrix(n - 4, n - 4).scalarAdd(1);\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+    \n     public void testGetRowMatrix() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m     = new DenseRealMatrix(subTestData);\n         RealMatrix mRow0 = new DenseRealMatrix(subRow0);\n         RealMatrix mRow3 = new DenseRealMatrix(subRow3);\n-        assertEquals(\"Row0\", mRow0, \n-                m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, \n-                m.getRowMatrix(3));\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n             fail(\"Expecting MatrixIndexException\");\n             // expected\n         }\n     }\n-    \n+\n     public void testSetRowMatrix() {\n         RealMatrix m = new DenseRealMatrix(subTestData);\n         RealMatrix mRow3 = new DenseRealMatrix(subRow3);\n         }\n     }\n     \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        RealMatrix sub = new DenseRealMatrix(1, n).scalarAdd(1);\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n     public void testGetColumnMatrix() {\n         RealMatrix m = new DenseRealMatrix(subTestData);\n         RealMatrix mColumn1 = new DenseRealMatrix(subColumn1);\n         }\n     }\n \n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        RealMatrix sub = new DenseRealMatrix(n, 1).scalarAdd(1);\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n     public void testGetRowVector() {\n         RealMatrix m = new DenseRealMatrix(subTestData);\n         RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n             // expected\n         }\n     }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        RealVector sub = new RealVectorImpl(n, 1.0);\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n     \n     public void testGetColumnVector() {\n         RealMatrix m = new DenseRealMatrix(subTestData);\n         }\n     }\n \n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        RealVector sub = new RealVectorImpl(n, 1.0);\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n     private RealVector columnToVector(double[][] column) {\n         double[] data = new double[column.length];\n         for (int i = 0; i < data.length; ++i) {\n             // expected\n         }\n     }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n     \n     public void testGetColumn() {\n         RealMatrix m = new DenseRealMatrix(subTestData);\n         }\n     }\n \n+    public void testGetSetColumnLarge() {\n+        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new DenseRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n     private double[] columnToArray(double[][] column) {\n         double[] data = new double[column.length];\n         for (int i = 0; i < data.length; ++i) {", "timestamp": 1230075033, "metainfo": ""}