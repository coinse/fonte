{"sha": "d3bb6ed8c136308643e428bb4c2892a1df061c21", "log": "MATH-689 Implemented \"copySign\" for integral types. Removed redundant \"indicator\" functions. Moved \"indicator\" tests (for floating point arguments) to \"FastMathTest\", as the corresponding \"copySign\" methods are in \"FastMath\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n      * where <ul>\n      * <li>{@code |a| = }{@link Math#abs}(a)</li>\n      * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n-     * <li>{@code sign(b) =  }{@link MathUtils#indicator}(b)\n+     * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n      * </ul>\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n             return createComplex(t, imaginary / (2.0 * t));\n         } else {\n             return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n-                                 MathUtils.indicator(imaginary) * t);\n+                                 FastMath.copySign(1d, imaginary) * t);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      */\n     public static int hash(double[] value) {\n         return Arrays.hashCode(value);\n-    }\n-\n-    /**\n-     * For a byte value x, this method returns (byte)(+1) if x >= 0 and\n-     * (byte)(-1) if x < 0.\n-     *\n-     * @param x the value, a byte\n-     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n-     */\n-    public static byte indicator(final byte x) {\n-        return (x >= ZB) ? PB : NB;\n-    }\n-\n-    /**\n-     * For a double precision value x, this method returns +1.0 if x >= 0 and\n-     * -1.0 if x < 0. Returns {@code NaN} if {@code x} is\n-     * {@code NaN}.\n-     *\n-     * @param x the value, a double\n-     * @return +1.0 or -1.0, depending on the sign of x\n-     */\n-    public static double indicator(final double x) {\n-        if (Double.isNaN(x)) {\n-            return Double.NaN;\n-        }\n-        return (x >= 0.0) ? 1.0 : -1.0;\n-    }\n-\n-    /**\n-     * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n-     * 0. Returns {@code NaN} if {@code x} is {@code NaN}.\n-     *\n-     * @param x the value, a float\n-     * @return +1.0F or -1.0F, depending on the sign of x\n-     */\n-    public static float indicator(final float x) {\n-        if (Float.isNaN(x)) {\n-            return Float.NaN;\n-        }\n-        return (x >= 0.0F) ? 1.0F : -1.0F;\n-    }\n-\n-    /**\n-     * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.\n-     *\n-     * @param x the value, an int\n-     * @return +1 or -1, depending on the sign of x\n-     */\n-    public static int indicator(final int x) {\n-        return (x >= 0) ? 1 : -1;\n-    }\n-\n-    /**\n-     * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.\n-     *\n-     * @param x the value, a long\n-     * @return +1L or -1L, depending on the sign of x\n-     */\n-    public static long indicator(final long x) {\n-        return (x >= 0L) ? 1L : -1L;\n-    }\n-\n-    /**\n-     * For a short value x, this method returns (short)(+1) if x >= 0 and\n-     * (short)(-1) if x < 0.\n-     *\n-     * @param x the value, a short\n-     * @return (short)(+1) or (short)(-1), depending on the sign of x\n-     */\n-    public static short indicator(final short x) {\n-        return (x >= ZS) ? PS : NS;\n     }\n \n     /**\n     }\n \n     /**\n+     * Returns the first argument with the sign of the second argument.\n+     *\n+     * @param magnitude Magnitude of the returned value.\n+     * @param sign Sign of the returned value.\n+     * @return a value with magnitude equal to {@code magnitude} and with the\n+     * same sign as the {@code sign} argument.\n+     * @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\n+     * and {@code sign >= 0}.\n+     */\n+    public static short copySign(short magnitude, short sign) {\n+        if ((magnitude >= 0 && sign >= 0) ||\n+            (magnitude < 0 && sign < 0)) { // Sign is OK.\n+            return magnitude;\n+        } else if (sign >= 0 &&\n+                   magnitude == Short.MIN_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n+        } else {\n+            return (short) -magnitude; // Flip sign.\n+        }\n+    }\n+\n+    /**\n+     * Returns the first argument with the sign of the second argument.\n+     *\n+     * @param magnitude Magnitude of the returned value.\n+     * @param sign Sign of the returned value.\n+     * @return a value with magnitude equal to {@code magnitude} and with the\n+     * same sign as the {@code sign} argument.\n+     * @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\n+     * and {@code sign >= 0}.\n+     */\n+    public static int copySign(int magnitude, int sign) {\n+        if ((magnitude >= 0 && sign >= 0) ||\n+            (magnitude < 0 && sign < 0)) { // Sign is OK.\n+            return magnitude;\n+        } else if (sign >= 0 &&\n+                   magnitude == Integer.MIN_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n+        } else {\n+            return (int) -magnitude; // Flip sign.\n+        }\n+    }\n+\n+    /**\n+     * Returns the first argument with the sign of the second argument.\n+     *\n+     * @param magnitude Magnitude of the returned value.\n+     * @param sign Sign of the returned value.\n+     * @return a value with magnitude equal to {@code magnitude} and with the\n+     * same sign as the {@code sign} argument.\n+     * @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\n+     * and {@code sign >= 0}.\n+     */\n+    public static long copySign(long magnitude, long sign) {\n+        if ((magnitude >= 0 && sign >= 0) ||\n+            (magnitude < 0 && sign < 0)) { // Sign is OK.\n+            return magnitude;\n+        } else if (sign >= 0 &&\n+                   magnitude == Long.MIN_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n+        } else {\n+            return (long) -magnitude; // Flip sign.\n+        }\n+    }\n+\n+    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n      * for int value {@code x}.\n      * <p>\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n         Assert.assertEquals(0, FastMath.log(0, 10), 0);\n         Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.log(10, 0), 0);\n     }\n+\n+    @Test\n+    public void testIndicatorDouble() {\n+        double delta = 0.0;\n+        Assert.assertEquals(1.0, FastMath.copySign(1d, 2.0), delta);\n+        Assert.assertEquals(1.0, FastMath.copySign(1d, 0.0), delta);\n+        Assert.assertEquals(-1.0, FastMath.copySign(1d, -2.0), delta);\n+    }\n+\n+    @Test\n+    public void testIndicatorFloat() {\n+        float delta = 0.0F;\n+        Assert.assertEquals(1.0F, FastMath.copySign(1d, 2.0F), delta);\n+        Assert.assertEquals(1.0F, FastMath.copySign(1d, 0.0F), delta);\n+        Assert.assertEquals(-1.0F, FastMath.copySign(1d, -2.0F), delta);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n \n     @Test\n     public void testIndicatorByte() {\n-        Assert.assertEquals((byte)1, MathUtils.indicator((byte)2));\n-        Assert.assertEquals((byte)1, MathUtils.indicator((byte)0));\n-        Assert.assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));\n-    }\n-\n-    @Test\n-    public void testIndicatorDouble() {\n-        double delta = 0.0;\n-        Assert.assertEquals(1.0, MathUtils.indicator(2.0), delta);\n-        Assert.assertEquals(1.0, MathUtils.indicator(0.0), delta);\n-        Assert.assertEquals(-1.0, MathUtils.indicator(-2.0), delta);\n-        Assert.assertTrue(Double.isNaN(MathUtils.indicator(Double.NaN)));\n-    }\n-\n-    @Test\n-    public void testIndicatorFloat() {\n-        float delta = 0.0F;\n-        Assert.assertEquals(1.0F, MathUtils.indicator(2.0F), delta);\n-        Assert.assertEquals(1.0F, MathUtils.indicator(0.0F), delta);\n-        Assert.assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);\n+        Assert.assertEquals((byte)1, MathUtils.copySign((byte)1, (byte)2));\n+        Assert.assertEquals((byte)1, MathUtils.copySign((byte)1, (byte)0));\n+        Assert.assertEquals((byte)(-1), MathUtils.copySign((byte)1, (byte)(-2)));\n     }\n \n     @Test\n     public void testIndicatorInt() {\n-        Assert.assertEquals(1, MathUtils.indicator((2)));\n-        Assert.assertEquals(1, MathUtils.indicator((0)));\n-        Assert.assertEquals((-1), MathUtils.indicator((-2)));\n+        Assert.assertEquals(1, MathUtils.copySign(1, 2));\n+        Assert.assertEquals(1, MathUtils.copySign(1, 0));\n+        Assert.assertEquals((-1), MathUtils.copySign(1, -2));\n     }\n \n     @Test\n     public void testIndicatorLong() {\n-        Assert.assertEquals(1L, MathUtils.indicator(2L));\n-        Assert.assertEquals(1L, MathUtils.indicator(0L));\n-        Assert.assertEquals(-1L, MathUtils.indicator(-2L));\n+        Assert.assertEquals(1L, MathUtils.copySign(1L, 2L));\n+        Assert.assertEquals(1L, MathUtils.copySign(1L, 0L));\n+        Assert.assertEquals(-1L, MathUtils.copySign(1L, -2L));\n     }\n \n     @Test\n     public void testIndicatorShort() {\n-        Assert.assertEquals((short)1, MathUtils.indicator((short)2));\n-        Assert.assertEquals((short)1, MathUtils.indicator((short)0));\n-        Assert.assertEquals((short)(-1), MathUtils.indicator((short)(-2)));\n+        Assert.assertEquals((short)1, MathUtils.copySign((short)1, (short)2));\n+        Assert.assertEquals((short)1, MathUtils.copySign((short)1, (short)0));\n+        Assert.assertEquals((short)(-1), MathUtils.copySign((short)1, (short)(-2)));\n     }\n \n     @Test", "timestamp": 1322244141, "metainfo": ""}