{"sha": "fee41d9dbb6bfe3f21b79aed24ee546e25bad501", "log": "Merged FieldLUDecomposition and FieldLUDecompositionImpl (see MATH-662).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n \n package org.apache.commons.math.linear;\n \n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n- * An interface to classes that implement an algorithm to calculate the\n- * LU-decomposition of a real matrix.\n- * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n- * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n- * to rearrange the rows of A before so that it can be decomposed. L is a lower\n- * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n- * <p>This interface is based on the class with similar name from the\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices\n+ * L, U and P that satisfy: PA = LU, L is lower triangular, and U is\n+ * upper triangular and P is a permutation matrix. All matrices are\n+ * m&times;m.</p>\n+ * <p>Since {@link FieldElement field elements} do not provide an ordering\n+ * operator, the permutation matrix is computed here only in order to avoid\n+ * a zero pivot element, no attempt is done to get the largest pivot\n+ * element.</p>\n+ * <p>This class is based on the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n  * <ul>\n  *   <li>a {@link #getP() getP} method has been added,</li>\n- *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant()\n+ *   <li>the {@code det} method has been renamed as {@link #getDeterminant()\n  *   getDeterminant},</li>\n- *   <li>the <code>getDoublePivot</code> method has been removed (but the int based\n+ *   <li>the {@code getDoublePivot} method has been removed (but the int based\n  *   {@link #getPivot() getPivot} method has been kept),</li>\n- *   <li>the <code>solve</code> and <code>isNonSingular</code> methods have been replaced\n- *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n- *   the returned {@link DecompositionSolver}.</li>\n+ *   <li>the {@code solve} and {@code isNonSingular} methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods\n+ *   provided by the returned {@link DecompositionSolver}.</li>\n  * </ul>\n  *\n  * @param <T> the type of the field elements\n  * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n  * @version $Id$\n- * @since 2.0\n+ * @since 2.0 (changed to concrete class in 3.0)\n  */\n-public interface FieldLUDecomposition<T extends FieldElement<T>> {\n+public class FieldLUDecomposition<T extends FieldElement<T>> {\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Entries of LU decomposition. */\n+    private T[][] lu;\n+\n+    /** Pivot permutation associated with LU decomposition. */\n+    private int[] pivot;\n+\n+    /** Parity of the permutation associated with the LU decomposition. */\n+    private boolean even;\n+\n+    /** Singularity indicator. */\n+    private boolean singular;\n+\n+    /** Cached value of L. */\n+    private FieldMatrix<T> cachedL;\n+\n+    /** Cached value of U. */\n+    private FieldMatrix<T> cachedU;\n+\n+    /** Cached value of P. */\n+    private FieldMatrix<T> cachedP;\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     * @throws NonSquareMatrixException if matrix is not square\n+     */\n+    public FieldLUDecomposition(FieldMatrix<T> matrix) {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getColumnDimension();\n+        field = matrix.getField();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        even     = true;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            T sum = field.getZero();\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final T[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int nonZero = col; // permutation row\n+            for (int row = col; row < m; row++) {\n+                final T[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+\n+                if (lu[nonZero][col].equals(field.getZero())) {\n+                    // try to select a better permutation choice\n+                    ++nonZero;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (nonZero >= m) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (nonZero != col) {\n+                T tmp = field.getZero();\n+                for (int i = 0; i < m; i++) {\n+                    tmp = lu[nonZero][i];\n+                    lu[nonZero][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[nonZero];\n+                pivot[nonZero] = pivot[col];\n+                pivot[col] = temp;\n+                even = !even;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final T luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                final T[] luRow = lu[row];\n+                luRow[col] = luRow[col].divide(luDiag);\n+            }\n+        }\n+\n+    }\n \n     /**\n      * Returns the matrix L of the decomposition.\n-     * <p>L is an lower-triangular matrix</p>\n+     * <p>L is a lower-triangular matrix</p>\n      * @return the L matrix (or null if decomposed matrix is singular)\n      */\n-    FieldMatrix<T> getL();\n+    public FieldMatrix<T> getL() {\n+        if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedL = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final T[] luI = lu[i];\n+                for (int j = 0; j < i; ++j) {\n+                    cachedL.setEntry(i, j, luI[j]);\n+                }\n+                cachedL.setEntry(i, i, field.getOne());\n+            }\n+        }\n+        return cachedL;\n+    }\n \n     /**\n      * Returns the matrix U of the decomposition.\n      * <p>U is an upper-triangular matrix</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n      */\n-    FieldMatrix<T> getU();\n+    public FieldMatrix<T> getU() {\n+        if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedU = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final T[] luI = lu[i];\n+                for (int j = i; j < m; ++j) {\n+                    cachedU.setEntry(i, j, luI[j]);\n+                }\n+            }\n+        }\n+        return cachedU;\n+    }\n \n     /**\n      * Returns the P rows permutation matrix.\n      * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n      * @see #getPivot()\n      */\n-    FieldMatrix<T> getP();\n+    public FieldMatrix<T> getP() {\n+        if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                cachedP.setEntry(i, pivot[i], field.getOne());\n+            }\n+        }\n+        return cachedP;\n+    }\n \n     /**\n      * Returns the pivot permutation vector.\n      * @return the pivot permutation vector\n      * @see #getP()\n      */\n-    int[] getPivot();\n-\n-    /**\n-     * Return the determinant of the matrix\n+    public int[] getPivot() {\n+        return pivot.clone();\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix.\n      * @return determinant of the matrix\n      */\n-    T getDeterminant();\n+    public T getDeterminant() {\n+        if (singular) {\n+            return field.getZero();\n+        } else {\n+            final int m = pivot.length;\n+            T determinant = even ? field.getOne() : field.getZero().subtract(field.getOne());\n+            for (int i = 0; i < m; i++) {\n+                determinant = determinant.multiply(lu[i][i]);\n+            }\n+            return determinant;\n+        }\n+    }\n \n     /**\n      * Get a solver for finding the A &times; X = B solution in exact linear sense.\n      * @return a solver\n      */\n-    FieldDecompositionSolver<T> getSolver();\n-\n+    public FieldDecompositionSolver<T> getSolver() {\n+        return new Solver<T>(field, lu, pivot, singular);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver<T extends FieldElement<T>> implements FieldDecompositionSolver<T> {\n+\n+        /** Field to which the elements belong. */\n+        private final Field<T> field;\n+\n+        /** Entries of LU decomposition. */\n+        private final T[][] lu;\n+\n+        /** Pivot permutation associated with LU decomposition. */\n+        private final int[] pivot;\n+\n+        /** Singularity indicator. */\n+        private final boolean singular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param field field to which the matrix elements belong\n+         * @param lu entries of LU decomposition\n+         * @param pivot pivot permutation associated with LU decomposition\n+         * @param singular singularity indicator\n+         */\n+        private Solver(final Field<T> field, final T[][] lu,\n+                       final int[] pivot, final boolean singular) {\n+            this.field    = field;\n+            this.lu       = lu;\n+            this.pivot    = pivot;\n+            this.singular = singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return !singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public FieldVector<T> solve(FieldVector<T> b) {\n+            try {\n+                return solve((ArrayFieldVector<T>) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = pivot.length;\n+                if (b.getDimension() != m) {\n+                    throw new DimensionMismatchException(b.getDimension(), m);\n+                }\n+                if (singular) {\n+                    throw new SingularMatrixException();\n+                }\n+\n+                @SuppressWarnings(\"unchecked\") // field is of type T\n+                final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n+\n+                // Apply permutations to b\n+                for (int row = 0; row < m; row++) {\n+                    bp[row] = b.getEntry(pivot[row]);\n+                }\n+\n+                // Solve LY = b\n+                for (int col = 0; col < m; col++) {\n+                    final T bpCol = bp[col];\n+                    for (int i = col + 1; i < m; i++) {\n+                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                    }\n+                }\n+\n+                // Solve UX = Y\n+                for (int col = m - 1; col >= 0; col--) {\n+                    bp[col] = bp[col].divide(lu[col][col]);\n+                    final T bpCol = bp[col];\n+                    for (int i = 0; i < col; i++) {\n+                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                    }\n+                }\n+\n+                return new ArrayFieldVector<T>(field, bp, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n+         */\n+        public ArrayFieldVector<T> solve(ArrayFieldVector<T> b) {\n+            final int m = pivot.length;\n+            if (b.data.length != m) {\n+                throw new DimensionMismatchException(b.data.length, m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            // field is of type T\n+            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(),\n+                                                   m);\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b.data[pivot[row]];\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] = bp[col].divide(lu[col][col]);\n+                final T bpCol = bp[col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            return new ArrayFieldVector<T>(bp, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public FieldMatrix<T> solve(FieldMatrix<T> b) {\n+            final int m = pivot.length;\n+            if (b.getRowDimension() != m) {\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+\n+            // Apply permutations to b\n+            @SuppressWarnings(\"unchecked\") // field is of type T\n+            final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n+            for (int row = 0; row < m; row++) {\n+                final T[] bpRow = bp[row];\n+                final int pRow = pivot[row];\n+                for (int col = 0; col < nColB; col++) {\n+                    bpRow[col] = b.getEntry(pRow, col);\n+                }\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T[] bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    final T[] bpI = bp[i];\n+                    final T luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n+                    }\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                final T[] bpCol = bp[col];\n+                final T luDiag = lu[col][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpCol[j] = bpCol[j].divide(luDiag);\n+                }\n+                for (int i = 0; i < col; i++) {\n+                    final T[] bpI = bp[i];\n+                    final T luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowFieldMatrix<T>(field, bp, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public FieldMatrix<T> getInverse() {\n+            final int m = pivot.length;\n+            final T one = field.getOne();\n+            FieldMatrix<T> identity = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                identity.setEntry(i, i, one);\n+            }\n+            return solve(identity);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.ArrayFieldVector;\n import org.apache.commons.math.linear.FieldDecompositionSolver;\n-import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldLUDecomposition;\n import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.QRDecomposition;\n         // compute exact coefficients\n         FieldMatrix<BigFraction> bigP = buildP(nSteps);\n         FieldDecompositionSolver<BigFraction> pSolver =\n-            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver();\n+            new FieldLUDecomposition<BigFraction>(bigP).getSolver();\n \n         BigFraction[] u = new BigFraction[nSteps];\n         Arrays.fill(u, BigFraction.ONE);\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n     @Test\n     public void testTranspose() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n-        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n-        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(mIT, mTI);\n         m = new BlockFieldMatrix<Fraction>(testData2);\n         FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);\n         Assert.assertEquals(2, p.getRowDimension());\n         Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse();\n         Assert.assertEquals(2, pInverse.getRowDimension());\n         Assert.assertEquals(2, pInverse.getColumnDimension());\n \n             new Fraction(1), new Fraction(-2), new Fraction(1)\n         };\n         Fraction[] solution;\n-        solution = new FieldLUDecompositionImpl<Fraction>(coefficients)\n+        solution = new FieldLUDecomposition<Fraction>(coefficients)\n             .getSolver()\n             .solve(new ArrayFieldVector<Fraction>(constants, false)).toArray();\n         Assert.assertEquals(new Fraction(2).multiply(solution[0]).\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+public class FieldLUDecompositionTest {\n+    private Fraction[][] testData = {\n+            { new Fraction(1), new Fraction(2), new Fraction(3)},\n+            { new Fraction(2), new Fraction(5), new Fraction(3)},\n+            { new Fraction(1), new Fraction(0), new Fraction(8)}\n+    };\n+    private Fraction[][] testDataMinus = {\n+            { new Fraction(-1), new Fraction(-2), new Fraction(-3)},\n+            { new Fraction(-2), new Fraction(-5), new Fraction(-3)},\n+            { new Fraction(-1),  new Fraction(0), new Fraction(-8)}\n+    };\n+    private Fraction[][] luData = {\n+            { new Fraction(2), new Fraction(3), new Fraction(3) },\n+            { new Fraction(2), new Fraction(3), new Fraction(7) },\n+            { new Fraction(6), new Fraction(6), new Fraction(8) }\n+    };\n+\n+    // singular matrices\n+    private Fraction[][] singular = {\n+            { new Fraction(2), new Fraction(3) },\n+            { new Fraction(2), new Fraction(3) }\n+    };\n+    private Fraction[][] bigSingular = {\n+            { new Fraction(1), new Fraction(2),   new Fraction(3),    new Fraction(4) },\n+            { new Fraction(2), new Fraction(5),   new Fraction(3),    new Fraction(4) },\n+            { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) },\n+            { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }\n+    }; // 4th row = 1st + 2nd\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        FieldMatrix<Fraction> matrix =\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n+        FieldLUDecomposition<Fraction> LU = new FieldLUDecomposition<Fraction>(matrix);\n+        Assert.assertEquals(testData.length, LU.getL().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getL().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    @Test\n+    public void testNonSquare() {\n+        try {\n+            // we don't use FractionField.getInstance() for testing purposes\n+            new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                    { Fraction.ZERO, Fraction.ZERO },\n+                    { Fraction.ZERO, Fraction.ZERO },\n+                    { Fraction.ZERO, Fraction.ZERO }\n+            }));\n+            Assert.fail(\"Expected NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ime) {\n+            // expected behavior\n+        }\n+    }\n+\n+    /** test PA = LU */\n+    @Test\n+    public void testPAEqualLU() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n+        FieldLUDecomposition<Fraction> lu = new FieldLUDecomposition<Fraction>(matrix);\n+        FieldMatrix<Fraction> l = lu.getL();\n+        FieldMatrix<Fraction> u = lu.getU();\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataMinus);\n+        lu = new FieldLUDecomposition<Fraction>(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            matrix.setEntry(i, i, Fraction.ONE);\n+        }\n+        lu = new FieldLUDecomposition<Fraction>(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular);\n+        lu = new FieldLUDecomposition<Fraction>(matrix);\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular);\n+        lu = new FieldLUDecomposition<Fraction>(matrix);\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    @Test\n+    public void testLLowerTriangular() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n+        FieldMatrix<Fraction> l = new FieldLUDecomposition<Fraction>(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            Assert.assertEquals(Fraction.ONE, l.getEntry(i, i));\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                Assert.assertEquals(Fraction.ZERO, l.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    @Test\n+    public void testUUpperTriangular() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n+        FieldMatrix<Fraction> u = new FieldLUDecomposition<Fraction>(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                Assert.assertEquals(Fraction.ZERO, u.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    @Test\n+    public void testPPermutation() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n+        FieldMatrix<Fraction> p   = new FieldLUDecomposition<Fraction>(matrix).getP();\n+\n+        FieldMatrix<Fraction> ppT = p.multiply(p.transpose());\n+        FieldMatrix<Fraction> id  =\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),\n+                                          p.getRowDimension(), p.getRowDimension());\n+        for (int i = 0; i < id.getRowDimension(); ++i) {\n+            id.setEntry(i, i, Fraction.ONE);\n+        }\n+        TestUtils.assertEquals(id, ppT);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final Fraction e = p.getEntry(i, j);\n+                if (e.equals(Fraction.ZERO)) {\n+                    ++zeroCount;\n+                } else if (e.equals(Fraction.ONE)) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final Fraction e = p.getEntry(i, j);\n+                if (e.equals(Fraction.ZERO)) {\n+                    ++zeroCount;\n+                } else if (e.equals(Fraction.ONE)) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            Assert.assertEquals(p.getRowDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+\n+    /** test singular */\n+    @Test\n+    public void testSingular() {\n+        FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));\n+        Assert.assertTrue(lu.getSolver().isNonSingular());\n+        lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular));\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular));\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+    }\n+\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues1() {\n+       FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(2), new Fraction(1), new Fraction(0) },\n+                { new Fraction(1), new Fraction(-2), new Fraction(1) }\n+        });\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n+                { new Fraction(1),  new Fraction(2), new Fraction(3) },\n+                { new Fraction(0), new Fraction(1), new Fraction(-3) },\n+                { new Fraction(0),  new Fraction(0), new Fraction(-1) }\n+        });\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(0), new Fraction(1), new Fraction(0) },\n+                { new Fraction(0), new Fraction(0), new Fraction(1) }\n+        });\n+        int[] pivotRef = { 0, 1, 2 };\n+\n+        // check values against known references\n+        FieldMatrix<Fraction> l = lu.getL();\n+        TestUtils.assertEquals(lRef, l);\n+        FieldMatrix<Fraction> u = lu.getU();\n+        TestUtils.assertEquals(uRef, u);\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(pRef, p);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n+\n+    }\n+\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues2() {\n+       FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), luData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(3), new Fraction(1), new Fraction(0) },\n+                { new Fraction(1), new Fraction(0), new Fraction(1) }\n+        });\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n+                { new Fraction(2), new Fraction(3), new Fraction(3)    },\n+                { new Fraction(0), new Fraction(-3), new Fraction(-1)  },\n+                { new Fraction(0), new Fraction(0), new Fraction(4) }\n+        });\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(0), new Fraction(0), new Fraction(1) },\n+                { new Fraction(0), new Fraction(1), new Fraction(0) }\n+        });\n+        int[] pivotRef = { 0, 2, 1 };\n+\n+        // check values against known references\n+        FieldMatrix<Fraction> l = lu.getL();\n+        TestUtils.assertEquals(lRef, l);\n+        FieldMatrix<Fraction> u = lu.getU();\n+        TestUtils.assertEquals(uRef, u);\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(pRef, p);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/FieldLUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUSolverTest.java\n     @Test\n     public void testSingular() {\n         FieldDecompositionSolver<Fraction> solver;\n-        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(testData))\n+        solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(testData))\n             .getSolver();\n         Assert.assertTrue(solver.isNonSingular());\n-        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(singular))\n+        solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(singular))\n             .getSolver();\n         Assert.assertFalse(solver.isNonSingular());\n-        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(bigSingular))\n+        solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(bigSingular))\n             .getSolver();\n         Assert.assertFalse(solver.isNonSingular());\n     }\n     @Test\n     public void testSolveDimensionErrors() {\n         FieldDecompositionSolver<Fraction> solver;\n-        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(testData))\n+        solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(testData))\n             .getSolver();\n         FieldMatrix<Fraction> b = createFractionMatrix(new int[2][2]);\n         try {\n     @Test\n     public void testSolveSingularityErrors() {\n         FieldDecompositionSolver solver;\n-        solver = new FieldLUDecompositionImpl(createFractionMatrix(singular))\n+        solver = new FieldLUDecomposition(createFractionMatrix(singular))\n             .getSolver();\n         FieldMatrix b = createFractionMatrix(new int[2][2]);\n         try {\n     @Test\n     public void testSolve() {\n         FieldDecompositionSolver solver;\n-        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(testData))\n+        solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(testData))\n             .getSolver();\n         FieldMatrix<Fraction> b = createFractionMatrix(new int[][] {\n                 { 1, 0 }, { 2, -5 }, { 3, 1 }\n     }\n \n     private double getDeterminant(final FieldMatrix<Fraction> m) {\n-        return new FieldLUDecompositionImpl<Fraction>(m).getDeterminant().doubleValue();\n+        return new FieldLUDecomposition<Fraction>(m).getDeterminant().doubleValue();\n     }\n }\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n     @Test\n     public void testTranspose() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n-        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n-        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(mIT, mTI);\n         m = new Array2DRowFieldMatrix<Fraction>(testData2);\n         FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);\n         Assert.assertEquals(2, p.getRowDimension());\n         Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse();\n         Assert.assertEquals(2, pInverse.getRowDimension());\n         Assert.assertEquals(2, pInverse.getColumnDimension());\n \n             new Fraction(1), new Fraction(-2), new Fraction(1)\n         };\n         Fraction[] solution;\n-        solution = new FieldLUDecompositionImpl<Fraction>(coefficients)\n+        solution = new FieldLUDecomposition<Fraction>(coefficients)\n             .getSolver()\n             .solve(new ArrayFieldVector<Fraction>(constants, false)).toArray();\n         Assert.assertEquals(new Fraction(2).multiply(solution[0]).\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n     @Test\n     public void testTranspose() {\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n-        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n-        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse();\n         assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = createSparseMatrix(testData2);\n         FieldMatrix<Fraction> mt = createSparseMatrix(testData2T);\n         Assert.assertEquals(2, p.getRowDimension());\n         Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse();\n         Assert.assertEquals(2, pInverse.getRowDimension());\n         Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);\n         Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };\n         Fraction[] solution;\n-        solution = new FieldLUDecompositionImpl<Fraction>(coefficients)\n+        solution = new FieldLUDecomposition<Fraction>(coefficients)\n             .getSolver()\n             .solve(new ArrayFieldVector<Fraction>(constants, false)).toArray();\n         Assert.assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),", "timestamp": 1316759579, "metainfo": ""}