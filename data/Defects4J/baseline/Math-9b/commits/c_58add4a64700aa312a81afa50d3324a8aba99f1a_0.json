{"sha": "58add4a64700aa312a81afa50d3324a8aba99f1a", "log": "changed Nordsieck transformer to an Adams-specific Nordsieck transformer the transformer associated with BDF integrator will be quite different  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.FieldDecompositionSolver;\n+import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/** Transformer to Nordsieck vectors for Adams integrators.\n+ * <p>This class i used by {@link AdamsBashforthIntegrator Adams-Bashforth} and\n+ * {@link AdamsMoultonIntegrator Adams-Moulton} integrators to convert between\n+ * classical representation with several previous first derivatives and Nordsieck\n+ * representation with higher order scaled derivatives.</p>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>With the previous definition, the classical representation of multistep methods\n+ * uses first derivatives only, i.e. it handles y<sub>n</sub>, s<sub>1</sub>(n) and\n+ * q<sub>n</sub> where q<sub>n</sub> is defined as:\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity).</p>\n+ *\n+ * <p>Another possible representation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step, i.e it handles y<sub>n</sub>,\n+ * s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector at step end. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ *\n+ * <p>Changing -i into +i in the formula above can be used to compute a similar transform between\n+ * classical representation and Nordsieck vector at step start. The resulting matrix is simply\n+ * the absolute value of matrix P.</p>\n+ *\n+ * <p>For {@link AdamsBashforthIntegrator Adams-Bashforth} method, the Nordsieck vector\n+ * at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre></p>\n+ *\n+ * <p>For {@link AdamsMoultonIntegrator Adams-Moulton} method, the predicted Nordsieck vector\n+ * at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n+ *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * From this predicted vector, the corrected vector is computed as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + S<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = R<sub>n+1</sub> + (s<sub>1</sub>(n+1) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>\n+ * </ul>\n+ * where the upper case Y<sub>n+1</sub>, S<sub>1</sub>(n+1) and R<sub>n+1</sub> represent the\n+ * predicted states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>\n+ * represent the corrected states.</p>\n+ *\n+ * <p>We observe that both methods use similar update formulas. In both cases a P<sup>-1</sup>u\n+ * vector and a P<sup>-1</sup> A P matrix are used that do not depend on the state,\n+ * they only depend on k. This class handles these transformations.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsNordsieckTransformer {\n+\n+    /** Cache for already computed coefficients. */\n+    private static final Map<Integer, AdamsNordsieckTransformer> cache =\n+        new HashMap<Integer, AdamsNordsieckTransformer>();\n+\n+    /** Initialization matrix for the higher order derivatives wrt y'', y''' ... */\n+    private final Array2DRowRealMatrix initialization;\n+\n+    /** Update matrix for the higher order derivatives h<sup>2</sup>/2y'', h<sup>3</sup>/6 y''' ... */\n+    private final Array2DRowRealMatrix update;\n+\n+    /** Update coefficients of the higher order derivatives wrt y'. */\n+    private final double[] c1;\n+\n+    /** Simple constructor.\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     */\n+    private AdamsNordsieckTransformer(final int nSteps) {\n+\n+        // compute exact coefficients\n+        FieldMatrix<BigFraction> bigP = buildP(nSteps);\n+        FieldDecompositionSolver<BigFraction> pSolver =\n+            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver();\n+\n+        BigFraction[] u = new BigFraction[nSteps];\n+        Arrays.fill(u, BigFraction.ONE);\n+        BigFraction[] bigC1 = pSolver.solve(u);\n+\n+        // update coefficients are computed by combining transform from\n+        // Nordsieck to multistep, then shifting rows to represent step advance\n+        // then applying inverse transform\n+        BigFraction[][] shiftedP = bigP.getData();\n+        for (int i = shiftedP.length - 1; i > 0; --i) {\n+            // shift rows\n+            shiftedP[i] = shiftedP[i - 1];\n+        }\n+        shiftedP[0] = new BigFraction[nSteps];\n+        Arrays.fill(shiftedP[0], BigFraction.ZERO);\n+        FieldMatrix<BigFraction> bigMSupdate =\n+            pSolver.solve(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n+\n+        // initialization coefficients, computed from a R matrix = abs(P)\n+        bigP.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<BigFraction>(BigFraction.ZERO) {\n+            /** {@inheritDoc} */\n+            @Override\n+            public BigFraction visit(int row, int column, BigFraction value) {\n+                return ((column & 0x1) == 0x1) ? value : value.negate();\n+            }\n+        });\n+        FieldMatrix<BigFraction> bigRInverse =\n+            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver().getInverse();\n+\n+        // convert coefficients to double\n+        initialization = MatrixUtils.bigFractionMatrixToRealMatrix(bigRInverse);\n+        update         = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n+        c1             = new double[nSteps];\n+        for (int i = 0; i < nSteps; ++i) {\n+            c1[i] = bigC1[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** Get the Nordsieck transformer for a given number of steps.\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     * @return Nordsieck transformer for the specified number of steps\n+     */\n+    public static AdamsNordsieckTransformer getInstance(final int nSteps) {\n+        synchronized(cache) {\n+            AdamsNordsieckTransformer t = cache.get(nSteps);\n+            if (t == null) {\n+                t = new AdamsNordsieckTransformer(nSteps);\n+                cache.put(nSteps, t);\n+            }\n+            return t;\n+        }\n+    }\n+\n+    /** Get the number of steps of the method\n+     * (excluding the one being computed).\n+     * @return number of steps of the method\n+     * (excluding the one being computed)\n+     */\n+    public int getNSteps() {\n+        return c1.length;\n+    }\n+\n+    /** Build the P matrix.\n+     * <p>The P matrix general terms are shifted j (-i)<sup>j-1</sup> terms:\n+     * <pre>\n+     *        [  -2   3   -4    5  ... ]\n+     *        [  -4  12  -32   80  ... ]\n+     *   P =  [  -6  27 -108  405  ... ]\n+     *        [  -8  48 -256 1280  ... ]\n+     *        [          ...           ]\n+     * </pre></p>\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     * @return P matrix\n+     */\n+    private FieldMatrix<BigFraction> buildP(final int nSteps) {\n+\n+        final BigFraction[][] pData = new BigFraction[nSteps][nSteps];\n+\n+        for (int i = 0; i < pData.length; ++i) {\n+            // build the P matrix elements from Taylor series formulas\n+            final BigFraction[] pI = pData[i];\n+            final int factor = -(i + 1);\n+            int aj = factor;\n+            for (int j = 0; j < pI.length; ++j) {\n+                pI[j] = new BigFraction(aj * (j + 2));\n+                aj *= factor;\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n+\n+    }\n+\n+    /** Initialize the high order scaled derivatives at step start.\n+     * @param first first scaled derivative at step start\n+     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+     * will be modified\n+     * @return high order derivatives at step start\n+     */\n+    public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                     final double[][] multistep) {\n+        for (int i = 0; i < multistep.length; ++i) {\n+            final double[] msI = multistep[i];\n+            for (int j = 0; j < first.length; ++j) {\n+                msI[j] -= first[j];\n+            }\n+        }\n+        return initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n+    }\n+\n+    /** Update the high order scaled derivatives for Adams integrators (phase 1).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n+     * @param highOrder high order scaled derivatives\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @return updated high order derivatives\n+     * @see #updateHighOrderDerivativesPhase2(double[], double[], RealMatrix)\n+     */\n+    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n+        return update.multiply(highOrder);\n+    }\n+\n+    /** Update the high order scaled derivatives Adams integrators (phase 2).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n+     * <p>Phase 1 of the update must already have been performed.</p>\n+     * @param start first order scaled derivatives at step start\n+     * @param end first order scaled derivatives at step end\n+     * @param highOrder high order scaled derivatives, will be modified\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @see #updateHighOrderDerivativesPhase1(RealMatrix)\n+     */\n+    public void updateHighOrderDerivativesPhase2(final double[] start,\n+                                                 final double[] end,\n+                                                 final RealMatrix highOrder) {\n+        highOrder.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            /** {@inheritDoc} */\n+            @Override\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                return value + c1[row] * (start[column] - end[column]);\n+            }\n+        });\n+    }\n+\n+}", "timestamp": 1246226073, "metainfo": ""}