{"sha": "b2e4c7c1b81d8b54ad6dcd589c0d730c764fad08", "log": "added utility methods to help serialize/deserialize classes that have RealVector/RealMatrix fields (possibly final) since the top level interfaces are not serializable anymore  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n \n package org.apache.commons.math.linear;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.lang.reflect.Array;\n import java.math.BigDecimal;\n import java.util.Arrays;\n \n     }\n \n+    /** Serialize a {@link RealVector}.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>writeObject</code> method (after a call to\n+     * <code>oos.defaultWriteObject()</code>) in a class that has a\n+     * {@link RealVector} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not serialize the vector (the {@link\n+     * RealVector} interface is not serializable by default) but this method does\n+     * serialize it specifically.\n+     * </p>\n+     * <p>\n+     * The following example shows how a simple class with a name and a real vector\n+     * should be written:\n+     * <pre><code>\n+     * public class NamedVector implements Serializable {\n+     *\n+     *     private final String name;\n+     *     private final transient RealVector coefficients;\n+     *\n+     *     // omitted constructors, getters ...\n+     *\n+     *     private void writeObject(ObjectOutputStream oos) throws IOException {\n+     *         oos.defaultWriteObject();  // takes care of name field\n+     *         MatrixUtils.serializeRealVector(coefficients, oos);\n+     *     }\n+     *\n+     *     private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n+     *         ois.defaultReadObject();  // takes care of name field\n+     *         MatrixUtils.deserializeRealVector(this, \"coefficients\", ois);\n+     *     }\n+     *\n+     * }\n+     * </code></pre>\n+     * </p>\n+     * \n+     * @param vector real vector to serialize\n+     * @param oos stream where the real vector should be written\n+     * @exception IOException if object cannot be written to stream\n+     * @see #deserializeRealVector(Object, String, ObjectInputStream)\n+     */\n+    public static void serializeRealVector(final RealVector vector,\n+                                           final ObjectOutputStream oos)\n+        throws IOException {\n+        final int n = vector.getDimension();\n+        oos.writeInt(n);\n+        for (int i = 0; i < n; ++i) {\n+            oos.writeDouble(vector.getEntry(i));\n+        }\n+    }\n+\n+    /** Deserialize  a {@link RealVector} field in a class.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>readObject</code> method (after a call to\n+     * <code>ois.defaultReadObject()</code>) in a class that has a\n+     * {@link RealVector} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not deserialize the vector (the {@link\n+     * RealVector} interface is not serializable by default) but this method does\n+     * deserialize it specifically.\n+     * </p>\n+     * @param instance instance in which the field must be set up\n+     * @param fieldName name of the field within the class (may be private and final)\n+     * @param ois stream from which the real vector should be read\n+     * @exception ClassNotFoundException if a class in the stream cannot be found\n+     * @exception IOException if object cannot be read from the stream\n+     * @see #serializeRealVector(RealVector, ObjectOutputStream)\n+     */\n+    public static void deserializeRealVector(final Object instance,\n+                                             final String fieldName,\n+                                             final ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            // read the vector data\n+            final int n = ois.readInt();\n+            final double[] data = new double[n];\n+            for (int i = 0; i < n; ++i) {\n+                data[i] = ois.readDouble();\n+            }\n+\n+            // create the instance\n+            final RealVector vector = new RealVectorImpl(data, false);\n+\n+            // set up the field\n+            final java.lang.reflect.Field f =\n+                instance.getClass().getDeclaredField(fieldName);\n+            f.setAccessible(true);\n+            f.set(instance, vector);\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n+    /** Serialize a {@link RealMatrix}.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>writeObject</code> method (after a call to\n+     * <code>oos.defaultWriteObject()</code>) in a class that has a\n+     * {@link RealMatrix} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not serialize the matrix (the {@link\n+     * RealMatrix} interface is not serializable by default) but this method does\n+     * serialize it specifically.\n+     * </p>\n+     * <p>\n+     * The following example shows how a simple class with a name and a real matrix\n+     * should be written:\n+     * <pre><code>\n+     * public class NamedMatrix implements Serializable {\n+     *\n+     *     private final String name;\n+     *     private final transient RealMatrix coefficients;\n+     *\n+     *     // omitted constructors, getters ...\n+     *\n+     *     private void writeObject(ObjectOutputStream oos) throws IOException {\n+     *         oos.defaultWriteObject();  // takes care of name field\n+     *         MatrixUtils.serializeRealMatrix(coefficients, oos);\n+     *     }\n+     *\n+     *     private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n+     *         ois.defaultReadObject();  // takes care of name field\n+     *         MatrixUtils.deserializeRealMatrix(this, \"coefficients\", ois);\n+     *     }\n+     *\n+     * }\n+     * </code></pre>\n+     * </p>\n+     * \n+     * @param matrix real matrix to serialize\n+     * @param oos stream where the real matrix should be written\n+     * @exception IOException if object cannot be written to stream\n+     * @see #deserializeRealMatrix(Object, String, ObjectInputStream)\n+     */\n+    public static void serializeRealMatrix(final RealMatrix matrix,\n+                                           final ObjectOutputStream oos)\n+        throws IOException {\n+        final int n = matrix.getRowDimension();\n+        final int m = matrix.getColumnDimension();\n+        oos.writeInt(n);\n+        oos.writeInt(m);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < m; ++j) {\n+                oos.writeDouble(matrix.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** Deserialize  a {@link RealMatrix} field in a class.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>readObject</code> method (after a call to\n+     * <code>ois.defaultReadObject()</code>) in a class that has a\n+     * {@link RealMatrix} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not deserialize the matrix (the {@link\n+     * RealMatrix} interface is not serializable by default) but this method does\n+     * deserialize it specifically.\n+     * </p>\n+     * @param instance instance in which the field must be set up\n+     * @param fieldName name of the field within the class (may be private and final)\n+     * @param ois stream from which the real matrix should be read\n+     * @exception ClassNotFoundException if a class in the stream cannot be found\n+     * @exception IOException if object cannot be read from the stream\n+     * @see #serializeVector(RealVector, ObjectOutputStream)\n+     */\n+    public static void deserializeRealMatrix(final Object instance,\n+                                             final String fieldName,\n+                                             final ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            // read the matrix data\n+            final int n = ois.readInt();\n+            final int m = ois.readInt();\n+            final double[][] data = new double[n][m];\n+            for (int i = 0; i < n; ++i) {\n+                final double[] dataI = data[i];\n+                for (int j = 0; j < m; ++j) {\n+                    dataI[j] = ois.readDouble();\n+                }\n+            }\n+\n+            // create the instance\n+            final RealMatrix matrix = new RealMatrixImpl(data, false);\n+\n+            // set up the field\n+            final java.lang.reflect.Field f =\n+                instance.getClass().getDeclaredField(fieldName);\n+            f.setAccessible(true);\n+            f.set(instance, matrix);\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n }", "timestamp": 1243933411, "metainfo": ""}