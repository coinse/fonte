{"sha": "2628b29e876bf69f58727a8ef9d63924f8f87a27", "log": "minor code cleanups (error messages, javadoc, avoiding array copies, final attributes ...)  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n       \"Nombre maximal d''it\\u00e9rations ({0}) d\\u00e9pass\\u00e9\" },\n \n     // org.apache.commons.math.DimensionMismatchException\n+    // org.apache.commons.math.optimization.LeastSquaresConverter\n     { \"dimension mismatch {0} != {1}\",\n       \"dimensions incompatibles {0} != {1}\" },\n \n     { \"Conversion Exception in Transformation: {0}\",\n       \"Exception de conversion dans une transformation : {0}\" },\n \n-    // org.apache.commons.math.estimation.AbstractEstimator\n+    // org.apache.commons.math.optimization.general.AbstractEstimator\n     { \"maximal number of evaluations exceeded ({0})\",\n       \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n     { \"unable to compute covariances: singular problem\",\n     { \"no degrees of freedom ({0} measurements, {1} parameters)\",\n       \"aucun degr\\u00e9 de libert\\u00e9 ({0} mesures, {1} param\\u00e8tres)\" },\n \n-    // org.apache.commons.math.estimation.GaussNewtonEstimator\n+    // org.apache.commons.math.optimization.general.GaussNewtonEstimator\n     { \"unable to solve: singular problem\",\n       \"r\\u00e9solution impossible : probl\\u00e8me singulier\" },\n \n-    // org.apache.commons.math.estimation.LevenbergMarquardtEstimator\n+    // org.apache.commons.math.optimization.general.LevenbergMarquardtEstimator\n     { \"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\",\n       \"trop petite tol\\u00e9rance relative sur le co\\u00fbt ({0}), aucune r\\u00e9duction de la somme des carr\\u00e9s n''est possible\" },\n     { \"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n     // org.apache.commons.math.ode.ContinuousOutputModel\n-    // org.apache.commons.math.optimization.DirectSearchOptimizer\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"unexpected exception caught\",\n       \"exception inattendue lev\\u00e9e\" },\n \n-    // org.apache.commons.math.optimization.DirectSearchOptimizer\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"none of the {0} start points lead to convergence\",\n       \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  },\n \n     // org.apache.commons.math.linear.decomposition.LUDecompositionImpl\n     // org.apache.commons.math.linear.decomposition.QRDecompositionImpl\n     // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n+    { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+      \"dimensions erronn\\u00e9es : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n+\n+    // org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.LUDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.QRDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n+    // org.apache.commons.math.linear.RealVectorImpl\n+    // org.apache.commons.math.linear.SparseRealVector\n     { \"vector length mismatch: got {0} but expected {1}\",\n       \"dimension de vecteur erronn\\u00e9e : {0} \\u00e0 la place de {1}\" },\n-    { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-      \"dimensions erronn\\u00e9es : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n       \n     // org.apache.commons.math.linear.RealVectorImpl\n+    // org.apache.commons.math.linear.SparseRealVector\n     { \"index {0} out of allowed range [{1}, {2}]\",\n       \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"vector must have at least one element\",\n+      \"un vecteur doit comporter au moins un \\u00e9l\\u00e9ment\" },\n+    { \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+      \"la position {0} et la taille {1} sont incompatibles avec la taille du tableau d''entr\\u00e9e {2}\"},\n \n     // org.apache.commons.math.linear.AbstractRealMatrix\n     { \"invalid row dimension: {0} (must be positive)\",\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n             throw new NullPointerException();\n         }   \n         if (d.length == 0) {\n-            throw new IllegalArgumentException(\"Vector must have at least one element.\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\"); \n         }\n         data = copyArray ? d.clone() :  d;\n     }\n      */\n     public RealVectorImpl(double[] d, int pos, int size) {\n         if (d.length < pos + size) {\n-            throw new IllegalArgumentException(\"Position \" + pos + \" and size \" + size +\n-                                               \" don't fit to the size of the input array \" +\n-                                               d.length);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n         }\n         data = new double[size];\n         System.arraycopy(d, pos, data, 0, size);\n      */\n     public RealVectorImpl(Double[] d, int pos, int size) {\n         if (d.length < pos + size) {\n-            throw new IllegalArgumentException(\"Position \" + pos + \" and size \" + size +\n-                                               \" don't fit to the size of the input array \" +\n-                                               d.length);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n         }\n         data = new double[size];\n         for (int i = pos; i < pos + size; i++) {\n     protected void checkVectorDimensions(int n)\n         throws IllegalArgumentException {\n         if (data.length != n) {\n-            throw new IllegalArgumentException(\"vector dimension is \" + data.length +\n-                                               \", not \" + n + \" as expected\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    data.length, n);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n */\n public class SparseRealVector implements RealVector {\n \n+    /** Default Tolerance for having a value considered zero. */\n+    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n+\n     /** Entries of the vector. */\n-    private  OpenIntToDoubleHashMap entries;\n+    private final OpenIntToDoubleHashMap entries;\n \n     /** Dimension of the vector. */\n     private final int virtualSize;\n \n     /** Tolerance for having a value considered zero. */\n-    private double epsilon = 1.0e-12;\n+    private double epsilon;\n \n     /**\n      * Build a 0-length vector.\n      * into this vector.</p>\n      */\n     public SparseRealVector() {\n-        virtualSize = 0;\n-        entries = new OpenIntToDoubleHashMap(0.0);\n+        this(0, DEFAULT_ZERO_TOLERANCE);\n     }\n \n     /**\n      * @param dimension size of the vector\n      */\n     public SparseRealVector(int dimension) {\n-        virtualSize = dimension;\n-        entries = new OpenIntToDoubleHashMap(0.0);\n-    }\n-\n-    /**\n-     * Construct a (dimension)-length vector of zeros, specifying zero tolerance\n+        this(dimension, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n      * @param dimension Size of the vector\n      * @param epsilon The tolerance for having a value considered zero\n      */\n-    public SparseRealVector(int dimension, double epsilon){\n+    public SparseRealVector(int dimension, double epsilon) {\n         virtualSize = dimension;\n         entries = new OpenIntToDoubleHashMap(0.0);\n         this.epsilon = epsilon;\n     }\n-    \n-    /**\n-     * Resize the vector, for use with append\n+\n+    /**\n+     * Build a resized vector, for use with append.\n      * @param v The original vector\n      * @param resize The amount to resize it\n      */\n     protected SparseRealVector(SparseRealVector v, int resize) {\n         virtualSize = v.getDimension() + resize;\n         entries = new OpenIntToDoubleHashMap(v.entries);\n-    }\n-\n-    /**\n-     * For advanced use, when you know the sparseness \n+        epsilon = DEFAULT_ZERO_TOLERANCE;\n+    }\n+\n+    /**\n+     * Build a vector with known the sparseness (for advanced use only).\n      * @param dimension The size of the vector\n-     * @param expectedSize The excpected number of non-zero entries\n+     * @param expectedSize The expected number of non-zero entries\n      */\n     public SparseRealVector(int dimension, int expectedSize) {\n-        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n-        virtualSize = dimension;\n-    }\n-\n-    /**\n-     * For advanced use, when you know the sparseness and want to specify zero tolerance\n+        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).\n      * @param dimension The size of the vector\n      * @param expectedSize The expected number of non-zero entries\n      * @param epsilon The tolerance for having a value considered zero\n      */\n-    public SparseRealVector(int dimension, int expectedSize, double epsilon){\n+    public SparseRealVector(int dimension, int expectedSize, double epsilon) {\n         virtualSize = dimension;\n         entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n         this.epsilon = epsilon;\n     }\n-    \n+\n     /**\n      * Create from a double array.\n      * Only non-zero entries will be stored\n      * @param values The set of values to create from\n      */\n     public SparseRealVector(double[] values) {\n-        virtualSize = values.length;\n-        fromDoubleArray(values);\n+        this(values, DEFAULT_ZERO_TOLERANCE);\n     }\n \n     /**\n      * Create from a double array, specifying zero tolerance.\n      * Only non-zero entries will be stored\n      * @param values The set of values to create from\n-     * @param epsilon The tolerance for having a value considered zero \n-     */\n-    public SparseRealVector(double [] values, double epsilon){\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public SparseRealVector(double[] values, double epsilon) {\n         virtualSize = values.length;\n-        this.epsilon = epsilon;\n-        fromDoubleArray(values);\n-    }\n-    \n-    /**\n-     * Create from a Double array.\n-     * Only non-zero entries will be stored\n-     * @param values The set of values to create from\n-     */\n-    public SparseRealVector(Double [] values) {\n-        virtualSize = values.length;\n-        double[] vals = new double[values.length];\n-        for(int i=0; i < values.length; i++){\n-            vals[i] = values[i].doubleValue();\n-        }\n-        fromDoubleArray(vals);\n-    }\n-    \n-    /**\n-     * Create from a Double array.\n-     * Only non-zero entries will be stored\n-     * @param values The set of values to create from\n-     * @param epsilon The tolerance for having a value considered zero\n-     */\n-    public SparseRealVector(Double [] values, double epsilon){\n-        virtualSize = values.length;\n-        this.epsilon = epsilon;\n-        double[] vals = new double[values.length];\n-        for(int i=0; i < values.length; i++){\n-            vals[i] = values[i].doubleValue();\n-        }\n-        fromDoubleArray(vals);\n-    }\n-    \n-    /**\n-     * Copy constructer\n-     * @param v The instance to copy from\n-     */\n-    public SparseRealVector(SparseRealVector v){\n-        virtualSize = v.getDimension();\n-        epsilon = v.getEpsilon();\n-        entries = new OpenIntToDoubleHashMap(v.getEntries());\n-    }\n-\n-    /**\n-     * Generic copy constructer\n-     * @param v The instance to copy from\n-     */\n-    public SparseRealVector(RealVector v) {\n-        virtualSize = v.getDimension();\n-        fromDoubleArray(v.getData());\n-    }\n-\n-    \n-    /**\n-     * Fill in the values from a double array\n-     * @param values The set of values to use\n-     */\n-    private void fromDoubleArray(double[] values) {\n         entries = new OpenIntToDoubleHashMap(0.0);\n         for (int key = 0; key < values.length; key++) {\n             double value = values[key];\n                 entries.put(key, value);\n             }\n         }\n-    }\n-\n-    /**\n-     * \n-     * @return The entries of this instance\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public SparseRealVector(Double[] values) {\n+        this(values, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public SparseRealVector(Double[] values, double epsilon) {\n+        virtualSize = values.length;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        for (int key = 0; key < values.length; key++) {\n+            double value = values[key].doubleValue();\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public SparseRealVector(SparseRealVector v) {\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToDoubleHashMap(v.getEntries());\n+        epsilon = v.getEpsilon();\n+    }\n+\n+    /**\n+     * Generic copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public SparseRealVector(RealVector v) {\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        for (int key = 0; key < virtualSize; key++) {\n+            double value = v.getEntry(key);\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+        epsilon = DEFAULT_ZERO_TOLERANCE;\n+    }\n+\n+    /**\n+     * Get the entries of this instance.\n+     * @return entries of this instance\n      */\n     private OpenIntToDoubleHashMap getEntries() {\n         return entries;\n     }\n \n-    \n-    /**\n-     * Determine if this value is zero\n+    /**\n+     * Determine if this value is zero.\n      * @param value The value to test\n      * @return <code>true</code> if this value is zero, <code>false</code> otherwise\n      */\n     }\n \n     /**\n-     * \n+     * Get the tolerance for having a value considered zero.\n      * @return The test range for testing if a value is zero\n      */\n     public double getEpsilon() {\n     }\n \n     /**\n-     * \n+     * Set the tolerance for having a value considered zero.\n      * @param epsilon The test range for testing if a value is zero\n      */\n     public void setEpsilon(double epsilon) {\n     /** {@inheritDoc} */\n     public RealVector add(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n-        if (v instanceof SparseRealVector)\n+        if (v instanceof SparseRealVector) {\n             return add((SparseRealVector) v);\n+        }\n         return add(v.getData());\n-\n-    }\n-\n-    /**\n-     * Optimized method to add two SparseRealVectors\n+    }\n+\n+    /**\n+     * Optimized method to add two SparseRealVectors.\n      * @param v Vector to add with\n      * @return The sum of <code>this</code> with <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n     }\n \n     /**\n-     * Optimized method to append a SparseRealVector\n+     * Optimized method to append a SparseRealVector.\n      * @param v vector to append\n      * @return The result of appending <code>v</code> to self\n      */\n         while (iter.hasNext()) {\n             int idx = iter.key();\n             double value = 0;\n-            if (idx < v.length)\n+            if (idx < v.length) {\n                 value = v[idx];\n+            }\n             res += value * iter.value();\n         }\n         return res;\n     /** {@inheritDoc} */\n     public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n         checkIndex(index);\n-        checkIndex(index+n-1);\n+        checkIndex(index + n - 1);\n         SparseRealVector res = new SparseRealVector(n);\n         int end = index + n;\n         Iterator iter = entries.iterator();\n     }\n \n     /**\n-     * Optimized method to compute distance\n+     * Optimized method to compute distance.\n      * @param v The vector to compute distance to\n      * @return The distance from <code>this</code> and <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n             iter.advance();\n             int key = iter.key();\n             if (!entries.containsKey(key)) {\n-                res += iter.value() * iter.value();\n+                final double value = iter.value();\n+                res += value * value;\n             }\n         }\n         return Math.sqrt(res);\n     }\n \n     /**\n-     * Optimized method to compute LInfDistance  \n+     * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n      * @return the LInfDistance\n      */\n         while (iter.hasNext()) {\n             iter.advance();\n             double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n-            if(delta > max)\n+            if (delta > max) {\n                 max = delta;\n+            }\n         }\n         iter = v.getEntries().iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             int key = iter.key();\n             if (!entries.containsKey(key)) {\n-                if(iter.value() > max)\n+                if (iter.value() > max) {\n                     max = iter.value();\n+                }\n             }\n         }\n         return max;\n         double max = 0;\n         for (int i = 0; i < v.length; i++) {\n             double delta = Math.abs(getEntry(i) - v[i]);\n-            if(delta > max)\n+            if (delta > max) {\n                 max = delta;\n+            }\n         }\n         return max;\n     }\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            if (Double.isInfinite(iter.value()))\n+            if (Double.isInfinite(iter.value())) {\n                 return true;\n+            }\n         }\n         return false;\n     }\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            if (Double.isNaN(iter.value()))\n+            if (Double.isNaN(iter.value())) {\n                 return true;\n+            }\n         }\n         return false;\n     }\n \n     /** {@inheritDoc} */\n     public RealVector mapAcosToSelf() {\n-        for(int i=0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.acos(getEntry(i)));\n         }\n         return this;\n \n     /** {@inheritDoc} */\n     public RealVector mapCosToSelf() {\n-        for(int i=0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.cos(getEntry(i)));\n         }\n         return this;\n \n     /** {@inheritDoc} */\n     public RealVector mapCoshToSelf() {\n-        for(int i = 0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.cosh(getEntry(i)));\n         }\n         return this;\n \n     /** {@inheritDoc} */\n     public RealVector mapInvToSelf() {\n-        for(int i=0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, 1.0/getEntry(i));\n         }\n         return this;\n \n     /** {@inheritDoc} */\n     public RealVector mapLog10ToSelf() {\n-        for(int i=0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.log10(getEntry(i)));\n         }\n         return this;\n         }\n         return this;\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public RealVector mapLogToSelf() {\n-        for(int i=0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.log(getEntry(i)));\n         }\n        return this;\n     }\n \n     /**\n-     * Optimized method to compute the outer product\n+     * Optimized method to compute the outer product.\n      * @param v The vector to comput the outer product on\n      * @return The outer product of <code>this</code> and <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n         checkVectorDimensions(v.getDimension());\n         SparseRealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);\n         Iterator iter = entries.iterator();\n-        while(iter.hasNext()){\n+        while (iter.hasNext()) {\n             iter.advance();\n             Iterator iter2 = v.getEntries().iterator();\n-            while(iter2.hasNext()){\n+            while (iter2.hasNext()) {\n                 iter2.advance();\n                 res.setEntry(iter.key(), iter2.key(), iter.value()*iter2.value());\n             }\n         }\n         return res;\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public RealMatrix outerProduct(RealVector v)\n             throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n-        if(v instanceof SparseRealVector){\n+        if (v instanceof SparseRealVector) {\n             return outerproduct((SparseRealVector)v);\n         }\n         RealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);\n         Iterator iter = entries.iterator();\n-        while(iter.hasNext()){\n+        while (iter.hasNext()) {\n             iter.advance();\n             int row = iter.key();\n-            for(int col=0; col < virtualSize; col++){\n+            for (int col = 0; col < virtualSize; col++) {\n                 res.setEntry(row, col, iter.value()*v.getEntry(col));\n             }\n         }\n \n     /** {@inheritDoc} */\n     public void set(double value) {\n-        for(int i=0; i < virtualSize; i++){\n+        for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, value);\n         }\n     }\n \n     /**\n-     * Optimized method to subtract SparseRealVectors\n+     * Optimized method to subtract SparseRealVectors.\n      * @param v The vector to subtract from <code>this</code>\n      * @return The difference of <code>this</code> and <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n     /** {@inheritDoc} */\n     public void unitize() {\n         double norm = getNorm();\n-        if(isZero(norm)){\n+        if (isZero(norm)) {\n             throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n-            \n         }\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n \n     /**\n      * Check if an index is valid.\n-     * \n+     *\n      * @param index\n      *            index to check\n      * @exception MatrixIndexException\n \n     /**\n      * Check if instance dimension is equal to some expected value.\n-     * \n+     *\n      * @param n\n      *            expected dimension.\n      * @exception IllegalArgumentException\n     /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object obj) {\n-        if (this == obj)\n+        if (this == obj) {\n             return true;\n-        if (obj == null)\n+        }\n+        if (obj == null) {\n             return false;\n-        if (!(obj instanceof SparseRealVector))\n+        }\n+        if (!(obj instanceof SparseRealVector)) {\n             return false;\n+        }\n         SparseRealVector other = (SparseRealVector) obj;\n-        if (virtualSize != other.virtualSize)\n+        if (virtualSize != other.virtualSize) {\n             return false;\n-        if (Double.doubleToLongBits(epsilon) != Double\n-                .doubleToLongBits(other.epsilon))\n+        }\n+        if (Double.doubleToLongBits(epsilon) !=\n+            Double.doubleToLongBits(other.epsilon)) {\n             return false;\n-        Iterator iter = entries.iterator();\n-        while(iter.hasNext()){\n+        }\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n             iter.advance();\n             double test = iter.value() - other.getEntry(iter.key());\n-            if(Math.abs(test) > epsilon)\n+            if (Math.abs(test) > epsilon) {\n                 return false;\n+            }\n         }\n         iter = other.getEntries().iterator();\n-        while(iter.hasNext()){\n+        while (iter.hasNext()) {\n             iter.advance();\n             double test = iter.value() - getEntry(iter.key());\n-            if(!isZero(test))\n+            if (!isZero(test)) {\n                 return false;\n+            }\n         }\n         return true;\n     }", "timestamp": 1235509181, "metainfo": ""}