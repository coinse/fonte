{"sha": "dc7eb2daa10ca3aeed9884a3aba329878b4d0fe5", "log": "added weibull distribution  ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.CauchyDistribution}.\n  *\n- * @version $Revision$ $Date$\n+ * @version $Revision: 1.13 $ $Date$\n  */\n public class CauchyDistributionImpl extends AbstractContinuousDistribution \n \t\timplements CauchyDistribution, Serializable {\n \tprivate double scale = 1;\n     \n \t/**\n-\t * Creates normal distribution with the mean equal to zero and standard\n-\t * deviation equal to one. \n+\t * Creates cauchy distribution with the medain equal to zero and scale\n+\t * equal to one. \n \t */\n \tpublic CauchyDistributionImpl(){\n \t\tthis(0.0, 1.0);\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n  * <li>Poisson</li>\n  * <li>Normal</li>\n  * <li>Student's t</li>\n+ * <li>Weibull</li>\n  * </ul>\n  *\n  * Common usage:<pre>\n      * Create a new Poisson distribution with poisson parameter lambda.\n      * \n      * @param lambda poisson parameter\n-     * @return a new normal distribution.  \n+     * @return a new poisson distribution.  \n      */               \n     public abstract PoissonDistribution \n         createPoissonDistribution(double lambda);\n+    \n+    /**\n+     * Create a new Weibull distribution with the given shape and scale\n+     * parameters.\n+     * \n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     * @return a new Weibull distribution.  \n+     */               \n+    public WeibullDistribution createWeibullDistribution(\n+        double alpha, double beta)\n+    {\n+        return new WeibullDistributionImpl(alpha, beta);\n+    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Weibull Distribution.  This interface defines the two parameter form of the\n+ * distribution as defined by\n+ * <a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n+ * Weibull Distribution</a>, equations (1) and (2).\n+ *\n+ * Instances of WeibullDistribution objects should be created using\n+ * {@link DistributionFactory#createWeibullDistribution(double, double)}\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n+ * Weibull Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision: 1.12 $ $Date: 2004-06-23 11:26:18 -0500 (Wed, 23 Jun 2004) $\n+ */\n+public interface WeibullDistribution extends ContinuousDistribution {\n+\n+    /**\n+     * Access the shape parameter.\n+     * @return the shape parameter.\n+     */\n+    double getShape();\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return the scale parameter.\n+     */\n+    double getScale();\n+    \n+    /**\n+     * Modify the shape parameter.\n+     * @param alpha The new shape parameter value.\n+     */\n+    void setShape(double alpha);\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param beta The new scale parameter value.\n+     */\n+    void setScale(double beta);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.WeibullDistribution}.\n+ *\n+ * @version $Revision: 1.13 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n+ */\n+public class WeibullDistributionImpl extends AbstractContinuousDistribution\n+        implements WeibullDistribution, Serializable {\n+    \n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 8589540077390120676L;\n+    \n+    /** The shape parameter. */\n+    private double alpha;\n+    \n+    /** The scale parameter. */\n+    private double beta;\n+    \n+    /**\n+     * Creates weibull distribution with the given shape and scale and a\n+     * location equal to zero.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     */\n+    public WeibullDistributionImpl(double alpha, double beta){\n+        super();\n+        setShape(alpha);\n+        setScale(beta);\n+    }\n+\n+    /**\n+     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     */\n+    public double cumulativeProbability(double x) {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = 1.0 - Math.exp(-Math.pow(x / getScale(), getShape()));\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Access alpha.\n+     * @return the alpha.\n+     */\n+    public double getShape() {\n+        return alpha;\n+    }\n+    \n+    /**\n+     * Access beta.\n+     * @return the beta.\n+     */\n+    public double getScale() {\n+        return beta;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public double inverseCumulativeProbability(double p) {\n+        double ret;\n+        if (p < 0.0 || p > 1.0) {\n+            throw new IllegalArgumentException\n+                (\"probability argument must be between 0 and 1 (inclusive)\");\n+        } else if (p == 0) {\n+            ret = 0.0;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify alpha.\n+     * @param alpha The new alpha value.\n+     */\n+    public void setShape(double alpha) {\n+        if (alpha <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"Shape must be positive.\");\n+        }       \n+        this.alpha = alpha;\n+    }\n+    \n+    /**\n+     * Modify beta.\n+     * @param beta The new beta value.\n+     */\n+    public void setScale(double beta) {\n+        if (beta <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"Scale must be positive.\");\n+        }       \n+        this.beta = beta;\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected double getDomainLowerBound(double p) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n+        // use median\n+        return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());\n+    }\n+}\n--- a/src/test/org/apache/commons/math/distribution/DistributionFactoryImplTest.java\n+++ b/src/test/org/apache/commons/math/distribution/DistributionFactoryImplTest.java\n         } catch(IllegalArgumentException ex) {\n         }\n     }\n+    \n+    public void testCauchyDistributionNegative() {\n+        try {\n+            factory.createCauchyDistribution(0.0, -1.0);\n+            fail(\"invalid scale. IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+    }\n+    \n+    public void testCauchyDistributionZero() {\n+        try {\n+            factory.createCauchyDistribution(0.0, 0.0);\n+            fail(\"invalid scale. IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+    }\n+    \n+    public void testWeibullDistributionNegativePositive() {\n+        try {\n+            factory.createWeibullDistribution(-1.0, 1.0);\n+            fail(\"invalid shape. IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+    }\n+    \n+    public void testWeibullDistributionZeroPositive() {\n+        try {\n+            factory.createWeibullDistribution(0.0, 1.0);\n+            fail(\"invalid shape. IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+    }\n+    \n+    public void testWeibullDistributionPositiveNegative() {\n+        try {\n+            factory.createWeibullDistribution(1.0, -1.0);\n+            fail(\"invalid scale. IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+    }\n+    \n+    public void testWeibullDistributionPositiveZero() {\n+        try {\n+            factory.createWeibullDistribution(1.0, 0.0);\n+            fail(\"invalid scale. IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for WeibullDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision: 1.8 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n+ */\n+public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n+    \n+    /**\n+     * Constructor for CauchyDistributionTest.\n+     * @param arg0\n+     */\n+    public WeibullDistributionTest(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    public ContinuousDistribution makeDistribution() {\n+        return DistributionFactory.newInstance().createWeibullDistribution(1.2, 2.1);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using Mathematica \n+        return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n+                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,\n+                6.232056007d, 7.497630467d, 10.51154969d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n+                0.975d, 0.990d, 0.999d};\n+    }\n+    \n+    //---------------------------- Additional test cases -------------------------\n+    \n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n+        setInverseCumulativeTestValues(\n+                new double[] {0.0, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testAlpha() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setShape(expected);\n+        assertEquals(expected, distribution.getShape(), 0.0);\n+    }\n+    \n+    public void testBeta() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setScale(expected);\n+        assertEquals(expected, distribution.getScale(), 0.0);\n+    }\n+    \n+    public void testSetAlpha() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        try {\n+            distribution.setShape(0.0);\n+            fail(\"Can not have 0.0 alpha.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setShape(-1.0);\n+            fail(\"Can not have negative alpha.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetBeta() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        try {\n+            distribution.setScale(0.0);\n+            fail(\"Can not have 0.0 beta.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setScale(-1.0);\n+            fail(\"Can not have negative beta.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+}", "timestamp": 1111029612, "metainfo": ""}