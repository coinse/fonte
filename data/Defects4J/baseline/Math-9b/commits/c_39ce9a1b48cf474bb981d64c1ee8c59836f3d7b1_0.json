{"sha": "39ce9a1b48cf474bb981d64c1ee8c59836f3d7b1", "log": "second attempt at fixing MATH-484 This fixes bad behavior when several events occur during a long step This also fixes bad behavior when events are triggered during backward integration Jira: MATH-484  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.SortedSet;\n import java.util.TreeSet;\n                 statesInitialized = true;\n             }\n \n+            // search for next events that may occur during the step\n+            final int orderingSign = interpolator.isForward() ? +1 : -1;\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n                 public int compare(EventState es0, EventState es1) {\n-                    return Double.compare(es0.getEventTime(), es1.getEventTime());\n+                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                 }\n \n             });\n \n-            // find all events that occur during the step\n             for (final EventState state : eventsStates) {\n                 if (state.evaluateStep(interpolator)) {\n                     // the event occurs during the current step\n                 }\n             }\n \n-            // handle the events chronologically\n-            for (final EventState state : occuringEvents) {\n+            while (!occuringEvents.isEmpty()) {\n+\n+                // handle the chronologically first event\n+                final Iterator<EventState> iterator = occuringEvents.iterator();\n+                final EventState currentEvent = iterator.next();\n+                iterator.remove();\n \n                 // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = state.getEventTime();\n+                final double eventT = currentEvent.getEventTime();\n                 interpolator.setSoftPreviousTime(previousT);\n                 interpolator.setSoftCurrentTime(eventT);\n \n                 // trigger the event\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState();\n-                state.stepAccepted(eventT, eventY);\n-                isLastStep = state.stop();\n+                currentEvent.stepAccepted(eventT, eventY);\n+                isLastStep = currentEvent.stop();\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n                     return eventT;\n                 }\n \n-                if (state.reset(eventT, eventY)) {\n+                if (currentEvent.reset(eventT, eventY)) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                 previousT = eventT;\n                 interpolator.setSoftPreviousTime(eventT);\n                 interpolator.setSoftCurrentTime(currentT);\n+\n+                // check if the same event occurs again in the remaining part of the step\n+                if (currentEvent.evaluateStep(interpolator)) {\n+                    // the event occurs during the current step\n+                    occuringEvents.add(currentEvent);\n+                }\n \n             }\n ", "timestamp": 1297693195, "metainfo": ""}