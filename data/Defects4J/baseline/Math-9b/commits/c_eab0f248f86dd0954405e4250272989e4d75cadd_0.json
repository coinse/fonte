{"sha": "eab0f248f86dd0954405e4250272989e4d75cadd", "log": "moved test java and resources directories for compliance with maven standard directory layout  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ArgumentOutsideDomainExceptionTest extends TestCase {\n+    \n+    public void testConstructor(){\n+        ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"3.14\") > 0);\n+        assertEquals(Math.PI, ex.getArgument()[0], 0);\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Locale;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ConvergenceExceptionTest extends TestCase {\n+\n+    public void testConstructor(){\n+        ConvergenceException ex = new ConvergenceException();\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertNotNull(ex.getMessage(Locale.FRENCH));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    public void testConstructorPatternArguments(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n+        ConvergenceException ex = new ConvergenceException(pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    public void testConstructorCause(){\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        ConvergenceException ex = new ConvergenceException(cause);\n+        assertEquals(cause, ex.getCause());\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        ConvergenceException ex = new ConvergenceException(cause, pattern, arguments);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/DuplicateSampleAbscissaExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class DuplicateSampleAbscissaExceptionTest extends TestCase {\n+    \n+    public void testConstructor(){\n+        DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"1.2\") > 0);\n+        assertEquals(1.2, ex.getDuplicateAbscissa(), 0);\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class FunctionEvaluationExceptionTest extends TestCase {\n+    \n+    public void testConstructor(){\n+        FunctionEvaluationException ex = new FunctionEvaluationException(0.0);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"0\") > 0);\n+        assertEquals(0.0, ex.getArgument()[0], 0);\n+    }\n+    \n+    public void testConstructorArray(){\n+        FunctionEvaluationException ex =\n+            new FunctionEvaluationException(new double[] { 0, 1, 2 });\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"0\") > 0);\n+        assertEquals(0.0, ex.getArgument()[0], 0);\n+        assertEquals(1.0, ex.getArgument()[1], 0);\n+        assertEquals(2.0, ex.getArgument()[2], 0);\n+    }\n+    \n+    public void testConstructorPatternArguments(){\n+        String pattern = \"evaluation failed for argument = {0}\";\n+        Object[] arguments = { Double.valueOf(0.0) };\n+        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+\n+    public void testConstructorArrayPatternArguments(){\n+        String pattern = \"evaluation failed for argument = {0}\";\n+        Object[] arguments = { Double.valueOf(0.0) };\n+        FunctionEvaluationException ex =\n+            new FunctionEvaluationException(new double[] { 0, 1, 2 }, pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+        assertEquals(0.0, ex.getArgument()[0], 0);\n+        assertEquals(1.0, ex.getArgument()[1], 0);\n+        assertEquals(2.0, ex.getArgument()[2], 0);\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"evaluation failed for argument = {0}\";\n+        Object[] arguments = { Double.valueOf(0.0) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0, pattern, arguments);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+\n+    public void testConstructorArrayPatternArgumentsCause(){\n+        String pattern = \"evaluation failed for argument = {0}\";\n+        Object[] arguments = { Double.valueOf(0.0) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        FunctionEvaluationException ex =\n+            new FunctionEvaluationException(cause, new double[] { 0, 1, 2 }, pattern, arguments);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+        assertEquals(0.0, ex.getArgument()[0], 0);\n+        assertEquals(1.0, ex.getArgument()[1], 0);\n+        assertEquals(2.0, ex.getArgument()[2], 0);\n+    }\n+\n+    public void testConstructorArgumentCause(){\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0);\n+        assertEquals(cause, ex.getCause());\n+        assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+\n+    public void testConstructorArrayArgumentCause(){\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        FunctionEvaluationException ex =\n+            new FunctionEvaluationException(cause, new double[] { 0, 1, 2 });\n+        assertEquals(cause, ex.getCause());\n+        assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+        assertEquals(0.0, ex.getArgument()[0], 0);\n+        assertEquals(1.0, ex.getArgument()[1], 0);\n+        assertEquals(2.0, ex.getArgument()[2], 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Locale;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class MathConfigurationExceptionTest extends TestCase {\n+\n+    public void testConstructor(){\n+        MathConfigurationException ex = new MathConfigurationException();\n+        assertNull(ex.getCause());\n+        assertNull(ex.getMessage());\n+        assertEquals(0, ex.getMessage(Locale.FRENCH).length());\n+    }\n+    \n+    public void testConstructorPatternArguments(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n+        MathConfigurationException ex = new MathConfigurationException(pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    public void testConstructorCause(){\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        MathConfigurationException ex = new MathConfigurationException(cause);\n+        assertEquals(cause, ex.getCause());\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        MathConfigurationException ex = new MathConfigurationException(cause, pattern, arguments);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/MathExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.Locale;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class MathExceptionTest extends TestCase {\n+\n+    public void testConstructor(){\n+        MathException ex = new MathException();\n+        assertNull(ex.getCause());\n+        assertNull(ex.getMessage());\n+        assertEquals(0, ex.getMessage(Locale.FRENCH).length());\n+    }\n+    \n+    public void testConstructorPatternArguments(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n+        MathException ex = new MathException(pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    public void testConstructorCause(){\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        MathException ex = new MathException(cause);\n+        assertEquals(cause, ex.getCause());\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        MathException ex = new MathException(cause, pattern, arguments);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    /**\n+     * Tests the printStackTrace() operation.\n+     */\n+    public void testPrintStackTrace() {\n+        String outMsg = \"outer message\";\n+        String inMsg = \"inner message\";\n+        MathException cause = new MathConfigurationException(inMsg);\n+        MathException ex = new MathException(cause, outMsg);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        ex.printStackTrace(ps);\n+        String stack = baos.toString();\n+        String outerMsg = \"org.apache.commons.math.MathException: outer message\";\n+        String innerMsg = \"Caused by: \" + \n+        \"org.apache.commons.math.MathConfigurationException: inner message\";\n+        assertTrue(stack.startsWith(outerMsg));\n+        assertTrue(stack.indexOf(innerMsg) > 0);\n+        \n+        PrintWriter pw = new PrintWriter(ps, true);\n+        ex.printStackTrace(pw);\n+        stack = baos.toString();\n+        assertTrue(stack.startsWith(outerMsg));\n+        assertTrue(stack.indexOf(innerMsg) > 0);\n+    }\n+    \n+    /**\n+     * Test serialization\n+     */\n+    public void testSerialization() {\n+        String outMsg = \"outer message\";\n+        String inMsg = \"inner message\";\n+        MathException cause = new MathConfigurationException(inMsg);\n+        MathException ex = new MathException(cause, outMsg);\n+        MathException image = (MathException) TestUtils.serializeAndRecover(ex);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        ex.printStackTrace(ps);\n+        String stack = baos.toString();\n+        \n+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n+        PrintStream ps2 = new PrintStream(baos2);\n+        image.printStackTrace(ps2);\n+        String stack2 = baos2.toString();\n+        \n+        // See if JDK supports nested exceptions.  If not, stack trace of\n+        // inner exception will not be serialized\n+        boolean jdkSupportsNesting = false;\n+        try {\n+            Throwable.class.getDeclaredMethod(\"getCause\", new Class[0]);\n+            jdkSupportsNesting = true;\n+        } catch (NoSuchMethodException e) {\n+            jdkSupportsNesting = false;\n+        }\n+        \n+        if (jdkSupportsNesting) {\n+            assertEquals(stack, stack2);\n+        } else {\n+            assertTrue(stack2.indexOf(inMsg) != -1);\n+            assertTrue(stack2.indexOf(\"MathConfigurationException\") != -1);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class MaxIterationsExceededExceptionTest extends TestCase {\n+    \n+    public void testSimpleConstructor(){\n+        MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"1,000,000\") > 0);\n+        assertEquals(1000000, ex.getMaxIterations());\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+\n+    public void testComplexConstructor(){\n+        MaxIterationsExceededException ex =\n+            new MaxIterationsExceededException(1000000,\n+                \"Continued fraction convergents failed to converge for value {0}\",\n+                1234567);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"1,000,000\") < 0);\n+        assertTrue(ex.getMessage().indexOf(\"1,234,567\") > 0);\n+        assertEquals(1000000, ex.getMaxIterations());\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/RetryTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.TestCase;\n+\n+/**\n+ * A TestCase that retries tests when assertions fail.\n+ * <p>\n+ * If one or more tests throw an AssertionFailedError, all tests are \n+ * repeated one time.  \n+ * <p>\n+ * Errors or exceptions other than AssertionFailedError do not lead to retries.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class RetryTestCase extends TestCase {\n+\n+    public RetryTestCase() {\n+        super();\n+    }\n+\n+    public RetryTestCase(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    /**\n+     *  Override runTest() to catch AssertionFailedError and retry\n+     */\n+    @Override\n+    protected void runTest() throws Throwable {\n+        try {\n+            super.runTest();\n+        } catch (AssertionFailedError err) {\n+            // System.out.println(\"Retrying \" + this.getName());\n+            super.runTest();\n+        }    \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.Assert;\n+import junit.framework.AssertionFailedError;\n+\n+import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.complex.ComplexFormat;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class TestUtils {\n+    /**\n+     * Collection of static methods used in math unit tests.\n+     */\n+    private TestUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Verifies that expected and actual are within delta, or are both NaN or\n+     * infinities of the same sign.\n+     */\n+    public static void assertEquals(double expected, double actual, double delta) {\n+        assertEquals(null, expected, actual, delta);\n+    }\n+\n+    /**\n+     * Verifies that expected and actual are within delta, or are both NaN or\n+     * infinities of the same sign.\n+     */\n+    public static void assertEquals(String msg, double expected, double actual, double delta) {\n+        // check for NaN\n+        if(Double.isNaN(expected)){\n+            Assert.assertTrue(\"\" + actual + \" is not NaN.\",\n+                Double.isNaN(actual));\n+        } else {\n+            Assert.assertEquals(msg, expected, actual, delta);\n+        }\n+    }\n+    \n+    /**\n+     * Verifies that the two arguments are exactly the same, either\n+     * both NaN or infinities of same sign, or identical floating point values.\n+     */\n+    public static void assertSame(double expected, double actual) {\n+     assertEquals(expected, actual, 0);\n+    }\n+    \n+    /**\n+     * Verifies that real and imaginary parts of the two complex arguments\n+     * are exactly the same.  Also ensures that NaN / infinite components match.\n+     */\n+    public static void assertSame(Complex expected, Complex actual) {\n+        assertSame(expected.getReal(), actual.getReal());\n+        assertSame(expected.getImaginary(), actual.getImaginary());\n+    }\n+    \n+    /**\n+     * Verifies that real and imaginary parts of the two complex arguments\n+     * differ by at most delta.  Also ensures that NaN / infinite components match.\n+     */\n+    public static void assertEquals(Complex expected, Complex actual, double delta) {\n+        assertEquals(expected.getReal(), actual.getReal(), delta);\n+        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);\n+    }\n+    \n+    /**\n+     * Verifies that two double arrays have equal entries, up to tolerance\n+     */\n+    public static void assertEquals(double expected[], double observed[], double tolerance) {\n+        assertEquals(\"Array comparison failure\", expected, observed, tolerance);\n+    }\n+    \n+    /**\n+     * Serializes an object to a bytes array and then recovers the object from the bytes array.\n+     * Returns the deserialized object.\n+     * \n+     * @param o  object to serialize and recover\n+     * @return  the recovered, deserialized object\n+     */\n+    public static Object serializeAndRecover(Object o) {\n+        try {\n+            // serialize the Object\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream so = new ObjectOutputStream(bos);\n+            so.writeObject(o);\n+\n+            // deserialize the Object\n+            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+            ObjectInputStream si = new ObjectInputStream(bis);\n+            return si.readObject();\n+        } catch (IOException ioe) {\n+            return null;\n+        } catch (ClassNotFoundException cnfe) {\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * Verifies that serialization preserves equals and hashCode.\n+     * Serializes the object, then recovers it and checks equals and hash code.\n+     * \n+     * @param object  the object to serialize and recover\n+     */\n+    public static void checkSerializedEquality(Object object) {\n+        Object object2 = serializeAndRecover(object);\n+        Assert.assertEquals(\"Equals check\", object, object2);\n+        Assert.assertEquals(\"HashCode check\", object.hashCode(), object2.hashCode());\n+    }\n+\n+    /**\n+     * Verifies that the relative error in actual vs. expected is less than or\n+     * equal to relativeError.  If expected is infinite or NaN, actual must be\n+     * the same (NaN or infinity of the same sign).\n+     * \n+     * @param expected expected value\n+     * @param actual  observed value\n+     * @param relativeError  maximum allowable relative error\n+     */\n+    public static void assertRelativelyEquals(double expected, double actual,\n+            double relativeError) {\n+        assertRelativelyEquals(null, expected, actual, relativeError);\n+    }\n+    \n+    /**\n+     * Verifies that the relative error in actual vs. expected is less than or\n+     * equal to relativeError.  If expected is infinite or NaN, actual must be\n+     * the same (NaN or infinity of the same sign).\n+     * \n+     * @param msg  message to return with failure\n+     * @param expected expected value\n+     * @param actual  observed value\n+     * @param relativeError  maximum allowable relative error\n+     */\n+    public static void assertRelativelyEquals(String msg, double expected,\n+            double actual, double relativeError) {\n+        if (Double.isNaN(expected)) {\n+            Assert.assertTrue(msg, Double.isNaN(actual));\n+        } else if (Double.isNaN(actual)) {\n+            Assert.assertTrue(msg, Double.isNaN(expected));\n+        } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {\n+            Assert.assertEquals(expected, actual, relativeError);\n+        } else if (expected == 0.0) {\n+            Assert.assertEquals(msg, actual, expected, relativeError);\n+        } else {\n+            double x = Math.abs((expected - actual) / expected);\n+            Assert.assertEquals(msg, 0.0, x, relativeError);\n+        }\n+    }\n+    \n+    /**\n+     * Fails iff values does not contain a number within epsilon of z.\n+     * \n+     * @param msg  message to return with failure\n+     * @param values complex array to search\n+     * @param z  value sought\n+     * @param epsilon  tolerance\n+     */\n+    public static void assertContains(String msg, Complex[] values,\n+            Complex z, double epsilon) {\n+        int i = 0;\n+        boolean found = false;\n+        while (!found && i < values.length) {\n+            try {\n+                assertEquals(values[i], z, epsilon);\n+                found = true; \n+            } catch (AssertionFailedError er) {\n+                // no match\n+            }\n+            i++;\n+        }\n+        if (!found) {\n+            Assert.fail(msg + \n+                \" Unable to find \" + ComplexFormat.formatComplex(z));\n+        }\n+    }\n+    \n+    /**\n+     * Fails iff values does not contain a number within epsilon of z.\n+     * \n+     * @param values complex array to search\n+     * @param z  value sought\n+     * @param epsilon  tolerance\n+     */\n+    public static void assertContains(Complex[] values,\n+            Complex z, double epsilon) {\n+        assertContains(null, values, z, epsilon);      \n+    }\n+    \n+    /**\n+     * Fails iff values does not contain a number within epsilon of x.\n+     * \n+     * @param msg  message to return with failure\n+     * @param values double array to search\n+     * @param x value sought\n+     * @param epsilon  tolerance\n+     */\n+    public static void assertContains(String msg, double[] values,\n+            double x, double epsilon) {\n+        int i = 0;\n+        boolean found = false;\n+        while (!found && i < values.length) {\n+            try {\n+                assertEquals(values[i], x, epsilon);\n+                found = true; \n+            } catch (AssertionFailedError er) {\n+                // no match\n+            }\n+            i++;\n+        }\n+        if (!found) {\n+            Assert.fail(msg + \" Unable to find\" + x);\n+        }\n+    }\n+    \n+    /**\n+     * Fails iff values does not contain a number within epsilon of x.\n+     * \n+     * @param values double array to search\n+     * @param x value sought\n+     * @param epsilon  tolerance\n+     */\n+    public static void assertContains(double[] values, double x,\n+            double epsilon) {\n+       assertContains(null, values, x, epsilon);\n+    }\n+    \n+    /** verifies that two matrices are close (1-norm) */              \n+    public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed,\n+        double tolerance) {\n+        \n+        if (observed == null) {\n+            Assert.fail(msg + \"\\nObserved is null\");\n+        }\n+        \n+        if (expected.getColumnDimension() != observed.getColumnDimension() || \n+                expected.getRowDimension() != observed.getRowDimension()) {\n+            StringBuffer messageBuffer = new StringBuffer(msg);\n+            messageBuffer.append(\"\\nObserved has incorrect dimensions.\"); \n+            messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() +\n+                    \" x \" + observed.getColumnDimension());\n+            messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() +\n+                    \" x \" + expected.getColumnDimension());\n+            Assert.fail(messageBuffer.toString());\n+        }\n+\n+        RealMatrix delta = expected.subtract(observed);\n+        if (delta.getNorm() >= tolerance) {\n+            StringBuffer messageBuffer = new StringBuffer(msg);\n+            messageBuffer.append(\"\\nExpected: \" + expected);\n+            messageBuffer.append(\"\\nObserved: \" + observed);\n+            messageBuffer.append(\"\\nexpected - observed: \" + delta);\n+            Assert.fail(messageBuffer.toString());\n+        }\n+    }\n+    \n+    /** verifies that two matrices are equal */              \n+    public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,\n+                                    FieldMatrix<? extends FieldElement<?>> observed) {\n+        \n+        if (observed == null) {\n+            Assert.fail(\"Observed is null\");\n+        }\n+        \n+        if (expected.getColumnDimension() != observed.getColumnDimension() || \n+                expected.getRowDimension() != observed.getRowDimension()) {\n+            StringBuffer messageBuffer = new StringBuffer();\n+            messageBuffer.append(\"Observed has incorrect dimensions.\"); \n+            messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() +\n+                    \" x \" + observed.getColumnDimension());\n+            messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() +\n+                    \" x \" + expected.getColumnDimension());\n+            Assert.fail(messageBuffer.toString());\n+        }\n+\n+        for (int i = 0; i < expected.getRowDimension(); ++i) {\n+            for (int j = 0; j < expected.getColumnDimension(); ++j) {\n+                FieldElement<?> eij = expected.getEntry(i, j);\n+                FieldElement<?> oij = observed.getEntry(i, j);\n+                Assert.assertEquals(eij, oij);\n+            }\n+        }\n+    }\n+    \n+    /** verifies that two arrays are close (sup norm) */\n+    public static void assertEquals(String msg, double[] expected, double[] observed,\n+        double tolerance) {\n+        StringBuffer out = new StringBuffer(msg);\n+        if (expected.length != observed.length) {\n+            out.append(\"\\n Arrays not same length. \\n\");\n+            out.append(\"expected has length \");\n+            out.append(expected.length);\n+            out.append(\" observed length = \");\n+            out.append(observed.length);\n+            Assert.fail(out.toString());\n+        }\n+        boolean failure = false;\n+        for (int i=0; i < expected.length; i++) {\n+            try {\n+                assertEquals(expected[i], observed[i], tolerance);\n+            } catch (AssertionFailedError ex) {\n+                failure = true;\n+                out.append(\"\\n Elements at index \");\n+                out.append(i);\n+                out.append(\" differ. \");\n+                out.append(\" expected = \");\n+                out.append(expected[i]);\n+                out.append(\" observed = \");\n+                out.append(observed[i]); \n+            }\n+        }\n+        if (failure) {\n+            Assert.fail(out.toString());\n+        }\n+    }\n+    \n+    /** verifies that two arrays are equal */\n+    public static <T extends FieldElement<T>> void assertEquals(T[] m, T[] n) {\n+        if (m.length != n.length) {\n+            Assert.fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            Assert.assertEquals(m[i],n[i]);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxillary class for testing purposes.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Expm1Function implements DifferentiableUnivariateRealFunction {\n+\n+    public double value(double x) throws FunctionEvaluationException {\n+        // Math.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n+        return Math.exp(x) - 1.0;\n+    }\n+\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws FunctionEvaluationException {\n+                return Math.exp(x);\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Wrapper class for counting functions calls.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public class MonitoredFunction implements UnivariateRealFunction {\n+\n+    public MonitoredFunction(UnivariateRealFunction f) {\n+        callsCount = 0;\n+        this.f = f;\n+    }\n+\n+    public void setCallsCount(int callsCount) {\n+        this.callsCount = callsCount;\n+    }\n+\n+    public int getCallsCount() {\n+        return callsCount;\n+    }\n+\n+    public double value(double x) throws FunctionEvaluationException {\n+        ++callsCount;\n+        return f.value(x);\n+    }\n+\n+    private int callsCount;\n+    private UnivariateRealFunction f;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxillary class for testing solvers.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public class QuinticFunction implements DifferentiableUnivariateRealFunction {\n+\n+    /* Evaluate quintic.\n+     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) throws FunctionEvaluationException {\n+        return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);\n+    }\n+\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws FunctionEvaluationException {\n+                return (5*x*x-3.75)*x*x+0.25;\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxillary class for testing solvers.\n+ *\n+ * The function is extraordinarily well behaved around zero roots: it\n+ * has an inflection point there (second order derivative is zero),\n+ * which means linear approximation (Regula Falsi) will converge\n+ * quadratically.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class SinFunction implements DifferentiableUnivariateRealFunction {\n+\n+    /* Evaluate sinus fuction.\n+     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) throws FunctionEvaluationException {\n+        return Math.sin(x);\n+    }\n+\n+    /* First derivative of sinus function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws FunctionEvaluationException {\n+                return Math.cos(x);\n+            }\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+\n+import junit.framework.*;\n+\n+public class LegendreGaussIntegratorTest\n+extends TestCase {\n+\n+    public LegendreGaussIntegratorTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(5, 64);\n+        integrator.setAbsoluteAccuracy(1.0e-10);\n+        integrator.setRelativeAccuracy(1.0e-14);\n+        integrator.setMinimalIterationCount(2);\n+        integrator.setMaximalIterationCount(15);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.max(integrator.getAbsoluteAccuracy(),\n+                             Math.abs(expected * integrator.getRelativeAccuracy()));\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.max(integrator.getAbsoluteAccuracy(),\n+                Math.abs(expected * integrator.getRelativeAccuracy()));\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);\n+        double min, max, expected, result;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, 1.0e-16);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, 1.0e-16);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, 1.0e-16);\n+    }\n+\n+    public void testExactIntegration()\n+        throws ConvergenceException, FunctionEvaluationException {\n+        Random random = new Random(86343623467878363l);\n+        for (int n = 2; n < 6; ++n) {\n+            LegendreGaussIntegrator integrator =\n+                new LegendreGaussIntegrator(n, 64);\n+\n+            // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly\n+            for (int degree = 0; degree <= 2 * n - 1; ++degree) {\n+                for (int i = 0; i < 10; ++i) {\n+                    double[] coeff = new double[degree + 1];\n+                    for (int k = 0; k < coeff.length; ++k) {\n+                        coeff[k] = 2 * random.nextDouble() - 1;\n+                    }\n+                    PolynomialFunction p = new PolynomialFunction(coeff);\n+                    double result    = integrator.integrate(p, -5.0, 15.0);\n+                    double reference = exactIntegration(p, -5.0, 15.0);\n+                    assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + Math.abs(reference)));\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    private double exactIntegration(PolynomialFunction p, double a, double b) {\n+        final double[] coeffs = p.getCoefficients();\n+        double yb = coeffs[coeffs.length - 1] / coeffs.length;\n+        double ya = yb;\n+        for (int i = coeffs.length - 2; i >= 0; --i) {\n+            yb = yb * b + coeffs[i] / (i + 1);\n+            ya = ya * a + coeffs[i] / (i + 1);\n+        }\n+        return yb * b - ya * a;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(LegendreGaussIntegratorTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Romberg integrator.\n+ * <p>\n+ * Romberg algorithm is very fast for good behavior integrand. Test runs\n+ * show that for a default relative accuracy of 1E-6, it generally takes\n+ * takes less than 5 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RombergIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator();\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(f, -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(50);\n+            integrator.integrate(f, -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Simpson integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it\n+ * generally takes 5 to 10 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class SimpsonIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(f, -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(99);\n+            integrator.integrate(f, -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for trapezoid integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it\n+ * generally takes 10 to 15 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class TrapezoidIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(f, -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(99);\n+            integrator.integrate(f, -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Divided Difference interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class DividedDifferenceInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.MathException;\n+import org.junit.Test;\n+\n+/**\n+ * Test of the LoessInterpolator class.\n+ */\n+public class LoessInterpolatorTest {\n+\n+    @Test\n+    public void testOnOnePoint() throws MathException {\n+        double[] xval = {0.5};\n+        double[] yval = {0.7};\n+        double[] res = new LoessInterpolator().smooth(xval, yval);\n+        assertEquals(1, res.length);\n+        assertEquals(0.7, res[0], 0.0);\n+    }\n+\n+    @Test\n+    public void testOnTwoPoints() throws MathException {\n+        double[] xval = {0.5, 0.6};\n+        double[] yval = {0.7, 0.8};\n+        double[] res = new LoessInterpolator().smooth(xval, yval);\n+        assertEquals(2, res.length);\n+        assertEquals(0.7, res[0], 0.0);\n+        assertEquals(0.8, res[1], 0.0);\n+    }\n+\n+    @Test\n+    public void testOnStraightLine() throws MathException {\n+        double[] xval = {1,2,3,4,5};\n+        double[] yval = {2,4,6,8,10};\n+        LoessInterpolator li = new LoessInterpolator(0.6, 2);\n+        double[] res = li.smooth(xval, yval);\n+        assertEquals(5, res.length);\n+        for(int i = 0; i < 5; ++i) {\n+            assertEquals(yval[i], res[i], 1e-8);\n+        }\n+    }\n+\n+    @Test\n+    public void testOnDistortedSine() throws MathException {\n+        int numPoints = 100;\n+        double[] xval = new double[numPoints];\n+        double[] yval = new double[numPoints];\n+        double xnoise = 0.1;\n+        double ynoise = 0.2;\n+\n+        generateSineData(xval, yval, xnoise, ynoise);\n+\n+        LoessInterpolator li = new LoessInterpolator(0.3, 4);\n+\n+        double[] res = li.smooth(xval, yval);\n+\n+        // Check that the resulting curve differs from\n+        // the \"real\" sine less than the jittered one\n+\n+        double noisyResidualSum = 0;\n+        double fitResidualSum = 0;\n+\n+        for(int i = 0; i < numPoints; ++i) {\n+            double expected = Math.sin(xval[i]);\n+            double noisy = yval[i];\n+            double fit = res[i];\n+\n+            noisyResidualSum += Math.pow(noisy - expected, 2);\n+            fitResidualSum += Math.pow(fit - expected, 2);\n+        }\n+\n+        assertTrue(fitResidualSum < noisyResidualSum);\n+    }\n+\n+    @Test\n+    public void testIncreasingBandwidthIncreasesSmoothness() throws MathException {\n+        int numPoints = 100;\n+        double[] xval = new double[numPoints];\n+        double[] yval = new double[numPoints];\n+        double xnoise = 0.1;\n+        double ynoise = 0.1;\n+\n+        generateSineData(xval, yval, xnoise, ynoise);\n+\n+        // Check that variance decreases as bandwidth increases\n+\n+        double[] bandwidths = {0.1, 0.5, 1.0};\n+        double[] variances = new double[bandwidths.length];\n+        for (int i = 0; i < bandwidths.length; i++) {\n+            double bw = bandwidths[i];\n+\n+            LoessInterpolator li = new LoessInterpolator(bw, 4);\n+\n+            double[] res = li.smooth(xval, yval);\n+\n+            for (int j = 1; j < res.length; ++j) {\n+                variances[i] += Math.pow(res[j] - res[j-1], 2);\n+            }\n+        }\n+\n+        for(int i = 1; i < variances.length; ++i) {\n+            assertTrue(variances[i] < variances[i-1]);\n+        }\n+    }\n+\n+    @Test\n+    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() throws MathException {\n+        int numPoints = 100;\n+        double[] xval = new double[numPoints];\n+        double[] yval = new double[numPoints];\n+        double xnoise = 0.1;\n+        double ynoise = 0.1;\n+\n+        generateSineData(xval, yval, xnoise, ynoise);\n+\n+        // Introduce a couple of outliers\n+        yval[numPoints/3] *= 100;\n+        yval[2 * numPoints/3] *= -100;\n+\n+        // Check that variance decreases as the number of robustness\n+        // iterations increases\n+\n+        double[] variances = new double[4];\n+        for (int i = 0; i < 4; i++) {\n+            LoessInterpolator li = new LoessInterpolator(0.3, i);\n+\n+            double[] res = li.smooth(xval, yval);\n+\n+            for (int j = 1; j < res.length; ++j) {\n+                variances[i] += Math.abs(res[j] - res[j-1]);\n+            }\n+        }\n+\n+        for(int i = 1; i < variances.length; ++i) {\n+            assertTrue(variances[i] < variances[i-1]);\n+        }\n+    }\n+\n+    @Test\n+    public void testUnequalSizeArguments() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyData() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {}, new double[] {});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testNonStrictlyIncreasing() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testNotAllFiniteReal() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testInsufficientBandwidth() {\n+        try {\n+            LoessInterpolator li = new LoessInterpolator(0.1, 3);\n+            li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testCompletelyIncorrectBandwidth() {\n+        try {\n+            new LoessInterpolator(-0.2, 3);\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator(1.1, 3);\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {\n+        double dx = 2 * Math.PI / xval.length;\n+        double x = 0;\n+        for(int i = 0; i < xval.length; ++i) {\n+            xval[i] = x;\n+            yval[i] = Math.sin(x) + (2 * Math.random() - 1) * ynoise;\n+            x += dx * (1 + (2 * Math.random() - 1) * xnoise);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Neville interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class NevilleInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test the SplineInterpolator.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public class SplineInterpolatorTest extends TestCase {\n+    \n+    /** error tolerance for spline interpolator value at knot points */\n+    protected double knotTolerance = 1E-12;\n+   \n+    /** error tolerance for interpolating polynomial coefficients */\n+    protected double coefficientTolerance = 1E-6;\n+    \n+    /** error tolerance for interpolated values -- high value is from sin test */\n+    protected double interpolationTolerance = 1E-2;\n+\n+    public SplineInterpolatorTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SplineInterpolatorTest.class);\n+        suite.setName(\"UnivariateRealInterpolator Tests\");\n+        return suite;\n+    }\n+\n+    public void testInterpolateLinearDegenerateTwoSegment()\n+        throws Exception {\n+        double x[] = { 0.0, 0.5, 1.0 };\n+        double y[] = { 0.0, 0.5, 1.0 };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        verifyConsistency((PolynomialSplineFunction) f, x);\n+        \n+        // Verify coefficients using analytical values\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 1d};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+        \n+        // Check interpolation\n+        assertEquals(0.0,f.value(0.0), interpolationTolerance);\n+        assertEquals(0.4,f.value(0.4), interpolationTolerance);\n+        assertEquals(1.0,f.value(1.0), interpolationTolerance);\n+    }\n+\n+    public void testInterpolateLinearDegenerateThreeSegment()\n+        throws Exception {\n+        double x[] = { 0.0, 0.5, 1.0, 1.5 };\n+        double y[] = { 0.0, 0.5, 1.0, 1.5 };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        \n+        // Verify coefficients using analytical values\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 1d};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[2], 1d};\n+        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);\n+        \n+        // Check interpolation\n+        assertEquals(0,f.value(0), interpolationTolerance);\n+        assertEquals(1.4,f.value(1.4), interpolationTolerance);\n+        assertEquals(1.5,f.value(1.5), interpolationTolerance);\n+    }\n+\n+    public void testInterpolateLinear() throws Exception {\n+        double x[] = { 0.0, 0.5, 1.0 };\n+        double y[] = { 0.0, 0.5, 0.0 };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        verifyConsistency((PolynomialSplineFunction) f, x);\n+        \n+        // Verify coefficients using analytical values\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1.5d, 0d, -2d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 0d, -3d, 2d};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    \n+    }\n+    \n+    public void testInterpolateSin() throws Exception {\n+        double x[] =\n+            {\n+                0.0,\n+                Math.PI / 6d,\n+                Math.PI / 2d,\n+                5d * Math.PI / 6d,\n+                Math.PI,\n+                7d * Math.PI / 6d,\n+                3d * Math.PI / 2d,\n+                11d * Math.PI / 6d,\n+                2.d * Math.PI };\n+        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        verifyConsistency((PolynomialSplineFunction) f, x);\n+        \n+        /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)\n+         * \n+         * To replicate in R:\n+         *     x[1] <- 0\n+         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)\n+         *     g <- splinefun(x, y, \"natural\")\n+         *     splinecoef <- eval(expression(z), envir = environment(g))\n+         *     print(splinecoef) \n+         */\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};\n+        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};\n+        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};\n+        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};\n+        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};\n+        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};\n+        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); \n+        \n+        //Check interpolation\n+        assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);\n+        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);     \n+    }\n+    \n+\n+    public void testIllegalArguments() throws MathException {\n+        // Data set arrays of different size.\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        try {\n+            double xval[] = { 0.0, 1.0 };\n+            double yval[] = { 0.0, 1.0, 2.0 };\n+            i.interpolate(xval, yval);\n+            fail(\"Failed to detect data set array with different sizes.\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+        // X values not sorted.\n+        try {\n+            double xval[] = { 0.0, 1.0, 0.5 };\n+            double yval[] = { 0.0, 1.0, 2.0 };\n+            i.interpolate(xval, yval);\n+            fail(\"Failed to detect unsorted arguments.\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+    }\n+    \n+    /**\n+     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.\n+     */\n+    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])  \n+        throws Exception{\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(f.value(x[i]), y[i], knotTolerance);\n+        }     \n+    }\n+    \n+    /**\n+     * Verifies that interpolating polynomials satisfy consistency requirement:\n+     *    adjacent polynomials must agree through two derivatives at knot points\n+     */\n+    protected void verifyConsistency(PolynomialSplineFunction f, double x[]) \n+        throws Exception {\n+        PolynomialFunction polynomials[] = f.getPolynomials();\n+        for (int i = 1; i < x.length - 2; i++) {\n+            // evaluate polynomials and derivatives at x[i + 1]  \n+            assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); \n+            assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), \n+                    polynomials[i + 1].derivative().value(0), 0.5); \n+            assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), \n+                    polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); \n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Lagrange form of polynomial function.\n+ * <p>\n+ * We use n+1 points to interpolate a polynomial of degree n. This should\n+ * give us the exact same polynomial as result. Thus we can use a very\n+ * small tolerance to account only for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4\n+        double x[] = { 0.0, 3.0 };\n+        double y[] = { -4.0, 0.5 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(2, c.length);\n+        assertEquals(-4.0, c[0], tolerance);\n+        assertEquals(1.5, c[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)\n+        double x[] = { 0.0, -1.0, 0.5 };\n+        double y[] = { -3.0, -6.0, 0.0 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(3, c.length);\n+        assertEquals(-3.0, c[0], tolerance);\n+        assertEquals(5.0, c[1], tolerance);\n+        assertEquals(2.0, c[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)\n+        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };\n+        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(6, c.length);\n+        assertEquals(0.0, c[0], tolerance);\n+        assertEquals(6.0, c[1], tolerance);\n+        assertEquals(1.0, c[2], tolerance);\n+        assertEquals(-7.0, c[3], tolerance);\n+        assertEquals(-1.0, c[4], tolerance);\n+        assertEquals(1.0, c[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+\n+        try {\n+            // bad input array length\n+            double x[] = { 1.0 };\n+            double y[] = { 2.0 };\n+            new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double x[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double y[] = { 0.0, -4.0, -24.0 };\n+            new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Newton form of polynomial function.\n+ * <p>\n+ * The small tolerance number is used only to account for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionNewtonFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)\n+        double a[] = { 2.0, 1.5 };\n+        double c[] = { 4.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(2, coefficients.length);\n+        assertEquals(-4.0, coefficients[0], tolerance);\n+        assertEquals(1.5, coefficients[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)\n+        double a[] = { 4.0, 3.0, 2.0 };\n+        double c[] = { 1.0, -2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(3, coefficients.length);\n+        assertEquals(-3.0, coefficients[0], tolerance);\n+        assertEquals(5.0, coefficients[1], tolerance);\n+        assertEquals(2.0, coefficients[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x\n+        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)\n+        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };\n+        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(6, coefficients.length);\n+        assertEquals(0.0, coefficients[0], tolerance);\n+        assertEquals(6.0, coefficients[1], tolerance);\n+        assertEquals(1.0, coefficients[2], tolerance);\n+        assertEquals(-7.0, coefficients[3], tolerance);\n+        assertEquals(-1.0, coefficients[4], tolerance);\n+        assertEquals(1.0, coefficients[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+\n+        try {\n+            // bad input array length\n+            double a[] = { 1.0 };\n+            double c[] = { 2.0 };\n+            new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double a[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double c[] = { 4.0, 3.0, 2.0, 1.0 };\n+            new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+// commons-math\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+// junit\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the PolynomialFunction implementation of a UnivariateRealFunction.\n+ *\n+ * @version $Revision$\n+ * @author Matt Cliff <matt@mattcliff.com>\n+ */\n+public final class PolynomialFunctionTest extends TestCase {\n+\n+    /** Error tolerance for tests */\n+    protected double tolerance = 1.0e-12;\n+\n+    /**\n+     * tests the value of a constant polynomial.\n+     *\n+     * <p>value of this is 2.5 everywhere.</p>\n+     */\n+    public void testConstants() throws MathException {\n+        double[] c = { 2.5 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] at several (nonsymmetric) places\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+        assertEquals( f.value( -1.0), c[0], tolerance );\n+        assertEquals( f.value( -123.5), c[0], tolerance );\n+        assertEquals( f.value( 3.0), c[0], tolerance );\n+        assertEquals( f.value( 456.89), c[0], tolerance );\n+        \n+        assertEquals(f.degree(), 0);\n+        assertEquals(f.derivative().value(0), 0, tolerance);\n+        \n+        assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);\n+    }\n+\n+    /**\n+     * tests the value of a linear polynomial.\n+     *\n+     * <p>This will test the function f(x) = 3*x - 1.5</p>\n+     * <p>This will have the values \n+     *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,\n+     *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>\n+     * </p>\n+     */\n+    public void testLinear() throws MathException {\n+        double[] c = { -1.5, 3.0 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] when x=0\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+\n+        // now check a few other places\n+        assertEquals( -4.5, f.value( -1.0), tolerance );\n+        assertEquals( -9.0, f.value( -2.5), tolerance );\n+        assertEquals( 0.0, f.value( 0.5), tolerance );\n+        assertEquals( 3.0, f.value( 1.5), tolerance );\n+        assertEquals( 7.5, f.value( 3.0), tolerance );\n+        \n+        assertEquals(f.degree(), 1);\n+        \n+        assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);\n+    \n+    }\n+\n+\n+    /**\n+     * Tests a second order polynomial.\n+     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>\n+     *\n+     */\n+    public void testQuadratic() {\n+        double[] c = { -2.0, -3.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] when x=0\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+\n+        // now check a few other places\n+        assertEquals( 0.0, f.value( -0.5), tolerance );\n+        assertEquals( 0.0, f.value( 2.0), tolerance );\n+        assertEquals( -2.0, f.value( 1.5), tolerance );\n+        assertEquals( 7.0, f.value( -1.5), tolerance );\n+        assertEquals( 265.5312, f.value( 12.34), tolerance );\n+    \n+    }    \n+\n+\n+    /** \n+     * This will test the quintic function \n+     *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>\n+     *\n+     */\n+    public void testQuintic() {\n+        double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] when x=0\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+\n+        // now check a few other places\n+        assertEquals( 0.0, f.value( 5.0), tolerance );\n+        assertEquals( 0.0, f.value( 1.0), tolerance );\n+        assertEquals( 0.0, f.value( -3.0), tolerance );\n+        assertEquals( 54.84375, f.value( -1.5), tolerance );\n+        assertEquals( -8.06637, f.value( 1.3), tolerance );\n+        \n+        assertEquals(f.degree(), 5);\n+    \n+    }    \n+\n+\n+    /**\n+     * tests the firstDerivative function by comparison\n+     *\n+     * <p>This will test the functions \n+     * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>\n+     * and <tt>h(x) = 6x - 4</tt>\n+     */\n+    public void testfirstDerivativeComparison() throws MathException {\n+        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };\n+        double[] g_coeff = { 6.0, -4.0, 3.0 };\n+        double[] h_coeff = { -4.0, 6.0 };\n+\n+        PolynomialFunction f = new PolynomialFunction( f_coeff );\n+        PolynomialFunction g = new PolynomialFunction( g_coeff );\n+        PolynomialFunction h = new PolynomialFunction( h_coeff );\n+\n+        // compare f' = g\n+        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );\n+        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );\n+        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );\n+        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );\n+        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );\n+\n+        // compare g' = h\n+        assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );\n+        assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );\n+\n+    }\n+\n+    public void testString() {\n+        PolynomialFunction p = new PolynomialFunction(new double[] { -5.0, 3.0, 1.0 });\n+        checkPolynomial(p, \"-5.0 + 3.0 x + x^2\");\n+        checkPolynomial(new PolynomialFunction(new double[] { 0.0, -2.0, 3.0 }),\n+                        \"-2.0 x + 3.0 x^2\");\n+        checkPolynomial(new PolynomialFunction(new double[] { 1.0, -2.0, 3.0 }),\n+                      \"1.0 - 2.0 x + 3.0 x^2\");\n+        checkPolynomial(new PolynomialFunction(new double[] { 0.0,  2.0, 3.0 }),\n+                       \"2.0 x + 3.0 x^2\");\n+        checkPolynomial(new PolynomialFunction(new double[] { 1.0,  2.0, 3.0 }),\n+                     \"1.0 + 2.0 x + 3.0 x^2\");\n+        checkPolynomial(new PolynomialFunction(new double[] { 1.0,  0.0, 3.0 }),\n+                     \"1.0 + 3.0 x^2\");\n+        checkPolynomial(new PolynomialFunction(new double[] { 0.0 }),\n+                     \"0\");\n+    }\n+\n+    public void testAddition() {\n+\n+        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2.0, 1.0 });\n+        PolynomialFunction p2 = new PolynomialFunction(new double[] { 2.0, -1.0, 0.0 });\n+        checkNullPolynomial(p1.add(p2));\n+\n+        p2 = p1.add(p1);\n+        checkPolynomial(p2, \"-4.0 + 2.0 x\");\n+\n+        p1 = new PolynomialFunction(new double[] { 1.0, -4.0, 2.0 });\n+        p2 = new PolynomialFunction(new double[] { -1.0, 3.0, -2.0 });\n+        p1 = p1.add(p2);\n+        assertEquals(1, p1.degree());\n+        checkPolynomial(p1, \"-x\");\n+\n+    }\n+\n+    public void testSubtraction() {\n+\n+        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2.0, 1.0 });\n+        checkNullPolynomial(p1.subtract(p1));\n+\n+        PolynomialFunction p2 = new PolynomialFunction(new double[] { -2.0, 6.0 });\n+        p2 = p2.subtract(p1);\n+        checkPolynomial(p2, \"5.0 x\");\n+\n+        p1 = new PolynomialFunction(new double[] { 1.0, -4.0, 2.0 });\n+        p2 = new PolynomialFunction(new double[] { -1.0, 3.0, 2.0 });\n+        p1 = p1.subtract(p2);\n+        assertEquals(1, p1.degree());\n+        checkPolynomial(p1, \"2.0 - 7.0 x\");\n+\n+    }\n+\n+    public void testMultiplication() {\n+\n+        PolynomialFunction p1 = new PolynomialFunction(new double[] { -3.0, 2.0 });\n+        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3.0, 2.0, 1.0 });\n+        checkPolynomial(p1.multiply(p2), \"-9.0 + x^2 + 2.0 x^3\");\n+\n+        p1 = new PolynomialFunction(new double[] { 0.0, 1.0 });\n+        p2 = p1;\n+        for (int i = 2; i < 10; ++i) {\n+            p2 = p2.multiply(p1);\n+            checkPolynomial(p2, \"x^\" + i);\n+        }\n+\n+    }\n+\n+    public void testSerial() {\n+        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3.0, 2.0, 1.0 });\n+        assertEquals(p2, TestUtils.serializeAndRecover(p2));\n+    }\n+    \n+    public void checkPolynomial(PolynomialFunction p, String reference) {\n+        assertEquals(reference, p.toString());\n+    }\n+\n+    private void checkNullPolynomial(PolynomialFunction p) {\n+        for (double coefficient : p.getCoefficients()) {\n+            assertEquals(0.0, coefficient, 1.0e-15);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.util.Arrays;\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Tests the PolynomialSplineFunction implementation.\n+ *\n+ * @version $Revision$\n+ */\n+public class PolynomialSplineFunctionTest extends TestCase {\n+\n+    /** Error tolerance for tests */\n+    protected double tolerance = 1.0e-12;\n+    \n+    /** \n+     * Quadratic polynomials used in tests: \n+     * \n+     * x^2 + x            [-1, 0)\n+     * x^2 + x + 2        [0, 1)\n+     * x^2 + x + 4        [1, 2)\n+     * \n+     * Defined so that evaluation using PolynomialSplineFunction evaluation\n+     * algorithm agrees at knot point boundaries.\n+     */\n+    protected PolynomialFunction[] polynomials = {\n+        new PolynomialFunction(new double[] {0d, 1d, 1d}), \n+        new PolynomialFunction(new double[] {2d, 1d, 1d}),\n+        new PolynomialFunction(new double[] {4d, 1d, 1d})\n+    };\n+    \n+    /** Knot points  */\n+    protected double[] knots = {-1, 0, 1, 2};\n+    \n+    /** Derivative of test polynomials -- 2x + 1  */\n+    protected PolynomialFunction dp = \n+        new PolynomialFunction(new double[] {1d, 2d});\n+    \n+    \n+    public void testConstructor() {\n+        PolynomialSplineFunction spline = \n+            new PolynomialSplineFunction(knots, polynomials);\n+        assertTrue(Arrays.equals(knots, spline.getKnots()));\n+        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);\n+        assertEquals(3, spline.getN());\n+        \n+        try { // too few knots\n+            new PolynomialSplineFunction(new double[] {0}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try { // too many knots\n+            new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try { // knots not increasing\n+            new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testValues() throws Exception {\n+        PolynomialSplineFunction spline = \n+            new PolynomialSplineFunction(knots, polynomials);\n+        UnivariateRealFunction dSpline = spline.derivative();\n+        \n+        /**\n+         * interior points -- spline value at x should equal p(x - knot)\n+         * where knot is the largest knot point less than or equal to x and p \n+         * is the polynomial defined over the knot segment to which x belongs.\n+         */\n+        double x = -1;\n+        int index = 0;\n+        for (int i = 0; i < 10; i++) {\n+           x+=0.25;\n+           index = findKnot(knots, x);\n+           assertEquals(\"spline function evaluation failed for x=\" + x, \n+                   polynomials[index].value(x - knots[index]), spline.value(x), tolerance);\n+           assertEquals(\"spline derivative evaluation failed for x=\" + x,\n+                   dp.value(x - knots[index]), dSpline.value(x), tolerance);\n+        }\n+        \n+        // knot points -- centering should zero arguments\n+        for (int i = 0; i < 3; i++) {\n+            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+                    polynomials[i].value(0), spline.value(knots[i]), tolerance);\n+            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+                    dp.value(0), dSpline.value(knots[i]), tolerance);\n+        }\n+        \n+        try { //outside of domain -- under min\n+            x = spline.value(-1.5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (FunctionEvaluationException ex) {\n+            // expected\n+        }\n+        \n+        try { //outside of domain -- over max\n+            x = spline.value(2.5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (FunctionEvaluationException ex) {\n+            // expected\n+        }         \n+    }  \n+    \n+    /**\n+     *  Do linear search to find largest knot point less than or equal to x.\n+     *  Implementation does binary search.\n+     */\n+     protected int findKnot(double[] knots, double x) {\n+         if (x < knots[0] || x >= knots[knots.length -1]) {\n+             throw new IllegalArgumentException(\"x is out of range\");\n+         }\n+         for (int i = 0; i < knots.length; i++) {\n+             if (knots[i] > x) {\n+                 return i -1;\n+             }\n+         }\n+         throw new IllegalArgumentException(\"x is out of range\");\n+     }\n+}\n+    \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the PolynomialsUtils class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialsUtilsTest extends TestCase {\n+\n+    public void testFirstChebyshevPolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), \"-3.0 x + 4.0 x^3\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), \"-1.0 + 2.0 x^2\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), \"x\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), \"-7.0 x + 56.0 x^3 - 112.0 x^5 + 64.0 x^7\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), \"-1.0 + 18.0 x^2 - 48.0 x^4 + 32.0 x^6\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), \"5.0 x - 20.0 x^3 + 16.0 x^5\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), \"1.0 - 8.0 x^2 + 8.0 x^4\");\n+\n+    }\n+\n+    public void testChebyshevBounds() {\n+        for (int k = 0; k < 12; ++k) {\n+            PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);\n+            for (double x = -1.0; x <= 1.0; x += 0.02) {\n+                assertTrue(k + \" \" + Tk.value(x), Math.abs(Tk.value(x)) < (1.0 + 1.0e-12));\n+            }\n+        }\n+    }\n+\n+    public void testChebyshevDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k);\n+            PolynomialFunction Tk1 = Tk0.polynomialDerivative();\n+            PolynomialFunction Tk2 = Tk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1});\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });\n+\n+            PolynomialFunction Tk0g0 = Tk0.multiply(g0);\n+            PolynomialFunction Tk1g1 = Tk1.multiply(g1);\n+            PolynomialFunction Tk2g2 = Tk2.multiply(g2);\n+\n+            checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));\n+\n+        }\n+    }\n+\n+    public void testFirstHermitePolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), \"-12.0 x + 8.0 x^3\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), \"-2.0 + 4.0 x^2\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), \"2.0 x\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), \"-1680.0 x + 3360.0 x^3 - 1344.0 x^5 + 128.0 x^7\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), \"-120.0 + 720.0 x^2 - 480.0 x^4 + 64.0 x^6\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), \"120.0 x - 160.0 x^3 + 32.0 x^5\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), \"12.0 - 48.0 x^2 + 16.0 x^4\");\n+\n+    }\n+\n+    public void testHermiteDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k);\n+            PolynomialFunction Hk1 = Hk0.polynomialDerivative();\n+            PolynomialFunction Hk2 = Hk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 });\n+\n+            PolynomialFunction Hk0g0 = Hk0.multiply(g0);\n+            PolynomialFunction Hk1g1 = Hk1.multiply(g1);\n+            PolynomialFunction Hk2g2 = Hk2.multiply(g2);\n+\n+            checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));\n+\n+        }\n+    }\n+\n+    public void testFirstLaguerrePolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, \"6.0 - 18.0 x + 9.0 x^2 - x^3\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, \"2.0 - 4.0 x + x^2\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, \"1.0 - x\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l,\n+                \"5040.0 - 35280.0 x + 52920.0 x^2 - 29400.0 x^3\"\n+                + \" + 7350.0 x^4 - 882.0 x^5 + 49.0 x^6 - x^7\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),  720l,\n+                \"720.0 - 4320.0 x + 5400.0 x^2 - 2400.0 x^3 + 450.0 x^4\"\n+                + \" - 36.0 x^5 + x^6\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),  120l,\n+        \"120.0 - 600.0 x + 600.0 x^2 - 200.0 x^3 + 25.0 x^4 - x^5\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),   24l,\n+        \"24.0 - 96.0 x + 72.0 x^2 - 16.0 x^3 + x^4\");\n+\n+    }\n+\n+    public void testLaguerreDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k);\n+            PolynomialFunction Lk1 = Lk0.polynomialDerivative();\n+            PolynomialFunction Lk2 = Lk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { k });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 });\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 });\n+\n+            PolynomialFunction Lk0g0 = Lk0.multiply(g0);\n+            PolynomialFunction Lk1g1 = Lk1.multiply(g1);\n+            PolynomialFunction Lk2g2 = Lk2.multiply(g2);\n+\n+            checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));\n+\n+        }\n+    }\n+\n+    public void testFirstLegendrePolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),  2l, \"-3.0 x + 5.0 x^3\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),  2l, \"-1.0 + 3.0 x^2\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),  1l, \"x\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),  1l, \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, \"-35.0 x + 315.0 x^3 - 693.0 x^5 + 429.0 x^7\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, \"-5.0 + 105.0 x^2 - 315.0 x^4 + 231.0 x^6\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),  8l, \"15.0 x - 70.0 x^3 + 63.0 x^5\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),  8l, \"3.0 - 30.0 x^2 + 35.0 x^4\");\n+\n+    }\n+\n+    public void testLegendreDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k);\n+            PolynomialFunction Pk1 = Pk0.polynomialDerivative();\n+            PolynomialFunction Pk2 = Pk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });\n+\n+            PolynomialFunction Pk0g0 = Pk0.multiply(g0);\n+            PolynomialFunction Pk1g1 = Pk1.multiply(g1);\n+            PolynomialFunction Pk2g2 = Pk2.multiply(g2);\n+\n+            checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));\n+\n+        }\n+    }\n+\n+    public void testHighDegreeLegendre() {\n+        PolynomialsUtils.createLegendrePolynomial(40);\n+        double[] l40 = PolynomialsUtils.createLegendrePolynomial(40).getCoefficients();\n+        double denominator = 274877906944.0;\n+        double[] numerators = new double[] {\n+                          +34461632205.0,            -28258538408100.0,          +3847870979902950.0,        -207785032914759300.0,\n+                  +5929294332103310025.0,     -103301483474866556880.0,    +1197358103913226000200.0,    -9763073770369381232400.0,\n+              +58171647881784229843050.0,  -260061484647976556945400.0,  +888315281771246239250340.0, -2345767627188139419665400.0,\n+            +4819022625419112503443050.0, -7710436200670580005508880.0, +9566652323054238154983240.0, -9104813935044723209570256.0,\n+            +6516550296251767619752905.0, -3391858621221953912598660.0, +1211378079007840683070950.0,  -265365894974690562152100.0,\n+              +26876802183334044115405.0\n+        };\n+        for (int i = 0; i < l40.length; ++i) {\n+            if (i % 2 == 0) {\n+                double ci = numerators[i / 2] / denominator;\n+                assertEquals(ci, l40[i], Math.abs(ci) * 1.0e-15);\n+            } else {\n+                assertEquals(0.0, l40[i], 0.0);\n+            }\n+        }\n+    }\n+\n+    private void checkPolynomial(PolynomialFunction p, long denominator, String reference) {\n+        PolynomialFunction q = new PolynomialFunction(new double[] { denominator});\n+        assertEquals(reference, p.multiply(q).toString());\n+    }\n+\n+    private void checkPolynomial(PolynomialFunction p, String reference) {\n+        assertEquals(reference, p.toString());\n+    }\n+\n+    private void checkNullPolynomial(PolynomialFunction p) {\n+        for (double coefficient : p.getCoefficients()) {\n+            assertEquals(0.0, coefficient, 1.0e-13);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public final class BisectionSolverTest extends TestCase {\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        result = solver.solve(3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+    public void testSinZero() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        result = solver.solve(f, 3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+   public void testQuinticZero() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        \n+        assertEquals(result, solver.getResult(), 0);\n+        assertTrue(solver.getIterationCount() > 0);\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testSetFunctionValueAccuracy(){\n+        double expected = 1.0e-2;    \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setFunctionValueAccuracy(expected);\n+        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetFunctionValueAccuracy(){\n+        double newValue = 1.0e-2;    \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        double oldValue = solver.getFunctionValueAccuracy();\n+        solver.setFunctionValueAccuracy(newValue);\n+        solver.resetFunctionValueAccuracy();\n+        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testSetAbsoluteAccuracy(){\n+        double expected = 1.0e-2; \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setAbsoluteAccuracy(expected);\n+        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); \n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetAbsoluteAccuracy(){\n+        double newValue = 1.0e-2;       \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        double oldValue = solver.getAbsoluteAccuracy();\n+        solver.setAbsoluteAccuracy(newValue);\n+        solver.resetAbsoluteAccuracy();\n+        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testSetMaximalIterationCount(){\n+        int expected = 100;\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setMaximalIterationCount(expected);\n+        assertEquals(expected, solver.getMaximalIterationCount());\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetMaximalIterationCount(){\n+        int newValue = 10000;\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        int oldValue = solver.getMaximalIterationCount();\n+        solver.setMaximalIterationCount(newValue);\n+        solver.resetMaximalIterationCount();\n+        assertEquals(oldValue, solver.getMaximalIterationCount());\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testSetRelativeAccuracy(){\n+        double expected = 1.0e-2;\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setRelativeAccuracy(expected);\n+        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetRelativeAccuracy(){\n+        double newValue = 1.0e-2;        \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        double oldValue = solver.getRelativeAccuracy();\n+        solver.setRelativeAccuracy(newValue);\n+        solver.resetRelativeAccuracy();\n+        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n+    }        \n+    \n+   \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.MonitoredFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Testcase for UnivariateRealSolver.\n+ * Because Brent-Dekker is guaranteed to converge in less than the default\n+ * maximum iteration count due to bisection fallback, it is quite hard to\n+ * debug. I include measured iteration counts plus one in order to detect\n+ * regressions. On average Brent-Dekker should use 4..5 iterations for the\n+ * default absolute accuracy of 10E-8 for sinus and the quintic function around\n+ * zero, and 5..10 iterations for the other zeros.\n+ * \n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ \n+ */\n+public final class BrentSolverTest extends TestCase {\n+\n+    public BrentSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BrentSolverTest.class);\n+        suite.setName(\"UnivariateRealSolver Tests\");\n+        return suite;\n+    }\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        // Somewhat benign interval. The function is monotone.\n+        result = solver.solve(3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver(f);\n+        result = solver.solve(3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        assertEquals(result, solver.getResult(), 0);\n+    }\n+\n+    public void testSinZero() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver();\n+        // Somewhat benign interval. The function is monotone.\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver();\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        assertEquals(result, solver.getResult(), 0);\n+    }\n+\n+   public void testQuinticZero() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second derivative\n+        // of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1, because\n+        // the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        // intervals containing these values are harder for the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        // Brent-Dekker solver.\n+        UnivariateRealSolver solver = new BrentSolver();\n+        // Symmetric bracket around 0. Test whether solvers can handle hitting\n+        // the root in the first iteration.\n+        result = solver.solve(f, -0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertTrue(solver.getIterationCount() <= 2);\n+        // 1 iterations on i586 JDK 1.4.1.\n+        // Asymmetric bracket around 0, just for fun. Contains extremum.\n+        result = solver.solve(f, -0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        // Large bracket around 0. Contains two extrema.\n+        result = solver.solve(f, -0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Benign bracket around 0.5, function is monotonous.\n+        result = solver.solve(f, 0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Less benign bracket around 0.5, contains one extremum.\n+        result = solver.solve(f, 0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Large, less benign bracket around 0.5, contains both extrema.\n+        result = solver.solve(f, 0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n+        // is still a problem.\n+        result = solver.solve(f, 0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Less benign bracket around 1 with extremum.\n+        result = solver.solve(f, 0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Large bracket around 1. Monotonous.\n+        result = solver.solve(f, 0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        // Large bracket around 1. Interval contains extremum.\n+        result = solver.solve(f, 0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        // Very large bracket around 1 for testing fast growth behaviour.\n+        result = solver.solve(f, 0.85, 5);\n+        //System.out.println(\n+       //     \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 12 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 13);\n+        // Secant solver.\n+        solver = new SecantSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 1 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 2);\n+        result = solver.solve(f, -0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        result = solver.solve(f, -0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(f, 0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(f, 0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(f, 0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(f, 0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        result = solver.solve(f, 0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(f, 0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // The followig is especially slow because the solver first has to reduce\n+        // the bracket to exclude the extremum. After that, convergence is rapide.\n+        result = solver.solve(f, 0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(f, 0.85, 5);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // Static solve method\n+        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, 1E-8);\n+        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, 1E-6);\n+    }\n+    \n+    public void testRootEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new BrentSolver();\n+        \n+        // endpoint is root\n+        double result = solver.solve(f, Math.PI, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, Math.PI);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+    \n+    public void testBadEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new BrentSolver();\n+        try {  // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(f, 1, 1.5);\n+            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testInitialGuess() throws MathException {\n+\n+        MonitoredFunction f = new MonitoredFunction(new QuinticFunction());\n+        UnivariateRealSolver solver = new BrentSolver();\n+        double result;\n+\n+        // no guess\n+        result = solver.solve(f, 0.6, 7.0);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        int referenceCallsCount = f.getCallsCount();\n+        assertTrue(referenceCallsCount >= 13);\n+ \n+        // invalid guess (it *is* a root, but outside of the range)\n+        try {\n+          result = solver.solve(f, 0.6, 7.0, 0.0);\n+          fail(\"an IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behaviour\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+ \n+        // bad guess\n+        f.setCallsCount(0);\n+        result = solver.solve(f, 0.6, 7.0, 0.61);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertTrue(f.getCallsCount() > referenceCallsCount);\n+ \n+        // good guess\n+        f.setCallsCount(0);\n+        result = solver.solve(f, 0.6, 7.0, 0.999999);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertTrue(f.getCallsCount() < referenceCallsCount);\n+\n+        // perfect guess\n+        f.setCallsCount(0);\n+        result = solver.solve(f, 0.6, 7.0, 1.0);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(0, solver.getIterationCount());\n+        assertEquals(1, f.getCallsCount());\n+ \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.complex.Complex;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Laguerre solver.\n+ * <p>\n+ * Laguerre's method is very efficient in solving polynomials. Test runs\n+ * show that for a default absolute accuracy of 1E-6, it generally takes\n+ * less than 5 iterations to find one root, provided solveAll() is not\n+ * invoked, and 15 to 20 iterations to find all roots for quintic function.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class LaguerreSolverTest extends TestCase {\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = 0.0; max = 2.0; expected = 0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -4.0; max = -1.0; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n+        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = -2.0; max = 2.0; expected = -1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -5.0; max = -2.5; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 3.0; max = 6.0; expected = 4.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solveAll().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        double initial = 0.0, tolerance;\n+        Complex expected, result[];\n+\n+        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n+        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n+        LaguerreSolver solver = new LaguerreSolver();\n+        result = solver.solveAll(coefficients, initial);\n+\n+        expected = new Complex(0.0, -2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(0.0, 2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(-1.0, 0.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+        \n+        expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad function\n+            solver.solve(new SinFunction(), -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad function\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Muller solver.\n+ * <p>\n+ * Muller's method converges almost quadratically near roots, but it can\n+ * be very slow in regions far away from zeros. Test runs show that for\n+ * reasonably good initial values, for a default absolute accuracy of 1E-6,\n+ * it generally takes 5 to 10 iterations for the solver to converge.\n+ * <p>\n+ * Tests for the exponential function illustrate the situations where\n+ * Muller solver performs poorly.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class MullerSolverTest extends TestCase {\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function using solve2().\n+     */\n+    public void testSinFunction2() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        MullerSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solve2().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     * <p>\n+     * It takes 10 to 15 iterations for the last two tests to converge.\n+     * In fact, if not for the bisection alternative, the solver would\n+     * exceed the default maximal iteration of 100.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function using solve2().\n+     * <p>\n+     * It takes 25 to 50 iterations for the last two tests to converge.\n+     */\n+    public void testExpm1Function2() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        MullerSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver();\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public final class NewtonSolverTest extends TestCase {\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new NewtonSolver(f);\n+        result = solver.solve(3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        \n+        assertEquals(result, solver.getResult(), 0);\n+        assertTrue(solver.getIterationCount() > 0);\n+    }\n+\n+    /**\n+    *\n+    */\n+   public void testSinZero() throws MathException {\n+       DifferentiableUnivariateRealFunction f = new SinFunction();\n+       double result;\n+       \n+       UnivariateRealSolver solver = new NewtonSolver();\n+       result = solver.solve(f, 3, 4);\n+       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+       result = solver.solve(f, 1, 4);\n+       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+       \n+       assertEquals(result, solver.getResult(), 0);\n+       assertTrue(solver.getIterationCount() > 0);\n+   }\n+\n+   /**\n+     *\n+     */\n+    public void testQuinticZero() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+\n+        UnivariateRealSolver solver = new NewtonSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Ridders solver.\n+ * <p>\n+ * Ridders' method converges superlinearly, more specific, its rate of\n+ * convergence is sqrt(2). Test runs show that for a default absolute\n+ * accuracy of 1E-6, it generally takes less than 5 iterations for close\n+ * initial bracket and 5 to 10 iterations for distant initial bracket\n+ * to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RiddersSolverTest extends TestCase {\n+\n+    /**\n+     * Test the deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImplTest.java\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class UnivariateRealSolverFactoryImplTest extends TestCase {\n+    \n+    /** solver factory */\n+    private UnivariateRealSolverFactory factory;\n+    \n+    /**\n+     * @throws java.lang.Exception\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        factory = new UnivariateRealSolverFactoryImpl();\n+    }\n+    \n+    /**\n+     * @throws java.lang.Exception\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    @Override\n+    protected void tearDown() throws Exception {\n+        factory = null;\n+        super.tearDown();\n+    }\n+\n+    public void testNewBisectionSolverValid() {\n+        UnivariateRealSolver solver = factory.newBisectionSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof BisectionSolver);\n+    }\n+\n+    public void testNewNewtonSolverValid() {\n+        UnivariateRealSolver solver = factory.newNewtonSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof NewtonSolver);\n+    }\n+\n+    public void testNewBrentSolverValid() {\n+        UnivariateRealSolver solver = factory.newBrentSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof BrentSolver);\n+    }\n+\n+    public void testNewSecantSolverValid() {\n+        UnivariateRealSolver solver = factory.newSecantSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof SecantSolver);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class UnivariateRealSolverUtilsTest extends TestCase {\n+    \n+    protected UnivariateRealFunction sin = new SinFunction();\n+    \n+    public void testSolveNull() throws MathException {\n+        try {\n+            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n+            fail();\n+        } catch(IllegalArgumentException ex){\n+            // success\n+        }\n+    }\n+    \n+    public void testSolveBadParameters() throws MathException {\n+        try { // bad endpoints\n+            UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }    \n+        try { // bad accuracy\n+            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+    public void testSolveSin() throws MathException {     \n+        double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);\n+        assertEquals(Math.PI, x, 1.0e-4);\n+    }\n+    \n+    public void testSolveAccuracyNull()  throws MathException {\n+        try {\n+            double accuracy = 1.0e-6;\n+            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n+            fail();\n+        } catch(IllegalArgumentException ex){\n+            // success\n+        }\n+    }\n+    \n+    public void testSolveAccuracySin() throws MathException {\n+        double accuracy = 1.0e-6;\n+        double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n+                4.0, accuracy);\n+        assertEquals(Math.PI, x, accuracy);\n+    }\n+    \n+    public void testSolveNoRoot() throws MathException {\n+        try {\n+            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);  \n+            fail(\"Expecting IllegalArgumentException \");  \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testBracketSin() throws MathException {\n+        double[] result = UnivariateRealSolverUtils.bracket(sin, \n+                0.0, -2.0, 2.0);\n+        assertTrue(sin.value(result[0]) < 0);\n+        assertTrue(sin.value(result[1]) > 0);\n+    }\n+    \n+    public void testBracketEndpointRoot() throws MathException {\n+        double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0);\n+        assertEquals(0.0, sin.value(result[0]), 1.0e-15);\n+        assertTrue(sin.value(result[1]) > 0);\n+    }\n+    \n+    public void testBadParameters() throws MathException {\n+        try { // null function\n+            UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // initial not between endpoints\n+            UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // endpoints not valid\n+            UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // bad maximum iterations\n+            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.complex;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Test;\n+\n+public class ComplexFieldTest {\n+\n+    @Test\n+    public void testZero() {\n+        assertEquals(Complex.ZERO, ComplexField.getInstance().getZero());\n+    }\n+\n+    @Test\n+    public void testOne() {\n+        assertEquals(Complex.ONE, ComplexField.getInstance().getOne());\n+    }\n+\n+    @Test\n+    public void testSerial() {\n+        // deserializing the singleton should give the singleton itself back\n+        ComplexField field = ComplexField.getInstance();\n+        assertTrue(field == TestUtils.serializeAndRecover(field));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+import junit.framework.TestCase;\n+\n+public abstract class ComplexFormatAbstractTest extends TestCase {\n+ \n+    CompositeFormat complexFormat = null;\n+    ComplexFormat complexFormatJ = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        complexFormat = ComplexFormat.getInstance(getLocale());\n+        complexFormatJ = ComplexFormat.getInstance(getLocale());\n+        complexFormatJ.setImaginaryCharacter(\"j\");\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        Complex c = new Complex(1, 1);\n+        String expected = \"1 + 1i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        Complex c = new Complex(1.23, 1.43);\n+        String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        Complex c = new Complex(1.2323, 1.4343);\n+        String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeReal() {\n+        Complex c = new Complex(-1.2323, 1.4343);\n+        String expected = \"-1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeImaginary() {\n+        Complex c = new Complex(1.2323, -1.4343);\n+        String expected = \"1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeBoth() {\n+        Complex c = new Complex(-1.2323, -1.4343);\n+        String expected = \"-1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testZeroReal() {\n+        Complex c = new Complex(0.0, -1.4343);\n+        String expected = \"0 - 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testZeroImaginary() {\n+        Complex c = new Complex(30.233, 0);\n+        String expected = \"30\" + getDecimalCharacter() + \"23\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testDifferentImaginaryChar() {\n+        Complex c = new Complex(1, 1);\n+        String expected = \"1 + 1j\";\n+        String actual = complexFormatJ.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatComplex() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        Complex c = new Complex(232.222, -342.33);\n+        String expected = \"232\" + getDecimalCharacter() + \"22 - 342\" + getDecimalCharacter() + \"33i\";\n+        String actual = ComplexFormat.formatComplex(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        Complex c = new Complex(Double.NaN, Double.NaN);\n+        String expected = \"(NaN) + (NaN)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        String expected = \"(Infinity) + (Infinity)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeInfinity() {\n+        Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        String expected = \"(-Infinity) - (Infinity)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testParseSimpleNoDecimals() {\n+        String source = \"1 + 1i\";\n+        Complex expected = new Complex(1, 1);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        Complex expected = new Complex(1.23, 1.43);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source = \"1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(1.2323, 1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeReal() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(-1.2323, 1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeImaginary() {\n+        String source = \"1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeBoth() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(-1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroReal() {\n+        String source = \"0\" + getDecimalCharacter() + \"0 - 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(0.0, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroImaginary() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323\";\n+        Complex expected = new Complex(-1.2323, 0);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseDifferentImaginaryChar() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343j\";\n+        Complex expected = new Complex(-1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormatJ.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"(NaN) + (NaN)i\";\n+        Complex expected = new Complex(Double.NaN, Double.NaN);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"(Infinity) + (Infinity)i\";\n+        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testPaseNegativeInfinity() {\n+        String source = \"(-Infinity) - (Infinity)i\";\n+        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getRealFormat());\n+    }\n+    \n+    public void testGetImaginaryFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat();\n+        \n+        assertNotSame(nf, cf.getImaginaryFormat());\n+        cf.setImaginaryFormat(nf);\n+        assertSame(nf, cf.getImaginaryFormat());\n+    }\n+    \n+    public void testSetImaginaryFormatNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryFormat(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetRealFormatNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setRealFormat(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testGetRealFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat();\n+        \n+        assertNotSame(nf, cf.getRealFormat());\n+        cf.setRealFormat(nf);\n+        assertSame(nf, cf.getRealFormat());\n+    }\n+    \n+    public void testSetImaginaryCharacterNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryCharacter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetImaginaryCharacterEmpty() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryCharacter(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testFormatNumber() {\n+        CompositeFormat cf = ComplexFormat.getInstance(getLocale());\n+        Double pi = Double.valueOf(Math.PI);\n+        String text = cf.format(pi);\n+        assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new ComplexFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenImaginaryCharacter() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n+        assertEquals(5, pos.getErrorIndex());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.util.Locale;\n+\n+\n+public class ComplexFormatTest extends ComplexFormatAbstractTest {\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+    \n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ComplexTest extends TestCase {\n+    \n+\n+    private double inf = Double.POSITIVE_INFINITY;\n+    private double neginf = Double.NEGATIVE_INFINITY;\n+    private double nan = Double.NaN;\n+    private double pi = Math.PI;\n+    private Complex oneInf = new Complex(1, inf);\n+    private Complex oneNegInf = new Complex(1, neginf);\n+    private Complex infOne = new Complex(inf, 1);\n+    private Complex infZero = new Complex(inf, 0);\n+    private Complex infNaN = new Complex(inf, nan);\n+    private Complex infNegInf = new Complex(inf, neginf);\n+    private Complex infInf = new Complex(inf, inf);\n+    private Complex negInfInf = new Complex(neginf, inf);\n+    private Complex negInfZero = new Complex(neginf, 0);\n+    private Complex negInfOne = new Complex(neginf, 1);\n+    private Complex negInfNaN = new Complex(neginf, nan);\n+    private Complex negInfNegInf = new Complex(neginf, neginf);\n+    private Complex oneNaN = new Complex(1, nan);\n+    private Complex zeroInf = new Complex(0, inf);\n+    private Complex zeroNaN = new Complex(0, nan);\n+    private Complex nanInf = new Complex(nan, inf);\n+    private Complex nanNegInf = new Complex(nan, neginf);\n+    private Complex nanZero = new Complex(nan, 0);\n+    \n+    public void testConstructor() {\n+        Complex z = new Complex(3.0, 4.0);\n+        assertEquals(3.0, z.getReal(), 1.0e-5);\n+        assertEquals(4.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testConstructorNaN() {\n+        Complex z = new Complex(3.0, Double.NaN);\n+        assertTrue(z.isNaN());\n+\n+        z = new Complex(nan, 4.0);\n+        assertTrue(z.isNaN());\n+\n+        z = new Complex(3.0, 4.0);\n+        assertFalse(z.isNaN());\n+    }\n+    \n+    public void testAbs() {\n+        Complex z = new Complex(3.0, 4.0);\n+        assertEquals(5.0, z.abs(), 1.0e-5);\n+    }\n+    \n+    public void testAbsNaN() {\n+        assertTrue(Double.isNaN(Complex.NaN.abs()));\n+        Complex z = new Complex(inf, nan);\n+        assertTrue(Double.isNaN(z.abs()));\n+    }\n+    \n+    public void testAbsInfinite() {\n+        Complex z = new Complex(inf, 0);\n+        assertEquals(inf, z.abs(), 0);\n+        z = new Complex(0, neginf);\n+        assertEquals(inf, z.abs(), 0);\n+        z = new Complex(inf, neginf);\n+        assertEquals(inf, z.abs(), 0);     \n+    }\n+    \n+    public void testAdd() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.add(y);\n+        assertEquals(8.0, z.getReal(), 1.0e-5);\n+        assertEquals(10.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testAddNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.add(Complex.NaN);\n+        assertTrue(z.isNaN());\n+        z = new Complex(1, nan);\n+        Complex w = x.add(z);\n+        assertEquals(w.getReal(), 4.0, 0);\n+        assertTrue(Double.isNaN(w.getImaginary()));\n+    }\n+    \n+    public void testAddInfinite() {\n+        Complex x = new Complex(1, 1);\n+        Complex z = new Complex(inf, 0);\n+        Complex w = x.add(z);\n+        assertEquals(w.getImaginary(), 1, 0);\n+        assertEquals(inf, w.getReal(), 0);\n+        \n+        x = new Complex(neginf, 0);\n+        assertTrue(Double.isNaN(x.add(z).getReal()));\n+    }\n+    \n+    public void testConjugate() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.conjugate();\n+        assertEquals(3.0, z.getReal(), 1.0e-5);\n+        assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testConjugateNaN() {\n+        Complex z = Complex.NaN.conjugate();\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testConjugateInfiinite() {\n+        Complex z = new Complex(0, inf);\n+        assertEquals(neginf, z.conjugate().getImaginary(), 0);\n+        z = new Complex(0, neginf);\n+        assertEquals(inf, z.conjugate().getImaginary(), 0);\n+    }\n+    \n+    public void testDivide() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.divide(y);\n+        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);\n+        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testDivideInfinite() {\n+        Complex x = new Complex(3, 4);\n+        Complex w = new Complex(neginf, inf);\n+        assertTrue(x.divide(w).equals(Complex.ZERO));\n+        \n+        Complex z = w.divide(x);\n+        assertTrue(Double.isNaN(z.getReal()));\n+        assertEquals(inf, z.getImaginary(), 0);\n+        \n+        w = new Complex(inf, inf);\n+        z = w.divide(x);\n+        assertTrue(Double.isNaN(z.getImaginary()));\n+        assertEquals(inf, z.getReal(), 0);\n+        \n+        w = new Complex(1, inf);\n+        z = w.divide(w);\n+        assertTrue(Double.isNaN(z.getReal()));\n+        assertTrue(Double.isNaN(z.getImaginary()));\n+    }\n+    \n+    public void testDivideNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.divide(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testDivideNaNInf() {  \n+       Complex z = oneInf.divide(Complex.ONE);\n+       assertTrue(Double.isNaN(z.getReal()));\n+       assertEquals(inf, z.getImaginary(), 0);\n+       \n+       z = negInfNegInf.divide(oneNaN);\n+       assertTrue(Double.isNaN(z.getReal()));\n+       assertTrue(Double.isNaN(z.getImaginary()));\n+       \n+       z = negInfInf.divide(Complex.ONE);\n+       assertTrue(Double.isNaN(z.getReal()));\n+       assertTrue(Double.isNaN(z.getImaginary()));\n+    }\n+    \n+    public void testMultiply() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.multiply(y);\n+        assertEquals(-9.0, z.getReal(), 1.0e-5);\n+        assertEquals(38.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testMultiplyNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.multiply(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testMultiplyNaNInf() {\n+        Complex z = new Complex(1,1);\n+        Complex w = z.multiply(infOne);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n+\n+        // [MATH-164]\n+        assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));\n+        assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));\n+        assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));\n+        \n+        w = oneInf.multiply(oneNegInf);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n+        \n+        w = negInfNegInf.multiply(oneNaN);\n+        assertTrue(Double.isNaN(w.getReal()));\n+        assertTrue(Double.isNaN(w.getImaginary()));  \n+    }\n+    \n+    public void testScalarMultiply() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double y = 2.0;\n+        Complex z = x.multiply(y);\n+        assertEquals(6.0, z.getReal(), 1.0e-5);\n+        assertEquals(8.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testScalarMultiplyNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.multiply(Double.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testScalarMultiplyInf() {\n+        Complex z = new Complex(1,1);\n+        Complex w = z.multiply(Double.POSITIVE_INFINITY);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n+\n+        w = z.multiply(Double.NEGATIVE_INFINITY);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n+    }\n+    \n+    public void testNegate() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.negate();\n+        assertEquals(-3.0, z.getReal(), 1.0e-5);\n+        assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testNegateNaN() {\n+        Complex z = Complex.NaN.negate();\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testSubtract() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.subtract(y);\n+        assertEquals(-2.0, z.getReal(), 1.0e-5);\n+        assertEquals(-2.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testSubtractNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.subtract(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testEqualsNull() {\n+        Complex x = new Complex(3.0, 4.0);\n+        assertFalse(x.equals(null));\n+    }\n+    \n+    public void testEqualsClass() {\n+        Complex x = new Complex(3.0, 4.0);\n+        assertFalse(x.equals(this));\n+    }\n+    \n+    public void testEqualsSame() {\n+        Complex x = new Complex(3.0, 4.0);\n+        assertTrue(x.equals(x));\n+    }\n+    \n+    public void testEqualsTrue() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(3.0, 4.0);\n+        assertTrue(x.equals(y));\n+    }\n+    \n+    public void testEqualsRealDifference() {\n+        Complex x = new Complex(0.0, 0.0);\n+        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n+        assertFalse(x.equals(y));\n+    }\n+    \n+    public void testEqualsImaginaryDifference() {\n+        Complex x = new Complex(0.0, 0.0);\n+        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n+        assertFalse(x.equals(y));\n+    }\n+    \n+    public void testEqualsNaN() {\n+        Complex realNaN = new Complex(Double.NaN, 0.0);\n+        Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n+        Complex complexNaN = Complex.NaN;\n+        assertTrue(realNaN.equals(imaginaryNaN));\n+        assertTrue(imaginaryNaN.equals(complexNaN));\n+        assertTrue(realNaN.equals(complexNaN));\n+    }\n+    \n+    public void testHashCode() {\n+        Complex x = new Complex(0.0, 0.0);\n+        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n+        assertFalse(x.hashCode()==y.hashCode());\n+        y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n+        assertFalse(x.hashCode()==y.hashCode());\n+        Complex realNaN = new Complex(Double.NaN, 0.0);\n+        Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n+        assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n+        assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n+    }\n+    \n+    public void testAcos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.936812, -2.30551);\n+        TestUtils.assertEquals(expected, z.acos(), 1.0e-5);\n+        TestUtils.assertEquals(new Complex(Math.acos(0), 0), \n+                Complex.ZERO.acos(), 1.0e-12);\n+    }\n+    \n+    public void testAcosInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.acos());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.acos());\n+        TestUtils.assertSame(Complex.NaN, infOne.acos());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.acos());\n+        TestUtils.assertSame(Complex.NaN, infInf.acos());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.acos());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.acos());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());\n+    }\n+    \n+    public void testAcosNaN() {\n+        assertTrue(Complex.NaN.acos().isNaN());\n+    }\n+    \n+    public void testAsin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.633984, 2.30551);\n+        TestUtils.assertEquals(expected, z.asin(), 1.0e-5);\n+    }\n+    \n+    public void testAsinNaN() {\n+        assertTrue(Complex.NaN.asin().isNaN());\n+    }\n+    \n+    public void testAsinInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.asin());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.asin());\n+        TestUtils.assertSame(Complex.NaN, infOne.asin());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.asin());\n+        TestUtils.assertSame(Complex.NaN, infInf.asin());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.asin());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.asin());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.asin());\n+    }\n+    \n+   \n+    public void testAtan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.44831, 0.158997);\n+        TestUtils.assertEquals(expected, z.atan(), 1.0e-5);\n+    }\n+    \n+    public void testAtanInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.atan());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());\n+        TestUtils.assertSame(Complex.NaN, infOne.atan());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.atan());\n+        TestUtils.assertSame(Complex.NaN, infInf.atan());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.atan());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.atan());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());\n+    } \n+    \n+    public void testAtanNaN() {\n+        assertTrue(Complex.NaN.atan().isNaN());\n+        assertTrue(Complex.I.atan().isNaN());\n+    }\n+    \n+    public void testCos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-27.03495, -3.851153);\n+        TestUtils.assertEquals(expected, z.cos(), 1.0e-5);\n+    }\n+    \n+    public void testCosNaN() {\n+        assertTrue(Complex.NaN.cos().isNaN());\n+    }\n+    \n+    public void testCosInf() {\n+        TestUtils.assertSame(infNegInf, oneInf.cos());\n+        TestUtils.assertSame(infInf, oneNegInf.cos());\n+        TestUtils.assertSame(Complex.NaN, infOne.cos());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.cos());\n+        TestUtils.assertSame(Complex.NaN, infInf.cos());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.cos());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.cos());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());\n+    } \n+    \n+    public void testCosh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.58066, -7.58155);\n+        TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);\n+    }\n+    \n+    public void testCoshNaN() {\n+        assertTrue(Complex.NaN.cosh().isNaN());\n+    }\n+    \n+    public void testCoshInf() {  \n+        TestUtils.assertSame(Complex.NaN, oneInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());\n+        TestUtils.assertSame(infInf, infOne.cosh());\n+        TestUtils.assertSame(infNegInf, negInfOne.cosh());\n+        TestUtils.assertSame(Complex.NaN, infInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.cosh());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());\n+    } \n+    \n+    public void testExp() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-13.12878, -15.20078);\n+        TestUtils.assertEquals(expected, z.exp(), 1.0e-5);\n+        TestUtils.assertEquals(Complex.ONE, \n+                Complex.ZERO.exp(), 10e-12);\n+        Complex iPi = Complex.I.multiply(new Complex(pi,0));\n+        TestUtils.assertEquals(Complex.ONE.negate(), \n+                iPi.exp(), 10e-12);\n+    }\n+    \n+    public void testExpNaN() {\n+        assertTrue(Complex.NaN.exp().isNaN());\n+    }\n+    \n+    public void testExpInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.exp());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.exp());\n+        TestUtils.assertSame(infInf, infOne.exp());\n+        TestUtils.assertSame(Complex.ZERO, negInfOne.exp());\n+        TestUtils.assertSame(Complex.NaN, infInf.exp());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.exp());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.exp());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());\n+    }\n+    \n+    public void testLog() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.60944, 0.927295);\n+        TestUtils.assertEquals(expected, z.log(), 1.0e-5);\n+    }\n+    \n+    public void testLogNaN() {\n+        assertTrue(Complex.NaN.log().isNaN());\n+    }\n+    \n+    public void testLogInf() {\n+        TestUtils.assertEquals(new Complex(inf, pi / 2),\n+                oneInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, -pi / 2),\n+                oneNegInf.log(), 10e-12);\n+        TestUtils.assertEquals(infZero, infOne.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, pi),\n+                negInfOne.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, pi / 4),\n+                infInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, -pi / 4),\n+                infNegInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),\n+                negInfInf.log(), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),\n+                negInfNegInf.log(), 10e-12);\n+    }\n+    \n+    public void testLogZero() {\n+        TestUtils.assertSame(negInfZero, Complex.ZERO.log());\n+    }\n+    \n+    public void testPow() {\n+        Complex x = new Complex(3, 4);\n+        Complex y = new Complex(5, 6);\n+        Complex expected = new Complex(-1.860893, 11.83677);\n+        TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);\n+    }\n+    \n+    public void testPowNaNBase() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(Complex.NaN.pow(x).isNaN());\n+    }\n+    \n+    public void testPowNaNExponent() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(x.pow(Complex.NaN).isNaN());\n+    }\n+    \n+   public void testPowInf() {\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));   \n+   }\n+   \n+   public void testPowZero() {\n+       TestUtils.assertSame(Complex.NaN, \n+               Complex.ZERO.pow(Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN, \n+               Complex.ZERO.pow(Complex.ZERO));\n+       TestUtils.assertSame(Complex.NaN, \n+               Complex.ZERO.pow(Complex.I));\n+       TestUtils.assertEquals(Complex.ONE,\n+               Complex.ONE.pow(Complex.ZERO), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE,\n+               Complex.I.pow(Complex.ZERO), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE,\n+               new Complex(-1, 3).pow(Complex.ZERO), 10e-12);\n+   }\n+    \n+    public void testpowNull() {\n+        try {\n+            Complex.ONE.pow(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(3.853738, -27.01681);\n+        TestUtils.assertEquals(expected, z.sin(), 1.0e-5);\n+    }\n+    \n+    public void testSinInf() {\n+        TestUtils.assertSame(infInf, oneInf.sin());\n+        TestUtils.assertSame(infNegInf, oneNegInf.sin());\n+        TestUtils.assertSame(Complex.NaN, infOne.sin());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.sin());\n+        TestUtils.assertSame(Complex.NaN, infInf.sin());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.sin());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.sin());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());\n+    }\n+    \n+    public void testSinNaN() {\n+        assertTrue(Complex.NaN.sin().isNaN());\n+    }\n+    \n+    public void testSinh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.54812, -7.61923);\n+        TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);\n+    }\n+    \n+    public void testSinhNaN() {\n+        assertTrue(Complex.NaN.sinh().isNaN());\n+    }\n+    \n+    public void testSinhInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());\n+        TestUtils.assertSame(infInf, infOne.sinh());\n+        TestUtils.assertSame(negInfInf, negInfOne.sinh());\n+        TestUtils.assertSame(Complex.NaN, infInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.sinh());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());\n+    }\n+    \n+    public void testSqrtRealPositive() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(2, 1);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealZero() {\n+        Complex z = new Complex(0.0, 4);\n+        Complex expected = new Complex(1.41421, 1.41421);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealNegative() {\n+        Complex z = new Complex(-3.0, 4);\n+        Complex expected = new Complex(1, 2);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryZero() {\n+        Complex z = new Complex(-3.0, 0.0);\n+        Complex expected = new Complex(0.0, 1.73205);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryNegative() {\n+        Complex z = new Complex(-3.0, -4.0);\n+        Complex expected = new Complex(1.0, -2.0);\n+        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n+    }\n+    \n+    public void testSqrtPolar() {\n+        double r = 1;\n+        for (int i = 0; i < 5; i++) {\n+            r += i;\n+            double theta = 0;\n+            for (int j =0; j < 11; j++) {\n+                theta += pi /12;\n+                Complex z = ComplexUtils.polar2Complex(r, theta);\n+                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);\n+                TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);\n+            }\n+        }       \n+    }\n+    \n+    public void testSqrtNaN() {\n+        assertTrue(Complex.NaN.sqrt().isNaN());\n+    }\n+      \n+    public void testSqrtInf() {\n+        TestUtils.assertSame(infNaN, oneInf.sqrt());\n+        TestUtils.assertSame(infNaN, oneNegInf.sqrt());\n+        TestUtils.assertSame(infZero, infOne.sqrt());\n+        TestUtils.assertSame(zeroInf, negInfOne.sqrt());\n+        TestUtils.assertSame(infNaN, infInf.sqrt());\n+        TestUtils.assertSame(infNaN, infNegInf.sqrt());\n+        TestUtils.assertSame(nanInf, negInfInf.sqrt());\n+        TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());\n+    }\n+    \n+    public void testSqrt1z() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(4.08033, -2.94094);\n+        TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);\n+    }\n+    \n+    public void testSqrt1zNaN() {\n+        assertTrue(Complex.NaN.sqrt1z().isNaN());\n+    }\n+    \n+    public void testTan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-0.000187346, 0.999356);\n+        TestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n+    }\n+    \n+    public void testTanNaN() {\n+        assertTrue(Complex.NaN.tan().isNaN());\n+    }\n+    \n+    public void testTanInf() {\n+        TestUtils.assertSame(zeroNaN, oneInf.tan());\n+        TestUtils.assertSame(zeroNaN, oneNegInf.tan());\n+        TestUtils.assertSame(Complex.NaN, infOne.tan());\n+        TestUtils.assertSame(Complex.NaN, negInfOne.tan());\n+        TestUtils.assertSame(Complex.NaN, infInf.tan());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.tan());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.tan());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());\n+    }\n+    \n+   public void testTanCritical() {\n+        TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());\n+        TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());\n+    }\n+    \n+    public void testTanh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.00071, 0.00490826);\n+        TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n+    }\n+    \n+    public void testTanhNaN() {\n+        assertTrue(Complex.NaN.tanh().isNaN());\n+    }\n+    \n+    public void testTanhInf() {\n+        TestUtils.assertSame(Complex.NaN, oneInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());\n+        TestUtils.assertSame(nanZero, infOne.tanh());\n+        TestUtils.assertSame(nanZero, negInfOne.tanh());\n+        TestUtils.assertSame(Complex.NaN, infInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, infNegInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, negInfInf.tanh());\n+        TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());\n+    }\n+    \n+    public void testTanhCritical() {\n+        TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());\n+    }\n+\n+    /** test issue MATH-221 */\n+    public void testMath221() {\n+        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n+    }\n+    \n+    /** \n+     * Test: computing <b>third roots</b> of z.\n+     * <pre>\n+     * <code>\n+     * <b>z = -2 + 2 * i</b>\n+     *   => z_0 =  1      +          i\n+     *   => z_1 = -1.3660 + 0.3660 * i\n+     *   => z_2 =  0.3660 - 1.3660 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_normal_thirdRoot() {\n+        // The complex number we want to compute all third-roots for.\n+        Complex z = new Complex(-2,2);\n+        // The List holding all third roots\n+        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(3, thirdRootsOfZ.length);\n+        // test z_0\n+        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+    }\n+\n+\n+    /** \n+     * Test: computing <b>fourth roots</b> of z.\n+     * <pre>\n+     * <code>\n+     * <b>z = 5 - 2 * i</b>\n+     *   => z_0 =  1.5164 - 0.1446 * i\n+     *   => z_1 =  0.1446 + 1.5164 * i\n+     *   => z_2 = -1.5164 + 0.1446 * i\n+     *   => z_3 = -1.5164 - 0.1446 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_normal_fourthRoot() {\n+        // The complex number we want to compute all third-roots for.\n+        Complex z = new Complex(5,-2);\n+        // The List holding all fourth roots\n+        Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(4, fourthRootsOfZ.length);\n+        // test z_0\n+        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);\n+        // test z_3\n+        assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);\n+        assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);\n+    }\n+\n+    /** \n+     * Test: computing <b>third roots</b> of z.\n+     * <pre>\n+     * <code>\n+     * <b>z = 8</b>\n+     *   => z_0 =  2\n+     *   => z_1 = -1 + 1.73205 * i\n+     *   => z_2 = -1 - 1.73205 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() {\n+        // The number 8 has three third roots. One we all already know is the number 2.\n+        // But there are two more complex roots.\n+        Complex z = new Complex(8,0);\n+        // The List holding all third roots\n+        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(3, thirdRootsOfZ.length);\n+        // test z_0\n+        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+    }\n+\n+\n+    /** \n+     * Test: computing <b>third roots</b> of z with real part 0.\n+     * <pre>\n+     * <code>\n+     * <b>z = 2 * i</b>\n+     *   => z_0 =  1.0911 + 0.6299 * i\n+     *   => z_1 = -1.0911 + 0.6299 * i\n+     *   => z_2 = -2.3144 - 1.2599 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_cornercase_thirdRoot_realPartZero() {\n+        // complex number with only imaginary part\n+        Complex z = new Complex(0,2);\n+        // The List holding all third roots\n+        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(3, thirdRootsOfZ.length);\n+        // test z_0\n+        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+    }\n+\n+    /**\n+     * Test cornercases with NaN and Infinity.\n+     */\n+    public void testNthRoot_cornercase_NAN_Inf() {\n+        // NaN + finite -> NaN\n+        List<Complex> roots = oneNaN.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.NaN, roots.get(0));\n+        \n+        roots = nanZero.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.NaN, roots.get(0));\n+        \n+        // NaN + infinite -> NaN\n+        roots = nanInf.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.NaN, roots.get(0));\n+        \n+        // finite + infinite -> Inf\n+        roots = oneInf.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.INF, roots.get(0));\n+        \n+        // infinite + infinite -> Inf\n+        roots = negInfInf.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.INF, roots.get(0));\n+    }\n+    \n+    /**\n+     * Test standard values\n+     */\n+    public void testGetArgument() {\n+        Complex z = new Complex(1, 0);\n+        assertEquals(0.0, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(1, 1);\n+        assertEquals(Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(0, 1);\n+        assertEquals(Math.PI/2, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(-1, 1);\n+        assertEquals(3 * Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(-1, 0);\n+        assertEquals(Math.PI, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(-1, -1);\n+        assertEquals(-3 * Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(0, -1);\n+        assertEquals(-Math.PI/2, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(1, -1);\n+        assertEquals(-Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+    }\n+    \n+    /**\n+     * Verify atan2-style handling of infinite parts\n+     */\n+    public void testGetArgumentInf() {\n+        assertEquals(Math.PI/4, infInf.getArgument(), 1.0e-12);\n+        assertEquals(Math.PI/2, oneInf.getArgument(), 1.0e-12);\n+        assertEquals(0.0, infOne.getArgument(), 1.0e-12);\n+        assertEquals(Math.PI/2, zeroInf.getArgument(), 1.0e-12);\n+        assertEquals(0.0, infZero.getArgument(), 1.0e-12);\n+        assertEquals(Math.PI, negInfOne.getArgument(), 1.0e-12);\n+        assertEquals(-3.0*Math.PI/4, negInfNegInf.getArgument(), 1.0e-12);  \n+        assertEquals(-Math.PI/2, oneNegInf.getArgument(), 1.0e-12);        \n+    }\n+    \n+    /**\n+     * Verify that either part NaN results in NaN\n+     */\n+    public void testGetArgumentNaN() {\n+        assertEquals(nan, nanZero.getArgument());\n+        assertEquals(nan, zeroNaN.getArgument());\n+        assertEquals(nan, Complex.NaN.getArgument());  \n+    }\n+    \n+    public void testSerial() {\n+        Complex z = new Complex(3.0, 4.0);\n+        assertEquals(z, TestUtils.serializeAndRecover(z));\n+        Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN);\n+        assertEquals(nanZero, ncmplx);\n+        assertTrue(ncmplx.isNaN());\n+        Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf);\n+        assertEquals(infInf, infcmplx);\n+        assertTrue(infcmplx.isInfinite());\n+        TestComplex tz = new TestComplex(3.0, 4.0);\n+        assertEquals(tz, TestUtils.serializeAndRecover(tz));\n+        TestComplex ntcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN));\n+        assertEquals(nanZero, ntcmplx);\n+        assertTrue(ntcmplx.isNaN());\n+        TestComplex inftcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf));\n+        assertEquals(infInf, inftcmplx);\n+        assertTrue(inftcmplx.isInfinite());\n+    }\n+    \n+    /**\n+     * Class to test extending Complex\n+     */\n+    public static class TestComplex extends Complex {\n+\n+        /**\n+         * Serialization identifier.\n+         */\n+        private static final long serialVersionUID = 3268726724160389237L;\n+\n+        public TestComplex(double real, double imaginary) {\n+            super(real, imaginary);\n+        }\n+        \n+        public TestComplex(Complex other){\n+            this(other.getReal(), other.getImaginary());\n+        }\n+\n+        @Override\n+        protected TestComplex createComplex(double real, double imaginary){\n+            return new TestComplex(real, imaginary);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ComplexUtilsTest extends TestCase {\n+    \n+    private double inf = Double.POSITIVE_INFINITY;\n+    private double negInf = Double.NEGATIVE_INFINITY;\n+    private double nan = Double.NaN;\n+    private double pi = Math.PI;\n+    \n+    private Complex negInfInf = new Complex(negInf, inf);\n+    private Complex infNegInf = new Complex(inf, negInf);\n+    private Complex infInf = new Complex(inf, inf);\n+    private Complex negInfNegInf = new Complex(negInf, negInf);\n+    private Complex infNaN = new Complex(inf, nan);\n+\n+    public void testPolar2Complex() {\n+        TestUtils.assertEquals(Complex.ONE, \n+                ComplexUtils.polar2Complex(1, 0), 10e-12);\n+        TestUtils.assertEquals(Complex.ZERO, \n+                ComplexUtils.polar2Complex(0, 1), 10e-12);\n+        TestUtils.assertEquals(Complex.ZERO, \n+                ComplexUtils.polar2Complex(0, -1), 10e-12);\n+        TestUtils.assertEquals(Complex.I, \n+                ComplexUtils.polar2Complex(1, pi/2), 10e-12);\n+        TestUtils.assertEquals(Complex.I.negate(), \n+                ComplexUtils.polar2Complex(1, -pi/2), 10e-12);\n+        double r = 0;\n+        for (int i = 0; i < 5; i++) {\n+          r += i;\n+          double theta = 0;\n+          for (int j =0; j < 20; j++) {\n+              theta += pi / 6;\n+              TestUtils.assertEquals(altPolar(r, theta), \n+                      ComplexUtils.polar2Complex(r, theta), 10e-12);\n+          }\n+          theta = -2 * pi;\n+          for (int j =0; j < 20; j++) {\n+              theta -= pi / 6;\n+              TestUtils.assertEquals(altPolar(r, theta), \n+                      ComplexUtils.polar2Complex(r, theta), 10e-12);\n+          }\n+        }   \n+    }\n+\n+    protected Complex altPolar(double r, double theta) {\n+        return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));\n+    }\n+    \n+    public void testPolar2ComplexIllegalModulus() {\n+        try {\n+            ComplexUtils.polar2Complex(-1, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }       \n+    }\n+    \n+    public void testPolar2ComplexNaN() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));\n+        TestUtils.assertSame(Complex.NaN, \n+                ComplexUtils.polar2Complex(nan, nan));     \n+    }\n+    \n+    public void testPolar2ComplexInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));\n+        TestUtils.assertSame(Complex.NaN,\n+                ComplexUtils.polar2Complex(1, negInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));\n+        TestUtils.assertSame(Complex.NaN,\n+                ComplexUtils.polar2Complex(inf, negInf));\n+        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));\n+        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));\n+        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));\n+        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));\n+        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/FrenchComplexFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.math.MathException;\n+\n+public class BetaDistributionTest extends TestCase {\n+    public void testCumulative() throws MathException {\n+        double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};\n+        // all test data computed using R 2.5\n+        checkCumulative(0.1, 0.1,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,\n+                0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,\n+                0.5936149061, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 0.5,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,\n+                0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,\n+                0.9423662883, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 1.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,\n+                0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,\n+                0.9895192582, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 2.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,\n+                0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,\n+                0.9994144508, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 4.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,\n+                0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,\n+                0.9999967829, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 0.1,\n+                x, new double[]{\n+                0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,\n+                0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,\n+                0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});\n+\n+        checkCumulative(0.5, 0.5,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,\n+                0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,\n+                0.7951672353, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 1.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,\n+                0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,\n+                0.9486832981, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 2.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,\n+                0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,\n+                0.9961174630, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 4.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,\n+                0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,\n+                0.9999714889, 1.0000000000, 1.0000000000});\n+        checkCumulative(1.0, 0.1,\n+                x, new double[]{\n+                0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,\n+                0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,\n+                0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});\n+        checkCumulative(1.0, 0.5,\n+                x, new double[]{\n+                0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,\n+                0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,\n+                0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});\n+        checkCumulative(1, 1,\n+                x, new double[]{\n+                0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});\n+        checkCumulative(1, 2,\n+                x, new double[]{\n+                0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});\n+        checkCumulative(1, 4,\n+                x, new double[]{\n+                0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,\n+                0.9984, 0.9999, 1.0000, 1.0000});\n+        checkCumulative(2.0, 0.1,\n+                x, new double[]{\n+                0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,\n+                0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,\n+                0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});\n+        checkCumulative(2, 1,\n+                x, new double[]{\n+                0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});\n+        checkCumulative(2.0, 0.5,\n+                x, new double[]{\n+                0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,\n+                0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,\n+                0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});\n+        checkCumulative(2, 2,\n+                x, new double[]{\n+                0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});\n+        checkCumulative(2, 4,\n+                x, new double[]{\n+                0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,\n+                0.96922, 0.99328, 0.99954, 1.00000, 1.00000});\n+        checkCumulative(4.0, 0.1,\n+                x, new double[]{\n+                0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,\n+                3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,\n+                1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});\n+        checkCumulative(4.0, 0.5,\n+                x, new double[]{\n+                0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,\n+                2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,\n+                1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});\n+        checkCumulative(4, 1,\n+                x, new double[]{\n+                0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,\n+                0.4096, 0.6561, 1.0000, 1.0000});\n+        checkCumulative(4, 2,\n+                x, new double[]{\n+                0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,\n+                0.52822, 0.73728, 0.91854, 1.00000, 1.00000});\n+        checkCumulative(4, 4,\n+                x, new double[]{\n+                0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,\n+                0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});\n+\n+    }\n+\n+    private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {\n+        BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);\n+        }\n+\n+        for (int i = 1; i < x.length - 1; i++) {\n+            assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);\n+        }\n+    }\n+\n+    public void testDensity() throws MathException {\n+        double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};\n+        checkDensity(0.1, 0.1,\n+                x, new double[]{\n+                12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,\n+                1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,\n+                2.639396531e-01, 4.429925026e-01});\n+        checkDensity(0.1, 0.5,\n+                x, new double[]{\n+                2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,\n+                2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,\n+                2.414013907e-01, 3.070567405e-01});\n+        checkDensity(0.1, 1.0,\n+                x, new double[]{\n+                2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,\n+                2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,\n+                1.222414585e-01, 1.099464743e-01});\n+        checkDensity(0.1, 2.0,\n+                x, new double[]{\n+                2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,\n+                1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,\n+                2.689298641e-02, 1.209399123e-02});\n+        checkDensity(0.1, 4.0,\n+                x, new double[]{\n+                2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,\n+                5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,\n+                1.167143939e-03, 1.312171805e-04});\n+        checkDensity(0.5, 0.1,\n+                x, new double[]{\n+                88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,\n+                0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,\n+                0.4203052841, 0.7394649088});\n+        checkDensity(0.5, 0.5,\n+                x, new double[]{\n+                318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,\n+                0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,\n+                0.7957762075, 1.0610376697});\n+        checkDensity(0.5, 1.0,\n+                x, new double[]{\n+                500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,\n+                0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,\n+                0.5590166450, 0.5270459839});\n+        checkDensity(0.5, 2.0,\n+                x, new double[]{\n+                749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,\n+                0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,\n+                0.16770415497, 0.07905610701});\n+        checkDensity(0.5, 4.0,\n+                x, new double[]{\n+                1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,\n+                3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,\n+                9.782644546e-03, 1.152878503e-03});\n+        checkDensity(1.0, 0.1,\n+                x, new double[]{\n+                0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,\n+                0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,\n+                0.7943353837});\n+        checkDensity(1.0, 0.5,\n+                x, new double[]{\n+                0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,\n+                0.7071074883, 0.7905704033, 0.9128724506,\n+                1.1180367838, 1.5811467358});\n+        checkDensity(1, 1,\n+                x, new double[]{\n+                1, 1, 1,\n+                1, 1, 1, 1,\n+                1, 1, 1});\n+        checkDensity(1, 2,\n+                x, new double[]{\n+                1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,\n+                0.599998, 0.399998,\n+                0.199998});\n+        checkDensity(1, 4,\n+                x, new double[]{\n+                3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,\n+                0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,\n+                0.031999520002, 0.003999880001});\n+        checkDensity(2.0, 0.1,\n+                x, new double[]{\n+                1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,\n+                6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,\n+                3.745917198e-01, 7.863929037e-01});\n+        checkDensity(2.0, 0.5,\n+                x, new double[]{\n+                7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,\n+                3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,\n+                1.341645818e+00, 2.134537420613655});\n+        checkDensity(2, 1,\n+                x, new double[]{\n+                0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,\n+                1.400002, 1.600002,\n+                1.800002});\n+        checkDensity(2, 2,\n+                x, new double[]{\n+                5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,\n+                1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,\n+                9.5999640e-01, 5.3999520e-01});\n+        checkDensity(2, 4,\n+                x, new double[]{\n+                0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,\n+                1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,\n+                0.12799824001, 0.01799948000});\n+        checkDensity(4.0, 0.1,\n+                x, new double[]{\n+                1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,\n+                1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,\n+                2.601171405e-01, 6.911229392e-01});\n+        checkDensity(4.0, 0.5,\n+                x, new double[]{\n+                1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,\n+                9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,\n+                1.252205894e+00, 2.52142232809988});\n+        checkDensity(4, 1,\n+                x, new double[]{\n+                4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,\n+                2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,\n+                2.048007680e+00, 2.916009720e+00});\n+        checkDensity(4, 2,\n+                x, new double[]{\n+                1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,\n+                7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,\n+                2.047997440e+00, 1.457990280e+00});\n+        checkDensity(4, 4,\n+                x, new double[]{\n+                1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,\n+                1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,\n+                5.734335488e-01, 1.020572784e-01});\n+\n+    }\n+\n+    private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException {\n+        BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for BinomialDistribution.\n+ * Extends IntegerDistributionAbstractTest.  See class javadoc for\n+ * IntegerDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class BinomialDistributionTest extends IntegerDistributionAbstractTest {\n+    \n+    /**\n+     * Constructor for BinomialDistributionTest.\n+     * @param name\n+     */\n+    public BinomialDistributionTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n+    public IntegerDistribution makeDistribution() {\n+        return new BinomialDistributionImpl(10,0.70);\n+    }\n+    \n+    /** Creates the default probability density test input values */\n+    @Override\n+    public int[] makeDensityTestPoints() {\n+        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n+    }\n+    \n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d, \n+                0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    @Override\n+    public int[] makeCumulativeTestPoints() {\n+        return makeDensityTestPoints();\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,\n+                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};\n+        }\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d,1}; \n+        }\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n+    public int[] makeInverseCumulativeTestValues() {\n+        return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};\n+    }\n+\n+    //----------------- Additional test cases ---------------------------------\n+   \n+    /** Test degenerate case p = 0   */\n+    public void testDegenerate0() throws Exception {\n+        setDistribution(new BinomialDistributionImpl(5,0.0d));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });\n+        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});\n+        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {-1, -1});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+    \n+    /** Test degenerate case p = 1   */\n+    public void testDegenerate1() throws Exception {\n+        setDistribution(new BinomialDistributionImpl(5,1.0d));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n+        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});\n+        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {4, 4});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for CauchyDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n+    \n+    /**\n+     * Constructor for CauchyDistributionTest.\n+     * @param arg0\n+     */\n+    public CauchyDistributionTest(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new CauchyDistributionImpl(1.2, 2.1);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using Mathematica \n+        return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,\n+                -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,\n+                27.88302995d, 68.0230835d, 669.6485619d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n+                0.975d, 0.990d, 0.999d};\n+    }\n+    \n+    //---------------------------- Additional test cases -------------------------\n+    \n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n+        setInverseCumulativeTestValues(\n+                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testMedian() {\n+        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setMedian(expected);\n+        assertEquals(expected, distribution.getMedian(), 0.0);\n+    }\n+    \n+    public void testScale() {\n+        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setScale(expected);\n+        assertEquals(expected, distribution.getScale(), 0.0);\n+    }\n+    \n+    public void testSetScale() {\n+        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+        try {\n+            distribution.setScale(0.0);\n+            fail(\"Can not have 0.0 scale.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setScale(-1.0);\n+            fail(\"Can not have negative scale.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for ChiSquareDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {\n+    \n+    /**\n+     * Constructor for ChiSquareDistributionTest.\n+     * @param name\n+     */\n+    public ChiSquareDistributionTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new ChiSquaredDistributionImpl(5.0);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, \n+                20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d}; \n+    }\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d, 1};     \n+    }\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n+    public double[] makeInverseCumulativeTestValues() {\n+        return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, \n+                20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d, \n+                Double.POSITIVE_INFINITY};\n+    }\n+    \n+ // --------------------- Override tolerance  --------------\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(5e-6);\n+    }\n+\n+ //---------------------------- Additional test cases -------------------------\n+    \n+    public void testSmallDf() throws Exception {\n+        setDistribution(new ChiSquaredDistributionImpl(0.1d));\n+        setTolerance(1E-4);\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32, \n+                1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438, \n+                0.5318646, 0.1526342});\n+        setInverseCumulativeTestValues(getCumulativeTestPoints());\n+        setInverseCumulativeTestPoints(getCumulativeTestValues());\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testDfAccessors() {\n+        ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();\n+        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        distribution.setDegreesOfFreedom(4d);\n+        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        try {\n+            distribution.setDegreesOfFreedom(0d);\n+            fail(\"Expecting IllegalArgumentException for df = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDensity() {\n+        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n+        //R 2.5: print(dchisq(x, df=1), digits=10)\n+        checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});\n+        //R 2.5: print(dchisq(x, df=0.1), digits=10)\n+        checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});\n+        //R 2.5: print(dchisq(x, df=2), digits=10)\n+        checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});\n+        //R 2.5: print(dchisq(x, df=10), digits=10)\n+        checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});\n+    }\n+\n+    private void checkDensity(double df, double[] x, double[] expected) {\n+        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Abstract base class for {@link ContinuousDistribution} tests.\n+ * <p>\n+ * To create a concrete test class for a continuous distribution\n+ * implementation, first implement makeDistribution() to return a distribution\n+ * instance to use in tests. Then implement each of the test data generation\n+ * methods below.  In each case, the test points and test values arrays\n+ * returned represent parallel arrays of inputs and expected values for the\n+ * distribution returned by makeDistribution().  Default implementations\n+ * are provided for the makeInverseXxx methods that just invert the mapping\n+ * defined by the arrays returned by the makeCumulativeXxx methods.\n+ * <p>\n+ * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities\n+ * makeCumulativeTestValues() -- expected cumulative probabilites\n+ * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf\n+ * makeInverseCumulativeTestValues() -- expected inverse cdf values\n+ * <p>\n+ * To implement additional test cases with different distribution instances and\n+ * test data, use the setXxx methods for the instance data in test cases and\n+ * call the verifyXxx methods to verify results. \n+ * <p>\n+ * Error tolerance can be overriden by implementing getTolerance().\n+ * <p>\n+ * Test data should be validated against reference tables or other packages\n+ * where possible, and the source of the reference data and/or validation\n+ * should be documented in the test cases.  A framework for validating\n+ * distribution data against R is included in the /src/test/R source tree.\n+ * <p>\n+ * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest}\n+ * for examples.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class ContinuousDistributionAbstractTest extends TestCase {\n+    \n+//-------------------- Private test instance data -------------------------\n+    /**  Distribution instance used to perform tests */\n+    private ContinuousDistribution distribution;\n+    \n+    /** Tolerance used in comparing expected and returned values */\n+    private double tolerance = 1E-4;\n+    \n+    /** Arguments used to test cumulative probability density calculations */\n+    private double[] cumulativeTestPoints;\n+    \n+    /** Values used to test cumulative probability density calculations */\n+    private double[] cumulativeTestValues;\n+    \n+    /** Arguments used to test inverse cumulative probability density calculations */\n+    private double[] inverseCumulativeTestPoints;\n+    \n+    /** Values used to test inverse cumulative probability density calculations */\n+    private double[] inverseCumulativeTestValues;\n+    \n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * Constructor for ContinuousDistributionAbstractTest.\n+     * @param name\n+     */\n+    public ContinuousDistributionAbstractTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------------- Abstract methods -----------------------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    public abstract ContinuousDistribution makeDistribution();\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    public abstract double[] makeCumulativeTestPoints();\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    public abstract double[] makeCumulativeTestValues();\n+    \n+    //---- Default implementations of inverse test data generation methods ----\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return makeCumulativeTestValues();\n+    }\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    public double[] makeInverseCumulativeTestValues() {\n+        return makeCumulativeTestPoints();\n+    }\n+    \n+    //-------------------- Setup / tear down ----------------------------------\n+     \n+    /**\n+     * Setup sets all test instance data to default values \n+     */\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        distribution = makeDistribution();\n+        cumulativeTestPoints = makeCumulativeTestPoints();\n+        cumulativeTestValues = makeCumulativeTestValues();\n+        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n+        inverseCumulativeTestValues = makeInverseCumulativeTestValues();   \n+    }\n+    \n+    /**\n+     * Cleans up test instance data\n+     */\n+    @Override\n+    protected void tearDown() throws Exception {      \n+        super.tearDown();\n+        distribution = null;\n+        cumulativeTestPoints = null;\n+        cumulativeTestValues = null;\n+        inverseCumulativeTestPoints = null;\n+        inverseCumulativeTestValues = null;   \n+    }\n+    \n+    //-------------------- Verification methods -------------------------------\n+    \n+    /**\n+     * Verifies that cumulative probability density calculations match expected values\n+     * using current test instance data\n+     */   \n+    protected void verifyCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            TestUtils.assertEquals(\"Incorrect cumulative probability value returned for \" \n+                + cumulativeTestPoints[i], cumulativeTestValues[i], \n+                distribution.cumulativeProbability(cumulativeTestPoints[i]), \n+                getTolerance());\n+        }           \n+    }\n+    \n+    /**\n+     * Verifies that inverse cumulative probability density calculations match expected values\n+     * using current test instance data\n+     */\n+    protected void verifyInverseCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n+            TestUtils.assertEquals(\"Incorrect inverse cumulative probability value returned for \" \n+                + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], \n+                 distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]), \n+                 getTolerance());\n+        }           \n+    }\n+    \n+    //------------------------ Default test cases -----------------------------\n+    \n+    /**\n+     * Verifies that cumulative probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    public void testCumulativeProbabilities() throws Exception {\n+        verifyCumulativeProbabilities();      \n+    }\n+    \n+    /**\n+     * Verifies that inverse cumulative probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    public void testInverseCumulativeProbabilities() throws Exception {\n+        verifyInverseCumulativeProbabilities();       \n+    }\n+    \n+    /**\n+     * Verifies that probability computations are consistent\n+     */\n+    public void testConsistency() throws Exception {\n+        for (int i=1; i < cumulativeTestPoints.length; i++) {\n+            \n+            // check that cdf(x, x) = 0\n+            TestUtils.assertEquals(0d, \n+               distribution.cumulativeProbability\n+                 (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);\n+            \n+            // check that P(a < X < b) = P(X < b) - P(X < a)\n+            double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n+            double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n+            double diff = distribution.cumulativeProbability(upper) - \n+                distribution.cumulativeProbability(lower);\n+            double direct = distribution.cumulativeProbability(lower, upper);\n+            TestUtils.assertEquals(\"Inconsistent cumulative probabilities for (\" \n+                    + lower + \",\" + upper + \")\", diff, direct, tolerance);\n+        }\n+    }\n+    \n+    /**\n+     * Verifies that illegal arguments are correctly handled\n+     */\n+    public void testIllegalArguments() throws Exception {\n+        try {\n+            distribution.cumulativeProbability(1, 0);\n+            fail(\"Expecting IllegalArgumentException for bad cumulativeProbability interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(-1);\n+            fail(\"Expecting IllegalArgumentException for p = -1\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(2);\n+            fail(\"Expecting IllegalArgumentException for p = 2\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }       \n+    }\n+    \n+    //------------------ Getters / Setters for test instance data -----------\n+    /**\n+     * @return Returns the cumulativeTestPoints.\n+     */\n+    protected double[] getCumulativeTestPoints() {\n+        return cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param cumulativeTestPoints The cumulativeTestPoints to set.\n+     */\n+    protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {\n+        this.cumulativeTestPoints = cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the cumulativeTestValues.\n+     */\n+    protected double[] getCumulativeTestValues() {\n+        return cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param cumulativeTestValues The cumulativeTestValues to set.\n+     */\n+    protected void setCumulativeTestValues(double[] cumulativeTestValues) {\n+        this.cumulativeTestValues = cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the distribution.\n+     */\n+    protected ContinuousDistribution getDistribution() {\n+        return distribution;\n+    }\n+\n+    /**\n+     * @param distribution The distribution to set.\n+     */\n+    protected void setDistribution(ContinuousDistribution distribution) {\n+        this.distribution = distribution;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestPoints.\n+     */\n+    protected double[] getInverseCumulativeTestPoints() {\n+        return inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.\n+     */\n+    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {\n+        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestValues.\n+     */\n+    protected double[] getInverseCumulativeTestValues() {\n+        return inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.\n+     */\n+    protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {\n+        this.inverseCumulativeTestValues = inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the tolerance.\n+     */\n+    protected double getTolerance() {\n+        return tolerance;\n+    }\n+\n+    /**\n+     * @param tolerance The tolerance to set.\n+     */\n+    protected void setTolerance(double tolerance) {\n+        this.tolerance = tolerance;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for ExponentialDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {\n+\n+    /**\n+     * Constructor for ExponentialDistributionTest.\n+     * @param name\n+     */\n+    public ExponentialDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new ExponentialDistributionImpl(5.0);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d, \n+                34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d}; \n+    }\n+    \n+    //------------ Additional tests -------------------------------------------\n+ \n+    public void testCumulativeProbabilityExtremes() throws Exception {\n+        setCumulativeTestPoints(new double[] {-2, 0});\n+        setCumulativeTestValues(new double[] {0, 0});\n+        verifyCumulativeProbabilities();\n+    }\n+\n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+         setInverseCumulativeTestPoints(new double[] {0, 1});\n+         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n+         verifyInverseCumulativeProbabilities();\n+    }\n+\n+    public void testCumulativeProbability2() throws Exception {\n+        double actual = getDistribution().cumulativeProbability(0.25, 0.75);\n+        assertEquals(0.0905214, actual, 10e-4);\n+    }\n+\n+    public void testDensity() {\n+        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);\n+        assertEquals(0.0, d1.density(-1e-9));\n+        assertEquals(1.0, d1.density(0.0));\n+        assertEquals(0.0, d1.density(1000.0));\n+        assertEquals(Math.exp(-1), d1.density(1.0));\n+        assertEquals(Math.exp(-2), d1.density(2.0));\n+\n+        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n+        assertEquals(1/3.0, d2.density(0.0));\n+        // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5\n+        assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n+\n+        // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5\n+        assertEquals(0.1711390397, d2.density(2.0), 1e-8);\n+    }\n+    \n+    public void testMeanAccessors() {\n+        ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();\n+        assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);\n+        distribution.setMean(2d);\n+        assertEquals(2d, distribution.getMean(), Double.MIN_VALUE);\n+        try {\n+            distribution.setMean(0);\n+            fail(\"Expecting IllegalArgumentException for 0 mean\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+   \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+\n+/**\n+ * Test cases for FDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class FDistributionTest extends ContinuousDistributionAbstractTest {\n+\n+    /**\n+     * Constructor for FDistributionTest.\n+     * @param name\n+     */\n+    public FDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new FDistributionImpl(5.0, 6.0);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        return new double[] {0.03468084d ,0.09370091d, 0.1433137d,\n+            0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d, \n+            4.387374d, 3.107512d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d}; \n+    }\n+    \n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(4e-6);\n+    }\n+\n+    //---------------------------- Additional test cases -------------------------\n+\n+    public void testCumulativeProbabilityExtremes() throws Exception {\n+        setCumulativeTestPoints(new double[] {-2, 0});\n+        setCumulativeTestValues(new double[] {0, 0});\n+        verifyCumulativeProbabilities();\n+    }\n+\n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0, 1});\n+        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testDfAccessors() {\n+        FDistribution distribution = (FDistribution) getDistribution();\n+        assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n+        distribution.setNumeratorDegreesOfFreedom(4d);\n+        assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n+        assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n+        distribution.setDenominatorDegreesOfFreedom(4d);\n+        assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n+        try {\n+            distribution.setNumeratorDegreesOfFreedom(0d);\n+            fail(\"Expecting IllegalArgumentException for df = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.setDenominatorDegreesOfFreedom(0d);\n+            fail(\"Expecting IllegalArgumentException for df = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    } \n+\n+    public void testLargeDegreesOfFreedom() throws Exception {\n+        org.apache.commons.math.distribution.FDistributionImpl fd =\n+            new org.apache.commons.math.distribution.FDistributionImpl(\n+                100000., 100000.);\n+        double p = fd.cumulativeProbability(.999);\n+        double x = fd.inverseCumulativeProbability(p);\n+        assertEquals(.999, x, 1.0e-5);\n+    }\n+\n+    public void testSmallDegreesOfFreedom() throws Exception {\n+        org.apache.commons.math.distribution.FDistributionImpl fd =\n+            new org.apache.commons.math.distribution.FDistributionImpl(\n+                1.0, 1.0);\n+        double p = fd.cumulativeProbability(0.975);\n+        double x = fd.inverseCumulativeProbability(p);\n+        assertEquals(0.975, x, 1.0e-5);\n+\n+        fd.setDenominatorDegreesOfFreedom(2.0);\n+        p = fd.cumulativeProbability(0.975);\n+        x = fd.inverseCumulativeProbability(p);\n+        assertEquals(0.975, x, 1.0e-5);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for GammaDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class GammaDistributionTest extends ContinuousDistributionAbstractTest {\n+    \n+    /**\n+     * Constructor for GammaDistributionTest.\n+     * @param name\n+     */\n+    public GammaDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+    //-------------- Implementations for abstract methods -----------------------\n+\n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new GammaDistributionImpl(4d, 2d);\n+    }\n+\n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,\n+            3.489539, 26.12448, 20.09024, 17.53455,\n+            15.50731, 13.36157};\n+    }\n+\n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d};\n+    }\n+\n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(6e-6);\n+    }\n+\n+    //---------------------------- Additional test cases -------------------------\n+    public void testParameterAccessors() {\n+        GammaDistribution distribution = (GammaDistribution) getDistribution();\n+        assertEquals(4d, distribution.getAlpha(), 0);\n+        distribution.setAlpha(3d);\n+        assertEquals(3d, distribution.getAlpha(), 0);\n+        assertEquals(2d, distribution.getBeta(), 0);\n+        distribution.setBeta(4d);\n+        assertEquals(4d, distribution.getBeta(), 0);\n+        try {\n+            distribution.setAlpha(0d);\n+            fail(\"Expecting IllegalArgumentException for alpha = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.setBeta(0d);\n+            fail(\"Expecting IllegalArgumentException for beta = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testProbabilities() throws Exception {\n+        testProbability(-1.000, 4.0, 2.0, .0000);\n+        testProbability(15.501, 4.0, 2.0, .9499);\n+        testProbability(0.504, 4.0, 1.0, .0018);\n+        testProbability(10.011, 1.0, 2.0, .9933);\n+        testProbability(5.000, 2.0, 2.0, .7127);\n+    }\n+\n+    public void testValues() throws Exception {\n+        testValue(15.501, 4.0, 2.0, .9499);\n+        testValue(0.504, 4.0, 1.0, .0018);\n+        testValue(10.011, 1.0, 2.0, .9933);\n+        testValue(5.000, 2.0, 2.0, .7127);\n+    }\n+\n+    private void testProbability(double x, double a, double b, double expected) throws Exception {\n+        GammaDistribution distribution = new GammaDistributionImpl( a, b );\n+        double actual = distribution.cumulativeProbability(x);\n+        assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+    }\n+\n+    private void testValue(double expected, double a, double b, double p) throws Exception {\n+        GammaDistribution distribution = new GammaDistributionImpl( a, b );\n+        double actual = distribution.inverseCumulativeProbability(p);\n+        assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n+    }\n+\n+    public void testDensity() {\n+        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n+        // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)\n+        checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});\n+        // R2.5: print(dgamma(x, shape=2, rate=1), digits=10)\n+        checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});\n+        // R2.5: print(dgamma(x, shape=4, rate=1), digits=10)\n+        checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});\n+        // R2.5: print(dgamma(x, shape=4, rate=10), digits=10)\n+        checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});\n+        // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)\n+        checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});\n+        // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)\n+        checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});\n+        // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)\n+        checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});\n+        // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)\n+        checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});\n+    }\n+\n+    private void checkDensity(double alpha, double rate, double[] x, double[] expected) {\n+        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+\n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0, 1});\n+        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for HyperGeometriclDistribution.\n+ * Extends IntegerDistributionAbstractTest.  See class javadoc for\n+ * IntegerDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {\n+\n+    /**\n+     * Constructor for ChiSquareDistributionTest.\n+     * @param name\n+     */\n+    public HypergeometricDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+//-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n+    public IntegerDistribution makeDistribution() {\n+        return new HypergeometricDistributionImpl(10,5, 5);\n+    }\n+    \n+    /** Creates the default probability density test input values */\n+    @Override\n+    public int[] makeDensityTestPoints() {\n+        return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};\n+    }\n+    \n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, \n+                0.099206d, 0.003968d, 0d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    @Override\n+    public int[] makeCumulativeTestPoints() {\n+        return makeDensityTestPoints();\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,\n+                1.00000d, 1d};\n+    }\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d, 1d}; \n+    }\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n+    public int[] makeInverseCumulativeTestValues() {\n+        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};\n+    }\n+    \n+    //-------------------- Additional test cases ------------------------------\n+    \n+    /** Verify that if there are no failures, mass is concentrated on sampleSize */\n+    public void testDegenerateNoFailures() throws Exception {\n+        setDistribution(new HypergeometricDistributionImpl(5,5,3));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n+        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n+        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {2, 2});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+    \n+    /** Verify that if there are no successes, mass is concentrated on 0 */\n+    public void testDegenerateNoSuccesses() throws Exception {\n+        setDistribution(new HypergeometricDistributionImpl(5,0,3));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n+        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n+        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {-1, -1});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+    \n+    /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */\n+    public void testDegenerateFullSample() throws Exception {\n+        setDistribution(new HypergeometricDistributionImpl(5,3,5));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n+        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n+        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {2, 2});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+\n+    public void testPopulationSize() {\n+        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5);\n+        try {\n+            dist.setPopulationSize(-1);\n+            fail(\"negative population size.  IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+        \n+        dist.setPopulationSize(10);\n+        assertEquals(10, dist.getPopulationSize());\n+    }\n+    \n+    public void testLargeValues() {\n+        int populationSize = 3456;\n+        int sampleSize = 789;\n+        int numberOfSucceses = 101;\n+        double[][] data = {\n+            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},\n+            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},\n+            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},\n+            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},\n+            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},\n+            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},\n+            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, \n+            {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, \n+            {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, \n+            {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, \n+            {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718}, \n+            {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418}, \n+            {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},\n+            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59}, \n+            {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},\n+            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, \n+            {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},\n+            {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},\n+        };\n+        \n+        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n+    }\n+\n+    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {\n+        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);\n+        for (int i = 0; i < data.length; ++i) {\n+            int x = (int)data[i][0];\n+            double pdf = data[i][1];\n+            double actualPdf = dist.probability(x);\n+            TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);\n+\n+            double cdf = data[i][2];\n+            double actualCdf = dist.cumulativeProbability(x);\n+            TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);\n+\n+            double cdf1 = data[i][3];\n+            double actualCdf1 = dist.upperCumulativeProbability(x);\n+            TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);\n+        }\n+    }\n+    \n+    public void testMoreLargeValues() {\n+        int populationSize = 26896;\n+        int sampleSize = 895;\n+        int numberOfSucceses = 55;\n+        double[][] data = {\n+            {0.0, 0.155168304750504, 0.155168304750504, 1.0}, \n+            {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, \n+            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, \n+            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, \n+            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, \n+            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, \n+            {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, \n+            {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, \n+            {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, \n+            {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20}, \n+            {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21}, \n+            {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23}, \n+            {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69}, \n+            {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71}, \n+            {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74}, \n+            {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, \n+            {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, \n+            {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        \n+        };\n+        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract base class for {@link IntegerDistribution} tests.\n+ * <p>\n+ * To create a concrete test class for an integer distribution implementation,\n+ *  implement makeDistribution() to return a distribution instance to use in \n+ *  tests and each of the test data generation methods below.  In each case, the\n+ *  test points and test values arrays returned represent parallel arrays of \n+ *  inputs and expected values for the distribution returned by makeDistribution().\n+ *  <p>\n+ *  makeDensityTestPoints() -- arguments used to test probability density calculation\n+ *  makeDensityTestValues() -- expected probability densities\n+ *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities\n+ *  makeCumulativeTestValues() -- expected cumulative probabilites\n+ *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation\n+ *  makeInverseCumulativeTestValues() -- expected inverse cdf values\n+ * <p>\n+ *  To implement additional test cases with different distribution instances and test data,\n+ *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods\n+ *  to verify results. \n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class IntegerDistributionAbstractTest extends TestCase {\n+    \n+//-------------------- Private test instance data -------------------------\n+    /** Discrete distribution instance used to perform tests */\n+    private IntegerDistribution distribution;\n+    \n+    /** Tolerance used in comparing expected and returned values */\n+    private double tolerance = 1E-4;\n+    \n+    /** Arguments used to test probability density calculations */\n+    private int[] densityTestPoints;\n+    \n+    /** Values used to test probability density calculations */\n+    private double[] densityTestValues;\n+    \n+    /** Arguments used to test cumulative probability density calculations */\n+    private int[] cumulativeTestPoints;\n+    \n+    /** Values used to test cumulative probability density calculations */\n+    private double[] cumulativeTestValues;\n+    \n+    /** Arguments used to test inverse cumulative probability density calculations */\n+    private double[] inverseCumulativeTestPoints;\n+    \n+    /** Values used to test inverse cumulative probability density calculations */\n+    private int[] inverseCumulativeTestValues;\n+    \n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * Constructor for IntegerDistributionAbstractTest.\n+     * @param name\n+     */\n+    public IntegerDistributionAbstractTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------------- Abstract methods -----------------------------------\n+    \n+    /** Creates the default discrete distribution instance to use in tests. */\n+    public abstract IntegerDistribution makeDistribution();\n+    \n+    /** Creates the default probability density test input values */\n+    public abstract int[] makeDensityTestPoints();\n+    \n+    /** Creates the default probability density test expected values */\n+    public abstract double[] makeDensityTestValues();\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    public abstract int[] makeCumulativeTestPoints();\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    public abstract double[] makeCumulativeTestValues();\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    public abstract double[] makeInverseCumulativeTestPoints();\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    public abstract int[] makeInverseCumulativeTestValues();\n+    \n+    //-------------------- Setup / tear down ----------------------------------\n+     \n+    /**\n+     * Setup sets all test instance data to default values \n+     */\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        distribution = makeDistribution();\n+        densityTestPoints = makeDensityTestPoints();\n+        densityTestValues = makeDensityTestValues();\n+        cumulativeTestPoints = makeCumulativeTestPoints();\n+        cumulativeTestValues = makeCumulativeTestValues();\n+        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n+        inverseCumulativeTestValues = makeInverseCumulativeTestValues();   \n+    }\n+    \n+    /**\n+     * Cleans up test instance data\n+     */\n+    @Override\n+    protected void tearDown() throws Exception {      \n+        super.tearDown();\n+        distribution = null;\n+        densityTestPoints = null;\n+        densityTestValues = null;\n+        cumulativeTestPoints = null;\n+        cumulativeTestValues = null;\n+        inverseCumulativeTestPoints = null;\n+        inverseCumulativeTestValues = null;   \n+    }\n+    \n+    //-------------------- Verification methods -------------------------------\n+    \n+    /**\n+     * Verifies that probability density calculations match expected values\n+     * using current test instance data\n+     */\n+    protected void verifyDensities() throws Exception {\n+        for (int i = 0; i < densityTestPoints.length; i++) {\n+            assertEquals(\"Incorrect density value returned for \" + densityTestPoints[i],\n+                    densityTestValues[i], \n+                    distribution.probability(densityTestPoints[i]), tolerance);\n+        }     \n+    }\n+    \n+    /**\n+     * Verifies that cumulative probability density calculations match expected values\n+     * using current test instance data\n+     */   \n+    protected void verifyCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            assertEquals(\"Incorrect cumulative probability value returned for \" + cumulativeTestPoints[i],\n+                    cumulativeTestValues[i], \n+                    distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);\n+        }           \n+    }\n+    \n+    \n+    /**\n+     * Verifies that inverse cumulative probability density calculations match expected values\n+     * using current test instance data\n+     */\n+    protected void verifyInverseCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n+            assertEquals(\"Incorrect inverse cumulative probability value returned for \" \n+                    + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], \n+                    distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));\n+        }           \n+    }\n+    \n+    //------------------------ Default test cases -----------------------------\n+\n+    /**\n+     * Verifies that probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    public void testDensities() throws Exception {\n+        verifyDensities();     \n+    }\n+    \n+    /**\n+     * Verifies that cumulative probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    public void testCumulativeProbabilities() throws Exception {\n+        verifyCumulativeProbabilities();      \n+    }\n+    \n+    /**\n+     * Verifies that floating point arguments are correctly handled by\n+     * cumulativeProbablility(-,-)\n+     * JIRA: MATH-184\n+     */\n+    public void testFloatingPointArguments() throws Exception {\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            double arg = cumulativeTestPoints[i];\n+            assertEquals(\n+                    \"Incorrect cumulative probability value returned for \" +\n+                    cumulativeTestPoints[i],\n+                    cumulativeTestValues[i], \n+                    distribution.cumulativeProbability(arg), tolerance);\n+            if (i < cumulativeTestPoints.length - 1) {\n+                double arg2 = cumulativeTestPoints[i + 1];\n+                assertEquals(\"Inconsistent probability for discrete range \" +\n+                        \"[ \" + arg + \",\" + arg2 + \" ]\",\n+                   distribution.cumulativeProbability(\n+                           cumulativeTestPoints[i],\n+                           cumulativeTestPoints[i + 1]),\n+                   distribution.cumulativeProbability(arg, arg2), tolerance);\n+                arg = arg - Math.random();\n+                arg2 = arg2 + Math.random();\n+                assertEquals(\"Inconsistent probability for discrete range \" +\n+                        \"[ \" + arg + \",\" + arg2 + \" ]\",\n+                   distribution.cumulativeProbability(\n+                           cumulativeTestPoints[i],\n+                           cumulativeTestPoints[i + 1]),\n+                   distribution.cumulativeProbability(arg, arg2), tolerance);\n+            }\n+        } \n+        int one = 1;\n+        int ten = 10;\n+        int two = 2;\n+        double oned = one;\n+        double twod = two;\n+        double tend = ten;\n+        assertEquals(distribution.cumulativeProbability(one, two), \n+                distribution.cumulativeProbability(oned, twod), tolerance);\n+        assertEquals(distribution.cumulativeProbability(one, two), \n+                distribution.cumulativeProbability(oned - tolerance,\n+                        twod + 0.9), tolerance);\n+        assertEquals(distribution.cumulativeProbability(two, ten), \n+                distribution.cumulativeProbability(twod, tend), tolerance);\n+        assertEquals(distribution.cumulativeProbability(two, ten), \n+                distribution.cumulativeProbability(twod - tolerance,\n+                        tend + 0.9), tolerance);\n+    }\n+    \n+    /**\n+     * Verifies that inverse cumulative probability density calculations match expected values\n+     * using default test instance data\n+     */\n+    public void testInverseCumulativeProbabilities() throws Exception {\n+        verifyInverseCumulativeProbabilities();       \n+    }\n+    \n+    /**\n+     * Verifies that illegal arguments are correctly handled\n+     */\n+    public void testIllegalArguments() throws Exception {\n+        try {\n+            distribution.cumulativeProbability(1, 0);\n+            fail(\"Expecting IllegalArgumentException for bad cumulativeProbability interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(-1);\n+            fail(\"Expecting IllegalArgumentException for p = -1\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(2);\n+            fail(\"Expecting IllegalArgumentException for p = 2\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }       \n+    }\n+    \n+    //------------------ Getters / Setters for test instance data -----------\n+    /**\n+     * @return Returns the cumulativeTestPoints.\n+     */\n+    protected int[] getCumulativeTestPoints() {\n+        return cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param cumulativeTestPoints The cumulativeTestPoints to set.\n+     */\n+    protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {\n+        this.cumulativeTestPoints = cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the cumulativeTestValues.\n+     */\n+    protected double[] getCumulativeTestValues() {\n+        return cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param cumulativeTestValues The cumulativeTestValues to set.\n+     */\n+    protected void setCumulativeTestValues(double[] cumulativeTestValues) {\n+        this.cumulativeTestValues = cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the densityTestPoints.\n+     */\n+    protected int[] getDensityTestPoints() {\n+        return densityTestPoints;\n+    }\n+\n+    /**\n+     * @param densityTestPoints The densityTestPoints to set.\n+     */\n+    protected void setDensityTestPoints(int[] densityTestPoints) {\n+        this.densityTestPoints = densityTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the densityTestValues.\n+     */\n+    protected double[] getDensityTestValues() {\n+        return densityTestValues;\n+    }\n+\n+    /**\n+     * @param densityTestValues The densityTestValues to set.\n+     */\n+    protected void setDensityTestValues(double[] densityTestValues) {\n+        this.densityTestValues = densityTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the distribution.\n+     */\n+    protected IntegerDistribution getDistribution() {\n+        return distribution;\n+    }\n+\n+    /**\n+     * @param distribution The distribution to set.\n+     */\n+    protected void setDistribution(IntegerDistribution distribution) {\n+        this.distribution = distribution;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestPoints.\n+     */\n+    protected double[] getInverseCumulativeTestPoints() {\n+        return inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.\n+     */\n+    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {\n+        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestValues.\n+     */\n+    protected int[] getInverseCumulativeTestValues() {\n+        return inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.\n+     */\n+    protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {\n+        this.inverseCumulativeTestValues = inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the tolerance.\n+     */\n+    protected double getTolerance() {\n+        return tolerance;\n+    }\n+\n+    /**\n+     * @param tolerance The tolerance to set.\n+     */\n+    protected void setTolerance(double tolerance) {\n+        this.tolerance = tolerance;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Test cases for NormalDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {\n+    \n+    /**\n+     * Constructor for NormalDistributionTest.\n+     * @param arg0\n+     */\n+    public NormalDistributionTest(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new NormalDistributionImpl(2.1, 1.4);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R \n+        return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d, \n+                6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d}; \n+    }\n+    \n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(1E-6);\n+    }\n+    \n+    //---------------------------- Additional test cases -------------------------\n+    \n+    private void verifyQuantiles() throws Exception {\n+        NormalDistribution distribution = (NormalDistribution) getDistribution();\n+        double mu = distribution.getMean();\n+        double sigma = distribution.getStandardDeviation();\n+        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma, \n+                mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,\n+                mu + 5 * sigma});\n+        // Quantiles computed using R (same as Mathematica)\n+        setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447, \n+                0.9772499, 0.9986501, 0.9999683,  0.9999997});\n+        verifyCumulativeProbabilities();       \n+    }\n+    \n+    public void testQuantiles() throws Exception {\n+        verifyQuantiles();\n+        setDistribution(new NormalDistributionImpl(0, 1));\n+        verifyQuantiles();\n+        setDistribution(new NormalDistributionImpl(0, 0.1));\n+        verifyQuantiles();\n+    }\n+    \n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0, 1});\n+        setInverseCumulativeTestValues(\n+                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testGetMean() {\n+        NormalDistribution distribution = (NormalDistribution) getDistribution();\n+        assertEquals(2.1, distribution.getMean(), 0);\n+    }\n+    \n+    public void testSetMean() throws Exception {\n+        double mu = Math.random();\n+        NormalDistribution distribution = (NormalDistribution) getDistribution();\n+        distribution.setMean(mu);\n+        verifyQuantiles();\n+    }\n+    \n+    public void testGetStandardDeviation() {\n+        NormalDistribution distribution = (NormalDistribution) getDistribution();\n+        assertEquals(1.4, distribution.getStandardDeviation(), 0);  \n+    }\n+    \n+    public void testSetStandardDeviation() throws Exception {\n+        double sigma = 0.1d + Math.random();\n+        NormalDistribution distribution = (NormalDistribution) getDistribution();\n+        distribution.setStandardDeviation(sigma);\n+        assertEquals(sigma, distribution.getStandardDeviation(), 0);\n+        verifyQuantiles();\n+        try {\n+            distribution.setStandardDeviation(0);\n+            fail(\"Expecting IllegalArgumentException for sd = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+    }\n+\n+    public void testDensity() {\n+        double [] x = new double[]{-2, -1, 0, 1, 2};\n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)\n+        checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});\n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) \n+        checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});\n+    }\n+\n+    private void checkDensity(double mean, double sd, double[] x, double[] expected) {\n+        NormalDistribution d = new NormalDistributionImpl(mean, sd);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-9);\n+        }\n+    }\n+\n+    /**\n+     * Check to make sure top-coding of extreme values works correctly.\n+     * Verifies fix for JIRA MATH-167\n+     */\n+    public void testExtremeValues() throws Exception {\n+        NormalDistribution distribution = (NormalDistribution) getDistribution();\n+        distribution.setMean(0);\n+        distribution.setStandardDeviation(1);\n+        for (int i = 0; i < 100; i+=5) { // make sure no convergence exception\n+            double lowerTail = distribution.cumulativeProbability(-i);\n+            double upperTail = distribution.cumulativeProbability(i);\n+            if (i < 10) { // make sure not top-coded\n+                assertTrue(lowerTail > 0.0d);\n+                assertTrue(upperTail < 1.0d);\n+            }\n+            else { // make sure top coding not reversed\n+                assertTrue(lowerTail < 0.00001);\n+                assertTrue(upperTail > 0.99999);\n+            }\n+        } \n+   }\n+\n+    public void testMath280() throws MathException {\n+        NormalDistribution normal = new NormalDistributionImpl(0,1);\n+        double result = normal.inverseCumulativeProbability(0.9772498680518209);\n+        assertEquals(2.0, result, 1.0e-12);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for PascalDistribution.\n+ * Extends IntegerDistributionAbstractTest.  See class javadoc for\n+ * IntegerDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class PascalDistributionTest extends IntegerDistributionAbstractTest {\n+    \n+    /**\n+     * Constructor for PascalDistributionTest.\n+     * @param name\n+     */\n+    public PascalDistributionTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n+    public IntegerDistribution makeDistribution() {\n+        return new PascalDistributionImpl(10,0.70);\n+    }\n+    \n+    /** Creates the default probability density test input values */\n+    @Override\n+    public int[] makeDensityTestPoints() {\n+      return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n+    }\n+    \n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+      return new double[] {0d, 0.02824d, 0.08474d, 0.13982d, \n+          0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};\n+    }\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    @Override\n+    public int[] makeCumulativeTestPoints() {\n+      return makeDensityTestPoints();\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+      return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,\n+          0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};\n+        }\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n+          0.990d, 0.975d, 0.950d, 0.900d, 1}; \n+        }\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n+    public int[] makeInverseCumulativeTestValues() {\n+      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};\n+    }\n+\n+    //----------------- Additional test cases ---------------------------------\n+   \n+    /** Test degenerate case p = 0   */\n+    public void testDegenerate0() throws Exception {\n+        setDistribution(new PascalDistributionImpl(5,0.0d));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });\n+        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});\n+        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+    \n+    /** Test degenerate case p = 1   */\n+    public void testDegenerate1() throws Exception {\n+        setDistribution(new PascalDistributionImpl(5,1.0d));\n+        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n+        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});\n+        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});\n+        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});\n+        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n+        setInverseCumulativeTestValues(new int[] {-1, -1});\n+        verifyDensities();\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();     \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * <code>PoissonDistributionTest</code>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class PoissonDistributionTest extends IntegerDistributionAbstractTest {\n+\n+    /**\n+     * Poisson parameter value for the test distribution.\n+     */\n+    private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;\n+\n+    /**\n+     * Constructor.\n+     * @param name\n+     */\n+    public PoissonDistributionTest(String name) {\n+        super(name);\n+        setTolerance(1e-12);\n+    }\n+\n+    /** \n+     * Creates the default discrete distribution instance to use in tests. \n+     */\n+    @Override\n+    public IntegerDistribution makeDistribution() {\n+        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);  \n+    }\n+\n+    /** \n+     * Creates the default probability density test input values.\n+     */\n+    @Override\n+    public int[] makeDensityTestPoints() {\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n+    }\n+\n+    /**\n+     * Creates the default probability density test expected values.\n+     * These and all other test values are generated by R, version 1.8.1\n+     */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] { 0d, 0.0183156388887d,  0.073262555555d,\n+                0.14652511111d, 0.195366814813d, 0.195366814813, \n+                0.156293451851d, 0.00529247667642d, 8.27746364655e-09};\n+    }\n+\n+    /**\n+     * Creates the default cumulative probability density test input values.\n+     */\n+    @Override\n+    public int[] makeCumulativeTestPoints() {\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };\n+    }\n+\n+    /**\n+     * Creates the default cumulative probability density test expected values.\n+     */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d, \n+                0.238103305554d, 0.433470120367d, 0.62883693518,\n+                0.78513038703d,  0.99716023388d, 0.999999998077 };\n+    }\n+\n+    /** \n+     * Creates the default inverse cumulative probability test input values.\n+     * Increased 3rd and 7th values slightly as computed cumulative\n+     * probabilities for corresponding values exceeds the target value (still \n+     * within tolerance).\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return new double[] { 0d,  0.018315638889d, 0.0915781944437d, \n+                0.238103305554d, 0.433470120367d, 0.62883693518,\n+                0.78513038704d,  0.99716023388d, 0.999999998077 };\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability density test expected values.\n+     */\n+    @Override\n+    public int[] makeInverseCumulativeTestValues() {\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n+    }\n+\n+    /**\n+     * Test the normal approximation of the Poisson distribution by\n+     * calculating P(90 &le; X &le; 110) for X = Po(100) and\n+     * P(9900 &le; X &le; 10200) for X  = Po(10000)\n+     */\n+    public void testNormalApproximateProbability() throws Exception {\n+        PoissonDistribution dist = new PoissonDistributionImpl(100);\n+        double result = dist.normalApproximateProbability(110)\n+                - dist.normalApproximateProbability(89);\n+        assertEquals(0.706281887248, result, 1E-10);\n+        dist.setMean(10000);\n+        result = dist.normalApproximateProbability(10200)\n+        - dist.normalApproximateProbability(9899);\n+        assertEquals(0.820070051552, result, 1E-10);\n+    }\n+\n+    /**\n+     * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.\n+     * @throws Exception\n+     */\n+    public void testDegenerateInverseCumulativeProbability() throws Exception {\n+        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n+        assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n+        assertEquals(-1, dist.inverseCumulativeProbability(0d));\n+    }\n+    \n+    public void testMean() {\n+        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n+        try {\n+            dist.setMean(-1);\n+            fail(\"negative mean.  IllegalArgumentException expected\");\n+        } catch(IllegalArgumentException ex) {\n+        }\n+        \n+        dist.setMean(10.0);\n+        assertEquals(10.0, dist.getMean(), 0.0);\n+    }\n+    \n+    public void testLargeMeanCumulativeProbability() {\n+        PoissonDistribution dist = new PoissonDistributionImpl(1.0);\n+        double mean = 1.0;\n+        while (mean <= 10000000.0) {\n+            dist.setMean(mean);\n+            \n+            double x = mean * 2.0;\n+            double dx = x / 10.0;\n+            while (x >= 0) {\n+                try {\n+                    dist.cumulativeProbability(x);\n+                } catch (MathException ex) {\n+                    fail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n+                }\n+                x -= dx;\n+            }\n+            \n+            mean *= 10.0;\n+        }\n+    }\n+    \n+    public void testLargeMeanInverseCumulativeProbability() {\n+        PoissonDistribution dist = new PoissonDistributionImpl(1.0);\n+        double mean = 1.0;\n+        while (mean <= 10000000.0) {\n+            dist.setMean(mean);\n+            \n+            double p = 0.1;\n+            double dp = p;\n+            while (p < 1.0) {\n+                try {\n+                    dist.inverseCumulativeProbability(p);\n+                } catch (MathException ex) {\n+                    fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n+                }\n+                p += dp;\n+            }\n+            \n+            mean *= 10.0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for TDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class TDistributionTest extends ContinuousDistributionAbstractTest {\n+\n+    /**\n+     * Constructor for TDistributionTest.\n+     * @param name\n+     */\n+    public TDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+//-------------- Implementations for abstract methods -----------------------\n+\n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new TDistributionImpl(5.0);\n+    }\n+\n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,\n+            -1.475884, 0.0, 5.89343, 3.36493, 2.570582,\n+            2.015048, 1.475884};\n+    }\n+\n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d};\n+    }\n+\n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(1E-6);\n+    }\n+\n+    //---------------------------- Additional test cases -------------------------\n+    /**\n+     * @see <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=27243\">\n+     *      Bug report that prompted this unit test.</a>\n+     */\n+    public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {\n+        TDistributionImpl td = new TDistributionImpl(5.);\n+        td.cumulativeProbability(.1);\n+        td.cumulativeProbability(.01);\n+    }\n+\n+    public void testSmallDf() throws Exception {\n+        setDistribution(new TDistributionImpl(1d));\n+        setTolerance(1E-4);\n+        // quantiles computed using R version 1.8.1 (linux version)\n+        setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752,\n+            -3.077684, 0.0, 318.3088, 31.82052, 12.70620,\n+            6.313752, 3.077684});\n+        setInverseCumulativeTestValues(getCumulativeTestPoints());\n+        verifyCumulativeProbabilities();\n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0, 1});\n+        setInverseCumulativeTestValues(\n+                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n+    public void testDfAccessors() {\n+        TDistribution distribution = (TDistribution) getDistribution();\n+        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        distribution.setDegreesOfFreedom(4d);\n+        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        try {\n+            distribution.setDegreesOfFreedom(0d);\n+            fail(\"Expecting IllegalArgumentException for df = 0\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for WeibullDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n+    \n+    /**\n+     * Constructor for CauchyDistributionTest.\n+     * @param arg0\n+     */\n+    public WeibullDistributionTest(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    @Override\n+    public ContinuousDistribution makeDistribution() {\n+        return new WeibullDistributionImpl(1.2, 2.1);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using Mathematica \n+        return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n+                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,\n+                6.232056007d, 7.497630467d, 10.51154969d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n+                0.975d, 0.990d, 0.999d};\n+    }\n+    \n+    //---------------------------- Additional test cases -------------------------\n+    \n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n+        setInverseCumulativeTestValues(\n+                new double[] {0.0, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testAlpha() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setShape(expected);\n+        assertEquals(expected, distribution.getShape(), 0.0);\n+    }\n+    \n+    public void testBeta() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setScale(expected);\n+        assertEquals(expected, distribution.getScale(), 0.0);\n+    }\n+    \n+    public void testSetAlpha() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        try {\n+            distribution.setShape(0.0);\n+            fail(\"Can not have 0.0 alpha.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setShape(-1.0);\n+            fail(\"Can not have negative alpha.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetBeta() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        try {\n+            distribution.setScale(0.0);\n+            fail(\"Can not have 0.0 beta.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setScale(-1.0);\n+            fail(\"Can not have negative beta.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for {@link ZipfDistribution}.\n+ * Extends IntegerDistributionAbstractTest.  See class javadoc for\n+ * IntegerDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ZipfDistributionTest extends IntegerDistributionAbstractTest {\n+    public ZipfDistributionTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default discrete distribution instance to use in tests. */\n+    @Override\n+    public IntegerDistribution makeDistribution() {\n+        return new ZipfDistributionImpl(10, 1);\n+    }\n+    \n+    /** Creates the default probability density test input values */\n+    @Override\n+    public int[] makeDensityTestPoints() {\n+        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n+    }\n+    \n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d, \n+                0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    @Override\n+    public int[] makeCumulativeTestPoints() {\n+        return makeDensityTestPoints();\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d,\n+                0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d};\n+        }\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d, 1}; \n+        }\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    @Override\n+    public int[] makeInverseCumulativeTestValues() {\n+        return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/estimation/EstimatedParameterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import org.apache.commons.math.estimation.EstimatedParameter;\n+\n+import junit.framework.*;\n+\n+@Deprecated\n+public class EstimatedParameterTest\n+  extends TestCase {\n+\n+  public EstimatedParameterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstruction() {\n+\n+    EstimatedParameter p1 = new EstimatedParameter(\"p1\", 1.0);\n+    assertTrue(p1.getName().equals(\"p1\"));\n+    checkValue(p1.getEstimate(), 1.0);\n+    assertTrue(! p1.isBound());\n+\n+    EstimatedParameter p2 = new EstimatedParameter(\"p2\", 2.0, true);\n+    assertTrue(p2.getName().equals(\"p2\"));\n+    checkValue(p2.getEstimate(), 2.0);\n+    assertTrue(p2.isBound());\n+\n+  }\n+\n+  public void testBound() {\n+\n+    EstimatedParameter p = new EstimatedParameter(\"p\", 0.0);\n+    assertTrue(! p.isBound());\n+    p.setBound(true);\n+    assertTrue(p.isBound());\n+    p.setBound(false);\n+    assertTrue(! p.isBound());\n+\n+  }\n+\n+  public void testEstimate() {\n+\n+    EstimatedParameter p = new EstimatedParameter(\"p\", 0.0);\n+    checkValue(p.getEstimate(), 0.0);\n+\n+    for (double e = 0.0; e < 10.0; e += 0.5) {\n+      p.setEstimate(e);\n+      checkValue(p.getEstimate(), e);\n+    }\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EstimatedParameterTest.class);\n+  }\n+\n+  private void checkValue(double value, double expected) {\n+    assertTrue(Math.abs(value - expected) < 1.0e-10);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+@Deprecated\n+public class GaussNewtonEstimatorTest\n+  extends TestCase {\n+\n+  public GaussNewtonEstimatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testTrivial() throws EstimationException {\n+    LinearProblem problem =\n+      new LinearProblem(new LinearMeasurement[] {\n+        new LinearMeasurement(new double[] {2},\n+                              new EstimatedParameter[] {\n+                                 new EstimatedParameter(\"p0\", 0)\n+                              }, 3.0)\n+      });\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(1.5,\n+                 problem.getUnboundParameters()[0].getEstimate(),\n+                 1.0e-10);\n+   }\n+\n+  public void testQRColumnsPermutation() throws EstimationException {\n+\n+    EstimatedParameter[] x = {\n+       new EstimatedParameter(\"p0\", 0), new EstimatedParameter(\"p1\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                            new EstimatedParameter[] { x[0], x[1] },\n+                            4.0),\n+      new LinearMeasurement(new double[] { 2.0 },\n+                            new EstimatedParameter[] { x[1] },\n+                            6.0),\n+      new LinearMeasurement(new double[] { 1.0, -2.0 },\n+                            new EstimatedParameter[] { x[0], x[1] },\n+                            1.0)\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);\n+    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testNoDependency() throws EstimationException {\n+    EstimatedParameter[] p = new EstimatedParameter[] {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 0),\n+      new EstimatedParameter(\"p2\", 0),\n+      new EstimatedParameter(\"p3\", 0),\n+      new EstimatedParameter(\"p4\", 0),\n+      new EstimatedParameter(\"p5\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)\n+    });\n+  GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+  estimator.estimate(problem);\n+  assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+  for (int i = 0; i < p.length; ++i) {\n+    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);\n+  }\n+}\n+\n+  public void testOneSet() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 0),\n+       new EstimatedParameter(\"p1\", 0),\n+       new EstimatedParameter(\"p2\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0 },\n+                            new EstimatedParameter[] { p[0] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -1.0, 1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -1.0, 1.0 },\n+                            new EstimatedParameter[] { p[1], p[2] },\n+                            1.0)\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testTwoSets() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 1),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 3),\n+      new EstimatedParameter(\"p4\", 4),\n+      new EstimatedParameter(\"p5\", 5)\n+    };\n+\n+    double epsilon = 1.0e-7;\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+\n+      // 4 elements sub-problem\n+      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[3] },\n+                            2.0),\n+      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },\n+                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                           -9.0),\n+      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            2.0),\n+      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },\n+                           new EstimatedParameter[] { p[1], p[2], p[3] },\n+                           2.0),\n+\n+      // 2 elements sub-problem\n+      new LinearMeasurement(new double[] { epsilon, 1.0 },\n+                            new EstimatedParameter[] { p[4], p[5] },\n+                            1.0 + epsilon * epsilon),\n+      new LinearMeasurement(new double[] {  1.0, 1.0 },\n+                            new EstimatedParameter[] { p[4], p[5] },\n+                            2.0)\n+\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);\n+    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);\n+    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testNonInversible() {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 0),\n+       new EstimatedParameter(\"p1\", 0),\n+       new EstimatedParameter(\"p2\", 0)\n+    };\n+    LinearMeasurement[] m = new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2] },\n+                            1.0),\n+      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -3.0, -9.0 },\n+                            new EstimatedParameter[] { p[0], p[2] },\n+                            1.0)\n+    };\n+    LinearProblem problem = new LinearProblem(m);\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    try {\n+      estimator.estimate(problem);\n+      fail(\"an exception should have been caught\");\n+    } catch (EstimationException ee) {\n+      // expected behavior\n+    } catch (Exception e) {\n+      fail(\"wrong exception type caught\");\n+    }\n+  }\n+\n+  public void testIllConditioned() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 1),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 3)\n+    };\n+\n+    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            32.0),\n+      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            23.0),\n+      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            33.0),\n+      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            31.0)\n+    });\n+    GaussNewtonEstimator estimator1 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator1.estimate(problem1);\n+    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);\n+    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);\n+\n+    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            32.0),\n+      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            23.0),\n+      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },\n+                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            33.0),\n+      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },\n+                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            31.0)\n+    });\n+    GaussNewtonEstimator estimator2 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator2.estimate(problem2);\n+    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);\n+    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);\n+    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);\n+    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);\n+    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);\n+\n+  }\n+\n+  public void testMoreEstimatedParametersSimple() {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 7),\n+       new EstimatedParameter(\"p1\", 6),\n+       new EstimatedParameter(\"p2\", 5),\n+       new EstimatedParameter(\"p3\", 4)\n+     };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 3.0, 2.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             7.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                             new EstimatedParameter[] { p[1], p[2], p[3] },\n+                             3.0),\n+      new LinearMeasurement(new double[] { 2.0, 1.0 },\n+                             new EstimatedParameter[] { p[0], p[2] },\n+                             5.0)\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    try {\n+        estimator.estimate(problem);\n+        fail(\"an exception should have been caught\");\n+    } catch (EstimationException ee) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+    }\n+\n+  }\n+\n+  public void testMoreEstimatedParametersUnsorted() {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 2),\n+      new EstimatedParameter(\"p1\", 2),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 2),\n+      new EstimatedParameter(\"p4\", 2),\n+      new EstimatedParameter(\"p5\", 2)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                           new EstimatedParameter[] { p[0], p[1] },\n+                           3.0),\n+      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n+                           new EstimatedParameter[] { p[2], p[3], p[4] },\n+                           12.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                           new EstimatedParameter[] { p[4], p[5] },\n+                           -1.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                           new EstimatedParameter[] { p[3], p[2], p[5] },\n+                           7.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                           new EstimatedParameter[] { p[4], p[3] },\n+                           1.0)\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    try {\n+        estimator.estimate(problem);\n+        fail(\"an exception should have been caught\");\n+    } catch (EstimationException ee) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+    }\n+\n+  }\n+\n+  public void testRedundantEquations() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 1),\n+      new EstimatedParameter(\"p1\", 1)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             3.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             1.0),\n+      new LinearMeasurement(new double[] { 1.0, 3.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             5.0)\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    EstimatedParameter[] all = problem.getAllParameters();\n+    for (int i = 0; i < all.length; ++i) {\n+        assertEquals(all[i].getName().equals(\"p0\") ? 2.0 : 1.0,\n+                     all[i].getEstimate(), 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInconsistentEquations() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 1),\n+      new EstimatedParameter(\"p1\", 1)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            3.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { 1.0, 3.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            4.0)\n+    });\n+\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    estimator.estimate(problem);\n+    assertTrue(estimator.getRMS(problem) > 0.1);\n+\n+  }\n+\n+  public void testBoundParameters() throws EstimationException {\n+      EstimatedParameter[] p = {\n+        new EstimatedParameter(\"unbound0\", 2, false),\n+        new EstimatedParameter(\"unbound1\", 2, false),\n+        new EstimatedParameter(\"bound\",    2, true)\n+      };\n+      LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+        new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n+                              new EstimatedParameter[] { p[0], p[1], p[2] },\n+                              3.0),\n+        new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                              new EstimatedParameter[] { p[0], p[1], p[2] },\n+                              1.0),\n+        new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },\n+                              new EstimatedParameter[] { p[0], p[1], p[2] },\n+                              7.0)\n+      });\n+\n+      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+      estimator.estimate(problem);\n+      assertTrue(estimator.getRMS(problem) < 1.0e-10);\n+      double[][] covariances = estimator.getCovariances(problem);\n+      int i0 = 0, i1 = 1;\n+      if (problem.getUnboundParameters()[0].getName().endsWith(\"1\")) {\n+          i0 = 1;\n+          i1 = 0;\n+      }\n+      assertEquals(11.0 / 24, covariances[i0][i0], 1.0e-10);\n+      assertEquals(-3.0 / 24, covariances[i0][i1], 1.0e-10);\n+      assertEquals(-3.0 / 24, covariances[i1][i0], 1.0e-10);\n+      assertEquals( 3.0 / 24, covariances[i1][i1], 1.0e-10);\n+\n+      double[] errors = estimator.guessParametersErrors(problem);\n+      assertEquals(0, errors[i0], 1.0e-10);\n+      assertEquals(0, errors[i1], 1.0e-10);\n+\n+  }\n+\n+  public void testMaxIterations() {\n+      Circle circle = new Circle(98.680, 47.345);\n+      circle.addPoint( 30.0,  68.0);\n+      circle.addPoint( 50.0,  -6.0);\n+      circle.addPoint(110.0, -20.0);\n+      circle.addPoint( 35.0,  15.0);\n+      circle.addPoint( 45.0,  97.0);\n+      try {\n+        GaussNewtonEstimator estimator = new GaussNewtonEstimator(4, 1.0e-14, 1.0e-14);\n+        estimator.estimate(circle);\n+        fail(\"an exception should have been caught\");\n+      } catch (EstimationException ee) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+      }\n+    }\n+\n+  public void testCircleFitting() throws EstimationException {\n+      Circle circle = new Circle(98.680, 47.345);\n+      circle.addPoint( 30.0,  68.0);\n+      circle.addPoint( 50.0,  -6.0);\n+      circle.addPoint(110.0, -20.0);\n+      circle.addPoint( 35.0,  15.0);\n+      circle.addPoint( 45.0,  97.0);\n+      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-10, 1.0e-10);\n+      estimator.estimate(circle);\n+      double rms = estimator.getRMS(circle);\n+      assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);\n+      assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);\n+      assertEquals(96.07590211815305, circle.getX(),      1.0e-10);\n+      assertEquals(48.13516790438953, circle.getY(),      1.0e-10);\n+    }\n+\n+  public void testCircleFittingBadInit() {\n+    Circle circle = new Circle(-12, -12);\n+    double[][] points = new double[][] {\n+      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+    };\n+    for (int i = 0; i < points.length; ++i) {\n+      circle.addPoint(points[i][0], points[i][1]);\n+    }\n+    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n+    try {\n+        estimator.estimate(circle);\n+        fail(\"an exception should have been caught\");\n+    } catch (EstimationException ee) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+    }\n+}\n+\n+  private static class LinearProblem extends SimpleEstimationProblem {\n+\n+    public LinearProblem(LinearMeasurement[] measurements) {\n+      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();\n+      for (int i = 0; i < measurements.length; ++i) {\n+        addMeasurement(measurements[i]);\n+        EstimatedParameter[] parameters = measurements[i].getParameters();\n+        for (int j = 0; j < parameters.length; ++j) {\n+          set.add(parameters[j]);\n+        }\n+      }\n+      for (EstimatedParameter p : set) {\n+        addParameter(p);\n+      }\n+    }\n+\n+  }\n+\n+  private static class LinearMeasurement extends WeightedMeasurement {\n+\n+    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,\n+                             double setPoint) {\n+      super(1.0, setPoint, true);\n+      this.factors = factors;\n+      this.parameters = parameters;\n+      setIgnored(false);\n+    }\n+\n+    @Override\n+    public double getTheoreticalValue() {\n+      double v = 0;\n+      for (int i = 0; i < factors.length; ++i) {\n+        v += factors[i] * parameters[i].getEstimate();\n+      }\n+      return v;\n+    }\n+\n+    @Override\n+    public double getPartial(EstimatedParameter parameter) {\n+      for (int i = 0; i < parameters.length; ++i) {\n+        if (parameters[i] == parameter) {\n+          return factors[i];\n+        }\n+      }\n+      return 0;\n+    }\n+\n+    public EstimatedParameter[] getParameters() {\n+      return parameters;\n+    }\n+\n+    private double[] factors;\n+    private EstimatedParameter[] parameters;\n+    private static final long serialVersionUID = -3922448707008868580L;\n+\n+  }\n+\n+  private static class Circle implements EstimationProblem {\n+\n+    public Circle(double cx, double cy) {\n+      this.cx = new EstimatedParameter(\"cx\", cx);\n+      this.cy = new EstimatedParameter(new EstimatedParameter(\"cy\", cy));\n+      points  = new ArrayList<PointModel>();\n+    }\n+\n+    public void addPoint(double px, double py) {\n+      points.add(new PointModel(this, px, py));\n+    }\n+\n+    public int getM() {\n+      return points.size();\n+    }\n+\n+    public WeightedMeasurement[] getMeasurements() {\n+      return points.toArray(new PointModel[points.size()]);\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      return new EstimatedParameter[] { cx, cy };\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return new EstimatedParameter[] { cx, cy };\n+    }\n+\n+    public double getPartialRadiusX() {\n+      double dRdX = 0;\n+      for (PointModel point : points) {\n+        dRdX += point.getPartialDiX();\n+      }\n+      return dRdX / points.size();\n+    }\n+\n+    public double getPartialRadiusY() {\n+      double dRdY = 0;\n+      for (PointModel point : points) {\n+        dRdY += point.getPartialDiY();\n+      }\n+      return dRdY / points.size();\n+    }\n+\n+   public double getRadius() {\n+      double r = 0;\n+      for (PointModel point : points) {\n+        r += point.getCenterDistance();\n+      }\n+      return r / points.size();\n+    }\n+\n+    public double getX() {\n+      return cx.getEstimate();\n+    }\n+\n+    public double getY() {\n+      return cy.getEstimate();\n+    }\n+\n+    private static class PointModel extends WeightedMeasurement {\n+\n+      public PointModel(Circle circle, double px, double py) {\n+        super(1.0, 0.0);\n+        this.px = px;\n+        this.py = py;\n+        this.circle = circle;\n+      }\n+\n+      @Override\n+      public double getPartial(EstimatedParameter parameter) {\n+        if (parameter == circle.cx) {\n+          return getPartialDiX() - circle.getPartialRadiusX();\n+        } else if (parameter == circle.cy) {\n+          return getPartialDiY() - circle.getPartialRadiusY();\n+        }\n+        return 0;\n+      }\n+\n+      public double getCenterDistance() {\n+        double dx = px - circle.cx.getEstimate();\n+        double dy = py - circle.cy.getEstimate();\n+        return Math.sqrt(dx * dx + dy * dy);\n+      }\n+\n+      public double getPartialDiX() {\n+        return (circle.cx.getEstimate() - px) / getCenterDistance();\n+      }\n+\n+      public double getPartialDiY() {\n+        return (circle.cy.getEstimate() - py) / getCenterDistance();\n+      }\n+\n+      @Override\n+      public double getTheoreticalValue() {\n+        return getCenterDistance() - circle.getRadius();\n+      }\n+\n+      private double px;\n+      private double py;\n+      private transient final Circle circle;\n+      private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    private EstimatedParameter cx;\n+    private EstimatedParameter cy;\n+    private ArrayList<PointModel> points;\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GaussNewtonEstimatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+@Deprecated\n+public class LevenbergMarquardtEstimatorTest\n+  extends TestCase {\n+\n+  public LevenbergMarquardtEstimatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testTrivial() throws EstimationException {\n+    LinearProblem problem =\n+      new LinearProblem(new LinearMeasurement[] {\n+        new LinearMeasurement(new double[] {2},\n+                              new EstimatedParameter[] {\n+                                 new EstimatedParameter(\"p0\", 0)\n+                              }, 3.0)\n+      });\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    try {\n+        estimator.guessParametersErrors(problem);\n+        fail(\"an exception should have been thrown\");\n+    } catch (EstimationException ee) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+    assertEquals(1.5,\n+                 problem.getUnboundParameters()[0].getEstimate(),\n+                 1.0e-10);\n+   }\n+\n+  public void testQRColumnsPermutation() throws EstimationException {\n+\n+    EstimatedParameter[] x = {\n+       new EstimatedParameter(\"p0\", 0), new EstimatedParameter(\"p1\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                            new EstimatedParameter[] { x[0], x[1] },\n+                            4.0),\n+      new LinearMeasurement(new double[] { 2.0 },\n+                            new EstimatedParameter[] { x[1] },\n+                            6.0),\n+      new LinearMeasurement(new double[] { 1.0, -2.0 },\n+                            new EstimatedParameter[] { x[0], x[1] },\n+                            1.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);\n+    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testNoDependency() throws EstimationException {\n+    EstimatedParameter[] p = new EstimatedParameter[] {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 0),\n+      new EstimatedParameter(\"p2\", 0),\n+      new EstimatedParameter(\"p3\", 0),\n+      new EstimatedParameter(\"p4\", 0),\n+      new EstimatedParameter(\"p5\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)\n+    });\n+  LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+  estimator.estimate(problem);\n+  assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+  for (int i = 0; i < p.length; ++i) {\n+    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);\n+  }\n+}\n+\n+  public void testOneSet() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 0),\n+       new EstimatedParameter(\"p1\", 0),\n+       new EstimatedParameter(\"p2\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0 },\n+                            new EstimatedParameter[] { p[0] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -1.0, 1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -1.0, 1.0 },\n+                            new EstimatedParameter[] { p[1], p[2] },\n+                            1.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testTwoSets() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 1),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 3),\n+      new EstimatedParameter(\"p4\", 4),\n+      new EstimatedParameter(\"p5\", 5)\n+    };\n+\n+    double epsilon = 1.0e-7;\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+\n+      // 4 elements sub-problem\n+      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[3] },\n+                            2.0),\n+      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },\n+                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                           -9.0),\n+      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            2.0),\n+      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },\n+                           new EstimatedParameter[] { p[1], p[2], p[3] },\n+                           2.0),\n+\n+      // 2 elements sub-problem\n+      new LinearMeasurement(new double[] { epsilon, 1.0 },\n+                            new EstimatedParameter[] { p[4], p[5] },\n+                            1.0 + epsilon * epsilon),\n+      new LinearMeasurement(new double[] {  1.0, 1.0 },\n+                            new EstimatedParameter[] { p[4], p[5] },\n+                            2.0)\n+\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);\n+    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);\n+    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testNonInversible() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 0),\n+       new EstimatedParameter(\"p1\", 0),\n+       new EstimatedParameter(\"p2\", 0)\n+    };\n+    LinearMeasurement[] m = new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2] },\n+                            1.0),\n+      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -3.0, -9.0 },\n+                            new EstimatedParameter[] { p[0], p[2] },\n+                            1.0)\n+    };\n+    LinearProblem problem = new LinearProblem(m);\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    double initialCost = estimator.getRMS(problem);\n+    estimator.estimate(problem);\n+    assertTrue(estimator.getRMS(problem) < initialCost);\n+    assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);\n+    try {\n+        estimator.getCovariances(problem);\n+        fail(\"an exception should have been thrown\");\n+    } catch (EstimationException ee) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+   double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])\n+                    + m[1].getResidual() * m[1].getPartial(p[0])\n+                    + m[2].getResidual() * m[2].getPartial(p[0]));\n+    double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])\n+                    + m[1].getResidual() * m[1].getPartial(p[1]));\n+    double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])\n+                    + m[1].getResidual() * m[1].getPartial(p[2])\n+                    + m[2].getResidual() * m[2].getPartial(p[2]));\n+    assertEquals(0, dJ0, 1.0e-10);\n+    assertEquals(0, dJ1, 1.0e-10);\n+    assertEquals(0, dJ2, 1.0e-10);\n+\n+  }\n+\n+  public void testIllConditioned() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 1),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 3)\n+    };\n+\n+    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            32.0),\n+      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            23.0),\n+      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            33.0),\n+      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            31.0)\n+    });\n+    LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();\n+    estimator1.estimate(problem1);\n+    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);\n+    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);\n+\n+    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            32.0),\n+      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            23.0),\n+      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },\n+                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            33.0),\n+      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },\n+                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            31.0)\n+    });\n+    LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();\n+    estimator2.estimate(problem2);\n+    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);\n+    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);\n+    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);\n+    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);\n+    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);\n+\n+  }\n+\n+  public void testMoreEstimatedParametersSimple() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 7),\n+       new EstimatedParameter(\"p1\", 6),\n+       new EstimatedParameter(\"p2\", 5),\n+       new EstimatedParameter(\"p3\", 4)\n+     };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 3.0, 2.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             7.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                             new EstimatedParameter[] { p[1], p[2], p[3] },\n+                             3.0),\n+      new LinearMeasurement(new double[] { 2.0, 1.0 },\n+                             new EstimatedParameter[] { p[0], p[2] },\n+                             5.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+\n+  }\n+\n+  public void testMoreEstimatedParametersUnsorted() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 2),\n+      new EstimatedParameter(\"p1\", 2),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 2),\n+      new EstimatedParameter(\"p4\", 2),\n+      new EstimatedParameter(\"p5\", 2)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                           new EstimatedParameter[] { p[0], p[1] },\n+                           3.0),\n+      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n+                           new EstimatedParameter[] { p[2], p[3], p[4] },\n+                           12.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                           new EstimatedParameter[] { p[4], p[5] },\n+                           -1.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                           new EstimatedParameter[] { p[3], p[2], p[5] },\n+                           7.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                           new EstimatedParameter[] { p[4], p[3] },\n+                           1.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(4.0, p[3].getEstimate(), 1.0e-10);\n+    assertEquals(5.0, p[4].getEstimate(), 1.0e-10);\n+    assertEquals(6.0, p[5].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testRedundantEquations() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 1),\n+      new EstimatedParameter(\"p1\", 1)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             3.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             1.0),\n+      new LinearMeasurement(new double[] { 1.0, 3.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             5.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(2.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testInconsistentEquations() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 1),\n+      new EstimatedParameter(\"p1\", 1)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            3.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { 1.0, 3.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            4.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertTrue(estimator.getRMS(problem) > 0.1);\n+\n+  }\n+\n+  public void testControlParameters() {\n+      Circle circle = new Circle(98.680, 47.345);\n+      circle.addPoint( 30.0,  68.0);\n+      circle.addPoint( 50.0,  -6.0);\n+      circle.addPoint(110.0, -20.0);\n+      circle.addPoint( 35.0,  15.0);\n+      circle.addPoint( 45.0,  97.0);\n+      checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);\n+      checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);\n+      checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);\n+      circle.addPoint(300, -300);\n+      checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);\n+  }\n+\n+  private void checkEstimate(EstimationProblem problem,\n+                             double initialStepBoundFactor, int maxCostEval,\n+                             double costRelativeTolerance, double parRelativeTolerance,\n+                             double orthoTolerance, boolean shouldFail) {\n+      try {\n+        LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+        estimator.setInitialStepBoundFactor(initialStepBoundFactor);\n+        estimator.setMaxCostEval(maxCostEval);\n+        estimator.setCostRelativeTolerance(costRelativeTolerance);\n+        estimator.setParRelativeTolerance(parRelativeTolerance);\n+        estimator.setOrthoTolerance(orthoTolerance);\n+        estimator.estimate(problem);\n+        assertTrue(! shouldFail);\n+      } catch (EstimationException ee) {\n+        assertTrue(shouldFail);\n+      } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+      }\n+    }\n+\n+  public void testCircleFitting() throws EstimationException {\n+      Circle circle = new Circle(98.680, 47.345);\n+      circle.addPoint( 30.0,  68.0);\n+      circle.addPoint( 50.0,  -6.0);\n+      circle.addPoint(110.0, -20.0);\n+      circle.addPoint( 35.0,  15.0);\n+      circle.addPoint( 45.0,  97.0);\n+      LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+      estimator.estimate(circle);\n+      assertTrue(estimator.getCostEvaluations() < 10);\n+      assertTrue(estimator.getJacobianEvaluations() < 10);\n+      double rms = estimator.getRMS(circle);\n+      assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);\n+      assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);\n+      assertEquals(96.07590211815305, circle.getX(),      1.0e-10);\n+      assertEquals(48.13516790438953, circle.getY(),      1.0e-10);\n+      double[][] cov = estimator.getCovariances(circle);\n+      assertEquals(1.839, cov[0][0], 0.001);\n+      assertEquals(0.731, cov[0][1], 0.001);\n+      assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+      assertEquals(0.786, cov[1][1], 0.001);\n+      double[] errors = estimator.guessParametersErrors(circle);\n+      assertEquals(1.384, errors[0], 0.001);\n+      assertEquals(0.905, errors[1], 0.001);\n+  \n+      // add perfect measurements and check errors are reduced\n+      double cx = circle.getX();\n+      double cy = circle.getY();\n+      double  r = circle.getRadius();\n+      for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n+          circle.addPoint(cx + r * Math.cos(d), cy + r * Math.sin(d));\n+      }\n+      estimator = new LevenbergMarquardtEstimator();\n+      estimator.estimate(circle);\n+      cov = estimator.getCovariances(circle);\n+      assertEquals(0.004, cov[0][0], 0.001);\n+      assertEquals(6.40e-7, cov[0][1], 1.0e-9);\n+      assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+      assertEquals(0.003, cov[1][1], 0.001);\n+      errors = estimator.guessParametersErrors(circle);\n+      assertEquals(0.004, errors[0], 0.001);\n+      assertEquals(0.004, errors[1], 0.001);\n+\n+  }\n+\n+  public void testCircleFittingBadInit() throws EstimationException {\n+    Circle circle = new Circle(-12, -12);\n+    double[][] points = new double[][] {\n+      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+    };\n+    for (int i = 0; i < points.length; ++i) {\n+      circle.addPoint(points[i][0], points[i][1]);\n+    }\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(circle);\n+    assertTrue(estimator.getCostEvaluations() < 15);\n+    assertTrue(estimator.getJacobianEvaluations() < 10);\n+    assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);\n+    assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);\n+    assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);\n+    assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);\n+  }\n+\n+  public void testMath199() {\n+      try {\n+          QuadraticProblem problem = new QuadraticProblem();\n+          problem.addPoint (0, -3.182591015485607, 0.0);\n+          problem.addPoint (1, -2.5581184967730577, 4.4E-323);\n+          problem.addPoint (2, -2.1488478161387325, 1.0);\n+          problem.addPoint (3, -1.9122489313410047, 4.4E-323);\n+          problem.addPoint (4, 1.7785661310051026, 0.0);\n+          new LevenbergMarquardtEstimator().estimate(problem);\n+          fail(\"an exception should have been thrown\");\n+      } catch (EstimationException ee) {\n+          // expected behavior\n+      }\n+\n+  }\n+\n+  private static class LinearProblem implements EstimationProblem {\n+\n+    public LinearProblem(LinearMeasurement[] measurements) {\n+      this.measurements = measurements;\n+    }\n+\n+    public WeightedMeasurement[] getMeasurements() {\n+      return measurements;\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return getAllParameters();\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();\n+      for (int i = 0; i < measurements.length; ++i) {\n+        EstimatedParameter[] parameters = measurements[i].getParameters();\n+        for (int j = 0; j < parameters.length; ++j) {\n+          set.add(parameters[j]);\n+        }\n+      }\n+      return set.toArray(new EstimatedParameter[set.size()]);\n+    }\n+  \n+    private LinearMeasurement[] measurements;\n+\n+  }\n+\n+  private static class LinearMeasurement extends WeightedMeasurement {\n+\n+    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,\n+                             double setPoint) {\n+      super(1.0, setPoint);\n+      this.factors = factors;\n+      this.parameters = parameters;\n+    }\n+\n+    @Override\n+    public double getTheoreticalValue() {\n+      double v = 0;\n+      for (int i = 0; i < factors.length; ++i) {\n+        v += factors[i] * parameters[i].getEstimate();\n+      }\n+      return v;\n+    }\n+\n+    @Override\n+    public double getPartial(EstimatedParameter parameter) {\n+      for (int i = 0; i < parameters.length; ++i) {\n+        if (parameters[i] == parameter) {\n+          return factors[i];\n+        }\n+      }\n+      return 0;\n+    }\n+\n+    public EstimatedParameter[] getParameters() {\n+      return parameters;\n+    }\n+\n+    private double[] factors;\n+    private EstimatedParameter[] parameters;\n+    private static final long serialVersionUID = -3922448707008868580L;\n+\n+  }\n+\n+  private static class Circle implements EstimationProblem {\n+\n+    public Circle(double cx, double cy) {\n+      this.cx = new EstimatedParameter(\"cx\", cx);\n+      this.cy = new EstimatedParameter(\"cy\", cy);\n+      points  = new ArrayList<PointModel>();\n+    }\n+\n+    public void addPoint(double px, double py) {\n+      points.add(new PointModel(this, px, py));\n+    }\n+\n+    public int getM() {\n+      return points.size();\n+    }\n+\n+    public WeightedMeasurement[] getMeasurements() {\n+      return points.toArray(new PointModel[points.size()]);\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      return new EstimatedParameter[] { cx, cy };\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return new EstimatedParameter[] { cx, cy };\n+    }\n+\n+    public double getPartialRadiusX() {\n+      double dRdX = 0;\n+      for (PointModel point : points) {\n+        dRdX += point.getPartialDiX();\n+      }\n+      return dRdX / points.size();\n+    }\n+\n+    public double getPartialRadiusY() {\n+      double dRdY = 0;\n+      for (PointModel point : points) {\n+        dRdY += point.getPartialDiY();\n+      }\n+      return dRdY / points.size();\n+    }\n+\n+   public double getRadius() {\n+      double r = 0;\n+      for (PointModel point : points) {\n+        r += point.getCenterDistance();\n+      }\n+      return r / points.size();\n+    }\n+\n+    public double getX() {\n+      return cx.getEstimate();\n+    }\n+\n+    public double getY() {\n+      return cy.getEstimate();\n+    }\n+\n+    private static class PointModel extends WeightedMeasurement {\n+\n+      public PointModel(Circle circle, double px, double py) {\n+        super(1.0, 0.0);\n+        this.px = px;\n+        this.py = py;\n+        this.circle = circle;\n+      }\n+\n+      @Override\n+      public double getPartial(EstimatedParameter parameter) {\n+        if (parameter == circle.cx) {\n+          return getPartialDiX() - circle.getPartialRadiusX();\n+        } else if (parameter == circle.cy) {\n+          return getPartialDiY() - circle.getPartialRadiusY();\n+        }\n+        return 0;\n+      }\n+\n+      public double getCenterDistance() {\n+        double dx = px - circle.cx.getEstimate();\n+        double dy = py - circle.cy.getEstimate();\n+        return Math.sqrt(dx * dx + dy * dy);\n+      }\n+\n+      public double getPartialDiX() {\n+        return (circle.cx.getEstimate() - px) / getCenterDistance();\n+      }\n+\n+      public double getPartialDiY() {\n+        return (circle.cy.getEstimate() - py) / getCenterDistance();\n+      }\n+\n+      @Override\n+      public double getTheoreticalValue() {\n+        return getCenterDistance() - circle.getRadius();\n+      }\n+\n+      private double px;\n+      private double py;\n+      private transient final Circle circle;\n+      private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    private EstimatedParameter cx;\n+    private EstimatedParameter cy;\n+    private ArrayList<PointModel> points;\n+\n+  }\n+\n+  private static class QuadraticProblem extends SimpleEstimationProblem {\n+\n+      private EstimatedParameter a;\n+      private EstimatedParameter b;\n+      private EstimatedParameter c;\n+\n+      public QuadraticProblem() {\n+          a = new EstimatedParameter(\"a\", 0.0);\n+          b = new EstimatedParameter(\"b\", 0.0);\n+          c = new EstimatedParameter(\"c\", 0.0);\n+          addParameter(a);\n+          addParameter(b);\n+          addParameter(c);\n+      }\n+\n+      public void addPoint(double x, double y, double w) {\n+          addMeasurement(new LocalMeasurement(this, x, y, w));\n+      }\n+\n+      public double theoreticalValue(double x) {\n+          return ( (a.getEstimate() * x + b.getEstimate() ) * x + c.getEstimate());\n+      }\n+\n+      private double partial(double x, EstimatedParameter parameter) {\n+          if (parameter == a) {\n+              return x * x;\n+          } else if (parameter == b) {\n+              return x;\n+          } else {\n+              return 1.0;\n+          }\n+      }\n+\n+      private static class LocalMeasurement extends WeightedMeasurement {\n+\n+        private static final long serialVersionUID = 1555043155023729130L;\n+        private final double x;\n+        private transient final QuadraticProblem pb;\n+\n+          // constructor\n+          public LocalMeasurement(QuadraticProblem pb, double x, double y, double w) {\n+              super(w, y);\n+              this.x = x;\n+              this.pb = pb;\n+          }\n+\n+          @Override\n+          public double getTheoreticalValue() {\n+              return pb.theoreticalValue(x);\n+          }\n+\n+          @Override\n+          public double getPartial(EstimatedParameter parameter) {\n+              return pb.partial(x, parameter);\n+          }\n+\n+      }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(LevenbergMarquardtEstimatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/estimation/MinpackTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.estimation.EstimatedParameter;\n+import org.apache.commons.math.estimation.EstimationException;\n+import org.apache.commons.math.estimation.EstimationProblem;\n+import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;\n+import org.apache.commons.math.estimation.WeightedMeasurement;\n+\n+import junit.framework.*;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+@Deprecated\n+public class MinpackTest\n+  extends TestCase {\n+\n+  public MinpackTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testMinpackLinearFullRank() {\n+    minpackTest(new LinearFullRankFunction(10, 5, 1.0,\n+                                           5.0, 2.23606797749979), false);\n+    minpackTest(new LinearFullRankFunction(50, 5, 1.0,\n+                                           8.06225774829855, 6.70820393249937), false);\n+  }\n+\n+  public void testMinpackLinearRank1() {\n+    minpackTest(new LinearRank1Function(10, 5, 1.0,\n+                                        291.521868819476, 1.4638501094228), false);\n+    minpackTest(new LinearRank1Function(50, 5, 1.0,\n+                                        3101.60039334535, 3.48263016573496), false);\n+  }\n+\n+  public void testMinpackLinearRank1ZeroColsAndRows() {\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);\n+  }\n+\n+  public void testMinpackRosenbrok() {\n+    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n+                                       Math.sqrt(24.2)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n+                                       Math.sqrt(1795769.0)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n+                                       11.0 * Math.sqrt(169000121.0)), false);\n+  }\n+\n+  public void testMinpackHelicalValley() {\n+    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },\n+                                          50.0), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },\n+                                          102.95630140987), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n+                                          991.261822123701), false);\n+  }\n+    \n+  public void testMinpackPowellSingular() {\n+    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n+                                           14.6628782986152), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },\n+                                           1270.9838708654), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n+                                           126887.903284750), false);\n+  }\n+    \n+  public void testMinpackFreudensteinRoth() {\n+    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n+                                             20.0124960961895, 6.99887517584575,\n+                                             new double[] {\n+                                               11.4124844654993,\n+                                               -0.896827913731509\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n+                                             12432.833948863, 6.9988751744895,\n+                                             new double[] {\n+                                               11.4130046614746,\n+                                               -0.896796038685958\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n+                                             11426454.595762, 6.99887517242903,\n+                                             new double[] {\n+                                               11.4127817857886,\n+                                               -0.89680510749204\n+                                             }), false);\n+  }\n+    \n+  public void testMinpackBard() {\n+    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n+                                 new double[] {\n+                                   0.0824105765758334,\n+                                   1.1330366534715,\n+                                   2.34369463894115\n+                                 }), false);\n+    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,\n+                                 new double[] {\n+                                   0.840666673818329,\n+                                   -158848033.259565,\n+                                   -164378671.653535\n+                                 }), false);\n+    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,\n+                                 new double[] {\n+                                   0.840666673867645,\n+                                   -158946167.205518,\n+                                   -164464906.857771\n+                                 }), false);\n+  }\n+    \n+  public void testMinpackKowalikOsborne() {\n+    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n+                                           0.0728915102882945,\n+                                           0.017535837721129,\n+                                           new double[] {\n+                                             0.192807810476249,\n+                                             0.191262653354071,\n+                                             0.123052801046931,\n+                                             0.136053221150517\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },\n+                                           2.97937007555202,\n+                                           0.032052192917937,\n+                                           new double[] {\n+                                             728675.473768287,\n+                                             -14.0758803129393,\n+                                             -32977797.7841797,\n+                                             -20571594.1977912\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },\n+                                           29.9590617016037,\n+                                           0.0175364017658228,\n+                                           new double[] {\n+                                             0.192948328597594,\n+                                             0.188053165007911,\n+                                             0.122430604321144,\n+                                             0.134575665392506\n+                                           }), true);\n+  }\n+    \n+  public void testMinpackMeyer() {\n+    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n+                                  41153.4665543031, 9.37794514651874,\n+                                  new double[] {\n+                                    0.00560963647102661,\n+                                    6181.34634628659,\n+                                    345.223634624144\n+                                  }), false);\n+    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },\n+                                  4168216.89130846, 792.917871779501,\n+                                  new double[] {\n+                                    1.42367074157994e-11,\n+                                    33695.7133432541,\n+                                    901.268527953801\n+                                  }), true);\n+  }\n+    \n+  public void testMinpackWatson() {\n+  \n+    minpackTest(new WatsonFunction(6, 0.0,\n+                                   5.47722557505166, 0.0478295939097601,\n+                                   new double[] {\n+                                     -0.0157249615083782, 1.01243488232965,\n+                                     -0.232991722387673,  1.26043101102818,\n+                                     -1.51373031394421,   0.99299727291842\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 10.0,\n+                                   6433.12578950026, 0.0478295939096951,\n+                                   new double[] {\n+                                     -0.0157251901386677, 1.01243485860105,\n+                                     -0.232991545843829,  1.26042932089163,\n+                                     -1.51372776706575,   0.99299573426328\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 100.0,\n+                                   674256.040605213, 0.047829593911544,\n+                                   new double[] {\n+                                    -0.0157247019712586, 1.01243490925658,\n+                                    -0.232991922761641,  1.26043292929555,\n+                                    -1.51373320452707,   0.99299901922322\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(9, 0.0,\n+                                   5.47722557505166, 0.00118311459212420,\n+                                   new double[] {\n+                                    -0.153070644166722e-4, 0.999789703934597,\n+                                     0.0147639634910978,   0.146342330145992,\n+                                     1.00082109454817,    -2.61773112070507,\n+                                     4.10440313943354,    -3.14361226236241,\n+                                     1.05262640378759\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 10.0,\n+                                   12088.127069307, 0.00118311459212513,\n+                                   new double[] {\n+                                   -0.153071334849279e-4, 0.999789703941234,\n+                                    0.0147639629786217,   0.146342334818836,\n+                                    1.00082107321386,    -2.61773107084722,\n+                                    4.10440307655564,    -3.14361222178686,\n+                                    1.05262639322589\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 100.0,\n+                                   1269109.29043834, 0.00118311459212384,\n+                                   new double[] {\n+                                    -0.153069523352176e-4, 0.999789703958371,\n+                                     0.0147639625185392,   0.146342341096326,\n+                                     1.00082104729164,    -2.61773101573645,\n+                                     4.10440301427286,    -3.14361218602503,\n+                                     1.05262638516774\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(12, 0.0,\n+                                   5.47722557505166, 0.217310402535861e-4,\n+                                   new double[] {\n+                                    -0.660266001396382e-8, 1.00000164411833,\n+                                    -0.000563932146980154, 0.347820540050756,\n+                                    -0.156731500244233,    1.05281515825593,\n+                                    -3.24727109519451,     7.2884347837505,\n+                                   -10.271848098614,       9.07411353715783,\n+                                    -4.54137541918194,     1.01201187975044\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 10.0,\n+                                   19220.7589790951, 0.217310402518509e-4,\n+                                   new double[] {\n+                                    -0.663710223017410e-8, 1.00000164411787,\n+                                    -0.000563932208347327, 0.347820540486998,\n+                                    -0.156731503955652,    1.05281517654573,\n+                                    -3.2472711515214,      7.28843489430665,\n+                                   -10.2718482369638,      9.07411364383733,\n+                                    -4.54137546533666,     1.01201188830857\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 100.0,\n+                                   2018918.04462367, 0.217310402539845e-4,\n+                                   new double[] {\n+                                    -0.663806046485249e-8, 1.00000164411786,\n+                                    -0.000563932210324959, 0.347820540503588,\n+                                    -0.156731504091375,    1.05281517718031,\n+                                    -3.24727115337025,     7.28843489775302,\n+                                   -10.2718482410813,      9.07411364688464,\n+                                    -4.54137546660822,     1.0120118885369\n+                                   }), false);\n+\n+  }\n+    \n+  public void testMinpackBox3Dimensional() {\n+    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n+                                            32.1115837449572), false);\n+  }\n+    \n+  public void testMinpackJennrichSampson() {\n+    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n+                                            64.5856498144943, 11.1517793413499,\n+                                            new double[] {\n+                                             0.257819926636811, 0.257829976764542\n+                                            }), false);\n+  }\n+\n+  public void testMinpackBrownDennis() {\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 25.0, 5.0, -5.0, -1.0 },\n+                                        2815.43839161816, 292.954288244866,\n+                                        new double[] {\n+                                         -11.59125141003, 13.2024883984741,\n+                                         -0.403574643314272, 0.236736269844604\n+                                        }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 250.0, 50.0, -50.0, -10.0 },\n+                                        555073.354173069, 292.954270581415,\n+                                        new double[] {\n+                                         -11.5959274272203, 13.2041866926242,\n+                                         -0.403417362841545, 0.236771143410386\n+                                       }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },\n+                                        61211252.2338581, 292.954306151134,\n+                                        new double[] {\n+                                         -11.5902596937374, 13.2020628854665,\n+                                         -0.403688070279258, 0.236665033746463\n+                                        }), false);\n+  }\n+    \n+  public void testMinpackChebyquad() {\n+    minpackTest(new ChebyquadFunction(1, 8, 1.0,\n+                                      1.88623796907732, 1.88623796907732,\n+                                      new double[] { 0.5 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 10.0,\n+                                      5383344372.34005, 1.88424820499951,\n+                                      new double[] { 0.9817314924684 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 100.0,\n+                                      0.118088726698392e19, 1.88424820499347,\n+                                      new double[] { 0.9817314852934 }), false);\n+    minpackTest(new ChebyquadFunction(8, 8, 1.0,\n+                                      0.196513862833975, 0.0593032355046727,\n+                                      new double[] {\n+                                        0.0431536648587336, 0.193091637843267,\n+                                        0.266328593812698,  0.499999334628884,\n+                                        0.500000665371116,  0.733671406187302,\n+                                        0.806908362156733,  0.956846335141266\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(9, 9, 1.0,\n+                                      0.16994993465202, 0.0,\n+                                      new double[] {\n+                                        0.0442053461357828, 0.199490672309881,\n+                                        0.23561910847106,   0.416046907892598,\n+                                        0.5,                0.583953092107402,\n+                                        0.764380891528940,  0.800509327690119,\n+                                        0.955794653864217\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(10, 10, 1.0,\n+                                      0.183747831178711, 0.0806471004038253,\n+                                      new double[] {\n+                                        0.0596202671753563, 0.166708783805937,\n+                                        0.239171018813509,  0.398885290346268,\n+                                        0.398883667870681,  0.601116332129320,\n+                                        0.60111470965373,   0.760828981186491,\n+                                        0.833291216194063,  0.940379732824644\n+                                      }), false);\n+  }\n+    \n+  public void testMinpackBrownAlmostLinear() {\n+    minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n+                                              16.5302162063499, 0.0,\n+                                              new double[] {\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 1.20569696650138\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(10, 5.0,\n+                                              9765624.00089211, 0.0,\n+                                              new double[] {\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 1.20569696650135\n+                                              }), false);  \n+    minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n+                                              0.9765625e17, 0.0,\n+                                              new double[] {\n+                                                1.0, 1.0, 1.0, 1.0, 1.0,\n+                                                1.0, 1.0, 1.0, 1.0, 1.0\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(30, 0.5,\n+                                              83.476044467848, 0.0,\n+                                              new double[] {\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 1.06737350671578\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(40, 0.5,\n+                                              128.026364472323, 0.0,\n+                                              new double[] {\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                0.999999999999121\n+                                              }), false);\n+    }\n+    \n+  public void testMinpackOsborne1() {\n+      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n+                                       0.937564021037838, 0.00739249260904843,\n+                                       new double[] {\n+                                         0.375410049244025, 1.93584654543108,\n+                                        -1.46468676748716, 0.0128675339110439,\n+                                         0.0221227011813076\n+                                       }), false);\n+    }\n+    \n+  public void testMinpackOsborne2() {\n+      \n+    minpackTest(new Osborne2Function(new double[] {\n+                                       1.3, 0.65, 0.65, 0.7, 0.6,\n+                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n+                                     },\n+                                     1.44686540984712, 0.20034404483314,\n+                                     new double[] {\n+                                       1.30997663810096,  0.43155248076,\n+                                       0.633661261602859, 0.599428560991695,\n+                                       0.754179768272449, 0.904300082378518,\n+                                       1.36579949521007, 4.82373199748107,\n+                                       2.39868475104871, 4.56887554791452,\n+                                       5.67534206273052\n+                                     }), false);\n+  }\n+\n+  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.setMaxCostEval(100 * (function.getN() + 1));\n+    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setOrthoTolerance(2.22044604926e-16);\n+    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));\n+    try {\n+      estimator.estimate(function);\n+      assertFalse(exceptionExpected);\n+    } catch (EstimationException lsse) {\n+      assertTrue(exceptionExpected);\n+    }\n+    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));\n+    assertTrue(function.checkTheoreticalMinParams());\n+  }\n+\n+  private static abstract class MinpackFunction implements EstimationProblem {\n+ \n+    protected MinpackFunction(int m,\n+                              double[] startParams,\n+                              double   theoreticalStartCost,\n+                              double   theoreticalMinCost,\n+                              double[] theoreticalMinParams) {\n+      this.m = m;\n+      this.n = startParams.length;\n+      parameters = new EstimatedParameter[n];\n+      for (int i = 0; i < n; ++i) {\n+        parameters[i] = new EstimatedParameter(\"p\" + i, startParams[i]);\n+      }\n+      this.theoreticalStartCost = theoreticalStartCost;\n+      this.theoreticalMinCost   = theoreticalMinCost;\n+      this.theoreticalMinParams = theoreticalMinParams;\n+      this.costAccuracy         = 1.0e-8;\n+      this.paramsAccuracy       = 1.0e-5;\n+    }\n+\n+    protected static double[] buildArray(int n, double x) {\n+      double[] array = new double[n];\n+      Arrays.fill(array, x);\n+      return array;\n+    }\n+\n+    protected void setCostAccuracy(double costAccuracy) {\n+      this.costAccuracy = costAccuracy;\n+    }\n+\n+    protected void setParamsAccuracy(double paramsAccuracy) {\n+      this.paramsAccuracy = paramsAccuracy;\n+    }\n+\n+    public int getN() {\n+      return parameters.length;\n+    }\n+\n+    public boolean checkTheoreticalStartCost(double rms) {\n+      double threshold = costAccuracy * (1.0 + theoreticalStartCost);\n+      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n+    }\n+\n+    public boolean checkTheoreticalMinCost(double rms) {\n+      double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n+     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n+    }\n+\n+    public boolean checkTheoreticalMinParams() {\n+      if (theoreticalMinParams != null) {\n+        for (int i = 0; i < theoreticalMinParams.length; ++i) {\n+          double mi = theoreticalMinParams[i];\n+          double vi = parameters[i].getEstimate();\n+          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n+            return false;\n+          }\n+        }\n+      }\n+      return true;\n+    }\n+ \n+    public WeightedMeasurement[] getMeasurements() {\n+      WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n+      for (int i = 0; i < m; ++i) {\n+        measurements[i] = new MinpackMeasurement(this, i);\n+      }\n+      return measurements;\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return parameters;\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      return parameters;\n+    }\n+\n+    protected abstract double[][] getJacobian();\n+\n+    protected abstract double[] getResiduals();\n+\n+    private static class MinpackMeasurement extends WeightedMeasurement {\n+\n+      public MinpackMeasurement(MinpackFunction f, int index) {\n+        super(1.0, 0.0);\n+        this.index = index;\n+        this.f = f;\n+      }\n+\n+      @Override\n+      public double getTheoreticalValue() {\n+        // this is obviously NOT efficient as we recompute the whole vector\n+        // each time we need only one element, but it is only for test\n+        // purposes and is simpler to check.\n+        // This implementation should NOT be taken as an example, it is ugly!\n+        return f.getResiduals()[index];\n+      }\n+\n+      @Override\n+      public double getPartial(EstimatedParameter parameter) {\n+        // this is obviously NOT efficient as we recompute the whole jacobian\n+        // each time we need only one element, but it is only for test\n+        // purposes and is simpler to check.\n+        // This implementation should NOT be taken as an example, it is ugly!\n+        for (int j = 0; j < f.n; ++j) {\n+          if (parameter == f.parameters[j]) {\n+            return f.getJacobian()[index][j];\n+          }\n+        }\n+        return 0;\n+      }\n+\n+      private int index;\n+      private transient final MinpackFunction f;\n+      private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    protected int                  n;\n+    protected int                  m;\n+    protected EstimatedParameter[] parameters;\n+    protected double               theoreticalStartCost;\n+    protected double               theoreticalMinCost;\n+    protected double[]             theoreticalMinParams;\n+    protected double               costAccuracy;\n+    protected double               paramsAccuracy;\n+\n+  }\n+\n+  private static class LinearFullRankFunction extends MinpackFunction {\n+\n+    public LinearFullRankFunction(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalStartCost,\n+            theoreticalMinCost, buildArray(n, -1.0));\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double t = 2.0 / m;\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i == j) ? (1 - t) : -t;\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += parameters[i].getEstimate();\n+      }\n+      double t  = 1 + 2 * sum / m;\n+      double[] f = new double[m];\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = parameters[i].getEstimate() - t;\n+      }\n+      Arrays.fill(f, n, m, -t);\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1Function extends MinpackFunction {\n+\n+    public LinearRank1Function(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i + 1) * (j + 1);\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += (i + 1) * parameters[i].getEstimate();\n+      }\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = (i + 1) * sum - 1;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {\n+\n+    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n+      super(m, buildArray(n, x0),\n+            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n+            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n+            null);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        jacobian[i][0] = 0;\n+        for (int j = 1; j < (n - 1); ++j) {\n+          if (i == 0) {\n+            jacobian[i][j] = 0;\n+          } else if (i != (m - 1)) {\n+            jacobian[i][j] = i * (j + 1);\n+          } else {\n+            jacobian[i][j] = 0;\n+          }\n+        }\n+        jacobian[i][n - 1] = 0;\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 1; i < (n - 1); ++i) {\n+        sum += (i + 1) * parameters[i].getEstimate();\n+      }\n+      for (int i = 0; i < (m - 1); ++i) {\n+        f[i] = i * sum - 1;\n+      }\n+      f[m - 1] = -1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class RosenbrockFunction extends MinpackFunction {\n+\n+    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {\n+      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n+    }\n+\n+  }\n+\n+  private static class HelicalValleyFunction extends MinpackFunction {\n+\n+    public HelicalValleyFunction(double[] startParams,\n+                                 double theoreticalStartCost) {\n+      super(3, startParams, theoreticalStartCost, 0.0,\n+            new double[] { 1.0, 0.0, 0.0 });\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double tmpSquare = x1 * x1 + x2 * x2;\n+      double tmp1 = twoPi * tmpSquare;\n+      double tmp2 = Math.sqrt(tmpSquare);\n+      return new double[][] {\n+        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n+        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n+        { 0, 0, 1 }\n+      };\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double tmp1;\n+      if (x1 == 0) {\n+        tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n+      } else {\n+        tmp1 = Math.atan(x2 / x1) / twoPi;\n+        if (x1 < 0) {\n+          tmp1 += 0.5;\n+        }\n+      }\n+      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n+      return new double[] {\n+        10.0 * (x3 - 10 * tmp1),\n+        10.0 * (tmp2 - 1),\n+        x3\n+      };\n+    }\n+\n+    private static final double twoPi = 2.0 * Math.PI;\n+\n+  }\n+\n+  private static class PowellSingularFunction extends MinpackFunction {\n+\n+    public PowellSingularFunction(double[] startParams,\n+                                  double theoreticalStartCost) {\n+      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      return new double[][] {\n+        { 1, 10, 0, 0 },\n+        { 0, 0, sqrt5, -sqrt5 },\n+        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },\n+        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }\n+      };\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      return new double[] {\n+        x1 + 10 * x2,\n+        sqrt5 * (x3 - x4),\n+        (x2 - 2 * x3) * (x2 - 2 * x3),\n+        sqrt10 * (x1 - x4) * (x1 - x4)\n+      };\n+    }\n+\n+    private static final double sqrt5  = Math.sqrt( 5.0);\n+    private static final double sqrt10 = Math.sqrt(10.0);\n+\n+  }\n+\n+  private static class FreudensteinRothFunction extends MinpackFunction {\n+\n+    public FreudensteinRothFunction(double[] startParams,\n+                                    double theoreticalStartCost,\n+                                    double theoreticalMinCost,\n+                                    double[] theoreticalMinParams) {\n+      super(2, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double x2 = parameters[1].getEstimate();\n+      return new double[][] {\n+        { 1, x2 * (10 - 3 * x2) -  2 },\n+        { 1, x2 * ( 2 + 3 * x2) - 14, }\n+      };\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      return new double[] {\n+       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,\n+       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2\n+      };\n+    }\n+\n+  }\n+\n+  private static class BardFunction extends MinpackFunction {\n+\n+    public BardFunction(double x0,\n+                        double theoreticalStartCost,\n+                        double theoreticalMinCost,\n+                        double[] theoreticalMinParams) {\n+      super(15, buildArray(3, x0), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i  + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        double tmp4 = x2 * tmp2 + x3 * tmp3;\n+        tmp4 *= tmp4;\n+        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.14, 0.18, 0.22, 0.25, 0.29,\n+      0.32, 0.35, 0.39, 0.37, 0.58,\n+      0.73, 0.96, 1.34, 2.10, 4.39\n+    };\n+\n+  }\n+\n+  private static class KowalikOsborneFunction extends MinpackFunction {\n+\n+    public KowalikOsborneFunction(double[] startParams,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost,\n+                                  double[] theoreticalMinParams) {\n+      super(11, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+      if (theoreticalStartCost > 20.0) {\n+        setCostAccuracy(2.0e-4);\n+        setParamsAccuracy(5.0e-3);\n+      }\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = v[i] * (v[i] + x3) + x4;\n+        double j1  = -v[i] * (v[i] + x2) / tmp;\n+        double j2  = -v[i] * x1 / tmp;\n+        double j3  = j1 * j2;\n+        double j4  = j3 / v[i];\n+        jacobian[i] = new double[] { j1, j2, j3, j4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] v = {\n+      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625\n+    };\n+\n+    private static final double[] y = {\n+      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,\n+      0.0456, 0.0342, 0.0323, 0.0235, 0.0246\n+    };\n+\n+  }\n+\n+  private static class MeyerFunction extends MinpackFunction {\n+\n+    public MeyerFunction(double[] startParams,\n+                         double theoreticalStartCost,\n+                         double theoreticalMinCost,\n+                         double[] theoreticalMinParams) {\n+      super(16, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+      if (theoreticalStartCost > 1.0e6) {\n+        setCostAccuracy(7.0e-3);\n+        setParamsAccuracy(2.0e-2);\n+      }\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 5.0 * (i + 1) + 45.0 + x3;\n+        double tmp1 = x2 / temp;\n+        double tmp2 = Math.exp(tmp1);\n+        double tmp3 = x1 * tmp2 / temp;\n+        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n+      }\n+     return f;\n+    }\n+\n+    private static final double[] y = {\n+      34780.0, 28610.0, 23650.0, 19630.0,\n+      16370.0, 13720.0, 11540.0,  9744.0,\n+       8261.0,  7030.0,  6005.0,  5147.0,\n+       4427.0,  3820.0,  3307.0,  2872.0                  \n+    };\n+\n+  }\n+\n+  private static class WatsonFunction extends MinpackFunction {\n+\n+    public WatsonFunction(int n, double x0,\n+                          double theoreticalStartCost,\n+                          double theoreticalMinCost,\n+                          double[] theoreticalMinParams) {\n+      super(31, buildArray(n, x0), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+\n+      double[][] jacobian = new double[m][];\n+\n+      for (int i = 0; i < (m - 2); ++i) {\n+        double div = (i + 1) / 29.0;\n+        double s2  = 0.0;\n+        double dx  = 1.0;\n+        for (int j = 0; j < n; ++j) {\n+          s2 += dx * parameters[j].getEstimate();\n+          dx *= div;\n+        }\n+        double temp= 2 * div * s2;\n+        dx = 1.0 / div;\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = dx * (j - temp);\n+          dx *= div;\n+        }\n+      }\n+\n+      jacobian[m - 2]    = new double[n];\n+      jacobian[m - 2][0] = 1;\n+\n+      jacobian[m - 1]   = new double[n];\n+      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();\n+      jacobian[m - 1][1]= 1;\n+\n+      return jacobian;\n+\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+     double[] f = new double[m];\n+     for (int i = 0; i < (m - 2); ++i) {\n+       double div = (i + 1) / 29.0;\n+       double s1 = 0;\n+       double dx = 1;\n+       for (int j = 1; j < n; ++j) {\n+         s1 += j * dx * parameters[j].getEstimate();\n+         dx *= div;\n+       }\n+       double s2 =0;\n+       dx =1;\n+       for (int j = 0; j < n; ++j) {\n+         s2 += dx * parameters[j].getEstimate();\n+         dx *= div;\n+       }\n+       f[i] = s1 - s2 * s2 - 1;\n+     }\n+\n+     double x1 = parameters[0].getEstimate();\n+     double x2 = parameters[1].getEstimate();\n+     f[m - 2] = x1;\n+     f[m - 1] = x2 - x1 * x1 - 1;\n+\n+     return f;\n+\n+    }\n+\n+  }\n+\n+  private static class Box3DimensionalFunction extends MinpackFunction {\n+\n+    public Box3DimensionalFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost) {\n+      super(m, startParams, theoreticalStartCost,\n+            0.0, new double[] { 1.0, 10.0, 1.0 });\n+   }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        jacobian[i] = new double[] {\n+          -tmp * Math.exp(-tmp * x1),\n+           tmp * Math.exp(-tmp * x2),\n+          Math.exp(-i - 1) - Math.exp(-tmp)\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n+             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class JennrichSampsonFunction extends MinpackFunction {\n+\n+    public JennrichSampsonFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost,\n+                                   double theoreticalMinCost,\n+                                   double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double t = i + 1;\n+        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i + 1;\n+        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class BrownDennisFunction extends MinpackFunction {\n+\n+    public BrownDennisFunction(int m, double[] startParams,\n+                               double theoreticalStartCost,\n+                               double theoreticalMinCost,\n+                               double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double ti   = Math.sin(temp);\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n+        jacobian[i] = new double[] {\n+          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n+        f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class ChebyquadFunction extends MinpackFunction {\n+\n+    private static double[] buildChebyquadArray(int n, double factor) {\n+      double[] array = new double[n];\n+      double inv = factor / (n + 1);\n+      for (int i = 0; i < n; ++i) {\n+        array[i] = (i + 1) * inv;\n+      }\n+      return array;\n+    }\n+\n+    public ChebyquadFunction(int n, int m, double factor,\n+                             double theoreticalStartCost,\n+                             double theoreticalMinCost,\n+                             double[] theoreticalMinParams) {\n+      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double dx = 1.0 / n;\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double temp = 2 * tmp2;\n+        double tmp3 = 0;\n+        double tmp4 = 2;\n+        for (int i = 0; i < m; ++i) {\n+          jacobian[i][j] = dx * tmp4;\n+          double ti = 4 * tmp2 + temp * tmp4 - tmp3;\n+          tmp3 = tmp4;\n+          tmp4 = ti;\n+          ti   = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+\n+      double[] f = new double[m];\n+\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double temp = 2 * tmp2;\n+        for (int i = 0; i < m; ++i) {\n+          f[i] += tmp2;\n+          double ti = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      double dx = 1.0 / n;\n+      boolean iev = false;\n+      for (int i = 0; i < m; ++i) {\n+        f[i] *= dx;\n+        if (iev) {\n+          f[i] += 1.0 / (i * (i + 2));\n+        }\n+        iev = ! iev;\n+      }\n+\n+      return f;\n+\n+    }\n+\n+  }\n+\n+  private static class BrownAlmostLinearFunction extends MinpackFunction {\n+\n+    public BrownAlmostLinearFunction(int m, double factor,\n+                                     double theoreticalStartCost,\n+                                     double theoreticalMinCost,\n+                                     double[] theoreticalMinParams) {\n+      super(m, buildArray(m, factor), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        prod *= parameters[j].getEstimate();\n+        for (int i = 0; i < n; ++i) {\n+          jacobian[i][j] = 1;\n+        }\n+        jacobian[j][j] = 2;\n+      }\n+\n+      for (int j = 0; j < n; ++j) {\n+        EstimatedParameter vj = parameters[j];\n+        double temp = vj.getEstimate();\n+        if (temp == 0) {\n+          temp = 1;\n+          prod = 1;\n+          for (int k = 0; k < n; ++k) {\n+            if (k != j) {\n+              prod *= parameters[k].getEstimate();\n+            }\n+          }\n+        }\n+        jacobian[n - 1][j] = prod / temp;\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum  = -(n + 1);\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        sum  += parameters[j].getEstimate();\n+        prod *= parameters[j].getEstimate();\n+      }\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = parameters[i].getEstimate() + sum;\n+      }\n+      f[n - 1] = prod - 1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class Osborne1Function extends MinpackFunction {\n+\n+    public Osborne1Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(33, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double   x5 = parameters[4].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        jacobian[i] = new double[] {\n+          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double x5 = parameters[4].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,\n+      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,\n+      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406\n+    };\n+\n+  }\n+\n+  private static class Osborne2Function extends MinpackFunction {\n+\n+    public Osborne2Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(65, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    @Override\n+    protected double[][] getJacobian() {\n+      double   x01 = parameters[0].getEstimate();\n+      double   x02 = parameters[1].getEstimate();\n+      double   x03 = parameters[2].getEstimate();\n+      double   x04 = parameters[3].getEstimate();\n+      double   x05 = parameters[4].getEstimate();\n+      double   x06 = parameters[5].getEstimate();\n+      double   x07 = parameters[6].getEstimate();\n+      double   x08 = parameters[7].getEstimate();\n+      double   x09 = parameters[8].getEstimate();\n+      double   x10 = parameters[9].getEstimate();\n+      double   x11 = parameters[10].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        jacobian[i] = new double[] {\n+          -tmp1,\n+          -tmp2,\n+          -tmp3,\n+          -tmp4,\n+          temp * x01 * tmp1,\n+          x02 * (temp - x09) * (temp - x09) * tmp2,\n+          x03 * (temp - x10) * (temp - x10) * tmp3,\n+          x04 * (temp - x11) * (temp - x11) * tmp4,\n+          -2 * x02 * x06 * (temp - x09) * tmp2,\n+          -2 * x03 * x07 * (temp - x10) * tmp3,\n+          -2 * x04 * x08 * (temp - x11) * tmp4\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    protected double[] getResiduals() {\n+      double x01 = parameters[0].getEstimate();\n+      double x02 = parameters[1].getEstimate();\n+      double x03 = parameters[2].getEstimate();\n+      double x04 = parameters[3].getEstimate();\n+      double x05 = parameters[4].getEstimate();\n+      double x06 = parameters[5].getEstimate();\n+      double x07 = parameters[6].getEstimate();\n+      double x08 = parameters[7].getEstimate();\n+      double x09 = parameters[8].getEstimate();\n+      double x10 = parameters[9].getEstimate();\n+      double x11 = parameters[10].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      1.366, 1.191, 1.112, 1.013, 0.991,\n+      0.885, 0.831, 0.847, 0.786, 0.725,\n+      0.746, 0.679, 0.608, 0.655, 0.616,\n+      0.606, 0.602, 0.626, 0.651, 0.724,\n+      0.649, 0.649, 0.694, 0.644, 0.624,\n+      0.661, 0.612, 0.558, 0.533, 0.495,\n+      0.500, 0.423, 0.395, 0.375, 0.372,\n+      0.391, 0.396, 0.405, 0.428, 0.429,\n+      0.523, 0.562, 0.607, 0.653, 0.672,\n+      0.708, 0.633, 0.668, 0.645, 0.632,\n+      0.591, 0.559, 0.597, 0.625, 0.739,\n+      0.710, 0.729, 0.720, 0.636, 0.581,\n+      0.428, 0.292, 0.162, 0.098, 0.054\n+    };\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MinpackTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/estimation/WeightedMeasurementTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import org.apache.commons.math.estimation.EstimatedParameter;\n+import org.apache.commons.math.estimation.WeightedMeasurement;\n+\n+import junit.framework.*;\n+\n+@Deprecated\n+public class WeightedMeasurementTest\n+  extends TestCase {\n+\n+  public WeightedMeasurementTest(String name) {\n+    super(name);\n+    p1 = null;\n+    p2 = null;\n+  }\n+\n+  public void testConstruction() {\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);\n+    checkValue(m.getWeight(), 3.0);\n+    checkValue(m.getMeasuredValue(), theoretical() + 0.1);\n+  }\n+\n+  public void testIgnored() {\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);\n+    assertTrue(!m.isIgnored());\n+    m.setIgnored(true);\n+    assertTrue(m.isIgnored());\n+    m.setIgnored(false);\n+    assertTrue(!m.isIgnored());\n+  }\n+\n+  public void testTheory() {\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);\n+    checkValue(m.getTheoreticalValue(), theoretical());\n+    checkValue(m.getResidual(), 0.1);\n+\n+    double oldP1 = p1.getEstimate();\n+    p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));\n+    checkValue(m.getResidual(), 0.0);\n+    p1.setEstimate(oldP1);\n+    checkValue(m.getResidual(), 0.1);\n+\n+    double oldP2 = p2.getEstimate();\n+    p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));\n+    checkValue(m.getResidual(), 0.0);\n+    p2.setEstimate(oldP2);\n+    checkValue(m.getResidual(), 0.1);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(WeightedMeasurementTest.class);\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    p1 = new EstimatedParameter(\"p1\", 1.0);\n+    p2 = new EstimatedParameter(\"p2\", 2.0);\n+  }\n+\n+  @Override\n+  public void tearDown() {\n+    p1 = null;\n+    p2 = null;\n+  }\n+\n+  private void checkValue(double value, double expected) {\n+   assertTrue(Math.abs(value - expected) < 1.0e-10);\n+  }\n+\n+  private double theoretical() {\n+   return 3 * p1.getEstimate() - p2.getEstimate();\n+  }\n+\n+  private double partial(EstimatedParameter p) {\n+    if (p == p1) {\n+      return 3.0;\n+    } else if (p == p2) {\n+      return -1.0;\n+    } else {\n+      return 0.0;\n+    }\n+  }\n+\n+  private static class MyMeasurement\n+    extends WeightedMeasurement {\n+\n+    public MyMeasurement(double weight, double measuredValue,\n+                         WeightedMeasurementTest testInstance) {\n+      super(weight, measuredValue);\n+      this.testInstance = testInstance;\n+    }\n+\n+    @Override\n+    public double getTheoreticalValue() {\n+      return testInstance.theoretical();\n+    }\n+\n+    @Override\n+    public double getPartial(EstimatedParameter p) {\n+      return testInstance.partial(p);\n+    }\n+\n+    private transient WeightedMeasurementTest testInstance;\n+\n+    private static final long serialVersionUID = -246712922500792332L;\n+\n+  }\n+\n+  private EstimatedParameter p1;\n+  private EstimatedParameter p2;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Test;\n+\n+public class BigFractionFieldTest {\n+\n+    @Test\n+    public void testZero() {\n+        assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero());\n+    }\n+\n+    @Test\n+    public void testOne() {\n+        assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne());\n+    }\n+\n+    @Test\n+    public void testSerial() {\n+        // deserializing the singleton should give the singleton itself back\n+        BigFractionField field = BigFractionField.getInstance();\n+        assertTrue(field == TestUtils.serializeAndRecover(field));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+public class BigFractionFormatTest extends TestCase {\n+ \n+    BigFractionFormat properFormat = null;\n+    BigFractionFormat improperFormat = null;\n+\n+    protected Locale getLocale() {\n+        return Locale.getDefault();\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        properFormat = BigFractionFormat.getProperInstance(getLocale());\n+        improperFormat = BigFractionFormat.getImproperInstance(getLocale());\n+    }\n+   \n+    public void testFormat() {\n+        BigFraction c = new BigFraction(1, 2);\n+        String expected = \"1 / 2\";\n+        \n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatNegative() {\n+        BigFraction c = new BigFraction(-1, 2);\n+        String expected = \"-1 / 2\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatZero() {\n+        BigFraction c = new BigFraction(0, 1);\n+        String expected = \"0 / 1\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testFormatImproper() {\n+        BigFraction c = new BigFraction(5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"5 / 3\", actual);\n+    }\n+    \n+    public void testFormatImproperNegative() {\n+        BigFraction c = new BigFraction(-5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"-5 / 3\", actual);\n+    }\n+    \n+    public void testParse() {\n+        String source = \"1 / 2\";\n+\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.ONE, c.getNumerator());\n+            assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.ONE, c.getNumerator());\n+            assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInteger() {\n+        String source = \"10\";\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.TEN, c.getNumerator());\n+            assertEquals(BigInteger.ONE, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        try {\n+            BigFraction c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.TEN, c.getNumerator());\n+            assertEquals(BigInteger.ONE, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInvalid() {\n+        String source = \"a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseInvalidDenominator() {\n+        String source = \"10 / a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseNegative() {\n+\n+        try {\n+            String source = \"-1 / 2\";\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+\n+            source = \"1 / -2\";\n+            c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseProper() {\n+        String source = \"1 2 / 3\";\n+\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(5, c.getNumeratorAsInt());\n+            assertEquals(3, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperNegative() {\n+        String source = \"-1 2 / 3\";\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-5, c.getNumeratorAsInt());\n+            assertEquals(3, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperInvalidMinus() {\n+        String source = \"2 -2 / 3\";\n+        try {\n+            properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+        source = \"2 2 / -3\";\n+        try {\n+            properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testParseBig() throws ParseException {\n+        BigFraction f1 =\n+            improperFormat.parse(\"167213075789791382630275400487886041651764456874403\" +\n+                                 \" / \" +\n+                                 \"53225575123090058458126718248444563466137046489291\");\n+        assertEquals(Math.PI, f1.doubleValue(), 0.0);\n+        BigFraction f2 =\n+            properFormat.parse(\"3 \" +\n+                               \"7536350420521207255895245742552351253353317406530\" +\n+                               \" / \" +\n+                               \"53225575123090058458126718248444563466137046489291\");\n+        assertEquals(Math.PI, f2.doubleValue(), 0.0);\n+        assertEquals(f1, f2);\n+        BigDecimal pi =\n+            new BigDecimal(\"3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068\");\n+        assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));\n+    }\n+    \n+    public void testNumeratorFormat() {\n+        NumberFormat old = properFormat.getNumeratorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, properFormat.getNumeratorFormat());\n+        properFormat.setNumeratorFormat(old);\n+\n+        old = improperFormat.getNumeratorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, improperFormat.getNumeratorFormat());\n+        improperFormat.setNumeratorFormat(old);\n+    }\n+    \n+    public void testDenominatorFormat() {\n+        NumberFormat old = properFormat.getDenominatorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, properFormat.getDenominatorFormat());\n+        properFormat.setDenominatorFormat(old);\n+\n+        old = improperFormat.getDenominatorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, improperFormat.getDenominatorFormat());\n+        improperFormat.setDenominatorFormat(old);\n+    }\n+    \n+    public void testWholeFormat() {\n+        ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;\n+        \n+        NumberFormat old = format.getWholeFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        format.setWholeFormat(nf);\n+        assertEquals(nf, format.getWholeFormat());\n+        format.setWholeFormat(old);\n+    }\n+    \n+    public void testLongFormat() {\n+        assertEquals(\"10 / 1\", improperFormat.format(10l));\n+    }\n+    \n+    public void testDoubleFormat() {\n+        assertEquals(\"1 / 16\", improperFormat.format(0.0625));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+public class BigFractionTest extends TestCase {\n+\n+    private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumeratorAsInt());\n+        assertEquals(expectedDenominator, actual.getDenominatorAsInt());\n+    }\n+\n+    private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumeratorAsLong());\n+        assertEquals(expectedDenominator, actual.getDenominatorAsLong());\n+    }\n+\n+    public void testConstructor() {\n+        assertFraction(0, 1, new BigFraction(0, 1));\n+        assertFraction(0, 1, new BigFraction(0l, 2l));\n+        assertFraction(0, 1, new BigFraction(0, -1));\n+        assertFraction(1, 2, new BigFraction(1, 2));\n+        assertFraction(1, 2, new BigFraction(2, 4));\n+        assertFraction(-1, 2, new BigFraction(-1, 2));\n+        assertFraction(-1, 2, new BigFraction(1, -2));\n+        assertFraction(-1, 2, new BigFraction(-2, 4));\n+        assertFraction(-1, 2, new BigFraction(2, -4));\n+        assertFraction(11, 1, new BigFraction(11));\n+        assertFraction(11, 1, new BigFraction(11l));\n+        assertFraction(11, 1, new BigFraction(new BigInteger(\"11\")));\n+\n+        try {\n+            assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100));\n+            assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100));\n+            assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100));\n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+        assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);\n+        assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);\n+        assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);\n+        assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001));\n+        assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001));\n+        try {\n+            new BigFraction(null, BigInteger.ONE);\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+        try {\n+            new BigFraction(BigInteger.ONE, null);\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+        try {\n+            new BigFraction(BigInteger.ONE, BigInteger.ZERO);\n+        } catch (ArithmeticException npe) {\n+            // expected\n+        }\n+        try {\n+            new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000);\n+        } catch (FractionConversionException fce) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGoldenRatio() {\n+        try {\n+            // the golden ratio is notoriously a difficult number for continuous\n+            // fraction\n+            new BigFraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConvergenceException ce) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    // MATH-179\n+    public void testDoubleConstructor() throws ConvergenceException {\n+        assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100));\n+        assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100));\n+        assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100));\n+        assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100));\n+        assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100));\n+        assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100));\n+        assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100));\n+        assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100));\n+        assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100));\n+        assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100));\n+        assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100));\n+        assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100));\n+        assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100));\n+        assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100));\n+        assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100));\n+        assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100));\n+        assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100));\n+        assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100));\n+        assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100));\n+        assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100));\n+        assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100));\n+        assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100));\n+        assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100));\n+        assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100));\n+        assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100));\n+        assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100));\n+        assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100));\n+        assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100));\n+        assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100));\n+        assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100));\n+        assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100));\n+        assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100));\n+        assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100));\n+        assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100));\n+        assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100));\n+        assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100));\n+        assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100));\n+        assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100));\n+        assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100));\n+        assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100));\n+        assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100));\n+    }\n+\n+    // MATH-181\n+    public void testDigitLimitConstructor() throws ConvergenceException {\n+        assertFraction(2, 5, new BigFraction(0.4, 9));\n+        assertFraction(2, 5, new BigFraction(0.4, 99));\n+        assertFraction(2, 5, new BigFraction(0.4, 999));\n+\n+        assertFraction(3, 5, new BigFraction(0.6152, 9));\n+        assertFraction(8, 13, new BigFraction(0.6152, 99));\n+        assertFraction(510, 829, new BigFraction(0.6152, 999));\n+        assertFraction(769, 1250, new BigFraction(0.6152, 9999));\n+    }\n+\n+    public void testEpsilonLimitConstructor() throws ConvergenceException {\n+        assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100));\n+\n+        assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100));\n+        assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100));\n+        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100));\n+        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100));\n+        assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100));\n+        assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100));\n+    }\n+\n+    public void testCompareTo() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(1, 3);\n+        BigFraction third = new BigFraction(1, 2);\n+\n+        assertEquals(0, first.compareTo(first));\n+        assertEquals(0, first.compareTo(third));\n+        assertEquals(1, first.compareTo(second));\n+        assertEquals(-1, second.compareTo(first));\n+\n+        // these two values are different approximations of PI\n+        // the first  one is approximately PI - 3.07e-18\n+        // the second one is approximately PI + 1.936e-17\n+        BigFraction pi1 = new BigFraction(1068966896, 340262731);\n+        BigFraction pi2 = new BigFraction( 411557987, 131002976);\n+        assertEquals(-1, pi1.compareTo(pi2));\n+        assertEquals( 1, pi2.compareTo(pi1));\n+        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n+\n+    }\n+\n+    public void testDoubleValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(1, 3);\n+\n+        assertEquals(0.5, first.doubleValue(), 0.0);\n+        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n+    }\n+\n+    public void testFloatValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(1, 3);\n+\n+        assertEquals(0.5f, first.floatValue(), 0.0f);\n+        assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);\n+    }\n+\n+    public void testIntValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(3, 2);\n+\n+        assertEquals(0, first.intValue());\n+        assertEquals(1, second.intValue());\n+    }\n+\n+    public void testLongValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(3, 2);\n+\n+        assertEquals(0L, first.longValue());\n+        assertEquals(1L, second.longValue());\n+    }\n+\n+    public void testConstructorDouble() {\n+        assertFraction(1, 2, new BigFraction(0.5));\n+        assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0));\n+        assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0));\n+        assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0));\n+        assertFraction(-1, 2, new BigFraction(-0.5));\n+        assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0));\n+        assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0));\n+        assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0));\n+        for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) {\n+            try {\n+                new BigFraction(v);\n+                fail(\"expected exception\");\n+            } catch (IllegalArgumentException iae) {\n+                // expected\n+            }\n+        }\n+        assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());\n+        assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());\n+        assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());\n+    }\n+\n+    public void testAbs() {\n+        BigFraction a = new BigFraction(10, 21);\n+        BigFraction b = new BigFraction(-10, 21);\n+        BigFraction c = new BigFraction(10, -21);\n+\n+        assertFraction(10, 21, a.abs());\n+        assertFraction(10, 21, b.abs());\n+        assertFraction(10, 21, c.abs());\n+    }\n+\n+    public void testReciprocal() {\n+        BigFraction f = null;\n+\n+        f = new BigFraction(50, 75);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumeratorAsInt());\n+        assertEquals(2, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(4, 3);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumeratorAsInt());\n+        assertEquals(4, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(-15, 47);\n+        f = f.reciprocal();\n+        assertEquals(-47, f.getNumeratorAsInt());\n+        assertEquals(15, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(0, 3);\n+        try {\n+            f = f.reciprocal();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+\n+        // large values\n+        f = new BigFraction(Integer.MAX_VALUE, 1);\n+        f = f.reciprocal();\n+        assertEquals(1, f.getNumeratorAsInt());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+    }\n+\n+    public void testNegate() {\n+        BigFraction f = null;\n+\n+        f = new BigFraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-2, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(2, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        // large values\n+        f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+\n+    }\n+\n+    public void testAdd() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(1, 1, a.add(a));\n+        assertFraction(7, 6, a.add(b));\n+        assertFraction(7, 6, b.add(a));\n+        assertFraction(4, 3, b.add(b));\n+\n+        BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        BigFraction f2 = BigFraction.ONE;\n+        BigFraction f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(-1, 13 * 13 * 2 * 2);\n+        f2 = new BigFraction(-2, 13 * 17 * 2);\n+        f = f1.add(f2);\n+        assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());\n+        assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());\n+\n+        try {\n+            f.add((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = new BigFraction(1, 32768 * 3);\n+        f2 = new BigFraction(1, 59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumeratorAsInt());\n+        assertEquals(1934917632, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, 3);\n+        f2 = new BigFraction(1, 3);\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        f = f1.add(BigInteger.ONE);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f.add(BigInteger.ZERO);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        f = f1.add(1);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f.add(0);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        f = f1.add(1l);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f.add(0l);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+    }\n+\n+    public void testDivide() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(1, 1, a.divide(a));\n+        assertFraction(3, 4, a.divide(b));\n+        assertFraction(4, 3, b.divide(a));\n+        assertFraction(1, 1, b.divide(b));\n+\n+        BigFraction f1 = new BigFraction(3, 5);\n+        BigFraction f2 = BigFraction.ZERO;\n+        try {\n+            f1.divide(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+\n+        f1 = new BigFraction(0, 5);\n+        f2 = new BigFraction(2, 7);\n+        BigFraction f = f1.divide(f2);\n+        assertSame(BigFraction.ZERO, f);\n+\n+        f1 = new BigFraction(2, 7);\n+        f2 = BigFraction.ONE;\n+        f = f1.divide(f2);\n+        assertEquals(2, f.getNumeratorAsInt());\n+        assertEquals(7, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f1);\n+        assertEquals(1, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = new BigFraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        try {\n+            f.divide((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        assertEquals(1, f.getNumeratorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.divide(Integer.MIN_VALUE);\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        assertEquals(1, f.getNumeratorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.divide((long) Integer.MIN_VALUE);\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        assertEquals(1, f.getNumeratorAsInt());\n+\n+    }\n+\n+    public void testMultiply() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(1, 4, a.multiply(a));\n+        assertFraction(1, 3, a.multiply(b));\n+        assertFraction(1, 3, b.multiply(a));\n+        assertFraction(4, 9, b.multiply(b));\n+\n+        BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1);\n+        BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        BigFraction f = f1.multiply(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f2.multiply(Integer.MAX_VALUE);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f2.multiply((long) Integer.MAX_VALUE);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        try {\n+            f.multiply((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+    }\n+\n+    public void testSubtract() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(0, 1, a.subtract(a));\n+        assertFraction(-1, 6, a.subtract(b));\n+        assertFraction(1, 6, b.subtract(a));\n+        assertFraction(0, 1, b.subtract(b));\n+\n+        BigFraction f = new BigFraction(1, 1);\n+        try {\n+            f.subtract((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        BigFraction f1 = new BigFraction(1, 32768 * 3);\n+        BigFraction f2 = new BigFraction(1, 59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumeratorAsInt());\n+        assertEquals(1934917632, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, 3);\n+        f2 = new BigFraction(1, 3).negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE, 1);\n+        f2 = BigFraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+    }\n+\n+    public void testBigDecimalValue() {\n+        assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());\n+        assertEquals(new BigDecimal(\"0.0003\"), new BigFraction(3, 10000).bigDecimalValue());\n+        assertEquals(new BigDecimal(\"0\"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));\n+        assertEquals(new BigDecimal(\"0.333\"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        BigFraction zero = new BigFraction(0, 1);\n+        BigFraction nullFraction = null;\n+        assertTrue(zero.equals(zero));\n+        assertFalse(zero.equals(nullFraction));\n+        assertFalse(zero.equals(Double.valueOf(0)));\n+        BigFraction zero2 = new BigFraction(0, 2);\n+        assertTrue(zero.equals(zero2));\n+        assertEquals(zero.hashCode(), zero2.hashCode());\n+        BigFraction one = new BigFraction(1, 1);\n+        assertFalse((one.equals(zero) || zero.equals(one)));\n+        assertTrue(one.equals(BigFraction.ONE));\n+    }\n+\n+    public void testGetReducedFraction() {\n+        BigFraction threeFourths = new BigFraction(3, 4);\n+        assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));\n+        assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));\n+        try {\n+            BigFraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+        assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);\n+        assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);\n+    }\n+\n+    public void testPow() {\n+        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13));\n+        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l));\n+        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l)));\n+        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0));\n+        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l));\n+        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l)));\n+        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13));\n+        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l));\n+        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l)));\n+    }\n+\n+    public void testSerial() throws FractionConversionException {\n+        BigFraction[] fractions = {\n+            new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO,\n+            new BigFraction(17), new BigFraction(Math.PI, 1000),\n+            new BigFraction(-5, 2)\n+        };\n+        for (BigFraction fraction : fractions) {\n+            assertEquals(fraction, TestUtils.serializeAndRecover(fraction));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Test;\n+\n+public class FractionFieldTest {\n+\n+    @Test\n+    public void testZero() {\n+        assertEquals(Fraction.ZERO, FractionField.getInstance().getZero());\n+    }\n+\n+    @Test\n+    public void testOne() {\n+        assertEquals(Fraction.ONE, FractionField.getInstance().getOne());\n+    }\n+\n+    @Test\n+    public void testSerial() {\n+        // deserializing the singleton should give the singleton itself back\n+        FractionField field = FractionField.getInstance();\n+        assertTrue(field == TestUtils.serializeAndRecover(field));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+public class FractionFormatTest extends TestCase {\n+ \n+    FractionFormat properFormat = null;\n+    FractionFormat improperFormat = null;\n+\n+    protected Locale getLocale() {\n+        return Locale.getDefault();\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        properFormat = FractionFormat.getProperInstance(getLocale());\n+        improperFormat = FractionFormat.getImproperInstance(getLocale());\n+    }\n+   \n+    public void testFormat() {\n+        Fraction c = new Fraction(1, 2);\n+        String expected = \"1 / 2\";\n+        \n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatNegative() {\n+        Fraction c = new Fraction(-1, 2);\n+        String expected = \"-1 / 2\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatZero() {\n+        Fraction c = new Fraction(0, 1);\n+        String expected = \"0 / 1\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testFormatImproper() {\n+        Fraction c = new Fraction(5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"5 / 3\", actual);\n+    }\n+    \n+    public void testFormatImproperNegative() {\n+        Fraction c = new Fraction(-5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"-5 / 3\", actual);\n+    }\n+    \n+    public void testParse() {\n+        String source = \"1 / 2\";\n+\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInteger() {\n+        String source = \"10\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(10, c.getNumerator());\n+            assertEquals(1, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        try {\n+            Fraction c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(10, c.getNumerator());\n+            assertEquals(1, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInvalid() {\n+        String source = \"a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseInvalidDenominator() {\n+        String source = \"10 / a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseNegative() {\n+\n+        try {\n+            String source = \"-1 / 2\";\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+\n+            source = \"1 / -2\";\n+            c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseProper() {\n+        String source = \"1 2 / 3\";\n+\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(5, c.getNumerator());\n+            assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperNegative() {\n+        String source = \"-1 2 / 3\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-5, c.getNumerator());\n+            assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperInvalidMinus() {\n+        String source = \"2 -2 / 3\";\n+        try {\n+            properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+        source = \"2 2 / -3\";\n+        try {\n+            properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testNumeratorFormat() {\n+        NumberFormat old = properFormat.getNumeratorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, properFormat.getNumeratorFormat());\n+        properFormat.setNumeratorFormat(old);\n+\n+        old = improperFormat.getNumeratorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, improperFormat.getNumeratorFormat());\n+        improperFormat.setNumeratorFormat(old);\n+    }\n+    \n+    public void testDenominatorFormat() {\n+        NumberFormat old = properFormat.getDenominatorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, properFormat.getDenominatorFormat());\n+        properFormat.setDenominatorFormat(old);\n+\n+        old = improperFormat.getDenominatorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, improperFormat.getDenominatorFormat());\n+        improperFormat.setDenominatorFormat(old);\n+    }\n+    \n+    public void testWholeFormat() {\n+        ProperFractionFormat format = (ProperFractionFormat)properFormat;\n+        \n+        NumberFormat old = format.getWholeFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        format.setWholeFormat(nf);\n+        assertEquals(nf, format.getWholeFormat());\n+        format.setWholeFormat(old);\n+    }\n+    \n+    public void testLongFormat() {\n+        assertEquals(\"10 / 1\", improperFormat.format(10l));\n+    }\n+    \n+    public void testDoubleFormat() {\n+        assertEquals(\"355 / 113\", improperFormat.format(Math.PI));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class FractionTest extends TestCase {\n+\n+    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumerator());\n+        assertEquals(expectedDenominator, actual.getDenominator());\n+    }\n+    \n+    public void testConstructor() {\n+        assertFraction(0, 1, new Fraction(0, 1));\n+        assertFraction(0, 1, new Fraction(0, 2));\n+        assertFraction(0, 1, new Fraction(0, -1));\n+        assertFraction(1, 2, new Fraction(1, 2));\n+        assertFraction(1, 2, new Fraction(2, 4));\n+        assertFraction(-1, 2, new Fraction(-1, 2));\n+        assertFraction(-1, 2, new Fraction(1, -2));\n+        assertFraction(-1, 2, new Fraction(-2, 4));\n+        assertFraction(-1, 2, new Fraction(2, -4));\n+        \n+        // overflow\n+        try {\n+            new Fraction(Integer.MIN_VALUE, -1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+        try {\n+            new Fraction(1, Integer.MIN_VALUE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+        try {        \n+            assertFraction(0, 1, new Fraction(0.00000000000001));\n+            assertFraction(2, 5, new Fraction(0.40000000000001));\n+            assertFraction(15, 1, new Fraction(15.0000000000001));\n+            \n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testGoldenRatio() {\n+        try {\n+            // the golden ratio is notoriously a difficult number for continuous fraction\n+            new Fraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConvergenceException ce) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    // MATH-179\n+    public void testDoubleConstructor() throws ConvergenceException  {\n+        assertFraction(1, 2, new Fraction((double)1 / (double)2));\n+        assertFraction(1, 3, new Fraction((double)1 / (double)3));\n+        assertFraction(2, 3, new Fraction((double)2 / (double)3));\n+        assertFraction(1, 4, new Fraction((double)1 / (double)4));\n+        assertFraction(3, 4, new Fraction((double)3 / (double)4));\n+        assertFraction(1, 5, new Fraction((double)1 / (double)5));\n+        assertFraction(2, 5, new Fraction((double)2 / (double)5));\n+        assertFraction(3, 5, new Fraction((double)3 / (double)5));\n+        assertFraction(4, 5, new Fraction((double)4 / (double)5));\n+        assertFraction(1, 6, new Fraction((double)1 / (double)6));\n+        assertFraction(5, 6, new Fraction((double)5 / (double)6));\n+        assertFraction(1, 7, new Fraction((double)1 / (double)7));\n+        assertFraction(2, 7, new Fraction((double)2 / (double)7));\n+        assertFraction(3, 7, new Fraction((double)3 / (double)7));\n+        assertFraction(4, 7, new Fraction((double)4 / (double)7));\n+        assertFraction(5, 7, new Fraction((double)5 / (double)7));\n+        assertFraction(6, 7, new Fraction((double)6 / (double)7));\n+        assertFraction(1, 8, new Fraction((double)1 / (double)8));\n+        assertFraction(3, 8, new Fraction((double)3 / (double)8));\n+        assertFraction(5, 8, new Fraction((double)5 / (double)8));\n+        assertFraction(7, 8, new Fraction((double)7 / (double)8));\n+        assertFraction(1, 9, new Fraction((double)1 / (double)9));\n+        assertFraction(2, 9, new Fraction((double)2 / (double)9));\n+        assertFraction(4, 9, new Fraction((double)4 / (double)9));\n+        assertFraction(5, 9, new Fraction((double)5 / (double)9));\n+        assertFraction(7, 9, new Fraction((double)7 / (double)9));\n+        assertFraction(8, 9, new Fraction((double)8 / (double)9));\n+        assertFraction(1, 10, new Fraction((double)1 / (double)10));\n+        assertFraction(3, 10, new Fraction((double)3 / (double)10));\n+        assertFraction(7, 10, new Fraction((double)7 / (double)10));\n+        assertFraction(9, 10, new Fraction((double)9 / (double)10));\n+        assertFraction(1, 11, new Fraction((double)1 / (double)11));\n+        assertFraction(2, 11, new Fraction((double)2 / (double)11));\n+        assertFraction(3, 11, new Fraction((double)3 / (double)11));\n+        assertFraction(4, 11, new Fraction((double)4 / (double)11));\n+        assertFraction(5, 11, new Fraction((double)5 / (double)11));\n+        assertFraction(6, 11, new Fraction((double)6 / (double)11));\n+        assertFraction(7, 11, new Fraction((double)7 / (double)11));\n+        assertFraction(8, 11, new Fraction((double)8 / (double)11));\n+        assertFraction(9, 11, new Fraction((double)9 / (double)11));\n+        assertFraction(10, 11, new Fraction((double)10 / (double)11));\n+    }\n+\n+    // MATH-181\n+    public void testDigitLimitConstructor() throws ConvergenceException  {\n+        assertFraction(2, 5, new Fraction(0.4,   9));\n+        assertFraction(2, 5, new Fraction(0.4,  99));\n+        assertFraction(2, 5, new Fraction(0.4, 999));\n+\n+        assertFraction(3, 5,      new Fraction(0.6152,    9));\n+        assertFraction(8, 13,     new Fraction(0.6152,   99));\n+        assertFraction(510, 829,  new Fraction(0.6152,  999));\n+        assertFraction(769, 1250, new Fraction(0.6152, 9999));\n+    }\n+\n+    public void testIntegerOverflow() {\n+        checkIntegerOverflow(0.75000000001455192);\n+        checkIntegerOverflow(1.0e10);\n+    }\n+\n+    private void checkIntegerOverflow(double a) {\n+        try {\n+            new Fraction(a, 1.0e-12, 1000);\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConvergenceException ce) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testEpsilonLimitConstructor() throws ConvergenceException  {\n+        assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100));\n+\n+        assertFraction(3, 5,      new Fraction(0.6152, 0.02, 100));\n+        assertFraction(8, 13,     new Fraction(0.6152, 1.0e-3, 100));\n+        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-4, 100));\n+        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-5, 100));\n+        assertFraction(510, 829,  new Fraction(0.6152, 1.0e-6, 100));\n+        assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100));\n+    }\n+\n+    public void testCompareTo() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(1, 3);\n+        Fraction third = new Fraction(1, 2);\n+        \n+        assertEquals(0, first.compareTo(first));\n+        assertEquals(0, first.compareTo(third));\n+        assertEquals(1, first.compareTo(second));\n+        assertEquals(-1, second.compareTo(first));\n+\n+        // these two values are different approximations of PI\n+        // the first  one is approximately PI - 3.07e-18\n+        // the second one is approximately PI + 1.936e-17\n+        Fraction pi1 = new Fraction(1068966896, 340262731);\n+        Fraction pi2 = new Fraction( 411557987, 131002976);\n+        assertEquals(-1, pi1.compareTo(pi2));\n+        assertEquals( 1, pi2.compareTo(pi1));\n+        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n+    }\n+    \n+    public void testDoubleValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(1, 3);\n+\n+        assertEquals(0.5, first.doubleValue(), 0.0);\n+        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n+    }\n+    \n+    public void testFloatValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(1, 3);\n+\n+        assertEquals(0.5f, first.floatValue(), 0.0f);\n+        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);\n+    }\n+    \n+    public void testIntValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(3, 2);\n+\n+        assertEquals(0, first.intValue());\n+        assertEquals(1, second.intValue());\n+    }\n+    \n+    public void testLongValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(3, 2);\n+\n+        assertEquals(0L, first.longValue());\n+        assertEquals(1L, second.longValue());\n+    }\n+    \n+    public void testConstructorDouble() {\n+        try {\n+            assertFraction(1, 2, new Fraction(0.5));\n+            assertFraction(1, 3, new Fraction(1.0 / 3.0));\n+            assertFraction(17, 100, new Fraction(17.0 / 100.0));\n+            assertFraction(317, 100, new Fraction(317.0 / 100.0));\n+            assertFraction(-1, 2, new Fraction(-0.5));\n+            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));\n+            assertFraction(-17, 100, new Fraction(17.0 / -100.0));\n+            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));\n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testAbs() {\n+        Fraction a = new Fraction(10, 21);\n+        Fraction b = new Fraction(-10, 21);\n+        Fraction c = new Fraction(10, -21);\n+        \n+        assertFraction(10, 21, a.abs());\n+        assertFraction(10, 21, b.abs());\n+        assertFraction(10, 21, c.abs());\n+    }\n+    \n+    public void testReciprocal() {\n+        Fraction f = null;\n+        \n+        f = new Fraction(50, 75);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = new Fraction(4, 3);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = new Fraction(-15, 47);\n+        f = f.reciprocal();\n+        assertEquals(-47, f.getNumerator());\n+        assertEquals(15, f.getDenominator());\n+        \n+        f = new Fraction(0, 3);\n+        try {\n+            f = f.reciprocal();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // large values\n+        f = new Fraction(Integer.MAX_VALUE, 1);\n+        f = f.reciprocal();\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+    }\n+    \n+    public void testNegate() {\n+        Fraction f = null;\n+        \n+        f = new Fraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = new Fraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+\n+        // large values\n+        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        f = new Fraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.negate();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testAdd() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 1, a.add(a));\n+        assertFraction(7, 6, a.add(b));\n+        assertFraction(7, 6, b.add(a));\n+        assertFraction(4, 3, b.add(b));\n+        \n+        Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n+        Fraction f2 = Fraction.ONE;\n+        Fraction f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        f = f1.add(1);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = new Fraction(-1, 13*13*2*2);\n+        f2 = new Fraction(-2, 13*17*2);\n+        f = f1.add(f2);\n+        assertEquals(13*13*17*2*2, f.getDenominator());\n+        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        \n+        try {\n+            f.add(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = new Fraction(1,32768*3);\n+        f2 = new Fraction(1,59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = new Fraction(Integer.MIN_VALUE, 3);\n+        f2 = new Fraction(1,3);\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        try {\n+            f = f.add(Fraction.ONE); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = new Fraction(Integer.MIN_VALUE, 5);\n+        f2 = new Fraction(-1,5);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(3,327680);\n+        f2 = new Fraction(2,59049);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testDivide() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 1, a.divide(a));\n+        assertFraction(3, 4, a.divide(b));\n+        assertFraction(4, 3, b.divide(a));\n+        assertFraction(1, 1, b.divide(b));\n+        \n+        Fraction f1 = new Fraction(3, 5);\n+        Fraction f2 = Fraction.ZERO;\n+        try {\n+            f1.divide(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(0, 5);\n+        f2 = new Fraction(2, 7);\n+        Fraction f = f1.divide(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = new Fraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.divide(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = new Fraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f1);  \n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = new Fraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.divide(null);\n+            fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = new Fraction(1, Integer.MAX_VALUE);\n+            f = f1.divide(f1.reciprocal());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f1 = new Fraction(1, -Integer.MAX_VALUE);\n+            f = f1.divide(f1.reciprocal());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f1 = new Fraction(6, 35);\n+        f  = f1.divide(15);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(175, f.getDenominator());\n+\n+    }\n+    \n+    public void testMultiply() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 4, a.multiply(a));\n+        assertFraction(1, 3, a.multiply(b));\n+        assertFraction(1, 3, b.multiply(a));\n+        assertFraction(4, 9, b.multiply(b));\n+        \n+        Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);\n+        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        Fraction f = f1.multiply(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.multiply(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        f1 = new Fraction(6, 35);\n+        f  = f1.multiply(15);\n+        assertEquals(18, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+    }\n+    \n+    public void testSubtract() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(0, 1, a.subtract(a));\n+        assertFraction(-1, 6, a.subtract(b));\n+        assertFraction(1, 6, b.subtract(a));\n+        assertFraction(0, 1, b.subtract(b));\n+        \n+        Fraction f = new Fraction(1,1);\n+        try {\n+            f.subtract(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        Fraction f1 = new Fraction(1,32768*3);\n+        Fraction f2 = new Fraction(1,59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = new Fraction(Integer.MIN_VALUE, 3);\n+        f2 = new Fraction(1,3).negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        f = f1.subtract(1);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f1 = new Fraction(1, Integer.MAX_VALUE);\n+            f2 = new Fraction(1, Integer.MAX_VALUE - 1);\n+            f = f1.subtract(f2);\n+            fail(\"expecting ArithmeticException\");  //should overflow\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = new Fraction(Integer.MIN_VALUE, 5);\n+        f2 = new Fraction(1,5);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(Integer.MIN_VALUE, 1);\n+            f = f.subtract(Fraction.ONE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(Integer.MAX_VALUE, 1);\n+            f = f.subtract(Fraction.ONE.negate());\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(3,327680);\n+        f2 = new Fraction(2,59049);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        Fraction zero  = new Fraction(0,1);\n+        Fraction nullFraction = null;\n+        assertTrue( zero.equals(zero));\n+        assertFalse(zero.equals(nullFraction));\n+        assertFalse(zero.equals(Double.valueOf(0)));\n+        Fraction zero2 = new Fraction(0,2);\n+        assertTrue(zero.equals(zero2));\n+        assertEquals(zero.hashCode(), zero2.hashCode());\n+        Fraction one = new Fraction(1,1);\n+        assertFalse((one.equals(zero) ||zero.equals(one)));\n+    }\n+    \n+    public void testGetReducedFraction() {\n+        Fraction threeFourths = new Fraction(3, 4);\n+        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));\n+        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));\n+        try {\n+            Fraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+        assertEquals(Fraction.getReducedFraction\n+                (2, Integer.MIN_VALUE).getNumerator(),-1);\n+        assertEquals(Fraction.getReducedFraction\n+                (1, -1).getNumerator(), -1);\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new Fraction(0, 3).toString());\n+        assertEquals(\"3\", new Fraction(6, 2).toString());\n+        assertEquals(\"2 / 3\", new Fraction(18, 27).toString());\n+    }\n+\n+    public void testSerial() throws FractionConversionException {\n+        Fraction[] fractions = {\n+            new Fraction(3, 4), Fraction.ONE, Fraction.ZERO,\n+            new Fraction(17), new Fraction(Math.PI, 1000),\n+            new Fraction(-5, 2)\n+        };\n+        for (Fraction fraction : fractions) {\n+            assertEquals(fraction, TestUtils.serializeAndRecover(fraction));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/BinaryChromosomeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+\n+public class BinaryChromosomeTest {\n+    \n+    @Test\n+    public void testInvalidConstructor() {        \n+        Integer[][] reprs = new Integer[][] {\n+                new Integer[] {0,1,0,1,2},\n+                new Integer[] {0,1,0,1,-1}\n+        };\n+        \n+        for (Integer[] repr : reprs) {\n+            try {\n+                new DummyBinaryChromosome(repr);\n+                fail(\"Exception not caught\");\n+            } catch (IllegalArgumentException e) {\n+                \n+            }\n+        }\n+    }\n+    \n+    @Test\n+    public void testRandomConstructor() {\n+        for (int i=0; i<20; i++) {\n+            new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));\n+        }\n+    }\n+    \n+    @Test\n+    public void testIsSame() {\n+        Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n+        Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1});\n+        Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1});\n+        Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});\n+        Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});\n+        Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n+        \n+        assertFalse(c1.isSame(c2));\n+        assertFalse(c1.isSame(c3));\n+        assertFalse(c1.isSame(c4));\n+        assertFalse(c1.isSame(c5));\n+        assertTrue(c1.isSame(c6));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/BinaryMutationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class BinaryMutationTest {\n+\n+    @Test\n+    public void testMutate() {\n+        BinaryMutation mutation = new BinaryMutation();\n+        \n+        // stochastic testing :)\n+        for (int i=0; i<20; i++) {\n+            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));            \n+            DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);\n+            \n+            // one gene should be different\n+            int numDifferent = 0;\n+            for (int j=0; j<original.getRepresentation().size(); j++) {\n+                if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j))\n+                    numDifferent++;\n+            }\n+            assertEquals(1, numDifferent);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/ChromosomeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+public class ChromosomeTest {\n+\n+    @Test\n+    public void testCompareTo() {\n+        Chromosome c1 = new Chromosome() {\n+            public double fitness() {                \n+                return 0;\n+            }\n+        };\n+        Chromosome c2 = new Chromosome() {\n+            public double fitness() {                \n+                return 10;\n+            }\n+        };\n+        Chromosome c3 = new Chromosome() {\n+            public double fitness() {                \n+                return 10;\n+            }\n+        };\n+        \n+        assertTrue(c1.compareTo(c2) < 0);\n+        assertTrue(c2.compareTo(c1) > 0);\n+        assertEquals(0,c3.compareTo(c2));\n+        assertEquals(0,c2.compareTo(c3));\n+    }\n+    \n+    private abstract static class DummyChromosome extends Chromosome {\n+        private final int repr;\n+\n+        public DummyChromosome(final int repr) {\n+            this.repr = repr;\n+        }\n+        @Override\n+        protected boolean isSame(Chromosome another) {\n+            return ((DummyChromosome) another).repr == repr;\n+        }\n+    }\n+    \n+    @Test\n+    public void testFindSameChromosome() {\n+        Chromosome c1 = new DummyChromosome(1) {\n+            public double fitness() {\n+                return 1;\n+            }\n+        };\n+        Chromosome c2 = new DummyChromosome(2) {\n+            public double fitness() {\n+                return 2;\n+            }\n+        };\n+        Chromosome c3 = new DummyChromosome(3) {\n+            public double fitness() {\n+                return 3;\n+            }\n+        };\n+        Chromosome c4 = new DummyChromosome(1) {\n+            public double fitness() {\n+                return 5;\n+            }\n+        };\n+        Chromosome c5 = new DummyChromosome(15) {\n+            public double fitness() {\n+                return 15;\n+            }\n+        };\n+        \n+        List<Chromosome> popChr = new ArrayList<Chromosome>();\n+        popChr.add(c1);\n+        popChr.add(c2);\n+        popChr.add(c3);\n+        Population pop = new ListPopulation(popChr,3) {\n+            public Population nextGeneration() {\n+                // not important\n+                return null;\n+            }\n+        };\n+        \n+        assertNull(c5.findSameChromosome(pop));\n+        assertEquals(c1, c4.findSameChromosome(pop));\n+        \n+        c4.searchForFitnessUpdate(pop);\n+        assertEquals(1, c4.getFitness(),0);\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/DummyBinaryChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.List;\n+\n+/**\n+ * Implementation of BinaryChromosome for testing purposes\n+ */\n+public class DummyBinaryChromosome extends BinaryChromosome {\n+\n+    public DummyBinaryChromosome(List<Integer> representation) {\n+        super(representation);\n+    }\n+    \n+    public DummyBinaryChromosome(Integer[] representation) {\n+        super(representation);\n+    }\n+\n+    @Override\n+    public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> representation) {\n+        return new DummyBinaryChromosome(representation);\n+    }\n+\n+    public double fitness() {\n+        // uninteresting\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/DummyRandomKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.List;\n+\n+/**\n+ * Implementation of RandomKey for testing purposes\n+ */\n+public class DummyRandomKey extends RandomKey<String> {\n+\n+    public DummyRandomKey(List<Double> representation) {\n+        super(representation);\n+    }\n+    \n+    public DummyRandomKey(Double[] representation) {\n+        super(representation);\n+    }\n+\n+    @Override\n+    public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> representation) {\n+        return new DummyRandomKey(representation);\n+    }\n+\n+    public double fitness() {\n+        // unimportant\n+        return 0;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/ElitisticListPopulationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class ElitisticListPopulationTest {\n+    \n+    private static int counter = 0;\n+\n+    @Test\n+    public void testNextGeneration() {\n+        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);\n+        \n+        for (int i=0; i<pop.getPopulationLimit(); i++) {\n+            pop.addChromosome(new DummyChromosome());\n+        }\n+        \n+        Population nextGeneration = pop.nextGeneration();\n+        \n+        assertEquals(20, nextGeneration.getPopulationSize());\n+    }\n+    \n+    private static class DummyChromosome extends Chromosome {\n+        private final int fitness;\n+        \n+        public DummyChromosome() {\n+            this.fitness = counter;\n+            counter++;\n+        }\n+        \n+        public double fitness() {            \n+            return this.fitness;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/FitnessCachingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.junit.Test;\n+\n+\n+public class FitnessCachingTest {\n+    \n+    // parameters for the GA\n+    private static final int DIMENSION = 50; \n+    private static final double CROSSOVER_RATE = 1;\n+    private static final double MUTATION_RATE = 0.1;\n+    private static final int TOURNAMENT_ARITY = 5;\n+    \n+    private static final int POPULATION_SIZE = 10;\n+    private static final int NUM_GENERATIONS = 50;\n+    private static final double ELITISM_RATE = 0.2;\n+\n+    // how many times was the fitness computed\n+    public static int fitnessCalls = 0;\n+\n+\n+    @Test\n+    public void testFitnessCaching() {\n+        // initialize a new genetic algorithm\n+        GeneticAlgorithm ga = new GeneticAlgorithm(\n+                new OnePointCrossover<Integer>(),\n+                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)\n+                new BinaryMutation(),\n+                MUTATION_RATE, // no mutation\n+                new TournamentSelection(TOURNAMENT_ARITY)\n+        );\n+        \n+        // initial population\n+        Population initial = randomPopulation();\n+        // stopping conditions\n+        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n+        \n+        // run the algorithm\n+        ga.evolve(initial, stopCond);\n+        \n+        int neededCalls =\n+            POPULATION_SIZE /*initial population*/ +\n+            (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/\n+            ;\n+        assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones\n+    }\n+\n+\n+    /**\n+     * Initializes a random population.\n+     */\n+    private static ElitisticListPopulation randomPopulation() {\n+        List<Chromosome> popList = new LinkedList<Chromosome>();\n+        \n+        for (int i=0; i<POPULATION_SIZE; i++) {\n+            BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));\n+            popList.add(randChrom);\n+        }        \n+        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n+    }\n+    \n+    private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {\n+\n+        public DummyCountingBinaryChromosome(List<Integer> representation) {\n+            super(representation);\n+        }        \n+\n+        @Override\n+        public double fitness() {\n+            fitnessCalls++;\n+            return 0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/FixedGenerationCountTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Iterator;\n+\n+import org.junit.Test;\n+\n+public class FixedGenerationCountTest {\n+\n+    @Test\n+    public void testIsSatisfied() {\n+        FixedGenerationCount fgc = new FixedGenerationCount(20);\n+        \n+        int cnt = 0;\n+        Population pop = new Population() {\n+            public void addChromosome(Chromosome chromosome) {\n+                // unimportant\n+            }\n+            public Chromosome getFittestChromosome() {\n+                // unimportant\n+                return null;\n+            }\n+            public int getPopulationLimit() {\n+                // unimportant\n+                return 0;\n+            }\n+            public int getPopulationSize() {\n+                // unimportant\n+                return 0;\n+            }\n+            public Population nextGeneration() {\n+                // unimportant\n+                return null;\n+            }\n+            public Iterator<Chromosome> iterator() {\n+                // unimportant\n+                return null;\n+            }\n+        };\n+        \n+        while (!fgc.isSatisfied(pop))\n+            cnt++;\n+        assertEquals(20, cnt);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.junit.Test;\n+\n+/**\n+ * This is also an example of usage.\n+ */\n+public class GeneticAlgorithmTestBinary {\n+    \n+    // parameters for the GA\n+    private static final int DIMENSION = 50;    \n+    private static final int POPULATION_SIZE = 50; \n+    private static final int NUM_GENERATIONS = 50;\n+    private static final double ELITISM_RATE = 0.2;\n+    private static final double CROSSOVER_RATE = 1;\n+    private static final double MUTATION_RATE = 0.1;\n+    private static final int TOURNAMENT_ARITY = 2;\n+\n+    @Test\n+    public void test() {\n+        // to test a stochastic algorithm is hard, so this will rather be an usage example\n+        \n+        // initialize a new genetic algorithm\n+        GeneticAlgorithm ga = new GeneticAlgorithm(\n+                new OnePointCrossover<Integer>(),\n+                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)\n+                new BinaryMutation(),\n+                MUTATION_RATE,\n+                new TournamentSelection(TOURNAMENT_ARITY)\n+        );\n+        \n+        // initial population\n+        Population initial = randomPopulation();\n+        // stopping conditions\n+        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n+        \n+        // best initial chromosome\n+        Chromosome bestInitial = initial.getFittestChromosome();\n+        \n+        // run the algorithm\n+        Population finalPopulation = ga.evolve(initial, stopCond);\n+        \n+        // best chromosome from the final population\n+        Chromosome bestFinal = finalPopulation.getFittestChromosome();\n+        \n+        // the only thing we can test is whether the final solution is not worse than the initial one\n+        // however, for some implementations of GA, this need not be true :)\n+        \n+        assertTrue(bestFinal.compareTo(bestInitial) > 0);\n+        \n+        //System.out.println(bestInitial);\n+        //System.out.println(bestFinal);\n+    }\n+    \n+    \n+    \n+    \n+    /**\n+     * Initializes a random population.\n+     */\n+    private static ElitisticListPopulation randomPopulation() {\n+        List<Chromosome> popList = new LinkedList<Chromosome>();\n+        \n+        for (int i=0; i<POPULATION_SIZE; i++) {\n+            BinaryChromosome randChrom = new FindOnes(BinaryChromosome.randomBinaryRepresentation(DIMENSION));\n+            popList.add(randChrom);\n+        }        \n+        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n+    }\n+    \n+    /**\n+     * Chromosomes represented by a binary chromosome.\n+     * \n+     * The goal is to set all bits (genes) to 1.\n+     */\n+    private static class FindOnes extends BinaryChromosome {\n+\n+        public FindOnes(List<Integer> representation) {\n+            super(representation);\n+        }\n+\n+        /**\n+         * Returns number of elements != 0\n+         */\n+        public double fitness() {\n+            int num = 0;\n+            for (int val : this.getRepresentation()) {\n+                if (val != 0)\n+                    num++;\n+            }\n+            // number of elements >= 0\n+            return num;\n+        }\n+\n+        @Override\n+        public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> representation) {\n+            return new FindOnes(representation);\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+/**\n+ * This is also an example of usage.\n+ * \n+ * This algorithm does \"stochastic sorting\" of a sequence 0,...,N.\n+ * \n+ */\n+public class GeneticAlgorithmTestPermutations {\n+    \n+    // parameters for the GA\n+    private static final int DIMENSION = 20;    \n+    private static final int POPULATION_SIZE = 80; \n+    private static final int NUM_GENERATIONS = 200;\n+    private static final double ELITISM_RATE = 0.2;\n+    private static final double CROSSOVER_RATE = 1;\n+    private static final double MUTATION_RATE = 0.08;\n+    private static final int TOURNAMENT_ARITY = 2;\n+    \n+    // numbers from 0 to N-1\n+    private static List<Integer> sequence = new ArrayList<Integer>();\n+    static {\n+        for (int i=0; i<DIMENSION; i++) {\n+            sequence.add(i);\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        // to test a stochastic algorithm is hard, so this will rather be an usage example\n+        \n+        // initialize a new genetic algorithm\n+        GeneticAlgorithm ga = new GeneticAlgorithm(\n+                new OnePointCrossover<Integer>(),\n+                CROSSOVER_RATE,\n+                new RandomKeyMutation(),\n+                MUTATION_RATE,\n+                new TournamentSelection(TOURNAMENT_ARITY)\n+        );\n+        \n+        // initial population\n+        Population initial = randomPopulation();\n+        // stopping conditions\n+        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n+        \n+        // best initial chromosome\n+        Chromosome bestInitial = initial.getFittestChromosome();\n+        \n+        // run the algorithm\n+        Population finalPopulation = ga.evolve(initial, stopCond);\n+        \n+        // best chromosome from the final population\n+        Chromosome bestFinal = finalPopulation.getFittestChromosome();\n+        \n+        // the only thing we can test is whether the final solution is not worse than the initial one\n+        // however, for some implementations of GA, this need not be true :)\n+        \n+        assertTrue(bestFinal.compareTo(bestInitial) > 0);\n+        \n+        //System.out.println(bestInitial);\n+        //System.out.println(bestFinal);\n+    }\n+    \n+    \n+    /**\n+     * Initializes a random population\n+     */\n+    private static ElitisticListPopulation randomPopulation() {\n+        List<Chromosome> popList = new ArrayList<Chromosome>();\n+        for (int i=0; i<POPULATION_SIZE; i++) {\n+            Chromosome randChrom = new MinPermutations(RandomKey.randomPermutation(DIMENSION));\n+            popList.add(randChrom);\n+        }\n+        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n+    }\n+    \n+    /**\n+     * Chromosomes representing a permutation of (0,1,2,...,DIMENSION-1).\n+     * \n+     * The goal is to sort the sequence.\n+     */\n+    private static class MinPermutations extends RandomKey<Integer> {\n+\n+        public MinPermutations(List<Double> representation) {\n+            super(representation);\n+        }\n+\n+        public double fitness() {\n+            int res = 0;\n+            List<Integer> decoded = decode(sequence);\n+            for (int i=0; i<decoded.size(); i++) {\n+                int value = (Integer) decoded.get(i);\n+                if (value != i) {\n+                    // bad position found\n+                    res += Math.abs(value - i);\n+                }\n+            }\n+            // the most fitted chromosome is the one with minimal error\n+            // therefore we must return negative value\n+            return -res; \n+        }\n+\n+        @Override\n+        public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> representation) {\n+            return new MinPermutations(representation);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/ListPopulationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+\n+import org.junit.Test;\n+\n+public class ListPopulationTest {\n+\n+    @Test\n+    public void testGetFittestChromosome() {\n+        Chromosome c1 = new Chromosome() {\n+            public double fitness() {                \n+                return 0;\n+            }\n+        };\n+        Chromosome c2 = new Chromosome() {\n+            public double fitness() {                \n+                return 10;\n+            }\n+        };\n+        Chromosome c3 = new Chromosome() {\n+            public double fitness() {                \n+                return 15;\n+            }\n+        };\n+        \n+        ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> ();\n+        chromosomes.add(c1);\n+        chromosomes.add(c2);\n+        chromosomes.add(c3);\n+        \n+        ListPopulation population = new ListPopulation(chromosomes,10) {\n+\n+            public Population nextGeneration() {\n+                // not important\n+                return null;\n+            }\n+        };\n+        \n+        assertEquals(c3, population.getFittestChromosome());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/OnePointCrossoverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+import org.junit.Test;\n+\n+public class OnePointCrossoverTest {\n+\n+    @Test\n+    public void testCrossover() {\n+        Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};\n+        \n+        BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+        \n+        OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>();\n+        \n+        // how to test a stochastic method?\n+        for (int i=0; i<20; i++) {\n+            ChromosomePair pair = opc.crossover(p1c,p2c);\n+            \n+            Integer[] c1 = new Integer[p1.length];\n+            Integer[] c2 = new Integer[p2.length];\n+            \n+            c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);\n+            c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);\n+            \n+            // first and last values will be the same\n+            assertEquals((int) p1[0], (int) c1[0]);\n+            assertEquals((int) p2[0], (int) c2[0]);\n+            assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);\n+            assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);\n+            // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same\n+            assertEquals((int) p1[2], (int) c1[2]);\n+            assertEquals((int) p2[2], (int) c2[2]);\n+            assertEquals((int) p1[3], (int) c1[3]);\n+            assertEquals((int) p2[3], (int) c2[3]);\n+            assertEquals((int) p1[7], (int) c1[7]);\n+            assertEquals((int) p2[7], (int) c2[7]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/RandomKeyMutationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class RandomKeyMutationTest {\n+\n+    @Test\n+    public void testMutate() {\n+        MutationPolicy mutation = new RandomKeyMutation();\n+        int l=10;\n+        for (int i=0; i<20; i++) {\n+            DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));\n+            Chromosome mutated = mutation.mutate(origRk);\n+            DummyRandomKey mutatedRk = (DummyRandomKey) mutated;\n+            \n+            int changes = 0;\n+            for (int j=0; j<origRk.getLength(); j++) {\n+                if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {\n+                    changes++;\n+                }\n+            }\n+            assertEquals(1,changes);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/RandomKeyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+public class RandomKeyTest {\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testConstructor1() {\n+        new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void testConstructor2() {\n+        new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});\n+    }\n+\n+    @Test\n+    public void testIsSame() {\n+        DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});\n+        DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});\n+        \n+        assertTrue(drk1.isSame(drk2));\n+        assertTrue(drk2.isSame(drk3));\n+        assertFalse(drk3.isSame(drk4));\n+        assertFalse(drk4.isSame(drk5));\n+    }\n+\n+    @Test\n+    public void testDecode() {\n+        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n+        List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n+        \n+        assertEquals(\"b\", decoded.get(0));\n+        assertEquals(\"e\", decoded.get(1));\n+        assertEquals(\"a\", decoded.get(2));\n+        assertEquals(\"c\", decoded.get(3));\n+        assertEquals(\"d\", decoded.get(4));\n+    }\n+\n+    @Test\n+    public void testRandomPermutation() {\n+        // never generate an invalid one\n+        for (int i=0; i<10; i++) {\n+            DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));\n+            assertNotNull(drk);\n+        }\n+    }\n+\n+    @Test\n+    public void testIdentityPermutation() {\n+        DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));\n+        List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n+        \n+        assertEquals(\"a\", decoded.get(0));\n+        assertEquals(\"b\", decoded.get(1));\n+        assertEquals(\"c\", decoded.get(2));\n+        assertEquals(\"d\", decoded.get(3));\n+        assertEquals(\"e\", decoded.get(4));\n+    }\n+\n+    @Test\n+    public void testComparatorPermutation() {\n+        List<String> data = Arrays.asList(new String[] {\"x\", \"b\", \"c\", \"z\", \"b\"});\n+        \n+        List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n+            public int compare(String o1, String o2) {\n+                return o1.compareTo(o2);\n+            }\n+        });\n+        Double[] permArr = new Double[data.size()];\n+        permArr = permutation.toArray(permArr);\n+        assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);\n+        List<String> decodedData = new DummyRandomKey(permutation).decode(data);\n+        assertEquals(\"b\", decodedData.get(0));\n+        assertEquals(\"b\", decodedData.get(1));\n+        assertEquals(\"c\", decodedData.get(2));\n+        assertEquals(\"x\", decodedData.get(3));\n+        assertEquals(\"z\", decodedData.get(4));\n+        \n+        permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n+            public int compare(String o1, String o2) {\n+                return o2.compareTo(o1);\n+            }\n+        });\n+        permArr = new Double[data.size()];\n+        permArr = permutation.toArray(permArr);\n+        assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);\n+        decodedData = new DummyRandomKey(permutation).decode(data);\n+        assertEquals(\"z\", decodedData.get(0));\n+        assertEquals(\"x\", decodedData.get(1));\n+        assertEquals(\"c\", decodedData.get(2));\n+        assertEquals(\"b\", decodedData.get(3));\n+        assertEquals(\"b\", decodedData.get(4));\n+    }\n+    \n+    @Test\n+    public void testInducedPermutation() {\n+        List<String> origData = Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"});\n+        List<String> permutedData = Arrays.asList(new String[] {\"d\", \"b\", \"c\", \"a\", \"d\"});\n+        \n+        DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));\n+        List<String> decoded = drk.decode(origData);\n+        \n+        assertEquals(\"d\", decoded.get(0));\n+        assertEquals(\"b\", decoded.get(1));\n+        assertEquals(\"c\", decoded.get(2));\n+        assertEquals(\"a\", decoded.get(3));\n+        assertEquals(\"d\", decoded.get(4));\n+\n+        try {\n+            RandomKey.inducedPermutation(\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"}),\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\"})\n+            );\n+            fail(\"Uncaught exception\");\n+        } catch (IllegalArgumentException e) {\n+            // no-op\n+        }\n+        try {\n+            RandomKey.inducedPermutation(\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"}),\n+                    Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"f\"})\n+            );\n+            fail(\"Uncaught exception\");\n+        } catch (IllegalArgumentException e) {\n+            // no-op\n+        }\n+    }\n+\n+    @Test\n+    public void testEqualRepr() {\n+        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});\n+        List<String> decodedData = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\"}));\n+        assertEquals(\"a\", decodedData.get(0));\n+        assertEquals(\"b\", decodedData.get(1));\n+        assertEquals(\"c\", decodedData.get(2));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/genetics/TournamentSelectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import static org.junit.Assert.*;\n+import org.junit.Test;\n+\n+public class TournamentSelectionTest {\n+    \n+    private static int counter = 0;\n+\n+    @Test\n+    public void testSelect() {\n+        TournamentSelection ts = new TournamentSelection(2);\n+        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);\n+        \n+        for (int i=0; i<pop.getPopulationLimit(); i++) {\n+            pop.addChromosome(new DummyChromosome());\n+        }\n+        // how to write a test for stochastic method?\n+        for (int i=0; i<20; i++) {\n+            ChromosomePair pair = ts.select(pop);\n+            // the worst chromosome should NEVER be selected\n+            assertTrue(pair.getFirst().getFitness() > 0);\n+            assertTrue(pair.getSecond().getFitness() > 0);\n+        }\n+    }\n+    \n+    private static class DummyChromosome extends Chromosome {\n+        private final int fitness;\n+        \n+        public DummyChromosome() {\n+            this.fitness = counter;\n+            counter++;\n+        }\n+        \n+        public double fitness() {            \n+            return this.fitness;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/RotationOrderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.math.geometry.RotationOrder;\n+\n+import junit.framework.*;\n+\n+public class RotationOrderTest\n+  extends TestCase {\n+\n+  public RotationOrderTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testName() {\n+\n+    RotationOrder[] orders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX,\n+      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+    };\n+\n+    for (int i = 0; i < orders.length; ++i) {\n+      assertEquals(getFieldName(orders[i]), orders[i].toString());\n+    }\n+\n+  }\n+\n+  private String getFieldName(RotationOrder order) {\n+    try {\n+      Field[] fields = RotationOrder.class.getFields();\n+      for (int i = 0; i < fields.length; ++i) {\n+        if (fields[i].get(null) == order) {\n+          return fields[i].getName();\n+        }\n+      }\n+    } catch (IllegalAccessException iae) {\n+      // ignored\n+    }\n+    return \"unknown\";\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(RotationOrderTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/RotationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.geometry.CardanEulerSingularityException;\n+import org.apache.commons.math.geometry.NotARotationMatrixException;\n+import org.apache.commons.math.geometry.Rotation;\n+import org.apache.commons.math.geometry.RotationOrder;\n+import org.apache.commons.math.geometry.Vector3D;\n+import org.apache.commons.math.util.MathUtils;\n+\n+import junit.framework.*;\n+\n+public class RotationTest\n+  extends TestCase {\n+\n+  public RotationTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testIdentity() {\n+\n+    Rotation r = Rotation.IDENTITY;\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(-1, 0, 0, 0, false);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(42, 0, 0, 0, true);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n+    checkAngle(r.getAngle(), 0);\n+\n+  }\n+\n+  public void testAxisAngle() {\n+\n+    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);\n+    double s = 1 / Math.sqrt(3);\n+    checkVector(r.getAxis(), new Vector3D(s, s, s));\n+    checkAngle(r.getAngle(), 2 * Math.PI / 3);\n+\n+    try {\n+      new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"unexpected exception\");\n+    }\n+\n+    r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);\n+    checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n+    checkAngle(r.getAngle(), 0.5 * Math.PI);\n+\n+    r = new Rotation(Vector3D.PLUS_J, Math.PI);\n+    checkVector(r.getAxis(), Vector3D.PLUS_J);\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);\n+\n+  }\n+\n+  public void testRevert() {\n+    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);\n+    Rotation reverted = r.revert();\n+    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);\n+    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);\n+    assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);\n+    assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);\n+  }\n+\n+  public void testVectorOnePair() {\n+\n+    Vector3D u = new Vector3D(3, 2, 1);\n+    Vector3D v = new Vector3D(-4, 2, 2);\n+    Rotation r = new Rotation(u, v);\n+    checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));\n+\n+    checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n+\n+    try {\n+        new Rotation(u, Vector3D.ZERO);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IllegalArgumentException e) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"unexpected exception\");\n+    }\n+\n+  }\n+\n+  public void testVectorTwoPairs() {\n+\n+    Vector3D u1 = new Vector3D(3, 0, 0);\n+    Vector3D u2 = new Vector3D(0, 5, 0);\n+    Vector3D v1 = new Vector3D(0, 0, 2);\n+    Vector3D v2 = new Vector3D(-2, 0, 2);\n+    Rotation r = new Rotation(u1, u2, v1, v2);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);\n+\n+    r = new Rotation(u1, u2, u1.negate(), u2.negate());\n+    Vector3D axis = r.getAxis();\n+    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {\n+      checkVector(axis, Vector3D.PLUS_K);\n+    } else {\n+      checkVector(axis, Vector3D.MINUS_K);\n+    }\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+    double sqrt = Math.sqrt(2) / 2;\n+    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,\n+                     new Vector3D(0.5, 0.5,  sqrt),\n+                     new Vector3D(0.5, 0.5, -sqrt));\n+    checkRotation(r, sqrt, 0.5, 0.5, 0);\n+\n+    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));\n+    checkRotation(r, sqrt, -sqrt, 0, 0);\n+\n+    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);\n+\n+    try {\n+        new Rotation(u1, u2, Vector3D.ZERO, v2);\n+        fail(\"an exception should have been thrown\");\n+    } catch (IllegalArgumentException e) {\n+      // expected behavior\n+    } catch (Exception e) {\n+        fail(\"unexpected exception\");\n+    }\n+\n+  }\n+\n+  public void testMatrix()\n+    throws NotARotationMatrixException {\n+\n+    try {\n+      new Rotation(new double[][] {\n+                     { 0.0, 1.0, 0.0 },\n+                     { 1.0, 0.0, 0.0 }\n+                   }, 1.0e-7);\n+    } catch (NotARotationMatrixException nrme) {\n+      // expected behavior\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+\n+    try {\n+      new Rotation(new double[][] {\n+                     {  0.445888,  0.797184, -0.407040 },\n+                     {  0.821760, -0.184320,  0.539200 },\n+                     { -0.354816,  0.574912,  0.737280 }\n+                   }, 1.0e-7);\n+    } catch (NotARotationMatrixException nrme) {\n+      // expected behavior\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+\n+    try {\n+        new Rotation(new double[][] {\n+                       {  0.4,  0.8, -0.4 },\n+                       { -0.4,  0.6,  0.7 },\n+                       {  0.8, -0.2,  0.5 }\n+                     }, 1.0e-15);\n+      } catch (NotARotationMatrixException nrme) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception caught: \" + e.getMessage());\n+      }\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 {  0.445888,  0.797184, -0.407040 },\n+                                 { -0.354816,  0.574912,  0.737280 },\n+                                 {  0.821760, -0.184320,  0.539200 }\n+                               }, 1.0e-10),\n+                  0.8, 0.288, 0.384, 0.36);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 {  0.539200,  0.737280,  0.407040 },\n+                                 {  0.184320, -0.574912,  0.797184 },\n+                                 {  0.821760, -0.354816, -0.445888 }\n+                              }, 1.0e-10),\n+                  0.36, 0.8, 0.288, 0.384);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 { -0.445888,  0.797184, -0.407040 },\n+                                 {  0.354816,  0.574912,  0.737280 },\n+                                 {  0.821760,  0.184320, -0.539200 }\n+                               }, 1.0e-10),\n+                  0.384, 0.36, 0.8, 0.288);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 { -0.539200,  0.737280,  0.407040 },\n+                                 { -0.184320, -0.574912,  0.797184 },\n+                                 {  0.821760,  0.354816,  0.445888 }\n+                               }, 1.0e-10),\n+                  0.288, 0.384, 0.36, 0.8);\n+\n+    double[][] m1 = { { 0.0, 1.0, 0.0 },\n+                      { 0.0, 0.0, 1.0 },\n+                      { 1.0, 0.0, 0.0 } };\n+    Rotation r = new Rotation(m1, 1.0e-7);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);\n+\n+    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+                      { 0.48293,  0.78164, -0.39474 },\n+                      { 0.27296,  0.29396,  0.91602 } };\n+    r = new Rotation(m2, 1.0e-12);\n+\n+    double[][] m3 = r.getMatrix();\n+    double d00 = m2[0][0] - m3[0][0];\n+    double d01 = m2[0][1] - m3[0][1];\n+    double d02 = m2[0][2] - m3[0][2];\n+    double d10 = m2[1][0] - m3[1][0];\n+    double d11 = m2[1][1] - m3[1][1];\n+    double d12 = m2[1][2] - m3[1][2];\n+    double d20 = m2[2][0] - m3[2][0];\n+    double d21 = m2[2][1] - m3[2][1];\n+    double d22 = m2[2][2] - m3[2][2];\n+\n+    assertTrue(Math.abs(d00) < 6.0e-6);\n+    assertTrue(Math.abs(d01) < 6.0e-6);\n+    assertTrue(Math.abs(d02) < 6.0e-6);\n+    assertTrue(Math.abs(d10) < 6.0e-6);\n+    assertTrue(Math.abs(d11) < 6.0e-6);\n+    assertTrue(Math.abs(d12) < 6.0e-6);\n+    assertTrue(Math.abs(d20) < 6.0e-6);\n+    assertTrue(Math.abs(d21) < 6.0e-6);\n+    assertTrue(Math.abs(d22) < 6.0e-6);\n+\n+    assertTrue(Math.abs(d00) > 4.0e-7);\n+    assertTrue(Math.abs(d01) > 4.0e-7);\n+    assertTrue(Math.abs(d02) > 4.0e-7);\n+    assertTrue(Math.abs(d10) > 4.0e-7);\n+    assertTrue(Math.abs(d11) > 4.0e-7);\n+    assertTrue(Math.abs(d12) > 4.0e-7);\n+    assertTrue(Math.abs(d20) > 4.0e-7);\n+    assertTrue(Math.abs(d21) > 4.0e-7);\n+    assertTrue(Math.abs(d22) > 4.0e-7);\n+\n+    for (int i = 0; i < 3; ++i) {\n+      for (int j = 0; j < 3; ++j) {\n+        double m3tm3 = m3[i][0] * m3[j][0]\n+                     + m3[i][1] * m3[j][1]\n+                     + m3[i][2] * m3[j][2];\n+        if (i == j) {\n+          assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);\n+        } else {\n+          assertTrue(Math.abs(m3tm3) < 1.0e-10);\n+        }\n+      }\n+    }\n+\n+    checkVector(r.applyTo(Vector3D.PLUS_I),\n+                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));\n+    checkVector(r.applyTo(Vector3D.PLUS_J),\n+                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));\n+    checkVector(r.applyTo(Vector3D.PLUS_K),\n+                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));\n+\n+    double[][] m4 = { { 1.0,  0.0,  0.0 },\n+                      { 0.0, -1.0,  0.0 },\n+                      { 0.0,  0.0, -1.0 } };\n+    r = new Rotation(m4, 1.0e-7);\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+    try {\n+      double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                        { 0.0, 1.0, 0.0 },\n+                        { 1.0, 0.0, 0.0 } };\n+      r = new Rotation(m5, 1.0e-7);\n+      fail(\"got \" + r + \", should have caught an exception\");\n+    } catch (NotARotationMatrixException e) {\n+      // expected\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  public void testAngles()\n+    throws CardanEulerSingularityException {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(CardanOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+    RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+          };\n+\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(EulerOrders[i],\n+                                      alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(EulerOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testSingularities() {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    double[] singularCardanAngle = { Math.PI / 2, -Math.PI / 2 };\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (int j = 0; j < singularCardanAngle.length; ++j) {\n+        Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);\n+        try {\n+          r.getAngles(CardanOrders[i]);\n+          fail(\"an exception should have been caught\");\n+        } catch (CardanEulerSingularityException cese) {\n+          // expected behavior\n+        } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+      }\n+    }\n+\n+    RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+          };\n+\n+    double[] singularEulerAngle = { 0, Math.PI };\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (int j = 0; j < singularEulerAngle.length; ++j) {\n+        Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);\n+        try {\n+          r.getAngles(EulerOrders[i]);\n+          fail(\"an exception should have been caught\");\n+        } catch (CardanEulerSingularityException cese) {\n+          // expected behavior\n+        } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+      }\n+    }\n+\n+\n+  }\n+\n+  public void testQuaternion() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    double n = 23.5;\n+    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),\n+                               n * r1.getQ2(), n * r1.getQ3(),\n+                               true);\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(u), r1.applyTo(u));\n+        }\n+      }\n+    }\n+\n+    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);\n+    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());\n+\n+  }\n+\n+  public void testCompose() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testComposeInverse() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyInverseTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testApplyInverseTo() {\n+\n+    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          r.applyInverseTo(r.applyTo(u));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = Rotation.IDENTITY;\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = new Rotation(Vector3D.PLUS_K, Math.PI);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+  }\n+\n+  private void checkVector(Vector3D v1, Vector3D v2) {\n+    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n+  }\n+\n+  private void checkAngle(double a1, double a2) {\n+    assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);\n+  }\n+\n+  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {\n+    assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(RotationTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+public abstract class Vector3DFormatAbstractTest extends TestCase {\n+ \n+    Vector3DFormat vector3DFormat = null;\n+    Vector3DFormat vector3DFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        vector3DFormat = Vector3DFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        vector3DFormatSquare = new Vector3DFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"{1; 1; 1}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        Vector3D c = new Vector3D(1.23, 1.43, 1.63);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeX() {\n+        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeY() {\n+        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeZ() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNonDefaultSetting() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = vector3DFormatSquare.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatVector3D() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        Vector3D c = new Vector3D(232.222, -342.33, 432.444);\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = Vector3DFormat.formatVector3D(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        Vector3D c = Vector3D.NaN;\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        Vector3D c = Vector3D.POSITIVE_INFINITY;\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void tesNegativeInfinity() {\n+        Vector3D c = Vector3D.NEGATIVE_INFINITY;\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseIgnoredWhitespace() {\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        assertEquals(expected, vector3DFormat.parseObject(source1, pos1));\n+        assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        assertEquals(expected, vector3DFormat.parseObject(source2, pos2));\n+        assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.NaN, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        try {\n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        try {\n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        Vector3DFormat cf = new Vector3DFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getFormat());\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new Vector3DFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"1; 1; 1}\", pos));\n+        assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"{1; 1 1}\", pos));\n+        assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"{1; 1; 1 \", pos));\n+        assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.util.Locale;\n+\n+\n+public class Vector3DFormatTest extends Vector3DFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.geometry.Vector3D;\n+\n+import junit.framework.*;\n+\n+public class Vector3DTest\n+  extends TestCase {\n+\n+  public Vector3DTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstructors() {\n+      double r = Math.sqrt(2) /2;\n+      checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)),\n+                  r, r * Math.sqrt(3), -2 * r);\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                              -3, Vector3D.MINUS_K),\n+                  2, 0, 3);\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                               5, Vector3D.PLUS_J,\n+                              -3, Vector3D.MINUS_K),\n+                  2, 5, 3);\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                               5, Vector3D.PLUS_J,\n+                               5, Vector3D.MINUS_J,\n+                               -3, Vector3D.MINUS_K),\n+                  2, 0, 3);\n+  }\n+\n+  public void testCoordinates() {\n+    Vector3D v = new Vector3D(1, 2, 3);\n+    assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);\n+    assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);\n+    assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);\n+  }\n+  \n+  public void testNorm1() {\n+    assertEquals(0.0, Vector3D.ZERO.getNorm1());\n+    assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);\n+  }\n+\n+  public void testNorm() {\n+      assertEquals(0.0, Vector3D.ZERO.getNorm());\n+      assertEquals(Math.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);\n+    }\n+\n+  public void testNormInf() {\n+      assertEquals(0.0, Vector3D.ZERO.getNormInf());\n+      assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0);\n+    }\n+\n+  public void testDistance1() {\n+      Vector3D v1 = new Vector3D(1, -2, 3);\n+      Vector3D v2 = new Vector3D(-4, 2, 0);\n+      assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+      assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12);\n+      assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12);\n+  }\n+\n+  public void testDistance() {\n+      Vector3D v1 = new Vector3D(1, -2, 3);\n+      Vector3D v2 = new Vector3D(-4, 2, 0);\n+      assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+      assertEquals(Math.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);\n+      assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);\n+  }\n+\n+  public void testDistanceSq() {\n+      Vector3D v1 = new Vector3D(1, -2, 3);\n+      Vector3D v2 = new Vector3D(-4, 2, 0);\n+      assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+      assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12);\n+      assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2),\n+                   Vector3D.distanceSq(v1, v2), 1.0e-12);\n+  }\n+\n+  public void testDistanceInf() {\n+      Vector3D v1 = new Vector3D(1, -2, 3);\n+      Vector3D v2 = new Vector3D(-4, 2, 0);\n+      assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+      assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12);\n+      assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12);\n+  }\n+\n+  public void testSubtract() {\n+\n+    Vector3D v1 = new Vector3D(1, 2, 3);\n+    Vector3D v2 = new Vector3D(-3, -2, -1);\n+    v1 = v1.subtract(v2);\n+    checkVector(v1, 4, 4, 4);\n+\n+    checkVector(v2.subtract(v1), -7, -6, -5);\n+    checkVector(v2.subtract(3, v1), -15, -14, -13);\n+\n+  }\n+\n+  public void testAdd() {\n+    Vector3D v1 = new Vector3D(1, 2, 3);\n+    Vector3D v2 = new Vector3D(-3, -2, -1);\n+    v1 = v1.add(v2);\n+    checkVector(v1, -2, 0, 2);\n+\n+    checkVector(v2.add(v1), -5, -2, 1);\n+    checkVector(v2.add(3, v1), -9, -2, 5);\n+\n+  }\n+\n+  public void testScalarProduct() {\n+    Vector3D v = new Vector3D(1, 2, 3);\n+    v = v.scalarMultiply(3);\n+    checkVector(v, 3, 6, 9);\n+\n+    checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);\n+\n+  }\n+\n+  public void testVectorialProducts() {\n+    Vector3D v1 = new Vector3D(2, 1, -4);\n+    Vector3D v2 = new Vector3D(3, 1, -1);\n+\n+    assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n+\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    checkVector(v3, 3, -10, -1);\n+\n+    assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n+    assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n+\n+  }\n+\n+  public void testAngular() {\n+\n+    assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);\n+\n+    Vector3D u = new Vector3D(-1, 1, -1);\n+    assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);\n+    assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);\n+\n+  }\n+\n+  public void testAngularSeparation() {\n+    Vector3D v1 = new Vector3D(2, -1, 4);\n+\n+    Vector3D  k = v1.normalize();\n+    Vector3D  i = k.orthogonal();\n+    Vector3D v2 = k.scalarMultiply(Math.cos(1.2)).add(i.scalarMultiply(Math.sin(1.2)));\n+\n+    assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n+\n+  }\n+\n+  public void testNormalize() {\n+    assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);\n+    try {\n+        Vector3D.ZERO.normalize();\n+        fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException ae) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+  }\n+\n+  public void testOrthogonal() {\n+      Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);\n+      assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);\n+      Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);\n+      assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);\n+      Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);\n+      assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);\n+      try {\n+          new Vector3D(0, 0, 0).orthogonal();\n+          fail(\"an exception should have been thrown\");\n+      } catch (ArithmeticException ae) {\n+          // expected behavior\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      }\n+  }\n+\n+  public void testAngle() {\n+     assertEquals(0.22572612855273393616, \n+                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),\n+                  1.0e-12);\n+     assertEquals(7.98595620686106654517199e-8, \n+                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),\n+                  1.0e-12);\n+     assertEquals(3.14159257373023116985197793156, \n+                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),\n+                  1.0e-12);\n+     try {\n+         Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);\n+         fail(\"an exception should have been thrown\");\n+     } catch (ArithmeticException ae) {\n+         // expected behavior\n+     } catch (Exception e) {\n+         fail(\"wrong exception caught: \" + e.getMessage());\n+     }\n+  }\n+\n+  private void checkVector(Vector3D v, double x, double y, double z) {\n+      assertEquals(x, v.getX(), 1.0e-12);\n+      assertEquals(y, v.getY(), 1.0e-12);\n+      assertEquals(z, v.getZ(), 1.0e-12);\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(Vector3DTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link Array2DRowRealMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class Array2DRowRealMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public Array2DRowRealMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(Array2DRowRealMatrixTest.class);\n+        suite.setName(\"Array2DRowRealMatrix Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());\n+        assertEquals(m2,m1);\n+        Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);\n+        assertEquals(m4,m3);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);\n+        TestUtils.assertEquals(\"m-n = m + -n\",m.subtract(m2),\n+            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+        try {\n+            m.subtract(new Array2DRowRealMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n+        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        TestUtils.assertEquals(\"inverse multiply\",m.multiply(mInv),\n+            identity,entryTolerance);\n+        TestUtils.assertEquals(\"inverse multiply\",mInv.multiply(m),\n+            identity,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m.multiply(identity),\n+            m,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",identity.multiply(mInv),\n+            mInv,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m2.multiply(identity),\n+            m2,entryTolerance); \n+        try {\n+            m.multiply(new Array2DRowRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }   \n+    \n+    //Additional Test for Array2DRowRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new Array2DRowRealMatrix(d3);   \n+       RealMatrix m4 = new Array2DRowRealMatrix(d4);\n+       RealMatrix m5 = new Array2DRowRealMatrix(d5);\n+       TestUtils.assertEquals(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new Array2DRowRealMatrix(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new Array2DRowRealMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        TestUtils.assertEquals(\"scalar add\",new Array2DRowRealMatrix(testDataPlus2),\n+            m.scalarAdd(2d),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new Array2DRowRealMatrix(id);\n+        TestUtils.assertEquals(\"identity operate\", testVector,\n+                    m.operate(testVector), entryTolerance);\n+        TestUtils.assertEquals(\"identity operate\", testVector,\n+                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);\n+        m = new Array2DRowRealMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new Array2DRowRealMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        }, false);\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = new Array2DRowRealMatrix(testData2);\n+        RealMatrix mt = new Array2DRowRealMatrix(testData2T);\n+        TestUtils.assertEquals(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(testVector),\n+                    preMultTest, normTolerance);\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(new ArrayRealVector(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new Array2DRowRealMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new Array2DRowRealMatrix(d3);   \n+        RealMatrix m4 = new Array2DRowRealMatrix(d4);\n+        RealMatrix m5 = new Array2DRowRealMatrix(d5);\n+        TestUtils.assertEquals(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n+        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);\n+        TestUtils.assertEquals(\"inverse multiply\",m.preMultiply(mInv),\n+                identity,entryTolerance);\n+        TestUtils.assertEquals(\"inverse multiply\",mInv.preMultiply(m),\n+                identity,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m.preMultiply(identity),\n+                m,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",identity.preMultiply(mInv),\n+                mInv,entryTolerance);\n+        try {\n+            m.preMultiply(new Array2DRowRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        TestUtils.assertEquals(\"get row\",m.getRow(0),testDataRow1,entryTolerance);\n+        TestUtils.assertEquals(\"get col\",m.getColumn(2),testDataCol3,entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new Array2DRowRealMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new Array2DRowRealMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new Array2DRowRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new Array2DRowRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testCopySubMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                             new double[1][1] :\n+                             new double[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                    new double[1][1] :\n+                    new double[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);\n+        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetRowMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, \n+                m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, \n+                m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayRealVector(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();\n+        Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        assertEquals(\"Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+        m = new Array2DRowRealMatrix();\n+        assertEquals(\"Array2DRowRealMatrix{}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();\n+        try {\n+            m2.setSubMatrix(testData,0,1);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        try {\n+            m2.setSubMatrix(testData,1,0);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+    \n+    \n+    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n+        @Override\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n+        private int count = 0;\n+        @Override\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   \n+        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n+                lowerData.length != upperData.length\n+                || lowerData.length != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                if (j < i) {\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = 0d;\n+                } else if (i == j) {\n+                    lowerData[i][j] = 1d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                } else {\n+                    lowerData[i][j] = 0d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        int m = matrix.getColumnDimension();\n+        double out[][] = new double[m][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n+            }\n+        }\n+        return new Array2DRowRealMatrix(out);\n+    }\n+    \n+//    /** Useful for debugging */\n+//    private void dumpMatrix(RealMatrix m) {\n+//          for (int i = 0; i < m.getRowDimension(); i++) {\n+//              String os = \"\";\n+//              for (int j = 0; j < m.getColumnDimension(); j++) {\n+//                  os += m.getEntry(i, j) + \" \";\n+//              }\n+//              System.out.println(os);\n+//          }\n+//    }\n+        \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link ArrayFieldVector} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ArrayFieldVectorTest extends TestCase {\n+\n+    // \n+    protected Fraction[][] ma1 = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6)},\n+            {new Fraction(7), new Fraction(8), new Fraction(9)}\n+    };\n+    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};\n+    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};\n+    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),\n+                                  new Fraction(4), new Fraction(5), new Fraction(6),\n+                                  new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};\n+    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),\n+                                  new Fraction(4), new Fraction(5), new Fraction(6),\n+                                  new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[][] mat1 = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6)},\n+            {new Fraction(7), new Fraction(8), new Fraction(9)}\n+    };\n+\n+    // Testclass to test the FieldVector<Fraction> interface \n+    // only with enough content to support the test\n+    public static class FieldVectorTestImpl<T extends FieldElement<T>>\n+        implements FieldVector<T>, Serializable {\n+\n+        private static final long serialVersionUID = 3970959016014158539L;\n+\n+        private final Field<T> field;\n+\n+        /** Entries of the vector. */\n+        protected T[] data;\n+\n+        /** Build an array of elements.\n+         * @param length size of the array to build\n+         * @return a new array\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        private T[] buildArray(final int length) {\n+            return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        }\n+\n+        public FieldVectorTestImpl(T[] d) {\n+            field = d[0].getField();\n+            data = d.clone();\n+        }\n+\n+        public Field<T> getField() {\n+            return field;\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public FieldVector<T> copy() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapAdd(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapAddToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapSubtract(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapSubtractToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapMultiply(T d) {\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].multiply(d);\n+            }\n+            return new FieldVectorTestImpl<T>(out);\n+        }\n+\n+        public FieldVector<T> mapMultiplyToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapDivide(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapDivideToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public T[] getData() {\n+            return data.clone();\n+        }\n+\n+        public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v.getEntry(i)));\n+            }\n+            return dot;\n+        }\n+\n+        public T dotProduct(T[] v) throws IllegalArgumentException {\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v[i]));\n+            }\n+            return dot;\n+        }\n+\n+        public FieldVector<T> projection(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> projection(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldMatrix<T> outerProduct(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public T getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public FieldVector<T> append(FieldVector<T> v) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> append(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> append(T[] a) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, T value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, FieldVector<T> v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, T[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(T value) {\n+            throw unsupported();\n+        }\n+\n+        public T[] toArray() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayFieldVectorTest.class);\n+        suite.setName(\"ArrayFieldVector<Fraction> Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance());\n+        assertEquals(0, v0.getDimension());\n+\n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7);\n+        assertEquals(7, v1.getDimension());\n+        assertEquals(new Fraction(0), v1.getEntry(6));\n+\n+        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100));\n+        assertEquals(5, v2.getDimension());\n+        assertEquals(new Fraction(123, 100), v2.getEntry(4));\n+\n+        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);\n+        assertEquals(3, v3.getDimension());\n+        assertEquals(new Fraction(2), v3.getEntry(1));\n+\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);\n+        assertEquals(2, v4.getDimension());\n+        assertEquals(new Fraction(4), v4.getEntry(0));\n+        try {\n+            new ArrayFieldVector<Fraction>(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1);\n+        assertEquals(9, v5_i.getDimension());\n+        assertEquals(new Fraction(9), v5_i.getEntry(8));\n+\n+        ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1);\n+        assertEquals(9, v5.getDimension());\n+        assertEquals(new Fraction(9), v5.getEntry(8));\n+\n+        ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2);\n+        assertEquals(2, v6.getDimension());\n+        assertEquals(new Fraction(4), v6.getEntry(0));\n+        try {\n+            new ArrayFieldVector<Fraction>(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1);\n+        assertEquals(7, v7.getDimension());\n+        assertEquals(new Fraction(0), v7.getEntry(6));\n+\n+        FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);\n+\n+        ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i);\n+        assertEquals(3, v7_2.getDimension());\n+        assertEquals(new Fraction(2), v7_2.getEntry(1));\n+\n+        ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true);\n+        assertEquals(7, v8.getDimension());\n+        assertEquals(new Fraction(0), v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false);\n+        assertEquals(7, v8_2.getDimension());\n+        assertEquals(new Fraction(0), v8_2.getEntry(6));\n+        assertEquals(v1.data, v8_2.data);\n+\n+        ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3);\n+        assertEquals(10, v9.getDimension());\n+        assertEquals(new Fraction(1), v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+\n+        FieldVector<Fraction> v_append_1 = v1.append(v2);\n+        assertEquals(6, v_append_1.getDimension());\n+        assertEquals(new Fraction(4), v_append_1.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));\n+        assertEquals(4, v_append_2.getDimension());\n+        assertEquals(new Fraction(2), v_append_2.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_3 = v1.append(vec2);\n+        assertEquals(6, v_append_3.getDimension());\n+        assertEquals(new Fraction(4), v_append_3.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_4 = v1.append(v2_t);\n+        assertEquals(6, v_append_4.getDimension());\n+        assertEquals(new Fraction(4), v_append_4.getEntry(3));\n+\n+        FieldVector<Fraction> v_copy = v1.copy();\n+        assertEquals(3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        Fraction[] a_frac = v1.toArray();\n+        assertEquals(3, a_frac.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_frac);\n+\n+\n+//      ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone();\n+//      assertEquals(3, vout4.getDimension());\n+//      assertEquals(v1.data, vout4.data);\n+\n+\n+        FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);\n+        assertEquals(3, vout5.getDimension());\n+        assertEquals(new Fraction(5), vout5.getEntry(1));\n+        try {\n+            v4.getSubVector(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy();\n+        v_set1.setEntry(1, new Fraction(11));\n+        assertEquals(new Fraction(11), v_set1.getEntry(1));\n+        try {\n+            v_set1.setEntry(3, new Fraction(11));\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(new Fraction(1), v_set2.getEntry(3));\n+        assertEquals(new Fraction(7), v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy();\n+        v_set3.set(new Fraction(13));\n+        assertEquals(new Fraction(13), v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy();\n+        v_set4.setSubVector(3, v2_t);\n+        assertEquals(new Fraction(4), v_set4.getEntry(3));\n+        assertEquals(new Fraction(7), v_set4.getEntry(6));\n+        try {\n+            v_set4.setSubVector(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();       \n+        ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.setEntry(0, new Fraction(11, 10));\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));\n+        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        checkArray(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(new Fraction(2));\n+        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        checkArray(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));\n+        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        checkArray(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));\n+        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        checkArray(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));\n+        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        checkArray(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));\n+        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        checkArray(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));\n+        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};\n+        checkArray(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));\n+        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};\n+        checkArray(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInv = v1.mapInv();\n+        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};\n+        checkArray(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};\n+        checkArray(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n+        new ArrayFieldVector<Fraction>(vec_null);\n+\n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+\n+        //octave =  v1 + v2\n+        ArrayFieldVector<Fraction> v_add = v1.add(v2);\n+        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        checkArray(\"compare vect\" ,v_add.getData(),result_add);\n+\n+        FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2);\n+        FieldVector<Fraction> v_add_i = v1.add(vt2);\n+        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        checkArray(\"compare vect\" ,v_add_i.getData(),result_add_i);\n+\n+        //octave =  v1 - v2\n+        ArrayFieldVector<Fraction> v_subtract = v1.subtract(v2);\n+        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        checkArray(\"compare vect\" ,v_subtract.getData(),result_subtract);\n+\n+        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);\n+        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        checkArray(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i);\n+\n+        // octave v1 .* v2\n+        ArrayFieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);\n+        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        checkArray(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply);\n+\n+        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        checkArray(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2);\n+\n+        // octave v1 ./ v2\n+        ArrayFieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);\n+        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};\n+        checkArray(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide);\n+\n+        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};\n+        checkArray(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2);\n+\n+        // octave  dot(v1,v2)\n+        Fraction dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(32), dot);\n+\n+        // octave  dot(v1,v2_t)\n+        Fraction dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+\n+        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+\n+        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+\n+        ArrayFieldVector<Fraction> v_projection = v1.projection(v2);\n+        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n+        checkArray(\"compare vect\", v_projection.getData(), result_projection);\n+\n+        FieldVector<Fraction> v_projection_2 = v1.projection(v2_t);\n+        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n+        checkArray(\"compare vect\", v_projection_2.getData(), result_projection_2);\n+\n+    }  \n+\n+    public void testMisc() { \n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n+        FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         Fraction[] dout1 = v1.copyOut();\n+        assertEquals(3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    public void testSerial()  {\n+        ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);\n+        assertEquals(v,TestUtils.serializeAndRecover(v));\n+    }\n+  \n+    /** verifies that two vectors are equals */\n+    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link ArrayRealVector} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ArrayRealVectorTest extends TestCase {\n+\n+    // \n+    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n+    protected double[] vec1 = {1d, 2d, 3d};\n+    protected double[] vec2 = {4d, 5d, 6d};\n+    protected double[] vec3 = {7d, 8d, 9d};\n+    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[] vec_null = {0d, 0d, 0d};\n+    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    // Testclass to test the RealVector interface \n+    // only with enough content to support the test\n+    public static class RealVectorTestImpl implements RealVector, Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4715341047369582908L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public RealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector copy() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAdd(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtract(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapMultiply(double d) {\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * d;\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivide(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPow(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLogToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1p() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1pToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCoshToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbs() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbsToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeil() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeilToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloor() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloorToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRint() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRintToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignum() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignumToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double[] getData() {\n+            return data.clone();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+\n+        public double dotProduct(double[] v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v[i];\n+            }\n+            return dot;\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector unitVector() {\n+            throw unsupported();\n+        }\n+\n+        public void unitize() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(double value) {\n+            throw unsupported();\n+        }\n+\n+        public double[] toArray() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayRealVectorTest.class);\n+        suite.setName(\"ArrayRealVector Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        ArrayRealVector v0 = new ArrayRealVector();\n+        assertEquals(\"testData len\", 0, v0.getDimension());\n+\n+        ArrayRealVector v1 = new ArrayRealVector(7);\n+        assertEquals(\"testData len\", 7, v1.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+\n+        ArrayRealVector v2 = new ArrayRealVector(5, 1.23);\n+        assertEquals(\"testData len\", 5, v2.getDimension());\n+        assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n+\n+        ArrayRealVector v3 = new ArrayRealVector(vec1);\n+        assertEquals(\"testData len\", 3, v3.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+\n+        ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);\n+        assertEquals(\"testData len\", 2, v4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        try {\n+            new ArrayRealVector(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVector v5_i = new ArrayRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+\n+        ArrayRealVector v5 = new ArrayRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+\n+        ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);\n+        assertEquals(\"testData len\", 2, v6.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0));\n+        try {\n+            new ArrayRealVector(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v7 = new ArrayRealVector(v1);\n+        assertEquals(\"testData len\", 7, v7.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+\n+        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);\n+\n+        ArrayRealVector v7_2 = new ArrayRealVector(v7_i);\n+        assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+\n+        ArrayRealVector v8 = new ArrayRealVector(v1, true);\n+        assertEquals(\"testData len\", 7, v8.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        ArrayRealVector v8_2 = new ArrayRealVector(v1, false);\n+        assertEquals(\"testData len\", 7, v8_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6));\n+        assertEquals(\"testData same object \", v1.data, v8_2.data);\n+\n+        ArrayRealVector v9 = new ArrayRealVector(v1, v3);\n+        assertEquals(\"testData len\", 10, v9.getDimension());\n+        assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+        ArrayRealVector v2 = new ArrayRealVector(vec2);\n+        ArrayRealVector v4 = new ArrayRealVector(vec4);\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        RealVector v_append_1 = v1.append(v2);\n+        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+\n+        RealVector v_append_2 = v1.append(2.0);\n+        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+\n+        RealVector v_append_3 = v1.append(vec2);\n+        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+\n+        RealVector v_append_4 = v1.append(v2_t);\n+        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+\n+        RealVector v_copy = v1.copy();\n+        assertEquals(\"testData len\", 3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        double[] a_double = v1.toArray();\n+        assertEquals(\"testData len\", 3, a_double.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_double);\n+\n+\n+//      ArrayRealVector vout4 = (ArrayRealVector) v1.clone();\n+//      assertEquals(\"testData len\", 3, vout4.getDimension());\n+//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n+\n+\n+        RealVector vout5 = v4.getSubVector(3, 3);\n+        assertEquals(\"testData len\", 3, vout5.getDimension());\n+        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        try {\n+            v4.getSubVector(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set1 = (ArrayRealVector) v1.copy();\n+        v_set1.setEntry(1, 11.0);\n+        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        try {\n+            v_set1.setEntry(3, 11.0);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set2 = (ArrayRealVector) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set3 = (ArrayRealVector) v1.copy();\n+        v_set3.set(13.0);\n+        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set4 = (ArrayRealVector) v4.copy();\n+        v_set4.setSubVector(3, v2_t);\n+        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        try {\n+            v_set4.setSubVector(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        ArrayRealVector vout10 = (ArrayRealVector) v1.copy();       \n+        ArrayRealVector vout10_2 = (ArrayRealVector) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.setEntry(0, 1.1);\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAdd = v1.mapAdd(2.0d);\n+        double[] result_mapAdd = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData(),normTolerance);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(2.0d);\n+        double[] result_mapAddToSelf = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtract = v1.mapSubtract(2.0d);\n+        double[] result_mapSubtract = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);\n+        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiply = v1.mapMultiply(2.0d);\n+        double[] result_mapMultiply = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);\n+        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivide = v1.mapDivide(2.0d);\n+        double[] result_mapDivide = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(2.0d);\n+        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPow = v1.mapPow(2.0d);\n+        double[] result_mapPow = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPow,v_mapPow.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPowToSelf = v1.copy();\n+        v_mapPowToSelf.mapPowToSelf(2.0d);\n+        double[] result_mapPowToSelf = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExp = v1.mapExp();\n+        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExpToSelf = v1.copy();\n+        v_mapExpToSelf.mapExpToSelf();\n+        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n+\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1 = v1.mapExpm1();\n+        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1ToSelf = v1.copy();\n+        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog = v1.mapLog();\n+        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLogToSelf = v1.copy();\n+        v_mapLogToSelf.mapLogToSelf();\n+        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n+\n+        //octave =  log10(v1)\n+        RealVector v_mapLog10 = v1.mapLog10();\n+        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog10ToSelf = v1.copy();\n+        v_mapLog10ToSelf.mapLog10ToSelf();\n+        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1p = v1.mapLog1p();\n+        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1pToSelf = v1.copy();\n+        v_mapLog1pToSelf.mapLog1pToSelf();\n+        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCosh = v1.mapCosh();\n+        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCoshToSelf = v1.copy();\n+        v_mapCoshToSelf.mapCoshToSelf();\n+        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinh = v1.mapSinh();\n+        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinhToSelf = v1.copy();\n+        v_mapSinhToSelf.mapSinhToSelf();\n+        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanh = v1.mapTanh();\n+        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanhToSelf = v1.copy();\n+        v_mapTanhToSelf.mapTanhToSelf();\n+        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCos = v1.mapCos();\n+        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCosToSelf = v1.copy();\n+        v_mapCosToSelf.mapCosToSelf();\n+        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSin = v1.mapSin();\n+        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSinToSelf = v1.copy();\n+        v_mapSinToSelf.mapSinToSelf();\n+        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTan = v1.mapTan();\n+        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTanToSelf = v1.copy();\n+        v_mapTanToSelf.mapTanToSelf();\n+        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n+\n+        double[] vat_a = {0d, 0.5d, 1.0d};\n+        ArrayRealVector vat = new ArrayRealVector(vat_a);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcos = vat.mapAcos();\n+        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcosToSelf = vat.copy();\n+        v_mapAcosToSelf.mapAcosToSelf();\n+        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsin = vat.mapAsin();\n+        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsinToSelf = vat.copy();\n+        v_mapAsinToSelf.mapAsinToSelf();        \n+        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtan = vat.mapAtan();\n+        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtanToSelf = vat.copy();\n+        v_mapAtanToSelf.mapAtanToSelf();\n+        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInv = v1.mapInv();\n+        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n+\n+        double[] abs_a = {-1.0d, 0.0d, 1.0d};\n+        ArrayRealVector abs_v = new ArrayRealVector(abs_a);\n+\n+        //octave =  abs(abs_v)\n+        RealVector v_mapAbs = abs_v.mapAbs();\n+        double[] result_mapAbs = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n+\n+        //octave = abs(abs_v)\n+        RealVector v_mapAbsToSelf = abs_v.copy();\n+        v_mapAbsToSelf.mapAbsToSelf();\n+        double[] result_mapAbsToSelf = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n+\n+        //octave =   sqrt(v1)\n+        RealVector v_mapSqrt = v1.mapSqrt();\n+        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n+\n+        //octave =  sqrt(v1)\n+        RealVector v_mapSqrtToSelf = v1.copy();\n+        v_mapSqrtToSelf.mapSqrtToSelf();\n+        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n+\n+        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};\n+        ArrayRealVector cbrt_v = new ArrayRealVector(cbrt_a);\n+\n+        //octave =  ???\n+        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapCbrtToSelf = cbrt_v.copy();\n+        v_mapCbrtToSelf.mapCbrtToSelf();\n+        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n+\n+        double[] ceil_a = {-1.1d, 0.9d, 1.1d};\n+        ArrayRealVector ceil_v = new ArrayRealVector(ceil_a);\n+\n+        //octave =  ceil(ceil_v)\n+        RealVector v_mapCeil = ceil_v.mapCeil();\n+        double[] result_mapCeil = {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n+\n+        //octave = ceil(ceil_v)\n+        RealVector v_mapCeilToSelf = ceil_v.copy();\n+        v_mapCeilToSelf.mapCeilToSelf();\n+        double[] result_mapCeilToSelf =  {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n+\n+        //octave =  floor(ceil_v)\n+        RealVector v_mapFloor = ceil_v.mapFloor();\n+        double[] result_mapFloor = {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n+\n+        //octave = floor(ceil_v)\n+        RealVector v_mapFloorToSelf = ceil_v.copy();\n+        v_mapFloorToSelf.mapFloorToSelf();\n+        double[] result_mapFloorToSelf =  {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapRint = ceil_v.mapRint();\n+        double[] result_mapRint = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapRintToSelf = ceil_v.copy();\n+        v_mapRintToSelf.mapRintToSelf();\n+        double[] result_mapRintToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapSignum = ceil_v.mapSignum();\n+        double[] result_mapSignum = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapSignumToSelf = ceil_v.copy();\n+        v_mapSignumToSelf.mapSignumToSelf();\n+        double[] result_mapSignumToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n+\n+\n+        // Is with the used resolutions of limited value as test\n+        //octave =  ???\n+        RealVector v_mapUlp = ceil_v.mapUlp();\n+        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapUlpToSelf = ceil_v.copy();\n+        v_mapUlpToSelf.mapUlpToSelf();\n+        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+        ArrayRealVector v2 = new ArrayRealVector(vec2);\n+        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n+\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        //octave =  sqrt(sumsq(v1))\n+        double d_getNorm = v1.getNorm();\n+        assertEquals(\"compare values  \", 3.7416573867739413,d_getNorm);\n+\n+        double d_getL1Norm = v1.getL1Norm();\n+        assertEquals(\"compare values  \",6.0, d_getL1Norm);\n+\n+        double d_getLInfNorm = v1.getLInfNorm();\n+        assertEquals(\"compare values  \",6.0, d_getLInfNorm);\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist = v1.getDistance(v2);\n+        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist_2 = v1.getDistance(v2_t);\n+        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+\n+        //octave =  ???\n+        double d_getL1Distance = v1. getL1Distance(v2);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+\n+        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+\n+        //octave =  ???\n+        double d_getLInfDistance = v1. getLInfDistance(v2);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+\n+        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+\n+        //octave =  v1 + v2\n+        ArrayRealVector v_add = v1.add(v2);\n+        double[] result_add = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+\n+        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n+        RealVector v_add_i = v1.add(vt2);\n+        double[] result_add_i = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n+\n+        //octave =  v1 - v2\n+        ArrayRealVector v_subtract = v1.subtract(v2);\n+        double[] result_subtract = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        RealVector v_subtract_i = v1.subtract(vt2);\n+        double[] result_subtract_i = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n+        double[] result_ebeMultiply = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n+        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        double dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",32d, dot);\n+\n+        // octave  dot(v1,v2_t)\n+        double dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",32d, dot_2);\n+\n+        RealMatrix m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+\n+        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+\n+        RealVector v_unitVector = v1.unitVector();\n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n+\n+        try {\n+            v_null.unitVector();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n+        v_unitize.unitize();\n+        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n+        try {\n+            v_null.unitize();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_projection = v1.projection(v2);\n+        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n+\n+        RealVector v_projection_2 = v1.projection(v2_t);\n+        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n+\n+    }  \n+\n+    public void testMisc() { \n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+        ArrayRealVector v4 = new ArrayRealVector(vec4);\n+        RealVector v4_2 = new ArrayRealVector(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         double[] dout1 = v1.copyOut();\n+        assertEquals(\"testData len\", 3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n+\n+        assertFalse(v.isNaN());\n+        v.setEntry(1, Double.NaN);\n+        assertTrue(v.isNaN());\n+\n+        assertFalse(v.isInfinite());\n+        v.setEntry(0, Double.POSITIVE_INFINITY);\n+        assertFalse(v.isInfinite());\n+        v.setEntry(1, 1);\n+        assertTrue(v.isInfinite());\n+\n+        v.setEntry(0, 0);\n+        assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));\n+        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));\n+\n+        assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+                     new ArrayRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());\n+\n+        assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n+                   new ArrayRealVector(new double[] { 0, 1, 2 }).hashCode());\n+\n+    }\n+\n+    public void testSerial()  {\n+        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n+        assertEquals(v,TestUtils.serializeAndRecover(v));\n+    }\n+    \n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.linear.BiDiagonalTransformer;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class BiDiagonalTransformerTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private double[][] testNonSquare = {\n+        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },\n+        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },\n+        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },\n+        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },\n+    };\n+\n+    public BiDiagonalTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testDimensions() {\n+        checkdimensions(MatrixUtils.createRealMatrix(testSquare));\n+        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n+    }\n+\n+    private void checkdimensions(RealMatrix matrix) {\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);\n+        assertEquals(m, transformer.getU().getRowDimension());\n+        assertEquals(m, transformer.getU().getColumnDimension());\n+        assertEquals(m, transformer.getB().getRowDimension());\n+        assertEquals(n, transformer.getB().getColumnDimension());\n+        assertEquals(n, transformer.getV().getRowDimension());\n+        assertEquals(n, transformer.getV().getColumnDimension());\n+\n+    }\n+\n+    public void testAEqualUSVt() {\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n+    }\n+\n+    private void checkAEqualUSVt(RealMatrix matrix) {\n+        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);\n+        RealMatrix u = transformer.getU();\n+        RealMatrix b = transformer.getB();\n+        RealMatrix v = transformer.getV();\n+        double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 1.0e-14);\n+    }\n+\n+    public void testUOrthogonal() {\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());\n+    }\n+\n+    public void testVOrthogonal() {\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);        \n+    }\n+\n+    public void testBBiDiagonal() {\n+        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());\n+    }\n+\n+    private void checkBiDiagonal(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if (rows < cols) {\n+                    if ((i < j) || (i > j + 1)) {\n+                        assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    }                    \n+                } else {\n+                    if ((i < j - 1) || (i > j)) {\n+                        assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testMatricesValues() {\n+       BiDiagonalTransformer transformer =\n+            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));\n+       final double s17 = Math.sqrt(17.0);\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                {  -8 / (5 * s17), 19 / (5 * s17) },\n+                { -19 / (5 * s17), -8 / (5 * s17) }\n+        });\n+        RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -3 * s17 / 5, 32 * s17 / 85 },\n+                {      0.0,     -5 * s17 / 17 }\n+        });\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1.0,  0.0 },\n+                { 0.0, -1.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix u = transformer.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);\n+        RealMatrix b = transformer.getB();\n+        assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);\n+        RealMatrix v = transformer.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == transformer.getU());\n+        assertTrue(b == transformer.getB());\n+        assertTrue(v == transformer.getV());\n+        \n+    }\n+\n+    public void testUpperOrLower() {\n+        assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());\n+        assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());\n+        assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(BiDiagonalTransformerTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/BigMatrixImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.math.BigDecimal;\n+\n+\n+/**\n+ * Test cases for the {@link BigMatrixImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+@Deprecated\n+public final class BigMatrixImplTest extends TestCase {\n+    \n+    // Test data for String constructors\n+    protected  String[][] testDataString = { {\"1\",\"2\",\"3\"}, {\"2\",\"5\",\"3\"}, {\"1\",\"0\",\"8\"} };\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+            {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+            {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public BigMatrixImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BigMatrixImplTest.class);\n+        suite.setName(\"BigMatrixImpl Tests\");\n+        return suite;\n+    }\n+\n+    public static final double[] asDouble(BigDecimal[] data) {\n+        double d[] = new double[data.length];\n+        for (int i=0;i<d.length;i++) {\n+            d[i] = data[i].doubleValue();\n+        }\n+        return d;\n+    }\n+\n+    public static final double[][] asDouble(BigDecimal[][] data) {\n+        double d[][] = new double[data.length][data[0].length];\n+        for (int i=0;i<d.length;i++) {\n+            for (int j=0;j<d[i].length;j++)\n+            d[i][j] = data[i][j].doubleValue();\n+        }\n+        return d;\n+    }\n+\n+    public static final BigDecimal[] asBigDecimal(double [] data) {\n+        BigDecimal d[] = new BigDecimal[data.length];\n+        for (int i=0;i<d.length;i++) {\n+            d[i] = new BigDecimal(data[i]);\n+        }\n+        return d;\n+    }\n+\n+    public static final BigDecimal[][] asBigDecimal(double [][] data) {\n+        BigDecimal d[][] = new BigDecimal[data.length][data[0].length];\n+        for (int i=0;i<d.length;i++) {\n+            for (int j=0;j<data[i].length;j++) {\n+                d[i][j] = new BigDecimal(data[i][j]);\n+            }\n+        }\n+        return d;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    }  \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        BigMatrixImpl m1 = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());\n+        assertEquals(m2,m1);\n+        BigMatrixImpl m3 = new BigMatrixImpl(testData);\n+        BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);\n+        assertEquals(m4,m3);\n+    }\n+    \n+    /** test constructors */\n+    public void testConstructors() {\n+        BigMatrix m1 = new BigMatrixImpl(testData);\n+        BigMatrix m2 = new BigMatrixImpl(testDataString);\n+        BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));\n+        BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);\n+        BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);\n+        assertClose(\"double, string\", m1, m2, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal\", m1, m3, Double.MIN_VALUE);\n+        assertClose(\"string, BigDecimal\", m2, m3, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal/true\", m1, m4, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal/false\", m1, m5, Double.MIN_VALUE);\n+        try {\n+            new BigMatrixImpl(new String[][] {{\"0\", \"hello\", \"1\"}});\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {\n+            // expected\n+        }\n+        try {\n+            new BigMatrixImpl(new String[][] {});\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            new BigMatrixImpl(new String[][] {{},{}});\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            new BigMatrixImpl(new String[][] {{\"a\", \"b\"},{\"c\"}});\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            new BigMatrixImpl(0, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            new BigMatrixImpl(1, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /** test add */\n+    public void testAdd() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n+        BigMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = asDouble(mPlusMInv.getData());\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm().doubleValue(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm().doubleValue(),entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);\n+        assertClose(\"m-n = m + -n\",m.subtract(m2),\n+            m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);\n+        try {\n+            m.subtract(new BigMatrixImpl(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n+        BigMatrixImpl identity = new BigMatrixImpl(id);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertClose(\"inverse multiply\",m.multiply(mInv),\n+            identity,entryTolerance);\n+        assertClose(\"inverse multiply\",mInv.multiply(m),\n+            identity,entryTolerance);\n+        assertClose(\"identity multiply\",m.multiply(identity),\n+            m,entryTolerance);\n+        assertClose(\"identity multiply\",identity.multiply(mInv),\n+            mInv,entryTolerance);\n+        assertClose(\"identity multiply\",m2.multiply(identity),\n+            m2,entryTolerance); \n+        try {\n+            m.multiply(new BigMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }   \n+    \n+    //Additional Test for BigMatrixImplTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       BigMatrix m3 = new BigMatrixImpl(d3);\n+       BigMatrix m4 = new BigMatrixImpl(d4);\n+       BigMatrix m5 = new BigMatrixImpl(d5);\n+       assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test isSingular */\n+    public void testIsSingular() {\n+        BigMatrixImpl m = new BigMatrixImpl(singular);\n+        assertTrue(\"singular\",m.isSingular());\n+        m = new BigMatrixImpl(bigSingular);\n+        assertTrue(\"big singular\",m.isSingular());\n+        m = new BigMatrixImpl(id);\n+        assertTrue(\"identity nonsingular\",!m.isSingular());\n+        m = new BigMatrixImpl(testData);\n+        assertTrue(\"testData nonsingular\",!m.isSingular());\n+    }\n+        \n+    /** test inverse */\n+    public void testInverse() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrix mInv = new BigMatrixImpl(testDataInv);\n+        assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n+        assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n+        \n+        // Not square\n+        m = new BigMatrixImpl(testData2);\n+        try {\n+            m.inverse();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+        \n+        // Singular\n+        m = new BigMatrixImpl(singular);\n+        try {\n+            m.inverse();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /** test solve */\n+    public void testSolve() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrix mInv = new BigMatrixImpl(testDataInv);\n+        // being a bit slothful here -- actually testing that X = A^-1 * B\n+        assertClose(\"inverse-operate\",\n+                    asDouble(mInv.operate(asBigDecimal(testVector))),\n+                    asDouble(m.solve(asBigDecimal(testVector))),\n+                    normTolerance);\n+        try {\n+            asDouble(m.solve(asBigDecimal(testVector2)));\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }       \n+        BigMatrix bs = new BigMatrixImpl(bigSingular);\n+        try {\n+            bs.solve(bs);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.solve(bs);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            new BigMatrixImpl(testData2).solve(bs);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        } \n+        try {\n+            (new BigMatrixImpl(testData2)).luDecompose();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // ignored\n+        }  \n+    }\n+    \n+    /** test determinant */\n+    public void testDeterminant() {       \n+        BigMatrix m = new BigMatrixImpl(bigSingular);\n+        assertEquals(\"singular determinant\",0,m.getDeterminant().doubleValue(),0);\n+        m = new BigMatrixImpl(detData);\n+        assertEquals(\"nonsingular test\",-3d,m.getDeterminant().doubleValue(),normTolerance);\n+        \n+        // Examples verified against R (version 1.8.1, Red Hat Linux 9)\n+        m = new BigMatrixImpl(detData2);\n+        assertEquals(\"nonsingular R test 1\",-2d,m.getDeterminant().doubleValue(),normTolerance);\n+        m = new BigMatrixImpl(testData);\n+        assertEquals(\"nonsingular  R test 2\",-1d,m.getDeterminant().doubleValue(),normTolerance);\n+\n+        try {\n+            double d = new BigMatrixImpl(testData2).getDeterminant().doubleValue();\n+            fail(\"Expecting InvalidMatrixException, got \" + d);\n+        } catch (InvalidMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test trace */\n+    public void testTrace() {\n+        BigMatrix m = new BigMatrixImpl(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace().doubleValue(),entryTolerance);\n+        m = new BigMatrixImpl(testData2);\n+        try {\n+            double t = m.getTrace().doubleValue();\n+            fail(\"Expecting NonSquareMatrixException, got \" + t);\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"scalar add\",new BigMatrixImpl(testDataPlus2),\n+            m.scalarAdd(new BigDecimal(2d)),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        BigMatrix m = new BigMatrixImpl(id);\n+        double[] x = asDouble(m.operate(asBigDecimal(testVector)));\n+        assertClose(\"identity operate\",testVector,x,entryTolerance);\n+        m = new BigMatrixImpl(bigSingular);\n+        try {\n+            asDouble(m.operate(asBigDecimal(testVector)));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {\n+                { new BigDecimal(1), new BigDecimal(2) },\n+                { new BigDecimal(3), new BigDecimal(4) },\n+                { new BigDecimal(5), new BigDecimal(6) }\n+        }, false);\n+        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);\n+        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);\n+        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"inverse-transpose\",m.inverse().transpose(),\n+            m.transpose().inverse(),normTolerance);\n+        m = new BigMatrixImpl(testData2);\n+        BigMatrix mt = new BigMatrixImpl(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"premultiply\",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);\n+        m = new BigMatrixImpl(bigSingular);\n+        try {\n+            m.preMultiply(asBigDecimal(testVector));\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        BigMatrix m3 = new BigMatrixImpl(d3);\n+        BigMatrix m4 = new BigMatrixImpl(d4);\n+        BigMatrix m5 = new BigMatrixImpl(d5);\n+        assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n+        BigMatrixImpl identity = new BigMatrixImpl(id);\n+        new BigMatrixImpl(testData2);\n+        assertClose(\"inverse multiply\",m.preMultiply(mInv),\n+                identity,entryTolerance);\n+        assertClose(\"inverse multiply\",mInv.preMultiply(m),\n+                identity,entryTolerance);\n+        assertClose(\"identity multiply\",m.preMultiply(identity),\n+                m,entryTolerance);\n+        assertClose(\"identity multiply\",identity.preMultiply(mInv),\n+                mInv,entryTolerance);\n+        try {\n+            m.preMultiply(new BigMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"get row\",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);\n+        assertClose(\"get col\",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);\n+        try {\n+            m.getRowAsDoubleArray(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumnAsDoubleArray(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+      \n+    public void testLUDecomposition() throws Exception {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrix lu = m.getLUMatrix();\n+        assertClose(\"LU decomposition\", lu, new BigMatrixImpl(testDataLU), normTolerance);\n+        verifyDecomposition(m, lu);\n+        m = new BigMatrixImpl(luData);\n+        lu = m.getLUMatrix();\n+        assertClose(\"LU decomposition\", lu, new BigMatrixImpl(luDataLUDecomposition), normTolerance);\n+        verifyDecomposition(m, lu);\n+        m = new BigMatrixImpl(testDataMinus);\n+        lu = m.getLUMatrix();\n+        verifyDecomposition(m, lu);\n+        m = new BigMatrixImpl(id);\n+        lu = m.getLUMatrix();\n+        verifyDecomposition(m, lu);\n+        try {\n+            m = new BigMatrixImpl(bigSingular); // singular\n+            lu = m.getLUMatrix();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+        try {\n+            m = new BigMatrixImpl(testData2);  // not square\n+            lu = m.getLUMatrix();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+   /**\n+    * test submatrix accessors\n+    */\n+    public void testSubMatrix() {\n+        BigMatrix m = new BigMatrixImpl(subTestData);\n+        BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);\n+        BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);\n+        BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);\n+        BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);\n+        BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);\n+        BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);\n+        BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);\n+        BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);\n+        assertEquals(\"Rows23Cols00\", mRows23Cols00, \n+                m.getSubMatrix(2 , 3 , 0, 0));\n+        assertEquals(\"Rows00Cols33\", mRows00Cols33, \n+                m.getSubMatrix(0 , 0 , 3, 3));\n+        assertEquals(\"Rows01Cols23\", mRows01Cols23,\n+                m.getSubMatrix(0 , 1 , 2, 3));   \n+        assertEquals(\"Rows02Cols13\", mRows02Cols13,\n+                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));  \n+        assertEquals(\"Rows03Cols12\", mRows03Cols12,\n+                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));  \n+        assertEquals(\"Rows03Cols123\", mRows03Cols123,\n+                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); \n+        assertEquals(\"Rows20Cols123\", mRows20Cols123,\n+                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); \n+        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n+                m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); \n+        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n+                m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); \n+        \n+        try {\n+            m.getSubMatrix(1,0,2,4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(-1,1,2,2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1,0,2,2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1,0,2,4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {}, new int[] {0});\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {0}, new int[] {4});\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        BigMatrix m = new BigMatrixImpl(subTestData);\n+        BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);\n+        BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, \n+                m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, \n+                m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetRowMatrix() {\n+        BigMatrix m = new BigMatrixImpl(subTestData);\n+        BigMatrix mRow0 = new BigMatrixImpl(subRow0);\n+        BigMatrix mRow3 = new BigMatrixImpl(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m1 = (BigMatrixImpl) m.copy();\n+        BigMatrixImpl mt = (BigMatrixImpl) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new BigMatrixImpl(bigSingular)));\n+        // Different scales make BigDecimals, so matrices unequal\n+        m = new BigMatrixImpl(new String[][] {{\"2.0\"}});\n+        m1 = new BigMatrixImpl(new String[][] {{\"2.00\"}});\n+        assertTrue(m.hashCode() != m1.hashCode());\n+        assertFalse(m.equals(m1));\n+    }\n+    \n+    public void testToString() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        assertEquals(\"BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}\",\n+                m.toString());\n+        m = new BigMatrixImpl();\n+        assertEquals(\"BigMatrixImpl{}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        BigDecimal[][] detData3 = \n+            MatrixUtils.createBigMatrix(detData2).getData();\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        m.setSubMatrix(detData3,1,1);\n+        BigMatrix expected = MatrixUtils.createBigMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData3,0,0);\n+        expected = MatrixUtils.createBigMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        BigDecimal[][] testDataPlus3 = \n+            MatrixUtils.createBigMatrix(testDataPlus2).getData();\n+        m.setSubMatrix(testDataPlus3,0,0);      \n+        expected = MatrixUtils.createBigMatrix\n+        (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n+        matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),\n+            new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);\n+        expected = MatrixUtils.createBigMatrix\n+            (new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),\n+             new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),\n+             new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},\n+             {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6),\n+              new BigDecimal(2)}});\n+        assertEquals(expected, matrix);   \n+        \n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(matrix.getData(),1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},\n+                    {new BigDecimal(2), new BigDecimal(3)}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+        // empty\n+        try {\n+            m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+    \n+    //--------------- -----------------Protected methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    protected void assertClose(String msg, BigMatrix m, BigMatrix n,\n+        double tolerance) {\n+        assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+        double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", \n+                m[i],n[i],tolerance);\n+        }\n+    }\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {\n+        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n+                lowerData.length != upperData.length\n+                || lowerData.length != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                if (j < i) {\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = new BigDecimal(0);\n+                } else if (i == j) {\n+                    lowerData[i][j] = new BigDecimal(1);\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                } else {\n+                    lowerData[i][j] = new BigDecimal(0);\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        int m = matrix.getColumnDimension();\n+        BigDecimal out[][] = new BigDecimal[m][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n+            }\n+        }\n+        return new BigMatrixImpl(out);\n+    }\n+    \n+    /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n+    protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{\n+        int n = matrix.getRowDimension();\n+        BigDecimal[][] lowerData = new BigDecimal[n][n];\n+        BigDecimal[][] upperData = new BigDecimal[n][n];\n+        splitLU(lu, lowerData, upperData);\n+        BigMatrix lower =new BigMatrixImpl(lowerData);\n+        BigMatrix upper = new BigMatrixImpl(upperData);\n+        int[] permutation = ((BigMatrixImpl) matrix).getPermutation();\n+        BigMatrix permuted = permuteRows(matrix, permutation);\n+        assertClose(\"lu decomposition does not work\", permuted,\n+                lower.multiply(upper), normTolerance);\n+    }\n+         \n+//    /** Useful for debugging */\n+//    private void dumpMatrix(BigMatrix m) {\n+//          for (int i = 0; i < m.getRowDimension(); i++) {\n+//              String os = \"\";\n+//              for (int j = 0; j < m.getColumnDimension(); j++) {\n+//                  os += m.getEntry(i, j) + \" \";\n+//              }\n+//              System.out.println(os);\n+//          }\n+//    }\n+        \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link BlockFieldMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class BlockFieldMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = {\n+            {new Fraction(1),new Fraction(0),new Fraction(0)},\n+            {new Fraction(0),new Fraction(1),new Fraction(0)},\n+            {new Fraction(0),new Fraction(0),new Fraction(1)}\n+    };\n+    \n+    // Test data for group operations\n+    protected Fraction[][] testData = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3)},\n+            {new Fraction(1),new Fraction(0),new Fraction(8)}\n+    };\n+    protected Fraction[][] testDataLU = {\n+            {new Fraction(2), new Fraction(5), new Fraction(3)},\n+            {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)},\n+            {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}\n+    };\n+    protected Fraction[][] testDataPlus2 = {\n+            {new Fraction(3),new Fraction(4),new Fraction(5)},\n+            {new Fraction(4),new Fraction(7),new Fraction(5)},\n+            {new Fraction(3),new Fraction(2),new Fraction(10)}\n+    };\n+    protected Fraction[][] testDataMinus = {\n+            {new Fraction(-1),new Fraction(-2),new Fraction(-3)},\n+            {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+            {new Fraction(-1),new Fraction(0),new Fraction(-8)}\n+    };\n+    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};\n+    protected Fraction[][] testDataInv = {\n+            {new Fraction(-40),new Fraction(16),new Fraction(9)},\n+            {new Fraction(13),new Fraction(-5),new Fraction(-3)},\n+            {new Fraction(5),new Fraction(-2),new Fraction(-1)}\n+    };\n+    protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)};\n+    protected Fraction[][] testData2 = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3)}\n+    };\n+    protected Fraction[][] testData2T = {\n+            {new Fraction(1),new Fraction(2)},\n+            {new Fraction(2),new Fraction(5)},\n+            {new Fraction(3),new Fraction(3)}\n+    };\n+    protected Fraction[][] testDataPlusInv = {\n+            {new Fraction(-39),new Fraction(18),new Fraction(12)},\n+            {new Fraction(15),new Fraction(0),new Fraction(0)},\n+            {new Fraction(6),new Fraction(-2),new Fraction(7)}\n+    };\n+    \n+    // lu decomposition tests\n+    protected Fraction[][] luData = {\n+            {new Fraction(2),new Fraction(3),new Fraction(3)},\n+            {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(6),new Fraction(9),new Fraction(8)}\n+    };\n+    protected Fraction[][] luDataLUDecomposition = {\n+            {new Fraction(6),new Fraction(9),new Fraction(8)},\n+            {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}\n+    };\n+    \n+    // singular matrices\n+    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n+    protected Fraction[][] bigSingular = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},\n+            {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)},\n+            {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}\n+    }; // 4th row = 1st + 2nd\n+    protected Fraction[][] detData = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(4),new Fraction(5),new Fraction(6)},\n+            {new Fraction(7),new Fraction(8),new Fraction(10)}\n+    };\n+    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n+    \n+    // vectors\n+    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n+    \n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n+            {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n+            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}\n+    }; \n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n+    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n+    protected Fraction[][] subRows03Cols123 = {\n+            {new Fraction(2), new Fraction(3), new Fraction(4)},\n+            {new Fraction(5), new Fraction(6), new Fraction(7)}\n+    };\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = {\n+            {new Fraction(4), new Fraction(6), new Fraction(8)},\n+            {new Fraction(2), new Fraction(3), new Fraction(4)}\n+    };\n+    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};\n+    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};\n+    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};\n+    // row matrices\n+    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};\n+    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};\n+    // column matrices\n+    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n+    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public BlockFieldMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BlockFieldMatrixTest.class);\n+        suite.setName(\"BlockFieldMatrix<Fraction> Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());\n+        assertEquals(m1, m2);\n+        BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        Fraction[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);\n+        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        try {\n+            m.subtract(new BlockFieldMatrix<Fraction>(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n+        TestUtils.assertEquals(m.multiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.multiply(m), identity);\n+        TestUtils.assertEquals(m.multiply(identity), m);\n+        TestUtils.assertEquals(identity.multiply(mInv), mInv);\n+        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        try {\n+            m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, new Fraction(i * 11 + j, 11));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                Fraction sum = Fraction.ZERO;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                Fraction sum = Fraction.ZERO;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] {\n+            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n+            {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}\n+    };\n+    private Fraction[][] d4 = new Fraction[][] {\n+            {new Fraction(1)},\n+            {new Fraction(2)},\n+            {new Fraction(3)},\n+            {new Fraction(4)}\n+    };\n+    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n+     \n+    public void testMultiply2() { \n+       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n+       TestUtils.assertEquals(m3.multiply(m4), m5);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n+        assertEquals(new Fraction(3),m.getTrace());\n+        m = new BlockFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),\n+                               m.scalarAdd(new Fraction(2)));\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(testVector, m.operate(testVector));\n+        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());\n+        m = new BlockFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    public void testOperateLarge() {\n+        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;\n+        Random random = new Random(111007463902334l);\n+        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n+        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n+        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;\n+        Random random = new Random(111007463902334l);\n+        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n+        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n+        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) },\n+                { new Fraction(3), new Fraction(4) },\n+                { new Fraction(5), new Fraction(6) }\n+        });\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( new Fraction(3), b[0]);\n+        assertEquals( new Fraction(7), b[1]);\n+        assertEquals(new Fraction(11), b[2]);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(mIT, mTI);\n+        m = new BlockFieldMatrix<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);\n+        TestUtils.assertEquals(mt, m.transpose());\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n+        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),\n+                               preMultTest);\n+        m = new BlockFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n+        TestUtils.assertEquals(m4.preMultiply(m3), m5);\n+        \n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(m.preMultiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.preMultiply(m), identity);\n+        TestUtils.assertEquals(m.preMultiply(identity), m);\n+        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n+        try {\n+            m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.getRow(0), testDataRow1);\n+        TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(m.getEntry(0,1),new Fraction(2));\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = {\n+                {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                {new Fraction(2),new Fraction(5),new Fraction(3)}\n+        };\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = {\n+                {new Fraction(1),new Fraction(2)},\n+                {new Fraction(2),new Fraction(5)},\n+                {new Fraction(1), new Fraction(7)}\n+        };\n+        FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        Fraction[][] coefficientsData = {\n+                {new Fraction(2), new Fraction(3), new Fraction(-2)},\n+                {new Fraction(-1), new Fraction(7), new Fraction(6)},\n+                {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n+        };\n+        FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);\n+        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals(new Fraction(2).multiply(solution[0]).\n+                     add(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(2).multiply(solution[2])),\n+                     constants[0]);\n+        assertEquals(new Fraction(-1).multiply(solution[0]).\n+                     add(new Fraction(7).multiply(solution[1])).\n+                     add(new Fraction(6).multiply(solution[2])),\n+                     constants[1]);\n+        assertEquals(new Fraction(4).multiply(solution[0]).\n+                     subtract(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(5).multiply(solution[2])),\n+                     constants[2]);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });\n+    }\n+\n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            if (reference != null) {\n+                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            if (reference != null) {\n+                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    public void testCopySubMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, -1, 1, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n+    }\n+\n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                             new Fraction[1][1] :\n+                             new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            if (reference != null) {\n+            \tassertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int[] selectedRows, int[] selectedColumns) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                    new Fraction[1][1] :\n+                    new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            if (reference != null) {\n+            \tassertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+    \n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayFieldVector<Fraction>(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        Fraction[] sub = new Fraction[n];\n+        Arrays.fill(sub, new Fraction(1));\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n+    \n+    public void testGetColumn() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn1 = columnToArray(subColumn1);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        Fraction[] sub = new Fraction[n];\n+        Arrays.fill(sub, new Fraction(1));\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n+    private Fraction[] columnToArray(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(Fraction[] expected, Fraction[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();\n+        BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(\"BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new BlockFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new BlockFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        BlockFieldMatrix<Fraction> matrix =\n+            new BlockFieldMatrix<Fraction>(new Fraction[][] {\n+                    {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n+                    {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},\n+                    {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}\n+            });\n+        matrix.setSubMatrix(new Fraction[][] {\n+                {new Fraction(3), new Fraction(4)},\n+                {new Fraction(5), new Fraction(6)}\n+        }, 1, 1);\n+        expected =\n+            new BlockFieldMatrix<Fraction>(new Fraction[][] {\n+                    {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},\n+                    {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},\n+                    {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}\n+            });\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+\n+    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n+        public SetVisitor() {\n+            super(Fraction.ZERO);\n+        }\n+        @Override\n+        public Fraction visit(int i, int j, Fraction value) {\n+            return new Fraction(i * 11 + j, 11);\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n+        private int count;\n+        public GetVisitor() {\n+            super(Fraction.ZERO);\n+            count = 0;\n+        }\n+        @Override\n+        public void visit(int i, int j, Fraction value) {\n+            ++count;\n+            assertEquals(new Fraction(i * 11 + j, 11), value);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {\n+        BlockFieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                int p = r.nextInt(20) - 10;\n+                int q = r.nextInt(20) - 10;\n+                if (q == 0) {\n+                    q = 1;\n+                }\n+                m.setEntry(i, j, new Fraction(p, q));\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link BlockRealMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class BlockRealMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public BlockRealMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BlockRealMatrixTest.class);\n+        suite.setName(\"BlockRealMatrix Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);\n+        BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());\n+        assertEquals(m1, m2);\n+        BlockRealMatrix m3 = new BlockRealMatrix(testData);\n+        BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);\n+        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        \n+        try {\n+            m.subtract(new BlockRealMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        BlockRealMatrix identity = new BlockRealMatrix(id);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertClose(m.multiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.multiply(m), identity, entryTolerance);\n+        assertClose(m.multiply(identity), m, entryTolerance);\n+        assertClose(identity.multiply(mInv), mInv, entryTolerance);\n+        assertClose(m2.multiply(identity), m2, entryTolerance); \n+        try {\n+            m.multiply(new BlockRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        RealMatrix m = new BlockRealMatrix(35, 71);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, i + j / 1024.0);\n+            }\n+        }\n+\n+        RealMatrix mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum += (k + i / 1024.0) * (k + j / 1024.0);\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum += (i + k / 1024.0) * (j + k / 1024.0);\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for BlockRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new BlockRealMatrix(d3);   \n+       RealMatrix m4 = new BlockRealMatrix(d4);\n+       RealMatrix m5 = new BlockRealMatrix(d5);\n+       assertClose(m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new BlockRealMatrix(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new BlockRealMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new BlockRealMatrix(id);\n+        assertClose(testVector, m.operate(testVector), entryTolerance);\n+        assertClose(testVector, m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);\n+        m = new BlockRealMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    public void testOperateLarge() {\n+        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * BlockRealMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * BlockRealMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new BlockRealMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        });\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new BlockRealMatrix(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        assertClose(mIT, mTI, normTolerance);\n+        m = new BlockRealMatrix(testData2);\n+        RealMatrix mt = new BlockRealMatrix(testData2T);\n+        assertClose(mt, m.transpose(), normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);\n+        assertClose(m.preMultiply(new ArrayRealVector(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new BlockRealMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new BlockRealMatrix(d3);   \n+        RealMatrix m4 = new BlockRealMatrix(d4);\n+        RealMatrix m5 = new BlockRealMatrix(d5);\n+        assertClose(m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        BlockRealMatrix identity = new BlockRealMatrix(id);\n+        assertClose(m.preMultiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.preMultiply(m), identity, entryTolerance);\n+        assertClose(m.preMultiply(identity), m, entryTolerance);\n+        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);\n+        try {\n+            m.preMultiply(new BlockRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new BlockRealMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new BlockRealMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new BlockRealMatrix(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });\n+    }\n+\n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            if (reference != null) {\n+            \t assertEquals(new BlockRealMatrix(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            if (reference != null) {\n+            \tassertEquals(new BlockRealMatrix(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    public void testCopySubMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, -1, 1, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n+    }\n+\n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                             new double[1][1] :\n+                             new double[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            if (reference != null) {\n+            \tassertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int[] selectedRows, int[] selectedColumns) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                    new double[1][1] :\n+                    new double[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            if (reference != null) {\n+            \tassertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m     = new BlockRealMatrix(subTestData);\n+        RealMatrix mRow0 = new BlockRealMatrix(subRow0);\n+        RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n+    public void testGetRowVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealVector sub = new ArrayRealVector(n, 1.0);\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealVector sub = new ArrayRealVector(n, 1.0);\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayRealVector(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m1 = (BlockRealMatrix) m.copy();\n+        BlockRealMatrix mt = (BlockRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new BlockRealMatrix(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(\"BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = new BlockRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new BlockRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new BlockRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        BlockRealMatrix matrix = new BlockRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n+        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n+        expected = new BlockRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new BlockRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+    \n+    public void testSerial()  {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+\n+    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n+        @Override\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n+        private int count = 0;\n+        @Override\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {\n+        assertTrue(m.subtract(n).getNorm() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(double[] m, double[] n, double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(m[i], n[i], tolerance);\n+        }\n+    }\n+\n+    private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {\n+        BlockRealMatrix m = new BlockRealMatrix(rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                m.setEntry(i, j, 200 * r.nextDouble() - 100);\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.linear.CholeskyDecomposition;\n+import org.apache.commons.math.linear.CholeskyDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.NonSquareMatrixException;\n+import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;\n+import org.apache.commons.math.linear.NotSymmetricMatrixException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.junit.Test;\n+\n+public class CholeskyDecompositionImplTest {\n+\n+    private double[][] testData = new double[][] {\n+            {  1,  2,   4,   7,  11 },\n+            {  2, 13,  23,  38,  58 },\n+            {  4, 23,  77, 122, 182 },\n+            {  7, 38, 122, 294, 430 },\n+            { 11, 58, 182, 430, 855 }\n+    };\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() throws MathException {\n+        CholeskyDecomposition llt =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+        assertEquals(testData.length, llt.getL().getRowDimension());\n+        assertEquals(testData.length, llt.getL().getColumnDimension());\n+        assertEquals(testData.length, llt.getLT().getRowDimension());\n+        assertEquals(testData.length, llt.getLT().getColumnDimension());\n+    }\n+\n+    /** test non-square matrix */\n+    @Test(expected = NonSquareMatrixException.class)\n+    public void testNonSquare() throws MathException {\n+        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));\n+    }\n+\n+    /** test non-symmetric matrix */\n+    @Test(expected = NotSymmetricMatrixException.class)\n+    public void testNotSymmetricMatrixException() throws MathException {\n+        double[][] changed = testData.clone();\n+        changed[0][changed[0].length - 1] += 1.0e-5;\n+        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(changed));\n+    }\n+\n+    /** test non positive definite matrix */\n+    @Test(expected = NotPositiveDefiniteMatrixException.class)\n+    public void testNotPositiveDefinite() throws MathException {\n+        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n+                { 14, 11, 13, 15, 24 },\n+                { 11, 34, 13, 8,  25 },\n+                { 13, 13, 14, 15, 21 },\n+                { 15, 8,  15, 18, 23 },\n+                { 24, 25, 21, 23, 45 }\n+        }));\n+    }\n+\n+    @Test(expected = NotPositiveDefiniteMatrixException.class)\n+    public void testMath274() throws MathException {\n+        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n+                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n+                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n+                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n+                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n+            \n+        }));\n+    }\n+\n+    /** test A = LLT */\n+    @Test\n+    public void testAEqualLLT() throws MathException {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);\n+        RealMatrix l  = llt.getL();\n+        RealMatrix lt = llt.getLT();\n+        double norm = l.multiply(lt).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 1.0e-15);\n+    }\n+\n+    /** test that L is lower triangular */\n+    @Test\n+    public void testLLowerTriangular() throws MathException {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix l = new CholeskyDecompositionImpl(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(0.0, l.getEntry(i, j), 0.0);\n+            }\n+        }\n+    }\n+\n+    /** test that LT is transpose of L */\n+    @Test\n+    public void testLTTransposed() throws MathException {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);\n+        RealMatrix l  = llt.getL();\n+        RealMatrix lt = llt.getLT();\n+        double norm = l.subtract(lt.transpose()).getNorm();\n+        assertEquals(0, norm, 1.0e-15);\n+    }\n+\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues() throws MathException {\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                {  1,  0,  0,  0,  0 },\n+                {  2,  3,  0,  0,  0 },\n+                {  4,  5,  6,  0,  0 },\n+                {  7,  8,  9, 10,  0 },\n+                { 11, 12, 13, 14, 15 }\n+        });\n+       CholeskyDecomposition llt =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+\n+        // check values against known references\n+        RealMatrix l = llt.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix lt = llt.getLT();\n+        assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l  == llt.getL());\n+        assertTrue(lt == llt.getLT());\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.linear.CholeskyDecompositionImpl;\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+public class CholeskySolverTest extends TestCase {\n+\n+    private double[][] testData = new double[][] {\n+            {  1,  2,   4,   7,  11 },\n+            {  2, 13,  23,  38,  58 },\n+            {  4, 23,  77, 122, 182 },\n+            {  7, 38, 122, 294, 430 },\n+            { 11, 58, 182, 430, 855 }\n+    };\n+\n+    public CholeskySolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CholeskySolverTest.class);\n+        suite.setName(\"LUSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() throws MathException {\n+        DecompositionSolver solver =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() throws MathException {\n+        DecompositionSolver solver =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                {   78,  -13,    1 },\n+                {  414,  -62,   -1 },\n+                { 1312, -202,  -37 },\n+                { 2989, -542,  145 },\n+                { 5510, -1465, 201 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1,  0,  1 },\n+                { 0,  1,  1 },\n+                { 2,  1, -4 },\n+                { 2,  2,  2 },\n+                { 5, -3,  0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using ArrayRealVector\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test determinant */\n+    public void testDeterminant() throws MathException {\n+        assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n+    }\n+\n+    private double getDeterminant(RealMatrix m) throws MathException {\n+        return new CholeskyDecompositionImpl(m).getDeterminant();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.apache.commons.math.linear.EigenDecomposition;\n+import org.apache.commons.math.linear.EigenDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.TriDiagonalTransformer;\n+import org.apache.commons.math.util.MathUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class EigenDecompositionImplTest extends TestCase {\n+\n+    private double[] refValues;\n+    private RealMatrix matrix;\n+\n+    public EigenDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EigenDecompositionImplTest.class);\n+        suite.setName(\"EigenDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    public void testDimension1() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n+    }\n+\n+    public void testDimension2() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                    { 59.0, 12.0 },\n+                    { 12.0, 66.0 }\n+            });\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n+    }\n+\n+    public void testDimension3() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   {  39632.0, -4824.0, -16560.0 },\n+                                   {  -4824.0,  8693.0,   7920.0 },\n+                                   { -16560.0,  7920.0,  17300.0 }\n+                               });\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n+        assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n+        assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n+    }\n+\n+    public void testDimension4WithSplit() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   {  0.784, -0.288,  0.000,  0.000 },\n+                                   { -0.288,  0.616,  0.000,  0.000 },\n+                                   {  0.000,  0.000,  0.164, -0.048 },\n+                                   {  0.000,  0.000, -0.048,  0.136 }\n+                               });\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n+    }\n+\n+    public void testDimension4WithoutSplit() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   {  0.5608, -0.2016,  0.1152, -0.2976 },\n+                                   { -0.2016,  0.4432, -0.2304,  0.1152 },\n+                                   {  0.1152, -0.2304,  0.3088, -0.1344 },\n+                                   { -0.2976,  0.1152, -0.1344,  0.3872 }\n+                               });\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n+    }\n+\n+    /** test a matrix already in tridiagonal form. */\n+    public void testTridiagonal() {\n+        Random r = new Random(4366663527842l);\n+        double[] ref = new double[30];\n+        for (int i = 0; i < ref.length; ++i) {\n+            if (i < 5) {\n+                ref[i] = 2 * r.nextDouble() - 1;\n+            } else {\n+                ref[i] = 0.0001 * r.nextDouble() + 6;                \n+            }\n+        }\n+        Arrays.sort(ref);\n+        TriDiagonalTransformer t =\n+            new TriDiagonalTransformer(createTestMatrix(r, ref));\n+        EigenDecomposition ed =\n+            new EigenDecompositionImpl(t.getMainDiagonalRef(),\n+                                       t.getSecondaryDiagonalRef(),\n+                                       MathUtils.SAFE_MIN);\n+        double[] eigenValues = ed.getRealEigenvalues();\n+        assertEquals(ref.length, eigenValues.length);\n+        for (int i = 0; i < ref.length; ++i) {\n+            assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n+        }\n+        \n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        final int m = matrix.getRowDimension();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        assertEquals(m, ed.getV().getRowDimension());\n+        assertEquals(m, ed.getV().getColumnDimension());\n+        assertEquals(m, ed.getD().getColumnDimension());\n+        assertEquals(m, ed.getD().getColumnDimension());\n+        assertEquals(m, ed.getVT().getRowDimension());\n+        assertEquals(m, ed.getVT().getColumnDimension());\n+    }\n+\n+    /** test eigenvalues */\n+    public void testEigenvalues() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        double[] eigenValues = ed.getRealEigenvalues();\n+        assertEquals(refValues.length, eigenValues.length);\n+        for (int i = 0; i < refValues.length; ++i) {\n+            assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n+        }\n+    }\n+\n+    /** test eigenvalues for a big matrix. */\n+    public void testBigMatrix() {\n+        Random r = new Random(17748333525117l);\n+        double[] bigValues = new double[200];\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            bigValues[i] = 2 * r.nextDouble() - 1;\n+        }\n+        Arrays.sort(bigValues);\n+        EigenDecomposition ed =\n+            new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);\n+        double[] eigenValues = ed.getRealEigenvalues();\n+        assertEquals(bigValues.length, eigenValues.length);\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n+        }\n+    }\n+\n+    /** test eigenvectors */\n+    public void testEigenvectors() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            double lambda = ed.getRealEigenvalue(i);\n+            RealVector v  = ed.getEigenvector(i);\n+            RealVector mV = matrix.operate(v);\n+            assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n+        }\n+    }\n+\n+    /** test A = VDVt */\n+    public void testAEqualVDVt() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        RealMatrix v  = ed.getV();\n+        RealMatrix d  = ed.getD();\n+        RealMatrix vT = ed.getVT();\n+        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 6.0e-13);\n+    }\n+\n+    /** test that V is orthogonal */\n+    public void testVOrthogonal() {\n+        RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();\n+        RealMatrix vTv = v.transpose().multiply(v);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n+        assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n+    }\n+\n+    /** test diagonal matrix */\n+    public void testDiagonal() {\n+        double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n+        RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n+        EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);\n+        assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n+        assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n+        assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n+        assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);\n+    }\n+\n+    /**\n+     * Matrix with eigenvalues {8, -1, -1}\n+     */\n+    public void testRepeatedEigenvalue() {\n+        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {\n+                {3,  2,  4},\n+                {2,  0,  2},\n+                {4,  2,  3}\n+        }); \n+        EigenDecomposition ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);\n+        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n+        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n+    }\n+    \n+    /**\n+     * Matrix with eigenvalues {2, 0, 12}\n+     */\n+    public void testDistinctEigenvalues() {\n+        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {\n+                {3, 1, -4},  \n+                {1, 3, -4}, \n+                {-4, -4, 8}\n+        });\n+        EigenDecomposition ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);\n+        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n+        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);\n+    }\n+    \n+    /**\n+     * Verifies that the given EigenDecomposition has eigenvalues equivalent to\n+     * the targetValues, ignoring the order of the values and allowing\n+     * values to differ by tolerance.\n+     */\n+    protected void checkEigenValues(double[] targetValues,\n+            EigenDecomposition ed, double tolerance) {\n+        double[] observed = ed.getRealEigenvalues();\n+        for (int i = 0; i < observed.length; i++) {\n+            assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n+            assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n+        }\n+    }\n+    \n+    /**\n+     * Returns true iff there is an entry within tolerance of value in\n+     * searchArray.\n+     */\n+    private boolean isIncludedValue(double value, double[] searchArray,\n+            double tolerance) {\n+       boolean found = false;\n+       int i = 0;\n+       while (!found && i < searchArray.length) {\n+           if (Math.abs(value - searchArray[i]) < tolerance) {\n+               found = true;\n+           }\n+           i++;\n+       }\n+       return found;\n+    }\n+    \n+    /**\n+     * Returns true iff eigenVector is a scalar multiple of one of the columns\n+     * of ed.getV().  Does not try linear combinations - i.e., should only be\n+     * used to find vectors in one-dimensional eigenspaces.\n+     */\n+    protected void checkEigenVector(double[] eigenVector,\n+            EigenDecomposition ed, double tolerance) {\n+        assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n+    }\n+    \n+    /**\n+     * Returns true iff there is a column that is a scalar multiple of column\n+     * in searchMatrix (modulo tolerance)\n+     */\n+    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,\n+            double tolerance) {\n+        boolean found = false;\n+        int i = 0;\n+        while (!found && i < searchMatrix.getColumnDimension()) {\n+            double multiplier = 1.0;\n+            boolean matching = true;\n+            int j = 0;\n+            while (matching && j < searchMatrix.getRowDimension()) {\n+                double colEntry = searchMatrix.getEntry(j, i);\n+                // Use the first entry where both are non-zero as scalar\n+                if (Math.abs(multiplier - 1.0) <= Math.ulp(1.0) && Math.abs(colEntry) > 1E-14\n+                        && Math.abs(column[j]) > 1e-14) {\n+                    multiplier = colEntry / column[j];\n+                } \n+                if (Math.abs(column[j] * multiplier - colEntry) > tolerance) {\n+                    matching = false;\n+                }\n+                j++;\n+            }\n+            found = matching;\n+            i++;\n+        }\n+        return found;\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        refValues = new double[] {\n+                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        matrix = createTestMatrix(new Random(35992629946426l), refValues);\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        refValues = null;\n+        matrix    = null;\n+    }\n+\n+    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n+        final int n = eigenValues.length;\n+        final RealMatrix v = createOrthogonalMatrix(r, n);\n+        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);\n+        return v.multiply(d).multiply(v.transpose());\n+    }\n+\n+    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {\n+\n+        final double[][] data = new double[size][size];\n+\n+        for (int i = 0; i < size; ++i) {\n+            final double[] dataI = data[i];\n+            double norm2 = 0;\n+            do {\n+\n+                // generate randomly row I\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] = 2 * r.nextDouble() - 1;\n+                }\n+\n+                // project the row in the subspace orthogonal to previous rows\n+                for (int k = 0; k < i; ++k) {\n+                    final double[] dataK = data[k];\n+                    double dotProduct = 0;\n+                    for (int j = 0; j < size; ++j) {\n+                        dotProduct += dataI[j] * dataK[j];\n+                    }\n+                    for (int j = 0; j < size; ++j) {\n+                        dataI[j] -= dotProduct * dataK[j];\n+                    }\n+                }\n+\n+                // normalize the row\n+                norm2 = 0;\n+                for (final double dataIJ : dataI) {\n+                    norm2 += dataIJ * dataIJ;\n+                }\n+                final double inv = 1.0 / Math.sqrt(norm2);\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] *= inv;\n+                }\n+\n+            } while (norm2 * size < 0.01);\n+        }\n+\n+        return MatrixUtils.createRealMatrix(data);\n+\n+    }\n+\n+    public static RealMatrix createDiagonalMatrix(final double[] diagonal,\n+                                                  final int rows, final int columns) {\n+        final double[][] dData = new double[rows][columns];\n+        for (int i = 0; i < Math.min(rows, columns); ++i) {\n+            dData[i][i] = diagonal[i];\n+        }\n+        return MatrixUtils.createRealMatrix(dData);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.EigenDecompositionImpl;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.util.MathUtils;\n+\n+public class EigenSolverTest extends TestCase {\n+\n+    private double[] refValues;\n+    private RealMatrix matrix;\n+\n+    public EigenSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EigenSolverTest.class);\n+        suite.setName(\"EigenSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test non invertible matrix */\n+    public void testNonInvertible() {\n+        Random r = new Random(9994100315209l);\n+        RealMatrix m =\n+            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });\n+        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n+        assertFalse(es.isNonSingular());\n+        try {\n+            es.getInverse();\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test invertible matrix */\n+    public void testInvertible() {\n+        Random r = new Random(9994100315209l);\n+        RealMatrix m =\n+            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n+        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n+        assertTrue(es.isNonSingular());\n+        RealMatrix inverse = es.getInverse();\n+        RealMatrix error =\n+            m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));\n+        assertEquals(0, error.getNorm(), 4.0e-15);\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        DecompositionSolver es = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            es.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            es.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {\n+                { 91,  5, 29, 32, 40, 14 },\n+                {  5, 34, -1,  0,  2, -1 },\n+                { 29, -1, 12,  9, 21,  8 },\n+                { 32,  0,  9, 14,  9,  0 },\n+                { 40,  2, 21,  9, 51, 19 },\n+                { 14, -1,  8,  0, 19, 14 }\n+        });\n+        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1561, 269, 188 },\n+                {   69, -21,  70 },\n+                {  739, 108,  63 },\n+                {  324,  86,  59 },\n+                { 1624, 194, 107 },\n+                {  796,  69,  36 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1,   2, 1 },\n+                { 2,  -1, 2 },\n+                { 4,   2, 3 },\n+                { 8,  -1, 0 },\n+                { 16,  2, 0 },\n+                { 32, -1, 0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, es.solve(b).subtract(xRef).getNorm(), 2.0e-12);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new ArrayRealVector(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using Array2DRowRealMatrix\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        refValues = new double[] {\n+                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        refValues = null;\n+        matrix    = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.linear.FieldLUDecomposition;\n+import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+\n+public class FieldLUDecompositionImplTest extends TestCase {\n+    private Fraction[][] testData = {\n+            { new Fraction(1), new Fraction(2), new Fraction(3)},\n+            { new Fraction(2), new Fraction(5), new Fraction(3)},\n+            { new Fraction(1), new Fraction(0), new Fraction(8)}\n+    };\n+    private Fraction[][] testDataMinus = {\n+            { new Fraction(-1), new Fraction(-2), new Fraction(-3)},\n+            { new Fraction(-2), new Fraction(-5), new Fraction(-3)},\n+            { new Fraction(-1),  new Fraction(0), new Fraction(-8)}\n+    };\n+    private Fraction[][] luData = {\n+            { new Fraction(2), new Fraction(3), new Fraction(3) },\n+            { new Fraction(2), new Fraction(3), new Fraction(7) },\n+            { new Fraction(6), new Fraction(6), new Fraction(8) }\n+    };\n+    \n+    // singular matrices\n+    private Fraction[][] singular = {\n+            { new Fraction(2), new Fraction(3) },\n+            { new Fraction(2), new Fraction(3) }\n+    };\n+    private Fraction[][] bigSingular = {\n+            { new Fraction(1), new Fraction(2),   new Fraction(3),    new Fraction(4) },\n+            { new Fraction(2), new Fraction(5),   new Fraction(3),    new Fraction(4) },\n+            { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) },\n+            { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }\n+    }; // 4th row = 1st + 2nd\n+\n+    public FieldLUDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldLUDecompositionImplTest.class);\n+        suite.setName(\"FieldLUDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        assertEquals(testData.length, LU.getL().getRowDimension());\n+        assertEquals(testData.length, LU.getL().getColumnDimension());\n+        assertEquals(testData.length, LU.getU().getRowDimension());\n+        assertEquals(testData.length, LU.getU().getColumnDimension());\n+        assertEquals(testData.length, LU.getP().getRowDimension());\n+        assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    public void testNonSquare() {\n+        try {\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                    { Fraction.ZERO, Fraction.ZERO },\n+                    { Fraction.ZERO, Fraction.ZERO },\n+                    { Fraction.ZERO, Fraction.ZERO }\n+            }));\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test PA = LU */\n+    public void testPAEqualLU() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        FieldMatrix<Fraction> l = lu.getL();\n+        FieldMatrix<Fraction> u = lu.getU();\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(testDataMinus);\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            matrix.setEntry(i, i, Fraction.ONE);\n+        }\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(singular);\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        assertFalse(lu.getSolver().isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+        matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        assertFalse(lu.getSolver().isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    public void testLLowerTriangular() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            assertEquals(Fraction.ONE, l.getEntry(i, i));\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(Fraction.ZERO, l.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    public void testUUpperTriangular() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(Fraction.ZERO, u.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    public void testPPermutation() {\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();\n+\n+        FieldMatrix<Fraction> ppT = p.multiply(p.transpose());\n+        FieldMatrix<Fraction> id  =\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),\n+                                          p.getRowDimension(), p.getRowDimension());\n+        for (int i = 0; i < id.getRowDimension(); ++i) {\n+            id.setEntry(i, i, Fraction.ONE);\n+        }\n+        TestUtils.assertEquals(id, ppT);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final Fraction e = p.getEntry(i, j);\n+                if (e.equals(Fraction.ZERO)) {\n+                    ++zeroCount;\n+                } else if (e.equals(Fraction.ONE)) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final Fraction e = p.getEntry(i, j);\n+                if (e.equals(Fraction.ZERO)) {\n+                    ++zeroCount;\n+                } else if (e.equals(Fraction.ONE)) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getRowDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+\n+    /** test singular */\n+    public void testSingular() {\n+        FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n+        assertTrue(lu.getSolver().isNonSingular());\n+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));\n+        assertFalse(lu.getSolver().isNonSingular());\n+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n+        assertFalse(lu.getSolver().isNonSingular());\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(2), new Fraction(1), new Fraction(0) },\n+                { new Fraction(1), new Fraction(-2), new Fraction(1) }\n+        });\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1),  new Fraction(2), new Fraction(3) },\n+                { new Fraction(0), new Fraction(1), new Fraction(-3) },\n+                { new Fraction(0),  new Fraction(0), new Fraction(-1) }\n+        });\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(0), new Fraction(1), new Fraction(0) },\n+                { new Fraction(0), new Fraction(0), new Fraction(1) }\n+        });\n+        int[] pivotRef = { 0, 1, 2 };\n+\n+        // check values against known references\n+        FieldMatrix<Fraction> l = lu.getL();\n+        TestUtils.assertEquals(lRef, l);\n+        FieldMatrix<Fraction> u = lu.getU();\n+        TestUtils.assertEquals(uRef, u);\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(pRef, p);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+       FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(3), new Fraction(1), new Fraction(0) },\n+                { new Fraction(1), new Fraction(0), new Fraction(1) }\n+        });\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(2), new Fraction(3), new Fraction(3)    },\n+                { new Fraction(0), new Fraction(-3), new Fraction(-1)  },\n+                { new Fraction(0), new Fraction(0), new Fraction(4) }\n+        });\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(0), new Fraction(0), new Fraction(1) },\n+                { new Fraction(0), new Fraction(1), new Fraction(0) }\n+        });\n+        int[] pivotRef = { 0, 2, 1 };\n+\n+        // check values against known references\n+        FieldMatrix<Fraction> l = lu.getL();\n+        TestUtils.assertEquals(lRef, l);\n+        FieldMatrix<Fraction> u = lu.getU();\n+        TestUtils.assertEquals(uRef, u);\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(pRef, p);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link Array2DRowFieldMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class FieldMatrixImplTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };\n+    \n+    // Test data for group operations\n+    protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} };\n+    protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}};\n+    protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} };\n+    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+       {new Fraction(-1),new Fraction(0),new Fraction(-8)} };\n+    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};\n+    protected Fraction[][] testDataInv = \n+        { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} };\n+    protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)};\n+    protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}};\n+    protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}};\n+    protected Fraction[][] testDataPlusInv = \n+        { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} };\n+    \n+    // lu decomposition tests\n+    protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} };\n+    protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} };\n+    \n+    // singular matrices\n+    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n+    protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},\n+        {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd\n+    protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} };\n+    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n+    \n+    // vectors\n+    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n+    \n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n+            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}}; \n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n+    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n+    protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)} , {new Fraction(5), new Fraction(6), new Fraction(7)}};\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)} , {new Fraction(2), new Fraction(3), new Fraction(4)}};\n+    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};\n+    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};\n+    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};\n+    // row matrices\n+    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};\n+    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};\n+    // column matrices\n+    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n+    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public FieldMatrixImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldMatrixImplTest.class);\n+        suite.setName(\"Array2DRowFieldMatrix<Fraction> Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData());\n+        assertEquals(m2,m1);\n+        Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);\n+        assertEquals(m4,m3);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        Fraction[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        try {\n+            m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n+        TestUtils.assertEquals(m.multiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.multiply(m), identity);\n+        TestUtils.assertEquals(m.multiply(identity), m);\n+        TestUtils.assertEquals(identity.multiply(mInv), mInv);\n+        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        try {\n+            m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }   \n+    \n+    //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};\n+    private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};\n+    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n+     \n+    public void testMultiply2() { \n+       FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n+       TestUtils.assertEquals(m3.multiply(m4), m5);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n+        assertEquals(\"identity trace\",new Fraction(3),m.getTrace());\n+        m = new Array2DRowFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(testVector, m.operate(testVector));\n+        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());\n+        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }\n+        }, false);\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( new Fraction(3), b[0]);\n+        assertEquals( new Fraction(7), b[1]);\n+        assertEquals(new Fraction(11), b[2]);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(mIT, mTI);\n+        m = new Array2DRowFieldMatrix<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);\n+        TestUtils.assertEquals(mt, m.transpose());\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n+        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),\n+                               preMultTest);\n+        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n+        TestUtils.assertEquals(m4.preMultiply(m3), m5);\n+        \n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(m.preMultiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.preMultiply(m), identity);\n+        TestUtils.assertEquals(m.preMultiply(identity), m);\n+        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n+        try {\n+            m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.getRow(0), testDataRow1);\n+        TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),new Fraction(2));\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = {\n+                {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                {new Fraction(2),new Fraction(5),new Fraction(3)}\n+        };\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = {\n+                {new Fraction(1),new Fraction(2)},\n+                {new Fraction(2),new Fraction(5)},\n+                {new Fraction(1), new Fraction(7)}\n+        };\n+        FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        Fraction[][] coefficientsData = {\n+                {new Fraction(2), new Fraction(3), new Fraction(-2)},\n+                {new Fraction(-1), new Fraction(7), new Fraction(6)},\n+                {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n+        };\n+        FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData);\n+        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals(new Fraction(2).multiply(solution[0]).\n+                     add(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(2).multiply(solution[2])), constants[0]);\n+        assertEquals(new Fraction(-1).multiply(solution[0]).\n+                     add(new Fraction(7).multiply(solution[1])).\n+                     add(new Fraction(6).multiply(solution[2])), constants[1]);\n+        assertEquals(new Fraction(4).multiply(solution[0]).\n+                     subtract(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });\n+    }\n+\n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testCopySubMatrix() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, -1, 1, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n+    }\n+\n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                             new Fraction[1][1] :\n+                             new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int[] selectedRows, int[] selectedColumns) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                    new Fraction[1][1] :\n+                    new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetRowMatrix() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, \n+                m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, \n+                m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayFieldVector<Fraction>(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumn() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn1 = columnToArray(subColumn1);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private Fraction[] columnToArray(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(Fraction[] expected, Fraction[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();\n+        Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        assertEquals(\"Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n+        assertEquals(\"Array2DRowFieldMatrix{}\", m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        FieldMatrix<Fraction> expected = new Array2DRowFieldMatrix<Fraction>\n+            (new Fraction[][] {\n+                    {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                    {new Fraction(2),new Fraction(1),new Fraction(3)},\n+                    {new Fraction(1),new Fraction(2),new Fraction(4)}\n+             });\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new Array2DRowFieldMatrix<Fraction>\n+            (new Fraction[][] {\n+                    {new Fraction(1),new Fraction(3),new Fraction(3)},\n+                    {new Fraction(2),new Fraction(4),new Fraction(3)},\n+                    {new Fraction(1),new Fraction(2),new Fraction(4)}\n+             });\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new Array2DRowFieldMatrix<Fraction>\n+            (new Fraction[][] {\n+                    {new Fraction(3),new Fraction(4),new Fraction(5)},\n+                    {new Fraction(4),new Fraction(7),new Fraction(5)},\n+                    {new Fraction(3),new Fraction(2),new Fraction(10)}\n+             });\n+        assertEquals(expected, m);   \n+        \n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n+        try {\n+            m2.setSubMatrix(testData,0,1);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        try {\n+            m2.setSubMatrix(testData,1,0);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        FieldMatrix<Fraction> m =\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+  \n+    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n+        public SetVisitor() {\n+            super(Fraction.ZERO);\n+        }\n+        @Override\n+        public Fraction visit(int i, int j, Fraction value) {\n+            return new Fraction(i * 1024 + j, 1024);\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n+        private int count;\n+        public GetVisitor() {\n+            super(Fraction.ZERO);\n+            count = 0;\n+        }\n+        @Override\n+        public void visit(int i, int j, Fraction value) {\n+            ++count;\n+            assertEquals(new Fraction(i * 1024 + j, 1024), value);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(FieldMatrix<Fraction> lu,\n+                           Fraction[][] lowerData,\n+                           Fraction[][] upperData)\n+        throws InvalidMatrixException {   \n+        if (!lu.isSquare() ||\n+            lowerData.length != lowerData[0].length ||\n+            upperData.length != upperData[0].length ||\n+            lowerData.length != upperData.length ||\n+            lowerData.length != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                if (j < i) {\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = Fraction.ZERO;\n+                } else if (i == j) {\n+                    lowerData[i][j] = Fraction.ONE;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                } else {\n+                    lowerData[i][j] = Fraction.ZERO;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        int m = matrix.getColumnDimension();\n+        Fraction out[][] = new Fraction[m][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n+            }\n+        }\n+        return new Array2DRowFieldMatrix<Fraction>(out);\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class InvalidMatrixExceptionTest extends TestCase {\n+    \n+    public void testConstructorMessage(){\n+        String msg = \"message\";\n+        InvalidMatrixException ex = new InvalidMatrixException(msg);\n+        assertEquals(msg, ex.getMessage());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecomposition;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class LUDecompositionImplTest extends TestCase {\n+    private double[][] testData = {\n+            { 1.0, 2.0, 3.0},\n+            { 2.0, 5.0, 3.0},\n+            { 1.0, 0.0, 8.0}\n+    };\n+    private double[][] testDataMinus = {\n+            { -1.0, -2.0, -3.0},\n+            { -2.0, -5.0, -3.0},\n+            { -1.0,  0.0, -8.0}\n+    };\n+    private double[][] luData = {\n+            { 2.0, 3.0, 3.0 },\n+            { 0.0, 5.0, 7.0 },\n+            { 6.0, 9.0, 8.0 }\n+    };\n+    \n+    // singular matrices\n+    private double[][] singular = {\n+            { 2.0, 3.0 },\n+            { 2.0, 3.0 }\n+    };\n+    private double[][] bigSingular = {\n+            { 1.0, 2.0,   3.0,    4.0 },\n+            { 2.0, 5.0,   3.0,    4.0 },\n+            { 7.0, 3.0, 256.0, 1930.0 },\n+            { 3.0, 7.0,   6.0,    8.0 }\n+    }; // 4th row = 1st + 2nd\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public LUDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LUDecompositionImplTest.class);\n+        suite.setName(\"LUDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        LUDecomposition LU = new LUDecompositionImpl(matrix);\n+        assertEquals(testData.length, LU.getL().getRowDimension());\n+        assertEquals(testData.length, LU.getL().getColumnDimension());\n+        assertEquals(testData.length, LU.getU().getRowDimension());\n+        assertEquals(testData.length, LU.getU().getColumnDimension());\n+        assertEquals(testData.length, LU.getP().getRowDimension());\n+        assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    public void testNonSquare() {\n+        try {\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test PA = LU */\n+    public void testPAEqualLU() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        LUDecomposition lu = new LUDecompositionImpl(matrix);\n+        RealMatrix l = lu.getL();\n+        RealMatrix u = lu.getU();\n+        RealMatrix p = lu.getP();\n+        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealMatrix(testDataMinus);\n+        lu = new LUDecompositionImpl(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealIdentityMatrix(17);\n+        lu = new LUDecompositionImpl(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealMatrix(singular);\n+        lu = new LUDecompositionImpl(matrix);\n+        assertFalse(lu.getSolver().isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+        matrix = MatrixUtils.createRealMatrix(bigSingular);\n+        lu = new LUDecompositionImpl(matrix);\n+        assertFalse(lu.getSolver().isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    public void testLLowerTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix l = new LUDecompositionImpl(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            assertEquals(l.getEntry(i, i), 1, entryTolerance);\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(l.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    public void testUUpperTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix u = new LUDecompositionImpl(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(u.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    public void testPPermutation() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix p   = new LUDecompositionImpl(matrix).getP();\n+\n+        RealMatrix ppT = p.multiply(p.transpose());\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());\n+        assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getRowDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+\n+    /** test singular */\n+    public void testSingular() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+        assertTrue(lu.getSolver().isNonSingular());\n+        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular));\n+        assertFalse(lu.getSolver().isNonSingular());\n+        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular));\n+        assertFalse(lu.getSolver().isNonSingular());\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       LUDecomposition lu =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1.0, 0.0, 0.0 },\n+                { 0.5, 1.0, 0.0 },\n+                { 0.5, 0.2, 1.0 }\n+        });\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 2.0,  5.0, 3.0 },\n+                { 0.0, -2.5, 6.5 },\n+                { 0.0,  0.0, 0.2 }\n+        });\n+        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 0.0, 0.0, 1.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 1, 2, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+       LUDecomposition lu =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(luData));\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                {    1.0,    0.0, 0.0 },\n+                {    0.0,    1.0, 0.0 },\n+                { 1.0 / 3.0, 0.0, 1.0 }\n+        });\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 6.0, 9.0,    8.0    },\n+                { 0.0, 5.0,    7.0    },\n+                { 0.0, 0.0, 1.0 / 3.0 }\n+        });\n+        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 2, 1, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+public class LUSolverTest extends TestCase {\n+    private double[][] testData = {\n+            { 1.0, 2.0, 3.0},\n+            { 2.0, 5.0, 3.0},\n+            { 1.0, 0.0, 8.0}\n+    };\n+    private double[][] luData = {\n+            { 2.0, 3.0, 3.0 },\n+            { 0.0, 5.0, 7.0 },\n+            { 6.0, 9.0, 8.0 }\n+    };\n+    \n+    // singular matrices\n+    private double[][] singular = {\n+            { 2.0, 3.0 },\n+            { 2.0, 3.0 }\n+    };\n+    private double[][] bigSingular = {\n+            { 1.0, 2.0,   3.0,    4.0 },\n+            { 2.0, 5.0,   3.0,    4.0 },\n+            { 7.0, 3.0, 256.0, 1930.0 },\n+            { 3.0, 7.0,   6.0,    8.0 }\n+    }; // 4th row = 1st + 2nd\n+\n+    public LUSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LUSolverTest.class);\n+        suite.setName(\"LUSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test threshold impact */\n+    public void testThreshold() {\n+        final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {\n+                                                       { 1.0, 2.0, 3.0},\n+                                                       { 2.0, 5.0, 3.0},\n+                                                       { 4.000001, 9.0, 9.0}\n+                                                     });\n+        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());\n+        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());\n+    }\n+\n+    /** test singular */\n+    public void testSingular() {\n+        DecompositionSolver solver =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        assertTrue(solver.isNonSingular());\n+        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();\n+        assertFalse(solver.isNonSingular());\n+        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)).getSolver();\n+        assertFalse(solver.isNonSingular());\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        DecompositionSolver solver =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        DecompositionSolver solver =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        DecompositionSolver solver =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1, 0 }, { 2, -5 }, { 3, 1 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 19, -71 }, { -6, 22 }, { -2, 9 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using ArrayRealVector\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test determinant */\n+    public void testDeterminant() {\n+        assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n+        assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);\n+        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);\n+        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);\n+    }\n+\n+    private double getDeterminant(RealMatrix m) {\n+        return new LUDecompositionImpl(m).getDeterminant();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixIndexExceptionTest extends TestCase {\n+    \n+    /**\n+     * \n+     */\n+    public void testConstructorMessage(){\n+        String msg = \"message\";\n+        MatrixIndexException ex = new MatrixIndexException(msg);\n+        assertEquals(msg, ex.getMessage());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.math.BigDecimal;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link MatrixUtils} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class MatrixUtilsTest extends TestCase {\n+    \n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] nullMatrix = null;\n+    protected double[] row = {1,2,3};\n+    protected BigDecimal[] bigRow = \n+        {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};\n+    protected String[] stringRow = {\"1\", \"2\", \"3\"};\n+    protected Fraction[] fractionRow = \n+        {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected double[][] rowMatrix = {{1,2,3}};\n+    protected BigDecimal[][] bigRowMatrix = \n+        {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};\n+    protected String[][] stringRowMatrix = {{\"1\", \"2\", \"3\"}};\n+    protected Fraction[][] fractionRowMatrix = \n+        {{new Fraction(1), new Fraction(2), new Fraction(3)}};\n+    protected double[] col = {0,4,6};\n+    protected BigDecimal[] bigCol = \n+        {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};\n+    protected String[] stringCol = {\"0\",\"4\",\"6\"};\n+    protected Fraction[] fractionCol = \n+        {new Fraction(0),new Fraction(4),new Fraction(6)};\n+    protected double[] nullDoubleArray = null;\n+    protected double[][] colMatrix = {{0},{4},{6}};\n+    protected BigDecimal[][] bigColMatrix = \n+        {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};\n+    protected String[][] stringColMatrix = {{\"0\"}, {\"4\"}, {\"6\"}};\n+    protected Fraction[][] fractionColMatrix = \n+        {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}};\n+    \n+    public MatrixUtilsTest(String name) {\n+        super(name);\n+    }\n+    \n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MatrixUtilsTest.class);\n+        suite.setName(\"MatrixUtils Tests\");\n+        return suite;\n+    }\n+    \n+    public void testCreateRealMatrix() {\n+        assertEquals(new BlockRealMatrix(testData), \n+                MatrixUtils.createRealMatrix(testData));\n+        try {\n+            MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        try {\n+            MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createRealMatrix(null);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+\n+    public void testcreateFieldMatrix() {\n+        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)), \n+                     MatrixUtils.createFieldMatrix(asFraction(testData)));\n+        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix), \n+                     MatrixUtils.createFieldMatrix(fractionColMatrix));\n+        try {\n+            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        try {\n+            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createFieldMatrix((Fraction[][])null);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+\n+    @Deprecated\n+    public void testCreateBigMatrix() {\n+        assertEquals(new BigMatrixImpl(testData), \n+                MatrixUtils.createBigMatrix(testData));\n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), \n+                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));\n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), \n+                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));\n+        assertEquals(new BigMatrixImpl(bigColMatrix), \n+                MatrixUtils.createBigMatrix(bigColMatrix));\n+        assertEquals(new BigMatrixImpl(stringColMatrix), \n+                MatrixUtils.createBigMatrix(stringColMatrix));\n+        try {\n+            MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        try {\n+            MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createBigMatrix(nullMatrix);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+        \n+    public void testCreateRowRealMatrix() {\n+        assertEquals(MatrixUtils.createRowRealMatrix(row),\n+                     new BlockRealMatrix(rowMatrix));\n+        try {\n+            MatrixUtils.createRowRealMatrix(new double[] {});  // empty\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createRowRealMatrix(null);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+    \n+    public void testCreateRowFieldMatrix() {\n+        assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),\n+                     new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));\n+        assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),\n+                     new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));\n+        try {\n+            MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+\n+    @Deprecated\n+    public void testCreateRowBigMatrix() {\n+        assertEquals(MatrixUtils.createRowBigMatrix(row),\n+                new BigMatrixImpl(rowMatrix));\n+        assertEquals(MatrixUtils.createRowBigMatrix(bigRow),\n+                new BigMatrixImpl(bigRowMatrix));\n+        assertEquals(MatrixUtils.createRowBigMatrix(stringRow),\n+                new BigMatrixImpl(stringRowMatrix));\n+        try {\n+            MatrixUtils.createRowBigMatrix(new double[] {});  // empty\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+\n+    public void testCreateColumnRealMatrix() {\n+        assertEquals(MatrixUtils.createColumnRealMatrix(col),\n+                     new BlockRealMatrix(colMatrix));\n+        try {\n+            MatrixUtils.createColumnRealMatrix(new double[] {});  // empty\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createColumnRealMatrix(null);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+    \n+    public void testCreateColumnFieldMatrix() {\n+        assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),\n+                     new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));\n+        assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),\n+                     new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));\n+\n+        try {\n+            MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+\n+    @Deprecated\n+    public void testCreateColumnBigMatrix() {\n+        assertEquals(MatrixUtils.createColumnBigMatrix(col),\n+                new BigMatrixImpl(colMatrix));\n+        assertEquals(MatrixUtils.createColumnBigMatrix(bigCol),\n+                new BigMatrixImpl(bigColMatrix));\n+        assertEquals(MatrixUtils.createColumnBigMatrix(stringCol),\n+                new BigMatrixImpl(stringColMatrix));   \n+       \n+        try {\n+            MatrixUtils.createColumnBigMatrix(new double[] {});  // empty\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        } \n+    }\n+\n+    /**\n+     * Verifies that the matrix is an identity matrix\n+     */\n+    protected void checkIdentityMatrix(RealMatrix m) {\n+        for (int i = 0; i < m.getRowDimension(); i++) {\n+            for (int j =0; j < m.getColumnDimension(); j++) {\n+                if (i == j) {\n+                    assertEquals(m.getEntry(i, j), 1d, 0);\n+                } else {\n+                    assertEquals(m.getEntry(i, j), 0d, 0);\n+                }\n+            }\n+        }   \n+    }\n+    \n+    public void testCreateIdentityMatrix() {\n+        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));\n+        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));\n+        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));\n+        try {\n+            MatrixUtils.createRealIdentityMatrix(0);\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /**\n+     * Verifies that the matrix is an identity matrix\n+     */\n+    protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m) {\n+        for (int i = 0; i < m.getRowDimension(); i++) {\n+            for (int j =0; j < m.getColumnDimension(); j++) {\n+                if (i == j) {\n+                    assertEquals(m.getEntry(i, j), Fraction.ONE);\n+                } else {\n+                    assertEquals(m.getEntry(i, j), Fraction.ZERO);\n+                }\n+            }\n+        }   \n+    }\n+    \n+    public void testcreateFieldIdentityMatrix() {\n+        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3));\n+        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2));\n+        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1));\n+        try {\n+            MatrixUtils.createRealIdentityMatrix(0);\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testBigFractionConverter() {\n+        BigFraction[][] bfData = {\n+                { new BigFraction(1), new BigFraction(2), new BigFraction(3) },\n+                { new BigFraction(2), new BigFraction(5), new BigFraction(3) },\n+                { new BigFraction(1), new BigFraction(0), new BigFraction(8) }\n+        };\n+        FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false);\n+        RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m);\n+        RealMatrix reference = new Array2DRowRealMatrix(testData, false);\n+        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n+    }\n+\n+    public void testFractionConverter() {\n+        Fraction[][] fData = {\n+                { new Fraction(1), new Fraction(2), new Fraction(3) },\n+                { new Fraction(2), new Fraction(5), new Fraction(3) },\n+                { new Fraction(1), new Fraction(0), new Fraction(8) }\n+        };\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false);\n+        RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m);\n+        RealMatrix reference = new Array2DRowRealMatrix(testData, false);\n+        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n+    }\n+\n+    public static final Fraction[][] asFraction(double[][] data) {\n+        Fraction d[][] = new Fraction[data.length][];\n+        try {\n+            for (int i = 0; i < data.length; ++i) {\n+                double[] dataI = data[i];\n+                Fraction[] dI  = new Fraction[dataI.length];\n+                for (int j = 0; j < dataI.length; ++j) {\n+                    dI[j] = new Fraction(dataI[j]);\n+                }\n+                d[i] = dI;\n+            }\n+        } catch (FractionConversionException fce) {\n+            fail(fce.getMessage());\n+        }\n+        return d;\n+    }\n+\n+    public static final Fraction[] asFraction(double[] data) {\n+        Fraction d[] = new Fraction[data.length];\n+        try {\n+            for (int i = 0; i < data.length; ++i) {\n+                d[i] = new Fraction(data[i]);\n+            }\n+        } catch (FractionConversionException fce) {\n+            fail(fce.getMessage());\n+        }\n+        return d;\n+    }\n+\n+    /**\n+     * Verifies that the matrix is an identity matrix\n+     */\n+    @Deprecated\n+    protected void checkIdentityBigMatrix(BigMatrix m) {\n+        for (int i = 0; i < m.getRowDimension(); i++) {\n+            for (int j =0; j < m.getColumnDimension(); j++) {\n+                if (i == j) {\n+                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);\n+                } else {\n+                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);\n+                }\n+            }\n+        }   \n+    }\n+\n+    @Deprecated\n+    public void testCreateBigIdentityMatrix() {\n+        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));\n+        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));\n+        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));\n+        try {\n+            MatrixUtils.createRealIdentityMatrix(0);\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.QRDecomposition;\n+import org.apache.commons.math.linear.QRDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class QRDecompositionImplTest extends TestCase {\n+    double[][] testData3x3NonSingular = { \n+            { 12, -51, 4 }, \n+            { 6, 167, -68 },\n+            { -4, 24, -41 }, };\n+\n+    double[][] testData3x3Singular = { \n+            { 1, 4, 7, }, \n+            { 2, 5, 8, },\n+            { 3, 6, 9, }, };\n+\n+    double[][] testData3x4 = { \n+            { 12, -51, 4, 1 }, \n+            { 6, 167, -68, 2 },\n+            { -4, 24, -41, 3 }, };\n+\n+    double[][] testData4x3 = { \n+            { 12, -51, 4, }, \n+            { 6, 167, -68, },\n+            { -4, 24, -41, }, \n+            { -5, 34, 7, }, };\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public QRDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(QRDecompositionImplTest.class);\n+        suite.setName(\"QRDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkDimension(createTestMatrix(r, p, q));\n+        checkDimension(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkDimension(RealMatrix m) {\n+        int rows = m.getRowDimension();\n+        int columns = m.getColumnDimension();\n+        QRDecomposition qr = new QRDecompositionImpl(m);\n+        assertEquals(rows,    qr.getQ().getRowDimension());\n+        assertEquals(rows,    qr.getQ().getColumnDimension());\n+        assertEquals(rows,    qr.getR().getRowDimension());\n+        assertEquals(columns, qr.getR().getColumnDimension());        \n+    }\n+\n+    /** test A = QR */\n+    public void testAEqualQR() {\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkAEqualQR(createTestMatrix(r, p, q));\n+\n+        checkAEqualQR(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkAEqualQR(RealMatrix m) {\n+        QRDecomposition qr = new QRDecompositionImpl(m);\n+        double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test the orthogonality of Q */\n+    public void testQOrthogonal() {\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkQOrthogonal(createTestMatrix(r, p, q));\n+\n+        checkQOrthogonal(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkQOrthogonal(RealMatrix m) {\n+        QRDecomposition qr = new QRDecompositionImpl(m);\n+        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());\n+        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test that R is upper triangular */\n+    public void testRUpperTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+    }\n+\n+    private void checkUpperTriangular(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column < row) {\n+                    assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+\n+    /** test that H is trapezoidal */\n+    public void testHTrapezoidal() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+    }\n+\n+    private void checkTrapezoidal(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column > row) {\n+                    assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+    /** test matrices values */\n+    public void testMatricesValues() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n+                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n+                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }\n+        });\n+        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -14.0,  -21.0, 14.0 },\n+                {   0.0, -175.0, 70.0 },\n+                {   0.0,    0.0, 35.0 }\n+        });\n+        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 26.0 / 14.0, 0.0, 0.0 },\n+                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },\n+                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix q = qr.getQ();\n+        assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        RealMatrix qT = qr.getQT();\n+        assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n+        RealMatrix r = qr.getR();\n+        assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n+        RealMatrix h = qr.getH();\n+        assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(q == qr.getQ());\n+        assertTrue(r == qr.getR());\n+        assertTrue(h == qr.getH());\n+        \n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            @Override\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.QRDecomposition;\n+import org.apache.commons.math.linear.QRDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+public class QRSolverTest extends TestCase {\n+    double[][] testData3x3NonSingular = { \n+            { 12, -51,   4 }, \n+            {  6, 167, -68 },\n+            { -4,  24, -41 }\n+    };\n+\n+    double[][] testData3x3Singular = { \n+            { 1, 2,  2 }, \n+            { 2, 4,  6 },\n+            { 4, 8, 12 }\n+    };\n+\n+    double[][] testData3x4 = { \n+            { 12, -51,   4, 1 }, \n+            {  6, 167, -68, 2 },\n+            { -4,  24, -41, 3 }\n+    };\n+\n+    double[][] testData4x3 = { \n+            { 12, -51,   4 }, \n+            {  6, 167, -68 },\n+            { -4,  24, -41 }, \n+            { -5,  34,   7 }\n+    };\n+\n+    public QRSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(QRSolverTest.class);\n+        suite.setName(\"QRSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test rank */\n+    public void testRank() {\n+        DecompositionSolver solver =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+        assertTrue(solver.isNonSingular());\n+\n+        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n+        assertFalse(solver.isNonSingular());\n+\n+        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();\n+        assertTrue(solver.isNonSingular());\n+\n+        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();\n+        assertTrue(solver.isNonSingular());\n+\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        DecompositionSolver solver =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve rank errors */\n+    public void testSolveRankErrors() {\n+        DecompositionSolver solver =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        QRDecomposition decomposition =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        DecompositionSolver solver = decomposition.getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            final double[] x = solver.solve(b.getColumn(i));\n+            final double error = new ArrayRealVector(x).subtract(xRef.getColumnVector(i)).getNorm();\n+            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+        // using ArrayRealVector\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            final RealVector x = solver.solve(b.getColumnVector(i));\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            final RealVector x = solver.solve(v);\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+    }\n+\n+    public void testOverdetermined() {\n+        final Random r    = new Random(5559252868205245l);\n+        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n+\n+        // build a perturbed system: A.X + noise = B\n+        RealMatrix b = a.multiply(xRef);\n+        final double noise = 0.001;\n+        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            @Override\n+            public double visit(int row, int column, double value) {\n+                return value * (1.0 + noise * (2 * r.nextDouble() - 1));\n+            }\n+        });\n+\n+        // despite perturbation, the least square solution should be pretty good\n+        RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);\n+        assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n+\n+    }\n+\n+    public void testUnderdetermined() {\n+        final Random r    = new Random(42185006424567123l);\n+        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n+        RealMatrix   b    = a.multiply(xRef);\n+        RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);\n+\n+        // too many equations, the system cannot be solved at all\n+        assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);\n+\n+        // the last unknown should have been set to 0\n+        assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm());\n+\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            @Override\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link RealMatrixImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+@Deprecated\n+public final class RealMatrixImplTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public RealMatrixImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RealMatrixImplTest.class);\n+        suite.setName(\"RealMatrixImpl Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        RealMatrixImpl m1 = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());\n+        assertEquals(m2,m1);\n+        RealMatrixImpl m3 = new RealMatrixImpl(testData);\n+        RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);\n+        assertEquals(m4,m3);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);\n+        TestUtils.assertEquals(\"m-n = m + -n\",m.subtract(m2),\n+            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+        try {\n+            m.subtract(new RealMatrixImpl(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n+        RealMatrixImpl identity = new RealMatrixImpl(id);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        TestUtils.assertEquals(\"inverse multiply\",m.multiply(mInv),\n+            identity,entryTolerance);\n+        TestUtils.assertEquals(\"inverse multiply\",mInv.multiply(m),\n+            identity,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m.multiply(identity),\n+            m,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",identity.multiply(mInv),\n+            mInv,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m2.multiply(identity),\n+            m2,entryTolerance); \n+        try {\n+            m.multiply(new RealMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }   \n+    \n+    //Additional Test for RealMatrixImplTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new RealMatrixImpl(d3);   \n+       RealMatrix m4 = new RealMatrixImpl(d4);\n+       RealMatrix m5 = new RealMatrixImpl(d5);\n+       TestUtils.assertEquals(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new RealMatrixImpl(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new RealMatrixImpl(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        TestUtils.assertEquals(\"scalar add\",new RealMatrixImpl(testDataPlus2),\n+            m.scalarAdd(2d),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new RealMatrixImpl(id);\n+        TestUtils.assertEquals(\"identity operate\", testVector,\n+                    m.operate(testVector), entryTolerance);\n+        TestUtils.assertEquals(\"identity operate\", testVector,\n+                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);\n+        m = new RealMatrixImpl(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new RealMatrixImpl(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        }, false);\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new RealMatrixImpl(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = new RealMatrixImpl(testData2);\n+        RealMatrix mt = new RealMatrixImpl(testData2T);\n+        TestUtils.assertEquals(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(testVector),\n+                    preMultTest, normTolerance);\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(new ArrayRealVector(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new RealMatrixImpl(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new RealMatrixImpl(d3);   \n+        RealMatrix m4 = new RealMatrixImpl(d4);\n+        RealMatrix m5 = new RealMatrixImpl(d5);\n+        TestUtils.assertEquals(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n+        RealMatrixImpl identity = new RealMatrixImpl(id);\n+        TestUtils.assertEquals(\"inverse multiply\",m.preMultiply(mInv),\n+                identity,entryTolerance);\n+        TestUtils.assertEquals(\"inverse multiply\",mInv.preMultiply(m),\n+                identity,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m.preMultiply(identity),\n+                m,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",identity.preMultiply(mInv),\n+                mInv,entryTolerance);\n+        try {\n+            m.preMultiply(new RealMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        TestUtils.assertEquals(\"get row\",m.getRow(0),testDataRow1,entryTolerance);\n+        TestUtils.assertEquals(\"get col\",m.getColumn(2),testDataCol3,entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new RealMatrixImpl(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new RealMatrixImpl(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new RealMatrixImpl(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new RealMatrixImpl(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new RealMatrixImpl(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testCopySubMatrix() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                             new double[1][1] :\n+                             new double[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                    new double[1][1] :\n+                    new double[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealMatrix mRow0 = new RealMatrixImpl(subRow0);\n+        RealMatrix mRow3 = new RealMatrixImpl(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetRowMatrix() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealMatrix mRow3 = new RealMatrixImpl(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);\n+        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, \n+                m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, \n+                m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayRealVector(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m1 = (RealMatrixImpl) m.copy();\n+        RealMatrixImpl mt = (RealMatrixImpl) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new RealMatrixImpl(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        assertEquals(\"RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+        m = new RealMatrixImpl();\n+        assertEquals(\"RealMatrixImpl{}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        RealMatrixImpl m2 = new RealMatrixImpl();\n+        try {\n+            m2.setSubMatrix(testData,0,1);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        try {\n+            m2.setSubMatrix(testData,1,0);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new RealMatrixImpl(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+    \n+    \n+    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n+        @Override\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n+        private int count = 0;\n+        @Override\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   \n+        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n+                lowerData.length != upperData.length\n+                || lowerData.length != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                if (j < i) {\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = 0d;\n+                } else if (i == j) {\n+                    lowerData[i][j] = 1d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                } else {\n+                    lowerData[i][j] = 0d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        int m = matrix.getColumnDimension();\n+        double out[][] = new double[m][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n+            }\n+        }\n+        return new RealMatrixImpl(out);\n+    }\n+    \n+//    /** Useful for debugging */\n+//    private void dumpMatrix(RealMatrix m) {\n+//          for (int i = 0; i < m.getRowDimension(); i++) {\n+//              String os = \"\";\n+//              for (int j = 0; j < m.getColumnDimension(); j++) {\n+//                  os += m.getEntry(i, j) + \" \";\n+//              }\n+//              System.out.println(os);\n+//          }\n+//    }\n+        \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+public abstract class RealVectorFormatAbstractTest extends TestCase {\n+ \n+    RealVectorFormat realVectorFormat = null;\n+    RealVectorFormat realVectorFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        realVectorFormat = RealVectorFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        realVectorFormatSquare = new RealVectorFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});\n+        String expected = \"{1; 1; 1}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeX() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeY() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeZ() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNonDefaultSetting() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = realVectorFormatSquare.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatRealVectorImpl() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        ArrayRealVector c = new ArrayRealVector(new double[] {232.222, -342.33, 432.444});\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = RealVectorFormat.formatRealVector(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {\n+                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n+        });\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void tesNegativeInfinity() {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {\n+                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        });\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseIgnoredWhitespace() {\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        assertEquals(expected, realVectorFormat.parseObject(source1, pos1));\n+        assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        assertEquals(expected, realVectorFormat.parseObject(source2, pos2));\n+        assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormatSquare.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source); \n+            assertEquals(new ArrayRealVector(new double[] {\n+                    Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n+            }), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source); \n+            assertEquals(new ArrayRealVector(new double[] {\n+                    Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n+            }), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNoComponents() {\n+        try {\n+            realVectorFormat.parseObject(\"{ }\");\n+        } catch (ParseException pe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testParseManyComponents() throws ParseException {\n+        ArrayRealVector parsed =\n+            (ArrayRealVector) realVectorFormat.parseObject(\"{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}\");\n+        assertEquals(24, parsed.getDimension());\n+    }\n+\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        RealVectorFormat cf = new RealVectorFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getFormat());\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new RealVectorFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"1; 1; 1}\", pos));\n+        assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"{1; 1 1}\", pos));\n+        assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"{1; 1; 1 \", pos));\n+        assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class RealVectorFormatTest extends RealVectorFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.SingularValueDecomposition;\n+import org.apache.commons.math.linear.SingularValueDecompositionImpl;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class SingularValueDecompositionImplTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private double[][] testNonSquare = {\n+        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },\n+        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },\n+        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },\n+        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },\n+    };\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public SingularValueDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SingularValueDecompositionImplTest.class);\n+        suite.setName(\"SingularValueDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    public void testMoreRows() {\n+        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n+        final int rows    = singularValues.length + 2;\n+        final int columns = singularValues.length;\n+        Random r = new Random(15338437322523l);\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));\n+        double[] computedSV = svd.getSingularValues();\n+        assertEquals(singularValues.length, computedSV.length);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+        }\n+    }\n+\n+    public void testMoreColumns() {\n+        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n+        final int rows    = singularValues.length;\n+        final int columns = singularValues.length + 2;\n+        Random r = new Random(732763225836210l);\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));\n+        double[] computedSV = svd.getSingularValues();\n+        assertEquals(singularValues.length, computedSV.length);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+        }\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n+        assertEquals(m, svd.getU().getRowDimension());\n+        assertEquals(m, svd.getU().getColumnDimension());\n+        assertEquals(m, svd.getS().getColumnDimension());\n+        assertEquals(n, svd.getS().getColumnDimension());\n+        assertEquals(n, svd.getV().getRowDimension());\n+        assertEquals(n, svd.getV().getColumnDimension());\n+\n+    }\n+\n+    /** Test based on a dimension 4 Hadamard matrix. */\n+    public void testHadamard() {\n+        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {\n+                {15.0 / 2.0,  5.0 / 2.0,  9.0 / 2.0,  3.0 / 2.0 },\n+                { 5.0 / 2.0, 15.0 / 2.0,  3.0 / 2.0,  9.0 / 2.0 },\n+                { 9.0 / 2.0,  3.0 / 2.0, 15.0 / 2.0,  5.0 / 2.0 },\n+                { 3.0 / 2.0,  9.0 / 2.0,  5.0 / 2.0, 15.0 / 2.0 }\n+        }, false);\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n+        assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);\n+        assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);\n+        assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);\n+        assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);\n+\n+        RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] {\n+                {  85.0 / 1024, -51.0 / 1024, -75.0 / 1024,  45.0 / 1024 },\n+                { -51.0 / 1024,  85.0 / 1024,  45.0 / 1024, -75.0 / 1024 },\n+                { -75.0 / 1024,  45.0 / 1024,  85.0 / 1024, -51.0 / 1024 },\n+                {  45.0 / 1024, -75.0 / 1024, -51.0 / 1024,  85.0 / 1024 }\n+        }, false);\n+        assertEquals(0.0,\n+                     fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),\n+                     1.0e-14);\n+\n+        RealMatrix halfCovariance = new Array2DRowRealMatrix(new double[][] {\n+                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },\n+                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 },\n+                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },\n+                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 }\n+        }, false);\n+        assertEquals(0.0,\n+                     halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),\n+                     1.0e-14);\n+\n+    }\n+\n+    /** test A = USVt */\n+    public void testAEqualUSVt() {\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n+    }\n+\n+    public void checkAEqualUSVt(final RealMatrix matrix) {\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n+        RealMatrix u = svd.getU();\n+        RealMatrix s = svd.getS();\n+        RealMatrix v = svd.getV();\n+        double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+    }\n+\n+    /** test that U is orthogonal */\n+    public void testUOrthogonal() {\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());\n+    }\n+\n+    /** test that V is orthogonal */\n+    public void testVOrthogonal() {\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());\n+    }\n+\n+    public void checkOrthogonal(final RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 3.0 / 5.0, -4.0 / 5.0 },\n+                { 4.0 / 5.0,  3.0 / 5.0 }\n+        });\n+        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 3.0, 0.0 },\n+                { 0.0, 1.0 }\n+        });\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 4.0 / 5.0,  3.0 / 5.0 },\n+                { 3.0 / 5.0, -4.0 / 5.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix u = svd.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        RealMatrix s = svd.getS();\n+        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        RealMatrix v = svd.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == svd.getU());\n+        assertTrue(s == svd.getS());\n+        assertTrue(v == svd.getV());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+            {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },\n+            { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },\n+            {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },\n+            { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }\n+        });\n+        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {\n+            { 4.0, 0.0, 0.0 },\n+            { 0.0, 3.0, 0.0 },\n+            { 0.0, 0.0, 2.0 }\n+        });\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n+            {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },\n+            {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },\n+            { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }\n+        });\n+\n+        // check values against known references\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare));\n+        RealMatrix u = svd.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        RealMatrix s = svd.getS();\n+        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        RealMatrix v = svd.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == svd.getU());\n+        assertTrue(s == svd.getS());\n+        assertTrue(v == svd.getV());\n+\n+    }\n+\n+    /** test condition number */\n+    public void testConditionNumber() {\n+        SingularValueDecompositionImpl svd =\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n+        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,\n+                                        final double[] singularValues) {\n+        final RealMatrix u =\n+            EigenDecompositionImplTest.createOrthogonalMatrix(r, rows);\n+        final RealMatrix d =\n+            EigenDecompositionImplTest.createDiagonalMatrix(singularValues, rows, columns);\n+        final RealMatrix v =\n+            EigenDecompositionImplTest.createOrthogonalMatrix(r, columns);\n+        return u.multiply(d).multiply(v);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.linear.SingularValueDecompositionImpl;\n+\n+public class SingularValueSolverTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public SingularValueSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SingularValueSolverTest.class);\n+        suite.setName(\"SingularValueSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        DecompositionSolver solver =\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        RealMatrix m =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   { 1.0, 0.0 },\n+                                   { 0.0, 0.0 }\n+                               });\n+        DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        DecompositionSolver solver =\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1, 2, 3 }, { 0, -5, 1 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },\n+                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using Array2DRowRealMatrix\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test condition number */\n+    public void testConditionNumber() {\n+        SingularValueDecompositionImpl svd =\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n+        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SparseFieldMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SparseFieldMatrixTest extends TestCase {\n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } };\n+    // Test data for group operations\n+    protected Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) },\n+            { new Fraction(1), new Fraction(0), new Fraction(8) } };\n+    protected Fraction[][] testDataLU = null;\n+    protected Fraction[][] testDataPlus2 = { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) },\n+            { new Fraction(3), new Fraction(2), new Fraction(10) } };\n+    protected Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3) },\n+            { new Fraction(-2), new Fraction(-5), new Fraction(-3) }, { new Fraction(-1), new Fraction(0), new Fraction(-8) } };\n+    protected Fraction[] testDataRow1 = { new Fraction(1), new Fraction(2), new Fraction(3) };\n+    protected Fraction[] testDataCol3 = { new Fraction(3), new Fraction(3), new Fraction(8) };\n+    protected Fraction[][] testDataInv = { { new Fraction(-40), new Fraction(16), new Fraction(9) }, { new Fraction(13), new Fraction(-5), new Fraction(-3) },\n+            { new Fraction(5), new Fraction(-2), new Fraction(-1) } };\n+    protected Fraction[] preMultTest = { new Fraction(8), new Fraction(12), new Fraction(33) };\n+    protected Fraction[][] testData2 = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };\n+    protected Fraction[][] testData2T = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(3), new Fraction(3) } };\n+    protected Fraction[][] testDataPlusInv = { { new Fraction(-39), new Fraction(18), new Fraction(12) },\n+            { new Fraction(15), new Fraction(0), new Fraction(0) }, { new Fraction(6), new Fraction(-2), new Fraction(7) } };\n+\n+    // lu decomposition tests\n+    protected Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(6), new Fraction(9), new Fraction(8) } };\n+    protected Fraction[][] luDataLUDecomposition = null;\n+\n+    // singular matrices\n+    protected Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } };\n+    protected Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },\n+            { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th\n+\n+    // row\n+    // =\n+    // 1st\n+    // +\n+    // 2nd\n+    protected Fraction[][] detData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(4), new Fraction(5), new Fraction(6) },\n+            { new Fraction(7), new Fraction(8), new Fraction(10) } };\n+    protected Fraction[][] detData2 = { { new Fraction(1), new Fraction(3) }, { new Fraction(2), new Fraction(4) } };\n+\n+    // vectors\n+    protected Fraction[] testVector = { new Fraction(1), new Fraction(2), new Fraction(3) };\n+    protected Fraction[] testVector2 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) };\n+\n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = null;\n+\n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4) }, { new Fraction(4), new Fraction(8) } };\n+    protected Fraction[][] subRows03Cols12 = { { new Fraction(2), new Fraction(3) }, { new Fraction(5), new Fraction(6) } };\n+    protected Fraction[][] subRows03Cols123 = { { new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7) } };\n+\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = { { new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(2), new Fraction(3), new Fraction(4) } };\n+    protected Fraction[][] subRows31Cols31 = null;\n+\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = null;\n+    protected Fraction[][] subRows23Cols00 = { { new Fraction(2) }, { new Fraction(4) } };\n+    protected Fraction[][] subRows00Cols33 = { { new Fraction(4) } };\n+\n+    // row matrices\n+    protected Fraction[][] subRow0 = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) } };\n+    protected Fraction[][] subRow3 = { { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };\n+\n+    // column matrices\n+    protected Fraction[][] subColumn1 = null;\n+    protected Fraction[][] subColumn3 = null;\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    protected Field<Fraction> field = FractionField.getInstance();\n+\n+    public SparseFieldMatrixTest(String name) {\n+        super(name);\n+        setupFractionArrays();\n+    }\n+\n+    private void setupFractionArrays() {\n+        try {\n+            testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) },\n+                    { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } };\n+            luDataLUDecomposition = new Fraction[][]{ { new Fraction(6), new Fraction(9), new Fraction(8) },\n+                { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } };\n+            subTestData = new Fraction [][]{ { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },\n+                    { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };\n+            subRows31Cols31 = new Fraction[][]{ { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } };\n+            subRows01Cols23 = new Fraction[][]{ { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } };\n+            subColumn1 = new Fraction [][]{ { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } };\n+            subColumn3 = new Fraction[][]{ { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } };\n+        } catch (FractionConversionException e) {\n+            // ignore, can't happen\n+        }\n+        \n+                \n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SparseFieldMatrixTest.class);\n+        suite.setName(\"SparseFieldMatrix<Fraction> Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n+        assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n+        assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n+        assertTrue(\"testData is square\", m.isSquare());\n+        assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n+        assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n+        assertTrue(\"testData2 is not square\", !m2.isSquare());\n+    }\n+\n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);\n+        FieldMatrix<Fraction> m2 = m1.copy();\n+        assertEquals(m1.getClass(), m2.getClass());\n+        assertEquals((m2), m1);\n+        SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);\n+        FieldMatrix<Fraction> m4 = m3.copy();\n+        assertEquals(m3.getClass(), m4.getClass());\n+        assertEquals((m4), m3);\n+    }\n+\n+    /** test add */\n+    public void testAdd() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n+        SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\", \n+                    mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(), \n+                    entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test add failure */\n+    public void testAddFail() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    \n+    /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv);\n+        assertClose(\"m-n = m + -n\", m.subtract(n),\n+            n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance);\n+        try {\n+            m.subtract(createSparseMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test multiply */\n+    public void testMultiply() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n+        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);\n+        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n+        assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", m.multiply(new Array2DRowFieldMatrix<Fraction>(testDataInv)), identity,\n+                    entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.multiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.multiply(mInv), mInv,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m2.multiply(identity), m2,\n+                entryTolerance);\n+        try {\n+            m.multiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    // Additional Test for Array2DRowRealMatrixTest.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } };\n+    private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };\n+    private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } };\n+\n+    public void testMultiply2() {\n+        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);\n+        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);\n+        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+    }\n+\n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(id);\n+        assertEquals(\"identity trace\", 3d, m.getTrace().doubleValue(), entryTolerance);\n+        m = createSparseMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2), \n+            m.scalarAdd(new Fraction(2)), entryTolerance);\n+    }\n+\n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(id);\n+        assertClose(\"identity operate\", testVector, m.operate(testVector),\n+                entryTolerance);\n+        assertClose(\"identity operate\", testVector, m.operate(\n+                new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } });\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals(3.0, b[0].doubleValue(), 1.0e-12);\n+        assertEquals(7.0, b[1].doubleValue(), 1.0e-12);\n+        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n+    }\n+\n+    /** test transpose */\n+    public void testTranspose() {\n+        \n+        FieldMatrix<Fraction> m = createSparseMatrix(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = createSparseMatrix(testData2);\n+        FieldMatrix<Fraction> mt = createSparseMatrix(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+\n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n+            normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(\n+            new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);\n+        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);\n+        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n+        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);\n+        assertClose(\"inverse multiply\", m.preMultiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.preMultiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.preMultiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.preMultiply(mInv), mInv,\n+                entryTolerance);\n+        try {\n+            m.preMultiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertClose(\"get row\", m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertEquals(\"get entry\", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };\n+        FieldMatrix<Fraction> m = createSparseMatrix(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } };\n+        FieldMatrix<Fraction> n = createSparseMatrix(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+\n+        // Solve example\n+        Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) },\n+                { new Fraction(4), new Fraction(-3), new Fraction(-5) } };\n+        FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);\n+        Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),\n+                constants[0].doubleValue(), 1E-12);\n+        assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),\n+                constants[1].doubleValue(), 1E-12);\n+        assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),\n+                constants[2].doubleValue(), 1E-12);\n+\n+    }\n+\n+    // test submatrix accessors\n+    public void testSubMatrix() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00);\n+        FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33);\n+        FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23);\n+        FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13);\n+        FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12);\n+        FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123);\n+        FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123);\n+        FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31);\n+        assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n+        assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n+        assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n+        assertEquals(\"Rows02Cols13\", mRows02Cols13, \n+            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n+        assertEquals(\"Rows03Cols12\", mRows03Cols12, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n+        assertEquals(\"Rows03Cols123\", mRows03Cols123, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows20Cols123\", mRows20Cols123, \n+            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(-1, 1, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {}, new int[] { 0 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0);\n+        FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayFieldVector<Fraction>(data, false);\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy();\n+        SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(createSparseMatrix(bigSingular)));\n+    }\n+\n+    /* Disable for now\n+    public void testToString() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\", \n+            m.toString());\n+        m = new SparseFieldMatrix<Fraction>(field, 1, 1);\n+        assertEquals(\"SparseFieldMatrix<Fraction>{{0.0}}\", m.toString());\n+    }\n+    */\n+\n+    public void testSetSubMatrix() throws Exception {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        m.setSubMatrix(detData2, 1, 1);\n+        FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(detData2, 0, 0);\n+        expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2, 0, 0);\n+        expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } });\n+        assertEquals(expected, m);\n+\n+        // javadoc example\n+        SparseFieldMatrix<Fraction> matrix = \n+            createSparseMatrix(new Fraction[][] { \n+        { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } });\n+        matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);\n+        expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } });\n+        assertEquals(expected, matrix);\n+\n+        // dimension overflow\n+        try {\n+            m.setSubMatrix(testData, 1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {\n+            m.setSubMatrix(testData, -1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {\n+            m.setSubMatrix(testData, 1, -1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+\n+        // null\n+        try {\n+            m.setSubMatrix(null, 1, 1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            new SparseFieldMatrix<Fraction>(field, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] { {} }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    // --------------- -----------------Protected methods\n+\n+    /** verifies that two matrices are close (1-norm) */\n+    protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n,\n+            double tolerance) {\n+        for(int i=0; i < m.getRowDimension(); i++){\n+            for(int j=0; j < m.getColumnDimension(); j++){\n+                assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);\n+            }\n+            \n+        }\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, Fraction[] m, Fraction[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" + i + \" elements differ\", m[i].doubleValue(), n[i].doubleValue(),\n+                    tolerance);\n+        }\n+    }\n+    \n+    private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) {\n+        SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length);\n+        for (int row = 0; row < data.length; row++) {\n+            for (int col = 0; col < data[row].length; col++) {\n+                matrix.setEntry(row, col, data[row][col]);\n+            }\n+        }\n+        return matrix;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link SparseFieldVector} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SparseFieldVectorTest extends TestCase {\n+\n+    // \n+    protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};\n+    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};\n+    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};\n+    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};\n+    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};\n+    protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    protected FractionField field = FractionField.getInstance();\n+\n+    public void testMapFunctions() throws FractionConversionException { \n+        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));\n+        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        assertEquals(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(new Fraction(2));\n+        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        assertEquals(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));\n+        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        assertEquals(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));\n+        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        assertEquals(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));\n+        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        assertEquals(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));\n+        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        assertEquals(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));\n+        Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};\n+        assertEquals(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));\n+        Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};\n+        assertEquals(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInv = v1.mapInv();\n+        Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};\n+        assertEquals(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};\n+        assertEquals(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n+\n+\n+    }\n+\n+    public void testBasicFunctions() throws FractionConversionException { \n+        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n+        SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);\n+\n+        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2); \n+\n+        //octave =  v1 + v2\n+        FieldVector<Fraction> v_add = v1.add(v2);\n+        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        assertEquals(\"compare vect\" ,v_add.getData(),result_add);\n+\n+        SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);\n+        FieldVector<Fraction> v_add_i = v1.add(vt2);\n+        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        assertEquals(\"compare vect\" ,v_add_i.getData(),result_add_i);\n+\n+        //octave =  v1 - v2\n+        SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);\n+        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);\n+        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        FieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);\n+        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        FieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);\n+        Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        Fraction dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(32), dot);\n+\n+        // octave  dot(v1,v2_t)\n+        Fraction dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+\n+        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+\n+        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+\n+    }\n+\n+\n+    public void testMisc() { \n+        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }     \n+\n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });\n+\n+        v.setEntry(0, field.getZero());\n+        assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));\n+        assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));\n+\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+        }\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i].doubleValue(),n[i].doubleValue(), tolerance);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link OpenMapRealMatrix} class.\n+ * \n+ * @version $Revision$ $Date: 2008-11-07 06:48:13 -0800 (Fri, 07 Nov\n+ *          2008) $\n+ */\n+public final class SparseRealMatrixTest extends TestCase {\n+\n+    // 3 x 3 identity matrix\n+    protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };\n+    // Test data for group operations\n+    protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d },\n+            { 1d, 0d, 8d } };\n+    protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d },\n+            { 0.5d, 0.2d, .2d } };\n+    protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d },\n+            { 3d, 2d, 10d } };\n+    protected double[][] testDataMinus = { { -1d, -2d, -3d },\n+            { -2d, -5d, -3d }, { -1d, 0d, -8d } };\n+    protected double[] testDataRow1 = { 1d, 2d, 3d };\n+    protected double[] testDataCol3 = { 3d, 3d, 8d };\n+    protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d },\n+            { 5d, -2d, -1d } };\n+    protected double[] preMultTest = { 8, 12, 33 };\n+    protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };\n+    protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } };\n+    protected double[][] testDataPlusInv = { { -39d, 18d, 12d },\n+            { 15d, 0d, 0d }, { 6d, -2d, 7d } };\n+\n+    // lu decomposition tests\n+    protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } };\n+    protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d },\n+            { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } };\n+\n+    // singular matrices\n+    protected double[][] singular = { { 2d, 3d }, { 2d, 3d } };\n+    protected double[][] bigSingular = { { 1d, 2d, 3d, 4d },\n+            { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th\n+\n+    // row\n+    // =\n+    // 1st\n+    // +\n+    // 2nd\n+    protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d },\n+            { 7d, 8d, 10d } };\n+    protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } };\n+\n+    // vectors\n+    protected double[] testVector = { 1, 2, 3 };\n+    protected double[] testVector2 = { 1, 2, 3, 4 };\n+\n+    // submatrix accessor tests\n+    protected double[][] subTestData = { { 1, 2, 3, 4 },\n+            { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } };\n+\n+    // array selections\n+    protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } };\n+    protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } };\n+    protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } };\n+\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } };\n+    protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } };\n+\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } };\n+    protected double[][] subRows23Cols00 = { { 2 }, { 4 } };\n+    protected double[][] subRows00Cols33 = { { 4 } };\n+\n+    // row matrices\n+    protected double[][] subRow0 = { { 1, 2, 3, 4 } };\n+    protected double[][] subRow3 = { { 4, 5, 6, 7 } };\n+\n+    // column matrices\n+    protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } };\n+    protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } };\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    public SparseRealMatrixTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SparseRealMatrixTest.class);\n+        suite.setName(\"SparseRealMatrix Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n+        assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n+        assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n+        assertTrue(\"testData is square\", m.isSquare());\n+        assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n+        assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n+        assertTrue(\"testData2 is not square\", !m2.isSquare());\n+    }\n+\n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        OpenMapRealMatrix m1 = createSparseMatrix(testData);\n+        RealMatrix m2 = m1.copy();\n+        assertEquals(m1.getClass(), m2.getClass());\n+        assertEquals((m2), m1);\n+        OpenMapRealMatrix m3 = createSparseMatrix(testData);\n+        RealMatrix m4 = m3.copy();\n+        assertEquals(m3.getClass(), m4.getClass());\n+        assertEquals((m4), m3);\n+    }\n+\n+    /** test add */\n+    public void testAdd() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);\n+        OpenMapRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\", \n+                    mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col), \n+                    entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test add failure */\n+    public void testAddFail() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test norm */\n+    public void testNorm() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n+        assertEquals(\"testData norm\", 14d, m.getNorm(), entryTolerance);\n+        assertEquals(\"testData2 norm\", 7d, m2.getNorm(), entryTolerance);\n+    }\n+\n+    /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix n = createSparseMatrix(testDataInv);\n+        assertClose(\"m-n = m + -n\", m.subtract(n),\n+            n.scalarMultiply(-1d).add(m), entryTolerance);\n+        try {\n+            m.subtract(createSparseMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test multiply */\n+    public void testMultiply() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);\n+        OpenMapRealMatrix identity = createSparseMatrix(id);\n+        OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n+        assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", m.multiply(new BlockRealMatrix(testDataInv)), identity,\n+                    entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.multiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.multiply(mInv), mInv,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m2.multiply(identity), m2,\n+                entryTolerance);\n+        try {\n+            m.multiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    // Additional Test for Array2DRowRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n+    private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };\n+    private double[][] d5 = new double[][] { { 30 }, { 70 } };\n+\n+    public void testMultiply2() {\n+        RealMatrix m3 = createSparseMatrix(d3);\n+        RealMatrix m4 = createSparseMatrix(d4);\n+        RealMatrix m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+    }\n+\n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = createSparseMatrix(id);\n+        assertEquals(\"identity trace\", 3d, m.getTrace(), entryTolerance);\n+        m = createSparseMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2), \n+            m.scalarAdd(2d), entryTolerance);\n+    }\n+\n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = createSparseMatrix(id);\n+        assertClose(\"identity operate\", testVector, m.operate(testVector),\n+                entryTolerance);\n+        assertClose(\"identity operate\", testVector, m.operate(\n+                new ArrayRealVector(testVector)).getData(), entryTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = createSparseMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 } });\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals(3.0, b[0], 1.0e-12);\n+        assertEquals(7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+\n+    /** test transpose */\n+    public void testTranspose() {\n+        \n+        RealMatrix m = createSparseMatrix(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = createSparseMatrix(testData2);\n+        RealMatrix mt = createSparseMatrix(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+\n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n+            normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(\n+            new ArrayRealVector(testVector).getData()), preMultTest, normTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testPremultiply() {\n+        RealMatrix m3 = createSparseMatrix(d3);\n+        RealMatrix m4 = createSparseMatrix(d4);\n+        RealMatrix m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);\n+        OpenMapRealMatrix identity = createSparseMatrix(id);\n+        assertClose(\"inverse multiply\", m.preMultiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.preMultiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.preMultiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.preMultiply(mInv), mInv,\n+                entryTolerance);\n+        try {\n+            m.preMultiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testGetVectors() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertClose(\"get row\", m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testGetEntry() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertEquals(\"get entry\", m.getEntry(0, 1), 2d, entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };\n+        RealMatrix m = createSparseMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } };\n+        RealMatrix n = createSparseMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+\n+        // Solve example\n+        double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },\n+                { 4, -3, -5 } };\n+        RealMatrix coefficients = createSparseMatrix(coefficientsData);\n+        double[] constants = { 1, -2, 1 };\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],\n+                constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],\n+                constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],\n+                constants[2], 1E-12);\n+\n+    }\n+\n+    // test submatrix accessors\n+    public void testSubMatrix() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);\n+        RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33);\n+        RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23);\n+        RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13);\n+        RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12);\n+        RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);\n+        RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);\n+        RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);\n+        assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n+        assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n+        assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n+        assertEquals(\"Rows02Cols13\", mRows02Cols13, \n+            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n+        assertEquals(\"Rows03Cols12\", mRows03Cols12, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n+        assertEquals(\"Rows03Cols123\", mRows03Cols123, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows20Cols123\", mRows20Cols123, \n+            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(-1, 1, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {}, new int[] { 0 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealMatrix mRow0 = createSparseMatrix(subRow0);\n+        RealMatrix mRow3 = createSparseMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnMatrix() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealMatrix mColumn1 = createSparseMatrix(subColumn1);\n+        RealMatrix mColumn3 = createSparseMatrix(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnVector() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayRealVector(data, false);\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        OpenMapRealMatrix m1 = (OpenMapRealMatrix) m.copy();\n+        OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(createSparseMatrix(bigSingular)));\n+    }\n+\n+    public void testToString() {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        assertEquals(\"OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\", \n+            m.toString());\n+        m = new OpenMapRealMatrix(1, 1);\n+        assertEquals(\"OpenMapRealMatrix{{0.0}}\", m.toString());\n+    }\n+\n+    public void testSetSubMatrix() throws Exception {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        m.setSubMatrix(detData2, 1, 1);\n+        RealMatrix expected = createSparseMatrix(new double[][] {\n+                { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(detData2, 0, 0);\n+        expected = createSparseMatrix(new double[][] {\n+                { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2, 0, 0);\n+        expected = createSparseMatrix(new double[][] {\n+                { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });\n+        assertEquals(expected, m);\n+\n+        // javadoc example\n+        OpenMapRealMatrix matrix = \n+            createSparseMatrix(new double[][] { \n+        { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });\n+        matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);\n+        expected = createSparseMatrix(new double[][] {\n+                { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });\n+        assertEquals(expected, matrix);\n+\n+        // dimension overflow\n+        try {\n+            m.setSubMatrix(testData, 1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {\n+            m.setSubMatrix(testData, -1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {\n+            m.setSubMatrix(testData, 1, -1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+\n+        // null\n+        try {\n+            m.setSubMatrix(null, 1, 1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            new OpenMapRealMatrix(0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] { {} }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        OpenMapRealMatrix m = createSparseMatrix(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+\n+    // --------------- -----------------Protected methods\n+\n+    /** verifies that two matrices are close (1-norm) */\n+    protected void assertClose(String msg, RealMatrix m, RealMatrix n,\n+            double tolerance) {\n+        assertTrue(msg, m.subtract(n).getNorm() < tolerance);\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" + i + \" elements differ\", m[i], n[i],\n+                    tolerance);\n+        }\n+    }\n+    \n+    private OpenMapRealMatrix createSparseMatrix(double[][] data) {\n+        OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length);\n+        for (int row = 0; row < data.length; row++) {\n+            for (int col = 0; col < data[row].length; col++) {\n+                matrix.setEntry(row, col, data[row][col]);\n+            }\n+        }\n+        return matrix;\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link OpenMapRealVector} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SparseRealVectorTest extends TestCase {\n+\n+    // \n+    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n+    protected double[] vec1 = {1d, 2d, 3d};\n+    protected double[] vec2 = {4d, 5d, 6d};\n+    protected double[] vec3 = {7d, 8d, 9d};\n+    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[] vec_null = {0d, 0d, 0d};\n+    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    // Testclass to test the RealVector interface \n+    // only with enough content to support the test\n+    public static class SparseRealVectorTestImpl implements RealVector, Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4715341047369582908L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public SparseRealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector copy() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAdd(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtract(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapMultiply(double d) {\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * d;\n+            }\n+            return new OpenMapRealVector(out);\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivide(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPow(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLogToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1p() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1pToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCoshToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbs() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbsToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeil() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeilToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloor() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloorToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRint() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRintToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignum() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignumToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double[] getData() {\n+            return data.clone();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+\n+        public double dotProduct(double[] v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v[i];\n+            }\n+            return dot;\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector unitVector() {\n+            throw unsupported();\n+        }\n+\n+        public void unitize() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(double value) {\n+            throw unsupported();\n+        }\n+\n+        public double[] toArray() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SparseRealVectorTest.class);\n+        suite.setName(\"SparseRealVector Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        OpenMapRealVector v0 = new OpenMapRealVector();\n+        assertEquals(\"testData len\", 0, v0.getDimension());\n+\n+        OpenMapRealVector v1 = new OpenMapRealVector(7);\n+        assertEquals(\"testData len\", 7, v1.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+\n+        OpenMapRealVector v3 = new OpenMapRealVector(vec1);\n+        assertEquals(\"testData len\", 3, v3.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+\n+        //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);\n+        //assertEquals(\"testData len\", 2, v4.getDimension());\n+        //assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        //try {\n+        //    new SparseRealVector(vec4, 8, 3);\n+        //    fail(\"IllegalArgumentException expected\");\n+        //} catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        //} catch (Exception e) {\n+        //    fail(\"wrong exception caught\");\n+        //}\n+\n+        RealVector v5_i = new OpenMapRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+\n+        OpenMapRealVector v5 = new OpenMapRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+\n+        OpenMapRealVector v7 = new OpenMapRealVector(v1);\n+        assertEquals(\"testData len\", 7, v7.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+\n+        SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);\n+\n+        OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);\n+        assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+\n+        OpenMapRealVector v8 = new OpenMapRealVector(v1);\n+        assertEquals(\"testData len\", 7, v8.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n+        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n+        OpenMapRealVector v4 = new OpenMapRealVector(vec4);\n+        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2); \n+\n+        RealVector v_append_1 = v1.append(v2);\n+        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+\n+        RealVector v_append_2 = v1.append(2.0);\n+        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+\n+        RealVector v_append_3 = v1.append(vec2);\n+        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+\n+\t    RealVector v_append_4 = v1.append(v2_t);\n+        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+        \n+        RealVector vout5 = v4.getSubVector(3, 3);\n+        assertEquals(\"testData len\", 3, vout5.getDimension());\n+        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        try {\n+            v4.getSubVector(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        OpenMapRealVector v_set1 = (OpenMapRealVector) v1.copy();\n+        v_set1.setEntry(1, 11.0);\n+        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        try {\n+            v_set1.setEntry(3, 11.0);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        OpenMapRealVector v_set2 = (OpenMapRealVector) v4.copy();\n+        v_set2.setSubVector(3, v1);\n+        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        try {\n+            v_set2.setSubVector(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        OpenMapRealVector v_set3 = (OpenMapRealVector) v1.copy();\n+        v_set3.set(13.0);\n+        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        OpenMapRealVector v_set4 = (OpenMapRealVector) v4.copy();\n+        v_set4.setSubVector(3, v2_t);\n+        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        try {\n+            v_set4.setSubVector(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAdd = v1.mapAdd(2.0d);\n+        double[] result_mapAdd = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData(),normTolerance);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(2.0d);\n+        double[] result_mapAddToSelf = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtract = v1.mapSubtract(2.0d);\n+        double[] result_mapSubtract = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);\n+        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiply = v1.mapMultiply(2.0d);\n+        double[] result_mapMultiply = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);\n+        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivide = v1.mapDivide(2.0d);\n+        double[] result_mapDivide = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(2.0d);\n+        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPow = v1.mapPow(2.0d);\n+        double[] result_mapPow = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPow,v_mapPow.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPowToSelf = v1.copy();\n+        v_mapPowToSelf.mapPowToSelf(2.0d);\n+        double[] result_mapPowToSelf = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExp = v1.mapExp();\n+        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExpToSelf = v1.copy();\n+        v_mapExpToSelf.mapExpToSelf();\n+        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n+\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1 = v1.mapExpm1();\n+        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1ToSelf = v1.copy();\n+        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog = v1.mapLog();\n+        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLogToSelf = v1.copy();\n+        v_mapLogToSelf.mapLogToSelf();\n+        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n+\n+        //octave =  log10(v1)\n+        RealVector v_mapLog10 = v1.mapLog10();\n+        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog10ToSelf = v1.copy();\n+        v_mapLog10ToSelf.mapLog10ToSelf();\n+        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1p = v1.mapLog1p();\n+        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1pToSelf = v1.copy();\n+        v_mapLog1pToSelf.mapLog1pToSelf();\n+        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCosh = v1.mapCosh();\n+        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCoshToSelf = v1.copy();\n+        v_mapCoshToSelf.mapCoshToSelf();\n+        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinh = v1.mapSinh();\n+        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinhToSelf = v1.copy();\n+        v_mapSinhToSelf.mapSinhToSelf();\n+        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanh = v1.mapTanh();\n+        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanhToSelf = v1.copy();\n+        v_mapTanhToSelf.mapTanhToSelf();\n+        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCos = v1.mapCos();\n+        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCosToSelf = v1.copy();\n+        v_mapCosToSelf.mapCosToSelf();\n+        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSin = v1.mapSin();\n+        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSinToSelf = v1.copy();\n+        v_mapSinToSelf.mapSinToSelf();\n+        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTan = v1.mapTan();\n+        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTanToSelf = v1.copy();\n+        v_mapTanToSelf.mapTanToSelf();\n+        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n+\n+        double[] vat_a = {0d, 0.5d, 1.0d};\n+        OpenMapRealVector vat = new OpenMapRealVector(vat_a);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcos = vat.mapAcos();\n+        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcosToSelf = vat.copy();\n+        v_mapAcosToSelf.mapAcosToSelf();\n+        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsin = vat.mapAsin();\n+        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsinToSelf = vat.copy();\n+        v_mapAsinToSelf.mapAsinToSelf();        \n+        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtan = vat.mapAtan();\n+        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtanToSelf = vat.copy();\n+        v_mapAtanToSelf.mapAtanToSelf();\n+        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInv = v1.mapInv();\n+        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n+\n+        double[] abs_a = {-1.0d, 0.0d, 1.0d};\n+        OpenMapRealVector abs_v = new OpenMapRealVector(abs_a);\n+\n+        //octave =  abs(abs_v)\n+        RealVector v_mapAbs = abs_v.mapAbs();\n+        double[] result_mapAbs = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n+\n+        //octave = abs(abs_v)\n+        RealVector v_mapAbsToSelf = abs_v.copy();\n+        v_mapAbsToSelf.mapAbsToSelf();\n+        double[] result_mapAbsToSelf = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n+\n+        //octave =   sqrt(v1)\n+        RealVector v_mapSqrt = v1.mapSqrt();\n+        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n+\n+        //octave =  sqrt(v1)\n+        RealVector v_mapSqrtToSelf = v1.copy();\n+        v_mapSqrtToSelf.mapSqrtToSelf();\n+        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n+\n+        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};\n+        OpenMapRealVector cbrt_v = new OpenMapRealVector(cbrt_a);\n+\n+        //octave =  ???\n+        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapCbrtToSelf = cbrt_v.copy();\n+        v_mapCbrtToSelf.mapCbrtToSelf();\n+        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n+\n+        double[] ceil_a = {-1.1d, 0.9d, 1.1d};\n+        OpenMapRealVector ceil_v = new OpenMapRealVector(ceil_a);\n+\n+        //octave =  ceil(ceil_v)\n+        RealVector v_mapCeil = ceil_v.mapCeil();\n+        double[] result_mapCeil = {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n+\n+        //octave = ceil(ceil_v)\n+        RealVector v_mapCeilToSelf = ceil_v.copy();\n+        v_mapCeilToSelf.mapCeilToSelf();\n+        double[] result_mapCeilToSelf =  {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n+\n+        //octave =  floor(ceil_v)\n+        RealVector v_mapFloor = ceil_v.mapFloor();\n+        double[] result_mapFloor = {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n+\n+        //octave = floor(ceil_v)\n+        RealVector v_mapFloorToSelf = ceil_v.copy();\n+        v_mapFloorToSelf.mapFloorToSelf();\n+        double[] result_mapFloorToSelf =  {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapRint = ceil_v.mapRint();\n+        double[] result_mapRint = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapRintToSelf = ceil_v.copy();\n+        v_mapRintToSelf.mapRintToSelf();\n+        double[] result_mapRintToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapSignum = ceil_v.mapSignum();\n+        double[] result_mapSignum = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapSignumToSelf = ceil_v.copy();\n+        v_mapSignumToSelf.mapSignumToSelf();\n+        double[] result_mapSignumToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n+\n+\n+        // Is with the used resolutions of limited value as test\n+        //octave =  ???\n+        RealVector v_mapUlp = ceil_v.mapUlp();\n+        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapUlpToSelf = ceil_v.copy();\n+        v_mapUlpToSelf.mapUlpToSelf();\n+        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n+        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n+        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n+\n+        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2); \n+\n+        //octave =  sqrt(sumsq(v1))\n+        double d_getNorm = v1.getNorm();\n+        assertEquals(\"compare values  \", 3.7416573867739413,d_getNorm);\n+\n+        double d_getL1Norm = v1.getL1Norm();\n+        assertEquals(\"compare values  \",6.0, d_getL1Norm);\n+\n+        double d_getLInfNorm = v1.getLInfNorm();\n+        assertEquals(\"compare values  \",6.0, d_getLInfNorm);\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist = v1.getDistance(v2);\n+        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist_2 = v1.getDistance(v2_t);\n+        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+\n+        //octave =  ???\n+        double d_getL1Distance = v1. getL1Distance(v2);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+\n+        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+\n+        //octave =  ???\n+        double d_getLInfDistance = v1. getLInfDistance(v2);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+\n+        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+\n+        //octave =  v1 + v2\n+        OpenMapRealVector v_add = v1.add(v2);\n+        double[] result_add = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+\n+        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n+        RealVector v_add_i = v1.add(vt2);\n+        double[] result_add_i = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n+\n+        //octave =  v1 - v2\n+        OpenMapRealVector v_subtract = v1.subtract(v2);\n+        double[] result_subtract = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        RealVector v_subtract_i = v1.subtract(vt2);\n+        double[] result_subtract_i = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n+        double[] result_ebeMultiply = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n+        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        double dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",32d, dot);\n+\n+        // octave  dot(v1,v2_t)\n+        double dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",32d, dot_2);\n+\n+        RealMatrix m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+\n+        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+\n+        RealVector v_unitVector = v1.unitVector();\n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n+\n+        try {\n+            v_null.unitVector();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        OpenMapRealVector v_unitize = (OpenMapRealVector)v1.copy();\n+        v_unitize.unitize();\n+        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n+        try {\n+            v_null.unitize();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVector v_projection = v1.projection(v2);\n+        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n+\n+        RealVector v_projection_2 = v1.projection(v2_t);\n+        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n+\n+    }  \n+\n+    public void testMisc() { \n+        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }     \n+\n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });\n+\n+        assertFalse(v.isNaN());\n+        v.setEntry(1, Double.NaN);\n+        assertTrue(v.isNaN());\n+\n+        assertFalse(v.isInfinite());\n+        v.setEntry(0, Double.POSITIVE_INFINITY);\n+        assertFalse(v.isInfinite()); // NaN has higher priority than infinity\n+        v.setEntry(1, 1);\n+        assertTrue(v.isInfinite());\n+\n+        v.setEntry(0, 0);\n+        assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));\n+        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));\n+\n+    }\n+\n+    public void testSerial()  {\n+        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });\n+        assertEquals(v,TestUtils.serializeAndRecover(v));\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.TriDiagonalTransformer;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class TriDiagonalTransformerTest extends TestCase {\n+\n+    private double[][] testSquare5 = {\n+            { 1, 2, 3, 1, 1 },\n+            { 2, 1, 1, 3, 1 },\n+            { 3, 1, 1, 1, 2 },\n+            { 1, 3, 1, 2, 1 },\n+            { 1, 1, 2, 1, 3 }\n+    };\n+\n+    private double[][] testSquare3 = {\n+            { 1, 3, 4 },\n+            { 3, 2, 2 },\n+            { 4, 2, 0 }\n+    };\n+\n+    public TriDiagonalTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testNonSquare() {\n+        try {\n+            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testAEqualQTQt() {\n+        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));\n+        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));\n+    }\n+\n+    private void checkAEqualQTQt(RealMatrix matrix) {\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        RealMatrix q  = transformer.getQ();\n+        RealMatrix qT = transformer.getQT();\n+        RealMatrix t  = transformer.getT();\n+        double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 4.0e-15);\n+    }\n+\n+    public void testNoAccessBelowDiagonal() {\n+        checkNoAccessBelowDiagonal(testSquare5);\n+        checkNoAccessBelowDiagonal(testSquare3);\n+    }\n+\n+    private void checkNoAccessBelowDiagonal(double[][] data) {\n+        double[][] modifiedData = new double[data.length][];\n+        for (int i = 0; i < data.length; ++i) {\n+            modifiedData[i] = data[i].clone();\n+            Arrays.fill(modifiedData[i], 0, i, Double.NaN);\n+        }\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData);\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        RealMatrix q  = transformer.getQ();\n+        RealMatrix qT = transformer.getQT();\n+        RealMatrix t  = transformer.getT();\n+        double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();\n+        assertEquals(0, norm, 4.0e-15);\n+    }\n+\n+    public void testQOrthogonal() {\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());\n+    }\n+\n+    public void testQTOrthogonal() {\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);        \n+    }\n+\n+    public void testTTriDiagonal() {\n+        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());\n+        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());\n+    }\n+\n+    private void checkTriDiagonal(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if ((i < j - 1) || (i > j + 1)) {\n+                    assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                }                    \n+            }\n+        }\n+    }\n+\n+    public void testMatricesValues5() {\n+        checkMatricesValues(testSquare5,\n+                            new double[][] {\n+                                { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },\n+                                { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },\n+                                { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },\n+                                { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },\n+                                { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }\n+                            },\n+                            new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },\n+                            new double[] { -Math.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });\n+    }\n+\n+    public void testMatricesValues3() {\n+        checkMatricesValues(testSquare3,\n+                            new double[][] {\n+                                {  1.0,  0.0,  0.0 },\n+                                {  0.0, -0.6,  0.8 },\n+                                {  0.0, -0.8, -0.6 },\n+                            },\n+                            new double[] { 1, 2.64, -0.64 },\n+                            new double[] { -5, -1.52 });\n+    }\n+\n+    private void checkMatricesValues(double[][] matrix, double[][] qRef,\n+                                     double[] mainDiagnonal,\n+                                     double[] secondaryDiagonal) {\n+        TriDiagonalTransformer transformer =\n+            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix));\n+\n+        // check values against known references\n+        RealMatrix q = transformer.getQ();\n+        assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);\n+\n+        RealMatrix t = transformer.getT();\n+        double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];\n+        for (int i = 0; i < mainDiagnonal.length; ++i) {\n+            tData[i][i] = mainDiagnonal[i];\n+            if (i > 0) {\n+                tData[i][i - 1] = secondaryDiagonal[i - 1];\n+            }\n+            if (i < secondaryDiagonal.length) {\n+                tData[i][i + 1] = secondaryDiagonal[i];\n+            }\n+        }\n+        assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(q == transformer.getQ());\n+        assertTrue(t == transformer.getT());\n+        \n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TriDiagonalTransformerTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ContinuousOutputModelTest\n+  extends TestCase {\n+\n+  public ContinuousOutputModelTest(String name) {\n+    super(name);\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();\n+    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());\n+    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());\n+    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));\n+  }\n+\n+  public void testRandomAccess()\n+    throws DerivativeException, IntegratorException {\n+\n+    ContinuousOutputModel cm = new ContinuousOutputModel();\n+    integ.addStepHandler(cm);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-9);\n+\n+  }\n+\n+  public void testModelsMerging()\n+    throws DerivativeException, IntegratorException {\n+\n+      // theoretical solution: y[0] = cos(t), y[1] = sin(t)\n+      FirstOrderDifferentialEquations problem =\n+          new FirstOrderDifferentialEquations() {\n+              private static final long serialVersionUID = 2472449657345878299L;\n+              public void computeDerivatives(double t, double[] y, double[] dot)\n+                  throws DerivativeException {\n+                  dot[0] = -y[1];\n+                  dot[1] =  y[0];\n+              }\n+              public int getDimension() {\n+                  return 2;\n+              }\n+          };\n+\n+      // integrate backward from &pi; to 0;\n+      ContinuousOutputModel cm1 = new ContinuousOutputModel();\n+      FirstOrderIntegrator integ1 =\n+          new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);\n+      integ1.addStepHandler(cm1);\n+      integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 },\n+                       0, new double[2]);\n+\n+      // integrate backward from 2&pi; to &pi;\n+      ContinuousOutputModel cm2 = new ContinuousOutputModel();\n+      FirstOrderIntegrator integ2 =\n+          new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);\n+      integ2.addStepHandler(cm2);\n+      integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 },\n+                       Math.PI, new double[2]);\n+\n+      // merge the two half circles\n+      ContinuousOutputModel cm = new ContinuousOutputModel();\n+      cm.append(cm2);\n+      cm.append(new ContinuousOutputModel());\n+      cm.append(cm1);\n+\n+      // check circle\n+      assertEquals(2.0 * Math.PI, cm.getInitialTime(), 1.0e-12);\n+      assertEquals(0, cm.getFinalTime(), 1.0e-12);\n+      assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);\n+      for (double t = 0; t < 2.0 * Math.PI; t += 0.1) {\n+          cm.setInterpolatedTime(t);\n+          double[] y = cm.getInterpolatedState();\n+          assertEquals(Math.cos(t), y[0], 1.0e-7);\n+          assertEquals(Math.sin(t), y[1], 1.0e-7);\n+      }\n+      \n+  }\n+\n+  public void testErrorConditions()\n+    throws DerivativeException {\n+\n+      ContinuousOutputModel cm = new ContinuousOutputModel();\n+      cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);\n+      \n+      // dimension mismatch\n+      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));\n+\n+      // hole between time ranges\n+      assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));\n+\n+      // propagation direction mismatch\n+      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));\n+\n+      // no errors\n+      assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));\n+\n+  }\n+\n+  private boolean checkAppendError(ContinuousOutputModel cm,\n+                                   double t0, double[] y0, double t1)\n+  throws DerivativeException {\n+      try {\n+          ContinuousOutputModel otherCm = new ContinuousOutputModel();\n+          otherCm.handleStep(buildInterpolator(t0, y0, t1), true);\n+          cm.append(otherCm);\n+      } catch(IllegalArgumentException iae) {\n+          //expected behavior\n+          return true;\n+      }\n+      return false;\n+  }\n+\n+  private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) {\n+      DummyStepInterpolator interpolator  = new DummyStepInterpolator(y0, t1 >= t0);\n+      interpolator.storeTime(t0);\n+      interpolator.shift();\n+      interpolator.storeTime(t1);\n+      return interpolator;\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ContinuousOutputModelTest.class);\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);\n+  }\n+\n+  @Override\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderConverter;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n+\n+import junit.framework.*;\n+\n+public class FirstOrderConverterTest\n+  extends TestCase {\n+\n+  public FirstOrderConverterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDoubleDimension() {\n+    for (int i = 1; i < 10; ++i) {\n+      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);\n+      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);\n+      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+      \n+    double previousError = Double.NaN;\n+    for (int i = 0; i < 10; ++i) {\n+\n+      double step  = Math.pow(2.0, -(i + 1));\n+      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)\n+                   - Math.sin(4.0);\n+      if (i > 0) {\n+        assertTrue(Math.abs(error) < Math.abs(previousError));\n+      }\n+      previousError = error;\n+      \n+    }\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n+                   - Math.sin(4.0);\n+    assertTrue(Math.abs(error) < 1.0e-10);\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n+                   - Math.sin(4.0);\n+    assertTrue(Math.abs(error) > 0.1);\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(FirstOrderConverterTest.class);\n+  }\n+\n+  private static class Equations\n+    implements SecondOrderDifferentialEquations {\n+      \n+     private int n;\n+\n+      private double omega2;\n+      \n+      public Equations(int n, double omega) {\n+        this.n = n;\n+        omega2 = omega * omega;\n+      }\n+      \n+      public int getDimension() {\n+        return n;\n+      }\n+      \n+      public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                           double[] yDDot) {\n+        for (int i = 0; i < n; ++i) {\n+          yDDot[i] = -omega2 * y[i];\n+        }\n+    }\n+      \n+  }\n+\n+  private double integrateWithSpecifiedStep(double omega,\n+                                            double t0, double t,\n+                                            double step)\n+  throws DerivativeException, IntegratorException {\n+    double[] y0 = new double[2];\n+    y0[0] = Math.sin(omega * t0);\n+    y0[1] = omega * Math.cos(omega * t0);\n+    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);\n+    double[] y = new double[2];\n+    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);\n+    return y[0];\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = -y\n+ * </pre>\n+ * the solution of this equation is a simple exponential function :\n+ * <pre>\n+ *   y (t) = y (t0) exp (t0-t)\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem1\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1977870815289373164L;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem1() {\n+    super();\n+    double[] y0 = { 1.0, 0.1 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(4.0);\n+    double[] errorScale = { 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem1(TestProblem1 problem) {\n+    super(problem);\n+    y = problem.y.clone();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public TestProblem1 copy() {\n+    return new TestProblem1(this);\n+  }\n+\n+  @Override\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = -y[i];\n+\n+  }\n+\n+  @Override\n+  public double[] computeTheoreticalState(double t) {\n+    double c = Math.exp (t0 - t);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c * y0[i];\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = t^3 - t y\n+ * </pre>\n+ * with the initial condition y (0) = 0. The solution of this equation\n+ * is the following function :\n+ * <pre>\n+ *   y (t) = t^2 + 2 (exp (- t^2 / 2) - 1)\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem2\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 8330741783213512366L;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem2() {\n+    super();\n+    double[] y0 = { 0.0 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(1.0);\n+    double[] errorScale = { 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem2(TestProblem2 problem) {\n+    super(problem);\n+    y = problem.y.clone();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public TestProblem2 copy() {\n+    return new TestProblem2(this);\n+  }\n+\n+  @Override\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = t * (t * t - y[i]);\n+\n+  }\n+\n+  @Override\n+  public double[] computeTheoreticalState(double t) {\n+    double t2 = t * t;\n+    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c;\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0\n+ *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))\n+ *    r = sqrt (y1^2 + y2^2), e = 0.9\n+ * </pre>\n+ * This is a two-body problem in the plane which can be solved by\n+ * Kepler's equation\n+ * <pre>\n+ *   y1 (t) = ...\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem3\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 8567328542728919999L;\n+\n+  /** Eccentricity */\n+  double e;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   * @param e eccentricity\n+   */\n+  public TestProblem3(double e) {\n+    super();\n+    this.e = e;\n+    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(20.0);\n+    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem3() {\n+    this(0.1);\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem3(TestProblem3 problem) {\n+    super(problem);\n+    e = problem.e;\n+    y = problem.y.clone();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public TestProblem3 copy() {\n+    return new TestProblem3(this);\n+  }\n+\n+  @Override\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // current radius\n+    double r2 = y[0] * y[0] + y[1] * y[1];\n+    double invR3 = 1 / (r2 * Math.sqrt(r2));\n+\n+    // compute the derivatives\n+    yDot[0] = y[2];\n+    yDot[1] = y[3];\n+    yDot[2] = -invR3  * y[0];\n+    yDot[3] = -invR3  * y[1];\n+\n+  }\n+\n+  @Override\n+  public double[] computeTheoreticalState(double t) {\n+\n+    // solve Kepler's equation\n+    double E = t;\n+    double d = 0;\n+    double corr = 999.0;\n+    for (int i = 0; (i < 50) && (Math.abs(corr) > 1.0e-12); ++i) {\n+      double f2  = e * Math.sin(E);\n+      double f0  = d - f2;\n+      double f1  = 1 - e * Math.cos(E);\n+      double f12 = f1 + f1;\n+      corr  = f0 * f12 / (f1 * f12 - f0 * f2);\n+      d -= corr;\n+      E = t + d;\n+    };\n+\n+    double cosE = Math.cos(E);\n+    double sinE = Math.sin(E);\n+\n+    y[0] = cosE - e;\n+    y[1] = Math.sqrt(1 - e * e) * sinE;\n+    y[2] = -sinE / (1 - e * cosE);\n+    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n+\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    x'' = -x\n+ * </pre>\n+ * And when x decreases down to 0, the state should be changed as follows :\n+ * <pre>\n+ *   x' -> -x'\n+ * </pre>\n+ * The theoretical solution of this problem is x = |sin(t+a)|\n+ * </p>\n+\n+ */\n+public class TestProblem4\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -5910438521889015745L;\n+\n+  /** Time offset. */\n+  private double a;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /** Simple constructor. */\n+  public TestProblem4() {\n+    super();\n+    a = 1.2;\n+    double[] y0 = { Math.sin(a), Math.cos(a) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(15);\n+    double[] errorScale = { 1.0, 0.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem4(TestProblem4 problem) {\n+    super(problem);\n+    a = problem.a;\n+    y = problem.y.clone();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public TestProblem4 copy() {\n+    return new TestProblem4(this);\n+  }\n+\n+  @Override\n+  public EventHandler[] getEventsHandlers() {\n+    return new EventHandler[] { new Bounce(), new Stop() };\n+  }\n+\n+  @Override\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] =  y[1];\n+    yDot[1] = -y[0];\n+  }\n+\n+  @Override\n+  public double[] computeTheoreticalState(double t) {\n+    double sin = Math.sin(t + a);\n+    double cos = Math.cos(t + a);\n+    y[0] = Math.abs(sin);\n+    y[1] = (sin >= 0) ? cos : -cos;\n+    return y;\n+  }\n+\n+  private static class Bounce implements EventHandler {\n+\n+    private static final long serialVersionUID = 1356097180027801200L;\n+    private int sign;\n+\n+    public Bounce() {\n+      sign = +1;\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return sign * y[0];\n+    }\n+\n+    public int eventOccurred(double t, double[] y, boolean increasing) {\n+      // this sign change is needed because the state will be reset soon\n+      sign = -sign;\n+      return EventHandler.RESET_STATE;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+      y[0] = -y[0];\n+      y[1] = -y[1];\n+    }\n+\n+  }\n+\n+  private static class Stop implements EventHandler {\n+\n+    private static final long serialVersionUID = 6975050568227951931L;\n+\n+    public Stop() {\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return t - 12.0;\n+    }\n+\n+    public int eventOccurred(double t, double[] y, boolean increasing) {\n+      return EventHandler.STOP;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem5.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ * <p>This is the same as problem 1 except integration is done\n+ * backward in time</p>\n+ */\n+public class TestProblem5\n+  extends TestProblem1 {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 7579233102411804237L;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem5() {\n+    super();\n+    setFinalConditions(2 * t0 - t1);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public TestProblem5 copy() {\n+    return new TestProblem5();\n+  }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem6.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = 3x^5 - y\n+ * </pre>\n+ * when the initial condition is y(0) = -360, the solution of this\n+ * equation degenerates to a simple quintic polynomial function :\n+ * <pre>\n+ *   y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem6\n+  extends TestProblemAbstract {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1353409119804352378L;\n+\n+    /** theoretical state */\n+    private double[] y;\n+\n+    /**\n+     * Simple constructor.\n+     */\n+    public TestProblem6() {\n+        super();\n+        double[] y0 = { -360.0 };\n+        setInitialConditions(0.0, y0);\n+        setFinalConditions(1.0);\n+        double[] errorScale = { 1.0 };\n+        setErrorScale(errorScale);\n+        y = new double[y0.length];\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param problem problem to copy\n+     */\n+    public TestProblem6(TestProblem6 problem) {\n+        super(problem);\n+        y = problem.y.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public TestProblem6 copy() {\n+      return new TestProblem6(this);\n+    }\n+\n+    @Override\n+    public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+        // compute the derivatives\n+        double t2 = t  * t;\n+        double t4 = t2 * t2;\n+        double t5 = t4 * t;\n+        for (int i = 0; i < n; ++i) {\n+            yDot[i] = 3 * t5 - y[i];\n+        }\n+\n+    }\n+\n+    @Override\n+    public double[] computeTheoreticalState(double t) {\n+        for (int i = 0; i < n; ++i) {\n+            y[i] = ((((3 * t - 15) * t + 60) * t - 180) * t + 360) * t - 360;\n+        }\n+        return y;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemAbstract.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+/**\n+ * This class is used as the base class of the problems that are\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+public abstract class TestProblemAbstract\n+  implements FirstOrderDifferentialEquations {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -8521928974502839379L;\n+\n+  /** Dimension of the problem. */\n+  protected int n;\n+\n+  /** Number of functions calls. */\n+  protected int calls;\n+\n+  /** Initial time */\n+  protected double t0;\n+\n+  /** Initial state */\n+  protected double[] y0;\n+\n+  /** Final time */\n+  protected double t1;\n+\n+  /** Error scale */\n+  protected double[] errorScale;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  protected TestProblemAbstract() {\n+    n          = 0;\n+    calls      = 0;\n+    t0         = 0;\n+    y0         = null;\n+    t1         = 0;\n+    errorScale = null;\n+  }\n+\n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  protected TestProblemAbstract(TestProblemAbstract problem) {\n+    n     = problem.n;\n+    calls = problem.calls;\n+    t0    = problem.t0;\n+    if (problem.y0 == null) {\n+      y0 = null;\n+    } else {\n+      y0 = problem.y0.clone();\n+    }\n+    if (problem.errorScale == null) {\n+      errorScale = null;\n+    } else {\n+      errorScale = problem.errorScale.clone();\n+    }\n+    t1 = problem.t1;\n+  }\n+\n+  /**\n+   * Copy operation.\n+   * @return a copy of the instance\n+   */\n+  public abstract TestProblemAbstract copy();\n+\n+  /**\n+   * Set the initial conditions\n+   * @param t0 initial time\n+   * @param y0 initial state vector\n+   */\n+  protected void setInitialConditions(double t0, double[] y0) {\n+    calls     = 0;\n+    n         = y0.length;\n+    this.t0   = t0;\n+    this.y0   = y0.clone(); \n+   }\n+\n+  /**\n+   * Set the final conditions.\n+   * @param t1 final time\n+   */\n+  protected void setFinalConditions(double t1) {\n+    this.t1 = t1;\n+  }\n+\n+  /**\n+   * Set the error scale\n+   * @param errorScale error scale\n+   */\n+  protected void setErrorScale(double[] errorScale) {\n+    this.errorScale = errorScale.clone(); \n+  }\n+\n+  public int getDimension() {\n+    return n;\n+  }\n+\n+  /**\n+   * Get the initial time.\n+   * @return initial time\n+   */\n+  public double getInitialTime() {\n+    return t0;\n+  }\n+\n+  /**\n+   * Get the initial state vector.\n+   * @return initial state vector\n+   */\n+  public double[] getInitialState() {\n+    return y0;\n+  }\n+\n+  /**\n+   * Get the final time.\n+   * @return final time\n+   */\n+  public double getFinalTime() {\n+    return t1;\n+  }\n+\n+  /**\n+   * Get the error scale.\n+   * @return error scale\n+   */\n+  public double[] getErrorScale() {\n+    return errorScale;\n+  }\n+\n+  /**\n+   * Get the events handlers.\n+   * @return events handlers   */\n+  public EventHandler[] getEventsHandlers() {\n+    return new EventHandler[0];\n+  }\n+\n+  /**\n+   * Get the number of calls.\n+   * @return nuber of calls\n+   */\n+  public int getCalls() {\n+    return calls;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    ++calls;\n+    doComputeDerivatives(t, y, yDot);\n+  }\n+\n+  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);\n+\n+  /**\n+   * Compute the theoretical state at the specified time.\n+   * @param t time at which the state is required\n+   * @return state vector at time t\n+   */\n+  abstract public double[] computeTheoreticalState(double t);\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ */\n+public class TestProblemFactory {\n+\n+  /** Problems pool. */\n+  private static TestProblemAbstract[] pool = {\n+    new TestProblem1(),\n+    new TestProblem2(),\n+    new TestProblem3(),\n+    new TestProblem4(),\n+    new TestProblem5(),\n+    new TestProblem6()\n+  };\n+\n+  /**\n+   * Private constructor.\n+   * This is a utility class, so there are no instance at all.\n+   */\n+  private TestProblemFactory() {\n+  }\n+\n+  /**\n+   * Get the problems.\n+   * @return array of problems to solve\n+   */\n+  public static TestProblemAbstract[] getProblems() {\n+    return pool;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.ODEIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class is used to handle steps for the test problems\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+public class TestProblemHandler\n+  implements StepHandler {\n+\n+  /** Associated problem. */\n+  private TestProblemAbstract problem;\n+\n+  /** Maximal errors encountered during the integration. */\n+  private double maxValueError;\n+  private double maxTimeError;\n+\n+  /** Error at the end of the integration. */\n+  private double lastError;\n+\n+  /** Time at the end of integration. */\n+  private double lastTime;\n+\n+  /** ODE solver used. */\n+  private ODEIntegrator integrator;\n+\n+  /** Expected start for step. */\n+  private double expectedStepStart;\n+\n+  /**\n+   * Simple constructor.\n+   * @param problem problem for which steps should be handled\n+   * @param integrator ODE solver used\n+   */\n+  public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {\n+    this.problem = problem;\n+    this.integrator = integrator;\n+    reset();\n+  }\n+\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  public void reset() {\n+    maxValueError = 0;\n+    maxTimeError  = 0;\n+    lastError     = 0;\n+    expectedStepStart = Double.NaN;\n+  }\n+\n+  public void handleStep(StepInterpolator interpolator,\n+                         boolean isLast)\n+    throws DerivativeException {\n+\n+    double start = integrator.getCurrentStepStart();\n+    if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {\n+        // multistep integrators do not handle the first steps themselves\n+        // so we have to make sure the integrator we look at has really started its work\n+        if (!Double.isNaN(expectedStepStart)) {\n+            maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));\n+        }\n+        expectedStepStart = start + integrator.getCurrentSignedStepsize();\n+    }\n+\n+    double pT = interpolator.getPreviousTime();\n+    double cT = interpolator.getCurrentTime();\n+    double[] errorScale = problem.getErrorScale();\n+\n+    // store the error at the last step\n+    if (isLast) {\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(cT);\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        lastError = Math.max(error, lastError);\n+      }\n+      lastTime = cT;\n+    }\n+\n+    // walk through the step\n+    for (int k = 0; k <= 20; ++k) {\n+\n+      double time = pT + (k * (cT - pT)) / 20;\n+      interpolator.setInterpolatedTime(time);\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());\n+\n+      // update the errors\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        maxValueError = Math.max(error, maxValueError);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get the maximal value error encountered during integration.\n+   * @return maximal value error\n+   */\n+  public double getMaximalValueError() {\n+    return maxValueError;\n+  }\n+\n+  /**\n+   * Get the maximal time error encountered during integration.\n+   * @return maximal time error\n+   */\n+  public double getMaximalTimeError() {\n+    return maxTimeError;\n+  }\n+\n+  /**\n+   * Get the error at the end of the integration.\n+   * @return error at the end of the integration\n+   */\n+  public double getLastError() {\n+    return lastError;\n+  }\n+\n+  /**\n+   * Get the time at the end of the integration.\n+   * @return time at the end of the integration.\n+   */\n+  public double getLastTime() {\n+    return lastTime;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblem6;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.junit.Test;\n+\n+public class AdamsBashforthIntegratorTest {\n+\n+    @Test(expected=IntegratorException.class)\n+    public void dimensionCheck() throws DerivativeException, IntegratorException {\n+        TestProblem1 pb = new TestProblem1();\n+        FirstOrderIntegrator integ =\n+            new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        integ.integrate(pb,\n+                        0.0, new double[pb.getDimension()+10],\n+                        1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test(expected=IntegratorException.class)\n+    public void testMinStep() throws DerivativeException, IntegratorException {\n+\n+          TestProblem1 pb = new TestProblem1();\n+          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+          double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,\n+                                                                    vecAbsoluteTolerance,\n+                                                                    vecRelativeTolerance);\n+          TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+          integ.addStepHandler(handler);\n+          integ.integrate(pb,\n+                          pb.getInitialTime(), pb.getInitialState(),\n+                          pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    }\n+\n+    @Test\n+    public void testIncreasingTolerance()\n+        throws DerivativeException, IntegratorException {\n+\n+        int previousCalls = Integer.MAX_VALUE;\n+        for (int i = -12; i < -5; ++i) {\n+            TestProblem1 pb = new TestProblem1();\n+            double minStep = 0;\n+            double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+            double scalAbsoluteTolerance = Math.pow(10.0, i);\n+            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb,\n+                            pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+            // the 31 and 36 factors are only valid for this test\n+            // and has been obtained from trial and error\n+            // there is no general relation between local and global errors\n+            assertTrue(handler.getMaximalValueError() > (31.0 * scalAbsoluteTolerance));\n+            assertTrue(handler.getMaximalValueError() < (36.0 * scalAbsoluteTolerance));\n+            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+\n+            int calls = pb.getCalls();\n+            assertEquals(integ.getEvaluations(), calls);\n+            assertTrue(calls <= previousCalls);\n+            previousCalls = calls;\n+\n+        }\n+\n+    }\n+\n+    @Test(expected = DerivativeException.class)\n+    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double range = pb.getFinalTime() - pb.getInitialTime();\n+\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(2, 0, range, 1.0e-12, 1.0e-12);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.setMaxEvaluations(650);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    }\n+\n+    @Test\n+    public void backward() throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 1.0e-8);\n+        assertTrue(handler.getMaximalValueError() < 1.0e-8);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+    }\n+\n+    @Test\n+    public void polynomial() throws DerivativeException, IntegratorException {\n+        TestProblem6 pb = new TestProblem6();\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+\n+        for (int nSteps = 1; nSteps < 8; ++nSteps) {\n+            AdamsBashforthIntegrator integ =\n+                new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+            if (nSteps < 4) {\n+                assertTrue(integ.getEvaluations() > 160);\n+            } else {\n+                assertTrue(integ.getEvaluations() < 80);\n+            }\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblem6;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.junit.Test;\n+\n+public class AdamsMoultonIntegratorTest {\n+\n+    @Test(expected=IntegratorException.class)\n+    public void dimensionCheck() throws DerivativeException, IntegratorException {\n+        TestProblem1 pb = new TestProblem1();\n+        FirstOrderIntegrator integ =\n+            new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        integ.integrate(pb,\n+                        0.0, new double[pb.getDimension()+10],\n+                        1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test(expected=IntegratorException.class)\n+    public void testMinStep() throws DerivativeException, IntegratorException {\n+\n+          TestProblem1 pb = new TestProblem1();\n+          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+          double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,\n+                                                                  vecAbsoluteTolerance,\n+                                                                  vecRelativeTolerance);\n+          TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+          integ.addStepHandler(handler);\n+          integ.integrate(pb,\n+                          pb.getInitialTime(), pb.getInitialState(),\n+                          pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    }\n+\n+    @Test\n+    public void testIncreasingTolerance()\n+        throws DerivativeException, IntegratorException {\n+\n+        int previousCalls = Integer.MAX_VALUE;\n+        for (int i = -12; i < -2; ++i) {\n+            TestProblem1 pb = new TestProblem1();\n+            double minStep = 0;\n+            double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+            double scalAbsoluteTolerance = Math.pow(10.0, i);\n+            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb,\n+                            pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+            // the 0.15 and 3.0 factors are only valid for this test\n+            // and has been obtained from trial and error\n+            // there is no general relation between local and global errors\n+            assertTrue(handler.getMaximalValueError() > (0.15 * scalAbsoluteTolerance));\n+            assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));\n+            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+\n+            int calls = pb.getCalls();\n+            assertEquals(integ.getEvaluations(), calls);\n+            assertTrue(calls <= previousCalls);\n+            previousCalls = calls;\n+\n+        }\n+\n+    }\n+\n+    @Test(expected = DerivativeException.class)\n+    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double range = pb.getFinalTime() - pb.getInitialTime();\n+\n+        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.setMaxEvaluations(650);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    }\n+\n+    @Test\n+    public void backward() throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 1.0e-9);\n+        assertTrue(handler.getMaximalValueError() < 1.0e-9);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+    }\n+\n+    @Test\n+    public void polynomial() throws DerivativeException, IntegratorException {\n+        TestProblem6 pb = new TestProblem6();\n+        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+\n+        for (int nSteps = 1; nSteps < 7; ++nSteps) {\n+            AdamsMoultonIntegrator integ =\n+                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+            if (nSteps < 4) {\n+                assertTrue(integ.getEvaluations() > 150);\n+            } else {\n+                assertTrue(integ.getEvaluations() < 100);\n+            }\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemFactory;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ClassicalRungeKuttaIntegratorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSanityChecks() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()+10],\n+                                                        1.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+    try  {\n+        TestProblem1 pb = new TestProblem1();\n+        new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                          0.0, new double[pb.getDimension()],\n+                                                          1.0, new double[pb.getDimension()+10]);\n+          fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        fail(\"wrong exception caught\");\n+      } catch(IntegratorException ie) {\n+      }\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()],\n+                                                        0.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = problems[k].copy();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        assertEquals(functions.length, integ.getEventHandlers().size());\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        integ.clearEventHandlers();\n+        assertEquals(0, integ.getEventHandlers().size());\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem5 pb = new TestProblem5();\n+    double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 5.0e-10);\n+    assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) throws DerivativeException {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+    private double maxError = 0;\n+    private TestProblem3 pb;\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class ClassicalRungeKuttaStepInterpolatorTest {\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem4;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince54IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,\n+                                                                           1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep() {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 vecAbsoluteTolerance,\n+                                                                 vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testSmallLastStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract pb = new TestProblem5();\n+    double minStep = 1.25;\n+    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+    double scalAbsoluteTolerance = 6.0e-4;\n+    double scalRelativeTolerance = 6.0e-4;\n+\n+    AdaptiveStepsizeIntegrator integ =\n+      new DormandPrince54Integrator(minStep, maxStep,\n+                                    scalAbsoluteTolerance,\n+                                    scalRelativeTolerance);\n+\n+    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);\n+    integ.addStepHandler(handler);\n+    integ.setInitialStepSize(1.7);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(handler.wasLastSeen());\n+    assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 scalAbsoluteTolerance,\n+                                                                 scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 2.0e-7);\n+      assertTrue(handler.getMaximalValueError() < 2.0e-7);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+  }\n+\n+  private static class DP54SmallLastHandler implements StepHandler {\n+\n+    public DP54SmallLastHandler(double minStep) {\n+      lastSeen = false;\n+      this.minStep = minStep;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+      if (isLast) {\n+        lastSeen = true;\n+        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n+        assertTrue(Math.abs(h) < minStep);\n+      }\n+    }\n+\n+    public boolean wasLastSeen() {\n+      return lastSeen;\n+    }\n+\n+    private boolean lastSeen;\n+    private double  minStep;\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      EmbeddedRungeKuttaIntegrator integ =\n+          new DormandPrince54Integrator(minStep, maxStep,\n+                                        scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setSafety(0.8);\n+      integ.setMaxGrowth(5.0);\n+      integ.setMinReduction(0.3);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      assertEquals(0.8, integ.getSafety(), 1.0e-12);\n+      assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);\n+      assertEquals(0.3, integ.getMinReduction(), 1.0e-12);\n+\n+      // the 0.7 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertEquals(integ.getEvaluations(), pb.getCalls());\n+    assertTrue(pb.getCalls() < 2800);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.addStepHandler(new VariableHandler());\n+    double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                      pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 7.0e-10);\n+        assertTrue(nbSteps < 400);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    public VariableHandler() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 450.0));\n+        assertTrue(maxStep > (1.0 / 4.2));\n+      }\n+    }  \n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class DormandPrince54StepInterpolatorTest {\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 119500);\n+    assertTrue(bos.size () < 120500);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 7.0e-10);\n+\n+  }\n+\n+  @Test\n+  public void checkClone()\n+    throws DerivativeException, IntegratorException {\n+      TestProblem3 pb = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = scalAbsoluteTolerance;\n+      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+      integ.addStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+          throws DerivativeException {\n+              StepInterpolator cloned = interpolator.copy();\n+              double tA = cloned.getPreviousTime();\n+              double tB = cloned.getCurrentTime();\n+              double halfStep = Math.abs(tB - tA) / 2;\n+              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+              for (int i = 0; i < 10; ++i) {\n+                  double t = (i * tB + (9 - i) * tA) / 9;\n+                  interpolator.setInterpolatedTime(t);\n+                  assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                  cloned.setInterpolatedTime(t);\n+                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                  double[] referenceState = interpolator.getInterpolatedState();\n+                  double[] cloneState     = cloned.getInterpolatedState();\n+                  for (int j = 0; j < referenceState.length; ++j) {\n+                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                  }\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return true;\n+          }\n+          public void reset() {\n+          }\n+      });\n+      integ.integrate(pb,\n+              pb.getInitialTime(), pb.getInitialState(),\n+              pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem4;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.DummyStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince853IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince853IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep() {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  vecAbsoluteTolerance,\n+                                                                  vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 8.0e-8);\n+      assertTrue(handler.getMaximalValueError() < 2.0e-7);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-9;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertEquals(integ.getEvaluations(), pb.getCalls());\n+    assertTrue(pb.getCalls() < 3300);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.addStepHandler(new VariableHandler());\n+    double stopTime = integ.integrate(pb,\n+                                      pb.getInitialTime(), pb.getInitialState(),\n+                                      pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  public void testNoDenseOutput()\n+    throws DerivativeException, IntegratorException {\n+    TestProblem1 pb1 = new TestProblem1();\n+    TestProblem1 pb2 = pb1.copy();\n+    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n+    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-4;\n+    double scalRelativeTolerance = 1.0e-4;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.addStepHandler(DummyStepHandler.getInstance());\n+    integ.integrate(pb1,\n+                    pb1.getInitialTime(), pb1.getInitialState(),\n+                    pb1.getFinalTime(), new double[pb1.getDimension()]);\n+    int callsWithoutDenseOutput = pb1.getCalls();\n+    assertEquals(integ.getEvaluations(), callsWithoutDenseOutput);\n+\n+    integ.addStepHandler(new InterpolatingStepHandler());\n+    integ.integrate(pb2,\n+                    pb2.getInitialTime(), pb2.getInitialState(),\n+                    pb2.getFinalTime(), new double[pb2.getDimension()]);\n+    int callsWithDenseOutput = pb2.getCalls();\n+    assertEquals(integ.getEvaluations(), callsWithDenseOutput);\n+\n+    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n+\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.4e-10);\n+        assertTrue(nbSteps < 150);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    public VariableHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 100.0));\n+        assertTrue(maxStep > (1.0 / 2.0));\n+      }\n+    }\n+    private boolean firstTime = true;\n+    private double  minStep = 0;\n+    private double  maxStep = 0;\n+  }\n+\n+  private static class InterpolatingStepHandler implements StepHandler {\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+      double prev = interpolator.getPreviousTime();\n+      double curr = interpolator.getCurrentTime();\n+      interpolator.setInterpolatedTime(0.5*(prev + curr));\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class DormandPrince853StepInterpolatorTest {\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 86000);\n+    assertTrue(bos.size () < 87000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 2.4e-10);\n+\n+  }\n+\n+  @Test\n+  public void checklone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.addStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemFactory;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.EulerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class EulerIntegratorTest\n+  extends TestCase {\n+\n+  public EulerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new EulerIntegrator(0.01).integrate(pb,\n+                                          0.0, new double[pb.getDimension()+10],\n+                                          1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = problems[k].copy();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new EulerIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-4);\n+   assertTrue(handler.getMaximalValueError() < 1.0e-3);\n+   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+   assertEquals(\"Euler\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalValueError() > 0.2);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new EulerIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 0.45);\n+      assertTrue(handler.getMaximalValueError() < 0.45);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Euler\", integ.getName());\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new EulerIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+            if (! isLast) {\n+                assertEquals(step,\n+                             interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                             1.0e-12);\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return false;\n+        }\n+        public void reset() {\n+        }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+                          private static final long serialVersionUID = 0L;\n+                          public void computeDerivatives(double t, double[] y, double[] dot) {\n+                              dot[0] = 1.0;\n+                          }\n+                          public int getDimension() {\n+                              return 1;\n+                          }\n+                      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EulerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class EulerStepInterpolatorTest {\n+\n+  @Test\n+  public void noReset() throws DerivativeException {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  @Test\n+  public void interpolationAtBounds()\n+    throws DerivativeException {\n+\n+    double   t0 = 0;\n+    double[] y0 = {0.0, 1.0, -2.0};\n+\n+    double[] y = y0.clone();\n+    double[][] yDot = { new double[y0.length] };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n+    interpolator.storeTime(t0);\n+\n+    double dt = 1.0;\n+    y[0] =  1.0;\n+    y[1] =  3.0;\n+    y[2] = -4.0;\n+    yDot[0][0] = (y[0] - y0[0]) / dt;\n+    yDot[0][1] = (y[1] - y0[1]) / dt;\n+    yDot[0][2] = (y[2] - y0[2]) / dt;\n+    interpolator.shift();\n+    interpolator.storeTime(t0 + dt);\n+\n+    interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  @Test\n+  public void interpolationInside()\n+  throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n+\n+  }\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+    \n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+    assertTrue(maxError < 0.001);\n+\n+  }\n+\n+  private static class DummyIntegrator extends RungeKuttaIntegrator {\n+\n+      \n+      protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {\n+          super(\"dummy\", new double[0], new double[0][0], new double[0], prototype, Double.NaN);\n+      }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemFactory;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class GillIntegratorTest\n+  extends TestCase {\n+\n+  public GillIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new GillIntegrator(0.01).integrate(pb,\n+                                         0.0, new double[pb.getDimension()+10],\n+                                         1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 5; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = problems[k].copy();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new GillIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 5) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"Gill\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new GillIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 5.0e-10);\n+      assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Gill\", integ.getName());\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    integ.addStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ = new GillIntegrator(0.3);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) throws DerivativeException {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.001);\n+      }\n+    }\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new GillIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class GillStepInterpolatorTest {\n+\n+  @Test\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.003);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem4;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class GraggBulirschStoerIntegratorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      AdaptiveStepsizeIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep() {\n+\n+    try {\n+      TestProblem5 pb  = new TestProblem5();\n+      double minStep   = 0.1 * Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep   = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };\n+      double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         vecAbsoluteTolerance, vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 9.0e-10);\n+      assertTrue(handler.getMaximalValueError() < 9.0e-10);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -4; ++i) {\n+      TestProblem1 pb     = new TestProblem1();\n+      double minStep      = 0;\n+      double maxStep      = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = Math.pow(10.0, i);\n+      double relTolerance = absTolerance;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the coefficients are only valid for this test\n+      // and have been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      double ratio =  handler.getMaximalValueError() / absTolerance;\n+      assertTrue(ratio < 2.4);\n+      assertTrue(ratio > 0.02);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testIntegratorControls()\n+  throws DerivativeException, IntegratorException {\n+\n+    TestProblem3 pb = new TestProblem3(0.999);\n+    GraggBulirschStoerIntegrator integ =\n+        new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),\n+                1.0e-8, 1.0e-10);\n+\n+    double errorWithDefaultSettings = getMaxError(integ, pb);\n+\n+    // stability control\n+    integ.setStabilityCheck(true, 2, 1, 0.99);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setStabilityCheck(true, -1, -1, -1);\n+\n+    integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setStepsizeControl(-1, -1, -1, -1);\n+\n+    integ.setOrderControl(10, 0.7, 0.95);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setOrderControl(-1, -1, -1);\n+\n+    integ.setInterpolationControl(true, 3);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setInterpolationControl(true, -1);\n+\n+  }\n+\n+  private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n+    throws DerivativeException, IntegratorException {\n+      TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n+      integrator.addStepHandler(handler);\n+      integrator.integrate(pb,\n+                           pb.getInitialTime(), pb.getInitialState(),\n+                           pb.getFinalTime(), new double[pb.getDimension()]);\n+      return handler.getMaximalValueError();\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-10;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-6;\n+    double relTolerance   = 1.0e-6;\n+\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.addStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertEquals(integ.getEvaluations(), pb.getCalls());\n+    assertTrue(pb.getCalls() < 2150);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-8;\n+    double relTolerance   = 1.0e-8;\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.addStepHandler(new VariableStepHandler());\n+    double stopTime = integ.integrate(pb,\n+                                      pb.getInitialTime(), pb.getInitialState(),\n+                                      pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  public void testUnstableDerivative()\n+    throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 100; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((100 - a) * prev + a * curr) / 100;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.7e-6);\n+        assertTrue(nbSteps < 80);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static class VariableStepHandler implements StepHandler {\n+    public VariableStepHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < 8.2e-3);\n+        assertTrue(maxStep > 1.7);\n+      }\n+    }\n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class GraggBulirschStoerStepInterpolatorTest {\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-8);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 34000);\n+    assertTrue(bos.size () < 35000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 5.0e-11);\n+\n+  }\n+\n+  @Test\n+  public void checklone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                          scalAbsoluteTolerance,\n+                                                                          scalRelativeTolerance);\n+    integ.addStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem4;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class HighamHall54IntegratorTest\n+  extends TestCase {\n+\n+  public HighamHall54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testWrongDerivative() {\n+    try {\n+      HighamHall54Integrator integrator =\n+          new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      FirstOrderDifferentialEquations equations =\n+          new FirstOrderDifferentialEquations() {\n+            private static final long serialVersionUID = -1157081786301178032L;\n+            public void computeDerivatives(double t, double[] y, double[] dot)\n+            throws DerivativeException {\n+            if (t < -0.5) {\n+                throw new DerivativeException(\"{0}\", \"oops\");\n+            } else {\n+                throw new DerivativeException(new RuntimeException(\"oops\"));\n+           }\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      };\n+\n+      try  {\n+        integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);\n+        fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        // expected behavior\n+      }\n+\n+      try  {\n+        integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);\n+        fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        // expected behavior\n+      }\n+\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());        \n+    }\n+  }\n+\n+  public void testMinStep() {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              vecAbsoluteTolerance,\n+                                                              vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 5.0e-7);\n+      assertTrue(handler.getMaximalValueError() < 5.0e-7);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 1.0e-7);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testEventsErrors() {\n+\n+      final TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ =\n+          new HighamHall54Integrator(minStep, maxStep,\n+                                     scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+\n+      integ.addEventHandler(new EventHandler() {\n+        public int eventOccurred(double t, double[] y, boolean increasing) {\n+          return EventHandler.CONTINUE;\n+        }\n+        public double g(double t, double[] y) throws EventException {\n+          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+          double offset = t - middle;\n+          if (offset > 0) {\n+            throw new EventException(\"Evaluation failed for argument = {0}\", t);\n+          }\n+          return offset;\n+        }\n+        public void resetState(double t, double[] y) {\n+        }\n+        private static final long serialVersionUID = 935652725339916361L;\n+      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+\n+      try {\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+      }\n+\n+  }\n+\n+  public void testEventsNoConvergence() {\n+\n+    final TestProblem1 pb = new TestProblem1();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ =\n+        new HighamHall54Integrator(minStep, maxStep,\n+                                   scalAbsoluteTolerance, scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+\n+    integ.addEventHandler(new EventHandler() {\n+      public int eventOccurred(double t, double[] y, boolean increasing) {\n+        return EventHandler.CONTINUE;\n+      }\n+      public double g(double t, double[] y) {\n+        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+        double offset = t - middle;\n+        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);\n+      }\n+      public void resetState(double t, double[] y) {\n+      }\n+      private static final long serialVersionUID = 935652725339916361L;\n+    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);\n+\n+    try {\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch (IntegratorException ie) {\n+       assertTrue(ie.getCause() != null);\n+       assertTrue(ie.getCause() instanceof ConvergenceException);\n+    } catch (Exception e) {\n+      fail(\"wrong exception type caught\");\n+    }\n+\n+}\n+\n+  public void testSanityChecks() {\n+    try {\n+      final TestProblem3 pb  = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), new double[6],\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[6]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getInitialTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };\n+    double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            vecAbsoluteTolerance,\n+                                                            vecRelativeTolerance);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) throws DerivativeException {\n+\n+      ++nbSteps;\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 4e-11);\n+        assertTrue(nbSteps < 670);\n+      }\n+    }\n+    private TestProblem3 pb;\n+    private int nbSteps;\n+    private double maxError;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class HighamHall54StepInterpolatorTest {\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 158000);\n+    assertTrue(bos.size () < 159000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.6e-10);\n+\n+  }\n+\n+  @Test\n+  public void checkClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.addStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemFactory;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class MidpointIntegratorTest\n+  extends TestCase {\n+\n+  public MidpointIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new MidpointIntegrator(0.01).integrate(pb,\n+                                             0.0, new double[pb.getDimension()+10],\n+                                             1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = problems[k].copy();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+        FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb,\n+                                          pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-7);\n+    assertTrue(handler.getMaximalValueError() < 1.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"midpoint\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalValueError() > 0.05);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 6.0e-4);\n+      assertTrue(handler.getMaximalValueError() < 6.0e-4);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"midpoint\", integ.getName());\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class MidpointStepInterpolatorTest {\n+\n+  @Test\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 98000);\n+    assertTrue(bos.size () < 99000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-6);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/StepProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+\n+public class StepProblem\n+  implements FirstOrderDifferentialEquations, EventHandler {\n+\n+  public StepProblem(double rateBefore, double rateAfter,\n+                     double switchTime) {\n+    this.rateAfter  = rateAfter;\n+    this.switchTime = switchTime;\n+    setRate(rateBefore);\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] = rate;\n+  }\n+\n+  public int getDimension() {\n+    return 1;\n+  }\n+\n+  public void setRate(double rate) {\n+    this.rate = rate;\n+  }\n+\n+  public int eventOccurred(double t, double[] y, boolean increasing) {\n+    setRate(rateAfter);\n+    return RESET_DERIVATIVES;\n+  }\n+\n+  public double g(double t, double[] y) {\n+    return t - switchTime;\n+  }\n+\n+  public void resetState(double t, double[] y) {\n+  }\n+\n+  private double rate;\n+  private double rateAfter;\n+  private double switchTime;\n+\n+  private static final long serialVersionUID = 7590601995477504318L;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.TestProblem5;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.ode.TestProblemFactory;\n+import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ThreeEighthesIntegratorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ThreeEighthesIntegrator(0.01).integrate(pb,\n+                                                  0.0, new double[pb.getDimension()+10],\n+                                                  1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+    \n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = problems[k].copy();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+ public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"3/8\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 5.0e-10);\n+      assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"3/8\", integ.getName());\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      maxError = 0;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+      maxError = 0;\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) throws DerivativeException {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+\n+    private TestProblem3 pb;\n+    private double maxError = 0;\n+\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Test;\n+\n+public class ThreeEighthesStepInterpolatorTest {\n+\n+  @Test\n+  public void derivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  @Test\n+  public void serialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.junit.Test;\n+\n+public class DummyStepInterpolatorTest {\n+\n+  @Test\n+  public void testNoReset() throws DerivativeException {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testFixedState()\n+    throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testSerialization()\n+  throws DerivativeException, IOException, ClassNotFoundException {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(interpolator);\n+\n+    assertTrue(bos.size () > 150);\n+    assertTrue(bos.size () < 250);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();\n+\n+    dsi.setInterpolatedTime(0.5);\n+    double[] result = dsi.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testImpossibleSerialization()\n+  throws IOException {\n+\n+    double[] y = { 0.0, 1.0, -2.0 };\n+    AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    try {\n+        oos.writeObject(interpolator);\n+        fail(\"an exception should have been thrown\");\n+    } catch (IOException ioe) {\n+        // expected behavior\n+        assertEquals(0, ioe.getMessage().length());\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  private static class BadStepInterpolator extends DummyStepInterpolator {\n+\t  @SuppressWarnings(\"unused\")\n+\t  public BadStepInterpolator() {\n+\t  }\n+\t  public BadStepInterpolator(double[] y, boolean forward) {\n+\t\t  super(y, forward);\n+\t  }\n+\t  @Override\n+\t  protected void doFinalize()\n+\t  throws DerivativeException {\n+          throw new DerivativeException(null);\n+      }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem1;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;\n+import org.junit.Test;\n+\n+public class NordsieckStepInterpolatorTest {\n+\n+    @Test\n+    public void derivativesConsistency()\n+    throws DerivativeException, IntegratorException {\n+        TestProblem3 pb = new TestProblem3();\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 7e-10);\n+    }\n+\n+    @Test\n+    public void serialization()\n+    throws DerivativeException, IntegratorException,\n+    IOException, ClassNotFoundException {\n+\n+        TestProblem1 pb = new TestProblem1();\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+        integ.addStepHandler(new ContinuousOutputModel());\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+        for (StepHandler handler : integ.getStepHandlers()) {\n+            oos.writeObject(handler);\n+        }\n+\n+        assertTrue(bos.size () >  20000);\n+        assertTrue(bos.size () <  25000);\n+\n+        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+        ObjectInputStream     ois = new ObjectInputStream(bis);\n+        ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+        Random random = new Random(347588535632l);\n+        double maxError = 0.0;\n+        for (int i = 0; i < 1000; ++i) {\n+            double r = random.nextDouble();\n+            double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+            cm.setInterpolatedTime(time);\n+            double[] interpolatedY = cm.getInterpolatedState ();\n+            double[] theoreticalY  = pb.computeTheoreticalState(time);\n+            double dx = interpolatedY[0] - theoreticalY[0];\n+            double dy = interpolatedY[1] - theoreticalY[1];\n+            double error = dx * dx + dy * dy;\n+            if (error > maxError) {\n+                maxError = error;\n+            }\n+        }\n+\n+        assertTrue(maxError < 1.0e-6);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode.sampling;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblemAbstract;\n+\n+public class StepInterpolatorTestUtils {\n+\n+    public static void checkDerivativesConsistency(final FirstOrderIntegrator integrator,\n+                                                   final TestProblemAbstract problem,\n+                                                   final double threshold)\n+        throws DerivativeException, IntegratorException {\n+        integrator.addStepHandler(new StepHandler() {\n+\n+            public boolean requiresDenseOutput() {\n+                return true;\n+            }\n+\n+            public void handleStep(StepInterpolator interpolator, boolean isLast)\n+                throws DerivativeException {\n+\n+                final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());\n+                final double t = interpolator.getCurrentTime() - 300 * h;\n+\n+                if (Math.abs(h) < 10 * Math.ulp(t)) {\n+                    return;\n+                }\n+\n+                interpolator.setInterpolatedTime(t - 4 * h);\n+                final double[] yM4h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t - 3 * h);\n+                final double[] yM3h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t - 2 * h);\n+                final double[] yM2h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t - h);\n+                final double[] yM1h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + h);\n+                final double[] yP1h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + 2 * h);\n+                final double[] yP2h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + 3 * h);\n+                final double[] yP3h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + 4 * h);\n+                final double[] yP4h = interpolator.getInterpolatedState().clone();\n+\n+                interpolator.setInterpolatedTime(t);\n+                final double[] yDot = interpolator.getInterpolatedDerivatives();\n+\n+                for (int i = 0; i < yDot.length; ++i) {\n+                    final double approYDot = ( -3 * (yP4h[i] - yM4h[i]) +\n+                                               32 * (yP3h[i] - yM3h[i]) +\n+                                             -168 * (yP2h[i] - yM2h[i]) +\n+                                              672 * (yP1h[i] - yM1h[i])) / (840 * h);\n+                    assertEquals(approYDot, yDot[i], threshold);\n+                }\n+\n+            }\n+\n+            public void reset() {\n+            }\n+\n+        });\n+\n+        integrator.integrate(problem,\n+                             problem.getInitialTime(), problem.getInitialState(),\n+                             problem.getFinalTime(), new double[problem.getDimension()]);\n+\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.TestProblem3;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.StepNormalizer;\n+\n+import junit.framework.*;\n+\n+public class StepNormalizerTest\n+  extends TestCase {\n+\n+  public StepNormalizerTest(String name) {\n+    super(name);\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.addStepHandler(new StepNormalizer(range / 10.0,\n+                                       new FixedStepHandler() {\n+                                        private static final long serialVersionUID = 1650337364641626444L;\n+                                        private boolean firstCall = true;\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                double[] yDot,\n+                                                                boolean isLast) {\n+                                           if (firstCall) {\n+                                             checkValue(t, pb.getInitialTime());\n+                                             firstCall = false;\n+                                           }\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t, pb.getFinalTime());\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void testBeforeEnd()\n+    throws DerivativeException, IntegratorException {\n+    final double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.addStepHandler(new StepNormalizer(range / 10.5,\n+                                       new FixedStepHandler() {\n+                                        private static final long serialVersionUID = 2228457391561277298L;\n+                                        public void handleStep(double t,\n+                                                                double[] y,\n+                                                                double[] yDot,\n+                                                                boolean isLast) {\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t,\n+                                                        pb.getFinalTime() - range / 21.0);\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public void setLastSeen(boolean lastSeen) {\n+    this.lastSeen = lastSeen;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(StepNormalizerTest.class);\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);\n+    lastSeen = false;\n+  }\n+\n+  @Override\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+  boolean lastSeen;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n+import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Test;\n+\n+public class MultiStartDifferentiableMultivariateRealOptimizerTest {\n+\n+    @Test\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        NonLinearConjugateGradientOptimizer underlying =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(753289573253l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(new double[] { 50.0, 50.0 }, new double[] { 10.0, 10.0 },\n+                                                  new GaussianRandomGenerator(g));\n+        MultiStartDifferentiableMultivariateRealOptimizer optimizer =\n+            new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);\n+        optimizer.setMaxIterations(100);\n+        assertEquals(100, optimizer.getMaxIterations());\n+        optimizer.setMaxEvaluations(100);\n+        assertEquals(100, optimizer.getMaxEvaluations());\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n+        BrentSolver solver = new BrentSolver();\n+        solver.setAbsoluteAccuracy(1.0e-13);\n+        solver.setRelativeAccuracy(1.0e-15);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+        RealPointValuePair[] optima = optimizer.getOptima();\n+        for (RealPointValuePair o : optima) {\n+            Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);\n+            assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n+            assertEquals(96.075902096, center.x, 1.0e-8);\n+            assertEquals(48.135167894, center.y, 1.0e-8);\n+        }\n+        assertTrue(optimizer.getGradientEvaluations() > 650);\n+        assertTrue(optimizer.getGradientEvaluations() < 700);\n+        assertTrue(optimizer.getEvaluations() > 70);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+        assertTrue(optimizer.getIterations() > 70);\n+        assertTrue(optimizer.getIterations() < 90);\n+        assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateRealFunction {\n+\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        private double[] gradient(double[] point) {\n+\n+            // optimal radius\n+            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+            double radius = getRadius(center);\n+\n+            // gradient of the sum of squared residuals\n+            double dJdX = 0;\n+            double dJdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dJdX += (center.x - pk.x) * (dk - radius) / dk;\n+                dJdY += (center.y - pk.y) * (dk - radius) / dk;\n+            }\n+            dJdX *= 2;\n+            dJdY *= 2;\n+\n+            return new double[] { dJdX, dJdY };\n+\n+        }\n+\n+        public double value(double[] variables)\n+        throws IllegalArgumentException, FunctionEvaluationException {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double sum = 0;\n+            for (Point2D.Double point : points) {\n+                double di = point.distance(center) - radius;\n+                sum += di * di;\n+            }\n+\n+            return sum;\n+\n+        }\n+\n+        public MultivariateVectorialFunction gradient() {\n+            return new MultivariateVectorialFunction() {\n+                public double[] value(double[] point) {\n+                    return gradient(point);\n+                }\n+            };\n+        }\n+\n+        public MultivariateRealFunction partialDerivative(final int k) {\n+            return new MultivariateRealFunction() {\n+                public double value(double[] point) {\n+                    return gradient(point)[k];\n+                }\n+            };\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Test;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {\n+\n+    @Test\n+    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n+            new GaussNewtonOptimizer(true);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(16069223052l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));\n+        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n+            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n+                                                                       10, generator);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+\n+        // no optima before first optimization attempt\n+        try {\n+            optimizer.getOptima();\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalStateException ise) {\n+            // expected\n+        }\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+        VectorialPointValuePair[] optima = optimizer.getOptima();\n+        assertEquals(10, optima.length);\n+        for (int i = 0; i < optima.length; ++i) {\n+            assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);\n+            assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);\n+        }\n+        assertTrue(optimizer.getEvaluations() > 20);\n+        assertTrue(optimizer.getEvaluations() < 50);\n+        assertTrue(optimizer.getIterations() > 20);\n+        assertTrue(optimizer.getIterations() < 50);\n+        assertTrue(optimizer.getJacobianEvaluations() > 20);\n+        assertTrue(optimizer.getJacobianEvaluations() < 50);\n+        assertEquals(100, optimizer.getMaxIterations());\n+    }\n+\n+    @Test(expected = OptimizationException.class)\n+    public void testNoOptimum() throws FunctionEvaluationException, OptimizationException {\n+        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n+            new GaussNewtonOptimizer(true);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(12373523445l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));\n+        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n+            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n+                                                                       10, generator);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        optimizer.optimize(new DifferentiableMultivariateVectorialFunction() {\n+                public MultivariateMatrixFunction jacobian() {\n+                    return null;\n+                }\n+                public double[] value(double[] point) throws FunctionEvaluationException {\n+                    throw new FunctionEvaluationException(point[0]);\n+                }\n+            }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });\n+    }\n+\n+    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n+\n+        private static final long serialVersionUID = -8804268799379350190L;\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new BlockRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        public double[] value(double[] variables) {\n+            return factors.operate(variables);\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -8387467946663627585L;\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.direct.NelderMead;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Test;\n+\n+public class MultiStartMultivariateRealOptimizerTest {\n+\n+  @Test\n+  public void testRosenbrock()\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    Rosenbrock rosenbrock = new Rosenbrock();\n+    NelderMead underlying = new NelderMead();\n+    underlying.setStartConfiguration(new double[][] {\n+                                         { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+                                     });\n+    JDKRandomGenerator g = new JDKRandomGenerator();\n+    g.setSeed(16069223052l);\n+    RandomVectorGenerator generator =\n+        new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));\n+    MultiStartMultivariateRealOptimizer optimizer =\n+        new MultiStartMultivariateRealOptimizer(underlying, 10, generator);\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxIterations(100);\n+    RealPointValuePair optimum =\n+        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 20);\n+    assertTrue(optimizer.getEvaluations() < 250);\n+    assertTrue(optimum.getValue() < 8.0e-4);\n+\n+  }\n+\n+  private static class Rosenbrock implements MultivariateRealFunction {\n+\n+      private int count;\n+\n+      public Rosenbrock() {\n+          count = 0;\n+      }\n+\n+      public double value(double[] x) throws FunctionEvaluationException {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+      }\n+\n+      public int getCount() {\n+          return count;\n+      }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.junit.Test;\n+\n+public class MultiStartUnivariateRealOptimizerTest {\n+\n+    @Test\n+    public void testSinMin() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer();\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(44428400075l);\n+        MultiStartUnivariateRealOptimizer minimizer =\n+            new MultiStartUnivariateRealOptimizer(underlying, 10, g);\n+        minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);\n+        double[] optima = minimizer.getOptima();\n+        double[] optimaValues = minimizer.getOptimaValues();\n+        for (int i = 1; i < optima.length; ++i) {\n+            double d = (optima[i] - optima[i-1]) / (2 * Math.PI);\n+            assertTrue (Math.abs(d - Math.rint(d)) < 1.0e-8);\n+            assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n+            assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n+        }\n+        assertTrue(minimizer.getEvaluations() > 2900);\n+        assertTrue(minimizer.getEvaluations() < 3100);\n+    }\n+\n+    @Test\n+    public void testQuinticMin() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer();\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(4312000053l);\n+        MultiStartUnivariateRealOptimizer minimizer =\n+            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n+        minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n+        minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n+\n+        try {\n+            minimizer.getOptima();\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalStateException ise) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            minimizer.getOptimaValues();\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalStateException ise) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        assertEquals(-0.27195612846834, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-13);\n+        assertEquals(-0.27194301946870, minimizer.getResult(), 1.0e-13);\n+        assertEquals(-0.04433426940878, minimizer.getFunctionValue(), 1.0e-13);\n+\n+        double[] optima = minimizer.getOptima();\n+        double[] optimaValues = minimizer.getOptimaValues();\n+        for (int i = 0; i < optima.length; ++i) {\n+            assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n+        }\n+\n+        assertTrue(minimizer.getEvaluations()    >= 510);\n+        assertTrue(minimizer.getEvaluations()    <= 530);\n+        assertTrue(minimizer.getIterationCount() >= 150);\n+        assertTrue(minimizer.getIterationCount() <= 170);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+public class MultiDirectionalTest\n+  extends TestCase {\n+\n+  public MultiDirectionalTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testFunctionEvaluationExceptions() {\n+      MultivariateRealFunction wrong =\n+          new MultivariateRealFunction() {\n+            private static final long serialVersionUID = 4751314470965489371L;\n+            public double value(double[] x) throws FunctionEvaluationException {\n+                if (x[0] < 0) {\n+                    throw new FunctionEvaluationException(x, \"{0}\", \"oops\");\n+                } else if (x[0] > 1) {\n+                    throw new FunctionEvaluationException(new RuntimeException(\"oops\"), x);\n+                } else {\n+                    return x[0] * (1 - x[0]);\n+                }\n+            }\n+      };\n+      try {\n+          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (FunctionEvaluationException ce) {\n+          // expected behavior\n+          assertNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+      try {\n+          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (FunctionEvaluationException ce) {\n+          // expected behavior\n+          assertNotNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+  }\n+\n+  public void testMinimizeMaximize()\n+      throws FunctionEvaluationException, ConvergenceException {\n+\n+      // the following function has 4 local extrema:\n+      final double xM        = -3.841947088256863675365;\n+      final double yM        = -1.391745200270734924416;\n+      final double xP        =  0.2286682237349059125691;\n+      final double yP        = -yM;\n+      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n+      final double valueXmYp = -valueXmYm;                // local  minimum\n+      final double valueXpYm = -0.7290400707055187115322; // global minimum\n+      final double valueXpYp = -valueXpYm;                // global maximum\n+      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n+          private static final long serialVersionUID = -7039124064449091152L;\n+          public double value(double[] variables) throws FunctionEvaluationException {\n+              final double x = variables[0];\n+              final double y = variables[1];\n+              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n+          }\n+      };\n+\n+      MultiDirectional optimizer = new MultiDirectional();\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setMaxIterations(200);\n+      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n+      RealPointValuePair optimum;\n+\n+      // minimization\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n+      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n+      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+      // maximization\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n+      assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n+      assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n+      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+  }\n+\n+  public void testRosenbrock()\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    MultivariateRealFunction rosenbrock =\n+      new MultivariateRealFunction() {\n+        private static final long serialVersionUID = -9044950469615237490L;\n+        public double value(double[] x) throws FunctionEvaluationException {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+        }\n+      };\n+\n+    count = 0;\n+    MultiDirectional optimizer = new MultiDirectional();\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxIterations(100);\n+    optimizer.setStartConfiguration(new double[][] {\n+            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+    });\n+    RealPointValuePair optimum =\n+        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+    assertEquals(count, optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 70);\n+    assertTrue(optimizer.getEvaluations() < 100);\n+    assertTrue(optimum.getValue() > 1.0e-2);\n+\n+  }\n+\n+  public void testPowell()\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    MultivariateRealFunction powell =\n+      new MultivariateRealFunction() {\n+        private static final long serialVersionUID = -832162886102041840L;\n+        public double value(double[] x) throws FunctionEvaluationException {\n+          ++count;\n+          double a = x[0] + 10 * x[1];\n+          double b = x[2] - x[3];\n+          double c = x[1] - 2 * x[2];\n+          double d = x[0] - x[3];\n+          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+      };\n+\n+    count = 0;\n+    MultiDirectional optimizer = new MultiDirectional();\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxIterations(1000);\n+    RealPointValuePair optimum =\n+      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+    assertEquals(count, optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 800);\n+    assertTrue(optimizer.getEvaluations() < 900);\n+    assertTrue(optimum.getValue() > 1.0e-2);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MultiDirectionalTest.class);\n+  }\n+\n+  private int count;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.LeastSquaresConverter;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleRealPointChecker;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.junit.Test;\n+\n+public class NelderMeadTest {\n+\n+  @Test\n+  public void testFunctionEvaluationExceptions() {\n+      MultivariateRealFunction wrong =\n+          new MultivariateRealFunction() {\n+            private static final long serialVersionUID = 4751314470965489371L;\n+            public double value(double[] x) throws FunctionEvaluationException {\n+                if (x[0] < 0) {\n+                    throw new FunctionEvaluationException(x, \"{0}\", \"oops\");\n+                } else if (x[0] > 1) {\n+                    throw new FunctionEvaluationException(new RuntimeException(\"oops\"), x);\n+                } else {\n+                    return x[0] * (1 - x[0]);\n+                }\n+            }\n+      };\n+      try {\n+          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (FunctionEvaluationException ce) {\n+          // expected behavior\n+          assertNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+      try {\n+          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (FunctionEvaluationException ce) {\n+          // expected behavior\n+          assertNotNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+  }\n+\n+  @Test\n+  public void testMinimizeMaximize()\n+      throws FunctionEvaluationException, ConvergenceException {\n+\n+      // the following function has 4 local extrema:\n+      final double xM        = -3.841947088256863675365;\n+      final double yM        = -1.391745200270734924416;\n+      final double xP        =  0.2286682237349059125691;\n+      final double yP        = -yM;\n+      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n+      final double valueXmYp = -valueXmYm;                // local  minimum\n+      final double valueXpYm = -0.7290400707055187115322; // global minimum\n+      final double valueXpYp = -valueXpYm;                // global maximum\n+      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n+          private static final long serialVersionUID = -7039124064449091152L;\n+          public double value(double[] variables) throws FunctionEvaluationException {\n+              final double x = variables[0];\n+              final double y = variables[1];\n+              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n+          }\n+      };\n+\n+      NelderMead optimizer = new NelderMead();\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setMaxIterations(100);\n+      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n+      RealPointValuePair optimum;\n+\n+      // minimization\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 2.0e-7);\n+      assertEquals(yP,        optimum.getPoint()[1], 2.0e-5);\n+      assertEquals(valueXmYp, optimum.getValue(),    6.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);\n+      assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);\n+      assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);              \n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+      // maximization\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 1.0e-5);\n+      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXmYm, optimum.getValue(),    3.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 4.0e-6);\n+      assertEquals(yP,        optimum.getPoint()[1], 5.0e-6);\n+      assertEquals(valueXpYp, optimum.getValue(),    7.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+  }\n+\n+  @Test\n+  public void testRosenbrock()\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    Rosenbrock rosenbrock = new Rosenbrock();\n+    NelderMead optimizer = new NelderMead();\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxIterations(100);\n+    optimizer.setStartConfiguration(new double[][] {\n+            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+    });\n+    RealPointValuePair optimum =\n+        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 40);\n+    assertTrue(optimizer.getEvaluations() < 50);\n+    assertTrue(optimum.getValue() < 8.0e-4);\n+\n+  }\n+\n+  @Test\n+  public void testPowell()\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    Powell powell = new Powell();\n+    NelderMead optimizer = new NelderMead();\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxIterations(200);\n+    RealPointValuePair optimum =\n+      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+    assertEquals(powell.getCount(), optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 110);\n+    assertTrue(optimizer.getEvaluations() < 130);\n+    assertTrue(optimum.getValue() < 2.0e-3);\n+\n+  }\n+\n+  @Test\n+  public void testLeastSquares1()\n+  throws FunctionEvaluationException, ConvergenceException {\n+\n+      final RealMatrix factors =\n+          new Array2DRowRealMatrix(new double[][] {\n+              { 1.0, 0.0 },\n+              { 0.0, 1.0 }\n+          }, false);\n+      LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+          public double[] value(double[] variables) {\n+              return factors.operate(variables);\n+          }\n+      }, new double[] { 2.0, -3.0 });\n+      NelderMead optimizer = new NelderMead();\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n+      optimizer.setMaxIterations(200);\n+      RealPointValuePair optimum =\n+          optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n+      assertEquals( 2.0, optimum.getPointRef()[0], 3.0e-5);\n+      assertEquals(-3.0, optimum.getPointRef()[1], 4.0e-4);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 80);\n+      assertTrue(optimum.getValue() < 1.0e-6);\n+  }\n+\n+  @Test\n+  public void testLeastSquares2()\n+  throws FunctionEvaluationException, ConvergenceException {\n+\n+      final RealMatrix factors =\n+          new Array2DRowRealMatrix(new double[][] {\n+              { 1.0, 0.0 },\n+              { 0.0, 1.0 }\n+          }, false);\n+      LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+          public double[] value(double[] variables) {\n+              return factors.operate(variables);\n+          }\n+      }, new double[] { 2.0, -3.0 }, new double[] { 10.0, 0.1 });\n+      NelderMead optimizer = new NelderMead();\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n+      optimizer.setMaxIterations(200);\n+      RealPointValuePair optimum =\n+          optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n+      assertEquals( 2.0, optimum.getPointRef()[0], 5.0e-5);\n+      assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 80);\n+      assertTrue(optimum.getValue() < 1.0e-6);\n+  }\n+\n+  @Test\n+  public void testLeastSquares3()\n+  throws FunctionEvaluationException, ConvergenceException {\n+\n+      final RealMatrix factors =\n+          new Array2DRowRealMatrix(new double[][] {\n+              { 1.0, 0.0 },\n+              { 0.0, 1.0 }\n+          }, false);\n+      LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+          public double[] value(double[] variables) {\n+              return factors.operate(variables);\n+          }\n+      }, new double[] { 2.0, -3.0 }, new Array2DRowRealMatrix(new double [][] {\n+          { 1.0, 1.2 }, { 1.2, 2.0 }\n+      }));\n+      NelderMead optimizer = new NelderMead();\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n+      optimizer.setMaxIterations(200);\n+      RealPointValuePair optimum =\n+          optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n+      assertEquals( 2.0, optimum.getPointRef()[0], 2.0e-3);\n+      assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 80);\n+      assertTrue(optimum.getValue() < 1.0e-6);\n+  }\n+\n+  @Test(expected = MaxIterationsExceededException.class)\n+  public void testMaxIterations() throws MathException {\n+      try {\n+          Powell powell = new Powell();\n+          NelderMead optimizer = new NelderMead();\n+          optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+          optimizer.setMaxIterations(20);\n+          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+      } catch (OptimizationException oe) {\n+          if (oe.getCause() instanceof ConvergenceException) {\n+              throw (ConvergenceException) oe.getCause();\n+          }\n+          throw oe;\n+      }\n+  }\n+\n+  @Test(expected = MaxEvaluationsExceededException.class)\n+  public void testMaxEvaluations() throws MathException {\n+      try {\n+          Powell powell = new Powell();\n+          NelderMead optimizer = new NelderMead();\n+          optimizer.setConvergenceChecker(new SimpleRealPointChecker(-1.0, 1.0e-3));\n+          optimizer.setMaxEvaluations(20);\n+          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+      } catch (FunctionEvaluationException fee) {\n+          if (fee.getCause() instanceof ConvergenceException) {\n+              throw (ConvergenceException) fee.getCause();\n+          }\n+          throw fee;\n+      }\n+  }\n+\n+  private static class Rosenbrock implements MultivariateRealFunction {\n+\n+      private int count;\n+\n+      public Rosenbrock() {\n+          count = 0;\n+      }\n+\n+      public double value(double[] x) throws FunctionEvaluationException {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+      }\n+\n+      public int getCount() {\n+          return count;\n+      }\n+\n+  }\n+\n+  private static class Powell implements MultivariateRealFunction {\n+\n+      private int count;\n+\n+      public Powell() {\n+          count = 0;\n+      }\n+\n+      public double value(double[] x) throws FunctionEvaluationException {\n+          ++count;\n+          double a = x[0] + 10 * x[1];\n+          double b = x[2] - x[3];\n+          double c = x[1] - 2 * x[2];\n+          double d = x[0] - x[3];\n+          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+      }\n+\n+      public int getCount() {\n+          return count;\n+      }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Test;\n+\n+public class HarmonicFitterTest {\n+\n+    @Test\n+    public void testNoError() throws OptimizationException {\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+        for (double x = 0.0; x < 1.3; x += 0.01) {\n+            fitter.addObservedPoint(1.0, x, f.value(x));\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.0e-13);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 1.0e-13);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.0e-13);\n+\n+        for (double x = -1.0; x < 1.0; x += 0.01) {\n+            assertTrue(Math.abs(f.value(x) - fitted.value(x)) < 1.0e-13);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void test1PercentError() throws OptimizationException {\n+        Random randomizer = new Random(64925784252l);\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+        for (double x = 0.0; x < 10.0; x += 0.1) {\n+            fitter.addObservedPoint(1.0, x,\n+                                   f.value(x) + 0.01 * randomizer.nextGaussian());\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 2.7e-3);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.3e-2);\n+\n+    }\n+\n+    @Test\n+    public void testInitialGuess() throws OptimizationException {\n+        Random randomizer = new Random(45314242l);\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer(), new double[] { 0.15, 3.6, 4.5 });\n+        for (double x = 0.0; x < 10.0; x += 0.1) {\n+            fitter.addObservedPoint(1.0, x,\n+                                   f.value(x) + 0.01 * randomizer.nextGaussian());\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.2e-3);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.3e-3);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.7e-2);\n+\n+    }\n+\n+    @Test\n+    public void testUnsorted() throws OptimizationException {\n+        Random randomizer = new Random(64925784252l);\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+\n+        // build a regularly spaced array of measurements\n+        int size = 100;\n+        double[] xTab = new double[size];\n+        double[] yTab = new double[size];\n+        for (int i = 0; i < size; ++i) {\n+            xTab[i] = 0.1 * i;\n+            yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian();\n+        }\n+\n+        // shake it\n+        for (int i = 0; i < size; ++i) {\n+            int i1 = randomizer.nextInt(size);\n+            int i2 = randomizer.nextInt(size);\n+            double xTmp = xTab[i1];\n+            double yTmp = yTab[i1];\n+            xTab[i1] = xTab[i2];\n+            yTab[i1] = yTab[i2];\n+            xTab[i2] = xTmp;\n+            yTab[i2] = yTmp;\n+        }\n+\n+        // pass it to the fitter\n+        for (int i = 0; i < size; ++i) {\n+            fitter.addObservedPoint(1.0, xTab[i], yTab[i]);\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.5e-3);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.5e-2);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n+import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.junit.Test;\n+\n+public class PolynomialFitterTest {\n+\n+    @Test\n+    public void testNoError() throws OptimizationException {\n+        Random randomizer = new Random(64925784252l);\n+        for (int degree = 1; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter =\n+                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());\n+            for (int i = 0; i <= degree; ++i) {\n+                fitter.addObservedPoint(1.0, i, p.value(i));\n+            }\n+\n+            PolynomialFunction fitted = fitter.fit();\n+\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                double error = Math.abs(p.value(x) - fitted.value(x)) /\n+                               (1.0 + Math.abs(p.value(x)));\n+                assertEquals(0.0, error, 1.0e-6);\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSmallError() throws OptimizationException {\n+        Random randomizer = new Random(53882150042l);\n+        double maxError = 0;\n+        for (int degree = 0; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter =\n+                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                fitter.addObservedPoint(1.0, x,\n+                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n+            }\n+\n+            PolynomialFunction fitted = fitter.fit();\n+\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                double error = Math.abs(p.value(x) - fitted.value(x)) /\n+                              (1.0 + Math.abs(p.value(x)));\n+                maxError = Math.max(maxError, error);\n+                assertTrue(Math.abs(error) < 0.1);\n+            }\n+        }\n+        assertTrue(maxError > 0.01);\n+\n+    }\n+\n+    @Test\n+    public void testRedundantSolvable() {\n+        // Levenberg-Marquardt should handle redundant information gracefully\n+        checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true);\n+    }\n+\n+    @Test\n+    public void testRedundantUnsolvable() {\n+        // Gauss-Newton should not be able to solve redundant information\n+        DifferentiableMultivariateVectorialOptimizer optimizer =\n+            new GaussNewtonOptimizer(true);\n+        checkUnsolvableProblem(optimizer, false);\n+    }\n+\n+    private void checkUnsolvableProblem(DifferentiableMultivariateVectorialOptimizer optimizer,\n+                                        boolean solvable) {\n+        Random randomizer = new Random(1248788532l);\n+        for (int degree = 0; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter = new PolynomialFitter(degree, optimizer);\n+\n+            // reusing the same point over and over again does not bring\n+            // information, the problem cannot be solved in this case for\n+            // degrees greater than 1 (but one point is sufficient for\n+            // degree 0)\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                fitter.addObservedPoint(1.0, 0.0, p.value(0.0));\n+            }\n+\n+            try {\n+                fitter.fit();\n+                assertTrue(solvable || (degree == 0));\n+            } catch(OptimizationException e) {\n+                assertTrue((! solvable) && (degree > 0));\n+            }\n+\n+        }\n+\n+    }\n+\n+    private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {\n+        final double[] coefficients = new double[degree + 1];\n+        for (int i = 0; i <= degree; ++i) {\n+            coefficients[i] = randomizer.nextGaussian();\n+        }\n+        return new PolynomialFunction(coefficients);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.SimpleVectorialPointChecker;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class GaussNewtonOptimizerTest\n+extends TestCase {\n+\n+    public GaussNewtonOptimizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+    }\n+\n+    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n+                              new double[] { 4.0, 6.0, 1.0 });\n+\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n+\n+    }\n+\n+    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 2, 0, 0, 0, 0, 0 },\n+                { 0, 2, 0, 0, 0, 0 },\n+                { 0, 0, 2, 0, 0, 0 },\n+                { 0, 0, 0, 2, 0, 0 },\n+                { 0, 0, 0, 0, 2, 0 },\n+                { 0, 0, 0, 0, 0, 2 }\n+        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        for (int i = 0; i < problem.target.length; ++i) {\n+            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1,  0, 0 },\n+                { -1,  1, 0 },\n+                {  0, -1, 1 }\n+        }, new double[] { 1, 1, 1});\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+\n+    }\n+\n+    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n+        double epsilon = 1.0e-7;\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  2,  1,   0,  4,       0, 0 },\n+                { -4, -2,   3, -7,       0, 0 },\n+                {  4,  1,  -2,  8,       0, 0 },\n+                {  0, -3, -12, -1,       0, 0 },\n+                {  0,  0,   0,  0, epsilon, 1 },\n+                {  0,  0,   0,  0,       1, 1 }\n+        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n+\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+\n+    }\n+\n+    public void testNonInversible() {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1, 2, -3 },\n+                {  2, 1,  3 },\n+                { -3, 0, -9 }\n+        }, new double[] { 1, 1, 1 });\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+            fail(\"an exception should have been caught\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+    }\n+\n+    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem1 = new LinearProblem(new double[][] {\n+                { 10.0, 7.0,  8.0,  7.0 },\n+                {  7.0, 5.0,  6.0,  5.0 },\n+                {  8.0, 6.0, 10.0,  9.0 },\n+                {  7.0, 5.0,  9.0, 10.0 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum1 =\n+            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n+\n+        LinearProblem problem2 = new LinearProblem(new double[][] {\n+                { 10.00, 7.00, 8.10, 7.20 },\n+                {  7.08, 5.04, 6.00, 5.00 },\n+                {  8.00, 5.98, 9.89, 9.00 },\n+                {  6.99, 4.99, 9.00, 9.98 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        VectorialPointValuePair optimum2 =\n+            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n+        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n+        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n+        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersSimple() {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 3.0, 2.0,  0.0, 0.0 },\n+                { 0.0, 1.0, -1.0, 1.0 },\n+                { 2.0, 0.0,  1.0, 0.0 }\n+        }, new double[] { 7.0, 3.0, 5.0 });\n+\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+                               new double[] { 7, 6, 5, 4 });\n+            fail(\"an exception should have been caught\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+\n+    }\n+\n+    public void testMoreEstimatedParametersUnsorted() {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n+                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n+                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n+                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n+                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n+        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 2, 2, 2, 2, 2, 2 });\n+            fail(\"an exception should have been caught\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+    }\n+\n+    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 5.0 });\n+\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+                               new double[] { 1, 1 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n+        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n+\n+    }\n+\n+    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 4.0 });\n+\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n+        assertTrue(optimizer.getRMS() > 0.1);\n+\n+    }\n+\n+    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+\n+        try {\n+            optimizer.optimize(problem, problem.target,\n+                               new double[] { 1 },\n+                               new double[] { 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException oe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        try {\n+            optimizer.optimize(problem, new double[] { 1 },\n+                               new double[] { 1 },\n+                               new double[] { 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (FunctionEvaluationException oe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+    }\n+\n+    public void testMaxIterations() {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialPointChecker(1.0e-30, 1.0e-30));\n+        try {\n+            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n+                               new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+            fail(\"an exception should have been caught\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+    }\n+\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n+                               new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);\n+        assertEquals(96.07590209601095, center.x, 1.0e-10);\n+        assertEquals(48.135167894714,   center.y, 1.0e-10);\n+    }\n+\n+    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        double[][] points = new double[][] {\n+                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+        };\n+        double[] target = new double[points.length];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[points.length];\n+        Arrays.fill(weights, 2.0);\n+        for (int i = 0; i < points.length; ++i) {\n+            circle.addPoint(points[i][0], points[i][1]);\n+        }\n+        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n+            fail(\"an exception should have been caught\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(circle, target, weights, new double[] { 0, 0 });\n+        assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-8);\n+        assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-8);\n+        assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n+\n+    }\n+\n+    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n+\n+        private static final long serialVersionUID = -8804268799379350190L;\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new BlockRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        public double[] value(double[] variables) {\n+            return factors.operate(variables);\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -8387467946663627585L;\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {\n+\n+        private static final long serialVersionUID = -7165774454925027042L;\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public int getN() {\n+            return points.size();\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        private double[][] jacobian(double[] variables) {\n+\n+            int n = points.size();\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+\n+            // gradient of the optimal radius\n+            double dRdX = 0;\n+            double dRdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dRdX += (center.x - pk.x) / dk;\n+                dRdY += (center.y - pk.y) / dk;\n+            }\n+            dRdX /= n;\n+            dRdY /= n;\n+\n+            // jacobian of the radius residuals\n+            double[][] jacobian = new double[n][2];\n+            for (int i = 0; i < n; ++i) {\n+                Point2D.Double pi = points.get(i);\n+                double di   = pi.distance(center);\n+                jacobian[i][0] = (center.x - pi.x) / di - dRdX;    \n+                jacobian[i][1] = (center.y - pi.y) / di - dRdY;    \n+           }\n+\n+            return jacobian;\n+\n+        }\n+\n+        public double[] value(double[] variables) {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double[] residuals = new double[points.size()];\n+            for (int i = 0; i < residuals.length; ++i) {\n+                residuals[i] = points.get(i).distance(center) - radius;\n+            }\n+\n+            return residuals;\n+\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -4340046230875165095L;\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(GaussNewtonOptimizerTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class LevenbergMarquardtOptimizerTest\n+  extends TestCase {\n+\n+    public LevenbergMarquardtOptimizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        try {\n+            optimizer.guessParametersErrors();\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+    }\n+\n+    public void testQRColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n+                              new double[] { 4.0, 6.0, 1.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n+\n+    }\n+\n+    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 2, 0, 0, 0, 0, 0 },\n+                { 0, 2, 0, 0, 0, 0 },\n+                { 0, 0, 2, 0, 0, 0 },\n+                { 0, 0, 0, 2, 0, 0 },\n+                { 0, 0, 0, 0, 2, 0 },\n+                { 0, 0, 0, 0, 0, 2 }\n+        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        for (int i = 0; i < problem.target.length; ++i) {\n+            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1,  0, 0 },\n+                { -1,  1, 0 },\n+                {  0, -1, 1 }\n+        }, new double[] { 1, 1, 1});\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+\n+    }\n+\n+    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n+        double epsilon = 1.0e-7;\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  2,  1,   0,  4,       0, 0 },\n+                { -4, -2,   3, -7,       0, 0 },\n+                {  4,  1,  -2,  8,       0, 0 },\n+                {  0, -3, -12, -1,       0, 0 },\n+                {  0,  0,   0,  0, epsilon, 1 },\n+                {  0,  0,   0,  0,       1, 1 }\n+        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+\n+    }\n+\n+    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1, 2, -3 },\n+                {  2, 1,  3 },\n+                { -3, 0, -9 }\n+        }, new double[] { 1, 1, 1 });\n+ \n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        assertTrue(Math.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n+        try {\n+            optimizer.getCovariances();\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+    }\n+\n+    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem1 = new LinearProblem(new double[][] {\n+                { 10.0, 7.0,  8.0,  7.0 },\n+                {  7.0, 5.0,  6.0,  5.0 },\n+                {  8.0, 6.0, 10.0,  9.0 },\n+                {  7.0, 5.0,  9.0, 10.0 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum1 =\n+            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n+\n+        LinearProblem problem2 = new LinearProblem(new double[][] {\n+                { 10.00, 7.00, 8.10, 7.20 },\n+                {  7.08, 5.04, 6.00, 5.00 },\n+                {  8.00, 5.98, 9.89, 9.00 },\n+                {  6.99, 4.99, 9.00, 9.98 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        VectorialPointValuePair optimum2 =\n+            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n+        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n+        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n+        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 3.0, 2.0,  0.0, 0.0 },\n+                { 0.0, 1.0, -1.0, 1.0 },\n+                { 2.0, 0.0,  1.0, 0.0 }\n+        }, new double[] { 7.0, 3.0, 5.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+                new double[] { 7, 6, 5, 4 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n+                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n+                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n+                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n+                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n+       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 2, 2, 2, 2, 2, 2 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n+        assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n+        assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n+        assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n+\n+    }\n+\n+    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 5.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+                               new double[] { 1, 1 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n+        assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n+\n+    }\n+\n+    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 4.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n+        assertTrue(optimizer.getRMS() > 0.1);\n+\n+    }\n+\n+    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+\n+        try {\n+            optimizer.optimize(problem, problem.target,\n+                               new double[] { 1 },\n+                               new double[] { 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException oe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        try {\n+            optimizer.optimize(problem, new double[] { 1 },\n+                               new double[] { 1 },\n+                               new double[] { 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (FunctionEvaluationException oe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+    }\n+\n+    public void testControlParameters() {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);\n+        checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);\n+        checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);\n+        circle.addPoint(300, -300);\n+        checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);\n+    }\n+\n+    private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,\n+                               double initialStepBoundFactor, int maxCostEval,\n+                               double costRelativeTolerance, double parRelativeTolerance,\n+                               double orthoTolerance, boolean shouldFail) {\n+        try {\n+            LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+            optimizer.setInitialStepBoundFactor(initialStepBoundFactor);\n+            optimizer.setMaxIterations(maxCostEval);\n+            optimizer.setCostRelativeTolerance(costRelativeTolerance);\n+            optimizer.setParRelativeTolerance(parRelativeTolerance);\n+            optimizer.setOrthoTolerance(orthoTolerance);\n+            optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+            assertTrue(! shouldFail);\n+        } catch (OptimizationException ee) {\n+            assertTrue(shouldFail);\n+        } catch (FunctionEvaluationException ee) {\n+            assertTrue(shouldFail);\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+    }\n+\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+        assertTrue(optimizer.getEvaluations() < 10);\n+        assertTrue(optimizer.getJacobianEvaluations() < 10);\n+        double rms = optimizer.getRMS();\n+        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n+        assertEquals(96.07590211815305, center.x,      1.0e-10);\n+        assertEquals(48.13516790438953, center.y,      1.0e-10);\n+        double[][] cov = optimizer.getCovariances();\n+        assertEquals(1.839, cov[0][0], 0.001);\n+        assertEquals(0.731, cov[0][1], 0.001);\n+        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        assertEquals(0.786, cov[1][1], 0.001);\n+        double[] errors = optimizer.guessParametersErrors();\n+        assertEquals(1.384, errors[0], 0.001);\n+        assertEquals(0.905, errors[1], 0.001);\n+\n+        // add perfect measurements and check errors are reduced\n+        double  r = circle.getRadius(center);\n+        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n+            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n+        }\n+        double[] target = new double[circle.getN()];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[circle.getN()];\n+        Arrays.fill(weights, 2.0);\n+        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n+        cov = optimizer.getCovariances();\n+        assertEquals(0.0016, cov[0][0], 0.001);\n+        assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n+        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        assertEquals(0.0016, cov[1][1], 0.001);\n+        errors = optimizer.guessParametersErrors();\n+        assertEquals(0.002, errors[0], 0.001);\n+        assertEquals(0.002, errors[1], 0.001);\n+\n+    }\n+\n+    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        double[][] points = new double[][] {\n+                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+        };\n+        double[] target = new double[points.length];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[points.length];\n+        Arrays.fill(weights, 2.0);\n+        for (int i = 0; i < points.length; ++i) {\n+            circle.addPoint(points[i][0], points[i][1]);\n+        }\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-10, 1.0e-10));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        assertTrue(optimizer.getEvaluations() < 25);\n+        assertTrue(optimizer.getJacobianEvaluations() < 20);\n+        assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n+        assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n+        assertEquals(-0.151738,  center.x,      1.0e-6);\n+        assertEquals( 0.2075001, center.y,      1.0e-6);\n+    }\n+\n+    public void testMath199() throws FunctionEvaluationException {\n+        try {\n+            QuadraticProblem problem = new QuadraticProblem();\n+            problem.addPoint (0, -3.182591015485607);\n+            problem.addPoint (1, -2.5581184967730577);\n+            problem.addPoint (2, -2.1488478161387325);\n+            problem.addPoint (3, -1.9122489313410047);\n+            problem.addPoint (4, 1.7785661310051026);\n+            new LevenbergMarquardtOptimizer().optimize(problem,\n+                                                       new double[] { 0, 0, 0, 0, 0 },\n+                                                       new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },\n+                                                       new double[] { 0, 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n+\n+        private static final long serialVersionUID = 703247177355019415L;\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new BlockRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        public double[] value(double[] variables) {\n+            return factors.operate(variables);\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = 556396458721526234L;\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {\n+\n+        private static final long serialVersionUID = -4711170319243817874L;\n+\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public int getN() {\n+            return points.size();\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        private double[][] jacobian(double[] point) {\n+\n+            int n = points.size();\n+            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+\n+            // gradient of the optimal radius\n+            double dRdX = 0;\n+            double dRdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dRdX += (center.x - pk.x) / dk;\n+                dRdY += (center.y - pk.y) / dk;\n+            }\n+            dRdX /= n;\n+            dRdY /= n;\n+\n+            // jacobian of the radius residuals\n+            double[][] jacobian = new double[n][2];\n+            for (int i = 0; i < n; ++i) {\n+                Point2D.Double pi = points.get(i);\n+                double di   = pi.distance(center);\n+                jacobian[i][0] = (center.x - pi.x) / di - dRdX;    \n+                jacobian[i][1] = (center.y - pi.y) / di - dRdY;    \n+            }\n+\n+            return jacobian;\n+\n+        }\n+\n+        public double[] value(double[] variables)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double[] residuals = new double[points.size()];\n+            for (int i = 0; i < residuals.length; ++i) {\n+                residuals[i] = points.get(i).distance(center) - radius;\n+            }\n+\n+            return residuals;\n+\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -4340046230875165095L;\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n+\n+        private static final long serialVersionUID = 7072187082052755854L;\n+        private List<Double> x;\n+        private List<Double> y;\n+\n+        public QuadraticProblem() {\n+            x = new ArrayList<Double>();\n+            y = new ArrayList<Double>();\n+        }\n+\n+        public void addPoint(double x, double y) {\n+            this.x.add(x);\n+            this.y.add(y);\n+        }\n+\n+        private double[][] jacobian(double[] variables) {\n+            double[][] jacobian = new double[x.size()][3];\n+            for (int i = 0; i < jacobian.length; ++i) {\n+                jacobian[i][0] = x.get(i) * x.get(i);\n+                jacobian[i][1] = x.get(i);\n+                jacobian[i][2] = 1.0;\n+            }\n+            return jacobian;\n+        }\n+\n+        public double[] value(double[] variables) {\n+            double[] values = new double[x.size()];\n+            for (int i = 0; i < values.length; ++i) {\n+                values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];\n+            }\n+            return values;\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -8673650298627399464L;\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(LevenbergMarquardtOptimizerTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class MinpackTest extends TestCase {\n+\n+  public MinpackTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testMinpackLinearFullRank() {\n+    minpackTest(new LinearFullRankFunction(10, 5, 1.0,\n+                                           5.0, 2.23606797749979), false);\n+    minpackTest(new LinearFullRankFunction(50, 5, 1.0,\n+                                           8.06225774829855, 6.70820393249937), false);\n+  }\n+\n+  public void testMinpackLinearRank1() {\n+    minpackTest(new LinearRank1Function(10, 5, 1.0,\n+                                        291.521868819476, 1.4638501094228), false);\n+    minpackTest(new LinearRank1Function(50, 5, 1.0,\n+                                        3101.60039334535, 3.48263016573496), false);\n+  }\n+\n+  public void testMinpackLinearRank1ZeroColsAndRows() {\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);\n+  }\n+\n+  public void testMinpackRosenbrok() {\n+    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n+                                       Math.sqrt(24.2)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n+                                       Math.sqrt(1795769.0)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n+                                       11.0 * Math.sqrt(169000121.0)), false);\n+  }\n+\n+  public void testMinpackHelicalValley() {\n+    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },\n+                                          50.0), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },\n+                                          102.95630140987), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n+                                          991.261822123701), false);\n+  }\n+    \n+  public void testMinpackPowellSingular() {\n+    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n+                                           14.6628782986152), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },\n+                                           1270.9838708654), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n+                                           126887.903284750), false);\n+  }\n+    \n+  public void testMinpackFreudensteinRoth() {\n+    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n+                                             20.0124960961895, 6.99887517584575,\n+                                             new double[] {\n+                                               11.4124844654993,\n+                                               -0.896827913731509\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n+                                             12432.833948863, 6.9988751744895,\n+                                             new double[] {\n+                                               11.4130046614746,\n+                                               -0.896796038685958\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n+                                             11426454.595762, 6.99887517242903,\n+                                             new double[] {\n+                                               11.4127817857886,\n+                                               -0.89680510749204\n+                                             }), false);\n+  }\n+    \n+  public void testMinpackBard() {\n+    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n+                                 new double[] {\n+                                   0.0824105765758334,\n+                                   1.1330366534715,\n+                                   2.34369463894115\n+                                 }), false);\n+    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,\n+                                 new double[] {\n+                                   0.840666673818329,\n+                                   -158848033.259565,\n+                                   -164378671.653535\n+                                 }), false);\n+    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,\n+                                 new double[] {\n+                                   0.840666673867645,\n+                                   -158946167.205518,\n+                                   -164464906.857771\n+                                 }), false);\n+  }\n+    \n+  public void testMinpackKowalikOsborne() {\n+    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n+                                           0.0728915102882945,\n+                                           0.017535837721129,\n+                                           new double[] {\n+                                             0.192807810476249,\n+                                             0.191262653354071,\n+                                             0.123052801046931,\n+                                             0.136053221150517\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },\n+                                           2.97937007555202,\n+                                           0.032052192917937,\n+                                           new double[] {\n+                                             728675.473768287,\n+                                             -14.0758803129393,\n+                                             -32977797.7841797,\n+                                             -20571594.1977912\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },\n+                                           29.9590617016037,\n+                                           0.0175364017658228,\n+                                           new double[] {\n+                                             0.192948328597594,\n+                                             0.188053165007911,\n+                                             0.122430604321144,\n+                                             0.134575665392506\n+                                           }), false);\n+  }\n+    \n+  public void testMinpackMeyer() {\n+    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n+                                  41153.4665543031, 9.37794514651874,\n+                                  new double[] {\n+                                    0.00560963647102661,\n+                                    6181.34634628659,\n+                                    345.223634624144\n+                                  }), false);\n+    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },\n+                                  4168216.89130846, 792.917871779501,\n+                                  new double[] {\n+                                    1.42367074157994e-11,\n+                                    33695.7133432541,\n+                                    901.268527953801\n+                                  }), true);\n+  }\n+    \n+  public void testMinpackWatson() {\n+  \n+    minpackTest(new WatsonFunction(6, 0.0,\n+                                   5.47722557505166, 0.0478295939097601,\n+                                   new double[] {\n+                                     -0.0157249615083782, 1.01243488232965,\n+                                     -0.232991722387673,  1.26043101102818,\n+                                     -1.51373031394421,   0.99299727291842\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 10.0,\n+                                   6433.12578950026, 0.0478295939096951,\n+                                   new double[] {\n+                                     -0.0157251901386677, 1.01243485860105,\n+                                     -0.232991545843829,  1.26042932089163,\n+                                     -1.51372776706575,   0.99299573426328\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 100.0,\n+                                   674256.040605213, 0.047829593911544,\n+                                   new double[] {\n+                                    -0.0157247019712586, 1.01243490925658,\n+                                    -0.232991922761641,  1.26043292929555,\n+                                    -1.51373320452707,   0.99299901922322\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(9, 0.0,\n+                                   5.47722557505166, 0.00118311459212420,\n+                                   new double[] {\n+                                    -0.153070644166722e-4, 0.999789703934597,\n+                                     0.0147639634910978,   0.146342330145992,\n+                                     1.00082109454817,    -2.61773112070507,\n+                                     4.10440313943354,    -3.14361226236241,\n+                                     1.05262640378759\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 10.0,\n+                                   12088.127069307, 0.00118311459212513,\n+                                   new double[] {\n+                                   -0.153071334849279e-4, 0.999789703941234,\n+                                    0.0147639629786217,   0.146342334818836,\n+                                    1.00082107321386,    -2.61773107084722,\n+                                    4.10440307655564,    -3.14361222178686,\n+                                    1.05262639322589\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 100.0,\n+                                   1269109.29043834, 0.00118311459212384,\n+                                   new double[] {\n+                                    -0.153069523352176e-4, 0.999789703958371,\n+                                     0.0147639625185392,   0.146342341096326,\n+                                     1.00082104729164,    -2.61773101573645,\n+                                     4.10440301427286,    -3.14361218602503,\n+                                     1.05262638516774\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(12, 0.0,\n+                                   5.47722557505166, 0.217310402535861e-4,\n+                                   new double[] {\n+                                    -0.660266001396382e-8, 1.00000164411833,\n+                                    -0.000563932146980154, 0.347820540050756,\n+                                    -0.156731500244233,    1.05281515825593,\n+                                    -3.24727109519451,     7.2884347837505,\n+                                   -10.271848098614,       9.07411353715783,\n+                                    -4.54137541918194,     1.01201187975044\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 10.0,\n+                                   19220.7589790951, 0.217310402518509e-4,\n+                                   new double[] {\n+                                    -0.663710223017410e-8, 1.00000164411787,\n+                                    -0.000563932208347327, 0.347820540486998,\n+                                    -0.156731503955652,    1.05281517654573,\n+                                    -3.2472711515214,      7.28843489430665,\n+                                   -10.2718482369638,      9.07411364383733,\n+                                    -4.54137546533666,     1.01201188830857\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 100.0,\n+                                   2018918.04462367, 0.217310402539845e-4,\n+                                   new double[] {\n+                                    -0.663806046485249e-8, 1.00000164411786,\n+                                    -0.000563932210324959, 0.347820540503588,\n+                                    -0.156731504091375,    1.05281517718031,\n+                                    -3.24727115337025,     7.28843489775302,\n+                                   -10.2718482410813,      9.07411364688464,\n+                                    -4.54137546660822,     1.0120118885369\n+                                   }), false);\n+\n+  }\n+    \n+  public void testMinpackBox3Dimensional() {\n+    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n+                                            32.1115837449572), false);\n+  }\n+    \n+  public void testMinpackJennrichSampson() {\n+    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n+                                            64.5856498144943, 11.1517793413499,\n+                                            new double[] {\n+                                             0.257819926636811, 0.257829976764542\n+                                            }), false);\n+  }\n+\n+  public void testMinpackBrownDennis() {\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 25.0, 5.0, -5.0, -1.0 },\n+                                        2815.43839161816, 292.954288244866,\n+                                        new double[] {\n+                                         -11.59125141003, 13.2024883984741,\n+                                         -0.403574643314272, 0.236736269844604\n+                                        }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 250.0, 50.0, -50.0, -10.0 },\n+                                        555073.354173069, 292.954270581415,\n+                                        new double[] {\n+                                         -11.5959274272203, 13.2041866926242,\n+                                         -0.403417362841545, 0.236771143410386\n+                                       }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },\n+                                        61211252.2338581, 292.954306151134,\n+                                        new double[] {\n+                                         -11.5902596937374, 13.2020628854665,\n+                                         -0.403688070279258, 0.236665033746463\n+                                        }), false);\n+  }\n+    \n+  public void testMinpackChebyquad() {\n+    minpackTest(new ChebyquadFunction(1, 8, 1.0,\n+                                      1.88623796907732, 1.88623796907732,\n+                                      new double[] { 0.5 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 10.0,\n+                                      5383344372.34005, 1.88424820499951,\n+                                      new double[] { 0.9817314924684 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 100.0,\n+                                      0.118088726698392e19, 1.88424820499347,\n+                                      new double[] { 0.9817314852934 }), false);\n+    minpackTest(new ChebyquadFunction(8, 8, 1.0,\n+                                      0.196513862833975, 0.0593032355046727,\n+                                      new double[] {\n+                                        0.0431536648587336, 0.193091637843267,\n+                                        0.266328593812698,  0.499999334628884,\n+                                        0.500000665371116,  0.733671406187302,\n+                                        0.806908362156733,  0.956846335141266\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(9, 9, 1.0,\n+                                      0.16994993465202, 0.0,\n+                                      new double[] {\n+                                        0.0442053461357828, 0.199490672309881,\n+                                        0.23561910847106,   0.416046907892598,\n+                                        0.5,                0.583953092107402,\n+                                        0.764380891528940,  0.800509327690119,\n+                                        0.955794653864217\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(10, 10, 1.0,\n+                                      0.183747831178711, 0.0806471004038253,\n+                                      new double[] {\n+                                        0.0596202671753563, 0.166708783805937,\n+                                        0.239171018813509,  0.398885290346268,\n+                                        0.398883667870681,  0.601116332129320,\n+                                        0.60111470965373,   0.760828981186491,\n+                                        0.833291216194063,  0.940379732824644\n+                                      }), false);\n+  }\n+    \n+  public void testMinpackBrownAlmostLinear() {\n+    minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n+                                              16.5302162063499, 0.0,\n+                                              new double[] {\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 1.20569696650138\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(10, 5.0,\n+                                              9765624.00089211, 0.0,\n+                                              new double[] {\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 1.20569696650135\n+                                              }), false);  \n+    minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n+                                              0.9765625e17, 0.0,\n+                                              new double[] {\n+                                                1.0, 1.0, 1.0, 1.0, 1.0,\n+                                                1.0, 1.0, 1.0, 1.0, 1.0\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(30, 0.5,\n+                                              83.476044467848, 0.0,\n+                                              new double[] {\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 1.06737350671578\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(40, 0.5,\n+                                              128.026364472323, 0.0,\n+                                              new double[] {\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                0.999999999999121\n+                                              }), false);\n+    }\n+    \n+  public void testMinpackOsborne1() {\n+      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n+                                       0.937564021037838, 0.00739249260904843,\n+                                       new double[] {\n+                                         0.375410049244025, 1.93584654543108,\n+                                        -1.46468676748716, 0.0128675339110439,\n+                                         0.0221227011813076\n+                                       }), false);\n+    }\n+    \n+  public void testMinpackOsborne2() {\n+      \n+    minpackTest(new Osborne2Function(new double[] {\n+                                       1.3, 0.65, 0.65, 0.7, 0.6,\n+                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n+                                     },\n+                                     1.44686540984712, 0.20034404483314,\n+                                     new double[] {\n+                                       1.30997663810096,  0.43155248076,\n+                                       0.633661261602859, 0.599428560991695,\n+                                       0.754179768272449, 0.904300082378518,\n+                                       1.36579949521007, 4.82373199748107,\n+                                       2.39868475104871, 4.56887554791452,\n+                                       5.67534206273052\n+                                     }), false);\n+  }\n+\n+  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n+      LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+      optimizer.setMaxIterations(100 * (function.getN() + 1));\n+      optimizer.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+      optimizer.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+      optimizer.setOrthoTolerance(2.22044604926e-16);\n+//      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n+      try {\n+          VectorialPointValuePair optimum =\n+              optimizer.optimize(function,\n+                                 function.getTarget(), function.getWeight(),\n+                                 function.getStartPoint());\n+          assertFalse(exceptionExpected);\n+          assertTrue(function.checkTheoreticalMinCost(optimizer.getRMS()));\n+          assertTrue(function.checkTheoreticalMinParams(optimum));\n+      } catch (OptimizationException lsse) {\n+          assertTrue(exceptionExpected);\n+      } catch (FunctionEvaluationException fe) {\n+          assertTrue(exceptionExpected);\n+      }\n+  }\n+\n+  private static abstract class MinpackFunction\n+      implements DifferentiableMultivariateVectorialFunction, Serializable {\n+ \n+      private static final long serialVersionUID = -6209760235478794233L;\n+      protected int      n;\n+      protected int      m;\n+      protected double[] startParams;\n+      protected double   theoreticalMinCost;\n+      protected double[] theoreticalMinParams;\n+      protected double   costAccuracy;\n+      protected double   paramsAccuracy;\n+\n+      protected MinpackFunction(int m, double[] startParams,\n+                                double theoreticalMinCost, double[] theoreticalMinParams) {\n+          this.m = m;\n+          this.n = startParams.length;\n+          this.startParams          = startParams.clone();\n+          this.theoreticalMinCost   = theoreticalMinCost;\n+          this.theoreticalMinParams = theoreticalMinParams;\n+          this.costAccuracy         = 1.0e-8;\n+          this.paramsAccuracy       = 1.0e-5;\n+      }\n+\n+      protected static double[] buildArray(int n, double x) {\n+          double[] array = new double[n];\n+          Arrays.fill(array, x);\n+          return array;\n+      }\n+\n+      public double[] getTarget() {\n+          return buildArray(m, 0.0);\n+      }\n+\n+      public double[] getWeight() {\n+          return buildArray(m, 1.0);\n+      }\n+\n+      public double[] getStartPoint() {\n+          return startParams.clone();\n+      }\n+\n+      protected void setCostAccuracy(double costAccuracy) {\n+          this.costAccuracy = costAccuracy;\n+      }\n+\n+      protected void setParamsAccuracy(double paramsAccuracy) {\n+          this.paramsAccuracy = paramsAccuracy;\n+      }\n+\n+      public int getN() {\n+          return startParams.length;\n+      }\n+\n+      public boolean checkTheoreticalMinCost(double rms) {\n+          double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n+          return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n+      }\n+\n+      public boolean checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n+          double[] params = optimum.getPointRef();\n+          if (theoreticalMinParams != null) {\n+              for (int i = 0; i < theoreticalMinParams.length; ++i) {\n+                  double mi = theoreticalMinParams[i];\n+                  double vi = params[i];\n+                  if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n+                      return false;\n+                  }\n+              }\n+          }\n+          return true;\n+      }\n+\n+      public MultivariateMatrixFunction jacobian() {\n+          return new MultivariateMatrixFunction() {\n+            private static final long serialVersionUID = -2435076097232923678L;\n+            public double[][] value(double[] point) {\n+                  return jacobian(point);\n+              }\n+          };\n+      }\n+\n+      public abstract double[][] jacobian(double[] variables);\n+\n+      public abstract double[] value(double[] variables);\n+\n+  }\n+\n+  private static class LinearFullRankFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -9030323226268039536L;\n+\n+    public LinearFullRankFunction(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalMinCost,\n+            buildArray(n, -1.0));\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double t = 2.0 / m;\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i == j) ? (1 - t) : -t;\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += variables[i];\n+      }\n+      double t  = 1 + 2 * sum / m;\n+      double[] f = new double[m];\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = variables[i] - t;\n+      }\n+      Arrays.fill(f, n, m, -t);\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1Function extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 8494863245104608300L;\n+\n+    public LinearRank1Function(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalMinCost, null);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i + 1) * (j + 1);\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += (i + 1) * variables[i];\n+      }\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = (i + 1) * sum - 1;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -3316653043091995018L;\n+\n+    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n+      super(m, buildArray(n, x0),\n+            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n+            null);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        jacobian[i][0] = 0;\n+        for (int j = 1; j < (n - 1); ++j) {\n+          if (i == 0) {\n+            jacobian[i][j] = 0;\n+          } else if (i != (m - 1)) {\n+            jacobian[i][j] = i * (j + 1);\n+          } else {\n+            jacobian[i][j] = 0;\n+          }\n+        }\n+        jacobian[i][n - 1] = 0;\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 1; i < (n - 1); ++i) {\n+        sum += (i + 1) * variables[i];\n+      }\n+      for (int i = 0; i < (m - 1); ++i) {\n+        f[i] = i * sum - 1;\n+      }\n+      f[m - 1] = -1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class RosenbrockFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 2893438180956569134L;\n+\n+    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {\n+      super(2, startParams, 0.0, buildArray(2, 1.0));\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double x1 = variables[0];\n+      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n+    }\n+\n+  }\n+\n+  private static class HelicalValleyFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 220613787843200102L;\n+\n+    public HelicalValleyFunction(double[] startParams,\n+                                 double theoreticalStartCost) {\n+      super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double tmpSquare = x1 * x1 + x2 * x2;\n+      double tmp1 = twoPi * tmpSquare;\n+      double tmp2 = Math.sqrt(tmpSquare);\n+      return new double[][] {\n+        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n+        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n+        { 0, 0, 1 }\n+      };\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double tmp1;\n+      if (x1 == 0) {\n+        tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n+      } else {\n+        tmp1 = Math.atan(x2 / x1) / twoPi;\n+        if (x1 < 0) {\n+          tmp1 += 0.5;\n+        }\n+      }\n+      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n+      return new double[] {\n+        10.0 * (x3 - 10 * tmp1),\n+        10.0 * (tmp2 - 1),\n+        x3\n+      };\n+    }\n+\n+    private static final double twoPi = 2.0 * Math.PI;\n+\n+  }\n+\n+  private static class PowellSingularFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 7298364171208142405L;\n+\n+    public PowellSingularFunction(double[] startParams,\n+                                  double theoreticalStartCost) {\n+      super(4, startParams, 0.0, buildArray(4, 0.0));\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n+      return new double[][] {\n+        { 1, 10, 0, 0 },\n+        { 0, 0, sqrt5, -sqrt5 },\n+        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },\n+        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }\n+      };\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n+      return new double[] {\n+        x1 + 10 * x2,\n+        sqrt5 * (x3 - x4),\n+        (x2 - 2 * x3) * (x2 - 2 * x3),\n+        sqrt10 * (x1 - x4) * (x1 - x4)\n+      };\n+    }\n+\n+    private static final double sqrt5  = Math.sqrt( 5.0);\n+    private static final double sqrt10 = Math.sqrt(10.0);\n+\n+  }\n+\n+  private static class FreudensteinRothFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 2892404999344244214L;\n+\n+    public FreudensteinRothFunction(double[] startParams,\n+                                    double theoreticalStartCost,\n+                                    double theoreticalMinCost,\n+                                    double[] theoreticalMinParams) {\n+      super(2, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double x2 = variables[1];\n+      return new double[][] {\n+        { 1, x2 * (10 - 3 * x2) -  2 },\n+        { 1, x2 * ( 2 + 3 * x2) - 14, }\n+      };\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      return new double[] {\n+       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,\n+       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2\n+      };\n+    }\n+\n+  }\n+\n+  private static class BardFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 5990442612572087668L;\n+\n+    public BardFunction(double x0,\n+                        double theoreticalStartCost,\n+                        double theoreticalMinCost,\n+                        double[] theoreticalMinParams) {\n+      super(15, buildArray(3, x0), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i  + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        double tmp4 = x2 * tmp2 + x3 * tmp3;\n+        tmp4 *= tmp4;\n+        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.14, 0.18, 0.22, 0.25, 0.29,\n+      0.32, 0.35, 0.39, 0.37, 0.58,\n+      0.73, 0.96, 1.34, 2.10, 4.39\n+    };\n+\n+  }\n+\n+  private static class KowalikOsborneFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -4867445739880495801L;\n+\n+    public KowalikOsborneFunction(double[] startParams,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost,\n+                                  double[] theoreticalMinParams) {\n+      super(11, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+      if (theoreticalStartCost > 20.0) {\n+        setCostAccuracy(2.0e-4);\n+        setParamsAccuracy(5.0e-3);\n+      }\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double   x4 = variables[3];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = v[i] * (v[i] + x3) + x4;\n+        double j1  = -v[i] * (v[i] + x2) / tmp;\n+        double j2  = -v[i] * x1 / tmp;\n+        double j3  = j1 * j2;\n+        double j4  = j3 / v[i];\n+        jacobian[i] = new double[] { j1, j2, j3, j4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] v = {\n+      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625\n+    };\n+\n+    private static final double[] y = {\n+      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,\n+      0.0456, 0.0342, 0.0323, 0.0235, 0.0246\n+    };\n+\n+  }\n+\n+  private static class MeyerFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -838060619150131027L;\n+\n+    public MeyerFunction(double[] startParams,\n+                         double theoreticalStartCost,\n+                         double theoreticalMinCost,\n+                         double[] theoreticalMinParams) {\n+      super(16, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+      if (theoreticalStartCost > 1.0e6) {\n+        setCostAccuracy(7.0e-3);\n+        setParamsAccuracy(2.0e-2);\n+      }\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 5.0 * (i + 1) + 45.0 + x3;\n+        double tmp1 = x2 / temp;\n+        double tmp2 = Math.exp(tmp1);\n+        double tmp3 = x1 * tmp2 / temp;\n+        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n+      }\n+     return f;\n+    }\n+\n+    private static final double[] y = {\n+      34780.0, 28610.0, 23650.0, 19630.0,\n+      16370.0, 13720.0, 11540.0,  9744.0,\n+       8261.0,  7030.0,  6005.0,  5147.0,\n+       4427.0,  3820.0,  3307.0,  2872.0                  \n+    };\n+\n+  }\n+\n+  private static class WatsonFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -9034759294980218927L;\n+\n+    public WatsonFunction(int n, double x0,\n+                          double theoreticalStartCost,\n+                          double theoreticalMinCost,\n+                          double[] theoreticalMinParams) {\n+      super(31, buildArray(n, x0), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+\n+      double[][] jacobian = new double[m][];\n+\n+      for (int i = 0; i < (m - 2); ++i) {\n+        double div = (i + 1) / 29.0;\n+        double s2  = 0.0;\n+        double dx  = 1.0;\n+        for (int j = 0; j < n; ++j) {\n+          s2 += dx * variables[j];\n+          dx *= div;\n+        }\n+        double temp= 2 * div * s2;\n+        dx = 1.0 / div;\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = dx * (j - temp);\n+          dx *= div;\n+        }\n+      }\n+\n+      jacobian[m - 2]    = new double[n];\n+      jacobian[m - 2][0] = 1;\n+\n+      jacobian[m - 1]   = new double[n];\n+      jacobian[m - 1][0]= -2 * variables[0];\n+      jacobian[m - 1][1]= 1;\n+\n+      return jacobian;\n+\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+     double[] f = new double[m];\n+     for (int i = 0; i < (m - 2); ++i) {\n+       double div = (i + 1) / 29.0;\n+       double s1 = 0;\n+       double dx = 1;\n+       for (int j = 1; j < n; ++j) {\n+         s1 += j * dx * variables[j];\n+         dx *= div;\n+       }\n+       double s2 =0;\n+       dx =1;\n+       for (int j = 0; j < n; ++j) {\n+         s2 += dx * variables[j];\n+         dx *= div;\n+       }\n+       f[i] = s1 - s2 * s2 - 1;\n+     }\n+\n+     double x1 = variables[0];\n+     double x2 = variables[1];\n+     f[m - 2] = x1;\n+     f[m - 1] = x2 - x1 * x1 - 1;\n+\n+     return f;\n+\n+    }\n+\n+  }\n+\n+  private static class Box3DimensionalFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 5511403858142574493L;\n+\n+    public Box3DimensionalFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost) {\n+      super(m, startParams, 0.0,\n+            new double[] { 1.0, 10.0, 1.0 });\n+   }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        jacobian[i] = new double[] {\n+          -tmp * Math.exp(-tmp * x1),\n+           tmp * Math.exp(-tmp * x2),\n+          Math.exp(-i - 1) - Math.exp(-tmp)\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n+             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class JennrichSampsonFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -2489165190443352947L;\n+\n+    public JennrichSampsonFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost,\n+                                   double theoreticalMinCost,\n+                                   double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double t = i + 1;\n+        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i + 1;\n+        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class BrownDennisFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 8340018645694243910L;\n+\n+    public BrownDennisFunction(int m, double[] startParams,\n+                               double theoreticalStartCost,\n+                               double theoreticalMinCost,\n+                               double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double   x4 = variables[3];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double ti   = Math.sin(temp);\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n+        jacobian[i] = new double[] {\n+          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n+        f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class ChebyquadFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -2394877275028008594L;\n+\n+    private static double[] buildChebyquadArray(int n, double factor) {\n+      double[] array = new double[n];\n+      double inv = factor / (n + 1);\n+      for (int i = 0; i < n; ++i) {\n+        array[i] = (i + 1) * inv;\n+      }\n+      return array;\n+    }\n+\n+    public ChebyquadFunction(int n, int m, double factor,\n+                             double theoreticalStartCost,\n+                             double theoreticalMinCost,\n+                             double[] theoreticalMinParams) {\n+      super(m, buildChebyquadArray(n, factor), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double dx = 1.0 / n;\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * variables[j] - 1;\n+        double temp = 2 * tmp2;\n+        double tmp3 = 0;\n+        double tmp4 = 2;\n+        for (int i = 0; i < m; ++i) {\n+          jacobian[i][j] = dx * tmp4;\n+          double ti = 4 * tmp2 + temp * tmp4 - tmp3;\n+          tmp3 = tmp4;\n+          tmp4 = ti;\n+          ti   = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+\n+      double[] f = new double[m];\n+\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * variables[j] - 1;\n+        double temp = 2 * tmp2;\n+        for (int i = 0; i < m; ++i) {\n+          f[i] += tmp2;\n+          double ti = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      double dx = 1.0 / n;\n+      boolean iev = false;\n+      for (int i = 0; i < m; ++i) {\n+        f[i] *= dx;\n+        if (iev) {\n+          f[i] += 1.0 / (i * (i + 2));\n+        }\n+        iev = ! iev;\n+      }\n+\n+      return f;\n+\n+    }\n+\n+  }\n+\n+  private static class BrownAlmostLinearFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 8239594490466964725L;\n+\n+    public BrownAlmostLinearFunction(int m, double factor,\n+                                     double theoreticalStartCost,\n+                                     double theoreticalMinCost,\n+                                     double[] theoreticalMinParams) {\n+      super(m, buildArray(m, factor), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        prod *= variables[j];\n+        for (int i = 0; i < n; ++i) {\n+          jacobian[i][j] = 1;\n+        }\n+        jacobian[j][j] = 2;\n+      }\n+\n+      for (int j = 0; j < n; ++j) {\n+        double temp = variables[j];\n+        if (temp == 0) {\n+          temp = 1;\n+          prod = 1;\n+          for (int k = 0; k < n; ++k) {\n+            if (k != j) {\n+              prod *= variables[k];\n+            }\n+          }\n+        }\n+        jacobian[n - 1][j] = prod / temp;\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double[] f = new double[m];\n+      double sum  = -(n + 1);\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        sum  += variables[j];\n+        prod *= variables[j];\n+      }\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = variables[i] + sum;\n+      }\n+      f[n - 1] = prod - 1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class Osborne1Function extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 4006743521149849494L;\n+\n+    public Osborne1Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(33, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double   x4 = variables[3];\n+      double   x5 = variables[4];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        jacobian[i] = new double[] {\n+          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n+      double x5 = variables[4];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,\n+      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,\n+      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406\n+    };\n+\n+  }\n+\n+  private static class Osborne2Function extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -8418268780389858746L;\n+\n+    public Osborne2Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(65, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    @Override\n+    public double[][] jacobian(double[] variables) {\n+      double   x01 = variables[0];\n+      double   x02 = variables[1];\n+      double   x03 = variables[2];\n+      double   x04 = variables[3];\n+      double   x05 = variables[4];\n+      double   x06 = variables[5];\n+      double   x07 = variables[6];\n+      double   x08 = variables[7];\n+      double   x09 = variables[8];\n+      double   x10 = variables[9];\n+      double   x11 = variables[10];\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        jacobian[i] = new double[] {\n+          -tmp1,\n+          -tmp2,\n+          -tmp3,\n+          -tmp4,\n+          temp * x01 * tmp1,\n+          x02 * (temp - x09) * (temp - x09) * tmp2,\n+          x03 * (temp - x10) * (temp - x10) * tmp3,\n+          x04 * (temp - x11) * (temp - x11) * tmp4,\n+          -2 * x02 * x06 * (temp - x09) * tmp2,\n+          -2 * x03 * x07 * (temp - x10) * tmp3,\n+          -2 * x04 * x08 * (temp - x11) * tmp4\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    @Override\n+    public double[] value(double[] variables) {\n+      double x01 = variables[0];\n+      double x02 = variables[1];\n+      double x03 = variables[2];\n+      double x04 = variables[3];\n+      double x05 = variables[4];\n+      double x06 = variables[5];\n+      double x07 = variables[6];\n+      double x08 = variables[7];\n+      double x09 = variables[8];\n+      double x10 = variables[9];\n+      double x11 = variables[10];\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      1.366, 1.191, 1.112, 1.013, 0.991,\n+      0.885, 0.831, 0.847, 0.786, 0.725,\n+      0.746, 0.679, 0.608, 0.655, 0.616,\n+      0.606, 0.602, 0.626, 0.651, 0.724,\n+      0.649, 0.649, 0.694, 0.644, 0.624,\n+      0.661, 0.612, 0.558, 0.533, 0.495,\n+      0.500, 0.423, 0.395, 0.375, 0.372,\n+      0.391, 0.396, 0.405, 0.428, 0.429,\n+      0.523, 0.562, 0.607, 0.653, 0.672,\n+      0.708, 0.633, 0.668, 0.645, 0.632,\n+      0.591, 0.559, 0.597, 0.625, 0.739,\n+      0.710, 0.729, 0.720, 0.636, 0.581,\n+      0.428, 0.292, 0.162, 0.098, 0.054\n+    };\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MinpackTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class NonLinearConjugateGradientOptimizerTest\n+extends TestCase {\n+\n+    public NonLinearConjugateGradientOptimizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0 });\n+        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(0.0, optimum.getValue(), 1.0e-10);\n+    }\n+\n+    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n+                              new double[] { 4.0, 6.0, 1.0 });\n+\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n+        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(0.0, optimum.getValue(), 1.0e-10);\n+\n+    }\n+\n+    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 2, 0, 0, 0, 0, 0 },\n+                { 0, 2, 0, 0, 0, 0 },\n+                { 0, 0, 2, 0, 0, 0 },\n+                { 0, 0, 0, 2, 0, 0 },\n+                { 0, 0, 0, 0, 2, 0 },\n+                { 0, 0, 0, 0, 0, 2 }\n+        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n+        for (int i = 0; i < problem.target.length; ++i) {\n+            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1,  0, 0 },\n+                { -1,  1, 0 },\n+                {  0, -1, 1 }\n+        }, new double[] { 1, 1, 1});\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n+        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+\n+    }\n+\n+    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n+        final double epsilon = 1.0e-7;\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  2,  1,   0,  4,       0, 0 },\n+                { -4, -2,   3, -7,       0, 0 },\n+                {  4,  1,  -2,  8,       0, 0 },\n+                {  0, -3, -12, -1,       0, 0 },\n+                {  0,  0,   0,  0, epsilon, 1 },\n+                {  0,  0,   0,  0,       1, 1 }\n+        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n+\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setPreconditioner(new Preconditioner() {\n+            public double[] precondition(double[] point, double[] r) {\n+                double[] d = r.clone();\n+                d[0] /=  72.0;\n+                d[1] /=  30.0;\n+                d[2] /= 314.0;\n+                d[3] /= 260.0;\n+                d[4] /= 2 * (1 + epsilon * epsilon);\n+                d[5] /= 4.0;\n+                return d;\n+            }\n+        });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n+\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+\n+    }\n+\n+    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1, 2, -3 },\n+                {  2, 1,  3 },\n+                { -3, 0, -9 }\n+        }, new double[] { 1, 1, 1 });\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+                optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n+        assertTrue(optimum.getValue() > 0.5);\n+    }\n+\n+    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem1 = new LinearProblem(new double[][] {\n+                { 10.0, 7.0,  8.0,  7.0 },\n+                {  7.0, 5.0,  6.0,  5.0 },\n+                {  8.0, 6.0, 10.0,  9.0 },\n+                {  7.0, 5.0,  9.0, 10.0 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n+        BrentSolver solver = new BrentSolver();\n+        solver.setAbsoluteAccuracy(1.0e-15);\n+        solver.setRelativeAccuracy(1.0e-15);\n+        optimizer.setLineSearchSolver(solver);\n+        RealPointValuePair optimum1 =\n+            optimizer.optimize(problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n+        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-5);\n+        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-5);\n+        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-5);\n+        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-5);\n+\n+        LinearProblem problem2 = new LinearProblem(new double[][] {\n+                { 10.00, 7.00, 8.10, 7.20 },\n+                {  7.08, 5.04, 6.00, 5.00 },\n+                {  8.00, 5.98, 9.89, 9.00 },\n+                {  6.99, 4.99, 9.00, 9.98 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        RealPointValuePair optimum2 =\n+            optimizer.optimize(problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n+        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);\n+        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);\n+        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);\n+        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersSimple()\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 3.0, 2.0,  0.0, 0.0 },\n+                { 0.0, 1.0, -1.0, 1.0 },\n+                { 2.0, 0.0,  1.0, 0.0 }\n+        }, new double[] { 7.0, 3.0, 5.0 });\n+\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n+        assertEquals(0, optimum.getValue(), 1.0e-10);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersUnsorted()\n+        throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n+                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n+                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n+                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n+                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n+        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n+        assertEquals(0, optimum.getValue(), 1.0e-10);\n+    }\n+\n+    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 5.0 });\n+\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n+        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n+        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n+\n+    }\n+\n+    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 4.0 });\n+\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n+        assertTrue(optimum.getValue() > 0.1);\n+\n+    }\n+\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        NonLinearConjugateGradientOptimizer optimizer =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));\n+        BrentSolver solver = new BrentSolver();\n+        solver.setAbsoluteAccuracy(1.0e-13);\n+        solver.setRelativeAccuracy(1.0e-15);\n+        optimizer.setLineSearchSolver(solver);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n+        assertEquals(96.075902096, center.x, 1.0e-8);\n+        assertEquals(48.135167894, center.y, 1.0e-8);\n+    }\n+\n+    private static class LinearProblem implements DifferentiableMultivariateRealFunction, Serializable {\n+\n+        private static final long serialVersionUID = 703247177355019415L;\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new BlockRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        private double[] gradient(double[] point) {\n+            double[] r = factors.operate(point);\n+            for (int i = 0; i < r.length; ++i) {\n+                r[i] -= target[i];\n+            }\n+            double[] p = factors.transpose().operate(r);\n+            for (int i = 0; i < p.length; ++i) {\n+                p[i] *= 2;\n+            }\n+            return p;\n+        }\n+\n+        public double value(double[] variables) throws FunctionEvaluationException {\n+            double[] y = factors.operate(variables);\n+            double sum = 0;\n+            for (int i = 0; i < y.length; ++i) {\n+                double ri = y[i] - target[i];\n+                sum += ri * ri;\n+            }\n+            return sum;\n+        }\n+\n+        public MultivariateVectorialFunction gradient() {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 2621997811350805819L;\n+                public double[] value(double[] point) {\n+                    return gradient(point);\n+                }\n+            };\n+        }\n+\n+        public MultivariateRealFunction partialDerivative(final int k) {\n+            return new MultivariateRealFunction() {\n+                private static final long serialVersionUID = -6186178619133562011L;\n+                public double value(double[] point) {\n+                    return gradient(point)[k];\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateRealFunction, Serializable {\n+\n+        private static final long serialVersionUID = -4711170319243817874L;\n+\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        private double[] gradient(double[] point) {\n+\n+            // optimal radius\n+            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+            double radius = getRadius(center);\n+\n+            // gradient of the sum of squared residuals\n+            double dJdX = 0;\n+            double dJdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dJdX += (center.x - pk.x) * (dk - radius) / dk;\n+                dJdY += (center.y - pk.y) * (dk - radius) / dk;\n+            }\n+            dJdX *= 2;\n+            dJdY *= 2;\n+\n+            return new double[] { dJdX, dJdY };\n+\n+        }\n+\n+        public double value(double[] variables)\n+                throws IllegalArgumentException, FunctionEvaluationException {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double sum = 0;\n+            for (Point2D.Double point : points) {\n+                double di = point.distance(center) - radius;\n+                sum += di * di;\n+            }\n+\n+            return sum;\n+\n+        }\n+\n+        public MultivariateVectorialFunction gradient() {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 3174909643301201710L;\n+                public double[] value(double[] point) {\n+                    return gradient(point);\n+                }\n+            };\n+        }\n+\n+        public MultivariateRealFunction partialDerivative(final int k) {\n+            return new MultivariateRealFunction() {\n+                private static final long serialVersionUID = 3073956364104833888L;\n+                public double value(double[] point) {\n+                    return gradient(point)[k];\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(NonLinearConjugateGradientOptimizerTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.junit.Test;\n+\n+public class SimplexSolverTest {\n+\n+    @Test\n+    public void testMath272() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));\n+        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        \n+        assertEquals(0.0, solution.getPoint()[0], .0000001);\n+        assertEquals(1.0, solution.getPoint()[1], .0000001);\n+        assertEquals(1.0, solution.getPoint()[2], .0000001);\n+        assertEquals(3.0, solution.getValue(), .0000001);\n+      }\n+\n+    @Test\n+    public void testSimplexSolver() throws OptimizationException {\n+        LinearObjectiveFunction f =\n+            new LinearObjectiveFunction(new double[] { 15, 10 }, 7);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(2.0, solution.getPoint()[0], 0.0);\n+        assertEquals(2.0, solution.getPoint()[1], 0.0);\n+        assertEquals(57.0, solution.getValue(), 0.0);\n+    }\n+\n+    @Test\n+    public void testSingleVariableAndConstraint() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(10.0, solution.getPoint()[0], 0.0);\n+        assertEquals(30.0, solution.getValue(), 0.0);\n+    }\n+    \n+    /**\n+     * With no artificial variables needed (no equals and no greater than\n+     * constraints) we can go straight to Phase 2.\n+     */\n+    @Test\n+    public void testModelWithNoArtificialVars() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(2.0, solution.getPoint()[0], 0.0);\n+        assertEquals(2.0, solution.getPoint()[1], 0.0);\n+        assertEquals(50.0, solution.getValue(), 0.0);\n+    }\n+\n+    @Test\n+    public void testMinimization() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));\n+        constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        assertEquals(4.0, solution.getPoint()[0], 0.0);\n+        assertEquals(0.0, solution.getPoint()[1], 0.0);\n+        assertEquals(-13.0, solution.getValue(), 0.0);\n+    }\n+\n+    @Test\n+    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));\n+        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(-2.0, solution.getPoint()[0], 0.0);\n+        assertEquals(8.0, solution.getPoint()[1], 0.0);\n+        assertEquals(12.0, solution.getValue(), 0.0);\n+    }\n+\n+    @Test(expected = NoFeasibleSolutionException.class)\n+    public void testInfeasibleSolution() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));\n+        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+    }\n+\n+    @Test(expected = UnboundedSolutionException.class)\n+    public void testUnboundedSolution() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+    }\n+\n+    @Test\n+    public void testRestrictVariablesToNonNegative() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));\n+        constraints.add(new LinearConstraint(new double[] {    12,   45,   7,  56,   23 }, Relationship.LEQ,    56454));\n+        constraints.add(new LinearConstraint(new double[] {     8,  768,   0,  34, 7456 }, Relationship.LEQ,  1923421));\n+        constraints.add(new LinearConstraint(new double[] { 12342, 2342,  34, 678, 2342 }, Relationship.GEQ,     4356));\n+        constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);\n+        assertEquals(480.419243986254, solution.getPoint()[1], .0000001);\n+        assertEquals(0.0, solution.getPoint()[2], .0000001);\n+        assertEquals(0.0, solution.getPoint()[3], .0000001);\n+        assertEquals(0.0, solution.getPoint()[4], .0000001);\n+        assertEquals(1438556.7491409, solution.getValue(), .0000001);\n+    }\n+\n+    @Test\n+    public void testEpsilon() throws OptimizationException {\n+      LinearObjectiveFunction f =\n+          new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);\n+      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+      constraints.add(new LinearConstraint(new double[] {  9, 8, 0 }, Relationship.EQ,  17));\n+      constraints.add(new LinearConstraint(new double[] {  0, 7, 8 }, Relationship.LEQ,  7));\n+      constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10));\n+\n+      SimplexSolver solver = new SimplexSolver();\n+      RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+      assertEquals(1.0, solution.getPoint()[0], 0.0);\n+      assertEquals(1.0, solution.getPoint()[1], 0.0);\n+      assertEquals(0.0, solution.getPoint()[2], 0.0);\n+      assertEquals(15.0, solution.getValue(), 0.0);\n+  }\n+    \n+    @Test\n+    public void testTrivialModel() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        assertEquals(0, solution.getValue(), .0000001);\n+    }\n+\n+    @Test\n+    public void testLargeModel() throws OptimizationException {\n+        double[] objective = new double[] {\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           12, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 12, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 12, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 12, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1};\n+\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(equationFromString(objective.length, \"x0 + x1 + x2 + x3 - x12 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49\"));\n+        constraints.add(equationFromString(objective.length, \"x0 + x1 + x2 + x3 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x14 + x15 + x16 + x17 - x26 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x14 + x15 + x16 + x17 - x12 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x28 + x29 + x30 + x31 - x40 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49\"));\n+        constraints.add(equationFromString(objective.length, \"x28 + x29 + x30 + x31 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x42 + x43 + x44 + x45 - x54 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x42 + x43 + x44 + x45 - x40 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x56 + x57 + x58 + x59 - x68 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51\"));\n+        constraints.add(equationFromString(objective.length, \"x56 + x57 + x58 + x59 >= 44\"));\n+        constraints.add(equationFromString(objective.length, \"x70 + x71 + x72 + x73 - x82 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x70 + x71 + x72 + x73 - x68 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x84 + x85 + x86 + x87 - x96 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51\"));\n+        constraints.add(equationFromString(objective.length, \"x84 + x85 + x86 + x87 >= 44\"));\n+        constraints.add(equationFromString(objective.length, \"x98 + x99 + x100 + x101 - x110 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x98 + x99 + x100 + x101 - x96 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x112 + x113 + x114 + x115 - x124 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49\"));\n+        constraints.add(equationFromString(objective.length, \"x112 + x113 + x114 + x115 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x126 + x127 + x128 + x129 - x138 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x126 + x127 + x128 + x129 - x124 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x140 + x141 + x142 + x143 - x152 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59\"));\n+        constraints.add(equationFromString(objective.length, \"x140 + x141 + x142 + x143 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x154 + x155 + x156 + x157 - x166 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x154 + x155 + x156 + x157 - x152 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x83 + x82 - x168 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x111 + x110 - x169 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x170 - x182 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x171 - x183 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x172 - x184 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x173 - x185 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x174 - x186 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x175 + x176 - x187 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x177 - x188 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x178 - x189 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x179 - x190 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x180 - x191 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x181 - x192 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x170 - x26 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x171 - x27 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x172 - x54 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x173 - x55 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x174 - x168 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x177 - x169 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x178 - x138 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x179 - x139 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x180 - x166 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x181 - x167 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x193 - x205 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x194 - x206 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x195 - x207 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x196 - x208 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x197 - x209 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x198 + x199 - x210 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x200 - x211 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x201 - x212 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x202 - x213 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x203 - x214 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x204 - x215 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x193 - x182 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x194 - x183 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x195 - x184 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x196 - x185 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x197 - x186 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x198 + x199 - x187 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x200 - x188 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x201 - x189 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x202 - x190 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x203 - x191 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x204 - x192 = 0\"));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        assertEquals(7518.0, solution.getValue(), .0000001);\n+    }\n+    \n+    /**\n+     * Converts a test string to a {@link LinearConstraint}.\n+     * Ex: x0 + x1 + x2 + x3 - x12 = 0\n+     */\n+    private LinearConstraint equationFromString(int numCoefficients, String s) {\n+        Relationship relationship;\n+        if (s.contains(\">=\")) {\n+            relationship = Relationship.GEQ;\n+        } else if (s.contains(\"<=\")) {\n+            relationship = Relationship.LEQ;\n+        } else if (s.contains(\"=\")) {\n+            relationship = Relationship.EQ;\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        String[] equationParts = s.split(\"[>|<]?=\");\n+        double rhs = Double.parseDouble(equationParts[1].trim());\n+\n+        RealVector lhs = new ArrayRealVector(numCoefficients);\n+        String left = equationParts[0].replaceAll(\" ?x\", \"\");\n+        String[] coefficients = left.split(\" \");\n+        for (String coefficient : coefficients) {\n+            double value = coefficient.charAt(0) == '-' ? -1 : 1;\n+            int index = Integer.parseInt(coefficient.replaceFirst(\"[+|-]\", \"\").trim());\n+            lhs.setEntry(index, value);\n+        }\n+        return new LinearConstraint(lhs, relationship, rhs);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexTableauTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+import junit.framework.TestCase;\n+\n+public class SimplexTableauTest extends TestCase {\n+\n+    public void testInitialization() {    \n+        LinearObjectiveFunction f = createFunction();\n+        Collection<LinearConstraint> constraints = createConstraints();\n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);\n+        double[][] expectedInitialTableau = {\n+                                             {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},\n+                                             { 0, 1, -15, -10, 25, 0, 0, 0,  0},\n+                                             { 0, 0,   1,   0, -1, 1, 0, 0,  2},\n+                                             { 0, 0,   0,   1, -1, 0, 1, 0,  3},\n+                                             { 0, 0,   1,   1, -2, 0, 0, 1,  4}\n+        };\n+        assertMatrixEquals(expectedInitialTableau, tableau.getData());\n+    }\n+\n+    public void testdiscardArtificialVariables() {    \n+        LinearObjectiveFunction f = createFunction();\n+        Collection<LinearConstraint> constraints = createConstraints();\n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);\n+        double[][] expectedTableau = {\n+                                      { 1, -15, -10, 25, 0, 0, 0},\n+                                      { 0,   1,   0, -1, 1, 0, 2},\n+                                      { 0,   0,   1, -1, 0, 1, 3},\n+                                      { 0,   1,   1, -2, 0, 0, 4}\n+        };\n+        tableau.discardArtificialVariables();\n+        assertMatrixEquals(expectedTableau, tableau.getData());\n+    }\n+\n+    public void testTableauWithNoArtificialVars() {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));    \n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);\n+        double[][] initialTableau = {\n+                                     {1, -15, -10, 25, 0, 0, 0, 0},\n+                                     {0,   1,   0, -1, 1, 0, 0, 2},\n+                                     {0,   0,   1, -1, 0, 1, 0, 3},\n+                                     {0,   1,   1, -2, 0, 0, 1, 4}\n+        };\n+        assertMatrixEquals(initialTableau, tableau.getData());\n+    }\n+\n+    public void testSerial() {\n+        LinearObjectiveFunction f = createFunction();\n+        Collection<LinearConstraint> constraints = createConstraints();\n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);\n+        assertEquals(tableau, TestUtils.serializeAndRecover(tableau));\n+    }\n+    private LinearObjectiveFunction createFunction() {\n+        return new LinearObjectiveFunction(new double[] {15, 10}, 0);\n+    }\n+\n+    private Collection<LinearConstraint> createConstraints() {\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4));\n+        return constraints;\n+    }\n+\n+    private void assertMatrixEquals(double[][] expected, double[][] result) {\n+        assertEquals(\"Wrong number of rows.\", expected.length, result.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals(\"Wrong number of columns.\", expected[i].length, result[i].length);\n+            for (int j = 0; j < expected[i].length; j++) {\n+                assertEquals(\"Wrong value at position [\" + i + \",\" + j + \"]\", expected[i][j], result[i][j]);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentMinimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+import org.junit.Test;\n+\n+/**\n+ * @version $Revision$ $Date$ \n+ */\n+public final class BrentMinimizerTest {\n+\n+    @Test\n+    public void testSinMin() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        minimizer.setMaxEvaluations(200);\n+        assertEquals(200, minimizer.getMaxEvaluations());\n+        try {\n+            minimizer.getResult();\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalStateException ise) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+        assertTrue(minimizer.getEvaluations()    <= 100);\n+        assertTrue(minimizer.getEvaluations()    >=  90);\n+        minimizer.setMaxEvaluations(50);\n+        try {\n+            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n+            fail(\"an exception should have been thrown\");\n+        } catch (FunctionEvaluationException fee) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    @Test\n+    public void testQuinticMin() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n+        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+\n+        // search in a large interval\n+        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+\n+    }\n+\n+    @Test\n+    public void testQuinticMax() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        assertEquals(0.27195613, minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3), 1.0e-8);\n+        minimizer.setMaximalIterationCount(30);\n+        try {\n+            minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);\n+            fail(\"an exception should have been thrown\");\n+        } catch (MaxIterationsExceededException miee) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    @Test\n+    public void testMinEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer solver = new BrentOptimizer();\n+\n+        // endpoint is minimum\n+        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5);\n+        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n+\n+        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2);\n+        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.Frequency;\n+ \n+\n+/**\n+ * Test cases for the AbstractRandomGenerator class\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class AbstractRandomGeneratorTest extends RandomDataTest {\n+    \n+    protected TestRandomGenerator testGenerator = new TestRandomGenerator();\n+    \n+    public AbstractRandomGeneratorTest(String name) {\n+        super(name);\n+        randomData = new RandomDataImpl(testGenerator);\n+    } \n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);\n+        suite.setName(\"AbstractRandomGenerator Tests\");\n+        return suite;\n+    }\n+    \n+    @Override\n+    public void testNextInt() {\n+        try {\n+            testGenerator.nextInt(-1);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency freq = new Frequency();\n+        int value = 0;\n+        for (int i=0; i<smallSampleSize; i++) {\n+            value = testGenerator.nextInt(4);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        long[] observed = new long[4];\n+        for (int i=0; i<4; i++) {\n+            observed[i] = freq.getCount(i);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    @Override\n+    public void testNextLong() {\n+        long q1 = Long.MAX_VALUE/4;\n+        long q2 = 2 *  q1;\n+        long q3 = 3 * q1;\n+        \n+        Frequency freq = new Frequency();\n+        long val = 0;\n+        int value = 0;\n+        for (int i=0; i<smallSampleSize; i++) {\n+            val = testGenerator.nextLong();\n+            if (val < q1) {\n+                value = 0;\n+            } else if (val < q2) {\n+                value = 1;\n+            } else if (val < q3) {\n+                value = 2;\n+            } else {\n+                value = 3;\n+            }\n+            freq.addValue(value);  \n+        }\n+        long[] observed = new long[4];\n+        for (int i=0; i<4; i++) {\n+            observed[i] = freq.getCount(i);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    public void testNextBoolean() {\n+        long halfSampleSize = smallSampleSize / 2; \n+        double[] expected = {halfSampleSize, halfSampleSize};\n+        long[] observed = new long[2];\n+        for (int i=0; i<smallSampleSize; i++) {\n+            if (testGenerator.nextBoolean()) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.635 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected,observed) < 10.828);    \n+    }\n+    \n+    public void testNextFloat() {\n+        Frequency freq = new Frequency();\n+        float val = 0;\n+        int value = 0;\n+        for (int i=0; i<smallSampleSize; i++) {\n+            val = testGenerator.nextFloat();\n+            if (val < 0.25) {\n+                value = 0;\n+            } else if (val < 0.5) {\n+                value = 1;\n+            } else if (val < 0.75) {\n+                value = 2;\n+            } else {\n+                value = 3;\n+            }\n+            freq.addValue(value);  \n+        }\n+        long[] observed = new long[4];\n+        for (int i=0; i<4; i++) {\n+            observed[i] = freq.getCount(i);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n+\n+public class CorrelatedRandomVectorGeneratorTest\n+extends TestCase {\n+\n+    public CorrelatedRandomVectorGeneratorTest(String name) {\n+        super(name);\n+        mean       = null;\n+        covariance = null;\n+        generator  = null;\n+    }\n+\n+    public void testRank() {\n+        assertEquals(3, generator.getRank());\n+    }\n+\n+    public void testMath226()\n+        throws DimensionMismatchException, NotPositiveDefiniteMatrixException {\n+        double[] mean = { 1, 1, 10, 1 };\n+        double[][] cov = {\n+                { 1, 3, 2, 6 },\n+                { 3, 13, 16, 2 },\n+                { 2, 16, 38, -1 },\n+                { 6, 2, -1, 197 }\n+        };\n+        RealMatrix covRM = MatrixUtils.createRealMatrix(cov);\n+        JDKRandomGenerator jg = new JDKRandomGenerator();\n+        jg.setSeed(5322145245211l);\n+        NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);\n+        CorrelatedRandomVectorGenerator sg =\n+            new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);\n+\n+        for (int i = 0; i < 10; i++) {\n+            double[] generated = sg.nextVector();\n+            assertTrue(Math.abs(generated[0] - 1) > 0.1);\n+        }\n+\n+    }\n+\n+    public void testRootMatrix() {\n+        RealMatrix b = generator.getRootMatrix();\n+        RealMatrix bbt = b.multiply(b.transpose());\n+        for (int i = 0; i < covariance.getRowDimension(); ++i) {\n+            for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n+                assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);\n+            }\n+        }\n+    }\n+\n+    public void testMeanAndCovariance() throws DimensionMismatchException {\n+\n+        VectorialMean meanStat = new VectorialMean(mean.length);\n+        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);\n+        for (int i = 0; i < 5000; ++i) {\n+            double[] v = generator.nextVector();\n+            meanStat.increment(v);\n+            covStat.increment(v);\n+        }\n+\n+        double[] estimatedMean = meanStat.getResult();\n+        RealMatrix estimatedCovariance = covStat.getResult();\n+        for (int i = 0; i < estimatedMean.length; ++i) {\n+            assertEquals(mean[i], estimatedMean[i], 0.07);\n+            for (int j = 0; j <= i; ++j) {\n+                assertEquals(covariance.getEntry(i, j),\n+                        estimatedCovariance.getEntry(i, j),\n+                        0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        try {\n+            mean = new double[] { 0.0, 1.0, -3.0, 2.3};\n+\n+            RealMatrix b = MatrixUtils.createRealMatrix(4, 3);\n+            int counter = 0;\n+            for (int i = 0; i < b.getRowDimension(); ++i) {\n+                for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                    b.setEntry(i, j, 1.0 + 0.1 * ++counter);\n+                }\n+            }\n+            RealMatrix bbt = b.multiply(b.transpose());\n+            covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);\n+            for (int i = 0; i < covariance.getRowDimension(); ++i) {\n+                covariance.setEntry(i, i, bbt.getEntry(i, i));\n+                for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n+                    double s = bbt.getEntry(i, j);\n+                    covariance.setEntry(i, j, s);\n+                    covariance.setEntry(j, i, s);\n+                }\n+            }\n+\n+            RandomGenerator rg = new JDKRandomGenerator();\n+            rg.setSeed(17399225432l);\n+            GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);\n+            generator = new CorrelatedRandomVectorGenerator(mean,\n+                                                            covariance,\n+                                                            1.0e-12 * covariance.getNorm(),\n+                                                            rawGenerator);\n+        } catch (DimensionMismatchException e) {\n+            fail(e.getMessage());\n+        } catch (NotPositiveDefiniteMatrixException e) {\n+            fail(\"not positive definite matrix\");\n+        }\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        mean       = null;\n+        covariance = null;\n+        generator  = null;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(CorrelatedRandomVectorGeneratorTest.class);\n+    }\n+\n+    private double[] mean;\n+    private RealMatrix covariance;\n+    private CorrelatedRandomVectorGenerator generator;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.util.ArrayList;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.RetryTestCase;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n+/**\n+ * Test cases for the EmpiricalDistribution class\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class EmpiricalDistributionTest extends RetryTestCase {\n+\n+    protected EmpiricalDistribution empiricalDistribution = null;\n+    protected EmpiricalDistribution empiricalDistribution2 = null;\n+    protected File file = null;\n+    protected URL url = null; \n+    protected double[] dataArray = null;\n+    \n+    public EmpiricalDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() throws IOException {\n+        empiricalDistribution = new EmpiricalDistributionImpl(100);\n+        url = getClass().getResource(\"testData.txt\");\n+        \n+        empiricalDistribution2 = new EmpiricalDistributionImpl(100);\n+        BufferedReader in = \n+                new BufferedReader(new InputStreamReader(\n+                        url.openStream()));\n+        String str = null;\n+        ArrayList<Double> list = new ArrayList<Double>();\n+        while ((str = in.readLine()) != null) {\n+            list.add(Double.valueOf(str));\n+        }\n+        in.close();\n+        in = null;\n+        \n+        dataArray = new double[list.size()];\n+        int i = 0;\n+        for (Double data : list) {\n+            dataArray[i] = data.doubleValue();\n+            i++;\n+        }                 \n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);\n+        suite.setName(\"EmpiricalDistribution Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Test EmpiricalDistrbution.load() using sample data file.<br> \n+     * Check that the sampleCount, mu and sigma match data in \n+     * the sample data file.\n+     */\n+    public void testLoad() throws Exception {\n+        empiricalDistribution.load(url);   \n+        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n+        // Make sure that loaded distribution matches this\n+        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);\n+        //TODO: replace with statistical tests\n+        assertEquals\n+            (empiricalDistribution.getSampleStats().getMean(),\n+                5.069831575018909,10E-7);\n+        assertEquals\n+          (empiricalDistribution.getSampleStats().getStandardDeviation(),\n+                1.0173699343977738,10E-7);\n+    }\n+\n+    /**\n+     * Test EmpiricalDistrbution.load(double[]) using data taken from\n+     * sample data file.<br> \n+     * Check that the sampleCount, mu and sigma match data in \n+     * the sample data file.\n+     */\n+    public void testDoubleLoad() throws Exception {\n+        empiricalDistribution2.load(dataArray);   \n+        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n+        // Make sure that loaded distribution matches this\n+        assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);\n+        //TODO: replace with statistical tests\n+        assertEquals\n+            (empiricalDistribution2.getSampleStats().getMean(),\n+                5.069831575018909,10E-7);\n+        assertEquals\n+          (empiricalDistribution2.getSampleStats().getStandardDeviation(),\n+                1.0173699343977738,10E-7);\n+        \n+        double[] bounds = empiricalDistribution2.getUpperBounds();\n+        assertEquals(bounds.length, 100);\n+        assertEquals(bounds[99], 1.0, 10e-12);\n+          \n+    }\n+   \n+    /** \n+      * Generate 1000 random values and make sure they look OK.<br>\n+      * Note that there is a non-zero (but very small) probability that\n+      * these tests will fail even if the code is working as designed.\n+      */\n+    public void testNext() throws Exception {\n+        tstGen(0.1);\n+        tstDoubleGen(0.1);\n+    }\n+    \n+    /**\n+      * Make sure exception thrown if digest getNext is attempted\n+      * before loading empiricalDistribution.\n+     */\n+    public void testNexFail() {\n+        try {\n+            empiricalDistribution.getNextValue();\n+            empiricalDistribution2.getNextValue();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+    \n+    /**\n+     * Make sure we can handle a grid size that is too fine\n+     */\n+    public void testGridTooFine() throws Exception {\n+        empiricalDistribution = new EmpiricalDistributionImpl(1001);\n+        tstGen(0.1);    \n+        empiricalDistribution2 = new EmpiricalDistributionImpl(1001);           \n+        tstDoubleGen(0.1);\n+    }\n+    \n+    /**\n+     * How about too fat?\n+     */\n+    public void testGridTooFat() throws Exception {\n+        empiricalDistribution = new EmpiricalDistributionImpl(1);\n+        tstGen(5); // ridiculous tolerance; but ridiculous grid size\n+                   // really just checking to make sure we do not bomb\n+        empiricalDistribution2 = new EmpiricalDistributionImpl(1);           \n+        tstDoubleGen(5);           \n+    }\n+    \n+    /**\n+     * Test bin index overflow problem (BZ 36450)\n+     */\n+    public void testBinIndexOverflow() throws Exception {\n+        double[] x = new double[] {9474.94326071674, 2080107.8865462579};\n+        new EmpiricalDistributionImpl().load(x);\n+    }\n+    \n+    public void testSerialization() {\n+        // Empty\n+        EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n+        EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);\n+        verifySame(dist, dist2);\n+        \n+        // Loaded\n+        empiricalDistribution2.load(dataArray);   \n+        dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);\n+        verifySame(empiricalDistribution2, dist2);\n+    }\n+\n+    public void testLoadNullDoubleArray() {\n+        EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n+        try {\n+            dist.load((double[]) null);\n+            fail(\"load((double[]) null) expected RuntimeException\");\n+        } catch (MathRuntimeException e) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testLoadNullURL() throws Exception {\n+        EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n+        try {\n+            dist.load((URL) null);\n+            fail(\"load((URL) null) expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testLoadNullFile() throws Exception {\n+        EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n+        try {\n+            dist.load((File) null);\n+            fail(\"load((File) null) expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {\n+        assertEquals(d1.isLoaded(), d2.isLoaded());\n+        assertEquals(d1.getBinCount(), d2.getBinCount());\n+        assertEquals(d1.getSampleStats(), d2.getSampleStats());\n+        if (d1.isLoaded()) {\n+            for (int i = 0;  i < d1.getUpperBounds().length; i++) {\n+                assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);\n+            }\n+            assertEquals(d1.getBinStats(), d2.getBinStats());\n+        }\n+    }\n+    \n+    private void tstGen(double tolerance)throws Exception {\n+        empiricalDistribution.load(url);   \n+        SummaryStatistics stats = new SummaryStatistics();\n+        for (int i = 1; i < 1000; i++) {\n+            stats.addValue(empiricalDistribution.getNextValue());\n+        }\n+        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        assertEquals\n+         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+    }\n+\n+    private void tstDoubleGen(double tolerance)throws Exception {\n+        empiricalDistribution2.load(dataArray);   \n+        SummaryStatistics stats = new SummaryStatistics();\n+        for (int i = 1; i < 1000; i++) {\n+            stats.addValue(empiricalDistribution2.getNextValue());\n+        }\n+        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        assertEquals\n+         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/GaussianRandomGeneratorTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.stat.StatUtils;\n+\n+import junit.framework.*;\n+\n+public class GaussianRandomGeneratorTest\n+extends TestCase {\n+\n+    public GaussianRandomGeneratorTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testMeanAndStandardDeviation() {\n+        RandomGenerator rg = new JDKRandomGenerator();\n+        rg.setSeed(17399225432l);\n+        GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);\n+        double[] sample = new double[10000];\n+        for (int i = 0; i < sample.length; ++i) {\n+            sample[i] = generator.nextNormalizedDouble();\n+        }\n+        assertEquals(0.0, StatUtils.mean(sample), 0.012);\n+        assertEquals(1.0, StatUtils.variance(sample), 0.01);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(GaussianRandomGeneratorTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Test;\n+\n+public class MersenneTwisterTest {\n+\n+    @Test\n+    public void testGaussian() {\n+        MersenneTwister mt = new MersenneTwister(42853252100l);\n+        SummaryStatistics sample = new SummaryStatistics();\n+        for (int i = 0; i < 1000; ++i) {\n+            sample.addValue(mt.nextGaussian());\n+        }\n+        assertEquals(0.0, sample.getMean(), 0.005);\n+        assertEquals(1.0, sample.getStandardDeviation(), 0.025);\n+    }\n+\n+    @Test\n+    public void testDouble() {\n+        MersenneTwister mt = new MersenneTwister(195357343514l);\n+        SummaryStatistics sample = new SummaryStatistics();\n+        for (int i = 0; i < 1000; ++i) {\n+            sample.addValue(mt.nextDouble());\n+        }\n+        assertEquals(0.5, sample.getMean(), 0.02);\n+        assertEquals(1.0 / (2.0 * Math.sqrt(3.0)),\n+                     sample.getStandardDeviation(),\n+                     0.002);\n+    }\n+\n+    @Test\n+    public void testFloat() {\n+        MersenneTwister mt = new MersenneTwister(4442733263l);\n+        SummaryStatistics sample = new SummaryStatistics();\n+        for (int i = 0; i < 1000; ++i) {\n+            sample.addValue(mt.nextFloat());\n+        }\n+        assertEquals(0.5, sample.getMean(), 0.01);\n+        assertEquals(1.0 / (2.0 * Math.sqrt(3.0)),\n+                     sample.getStandardDeviation(),\n+                     0.006);\n+    }\n+\n+    @Test(expected=java.lang.IllegalArgumentException.class)\n+    public void testNextIntNeg() {\n+        new MersenneTwister(1).nextInt(-1);\n+    }\n+\n+    @Test\n+    public void testNextIntN() {\n+        MersenneTwister mt = new MersenneTwister(0x12b8a7412bb25el);\n+        for (int n = 1; n < 20; ++n) {\n+            int[] count = new int[n];\n+            for (int k = 0; k < 10000; ++k) {\n+                int l = mt.nextInt(n);\n+                ++count[l];\n+                assertTrue(l >= 0);\n+                assertTrue(l <  n);\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                assertTrue(n * count[i] >  8600);\n+                assertTrue(n * count[i] < 11200);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNextInt() {\n+        MersenneTwister mt = new MersenneTwister(new int[] { 1, 2, 3, 4, 5 });\n+        int walk = 0;\n+        for (int k = 0; k < 10000; ++k) {\n+           if (mt.nextInt() >= 0) {\n+               ++walk;\n+           } else {\n+               --walk;\n+           }\n+        }\n+        assertTrue(Math.abs(walk) < 120);\n+    }\n+\n+    @Test\n+    public void testNextLong() {\n+        MersenneTwister mt = new MersenneTwister(12345);\n+        int walk = 0;\n+        for (int k = 0; k < 10000; ++k) {\n+           if (mt.nextLong() >= 0) {\n+               ++walk;\n+           } else {\n+               --walk;\n+           }\n+        }\n+        assertTrue(Math.abs(walk) < 50);\n+    }\n+\n+    @Test\n+    public void testNexBoolean() {\n+        MersenneTwister mt = new MersenneTwister(76342);\n+        int walk = 0;\n+        for (int k = 0; k < 10000; ++k) {\n+           if (mt.nextBoolean()) {\n+               ++walk;\n+           } else {\n+               --walk;\n+           }\n+        }\n+        assertTrue(Math.abs(walk) < 250);\n+    }\n+\n+    @Test\n+    public void testNexBytes() {\n+        MersenneTwister mt = new MersenneTwister(0);\n+        int[] count = new int[256];\n+        byte[] bytes = new byte[10];\n+        for (int k = 0; k < 100000; ++k) {\n+           mt.nextBytes(bytes);\n+           for (byte b : bytes) {\n+               ++count[b + 128];\n+           }\n+        }\n+        int min = Integer.MAX_VALUE;\n+        int max = Integer.MIN_VALUE;\n+        for (int c : count) {\n+            min = Math.min(min, c);\n+            max = Math.max(max, c);\n+        }\n+        int expected = (100000 * bytes.length) / count.length;\n+        assertTrue((expected - 200) < min);\n+        assertTrue(max < (expected + 200));\n+    }\n+\n+    @Test\n+    public void testMakotoNishimura() {\n+        MersenneTwister mt = new MersenneTwister(new int[] {0x123, 0x234, 0x345, 0x456});\n+        long[] refInt = {\n+            1067595299l,  955945823l,  477289528l, 4107218783l, 4228976476l, 3344332714l, 3355579695l,  227628506l,\n+            810200273l, 2591290167l, 2560260675l, 3242736208l,  646746669l, 1479517882l, 4245472273l, 1143372638l,\n+            3863670494l, 3221021970l, 1773610557l, 1138697238l, 1421897700l, 1269916527l, 2859934041l, 1764463362l,\n+            3874892047l, 3965319921l,   72549643l, 2383988930l, 2600218693l, 3237492380l, 2792901476l,  725331109l,\n+            605841842l,  271258942l,  715137098l, 3297999536l, 1322965544l, 4229579109l, 1395091102l, 3735697720l,\n+            2101727825l, 3730287744l, 2950434330l, 1661921839l, 2895579582l, 2370511479l, 1004092106l, 2247096681l,\n+            2111242379l, 3237345263l, 4082424759l,  219785033l, 2454039889l, 3709582971l,  835606218l, 2411949883l,\n+            2735205030l,  756421180l, 2175209704l, 1873865952l, 2762534237l, 4161807854l, 3351099340l,  181129879l,\n+            3269891896l,  776029799l, 2218161979l, 3001745796l, 1866825872l, 2133627728l,   34862734l, 1191934573l,\n+            3102311354l, 2916517763l, 1012402762l, 2184831317l, 4257399449l, 2899497138l, 3818095062l, 3030756734l,\n+            1282161629l,  420003642l, 2326421477l, 2741455717l, 1278020671l, 3744179621l,  271777016l, 2626330018l,\n+            2560563991l, 3055977700l, 4233527566l, 1228397661l, 3595579322l, 1077915006l, 2395931898l, 1851927286l,\n+            3013683506l, 1999971931l, 3006888962l, 1049781534l, 1488758959l, 3491776230l,  104418065l, 2448267297l,\n+            3075614115l, 3872332600l,  891912190l, 3936547759l, 2269180963l, 2633455084l, 1047636807l, 2604612377l,\n+            2709305729l, 1952216715l,  207593580l, 2849898034l,  670771757l, 2210471108l,  467711165l,  263046873l,\n+            3569667915l, 1042291111l, 3863517079l, 1464270005l, 2758321352l, 3790799816l, 2301278724l, 3106281430l,\n+            7974801l, 2792461636l,  555991332l,  621766759l, 1322453093l,  853629228l,  686962251l, 1455120532l,\n+            957753161l, 1802033300l, 1021534190l, 3486047311l, 1902128914l, 3701138056l, 4176424663l, 1795608698l,\n+            560858864l, 3737752754l, 3141170998l, 1553553385l, 3367807274l,  711546358l, 2475125503l,  262969859l,\n+            251416325l, 2980076994l, 1806565895l,  969527843l, 3529327173l, 2736343040l, 2987196734l, 1649016367l,\n+            2206175811l, 3048174801l, 3662503553l, 3138851612l, 2660143804l, 1663017612l, 1816683231l,  411916003l,\n+            3887461314l, 2347044079l, 1015311755l, 1203592432l, 2170947766l, 2569420716l,  813872093l, 1105387678l,\n+            1431142475l,  220570551l, 4243632715l, 4179591855l, 2607469131l, 3090613241l,  282341803l, 1734241730l,\n+            1391822177l, 1001254810l,  827927915l, 1886687171l, 3935097347l, 2631788714l, 3905163266l,  110554195l,\n+            2447955646l, 3717202975l, 3304793075l, 3739614479l, 3059127468l,  953919171l, 2590123714l, 1132511021l,\n+            3795593679l, 2788030429l,  982155079l, 3472349556l,  859942552l, 2681007391l, 2299624053l,  647443547l,\n+            233600422l,  608168955l, 3689327453l, 1849778220l, 1608438222l, 3968158357l, 2692977776l, 2851872572l,\n+            246750393l, 3582818628l, 3329652309l, 4036366910l, 1012970930l,  950780808l, 3959768744l, 2538550045l,\n+            191422718l, 2658142375l, 3276369011l, 2927737484l, 1234200027l, 1920815603l, 3536074689l, 1535612501l,\n+            2184142071l, 3276955054l,  428488088l, 2378411984l, 4059769550l, 3913744741l, 2732139246l,   64369859l,\n+            3755670074l,  842839565l, 2819894466l, 2414718973l, 1010060670l, 1839715346l, 2410311136l,  152774329l,\n+            3485009480l, 4102101512l, 2852724304l,  879944024l, 1785007662l, 2748284463l, 1354768064l, 3267784736l,\n+            2269127717l, 3001240761l, 3179796763l,  895723219l,  865924942l, 4291570937l,   89355264l, 1471026971l,\n+            4114180745l, 3201939751l, 2867476999l, 2460866060l, 3603874571l, 2238880432l, 3308416168l, 2072246611l,\n+            2755653839l, 3773737248l, 1709066580l, 4282731467l, 2746170170l, 2832568330l,  433439009l, 3175778732l,\n+            26248366l, 2551382801l,  183214346l, 3893339516l, 1928168445l, 1337157619l, 3429096554l, 3275170900l,\n+            1782047316l, 4264403756l, 1876594403l, 4289659572l, 3223834894l, 1728705513l, 4068244734l, 2867840287l,\n+            1147798696l,  302879820l, 1730407747l, 1923824407l, 1180597908l, 1569786639l,  198796327l,  560793173l,\n+            2107345620l, 2705990316l, 3448772106l, 3678374155l,  758635715l,  884524671l,  486356516l, 1774865603l,\n+            3881226226l, 2635213607l, 1181121587l, 1508809820l, 3178988241l, 1594193633l, 1235154121l,  326117244l,\n+            2304031425l,  937054774l, 2687415945l, 3192389340l, 2003740439l, 1823766188l, 2759543402l,   10067710l,\n+            1533252662l, 4132494984l,   82378136l,  420615890l, 3467563163l,  541562091l, 3535949864l, 2277319197l,\n+            3330822853l, 3215654174l, 4113831979l, 4204996991l, 2162248333l, 3255093522l, 2219088909l, 2978279037l,\n+            255818579l, 2859348628l, 3097280311l, 2569721123l, 1861951120l, 2907080079l, 2719467166l,  998319094l,\n+            2521935127l, 2404125338l,  259456032l, 2086860995l, 1839848496l, 1893547357l, 2527997525l, 1489393124l,\n+            2860855349l,   76448234l, 2264934035l,  744914583l, 2586791259l, 1385380501l,   66529922l, 1819103258l,\n+            1899300332l, 2098173828l, 1793831094l,  276463159l,  360132945l, 4178212058l,  595015228l,  177071838l,\n+            2800080290l, 1573557746l, 1548998935l,  378454223l, 1460534296l, 1116274283l, 3112385063l, 3709761796l,\n+            827999348l, 3580042847l, 1913901014l,  614021289l, 4278528023l, 1905177404l,   45407939l, 3298183234l,\n+            1184848810l, 3644926330l, 3923635459l, 1627046213l, 3677876759l,  969772772l, 1160524753l, 1522441192l,\n+            452369933l, 1527502551l,  832490847l, 1003299676l, 1071381111l, 2891255476l,  973747308l, 4086897108l,\n+            1847554542l, 3895651598l, 2227820339l, 1621250941l, 2881344691l, 3583565821l, 3510404498l,  849362119l,\n+            862871471l,  797858058l, 2867774932l, 2821282612l, 3272403146l, 3997979905l,  209178708l, 1805135652l,\n+            6783381l, 2823361423l,  792580494l, 4263749770l,  776439581l, 3798193823l, 2853444094l, 2729507474l,\n+            1071873341l, 1329010206l, 1289336450l, 3327680758l, 2011491779l,   80157208l,  922428856l, 1158943220l,\n+            1667230961l, 2461022820l, 2608845159l,  387516115l, 3345351910l, 1495629111l, 4098154157l, 3156649613l,\n+            3525698599l, 4134908037l,  446713264l, 2137537399l, 3617403512l,  813966752l, 1157943946l, 3734692965l,\n+            1680301658l, 3180398473l, 3509854711l, 2228114612l, 1008102291l,  486805123l,  863791847l, 3189125290l,\n+            1050308116l, 3777341526l, 4291726501l,  844061465l, 1347461791l, 2826481581l,  745465012l, 2055805750l,\n+            4260209475l, 2386693097l, 2980646741l,  447229436l, 2077782664l, 1232942813l, 4023002732l, 1399011509l,\n+            3140569849l, 2579909222l, 3794857471l,  900758066l, 2887199683l, 1720257997l, 3367494931l, 2668921229l,\n+            955539029l, 3818726432l, 1105704962l, 3889207255l, 2277369307l, 2746484505l, 1761846513l, 2413916784l,\n+            2685127085l, 4240257943l, 1166726899l, 4215215715l, 3082092067l, 3960461946l, 1663304043l, 2087473241l,\n+            4162589986l, 2507310778l, 1579665506l,  767234210l,  970676017l,  492207530l, 1441679602l, 1314785090l,\n+            3262202570l, 3417091742l, 1561989210l, 3011406780l, 1146609202l, 3262321040l, 1374872171l, 1634688712l,\n+            1280458888l, 2230023982l,  419323804l, 3262899800l,   39783310l, 1641619040l, 1700368658l, 2207946628l,\n+            2571300939l, 2424079766l,  780290914l, 2715195096l, 3390957695l,  163151474l, 2309534542l, 1860018424l,\n+            555755123l,  280320104l, 1604831083l, 2713022383l, 1728987441l, 3639955502l,  623065489l, 3828630947l,\n+            4275479050l, 3516347383l, 2343951195l, 2430677756l,  635534992l, 3868699749l,  808442435l, 3070644069l,\n+            4282166003l, 2093181383l, 2023555632l, 1568662086l, 3422372620l, 4134522350l, 3016979543l, 3259320234l,\n+            2888030729l, 3185253876l, 4258779643l, 1267304371l, 1022517473l,  815943045l,  929020012l, 2995251018l,\n+            3371283296l, 3608029049l, 2018485115l,  122123397l, 2810669150l, 1411365618l, 1238391329l, 1186786476l,\n+            3155969091l, 2242941310l, 1765554882l,  279121160l, 4279838515l, 1641578514l, 3796324015l,   13351065l,\n+            103516986l, 1609694427l,  551411743l, 2493771609l, 1316337047l, 3932650856l, 4189700203l,  463397996l,\n+            2937735066l, 1855616529l, 2626847990l,   55091862l, 3823351211l,  753448970l, 4045045500l, 1274127772l,\n+            1124182256l,   92039808l, 2126345552l,  425973257l,  386287896l, 2589870191l, 1987762798l, 4084826973l,\n+            2172456685l, 3366583455l, 3602966653l, 2378803535l, 2901764433l, 3716929006l, 3710159000l, 2653449155l,\n+            3469742630l, 3096444476l, 3932564653l, 2595257433l,  318974657l, 3146202484l,  853571438l,  144400272l,\n+            3768408841l,  782634401l, 2161109003l,  570039522l, 1886241521l,   14249488l, 2230804228l, 1604941699l,\n+            3928713335l, 3921942509l, 2155806892l,  134366254l,  430507376l, 1924011722l,  276713377l,  196481886l,\n+            3614810992l, 1610021185l, 1785757066l,  851346168l, 3761148643l, 2918835642l, 3364422385l, 3012284466l,\n+            3735958851l, 2643153892l, 3778608231l, 1164289832l,  205853021l, 2876112231l, 3503398282l, 3078397001l,\n+            3472037921l, 1748894853l, 2740861475l,  316056182l, 1660426908l,  168885906l,  956005527l, 3984354789l,\n+            566521563l, 1001109523l, 1216710575l, 2952284757l, 3834433081l, 3842608301l, 2467352408l, 3974441264l,\n+            3256601745l, 1409353924l, 1329904859l, 2307560293l, 3125217879l, 3622920184l, 3832785684l, 3882365951l,\n+            2308537115l, 2659155028l, 1450441945l, 3532257603l, 3186324194l, 1225603425l, 1124246549l,  175808705l,\n+            3009142319l, 2796710159l, 3651990107l,  160762750l, 1902254979l, 1698648476l, 1134980669l,  497144426l,\n+            3302689335l, 4057485630l, 3603530763l, 4087252587l,  427812652l,  286876201l,  823134128l, 1627554964l,\n+            3745564327l, 2589226092l, 4202024494l,   62878473l, 3275585894l, 3987124064l, 2791777159l, 1916869511l,\n+            2585861905l, 1375038919l, 1403421920l,   60249114l, 3811870450l, 3021498009l, 2612993202l,  528933105l,\n+            2757361321l, 3341402964l, 2621861700l,  273128190l, 4015252178l, 3094781002l, 1621621288l, 2337611177l,\n+            1796718448l, 1258965619l, 4241913140l, 2138560392l, 3022190223l, 4174180924l,  450094611l, 3274724580l,\n+            617150026l, 2704660665l, 1469700689l, 1341616587l,  356715071l, 1188789960l, 2278869135l, 1766569160l,\n+            2795896635l,   57824704l, 2893496380l, 1235723989l, 1630694347l, 3927960522l,  428891364l, 1814070806l,\n+            2287999787l, 4125941184l, 3968103889l, 3548724050l, 1025597707l, 1404281500l, 2002212197l,   92429143l,\n+            2313943944l, 2403086080l, 3006180634l, 3561981764l, 1671860914l, 1768520622l, 1803542985l,  844848113l,\n+            3006139921l, 1410888995l, 1157749833l, 2125704913l, 1789979528l, 1799263423l,  741157179l, 2405862309l,\n+            767040434l, 2655241390l, 3663420179l, 2172009096l, 2511931187l, 1680542666l,  231857466l, 1154981000l,\n+            157168255l, 1454112128l, 3505872099l, 1929775046l, 2309422350l, 2143329496l, 2960716902l,  407610648l,\n+            2938108129l, 2581749599l,  538837155l, 2342628867l,  430543915l,  740188568l, 1937713272l, 3315215132l,\n+            2085587024l, 4030765687l,  766054429l, 3517641839l,  689721775l, 1294158986l, 1753287754l, 4202601348l,\n+            1974852792l,   33459103l, 3568087535l, 3144677435l, 1686130825l, 4134943013l, 3005738435l, 3599293386l,\n+            426570142l,  754104406l, 3660892564l, 1964545167l,  829466833l,  821587464l, 1746693036l, 1006492428l,\n+            1595312919l, 1256599985l, 1024482560l, 1897312280l, 2902903201l,  691790057l, 1037515867l, 3176831208l,\n+            1968401055l, 2173506824l, 1089055278l, 1748401123l, 2941380082l,  968412354l, 1818753861l, 2973200866l,\n+            3875951774l, 1119354008l, 3988604139l, 1647155589l, 2232450826l, 3486058011l, 3655784043l, 3759258462l,\n+            847163678l, 1082052057l,  989516446l, 2871541755l, 3196311070l, 3929963078l,  658187585l, 3664944641l,\n+            2175149170l, 2203709147l, 2756014689l, 2456473919l, 3890267390l, 1293787864l, 2830347984l, 3059280931l,\n+            4158802520l, 1561677400l, 2586570938l,  783570352l, 1355506163l,   31495586l, 3789437343l, 3340549429l,\n+            2092501630l,  896419368l,  671715824l, 3530450081l, 3603554138l, 1055991716l, 3442308219l, 1499434728l,\n+            3130288473l, 3639507000l,   17769680l, 2259741420l,  487032199l, 4227143402l, 3693771256l, 1880482820l,\n+            3924810796l,  381462353l, 4017855991l, 2452034943l, 2736680833l, 2209866385l, 2128986379l,  437874044l,\n+            595759426l,  641721026l, 1636065708l, 3899136933l,  629879088l, 3591174506l,  351984326l, 2638783544l,\n+            2348444281l, 2341604660l, 2123933692l,  143443325l, 1525942256l,  364660499l,  599149312l,  939093251l,\n+            1523003209l,  106601097l,  376589484l, 1346282236l, 1297387043l,  764598052l, 3741218111l,  933457002l,\n+            1886424424l, 3219631016l,  525405256l, 3014235619l,  323149677l, 2038881721l, 4100129043l, 2851715101l,\n+            2984028078l, 1888574695l, 2014194741l, 3515193880l, 4180573530l, 3461824363l, 2641995497l, 3179230245l,\n+            2902294983l, 2217320456l, 4040852155l, 1784656905l, 3311906931l,   87498458l, 2752971818l, 2635474297l,\n+            2831215366l, 3682231106l, 2920043893l, 3772929704l, 2816374944l,  309949752l, 2383758854l,  154870719l,\n+            385111597l, 1191604312l, 1840700563l,  872191186l, 2925548701l, 1310412747l, 2102066999l, 1504727249l,\n+            3574298750l, 1191230036l, 3330575266l, 3180292097l, 3539347721l,  681369118l, 3305125752l, 3648233597l,\n+            950049240l, 4173257693l, 1760124957l,  512151405l,  681175196l,  580563018l, 1169662867l, 4015033554l,\n+            2687781101l,  699691603l, 2673494188l, 1137221356l,  123599888l,  472658308l, 1053598179l, 1012713758l,\n+            3481064843l, 3759461013l, 3981457956l, 3830587662l, 1877191791l, 3650996736l,  988064871l, 3515461600l,\n+            4089077232l, 2225147448l, 1249609188l, 2643151863l, 3896204135l, 2416995901l, 1397735321l, 3460025646l \n+        };\n+        double[] refDouble = {\n+            0.76275443, 0.99000644, 0.98670464, 0.10143112, 0.27933125, 0.69867227, 0.94218740, 0.03427201,\n+            0.78842173, 0.28180608, 0.92179002, 0.20785655, 0.54534773, 0.69644020, 0.38107718, 0.23978165,\n+            0.65286910, 0.07514568, 0.22765211, 0.94872929, 0.74557914, 0.62664415, 0.54708246, 0.90959343,\n+            0.42043116, 0.86334511, 0.19189126, 0.14718544, 0.70259889, 0.63426346, 0.77408121, 0.04531601,\n+            0.04605807, 0.88595519, 0.69398270, 0.05377184, 0.61711170, 0.05565708, 0.10133577, 0.41500776,\n+            0.91810699, 0.22320679, 0.23353705, 0.92871862, 0.98897234, 0.19786706, 0.80558809, 0.06961067,\n+            0.55840445, 0.90479405, 0.63288060, 0.95009721, 0.54948447, 0.20645042, 0.45000959, 0.87050869,\n+            0.70806991, 0.19406895, 0.79286390, 0.49332866, 0.78483914, 0.75145146, 0.12341941, 0.42030252,\n+            0.16728160, 0.59906494, 0.37575460, 0.97815160, 0.39815952, 0.43595080, 0.04952478, 0.33917805,\n+            0.76509902, 0.61034321, 0.90654701, 0.92915732, 0.85365931, 0.18812377, 0.65913428, 0.28814566,\n+            0.59476081, 0.27835931, 0.60722542, 0.68310435, 0.69387186, 0.03699800, 0.65897714, 0.17527003,\n+            0.02889304, 0.86777366, 0.12352068, 0.91439461, 0.32022990, 0.44445731, 0.34903686, 0.74639273,\n+            0.65918367, 0.92492794, 0.31872642, 0.77749724, 0.85413832, 0.76385624, 0.32744211, 0.91326300,\n+            0.27458185, 0.22190155, 0.19865383, 0.31227402, 0.85321225, 0.84243342, 0.78544200, 0.71854080,\n+            0.92503892, 0.82703064, 0.88306297, 0.47284073, 0.70059042, 0.48003761, 0.38671694, 0.60465770,\n+            0.41747204, 0.47163243, 0.72750808, 0.65830223, 0.10955369, 0.64215401, 0.23456345, 0.95944940,\n+            0.72822249, 0.40888451, 0.69980355, 0.26677428, 0.57333635, 0.39791582, 0.85377858, 0.76962816,\n+            0.72004885, 0.90903087, 0.51376506, 0.37732665, 0.12691640, 0.71249738, 0.81217908, 0.37037313,\n+            0.32772374, 0.14238259, 0.05614811, 0.74363008, 0.39773267, 0.94859135, 0.31452454, 0.11730313,\n+            0.62962618, 0.33334237, 0.45547255, 0.10089665, 0.56550662, 0.60539371, 0.16027624, 0.13245301,\n+            0.60959939, 0.04671662, 0.99356286, 0.57660859, 0.40269560, 0.45274629, 0.06699735, 0.85064246,\n+            0.87742744, 0.54508392, 0.87242982, 0.29321385, 0.67660627, 0.68230715, 0.79052073, 0.48592054,\n+            0.25186266, 0.93769755, 0.28565487, 0.47219067, 0.99054882, 0.13155240, 0.47110470, 0.98556600,\n+            0.84397623, 0.12875246, 0.90953202, 0.49129015, 0.23792727, 0.79481194, 0.44337770, 0.96564297,\n+            0.67749118, 0.55684872, 0.27286897, 0.79538393, 0.61965356, 0.22487929, 0.02226018, 0.49248200,\n+            0.42247006, 0.91797788, 0.99250134, 0.23449967, 0.52531508, 0.10246337, 0.78685622, 0.34310922,\n+            0.89892996, 0.40454552, 0.68608407, 0.30752487, 0.83601319, 0.54956031, 0.63777550, 0.82199797,\n+            0.24890696, 0.48801123, 0.48661910, 0.51223987, 0.32969635, 0.31075073, 0.21393155, 0.73453207,\n+            0.15565705, 0.58584522, 0.28976728, 0.97621478, 0.61498701, 0.23891470, 0.28518540, 0.46809591,\n+            0.18371914, 0.37597910, 0.13492176, 0.66849449, 0.82811466, 0.56240330, 0.37548956, 0.27562998,\n+            0.27521910, 0.74096121, 0.77176757, 0.13748143, 0.99747138, 0.92504502, 0.09175241, 0.21389176,\n+            0.21766512, 0.31183245, 0.23271221, 0.21207367, 0.57903312, 0.77523344, 0.13242613, 0.31037988,\n+            0.01204835, 0.71652949, 0.84487594, 0.14982178, 0.57423142, 0.45677888, 0.48420169, 0.53465428,\n+            0.52667473, 0.46880526, 0.49849733, 0.05670710, 0.79022476, 0.03872047, 0.21697212, 0.20443086,\n+            0.28949326, 0.81678186, 0.87629474, 0.92297064, 0.27373097, 0.84625273, 0.51505586, 0.00582792,\n+            0.33295971, 0.91848412, 0.92537226, 0.91760033, 0.07541125, 0.71745848, 0.61158698, 0.00941650,\n+            0.03135554, 0.71527471, 0.24821915, 0.63636652, 0.86159918, 0.26450229, 0.60160194, 0.35557725,\n+            0.24477500, 0.07186456, 0.51757096, 0.62120362, 0.97981062, 0.69954667, 0.21065616, 0.13382753,\n+            0.27693186, 0.59644095, 0.71500764, 0.04110751, 0.95730081, 0.91600724, 0.47704678, 0.26183479,\n+            0.34706971, 0.07545431, 0.29398385, 0.93236070, 0.60486023, 0.48015011, 0.08870451, 0.45548581,\n+            0.91872718, 0.38142712, 0.10668643, 0.01397541, 0.04520355, 0.93822273, 0.18011940, 0.57577277,\n+            0.91427606, 0.30911399, 0.95853475, 0.23611214, 0.69619891, 0.69601980, 0.76765372, 0.58515930,\n+            0.49479057, 0.11288752, 0.97187699, 0.32095365, 0.57563608, 0.40760618, 0.78703383, 0.43261152,\n+            0.90877651, 0.84686346, 0.10599030, 0.72872803, 0.19315490, 0.66152912, 0.10210518, 0.06257876,\n+            0.47950688, 0.47062066, 0.72701157, 0.48915116, 0.66110261, 0.60170685, 0.24516994, 0.12726050,\n+            0.03451185, 0.90864994, 0.83494878, 0.94800035, 0.91035206, 0.14480751, 0.88458997, 0.53498312,\n+            0.15963215, 0.55378627, 0.35171349, 0.28719791, 0.09097957, 0.00667896, 0.32309622, 0.87561479,\n+            0.42534520, 0.91748977, 0.73908457, 0.41793223, 0.99279792, 0.87908370, 0.28458072, 0.59132853,\n+            0.98672190, 0.28547393, 0.09452165, 0.89910674, 0.53681109, 0.37931425, 0.62683489, 0.56609740,\n+            0.24801549, 0.52948179, 0.98328855, 0.66403523, 0.55523786, 0.75886666, 0.84784685, 0.86829981,\n+            0.71448906, 0.84670080, 0.43922919, 0.20771016, 0.64157936, 0.25664246, 0.73055695, 0.86395782,\n+            0.65852932, 0.99061803, 0.40280575, 0.39146298, 0.07291005, 0.97200603, 0.20555729, 0.59616495,\n+            0.08138254, 0.45796388, 0.33681125, 0.33989127, 0.18717090, 0.53545811, 0.60550838, 0.86520709,\n+            0.34290701, 0.72743276, 0.73023855, 0.34195926, 0.65019733, 0.02765254, 0.72575740, 0.32709576,\n+            0.03420866, 0.26061893, 0.56997511, 0.28439072, 0.84422744, 0.77637570, 0.55982168, 0.06720327,\n+            0.58449067, 0.71657369, 0.15819609, 0.58042821, 0.07947911, 0.40193792, 0.11376012, 0.88762938,\n+            0.67532159, 0.71223735, 0.27829114, 0.04806073, 0.21144026, 0.58830274, 0.04140071, 0.43215628,\n+            0.12952729, 0.94668759, 0.87391019, 0.98382450, 0.27750768, 0.90849647, 0.90962737, 0.59269720,\n+            0.96102026, 0.49544979, 0.32007095, 0.62585546, 0.03119821, 0.85953001, 0.22017528, 0.05834068,\n+            0.80731217, 0.53799961, 0.74166948, 0.77426600, 0.43938444, 0.54862081, 0.58575513, 0.15886492,\n+            0.73214332, 0.11649057, 0.77463977, 0.85788827, 0.17061997, 0.66838056, 0.96076133, 0.07949296,\n+            0.68521946, 0.89986254, 0.05667410, 0.12741385, 0.83470977, 0.63969104, 0.46612929, 0.10200126,\n+            0.01194925, 0.10476340, 0.90285217, 0.31221221, 0.32980614, 0.46041971, 0.52024973, 0.05425470,\n+            0.28330912, 0.60426543, 0.00598243, 0.97244013, 0.21135841, 0.78561597, 0.78428734, 0.63422849,\n+            0.32909934, 0.44771136, 0.27380750, 0.14966697, 0.18156268, 0.65686758, 0.28726350, 0.97074787,\n+            0.63676171, 0.96649494, 0.24526295, 0.08297372, 0.54257548, 0.03166785, 0.33735355, 0.15946671,\n+            0.02102971, 0.46228045, 0.11892296, 0.33408336, 0.29875681, 0.29847692, 0.73767569, 0.02080745,\n+            0.62980060, 0.08082293, 0.22993106, 0.25031439, 0.87787525, 0.45150053, 0.13673441, 0.63407612,\n+            0.97907688, 0.52241942, 0.50580158, 0.06273902, 0.05270283, 0.77031811, 0.05113352, 0.24393329,\n+            0.75036441, 0.37436336, 0.22877652, 0.59975358, 0.85707591, 0.88691457, 0.85547165, 0.36641027,\n+            0.58720133, 0.45462835, 0.09243817, 0.32981586, 0.07820411, 0.25421519, 0.36004706, 0.60092307,\n+            0.46192412, 0.36758683, 0.98424170, 0.08019934, 0.68594024, 0.45826386, 0.29962317, 0.79365413,\n+            0.89231296, 0.49478547, 0.87645944, 0.23590734, 0.28106737, 0.75026285, 0.08136314, 0.79582424,\n+            0.76010628, 0.82792971, 0.27947652, 0.72482861, 0.82191216, 0.46171689, 0.79189752, 0.96043686,\n+            0.51609668, 0.88995725, 0.28998963, 0.55191845, 0.03934737, 0.83033700, 0.49553013, 0.98009549,\n+            0.19017594, 0.98347750, 0.33452066, 0.87144372, 0.72106301, 0.71272114, 0.71465963, 0.88361677,\n+            0.85571283, 0.73782329, 0.20920458, 0.34855153, 0.46766817, 0.02780062, 0.74898344, 0.03680650,\n+            0.44866557, 0.77426312, 0.91025891, 0.25195236, 0.87319953, 0.63265037, 0.25552148, 0.27422476,\n+            0.95217406, 0.39281839, 0.66441573, 0.09158900, 0.94515992, 0.07800798, 0.02507888, 0.39901462,\n+            0.17382573, 0.12141278, 0.85502334, 0.19902911, 0.02160210, 0.44460522, 0.14688742, 0.68020336,\n+            0.71323733, 0.60922473, 0.95400380, 0.99611159, 0.90897777, 0.41073520, 0.66206647, 0.32064685,\n+            0.62805003, 0.50677209, 0.52690101, 0.87473387, 0.73918362, 0.39826974, 0.43683919, 0.80459118,\n+            0.32422684, 0.01958019, 0.95319576, 0.98326137, 0.83931735, 0.69060863, 0.33671416, 0.68062550,\n+            0.65152380, 0.33392969, 0.03451730, 0.95227244, 0.68200635, 0.85074171, 0.64721009, 0.51234433,\n+            0.73402047, 0.00969637, 0.93835057, 0.80803854, 0.31485260, 0.20089527, 0.01323282, 0.59933780,\n+            0.31584602, 0.20209563, 0.33754800, 0.68604181, 0.24443049, 0.19952227, 0.78162632, 0.10336988,\n+            0.11360736, 0.23536740, 0.23262256, 0.67803776, 0.48749791, 0.74658435, 0.92156640, 0.56706407,\n+            0.36683221, 0.99157136, 0.23421374, 0.45183767, 0.91609720, 0.85573315, 0.37706276, 0.77042618,\n+            0.30891908, 0.40709595, 0.06944866, 0.61342849, 0.88817388, 0.58734506, 0.98711323, 0.14744128,\n+            0.63242656, 0.87704136, 0.68347125, 0.84446569, 0.43265239, 0.25146321, 0.04130111, 0.34259839,\n+            0.92697368, 0.40878778, 0.56990338, 0.76204273, 0.19820348, 0.66314909, 0.02482844, 0.06669207,\n+            0.50205581, 0.26084093, 0.65139159, 0.41650223, 0.09733904, 0.56344203, 0.62651696, 0.67332139,\n+            0.58037374, 0.47258086, 0.21010758, 0.05713135, 0.89390629, 0.10781246, 0.32037450, 0.07628388,\n+            0.34227964, 0.42190597, 0.58201860, 0.77363549, 0.49595133, 0.86031236, 0.83906769, 0.81098161,\n+            0.26694195, 0.14215941, 0.88210306, 0.53634237, 0.12090720, 0.82480459, 0.75930318, 0.31847147,\n+            0.92768077, 0.01037616, 0.56201727, 0.88107122, 0.35925856, 0.85860762, 0.61109408, 0.70408301,\n+            0.58434977, 0.92192494, 0.62667915, 0.75988365, 0.06858761, 0.36156496, 0.58057195, 0.13636150,\n+            0.57719713, 0.59340255, 0.63530602, 0.22976282, 0.71915530, 0.41162531, 0.63979565, 0.09931342,\n+            0.79344045, 0.10893790, 0.84450224, 0.23122236, 0.99485593, 0.73637397, 0.17276368, 0.13357764,\n+            0.74965804, 0.64991737, 0.61990341, 0.41523170, 0.05878239, 0.05687301, 0.05497131, 0.42868366,\n+            0.42571090, 0.25810502, 0.89642955, 0.30439758, 0.39310223, 0.11357431, 0.04288255, 0.23397550,\n+            0.11200634, 0.85621396, 0.89733974, 0.37508865, 0.42077265, 0.68597384, 0.72781399, 0.19296476,\n+            0.61699087, 0.31667128, 0.67756410, 0.00177323, 0.05725176, 0.79474693, 0.18885238, 0.06724856,\n+            0.68193156, 0.42202167, 0.22082041, 0.28554673, 0.64995708, 0.87851940, 0.29124547, 0.61009521,\n+            0.87374537, 0.05743712, 0.69902994, 0.81925115, 0.45653873, 0.37236821, 0.31118709, 0.52734307,\n+            0.39672836, 0.38185294, 0.30163915, 0.17374510, 0.04913278, 0.90404879, 0.25742801, 0.58266467,\n+            0.97663209, 0.79823377, 0.36437958, 0.15206043, 0.26529938, 0.22690047, 0.05839021, 0.84721160,\n+            0.18622435, 0.37809403, 0.55706977, 0.49828704, 0.47659049, 0.24289680, 0.88477595, 0.07807463,\n+            0.56245739, 0.73490635, 0.21099431, 0.13164942, 0.75840044, 0.66877037, 0.28988183, 0.44046090,\n+            0.24967434, 0.80048356, 0.26029740, 0.30416821, 0.64151867, 0.52067892, 0.12880774, 0.85465381,\n+            0.02690525, 0.19149288, 0.49630295, 0.79682619, 0.43566145, 0.00288078, 0.81484193, 0.03763639,\n+            0.68529083, 0.01339574, 0.38405386, 0.30537067, 0.22994703, 0.44000045, 0.27217985, 0.53831243,\n+            0.02870435, 0.86282045, 0.61831306, 0.09164956, 0.25609707, 0.07445781, 0.72185784, 0.90058883,\n+            0.30070608, 0.94476583, 0.56822213, 0.21933909, 0.96772793, 0.80063440, 0.26307906, 0.31183306,\n+            0.16501252, 0.55436179, 0.68562285, 0.23829083, 0.86511559, 0.57868991, 0.81888344, 0.20126869,\n+            0.93172350, 0.66028129, 0.21786948, 0.78515828, 0.10262106, 0.35390326, 0.79303876, 0.63427924,\n+            0.90479631, 0.31024934, 0.60635447, 0.56198079, 0.63573813, 0.91854197, 0.99701497, 0.83085849,\n+            0.31692291, 0.01925964, 0.97446405, 0.98751283, 0.60944293, 0.13751018, 0.69519957, 0.68956636,\n+            0.56969015, 0.46440193, 0.88341765, 0.36754434, 0.89223647, 0.39786427, 0.85055280, 0.12749961,\n+            0.79452122, 0.89449784, 0.14567830, 0.45716830, 0.74822309, 0.28200437, 0.42546044, 0.17464886,\n+            0.68308746, 0.65496587, 0.52935411, 0.12736159, 0.61523955, 0.81590528, 0.63107864, 0.39786553,\n+            0.20102294, 0.53292914, 0.75485590, 0.59847044, 0.32861691, 0.12125866, 0.58917183, 0.07638293,\n+            0.86845380, 0.29192617, 0.03989733, 0.52180460, 0.32503407, 0.64071852, 0.69516575, 0.74254998,\n+            0.54587026, 0.48713246, 0.32920155, 0.08719954, 0.63497059, 0.54328459, 0.64178757, 0.45583809,\n+            0.70694291, 0.85212760, 0.86074305, 0.33163422, 0.85739792, 0.59908488, 0.74566046, 0.72157152\n+        };\n+\n+        for (int i = 0; i < refInt.length; ++i) {\n+            int r = mt.nextInt();\n+            assertEquals(refInt[i], (r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l));\n+        }\n+\n+        for (int i = 0; i < refDouble.length; ++i) {\n+            int r = mt.nextInt();\n+            assertEquals(refDouble[i],\n+                         ((r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l)) / 4294967296.0,\n+                         1.0e-8);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/RandomAdaptorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import java.util.Random;\n+\n+/**\n+ * Test cases for the RandomAdaptor class\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class RandomAdaptorTest extends RandomDataTest {\n+    \n+    public RandomAdaptorTest(String name) {\n+        super(name);\n+    } \n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomAdaptorTest.class);\n+        suite.setName(\"RandomAdaptor Tests\");\n+        return suite;\n+    }\n+    \n+    public void testAdaptor() {\n+        ConstantGenerator generator = new ConstantGenerator();\n+        Random random = RandomAdaptor.createAdaptor(generator);\n+        checkConstant(random);\n+        RandomAdaptor randomAdaptor = new RandomAdaptor(generator);\n+        checkConstant(randomAdaptor); \n+    }\n+    \n+    private void checkConstant(Random random) {\n+        byte[] bytes = new byte[] {0};\n+        random.nextBytes(bytes);\n+        assertEquals(0, bytes[0]);  \n+        assertEquals(false, random.nextBoolean());\n+        assertEquals(0, random.nextDouble(), 0);\n+        assertEquals(0, random.nextFloat(), 0);\n+        assertEquals(0, random.nextGaussian(), 0);\n+        assertEquals(0, random.nextInt());\n+        assertEquals(0, random.nextInt(1));\n+        assertEquals(0, random.nextLong());\n+        random.setSeed(100);\n+        assertEquals(0, random.nextDouble(), 0);\n+    }\n+    \n+    /*\n+     * \"Constant\" generator to test Adaptor delegation.\n+     * \"Powered by Eclipse ;-)\"\n+     * \n+     */\n+    private static class ConstantGenerator implements RandomGenerator {\n+        \n+        public boolean nextBoolean() {\n+            return false;\n+        }\n+        \n+        public void nextBytes(byte[] bytes) {\n+        }\n+\n+        public double nextDouble() {\n+            return 0;\n+        }\n+\n+        public float nextFloat() {\n+            return 0;\n+        }\n+\n+        public double nextGaussian() {\n+            return 0;\n+        }\n+\n+        public int nextInt() {\n+            return 0;\n+        }\n+\n+        public int nextInt(int n) {\n+            return 0;\n+        }\n+\n+        public long nextLong() {\n+            return 0;\n+        }\n+\n+        public void setSeed(int seed) {\n+        }\n+        \n+        public void setSeed(int[] seed) {\n+        }\n+\n+        public void setSeed(long seed) {\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import java.util.HashSet;\n+\n+import org.apache.commons.math.RetryTestCase;\n+import org.apache.commons.math.stat.Frequency;\n+import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n+/**\n+ * Test cases for the RandomData class.\n+ * \n+ * @version $Revision$ $Date: 2009-04-05 11:55:59 -0500 (Sun, 05 Apr\n+ *          2009) $\n+ */\n+\n+public class RandomDataTest extends RetryTestCase {\n+\n+\tpublic RandomDataTest(String name) {\n+\t\tsuper(name);\n+\t\trandomData = new RandomDataImpl();\n+\t}\n+\n+\tprotected long smallSampleSize = 1000;\n+\tprotected double[] expected = { 250, 250, 250, 250 };\n+\tprotected int largeSampleSize = 10000;\n+\tprivate String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n+\t\t\t\"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n+\tprotected RandomDataImpl randomData = null;\n+\tprotected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n+\n+\tpublic static Test suite() {\n+\t\tTestSuite suite = new TestSuite(RandomDataTest.class);\n+\t\tsuite.setName(\"RandomData Tests\");\n+\t\treturn suite;\n+\t}\n+\n+\tpublic void testNextIntExtremeValues() {\n+\t\tint x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\t\tint y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\t\tassertFalse(x == y);\n+\t}\n+\n+\tpublic void testNextLongExtremeValues() {\n+\t\tlong x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+\t\tlong y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+\t\tassertFalse(x == y);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextInt() */\n+\tpublic void testNextInt() {\n+\t\ttry {\n+\t\t\trandomData.nextInt(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tint value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextInt(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextLong() */\n+\tpublic void testNextLong() {\n+\t\ttry {\n+\t\t\trandomData.nextLong(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tlong value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextLong(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextSecureLong() */\n+\tpublic void testNextSecureLong() {\n+\t\ttry {\n+\t\t\trandomData.nextSecureLong(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tlong value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextSecureLong(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextSecureInt() */\n+\tpublic void testNextSecureInt() {\n+\t\ttry {\n+\t\t\trandomData.nextSecureInt(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tint value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextSecureInt(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/**\n+\t * Make sure that empirical distribution of random Poisson(4)'s has P(X <=\n+\t * 5) close to actual cumulative Poisson probablity and that nextPoisson\n+\t * fails when mean is non-positive TODO: replace with statistical test,\n+\t * adding test stat to TestStatistic\n+\t */\n+\tpublic void testNextPoisson() {\n+\t\ttry {\n+\t\t\trandomData.nextPoisson(0);\n+\t\t\tfail(\"zero mean -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency f = new Frequency();\n+\t\tfor (int i = 0; i < largeSampleSize; i++) {\n+\t\t\ttry {\n+\t\t\t\tf.addValue(randomData.nextPoisson(4.0d));\n+\t\t\t} catch (Exception ex) {\n+\t\t\t\tfail(ex.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\tlong cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)\n+\t\t\t\t+ f.getCount(3) + f.getCount(4) + f.getCount(5);\n+\t\tlong sumFreq = f.getSumFreq();\n+\t\tdouble cumPct = Double.valueOf(cumFreq).doubleValue()\n+\t\t\t\t/ Double.valueOf(sumFreq).doubleValue();\n+\t\tassertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n+\t\ttry {\n+\t\t\trandomData.nextPoisson(-1);\n+\t\t\tfail(\"negative mean supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextPoisson(0);\n+\t\t\tfail(\"0 mean supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\n+\t}\n+\n+\tpublic void testNextPoissonLargeMean() {\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tlong n = randomData.nextPoisson(1500.0);\n+\t\t\tassertTrue(0 <= n);\n+\t\t}\n+\t}\n+\n+\t/** test dispersion and failute modes for nextHex() */\n+\tpublic void testNextHex() {\n+\t\ttry {\n+\t\t\trandomData.nextHexString(-1);\n+\t\t\tfail(\"negative length supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextHexString(0);\n+\t\t\tfail(\"zero length supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tString hexString = randomData.nextHexString(3);\n+\t\tif (hexString.length() != 3) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\thexString = randomData.nextHexString(1);\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\ttry {\n+\t\t\thexString = randomData.nextHexString(0);\n+\t\t\tfail(\"zero length requested -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\tFrequency f = new Frequency();\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\thexString = randomData.nextHexString(100);\n+\t\t\tif (hexString.length() != 100) {\n+\t\t\t\tfail(\"incorrect length for generated string\");\n+\t\t\t}\n+\t\t\tfor (int j = 0; j < hexString.length(); j++) {\n+\t\t\t\tf.addValue(hexString.substring(j, j + 1));\n+\t\t\t}\n+\t\t}\n+\t\tdouble[] expected = new double[16];\n+\t\tlong[] observed = new long[16];\n+\t\tfor (int i = 0; i < 16; i++) {\n+\t\t\texpected[i] = (double) smallSampleSize * 100 / 16;\n+\t\t\tobserved[i] = f.getCount(hex[i]);\n+\t\t}\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 37.70);\n+\t}\n+\n+\t/** test dispersion and failute modes for nextHex() */\n+\tpublic void testNextSecureHex() {\n+\t\ttry {\n+\t\t\trandomData.nextSecureHexString(-1);\n+\t\t\tfail(\"negative length -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextSecureHexString(0);\n+\t\t\tfail(\"zero length -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tString hexString = randomData.nextSecureHexString(3);\n+\t\tif (hexString.length() != 3) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\thexString = randomData.nextSecureHexString(1);\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\ttry {\n+\t\t\thexString = randomData.nextSecureHexString(0);\n+\t\t\tfail(\"zero length requested -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\tFrequency f = new Frequency();\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\thexString = randomData.nextSecureHexString(100);\n+\t\t\tif (hexString.length() != 100) {\n+\t\t\t\tfail(\"incorrect length for generated string\");\n+\t\t\t}\n+\t\t\tfor (int j = 0; j < hexString.length(); j++) {\n+\t\t\t\tf.addValue(hexString.substring(j, j + 1));\n+\t\t\t}\n+\t\t}\n+\t\tdouble[] expected = new double[16];\n+\t\tlong[] observed = new long[16];\n+\t\tfor (int i = 0; i < 16; i++) {\n+\t\t\texpected[i] = (double) smallSampleSize * 100 / 16;\n+\t\t\tobserved[i] = f.getCount(hex[i]);\n+\t\t}\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 37.70);\n+\t}\n+\n+\t/** test failure modes and dispersion of nextUniform() */\n+\tpublic void testNextUniform() {\n+\t\ttry {\n+\t\t\trandomData.nextUniform(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextUniform(3, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tdouble[] expected = { 500, 500 };\n+\t\tlong[] observed = { 0, 0 };\n+\t\tdouble lower = -1d;\n+\t\tdouble upper = 20d;\n+\t\tdouble midpoint = (lower + upper) / 2d;\n+\t\tdouble result = 0;\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tresult = randomData.nextUniform(lower, upper);\n+\t\t\tif ((result == lower) || (result == upper)) {\n+\t\t\t\tfail(\"generated value equal to an endpoint: \" + result);\n+\t\t\t}\n+\t\t\tif (result < midpoint) {\n+\t\t\t\tobserved[0]++;\n+\t\t\t} else {\n+\t\t\t\tobserved[1]++;\n+\t\t\t}\n+\t\t}\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for\n+\t\t * alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 10.83);\n+\t}\n+\n+\t/** test exclusive endpoints of nextUniform **/\n+\tpublic void testNextUniformExclusiveEndpoints() {\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tdouble u = randomData.nextUniform(0.99, 1);\n+\t\t\tassertTrue(u > 0.99 && u < 1);\n+\t\t}\n+\t}\n+\n+\t/** test failure modes and distribution of nextGaussian() */\n+\tpublic void testNextGaussian() {\n+\t\ttry {\n+\t\t\trandomData.nextGaussian(0, 0);\n+\t\t\tfail(\"zero sigma -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tSummaryStatistics u = new SummaryStatistics();\n+\t\tfor (int i = 0; i < largeSampleSize; i++) {\n+\t\t\tu.addValue(randomData.nextGaussian(0, 1));\n+\t\t}\n+\t\tdouble xbar = u.getMean();\n+\t\tdouble s = u.getStandardDeviation();\n+\t\tdouble n = u.getN();\n+\t\t/*\n+\t\t * t-test at .001-level TODO: replace with externalized t-test, with\n+\t\t * test statistic defined in TestStatistic\n+\t\t */\n+\t\tassertTrue(Math.abs(xbar) / (s / Math.sqrt(n)) < 3.29);\n+\t}\n+\n+\t/** test failure modes and distribution of nextExponential() */\n+\tpublic void testNextExponential() {\n+\t\ttry {\n+\t\t\trandomData.nextExponential(-1);\n+\t\t\tfail(\"negative mean -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tassertEquals(\"0 mean\", 0, randomData.nextExponential(0), 10E-8);\n+\t\tlong cumFreq = 0;\n+\t\tdouble v = 0;\n+\t\tfor (int i = 0; i < largeSampleSize; i++) {\n+\t\t\tv = randomData.nextExponential(1);\n+\t\t\tassertTrue(\"exponential deviate postive\", v > 0);\n+\t\t\tif (v < 2)\n+\t\t\t\tcumFreq++;\n+\t\t}\n+\t\t/*\n+\t\t * TODO: Replace with a statistical test, with statistic added to\n+\t\t * TestStatistic. Check below compares observed cumulative distribution\n+\t\t * evaluated at 2 with exponential CDF\n+\t\t */\n+\t\tassertEquals(\"exponential cumulative distribution\", (double) cumFreq\n+\t\t\t\t/ (double) largeSampleSize, 0.8646647167633873, .2);\n+\t}\n+\n+\t/** test reseeding, algorithm/provider games */\n+\tpublic void testConfig() {\n+\t\trandomData.reSeed(1000);\n+\t\tdouble v = randomData.nextUniform(0, 1);\n+\t\trandomData.reSeed();\n+\t\tassertTrue(\"different seeds\", Math\n+\t\t\t\t.abs(v - randomData.nextUniform(0, 1)) > 10E-12);\n+\t\trandomData.reSeed(1000);\n+\t\tassertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n+\t\trandomData.reSeedSecure(1000);\n+\t\tString hex = randomData.nextSecureHexString(40);\n+\t\trandomData.reSeedSecure();\n+\t\tassertTrue(\"different seeds\", !hex.equals(randomData\n+\t\t\t\t.nextSecureHexString(40)));\n+\t\trandomData.reSeedSecure(1000);\n+\t\tassertTrue(\"same seeds\", !hex\n+\t\t\t\t.equals(randomData.nextSecureHexString(40)));\n+\n+\t\t/*\n+\t\t * remove this test back soon, since it takes about 4 seconds\n+\t\t * \n+\t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n+\t\t * (NoSuchProviderException ex) { ; } assertTrue(\"different seeds\",\n+\t\t * !hex.equals(randomData.nextSecureHexString(40))); try {\n+\t\t * randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n+\t\t * fail(\"expecting NoSuchAlgorithmException\"); } catch\n+\t\t * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n+\t\t * ex) { ; }\n+\t\t * \n+\t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n+\t\t * fail(\"expecting NoSuchProviderException\"); } catch\n+\t\t * (NoSuchProviderException ex) { ; }\n+\t\t */\n+\n+\t\t// test reseeding without first using the generators\n+\t\tRandomDataImpl rd = new RandomDataImpl();\n+\t\trd.reSeed(100);\n+\t\trd.nextLong(1, 2);\n+\t\tRandomDataImpl rd2 = new RandomDataImpl();\n+\t\trd2.reSeedSecure(2000);\n+\t\trd2.nextSecureLong(1, 2);\n+\t\trd = new RandomDataImpl();\n+\t\trd.reSeed();\n+\t\trd.nextLong(1, 2);\n+\t\trd2 = new RandomDataImpl();\n+\t\trd2.reSeedSecure();\n+\t\trd2.nextSecureLong(1, 2);\n+\t}\n+\n+\t/** tests for nextSample() sampling from Collection */\n+\tpublic void testNextSample() {\n+\t\tObject[][] c = { { \"0\", \"1\" }, { \"0\", \"2\" }, { \"0\", \"3\" },\n+\t\t\t\t{ \"0\", \"4\" }, { \"1\", \"2\" }, { \"1\", \"3\" }, { \"1\", \"4\" },\n+\t\t\t\t{ \"2\", \"3\" }, { \"2\", \"4\" }, { \"3\", \"4\" } };\n+\t\tlong[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+\t\tdouble[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+\t\tHashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}\n+\t\tfor (int i = 0; i < 5; i++) {\n+\t\t\tcPop.add(Integer.toString(i));\n+\t\t}\n+\n+\t\tObject[] sets = new Object[10]; // 2-sets from 5\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\tHashSet<Object> hs = new HashSet<Object>();\n+\t\t\ths.add(c[i][0]);\n+\t\t\ths.add(c[i][1]);\n+\t\t\tsets[i] = hs;\n+\t\t}\n+\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tObject[] cSamp = randomData.nextSample(cPop, 2);\n+\t\t\tobserved[findSample(sets, cSamp)]++;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 27.88);\n+\n+\t\t// Make sure sample of size = size of collection returns same collection\n+\t\tHashSet<Object> hs = new HashSet<Object>();\n+\t\ths.add(\"one\");\n+\t\tObject[] one = randomData.nextSample(hs, 1);\n+\t\tString oneString = (String) one[0];\n+\t\tif ((one.length != 1) || !oneString.equals(\"one\")) {\n+\t\t\tfail(\"bad sample for set size = 1, sample size = 1\");\n+\t\t}\n+\n+\t\t// Make sure we fail for sample size > collection size\n+\t\ttry {\n+\t\t\tone = randomData.nextSample(hs, 2);\n+\t\t\tfail(\"sample size > set size, expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\n+\t\t// Make sure we fail for empty collection\n+\t\ttry {\n+\t\t\ths = new HashSet<Object>();\n+\t\t\tone = randomData.nextSample(hs, 0);\n+\t\t\tfail(\"n = k = 0, expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate int findSample(Object[] u, Object[] samp) {\n+\t\tfor (int i = 0; i < u.length; i++) {\n+\t\t\tHashSet<Object> set = (HashSet<Object>) u[i];\n+\t\t\tHashSet<Object> sampSet = new HashSet<Object>();\n+\t\t\tfor (int j = 0; j < samp.length; j++) {\n+\t\t\t\tsampSet.add(samp[j]);\n+\t\t\t}\n+\t\t\tif (set.equals(sampSet)) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\tfail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+\t\treturn -1;\n+\t}\n+\n+\t/** tests for nextPermutation */\n+\tpublic void testNextPermutation() {\n+\t\tint[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },\n+\t\t\t\t{ 2, 0, 1 }, { 2, 1, 0 } };\n+\t\tlong[] observed = { 0, 0, 0, 0, 0, 0 };\n+\t\tdouble[] expected = { 100, 100, 100, 100, 100, 100 };\n+\n+\t\tfor (int i = 0; i < 600; i++) {\n+\t\t\tint[] perm = randomData.nextPermutation(3, 3);\n+\t\t\tobserved[findPerm(p, perm)]++;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 20.52);\n+\n+\t\t// Check size = 1 boundary case\n+\t\tint[] perm = randomData.nextPermutation(1, 1);\n+\t\tif ((perm.length != 1) || (perm[0] != 0)) {\n+\t\t\tfail(\"bad permutation for n = 1, sample k = 1\");\n+\n+\t\t\t// Make sure we fail for k size > n\n+\t\t\ttry {\n+\t\t\t\tperm = randomData.nextPermutation(2, 3);\n+\t\t\t\tfail(\"permutation k > n, expecting IllegalArgumentException\");\n+\t\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t\t// ignored\n+\t\t\t}\n+\n+\t\t\t// Make sure we fail for n = 0\n+\t\t\ttry {\n+\t\t\t\tperm = randomData.nextPermutation(0, 0);\n+\t\t\t\tfail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n+\t\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t\t// ignored\n+\t\t\t}\n+\n+\t\t\t// Make sure we fail for k < n < 0\n+\t\t\ttry {\n+\t\t\t\tperm = randomData.nextPermutation(-1, -3);\n+\t\t\t\tfail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n+\t\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t\t// ignored\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\t\n+\t// Disable until we have equals\n+\t//public void testSerial() {\n+\t//    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n+\t//}\n+\t\n+\tprivate int findPerm(int[][] p, int[] samp) {\n+\t\tfor (int i = 0; i < p.length; i++) {\n+\t\t\tboolean good = true;\n+\t\t\tfor (int j = 0; j < samp.length; j++) {\n+\t\t\t\tif (samp[j] != p[i][j]) {\n+\t\t\t\t\tgood = false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (good) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\tfail(\"permutation not found\");\n+\t\treturn -1;\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/TestRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+import java.util.Random;\n+\n+/**\n+ * Dummy AbstractRandomGenerator concrete subclass that just wraps a \n+ * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test\n+ * default implementations in AbstractRandomGenerator.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class TestRandomGenerator extends AbstractRandomGenerator {\n+\n+    private Random random = new Random();\n+\n+    @Override\n+    public void setSeed(long seed) {\n+       clear();\n+       random.setSeed(seed);\n+    }\n+\n+    @Override\n+    public double nextDouble() {\n+        return random.nextDouble();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/UncorrelatedRandomVectorGeneratorTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n+\n+import junit.framework.*;\n+\n+public class UncorrelatedRandomVectorGeneratorTest\n+extends TestCase {\n+\n+    public UncorrelatedRandomVectorGeneratorTest(String name) {\n+        super(name);\n+        mean = null;\n+        standardDeviation = null;\n+        generator = null;\n+    }\n+\n+    public void testMeanAndCorrelation() throws DimensionMismatchException {\n+\n+        VectorialMean meanStat = new VectorialMean(mean.length);\n+        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);\n+        for (int i = 0; i < 10000; ++i) {\n+            double[] v = generator.nextVector();\n+            meanStat.increment(v);\n+            covStat.increment(v);\n+        }\n+\n+        double[] estimatedMean = meanStat.getResult();\n+        double scale;\n+        RealMatrix estimatedCorrelation = covStat.getResult();\n+        for (int i = 0; i < estimatedMean.length; ++i) {\n+            assertEquals(mean[i], estimatedMean[i], 0.07);\n+            for (int j = 0; j < i; ++j) {\n+                scale = standardDeviation[i] * standardDeviation[j];\n+                assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);\n+            }\n+            scale = standardDeviation[i] * standardDeviation[i];\n+            assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        mean              = new double[] {0.0, 1.0, -3.0, 2.3};\n+        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};\n+        RandomGenerator rg = new JDKRandomGenerator();\n+        rg.setSeed(17399225432l);\n+        generator =\n+            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,\n+                    new GaussianRandomGenerator(rg));\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        mean = null;\n+        standardDeviation = null;\n+        generator = null;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class);\n+    }\n+\n+    private double[] mean;\n+    private double[] standardDeviation;\n+    private UncorrelatedRandomVectorGenerator generator;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/UniformRandomGeneratorTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.stat.StatUtils;\n+\n+import junit.framework.*;\n+\n+public class UniformRandomGeneratorTest\n+extends TestCase {\n+\n+    public UniformRandomGeneratorTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testMeanAndStandardDeviation() {\n+        RandomGenerator rg = new JDKRandomGenerator();\n+        rg.setSeed(17399225432l);\n+        UniformRandomGenerator generator = new UniformRandomGenerator(rg);\n+        double[] sample = new double[10000];\n+        for (int i = 0; i < sample.length; ++i) {\n+            sample[i] = generator.nextNormalizedDouble();\n+        }\n+        assertEquals(0.0, StatUtils.mean(sample), 0.07);\n+        assertEquals(1.0, StatUtils.variance(sample), 0.02);\n+    }\n+    \n+    \n+    public static Test suite() {\n+        return new TestSuite(UniformRandomGeneratorTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/random/ValueServerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import java.io.EOFException;\n+import java.net.URL;\n+\n+import org.apache.commons.math.RetryTestCase;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+ \n+/**\n+ * Test cases for the ValueServer class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class ValueServerTest extends RetryTestCase {\n+\n+    private ValueServer vs = new ValueServer();\n+    \n+    public ValueServerTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        vs.setMode(ValueServer.DIGEST_MODE);\n+        try {\n+            URL url = getClass().getResource(\"testData.txt\");\n+            vs.setValuesFileURL(url); \n+        } catch (Exception ex) {\n+            fail(\"malformed test URL\");\n+        }\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValueServerTest.class);\n+        suite.setName(\"ValueServer Tests\");\n+        return suite;\n+    }\n+\n+   \n+    /** \n+      * Generate 1000 random values and make sure they look OK.<br>\n+      * Note that there is a non-zero (but very small) probability that\n+      * these tests will fail even if the code is working as designed.\n+      */\n+    public void testNextDigest() throws Exception{\n+        double next = 0.0;\n+        double tolerance = 0.1;\n+        vs.computeDistribution();\n+        assertTrue(\"empirical distribution property\", \n+            vs.getEmpiricalDistribution() != null);\n+        SummaryStatistics stats = new SummaryStatistics();\n+        for (int i = 1; i < 1000; i++) {\n+            next = vs.getNext();\n+            stats.addValue(next);\n+        }    \n+        assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n+        assertEquals\n+         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), \n+            tolerance);\n+        \n+        vs.computeDistribution(500);\n+        stats = new SummaryStatistics();\n+        for (int i = 1; i < 1000; i++) {\n+            next = vs.getNext();\n+            stats.addValue(next);\n+        }    \n+        assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n+        assertEquals\n+         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), \n+            tolerance);\n+        \n+    }\n+    \n+    /**\n+      * Make sure exception thrown if digest getNext is attempted\n+      * before loading empiricalDistribution.\n+      */\n+    public void testNextDigestFail() throws Exception {\n+        try {\n+            vs.getNext();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testEmptyReplayFile() {\n+        try {\n+            URL url = getClass().getResource(\"emptyFile.txt\");\n+            vs.setMode(ValueServer.REPLAY_MODE);\n+            vs.setValuesFileURL(url);\n+            vs.getNext();\n+            fail(\"an exception should have been thrown\");\n+        } catch (EOFException eof) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testEmptyDigestFile() {\n+        try {\n+            URL url = getClass().getResource(\"emptyFile.txt\");\n+            vs.setMode(ValueServer.DIGEST_MODE);\n+            vs.setValuesFileURL(url);\n+            vs.computeDistribution();\n+            fail(\"an exception should have been thrown\");\n+        } catch (EOFException eof) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /**\n+     * Test ValueServer REPLAY_MODE using values in testData file.<br> \n+     * Check that the values 1,2,1001,1002 match data file values 1 and 2.\n+     * the sample data file.\n+     */\n+    public void testReplay() throws Exception {\n+        double firstDataValue = 4.038625496201205;\n+        double secondDataValue = 3.6485326248346936;\n+        double tolerance = 10E-15;\n+        double compareValue = 0.0d;\n+        vs.setMode(ValueServer.REPLAY_MODE);\n+        vs.resetReplayFile();\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,secondDataValue,tolerance);\n+        for (int i = 3; i < 1001; i++) {\n+           compareValue = vs.getNext();\n+        }\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,secondDataValue,tolerance);\n+        vs.closeReplayFile();\n+        // make sure no NPE\n+        vs.closeReplayFile();\n+    }\n+    \n+    /** \n+     * Test other ValueServer modes\n+     */\n+    public void testModes() throws Exception {\n+        vs.setMode(ValueServer.CONSTANT_MODE);\n+        vs.setMu(0);\n+        assertEquals(\"constant mode test\",vs.getMu(),vs.getNext(),Double.MIN_VALUE);\n+        vs.setMode(ValueServer.UNIFORM_MODE);\n+        vs.setMu(2);\n+        double val = vs.getNext();\n+        assertTrue(val > 0 && val < 4);\n+        vs.setSigma(1);\n+        vs.setMode(ValueServer.GAUSSIAN_MODE);\n+        val = vs.getNext();\n+        assertTrue(\"gaussian value close enough to mean\",\n+            val < vs.getMu() + 100*vs.getSigma());\n+        vs.setMode(ValueServer.EXPONENTIAL_MODE);\n+        val = vs.getNext();\n+        assertTrue(val > 0);\n+        try {\n+            vs.setMode(1000);\n+            vs.getNext();\n+            fail(\"bad mode, expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /**\n+     * Test fill\n+     */\n+    public void testFill() throws Exception {\n+        vs.setMode(ValueServer.CONSTANT_MODE);\n+        vs.setMu(2);\n+        double[] val = new double[5];\n+        vs.fill(val);\n+        for (int i = 0; i < 5; i++) {\n+            assertEquals(\"fill test in place\",2,val[i],Double.MIN_VALUE);\n+        }\n+        double v2[] = vs.fill(3);\n+        for (int i = 0; i < 3; i++) {\n+            assertEquals(\"fill test in place\",2,v2[i],Double.MIN_VALUE);\n+        }\n+    }\n+    \n+    /**\n+     * Test getters to make Clover happy\n+     */\n+    public void testProperties() throws Exception {\n+        vs.setMode(ValueServer.CONSTANT_MODE);\n+        assertEquals(\"mode test\",ValueServer.CONSTANT_MODE,vs.getMode());\n+        vs.setValuesFileURL(\"http://www.apache.org\");\n+        URL url = vs.getValuesFileURL();\n+        assertEquals(\"valuesFileURL test\",\"http://www.apache.org\",url.toString());\n+    }\n+                          \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/special/BetaTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class BetaTest extends TestCase {\n+    /**\n+     * Constructor for BetaTest.\n+     * @param name\n+     */\n+    public BetaTest(String name) {\n+        super(name);\n+    }\n+\n+    private void testRegularizedBeta(double expected, double x, double a,\n+        double b)\n+    {\n+        try {\n+            double actual = Beta.regularizedBeta(x, a, b);\n+            TestUtils.assertEquals(expected, actual, 10e-15);\n+        } catch(MathException ex){\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    private void testLogBeta(double expected, double a, double b) {\n+        double actual = Beta.logBeta(a, b);\n+        TestUtils.assertEquals(expected, actual, 10e-15);\n+    }\n+\n+    public void testRegularizedBetaNanPositivePositive() {\n+        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);\n+    }\n+\n+    public void testRegularizedBetaPositiveNanPositive() {\n+        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);\n+    }\n+\n+    public void testRegularizedBetaPositivePositiveNan() {\n+        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);\n+    }\n+    \n+    public void testRegularizedBetaNegativePositivePositive() {\n+        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositiveNegativePositive() {\n+        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositivePositiveNegative() {\n+        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);\n+    }\n+    \n+    public void testRegularizedBetaZeroPositivePositive() {\n+        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositiveZeroPositive() {\n+        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositivePositiveZero() {\n+        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);\n+    }\n+    \n+    public void testRegularizedBetaPositivePositivePositive() {\n+        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);\n+    }\n+    \n+    public void testLogBetaNanPositive() {\n+        testLogBeta(Double.NaN, Double.NaN, 2.0);\n+    }\n+    \n+    public void testLogBetaPositiveNan() {\n+        testLogBeta(Double.NaN, 1.0, Double.NaN);\n+    }\n+    \n+    public void testLogBetaNegativePositive() {\n+        testLogBeta(Double.NaN, -1.0, 2.0);\n+    }\n+    \n+    public void testLogBetaPositiveNegative() {\n+        testLogBeta(Double.NaN, 1.0, -2.0);\n+    }\n+    \n+    public void testLogBetaZeroPositive() {\n+        testLogBeta(Double.NaN, 0.0, 2.0);\n+    }\n+    \n+    public void testLogBetaPositiveZero() {\n+        testLogBeta(Double.NaN, 1.0, 0.0);\n+    }\n+    \n+    public void testLogBetaPositivePositive() {\n+        testLogBeta(-0.693147180559945, 1.0, 2.0);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ErfTest extends TestCase {\n+\n+    public void testErf0() throws MathException {\n+        double actual = Erf.erf(0.0);\n+        double expected = 0.0;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf1960() throws MathException {\n+        double x = 1.960 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.95;\n+        assertEquals(expected, actual, 1.0e-5);\n+\n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf2576() throws MathException {\n+        double x = 2.576 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.99;\n+        assertEquals(expected, actual, 1.0e-5);\n+    \n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf2807() throws MathException {\n+        double x = 2.807 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.995;\n+        assertEquals(expected, actual, 1.0e-5);\n+        \n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf3291() throws MathException {\n+        double x = 3.291 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.999;\n+        assertEquals(expected, actual, 1.0e-5);\n+        \n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/special/GammaTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class GammaTest extends TestCase {\n+     \n+    public GammaTest(String name) {\n+        super(name);\n+    }\n+\n+    private void testRegularizedGamma(double expected, double a, double x) {\n+        try {\n+            double actualP = Gamma.regularizedGammaP(a, x);\n+            double actualQ = Gamma.regularizedGammaQ(a, x);\n+            TestUtils.assertEquals(expected, actualP, 10e-15);\n+            TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);\n+        } catch(MathException ex){\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    private void testLogGamma(double expected, double x) {\n+        double actual = Gamma.logGamma(x);\n+        TestUtils.assertEquals(expected, actual, 10e-15);\n+    }\n+\n+    public void testRegularizedGammaNanPositive() {\n+        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);\n+    }\n+\n+    public void testRegularizedGammaPositiveNan() {\n+        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);\n+    }\n+    \n+    public void testRegularizedGammaNegativePositive() {\n+        testRegularizedGamma(Double.NaN, -1.5, 1.0);\n+    }\n+    \n+    public void testRegularizedGammaPositiveNegative() {\n+        testRegularizedGamma(Double.NaN, 1.0, -1.0);\n+    }\n+    \n+    public void testRegularizedGammaZeroPositive() {\n+        testRegularizedGamma(Double.NaN, 0.0, 1.0);\n+    }\n+    \n+    public void testRegularizedGammaPositiveZero() {\n+        testRegularizedGamma(0.0, 1.0, 0.0);\n+    }\n+    \n+    public void testRegularizedGammaPositivePositive() {\n+        testRegularizedGamma(0.632120558828558, 1.0, 1.0);\n+    }\n+    \n+    public void testLogGammaNan() {\n+        testLogGamma(Double.NaN, Double.NaN);\n+    }\n+    \n+    public void testLogGammaNegative() {\n+        testLogGamma(Double.NaN, -1.0);\n+    }\n+    \n+    public void testLogGammaZero() {\n+        testLogGamma(Double.NaN, 0.0);\n+    }\n+    \n+    public void testLogGammaPositive() {\n+        testLogGamma(0.6931471805599457, 3.0);\n+    }\n+\n+    public void testDigammaLargeArgs() {\n+        double eps = 1e-8;\n+        assertEquals(4.6001618527380874002, Gamma.digamma(100), eps);\n+        assertEquals(3.9019896734278921970, Gamma.digamma(50), eps);\n+        assertEquals(2.9705239922421490509, Gamma.digamma(20), eps);\n+        assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps);\n+        assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps);\n+        assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps);\n+        assertEquals(1.8727843350984671394, Gamma.digamma(7), eps);\n+        assertEquals(0.42278433509846713939, Gamma.digamma(2), eps);\n+        assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps);\n+        assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps);\n+        assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps);\n+    }\n+\n+    public void testDigammaSmallArgs() {\n+        // values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits\n+        // see functions.wolfram.com\n+        double[] expected = {-10.423754940411076795, -100.56088545786867450, -1000.5755719318103005,\n+                -10000.577051183514335, -100000.57719921568107, -1.0000005772140199687e6, -1.0000000577215500408e7,\n+                -1.0000000057721564845e8, -1.0000000005772156633e9, -1.0000000000577215665e10, -1.0000000000057721566e11,\n+                -1.0000000000005772157e12, -1.0000000000000577216e13, -1.0000000000000057722e14, -1.0000000000000005772e15, -1e+16,\n+                -1e+17, -1e+18, -1e+19, -1e+20, -1e+21, -1e+22, -1e+23, -1e+24, -1e+25, -1e+26,\n+                -1e+27, -1e+28, -1e+29, -1e+30};\n+        for (double n = 1; n < 30; n++) {\n+            checkRelativeError(String.format(\"Test %.0f: \", n), expected[(int) (n - 1)], Gamma.digamma(Math.pow(10.0, -n)), 1e-8);\n+        }\n+    }\n+\n+    public void testTrigamma() {\n+        double eps = 1e-8;\n+        // computed using webMathematica.  For example, to compute trigamma($i) = Polygamma(1, $i), use\n+        //\n+        // http://functions.wolfram.com/webMathematica/Evaluated.jsp?name=PolyGamma2&plottype=0&vars={%221%22,%22$i%22}&digits=20\n+        double[] data = {\n+                1e-4, 1.0000000164469368793e8,\n+                1e-3, 1.0000016425331958690e6,\n+                1e-2, 10001.621213528313220,\n+                1e-1, 101.43329915079275882,\n+                1, 1.6449340668482264365,\n+                2, 0.64493406684822643647,\n+                3, 0.39493406684822643647,\n+                4, 0.28382295573711532536,\n+                5, 0.22132295573711532536,\n+                10, 0.10516633568168574612,\n+                20, 0.051270822935203119832,\n+                50, 0.020201333226697125806,\n+                100, 0.010050166663333571395\n+        };\n+        for (int i = data.length - 2; i >= 0; i -= 2) {\n+            assertEquals(String.format(\"trigamma %.0f\", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps);\n+        }\n+    }\n+\n+    private void checkRelativeError(String msg, double expected, double actual, double tolerance) {\n+        assertEquals(msg, expected, actual, Math.abs(tolerance * actual));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/CertifiedDataTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+\n+/**\n+ * Certified data test cases.\n+ * @version $Revision$ $Date$\n+ */\n+public class CertifiedDataTest extends TestCase  {\n+\n+    protected double mean = Double.NaN;\n+\n+    protected double std = Double.NaN;\n+\n+    /**\n+     * Certified Data Test Constructor\n+     * @param name\n+     */\n+    public CertifiedDataTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * @return The test suite\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CertifiedDataTest.class);\n+        suite.setName(\"Certified Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Test SummaryStatistics - implementations that do not store the data\n+     * and use single pass algorithms to compute statistics\n+    */\n+    public void testSummaryStatistics() throws Exception {\n+        SummaryStatistics u = new SummaryStatistics();\n+        loadStats(\"data/PiDigits.txt\", u);\n+        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-13);\n+        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-13);  \n+\n+        loadStats(\"data/Mavro.txt\", u);\n+        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n+        \n+        loadStats(\"data/Michelso.txt\", u);\n+        assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-13);\n+        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-13);   \n+                                        \n+        loadStats(\"data/NumAcc1.txt\", u);\n+        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n+        \n+        loadStats(\"data/NumAcc2.txt\", u);\n+        assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n+    }\n+\n+    /**\n+     * Test DescriptiveStatistics - implementations that store full array of\n+     * values and execute multi-pass algorithms\n+     */\n+    public void testDescriptiveStatistics() throws Exception {\n+\n+        DescriptiveStatistics u = new DescriptiveStatistics();\n+        \n+        loadStats(\"data/PiDigits.txt\", u);\n+        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-14);\n+        \n+        loadStats(\"data/Mavro.txt\", u);\n+        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);        \n+        \n+        loadStats(\"data/Michelso.txt\", u);\n+        assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-14);   \n+\n+        loadStats(\"data/NumAcc1.txt\", u);\n+        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n+        \n+        loadStats(\"data/NumAcc2.txt\", u);\n+        assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n+    }\n+\n+    /**\n+     * loads a DescriptiveStatistics off of a test file\n+     * @param file\n+     * @param statistical summary\n+     */\n+    private void loadStats(String resource, Object u) throws Exception {\n+        \n+        DescriptiveStatistics d = null;\n+        SummaryStatistics s = null;\n+        if (u instanceof DescriptiveStatistics) {\n+            d = (DescriptiveStatistics) u;\n+        } else {\n+            s = (SummaryStatistics) u;\n+        }\n+        u.getClass().getDeclaredMethod(\n+                \"clear\", new Class[]{}).invoke(u, new Object[]{});\n+        mean = Double.NaN;\n+        std = Double.NaN;\n+        \n+        BufferedReader in =\n+            new BufferedReader(\n+                    new InputStreamReader(\n+                            CertifiedDataTest.class.getResourceAsStream(resource)));\n+        \n+        String line = null;\n+        \n+        for (int j = 0; j < 60; j++) {\n+            line = in.readLine();\n+            if (j == 40) {\n+                mean =\n+                    Double.parseDouble(\n+                            line.substring(line.lastIndexOf(\":\") + 1).trim());\n+            }\n+            if (j == 41) {\n+                std =\n+                    Double.parseDouble(\n+                            line.substring(line.lastIndexOf(\":\") + 1).trim());\n+            }\n+        }\n+        \n+        line = in.readLine();\n+        \n+        while (line != null) {\n+            if (d != null) {\n+                d.addValue(Double.parseDouble(line.trim()));\n+            }  else {\n+                s.addValue(Double.parseDouble(line.trim()));\n+            }\n+            line = in.readLine();\n+        }\n+        \n+        in.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/FrequencyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.Iterator;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Frequency} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class FrequencyTest extends TestCase {\n+    private long oneL = 1;\n+    private long twoL = 2;\n+    private long threeL = 3;\n+    private int oneI = 1;\n+    private int twoI = 2;\n+    private int threeI=3;\n+    private double tolerance = 10E-15;\n+    private Frequency f = null;\n+    \n+    public FrequencyTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() {  \n+        f = new Frequency();\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FrequencyTest.class);\n+        suite.setName(\"Frequency Tests\");\n+        return suite;\n+    }\n+    \n+    /** test freq counts */\n+    public void testCounts() {\n+        assertEquals(\"total count\",0,f.getSumFreq());\n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(1);\n+        f.addValue(oneI);\n+        assertEquals(\"one frequency count\",3,f.getCount(1));\n+        assertEquals(\"two frequency count\",1,f.getCount(2));\n+        assertEquals(\"three frequency count\",0,f.getCount(3));\n+        assertEquals(\"total count\",4,f.getSumFreq());\n+        assertEquals(\"zero cumulative frequency\", 0, f.getCumFreq(0));\n+        assertEquals(\"one cumulative frequency\", 3,  f.getCumFreq(1));\n+        assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(2));\n+        assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(Integer.valueOf(2)));\n+        assertEquals(\"five cumulative frequency\", 4,  f.getCumFreq(5));\n+        assertEquals(\"foo cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n+        \n+        f.clear();\n+        assertEquals(\"total count\",0,f.getSumFreq());\n+        \n+        // userguide examples -------------------------------------------------------------------\n+        f.addValue(\"one\");\n+        f.addValue(\"One\");\n+        f.addValue(\"oNe\");\n+        f.addValue(\"Z\");\n+        assertEquals(\"one cumulative frequency\", 1 ,  f.getCount(\"one\"));\n+        assertEquals(\"Z cumulative pct\", 0.5,  f.getCumPct(\"Z\"), tolerance);\n+        assertEquals(\"z cumulative pct\", 1.0,  f.getCumPct(\"z\"), tolerance);\n+        assertEquals(\"Ot cumulative pct\", 0.25,  f.getCumPct(\"Ot\"), tolerance);\n+        f.clear();\n+        \n+        f = null;\n+        Frequency f = new Frequency();\n+        f.addValue(1);\n+        f.addValue(Integer.valueOf(1));\n+        f.addValue(Long.valueOf(1));\n+        f.addValue(2);\n+        f.addValue(Integer.valueOf(-1));\n+        assertEquals(\"1 count\", 3, f.getCount(1));\n+        assertEquals(\"1 count\", 3, f.getCount(Integer.valueOf(1)));\n+        assertEquals(\"0 cum pct\", 0.2, f.getCumPct(0), tolerance);\n+        assertEquals(\"1 pct\", 0.6, f.getPct(Integer.valueOf(1)), tolerance);\n+        assertEquals(\"-2 cum pct\", 0, f.getCumPct(-2), tolerance);\n+        assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);   \n+        \n+        f = null;\n+        f = new Frequency(String.CASE_INSENSITIVE_ORDER);\n+        f.addValue(\"one\");\n+        f.addValue(\"One\");\n+        f.addValue(\"oNe\");\n+        f.addValue(\"Z\");\n+        assertEquals(\"one count\", 3 ,  f.getCount(\"one\"));\n+        assertEquals(\"Z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"Z\"), tolerance);\n+        assertEquals(\"z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"z\"), tolerance);\n+\n+        f = null;\n+        f = new Frequency();\n+        assertEquals(0L, f.getCount('a'));\n+        assertEquals(0L, f.getCumFreq('b'));\n+        TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);\n+        TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);\n+        f.addValue('a');\n+        f.addValue('b');\n+        f.addValue('c');\n+        f.addValue('d');\n+        assertEquals(1L, f.getCount('a'));\n+        assertEquals(2L, f.getCumFreq('b'));\n+        assertEquals(0.25, f.getPct('a'), 0.0);\n+        assertEquals(0.5, f.getCumPct('b'), 0.0);\n+        assertEquals(1.0, f.getCumPct('e'), 0.0);\n+    }     \n+    \n+    /** test pcts */\n+    public void testPcts() {\n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(oneI);\n+        f.addValue(twoI);\n+        f.addValue(threeL);\n+        f.addValue(threeL);\n+        f.addValue(3);\n+        f.addValue(threeI);\n+        assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n+        assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n+        assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n+        assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n+        assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n+        assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n+        assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n+        assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n+        assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n+        assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n+        assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n+        assertEquals(\"foo cum pct\",0,f.getCumPct(\"foo\"),tolerance);\n+    }\n+    \n+    /** test adding incomparable values */\n+    public void testAdd() {\n+        char aChar = 'a';\n+        char bChar = 'b';\n+        String aString = \"a\";\n+        f.addValue(aChar);\n+        f.addValue(bChar);\n+        try {\n+            f.addValue(aString);    \n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            f.addValue(2);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(\"a pct\",0.5,f.getPct(aChar),tolerance);\n+        assertEquals(\"b cum pct\",1.0,f.getCumPct(bChar),tolerance);\n+        assertEquals(\"a string pct\",0.0,f.getPct(aString),tolerance);\n+        assertEquals(\"a string cum pct\",0.0,f.getCumPct(aString),tolerance);\n+        \n+        f = new Frequency();\n+        f.addValue(\"One\");\n+        try {\n+            f.addValue(new Integer(\"One\")); \n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    // Check what happens when non-Comparable objects are added\n+    @SuppressWarnings(\"deprecation\")\n+    public void testAddNonComparable(){\n+        try {\n+            f.addValue(new Object()); // This was previously OK\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+        f.clear();\n+        f.addValue(1);\n+        try {\n+            f.addValue(new Object());\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+    }\n+\n+    /** test empty table */\n+    public void testEmptyTable() {\n+        assertEquals(\"freq sum, empty table\", 0, f.getSumFreq());\n+        assertEquals(\"count, empty table\", 0, f.getCount(0));\n+        assertEquals(\"count, empty table\",0, f.getCount(Integer.valueOf(0)));\n+        assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(0));\n+        assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(\"x\"));\n+        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(0)));\n+        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(Integer.valueOf(0))));\n+        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(0)));\n+        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));   \n+    }\n+    \n+    /**\n+     * Tests toString() \n+     */\n+    public void testToString(){\n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(oneI);\n+        f.addValue(twoI);\n+        \n+        String s = f.toString();\n+        //System.out.println(s);\n+        assertNotNull(s);\n+        BufferedReader reader = new BufferedReader(new StringReader(s));\n+        try {\n+            String line = reader.readLine(); // header line\n+            assertNotNull(line);\n+            \n+            line = reader.readLine(); // one's or two's line\n+            assertNotNull(line);\n+                        \n+            line = reader.readLine(); // one's or two's line\n+            assertNotNull(line);\n+\n+            line = reader.readLine(); // no more elements\n+            assertNull(line);\n+        } catch(IOException ex){\n+            fail(ex.getMessage());\n+        }        \n+    }\n+    public void testIntegerValues() {\n+        Comparable<?> obj1 = null;\n+        obj1 = Integer.valueOf(1);\n+        Integer int1 = Integer.valueOf(1);\n+        f.addValue(obj1);\n+        f.addValue(int1);\n+        f.addValue(2);\n+        f.addValue(Long.valueOf(2));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(1));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(Integer.valueOf(1)));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(Long.valueOf(1)));\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(1), tolerance);\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);\n+        Iterator<?> it = f.valuesIterator();\n+        while (it.hasNext()) {\n+            assertTrue(it.next() instanceof Long);\n+        }     \n+    }\n+    \n+    public void testSerial() {\n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(oneI);\n+        f.addValue(twoI);\n+        assertEquals(f, TestUtils.serializeAndRecover(f));\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link StatUtils} class.\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class StatUtilsTest extends TestCase {\n+\n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double min = 1;\n+    private double max = 3;\n+    private double tolerance = 10E-15;\n+    private double nan = Double.NaN;\n+\n+    public StatUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StatUtilsTest.class);\n+        suite.setName(\"StatUtil Tests\");\n+        return suite;\n+    }\n+\n+    /** test stats */\n+    public void testStats() {\n+        double[] values = new double[] { one, two, two, three };\n+        assertEquals(\"sum\", sum, StatUtils.sum(values), tolerance);\n+        assertEquals(\"sumsq\", sumSq, StatUtils.sumSq(values), tolerance);\n+        assertEquals(\"var\", var, StatUtils.variance(values), tolerance);\n+        assertEquals(\"var with mean\", var, StatUtils.variance(values, mean), tolerance);\n+        assertEquals(\"mean\", mean, StatUtils.mean(values), tolerance);\n+        assertEquals(\"min\", min, StatUtils.min(values), tolerance);\n+        assertEquals(\"max\", max, StatUtils.max(values), tolerance);\n+    }\n+\n+    public void testN0andN1Conditions() throws Exception {\n+        double[] values = new double[0];\n+\n+        assertTrue(\n+            \"Mean of n = 0 set should be NaN\",\n+            Double.isNaN(StatUtils.mean(values)));\n+        assertTrue(\n+            \"Variance of n = 0 set should be NaN\",\n+            Double.isNaN(StatUtils.variance(values)));\n+\n+        values = new double[] { one };\n+\n+        assertTrue(\n+            \"Mean of n = 1 set should be value of single item n1\",\n+            StatUtils.mean(values) == one);\n+        assertTrue(\n+            \"Variance of n = 1 set should be zero\",\n+            StatUtils.variance(values) == 0);\n+    }\n+\n+    public void testArrayIndexConditions() throws Exception {\n+        double[] values = { 1.0, 2.0, 3.0, 4.0 };\n+\n+        assertEquals(\n+            \"Sum not expected\",\n+            5.0,\n+            StatUtils.sum(values, 1, 2),\n+            Double.MIN_VALUE);\n+        assertEquals(\n+            \"Sum not expected\",\n+            3.0,\n+            StatUtils.sum(values, 0, 2),\n+            Double.MIN_VALUE);\n+        assertEquals(\n+            \"Sum not expected\",\n+            7.0,\n+            StatUtils.sum(values, 2, 2),\n+            Double.MIN_VALUE);\n+\n+        try {\n+            StatUtils.sum(values, 2, 3);\n+            assertTrue(\"Didn't throw exception\", false);\n+        } catch (Exception e) {\n+            assertTrue(true);\n+        }\n+\n+        try {\n+            StatUtils.sum(values, -1, 2);\n+            assertTrue(\"Didn't throw exception\", false);\n+        } catch (Exception e) {\n+            assertTrue(true);\n+        }\n+\n+    }\n+    \n+    public void testSumSq() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.sumSq(x);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.sumSq(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);\n+    }\n+    \n+    public void testProduct() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.product(x);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.product(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);\n+    }\n+    \n+    public void testSumLog() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.sumLog(x);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.sumLog(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);\n+    }\n+    \n+    public void testMean() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.mean(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);\n+    }\n+    \n+    public void testVariance() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.variance(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);\n+        \n+        // test precomputed mean\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);\n+    }\n+    \n+    public void testMax() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.max(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);\n+\n+        // test first nan is ignored\n+        x = new double[] {nan, two, three};\n+        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);\n+\n+        // test middle nan is ignored\n+        x = new double[] {one, nan, three};\n+        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);\n+        \n+        // test last nan is ignored\n+        x = new double[] {one, two, nan};\n+        TestUtils.assertEquals(two, StatUtils.max(x), tolerance);\n+\n+        // test all nan returns nan\n+        x = new double[] {nan, nan, nan};\n+        TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);\n+    }\n+    \n+    public void testMin() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.min(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);\n+\n+        // test first nan is ignored\n+        x = new double[] {nan, two, three};\n+        TestUtils.assertEquals(two, StatUtils.min(x), tolerance);\n+\n+        // test middle nan is ignored\n+        x = new double[] {one, nan, three};\n+        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);\n+        \n+        // test last nan is ignored\n+        x = new double[] {one, two, nan};\n+        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);\n+\n+        // test all nan returns nan\n+        x = new double[] {nan, nan, nan};\n+        TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);\n+    }\n+    \n+    public void testPercentile() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.percentile(x, .25);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.percentile(x, 0, 4, 0.25);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);\n+        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);\n+        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);\n+    }\n+    \n+    public void testDifferenceStats() throws Exception {\n+        double sample1[] = {1d, 2d, 3d, 4d};\n+        double sample2[] = {1d, 3d, 4d, 2d};\n+        double diff[] = {0d, -1d, -1d, 2d};\n+        double small[] = {1d, 4d};\n+        double meanDifference = StatUtils.meanDifference(sample1, sample2);\n+        assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);\n+        assertEquals(meanDifference, StatUtils.mean(diff), tolerance);\n+        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference), \n+                StatUtils.variance(diff), tolerance);\n+        try {\n+            StatUtils.meanDifference(sample1, small);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            StatUtils.varianceDifference(sample1, small, meanDifference);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            double[] single = {1.0};\n+            StatUtils.varianceDifference(single, single, meanDifference);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGeometricMean() throws Exception {\n+        double[] test = null;\n+        try {\n+            StatUtils.geometricMean(test);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        test = new double[] {2, 4, 6, 8};\n+        assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)), \n+                StatUtils.geometricMean(test), Double.MIN_VALUE);\n+        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)), \n+                StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Test;\n+\n+public class EuclideanIntegerPointTest {\n+\n+    @Test\n+    public void testArrayIsReference() {\n+        int[] array = { -3, -2, -1, 0, 1 };\n+        assertTrue(array == new EuclideanIntegerPoint(array).getPoint());\n+    }\n+    \n+    @Test\n+    public void testDistance() {\n+        EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n+        EuclideanIntegerPoint e2 = new EuclideanIntegerPoint(new int[] {  1,  0, -1, 1, 1 });\n+        assertEquals(Math.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);\n+        assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);\n+        assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);\n+    }\n+    \n+    @Test\n+    public void testCentroid() {\n+        List<EuclideanIntegerPoint> list = new ArrayList<EuclideanIntegerPoint>();\n+        list.add(new EuclideanIntegerPoint(new int[] {  1,  3 }));\n+        list.add(new EuclideanIntegerPoint(new int[] {  2,  2 }));\n+        list.add(new EuclideanIntegerPoint(new int[] {  3,  3 }));\n+        list.add(new EuclideanIntegerPoint(new int[] {  2,  4 }));\n+        EuclideanIntegerPoint c = list.get(0).centroidOf(list);\n+        assertEquals(2, c.getPoint()[0]);\n+        assertEquals(3, c.getPoint()[1]);\n+    }\n+    \n+    @Test\n+    public void testSerial() {\n+        EuclideanIntegerPoint p = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n+        assertEquals(p, TestUtils.serializeAndRecover(p));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.junit.Test;\n+\n+public class KMeansPlusPlusClustererTest {\n+\n+    @Test\n+    public void dimension2() {\n+        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =\n+            new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));\n+        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n+\n+                // first expected cluster\n+                new EuclideanIntegerPoint(new int[] { -15,  3 }),\n+                new EuclideanIntegerPoint(new int[] { -15,  4 }),\n+                new EuclideanIntegerPoint(new int[] { -15,  5 }),\n+                new EuclideanIntegerPoint(new int[] { -14,  3 }),\n+                new EuclideanIntegerPoint(new int[] { -14,  5 }),\n+                new EuclideanIntegerPoint(new int[] { -13,  3 }),\n+                new EuclideanIntegerPoint(new int[] { -13,  4 }),\n+                new EuclideanIntegerPoint(new int[] { -13,  5 }),\n+\n+                // second expected cluster\n+                new EuclideanIntegerPoint(new int[] { -1,  0 }),\n+                new EuclideanIntegerPoint(new int[] { -1, -1 }),\n+                new EuclideanIntegerPoint(new int[] {  0, -1 }),\n+                new EuclideanIntegerPoint(new int[] {  1, -1 }),\n+                new EuclideanIntegerPoint(new int[] {  1, -2 }),\n+\n+                // third expected cluster\n+                new EuclideanIntegerPoint(new int[] { 13,  3 }),\n+                new EuclideanIntegerPoint(new int[] { 13,  4 }),\n+                new EuclideanIntegerPoint(new int[] { 14,  4 }),\n+                new EuclideanIntegerPoint(new int[] { 14,  7 }),\n+                new EuclideanIntegerPoint(new int[] { 16,  5 }),\n+                new EuclideanIntegerPoint(new int[] { 16,  6 }),\n+                new EuclideanIntegerPoint(new int[] { 17,  4 }),\n+                new EuclideanIntegerPoint(new int[] { 17,  7 })\n+\n+        };\n+        List<Cluster<EuclideanIntegerPoint>> clusters =\n+            transformer.cluster(Arrays.asList(points), 3, 10);\n+\n+        assertEquals(3, clusters.size());\n+        boolean cluster1Found = false;\n+        boolean cluster2Found = false;\n+        boolean cluster3Found = false;\n+        for (Cluster<EuclideanIntegerPoint> cluster : clusters) {\n+            int[] center = cluster.getCenter().getPoint();\n+            if (center[0] < 0) {\n+                cluster1Found = true;\n+                assertEquals(8, cluster.getPoints().size());\n+                assertEquals(-14, center[0]);\n+                assertEquals( 4, center[1]);\n+            } else if (center[1] < 0) {\n+                cluster2Found = true;\n+                assertEquals(5, cluster.getPoints().size());\n+                assertEquals( 0, center[0]);\n+                assertEquals(-1, center[1]);\n+            } else {\n+                cluster3Found = true;\n+                assertEquals(8, cluster.getPoints().size());\n+                assertEquals(15, center[0]);\n+                assertEquals(5, center[1]);\n+            }\n+        }\n+        assertTrue(cluster1Found);\n+        assertTrue(cluster2Found);\n+        assertTrue(cluster3Found);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/CovarianceTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.correlation;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+\n+import junit.framework.TestCase;\n+\n+public class CovarianceTest extends TestCase {\n+    \n+    protected final double[] longleyData = new double[] {\n+            60323,83.0,234289,2356,1590,107608,1947,\n+            61122,88.5,259426,2325,1456,108632,1948,\n+            60171,88.2,258054,3682,1616,109773,1949,\n+            61187,89.5,284599,3351,1650,110929,1950,\n+            63221,96.2,328975,2099,3099,112075,1951,\n+            63639,98.1,346999,1932,3594,113270,1952,\n+            64989,99.0,365385,1870,3547,115094,1953,\n+            63761,100.0,363112,3578,3350,116219,1954,\n+            66019,101.2,397469,2904,3048,117388,1955,\n+            67857,104.6,419180,2822,2857,118734,1956,\n+            68169,108.4,442769,2936,2798,120445,1957,\n+            66513,110.8,444546,4681,2637,121950,1958,\n+            68655,112.6,482704,3813,2552,123366,1959,\n+            69564,114.2,502601,3931,2514,125368,1960,\n+            69331,115.7,518173,4806,2572,127852,1961,\n+            70551,116.9,554894,4007,2827,130081,1962\n+        };\n+    \n+    protected final double[] swissData = new double[] {\n+            80.2,17.0,15,12,9.96,\n+            83.1,45.1,6,9,84.84,\n+            92.5,39.7,5,5,93.40,\n+            85.8,36.5,12,7,33.77,\n+            76.9,43.5,17,15,5.16,\n+            76.1,35.3,9,7,90.57,\n+            83.8,70.2,16,7,92.85,\n+            92.4,67.8,14,8,97.16,\n+            82.4,53.3,12,7,97.67,\n+            82.9,45.2,16,13,91.38,\n+            87.1,64.5,14,6,98.61,\n+            64.1,62.0,21,12,8.52,\n+            66.9,67.5,14,7,2.27,\n+            68.9,60.7,19,12,4.43,\n+            61.7,69.3,22,5,2.82,\n+            68.3,72.6,18,2,24.20,\n+            71.7,34.0,17,8,3.30,\n+            55.7,19.4,26,28,12.11,\n+            54.3,15.2,31,20,2.15,\n+            65.1,73.0,19,9,2.84,\n+            65.5,59.8,22,10,5.23,\n+            65.0,55.1,14,3,4.52,\n+            56.6,50.9,22,12,15.14,\n+            57.4,54.1,20,6,4.20,\n+            72.5,71.2,12,1,2.40,\n+            74.2,58.1,14,8,5.23,\n+            72.0,63.5,6,3,2.56,\n+            60.5,60.8,16,10,7.72,\n+            58.3,26.8,25,19,18.46,\n+            65.4,49.5,15,8,6.10,\n+            75.5,85.9,3,2,99.71,\n+            69.3,84.9,7,6,99.68,\n+            77.3,89.7,5,2,100.00,\n+            70.5,78.2,12,6,98.96,\n+            79.4,64.9,7,3,98.22,\n+            65.0,75.9,9,9,99.06,\n+            92.2,84.6,3,3,99.46,\n+            79.3,63.1,13,13,96.83,\n+            70.4,38.4,26,12,5.62,\n+            65.7,7.7,29,11,13.79,\n+            72.7,16.7,22,13,11.22,\n+            64.4,17.6,35,32,16.92,\n+            77.6,37.6,15,7,4.97,\n+            67.6,18.7,25,7,8.65,\n+            35.0,1.2,37,53,42.34,\n+            44.7,46.6,16,29,50.43,\n+            42.8,27.7,22,29,58.33\n+        };\n+ \n+    \n+    /**\n+     * Test Longley dataset against R.\n+     * Data Source: J. Longley (1967) \"An Appraisal of Least Squares\n+     * Programs for the Electronic Computer from the Point of View of the User\"\n+     * Journal of the American Statistical Association, vol. 62. September,\n+     * pp. 819-841.\n+     * \n+     * Data are from NIST:\n+     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat\n+     */\n+    public void testLongly() {  \n+        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n+        RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n+        double[] rData = new double[] {\n+         12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,\n+         1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,\n+         36796.66000000000, 1.164576250000000e+02, 1063604.115416667,\n+         6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,\n+         343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,\n+         56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,\n+         1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,\n+         873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,\n+         1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,\n+         -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,\n+         23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,\n+         4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,\n+         16240.93333333333, 5.092333333333334e+01, 470977.900000000,\n+         2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667\n+        };\n+        \n+        TestUtils.assertEquals(\"covariance matrix\", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9);\n+\n+    }\n+    \n+    /**\n+     * Test R Swiss fertility dataset against R.\n+     * Data Source: R datasets package\n+     */\n+    public void testSwissFertility() {\n+         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n+         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n+         double[] rData = new double[] {\n+           156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,\n+           100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,\n+           -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,\n+           -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,\n+            241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890\n+         };\n+         \n+         TestUtils.assertEquals(\"covariance matrix\", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);\n+    }\n+    \n+    /**\n+     * Constant column\n+     */\n+    public void testConstant() {\n+        double[] noVariance = new double[] {1, 1, 1, 1};\n+        double[] values = new double[] {1, 2, 3, 4};\n+        assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);\n+        assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);\n+    }\n+    \n+    \n+    /**\n+     * Insufficient data\n+     */\n+    public void testInsufficientData() {\n+        double[] one = new double[] {1};\n+        double[] two = new double[] {2};\n+        try {\n+            new Covariance().covariance(one, two, false);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {{0},{1}});\n+        try {\n+            new Covariance(matrix);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+    }\n+    \n+    /**\n+     * Verify that diagonal entries are consistent with Variance computation and matrix matches\n+     * column-by-column covariances\n+     */\n+    public void testConsistency() {\n+        final RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n+        final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n+        \n+        // Variances on the diagonal\n+        Variance variance = new Variance();\n+        for (int i = 0; i < 5; i++) {\n+            assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);\n+        }\n+        \n+        // Symmetry, column-consistency\n+        assertEquals(covarianceMatrix.getEntry(2, 3), \n+                new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);\n+        assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);\n+        \n+        // All columns same -> all entries = column variance\n+        RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);\n+        for (int i = 0; i < 3; i++) {\n+            repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0));\n+        }\n+        RealMatrix repeatedCovarianceMatrix = new Covariance(repeatedColumns).getCovarianceMatrix();\n+        double columnVariance = variance.evaluate(matrix.getColumn(0));\n+        for (int i = 0; i < 3; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);\n+            }\n+        }\n+        \n+        // Check bias-correction defaults\n+        double[][] data = matrix.getData();\n+        TestUtils.assertEquals(\"Covariances\", \n+                covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);\n+        TestUtils.assertEquals(\"Covariances\", \n+                covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE);\n+        \n+        double[] x = data[0];\n+        double[] y = data[1];\n+        assertEquals(new Covariance().covariance(x, y), \n+                new Covariance().covariance(x, y, true), Double.MIN_VALUE); \n+    }\n+    \n+    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {\n+        double[][] matrixData = new double[nRows][nCols];\n+        int ptr = 0;\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data, ptr, matrixData[i], 0, nCols);\n+            ptr += nCols;\n+        }\n+        return new Array2DRowRealMatrix(matrixData); \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.correlation;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.distribution.TDistribution;\n+import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+\n+import junit.framework.TestCase;\n+\n+public class PearsonsCorrelationTest extends TestCase {\n+    \n+    protected final double[] longleyData = new double[] {\n+            60323,83.0,234289,2356,1590,107608,1947,\n+            61122,88.5,259426,2325,1456,108632,1948,\n+            60171,88.2,258054,3682,1616,109773,1949,\n+            61187,89.5,284599,3351,1650,110929,1950,\n+            63221,96.2,328975,2099,3099,112075,1951,\n+            63639,98.1,346999,1932,3594,113270,1952,\n+            64989,99.0,365385,1870,3547,115094,1953,\n+            63761,100.0,363112,3578,3350,116219,1954,\n+            66019,101.2,397469,2904,3048,117388,1955,\n+            67857,104.6,419180,2822,2857,118734,1956,\n+            68169,108.4,442769,2936,2798,120445,1957,\n+            66513,110.8,444546,4681,2637,121950,1958,\n+            68655,112.6,482704,3813,2552,123366,1959,\n+            69564,114.2,502601,3931,2514,125368,1960,\n+            69331,115.7,518173,4806,2572,127852,1961,\n+            70551,116.9,554894,4007,2827,130081,1962\n+        };\n+    \n+    protected final double[] swissData = new double[] {\n+            80.2,17.0,15,12,9.96,\n+            83.1,45.1,6,9,84.84,\n+            92.5,39.7,5,5,93.40,\n+            85.8,36.5,12,7,33.77,\n+            76.9,43.5,17,15,5.16,\n+            76.1,35.3,9,7,90.57,\n+            83.8,70.2,16,7,92.85,\n+            92.4,67.8,14,8,97.16,\n+            82.4,53.3,12,7,97.67,\n+            82.9,45.2,16,13,91.38,\n+            87.1,64.5,14,6,98.61,\n+            64.1,62.0,21,12,8.52,\n+            66.9,67.5,14,7,2.27,\n+            68.9,60.7,19,12,4.43,\n+            61.7,69.3,22,5,2.82,\n+            68.3,72.6,18,2,24.20,\n+            71.7,34.0,17,8,3.30,\n+            55.7,19.4,26,28,12.11,\n+            54.3,15.2,31,20,2.15,\n+            65.1,73.0,19,9,2.84,\n+            65.5,59.8,22,10,5.23,\n+            65.0,55.1,14,3,4.52,\n+            56.6,50.9,22,12,15.14,\n+            57.4,54.1,20,6,4.20,\n+            72.5,71.2,12,1,2.40,\n+            74.2,58.1,14,8,5.23,\n+            72.0,63.5,6,3,2.56,\n+            60.5,60.8,16,10,7.72,\n+            58.3,26.8,25,19,18.46,\n+            65.4,49.5,15,8,6.10,\n+            75.5,85.9,3,2,99.71,\n+            69.3,84.9,7,6,99.68,\n+            77.3,89.7,5,2,100.00,\n+            70.5,78.2,12,6,98.96,\n+            79.4,64.9,7,3,98.22,\n+            65.0,75.9,9,9,99.06,\n+            92.2,84.6,3,3,99.46,\n+            79.3,63.1,13,13,96.83,\n+            70.4,38.4,26,12,5.62,\n+            65.7,7.7,29,11,13.79,\n+            72.7,16.7,22,13,11.22,\n+            64.4,17.6,35,32,16.92,\n+            77.6,37.6,15,7,4.97,\n+            67.6,18.7,25,7,8.65,\n+            35.0,1.2,37,53,42.34,\n+            44.7,46.6,16,29,50.43,\n+            42.8,27.7,22,29,58.33\n+        };\n+ \n+    \n+    /**\n+     * Test Longley dataset against R.\n+     */\n+    public void testLongly() throws Exception {  \n+        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n+        double[] rData = new double[] {\n+                1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942,\n+                0.4573073999764817, 0.960390571594376, 0.9713294591921188,\n+                0.970898525061056, 1.0000000000000000, 0.9915891780247822, 0.6206333925590966,\n+                0.4647441876006747, 0.979163432977498, 0.9911491900672053,\n+                0.983551611179669, 0.9915891780247822, 1.0000000000000000, 0.6042609398895580,\n+                0.4464367918926265, 0.991090069458478, 0.9952734837647849,\n+                0.502498083875994, 0.6206333925590966, 0.6042609398895580, 1.0000000000000000,\n+                -0.1774206295018783, 0.686551516365312, 0.6682566045621746,\n+                0.457307399976482, 0.4647441876006747, 0.4464367918926265, -0.1774206295018783,\n+                1.0000000000000000, 0.364416267189032, 0.4172451498349454,\n+                0.960390571594376, 0.9791634329774981, 0.9910900694584777, 0.6865515163653120,\n+                0.3644162671890320, 1.000000000000000, 0.9939528462329257,\n+                0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746,\n+                0.4172451498349454, 0.993952846232926, 1.0000000000000000\n+        }; \n+        TestUtils.assertEquals(\"correlation matrix\", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);\n+        \n+        double[] rPvalues = new double[] {\n+                4.38904690369668e-10,\n+                8.36353208910623e-12, 7.8159700933611e-14,\n+                0.0472894097790304, 0.01030636128354301, 0.01316878049026582, \n+                0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452,\n+                3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684, \n+                3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15\n+        };\n+        RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7);\n+        fillUpper(rPMatrix, 0d);\n+        TestUtils.assertEquals(\"correlation p values\", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);\n+    }\n+    \n+    /**\n+     * Test R Swiss fertility dataset against R.\n+     */\n+    public void testSwissFertility() throws Exception {\n+         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n+         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n+         double[] rData = new double[] {\n+               1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691,  0.4636847006517939,\n+                 0.3530791836199747, 1.0000000000000000,-0.6865422086171366, -0.6395225189483201, 0.4010950530487398,\n+                -0.6458827064572875, -0.6865422086171366, 1.0000000000000000, 0.6984152962884830, -0.5727418060641666,\n+                -0.6637888570350691, -0.6395225189483201, 0.6984152962884830, 1.0000000000000000, -0.1538589170909148,\n+                 0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000\n+         };\n+         TestUtils.assertEquals(\"correlation matrix\", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);\n+         \n+         double[] rPvalues = new double[] {\n+                 0.01491720061472623,\n+                 9.45043734069043e-07, 9.95151527133974e-08,\n+                 3.658616965962355e-07, 1.304590105694471e-06, 4.811397236181847e-08,\n+                 0.001028523190118147, 0.005204433539191644, 2.588307925380906e-05, 0.301807756132683\n+         };\n+         RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 5);\n+         fillUpper(rPMatrix, 0d);\n+         TestUtils.assertEquals(\"correlation p values\", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);\n+    }\n+    \n+    /**\n+     * Constant column\n+     */\n+    public void testConstant() {\n+        double[] noVariance = new double[] {1, 1, 1, 1};\n+        double[] values = new double[] {1, 2, 3, 4};\n+        assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));\n+    }\n+    \n+    \n+    /**\n+     * Insufficient data\n+     */\n+     \n+    public void testInsufficientData() {\n+        double[] one = new double[] {1};\n+        double[] two = new double[] {2};\n+        try {\n+            new PearsonsCorrelation().correlation(one, two);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});\n+        try {\n+            new PearsonsCorrelation(matrix);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+    }\n+    \n+    /**\n+     * Verify that direct t-tests using standard error estimates are consistent\n+     * with reported p-values\n+     */\n+    public void testStdErrorConsistency() throws Exception {\n+        TDistribution tDistribution = new TDistributionImpl(45);\n+        RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        RealMatrix rValues = corrInstance.getCorrelationMatrix();\n+        RealMatrix pValues = corrInstance.getCorrelationPValues();\n+        RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();\n+        for (int i = 0; i < 5; i++) {\n+            for (int j = 0; j < i; j++) {\n+                double t = Math.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);\n+                double p = 2 * (1 - tDistribution.cumulativeProbability(t));\n+                assertEquals(p, pValues.getEntry(i, j), 10E-15);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Verify that creating correlation from covariance gives same results as\n+     * direct computation from the original matrix\n+     */\n+    public void testCovarianceConsistency() throws Exception {\n+        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        Covariance covInstance = new Covariance(matrix);\n+        PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance);\n+        TestUtils.assertEquals(\"correlation values\", corrInstance.getCorrelationMatrix(),\n+                corrFromCovInstance.getCorrelationMatrix(), 10E-15);\n+        TestUtils.assertEquals(\"p values\", corrInstance.getCorrelationPValues(),\n+                corrFromCovInstance.getCorrelationPValues(), 10E-15);\n+        TestUtils.assertEquals(\"standard errors\", corrInstance.getCorrelationStandardErrors(),\n+                corrFromCovInstance.getCorrelationStandardErrors(), 10E-15);\n+        \n+        PearsonsCorrelation corrFromCovInstance2 = \n+            new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16);\n+        TestUtils.assertEquals(\"correlation values\", corrInstance.getCorrelationMatrix(),\n+                corrFromCovInstance2.getCorrelationMatrix(), 10E-15);\n+        TestUtils.assertEquals(\"p values\", corrInstance.getCorrelationPValues(),\n+                corrFromCovInstance2.getCorrelationPValues(), 10E-15);\n+        TestUtils.assertEquals(\"standard errors\", corrInstance.getCorrelationStandardErrors(),\n+                corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15);\n+    }\n+    \n+     \n+    public void testConsistency() {\n+        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        double[][] data = matrix.getData();\n+        double[] x = matrix.getColumn(0);\n+        double[] y = matrix.getColumn(1);\n+        assertEquals(new PearsonsCorrelation().correlation(x, y), \n+                corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n+        TestUtils.assertEquals(\"Correlation matrix\", corrInstance.getCorrelationMatrix(),\n+                new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n+    }\n+    \n+    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {\n+        double[][] matrixData = new double[nRows][nCols];\n+        int ptr = 0;\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data, ptr, matrixData[i], 0, nCols);\n+            ptr += nCols;\n+        }\n+        return new BlockRealMatrix(matrixData); \n+    }\n+    \n+    protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {\n+        int ptr = 0;\n+        RealMatrix result = new BlockRealMatrix(dimension, dimension);\n+        for (int i = 1; i < dimension; i++) {\n+            for (int j = 0; j < i; j++) {\n+                result.setEntry(i, j, data[ptr]);\n+                ptr++;\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    protected void fillUpper(RealMatrix matrix, double diagonalValue) {\n+        int dimension = matrix.getColumnDimension();\n+        for (int i = 0; i < dimension; i++) {\n+            matrix.setEntry(i, i, diagonalValue);\n+            for (int j = i+1; j < dimension; j++) {\n+                matrix.setEntry(i, j, matrix.getEntry(j, i));\n+            }\n+        }  \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.correlation;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Test cases for Spearman's rank correlation\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest {\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    /**\n+     * Test Longley dataset against R.\n+     */\n+    @Override\n+    public void testLongly() throws Exception {  \n+        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n+        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); \n+        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n+        double[] rData = new double[] {\n+                1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294,\n+                0.976470588235294, 0.982352941176471, 1, 0.997058823529412, 0.664705882352941, 0.2205882352941176,\n+                0.997058823529412, 0.997058823529412, 0.985294117647059, 0.997058823529412, 1, 0.638235294117647,\n+                0.2235294117647059, 0.9941176470588236, 0.9941176470588236, 0.564705882352941, 0.664705882352941,\n+                0.638235294117647, 1, -0.3411764705882353, 0.685294117647059, 0.685294117647059, 0.2264705882352941,\n+                0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941,\n+                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1,\n+                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1\n+        }; \n+        TestUtils.assertEquals(\"Spearman's correlation matrix\", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);\n+    }\n+    \n+    /**\n+     * Test R swiss fertility dataset.\n+     */\n+    public void testSwiss() throws Exception {  \n+        RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n+        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); \n+        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n+        double[] rData = new double[] {\n+                1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432,\n+                0.2426642769364176, 1, -0.598859938748963, -0.650463814145816, 0.2886878090882852,\n+               -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745,\n+               -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244,\n+                0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1\n+        }; \n+        TestUtils.assertEquals(\"Spearman's correlation matrix\", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);\n+    }\n+    \n+    /**\n+     * Constant column\n+     */\n+    @Override\n+    public void testConstant() {\n+        double[] noVariance = new double[] {1, 1, 1, 1};\n+        double[] values = new double[] {1, 2, 3, 4};\n+        assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));\n+    }\n+    \n+    /**\n+     * Insufficient data\n+     */ \n+    @Override\n+    public void testInsufficientData() {\n+        double[] one = new double[] {1};\n+        double[] two = new double[] {2};\n+        try {\n+            new SpearmansCorrelation().correlation(one, two);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});\n+        try {\n+            new SpearmansCorrelation(matrix);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // Expected\n+        }\n+    }\n+    \n+    @Override\n+    public void testConsistency() {\n+        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n+        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); \n+        double[][] data = matrix.getData();\n+        double[] x = matrix.getColumn(0);\n+        double[] y = matrix.getColumn(1);\n+        assertEquals(new SpearmansCorrelation().correlation(x, y), \n+                corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n+        TestUtils.assertEquals(\"Correlation matrix\", corrInstance.getCorrelationMatrix(),\n+                new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n+    }\n+    \n+    // Not relevant here\n+    @Override\n+    public void testStdErrorConsistency() throws Exception {}\n+    @Override\n+    public void testCovarianceConsistency() throws Exception {}\n+     \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.data;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class CertifiedDataAbstractTest extends TestCase {\n+    \n+    private DescriptiveStatistics descriptives;\n+    \n+    private SummaryStatistics summaries;\n+    \n+    private Map<String, Double> certifiedValues;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        descriptives = new DescriptiveStatistics();\n+        summaries = new SummaryStatistics();\n+        certifiedValues = new HashMap<String, Double>();\n+        \n+        loadData();\n+    }\n+\n+    private void loadData() throws IOException {\n+        BufferedReader in = null;\n+\n+        try {\n+            URL resourceURL = getClass().getClassLoader().getResource(getResourceName());\n+            in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));\n+            \n+            String line = in.readLine();\n+            while (line != null) {\n+                \n+                /* this call to StringUtils did little for the \n+                 * following conditional structure \n+                 */\n+                line = line.trim();\n+\n+                // not empty line or comment\n+                if (!(\"\".equals(line) || line.startsWith(\"#\"))) {\n+                    int n = line.indexOf('=');\n+                    if (n == -1) {\n+                        // data value\n+                        double value = Double.parseDouble(line);\n+                        descriptives.addValue(value);\n+                        summaries.addValue(value);\n+                    } else {\n+                        // certified value\n+                        String name = line.substring(0, n).trim();\n+                        String valueString = line.substring(n + 1).trim();\n+                        Double value = Double.valueOf(valueString);\n+                        certifiedValues.put(name, value);\n+                    }\n+                }\n+                line = in.readLine();\n+            }\n+        } finally {\n+            if (in != null) {\n+                in.close();\n+            }\n+        }\n+    }\n+\n+    protected abstract String getResourceName();\n+\n+    protected double getMaximumAbsoluteError() {\n+        return 1.0e-5;\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        descriptives.clear();\n+        descriptives = null;\n+        \n+        summaries.clear();\n+        summaries = null;\n+        \n+        certifiedValues.clear();\n+        certifiedValues = null;\n+    }\n+    \n+    public void testCertifiedValues() {\n+        for (String name : certifiedValues.keySet()) {\n+            Double expectedValue = certifiedValues.get(name);\n+\n+            Double summariesValue = getProperty(summaries, name);\n+            if (summariesValue != null) {\n+                TestUtils.assertEquals(\"summary value for \" + name + \" is incorrect.\",\n+                                       summariesValue.doubleValue(), expectedValue.doubleValue(),\n+                                       getMaximumAbsoluteError());\n+            }\n+\n+            Double descriptivesValue = getProperty(descriptives, name);\n+            if (descriptivesValue != null) {\n+                TestUtils.assertEquals(\"descriptive value for \" + name + \" is incorrect.\",\n+                                       descriptivesValue.doubleValue(), expectedValue.doubleValue(),\n+                                       getMaximumAbsoluteError());\n+            }\n+        }\n+    }\n+    \n+    \n+    protected Double getProperty(Object bean, String name) {\n+        try {\n+            // Get the value of prop\n+            String prop = \"get\" + name.substring(0,1).toUpperCase() + name.substring(1); \n+            Method meth = bean.getClass().getMethod(prop, new Class[0]);\n+            Object property = meth.invoke(bean, new Object[0]);\n+            if (meth.getReturnType().equals(Double.TYPE)) {\n+                return (Double) property;\n+            } else if (meth.getReturnType().equals(Long.TYPE)) {\n+                return Double.valueOf(((Long) property).doubleValue());\n+            } else {\n+                fail(\"wrong type: \" + meth.getReturnType().getName());\n+            }\n+        } catch (NoSuchMethodException nsme) {\n+            // ignored\n+        } catch (InvocationTargetException ite) {\n+            fail(ite.getMessage());\n+        } catch (IllegalAccessException iae) {\n+            fail(iae.getMessage());\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/data/LewTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.data;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class LewTest extends CertifiedDataAbstractTest {\n+\n+    @Override\n+    protected String getResourceName() {\n+        return \"org/apache/commons/math/stat/data/Lew.txt\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/data/LotteryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.data;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class LotteryTest extends CertifiedDataAbstractTest {\n+\n+    @Override\n+    protected String getResourceName() {\n+        return \"org/apache/commons/math/stat/data/Lottery.txt\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+\n+/**\n+ * Tests for AbstractUnivariateStatistic \n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class AbstractUnivariateStatisticTest extends TestCase {\n+    \n+    public AbstractUnivariateStatisticTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);\n+        suite.setName(\"AbstractUnivariateStatistic Tests\");\n+        return suite;\n+    }\n+    \n+    protected double[] testArray = {0, 1, 2, 3, 4, 5};\n+    protected double[] nullArray = null;\n+    protected double[] singletonArray = {0};\n+    protected Mean testStatistic = new Mean();\n+    \n+    public void testTestPositive() {\n+        for (int j = 0; j < 6; j++) {\n+            for (int i = 1; i < (7 - j); i++) {\n+                assertTrue(testStatistic.test(testArray, 0, i));\n+            }  \n+        }\n+        assertTrue(testStatistic.test(singletonArray, 0, 1));\n+    }\n+    \n+    public void testTestNegative() {\n+        assertFalse(testStatistic.test(singletonArray, 0, 0));\n+        assertFalse(testStatistic.test(testArray, 0, 0));\n+        try {\n+            testStatistic.test(singletonArray, 2, 1);  // start past end\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, 0, 7);  // end past end\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, -1, 1);  // start negative\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, 0, -1);  // length negative\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(nullArray, 0, 1);  // null array\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    } \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.util.Collection;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.TestUtils;\n+\n+\n+/**\n+ * Test cases for {@link AggregateSummaryStatistics}\n+ *\n+ */\n+public class AggregateSummaryStatisticsTest extends TestCase {\n+    \n+    /**\n+     * Creates and returns a {@code Test} representing all the test cases in this\n+     * class\n+     *\n+     * @return a {@code Test} representing all the test cases in this class\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AggregateSummaryStatisticsTest.class);\n+        suite.setName(\"AggregateSummaryStatistics tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * Tests the standard aggregation behavior\n+     */\n+    public void testAggregation() {\n+        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n+        SummaryStatistics setOneStats = aggregate.createContributingStatistics();\n+        SummaryStatistics setTwoStats = aggregate.createContributingStatistics();\n+        \n+        assertNotNull(\"The set one contributing stats are null\", setOneStats);\n+        assertNotNull(\"The set two contributing stats are null\", setTwoStats);\n+        assertNotSame(\"Contributing stats objects are the same\", setOneStats, setTwoStats);\n+        \n+        setOneStats.addValue(2);\n+        setOneStats.addValue(3);\n+        setOneStats.addValue(5);\n+        setOneStats.addValue(7);\n+        setOneStats.addValue(11);\n+        assertEquals(\"Wrong number of set one values\", 5, setOneStats.getN());\n+        assertEquals(\"Wrong sum of set one values\", 28.0, setOneStats.getSum());\n+        \n+        setTwoStats.addValue(2);\n+        setTwoStats.addValue(4);\n+        setTwoStats.addValue(8);\n+        assertEquals(\"Wrong number of set two values\", 3, setTwoStats.getN());\n+        assertEquals(\"Wrong sum of set two values\", 14.0, setTwoStats.getSum());\n+        \n+        assertEquals(\"Wrong number of aggregate values\", 8, aggregate.getN());\n+        assertEquals(\"Wrong aggregate sum\", 42.0, aggregate.getSum());\n+    }\n+    \n+    /**\n+     * Verify that aggregating over a partition gives the same results\n+     * as direct computation.\n+     * \n+     *  1) Randomly generate a dataset of 10-100 values\n+     *     from [-100, 100]\n+     *  2) Divide the dataset it into 2-5 partitions\n+     *  3) Create an AggregateSummaryStatistic and ContributingStatistics\n+     *     for each partition \n+     *  4) Compare results from the AggregateSummaryStatistic with values\n+     *     returned by a single SummaryStatistics instance that is provided \n+     *     the full dataset\n+     */\n+    public void testAggregationConsistency() throws Exception {\n+        \n+        // Generate a random sample and random partition\n+        double[] totalSample = generateSample();\n+        double[][] subSamples = generatePartition(totalSample);\n+        int nSamples = subSamples.length;\n+        \n+        // Create aggregator and total stats for comparison\n+        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n+        SummaryStatistics totalStats = new SummaryStatistics();\n+        \n+        // Create array of component stats\n+        SummaryStatistics componentStats[] = new SummaryStatistics[nSamples];\n+        \n+        for (int i = 0; i < nSamples; i++) {\n+            \n+            // Make componentStats[i] a contributing statistic to aggregate\n+            componentStats[i] = aggregate.createContributingStatistics();\n+            \n+            // Add values from subsample\n+            for (int j = 0; j < subSamples[i].length; j++) {\n+                componentStats[i].addValue(subSamples[i][j]);\n+            }\n+        }\n+        \n+        // Compute totalStats directly\n+        for (int i = 0; i < totalSample.length; i++) {\n+            totalStats.addValue(totalSample[i]);\n+        }\n+        \n+        /*\n+         * Compare statistics in totalStats with aggregate.\n+         * Note that guaranteed success of this comparison depends on the\n+         * fact that <aggregate> gets values in exactly the same order\n+         * as <totalStats>. \n+         *  \n+         */\n+        assertEquals(totalStats.getSummary(), aggregate.getSummary());  \n+        \n+    }\n+    \n+    /**\n+     * Test aggregate function by randomly generating a dataset of 10-100 values\n+     * from [-100, 100], dividing it into 2-5 partitions, computing stats for each\n+     * partition and comparing the result of aggregate(...) applied to the collection\n+     * of per-partition SummaryStatistics with a single SummaryStatistics computed\n+     * over the full sample.\n+     * \n+     * @throws Exception\n+     */\n+    public void testAggregate() throws Exception {\n+        \n+        // Generate a random sample and random partition\n+        double[] totalSample = generateSample();\n+        double[][] subSamples = generatePartition(totalSample);\n+        int nSamples = subSamples.length;\n+       \n+        // Compute combined stats directly\n+        SummaryStatistics totalStats = new SummaryStatistics();\n+        for (int i = 0; i < totalSample.length; i++) {\n+            totalStats.addValue(totalSample[i]);\n+        }\n+        \n+        // Now compute subsample stats individually and aggregate\n+        SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];\n+        for (int i = 0; i < nSamples; i++) {\n+            subSampleStats[i] = new SummaryStatistics();\n+        }\n+        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n+        for (int i = 0; i < nSamples; i++) {\n+            for (int j = 0; j < subSamples[i].length; j++) { \n+                subSampleStats[i].addValue(subSamples[i][j]);\n+            }\n+            aggregate.add(subSampleStats[i]);\n+        }\n+        \n+        // Compare values\n+        StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n+        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n+    }\n+    \n+    \n+    public void testAggregateDegenerate() throws Exception {\n+        double[] totalSample = {1, 2, 3, 4, 5};\n+        double[][] subSamples = {{1}, {2}, {3}, {4}, {5}};\n+        \n+        // Compute combined stats directly\n+        SummaryStatistics totalStats = new SummaryStatistics();\n+        for (int i = 0; i < totalSample.length; i++) {\n+            totalStats.addValue(totalSample[i]);\n+        }\n+        \n+        // Now compute subsample stats individually and aggregate\n+        SummaryStatistics[] subSampleStats = new SummaryStatistics[5];\n+        for (int i = 0; i < 5; i++) {\n+            subSampleStats[i] = new SummaryStatistics();\n+        }\n+        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n+        for (int i = 0; i < 5; i++) {\n+            for (int j = 0; j < subSamples[i].length; j++) { \n+                subSampleStats[i].addValue(subSamples[i][j]);\n+            }\n+            aggregate.add(subSampleStats[i]);\n+        }\n+        \n+        // Compare values\n+        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n+        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n+    }\n+    \n+    public void testAggregateSpecialValues() throws Exception {\n+        double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5};\n+        double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}};\n+        \n+        // Compute combined stats directly\n+        SummaryStatistics totalStats = new SummaryStatistics();\n+        for (int i = 0; i < totalSample.length; i++) {\n+            totalStats.addValue(totalSample[i]);\n+        }\n+        \n+        // Now compute subsample stats individually and aggregate\n+        SummaryStatistics[] subSampleStats = new SummaryStatistics[5];\n+        for (int i = 0; i < 4; i++) {\n+            subSampleStats[i] = new SummaryStatistics();\n+        }\n+        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < subSamples[i].length; j++) { \n+                subSampleStats[i].addValue(subSamples[i][j]);\n+            }\n+            aggregate.add(subSampleStats[i]);\n+        }\n+        \n+        // Compare values\n+        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n+        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n+        \n+    }\n+    \n+    /**\n+     * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up\n+     * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values\n+     * have to agree exactly, delta is used only for sum, mean, variance, std dev.\n+     */\n+    protected static void assertEquals(StatisticalSummary expected, StatisticalSummary observed, double delta) {\n+        TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0);\n+        TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0);\n+        assertEquals(expected.getN(), observed.getN());\n+        TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta);\n+        TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta);\n+        TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta);\n+        TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta);\n+    }\n+\n+    \n+    /**\n+     * Generates a random sample of double values.\n+     * Sample size is random, between 10 and 100 and values are \n+     * uniformly distributed over [-100, 100].\n+     * \n+     * @return array of random double values\n+     */\n+    private double[] generateSample() {\n+        final RandomData randomData = new RandomDataImpl();\n+        final int sampleSize = randomData.nextInt(10,100);\n+        double[] out = new double[sampleSize];\n+        for (int i = 0; i < out.length; i++) {\n+            out[i] = randomData.nextUniform(-100, 100);\n+        }\n+        return out;     \n+    }\n+    \n+    /**\n+     * Generates a partition of <sample> into up to 5 sequentially selected\n+     * subsamples with randomly selected partition points.\n+     * \n+     * @param sample array to partition\n+     * @return rectangular array with rows = subsamples\n+     */\n+    private double[][] generatePartition(double[] sample) {\n+        final int length = sample.length;\n+        final double[][] out = new double[5][];\n+        final RandomData randomData = new RandomDataImpl();\n+        int cur = 0;\n+        int offset = 0;\n+        int sampleCount = 0;\n+        for (int i = 0; i < 5; i++) {\n+            if (cur == length || offset == length) {\n+                break;\n+            }\n+            final int next = (i == 4 || cur == length - 1) ? length - 1 : randomData.nextInt(cur, length - 1);\n+            final int subLength = next - cur + 1;\n+            out[i] = new double[subLength];\n+            System.arraycopy(sample, offset, out[i], 0, subLength);\n+            cur = next + 1;\n+            sampleCount++;\n+            offset += subLength;\n+        }\n+        if (sampleCount < 5) {\n+            double[][] out2 = new double[sampleCount][];\n+            for (int j = 0; j < sampleCount; j++) {\n+                final int curSize = out[j].length;\n+                out2[j] = new double[curSize];\n+                System.arraycopy(out[j], 0, out2[j], 0, curSize);\n+            }\n+            return out2;\n+        } else {\n+            return out;\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.util.Locale;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.rank.Percentile;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Test cases for the DescriptiveStatistics class.\n+ * \n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ *          2007) $\n+ */\n+public class DescriptiveStatisticsTest extends TestCase {\n+\n+    public DescriptiveStatisticsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);\n+        suite.setName(\"DescriptiveStatistics Tests\");\n+        return suite;\n+    }\n+\n+    protected DescriptiveStatistics createDescriptiveStatistics() {\n+        return new DescriptiveStatistics();\n+    }\n+\n+    public void testSetterInjection() {\n+        DescriptiveStatistics stats = createDescriptiveStatistics();\n+        stats.addValue(1);\n+        stats.addValue(3);\n+        assertEquals(2, stats.getMean(), 1E-10);\n+        // Now lets try some new math\n+        stats.setMeanImpl(new deepMean());\n+        assertEquals(42, stats.getMean(), 1E-10);\n+    }\n+    \n+    public void testCopy() {\n+        DescriptiveStatistics stats = createDescriptiveStatistics();\n+        stats.addValue(1);\n+        stats.addValue(3);\n+        DescriptiveStatistics copy = new DescriptiveStatistics(stats);\n+        assertEquals(2, copy.getMean(), 1E-10);\n+        // Now lets try some new math\n+        stats.setMeanImpl(new deepMean());\n+        copy = stats.copy();\n+        assertEquals(42, copy.getMean(), 1E-10);\n+    }\n+    \n+    public void testWindowSize() {\n+        DescriptiveStatistics stats = createDescriptiveStatistics();\n+        stats.setWindowSize(300);\n+        for (int i = 0; i < 100; ++i) {\n+            stats.addValue(i + 1);\n+        }\n+        int refSum = (100 * 101) / 2;\n+        assertEquals(refSum / 100.0, stats.getMean(), 1E-10);\n+        assertEquals(300, stats.getWindowSize());\n+        try {\n+            stats.setWindowSize(-3);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+        assertEquals(300, stats.getWindowSize());\n+        stats.setWindowSize(50);\n+        assertEquals(50, stats.getWindowSize());\n+        int refSum2 = refSum - (50 * 51) / 2;\n+        assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);\n+    }\n+    \n+    public void testGetValues() {\n+        DescriptiveStatistics stats = createDescriptiveStatistics();\n+        for (int i = 100; i > 0; --i) {\n+            stats.addValue(i);\n+        }\n+        int refSum = (100 * 101) / 2;\n+        assertEquals(refSum / 100.0, stats.getMean(), 1E-10);\n+        double[] v = stats.getValues();\n+        for (int i = 0; i < v.length; ++i) {\n+            assertEquals(100.0 - i, v[i], 1.0e-10);\n+        }\n+        double[] s = stats.getSortedValues();\n+        for (int i = 0; i < s.length; ++i) {\n+            assertEquals(i + 1.0, s[i], 1.0e-10);\n+        }\n+        assertEquals(12.0, stats.getElement(88), 1.0e-10);\n+    }\n+    \n+    public void testToString() {\n+        DescriptiveStatistics stats = createDescriptiveStatistics();\n+        stats.addValue(1);\n+        stats.addValue(2);\n+        stats.addValue(3);\n+        Locale d = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        assertEquals(\"DescriptiveStatistics:\\n\" +\n+                     \"n: 3\\n\" +\n+                     \"min: 1.0\\n\" +\n+                     \"max: 3.0\\n\" +\n+                     \"mean: 2.0\\n\" +\n+                     \"std dev: 1.0\\n\" +\n+                     \"median: 2.0\\n\" +\n+                     \"skewness: 0.0\\n\" +\n+                     \"kurtosis: NaN\\n\",  stats.toString());\n+        Locale.setDefault(d);\n+    }\n+\n+    public void testShuffledStatistics() {\n+        // the purpose of this test is only to check the get/set methods\n+        // we are aware shuffling statistics like this is really not\n+        // something sensible to do in production ...\n+        DescriptiveStatistics reference = createDescriptiveStatistics();\n+        DescriptiveStatistics shuffled  = createDescriptiveStatistics();\n+\n+        UnivariateStatistic tmp = shuffled.getGeometricMeanImpl();\n+        shuffled.setGeometricMeanImpl(shuffled.getMeanImpl());\n+        shuffled.setMeanImpl(shuffled.getKurtosisImpl());\n+        shuffled.setKurtosisImpl(shuffled.getSkewnessImpl());\n+        shuffled.setSkewnessImpl(shuffled.getVarianceImpl());\n+        shuffled.setVarianceImpl(shuffled.getMaxImpl());\n+        shuffled.setMaxImpl(shuffled.getMinImpl());\n+        shuffled.setMinImpl(shuffled.getSumImpl());\n+        shuffled.setSumImpl(shuffled.getSumsqImpl());\n+        shuffled.setSumsqImpl(tmp);\n+\n+        for (int i = 100; i > 0; --i) {\n+            reference.addValue(i);\n+            shuffled.addValue(i);\n+        }\n+\n+        assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);\n+        assertEquals(reference.getKurtosis(),      shuffled.getMean(),          1.0e-10);\n+        assertEquals(reference.getSkewness(),      shuffled.getKurtosis(), 1.0e-10);\n+        assertEquals(reference.getVariance(),      shuffled.getSkewness(), 1.0e-10);\n+        assertEquals(reference.getMax(),           shuffled.getVariance(), 1.0e-10);\n+        assertEquals(reference.getMin(),           shuffled.getMax(), 1.0e-10);\n+        assertEquals(reference.getSum(),           shuffled.getMin(), 1.0e-10);\n+        assertEquals(reference.getSumsq(),         shuffled.getSum(), 1.0e-10);\n+        assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);\n+\n+    }\n+    \n+    public void testPercentileSetter() throws Exception {\n+        DescriptiveStatistics stats = createDescriptiveStatistics();\n+        stats.addValue(1);\n+        stats.addValue(2);\n+        stats.addValue(3);\n+        assertEquals(2, stats.getPercentile(50.0), 1E-10);\n+        \n+        // Inject wrapped Percentile impl\n+        stats.setPercentileImpl(new goodPercentile());\n+        assertEquals(2, stats.getPercentile(50.0), 1E-10);\n+        \n+        // Try \"new math\" impl\n+        stats.setPercentileImpl(new subPercentile());\n+        assertEquals(10.0, stats.getPercentile(10.0), 1E-10);\n+        \n+        // Try to set bad impl\n+        try {\n+            stats.setPercentileImpl(new badPercentile()); \n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test20090720() {\n+        DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics(100);\n+        for (int i = 0; i < 161; i++) {\n+            descriptiveStatistics.addValue(1.2);\n+        }\n+        descriptiveStatistics.clear();\n+        descriptiveStatistics.addValue(1.2);\n+        assertEquals(1, descriptiveStatistics.getN());\n+    }\n+\n+    public void testRemoval() {\n+\n+        final DescriptiveStatistics dstat = createDescriptiveStatistics();\n+\n+        checkremoval(dstat, 1, 6.0, 0.0, Double.NaN);\n+        checkremoval(dstat, 3, 5.0, 3.0, 4.5);\n+        checkremoval(dstat, 6, 3.5, 2.5, 3.0);\n+        checkremoval(dstat, 9, 3.5, 2.5, 3.0);\n+        checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);\n+\n+    }\n+\n+    public void checkremoval(DescriptiveStatistics dstat, int wsize,\n+                             double mean1, double mean2, double mean3) {\n+\n+        dstat.setWindowSize(wsize);\n+        dstat.clear();\n+\n+        for (int i = 1 ; i <= 6 ; ++i) {\n+            dstat.addValue(i);\n+        }\n+\n+        assertTrue(MathUtils.equals(mean1, dstat.getMean()));\n+        dstat.replaceMostRecentValue(0);\n+        assertTrue(MathUtils.equals(mean2, dstat.getMean()));\n+        dstat.removeMostRecentValue();\n+        assertTrue(MathUtils.equals(mean3, dstat.getMean()));\n+\n+    }\n+    \n+    // Test UnivariateStatistics impls for setter injection tests\n+    \n+    /**\n+     * A new way to compute the mean \n+     */\n+    static class deepMean implements UnivariateStatistic {\n+\n+        public double evaluate(double[] values, int begin, int length) {\n+            return 42;\n+        }\n+\n+        public double evaluate(double[] values) {\n+            return 42;\n+        }  \n+        public UnivariateStatistic copy() {\n+            return new deepMean();\n+        }\n+    }\n+    \n+    /**\n+     * Test percentile implementation - wraps a Percentile\n+     */\n+    static class goodPercentile implements UnivariateStatistic {\n+        private Percentile percentile = new Percentile();\n+        public void setQuantile(double quantile) {\n+            percentile.setQuantile(quantile);\n+        }\n+        public double evaluate(double[] values, int begin, int length) {\n+            return percentile.evaluate(values, begin, length);\n+        }\n+        public double evaluate(double[] values) {\n+            return percentile.evaluate(values);\n+        }  \n+        public UnivariateStatistic copy() {\n+            goodPercentile result = new goodPercentile();\n+            result.setQuantile(percentile.getQuantile());\n+            return result;\n+        }\n+    }\n+    \n+    /**\n+     * Test percentile subclass - another \"new math\" impl\n+     * Always returns currently set quantile\n+     */\n+    static class subPercentile extends Percentile {\n+        @Override\n+        public double evaluate(double[] values, int begin, int length) {\n+            return getQuantile();\n+        }\n+        @Override\n+        public double evaluate(double[] values) {\n+            return getQuantile();\n+        }  \n+        private static final long serialVersionUID = 8040701391045914979L;\n+        @Override\n+        public Percentile copy() {\n+            subPercentile result = new subPercentile();\n+            return result;\n+        }\n+    }\n+    \n+    /**\n+     * \"Bad\" test percentile implementation - no setQuantile\n+     */\n+    static class badPercentile implements UnivariateStatistic {\n+        private Percentile percentile = new Percentile();\n+        public double evaluate(double[] values, int begin, int length) {\n+            return percentile.evaluate(values, begin, length);\n+        }\n+        public double evaluate(double[] values) {\n+            return percentile.evaluate(values);\n+        }\n+        public UnivariateStatistic copy() {\n+            return new badPercentile();\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/InteractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.stat.descriptive.moment.FourthMoment;\n+import org.apache.commons.math.stat.descriptive.moment.Kurtosis;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Skewness;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class InteractionTest extends TestCase {\n+\n+    protected double mean = 12.40454545454550;\n+    protected double var = 10.00235930735930;\n+    protected double skew = 1.437423729196190;\n+    protected double kurt = 2.377191264804700;\n+\n+    protected double tolerance = 10E-12;\n+\n+    protected double[] testArray =\n+        {\n+            12.5,\n+            12,\n+            11.8,\n+            14.2,\n+            14.9,\n+            14.5,\n+            21,\n+            8.2,\n+            10.3,\n+            11.3,\n+            14.1,\n+            9.9,\n+            12.2,\n+            12,\n+            12.1,\n+            11,\n+            19.8,\n+            11,\n+            10,\n+            8.8,\n+            9,\n+            12.3 };\n+\n+    public InteractionTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    public void testInteraction() {\n+        \n+        FourthMoment m4 = new FourthMoment();\n+        Mean m = new Mean(m4);\n+        Variance v = new Variance(m4);\n+        Skewness s= new Skewness(m4);\n+        Kurtosis k = new Kurtosis(m4);\n+\n+        for (int i = 0; i < testArray.length; i++){\n+            m4.increment(testArray[i]);\n+        }\n+        \n+        assertEquals(mean,m.getResult(),tolerance);\n+        assertEquals(var,v.getResult(),tolerance);\n+        assertEquals(skew ,s.getResult(),tolerance);\n+        assertEquals(kurt,k.getResult(),tolerance);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.util.DefaultTransformer;\n+import org.apache.commons.math.util.NumberTransformer;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8837442489133392138L;\n+    \n+    /**\n+     * Holds a reference to a list - GENERICs are going to make\n+     * our lives easier here as we could only accept List<Number>\n+     */\n+    protected List<Object> list;\n+\n+    /** Number Transformer maps Objects to Number for us. */\n+    protected NumberTransformer transformer;\n+\n+    /**\n+     * No argument Constructor\n+     */\n+    public ListUnivariateImpl(){\n+        this(new ArrayList<Object>());\n+    }\n+    \n+    /**\n+     * Construct a ListUnivariate with a specific List.\n+     * @param list The list that will back this DescriptiveStatistics\n+     */\n+    public ListUnivariateImpl(List<Object> list) {\n+        this(list, new DefaultTransformer());\n+    }\n+    \n+    /**\n+     * Construct a ListUnivariate with a specific List.\n+     * @param list The list that will back this DescriptiveStatistics\n+     * @param transformer the number transformer used to convert the list items.\n+     */\n+    public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {\n+        super();\n+        this.list = list;\n+        this.transformer = transformer;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] getValues() {\n+\n+        int length = list.size();\n+\n+        // If the window size is not INFINITE_WINDOW AND\n+        // the current list is larger that the window size, we need to\n+        // take into account only the last n elements of the list\n+        // as definied by windowSize\n+\n+        if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&\n+            windowSize < list.size())\n+        {\n+            length = list.size() - Math.max(0, list.size() - windowSize);\n+        }\n+\n+        // Create an array to hold all values\n+        double[] copiedArray = new double[length];\n+\n+        for (int i = 0; i < copiedArray.length; i++) {\n+            copiedArray[i] = getElement(i);\n+        }\n+        return copiedArray;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getElement(int index) {\n+\n+        double value = Double.NaN;\n+\n+        int calcIndex = index;\n+\n+        if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&\n+            windowSize < list.size())\n+        {\n+            calcIndex = (list.size() - windowSize) + index;\n+        }\n+\n+        \n+        try {\n+            value = transformer.transform(list.get(calcIndex));\n+        } catch (MathException e) {\n+            e.printStackTrace();\n+        }\n+        \n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public long getN() {\n+        int n = 0;\n+\n+        if (windowSize != DescriptiveStatistics.INFINITE_WINDOW) {\n+            if (list.size() > windowSize) {\n+                n = windowSize;\n+            } else {\n+                n = list.size();\n+            }\n+        } else {\n+            n = list.size();\n+        }\n+        return n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addValue(double v) {\n+        list.add(Double.valueOf(v));\n+    }\n+    \n+    /**\n+     * Adds an object to this list. \n+     * @param o Object to add to the list\n+     */\n+    public void addObject(Object o) {\n+        list.add(o);\n+    }\n+\n+    /**\n+     * Clears all statistics.\n+     * <p>\n+     * <strong>N.B.: </strong> This method has the side effect of clearing the underlying list.\n+     */\n+    @Override\n+    public void clear() {\n+        list.clear();\n+    }\n+    \n+    /**\n+     * Apply the given statistic to this univariate collection.\n+     * @param stat the statistic to apply\n+     * @return the computed value of the statistic.\n+     */\n+    @Override\n+    public double apply(UnivariateStatistic stat) {\n+        double[] v = this.getValues();\n+\n+        if (v != null) {\n+            return stat.evaluate(v, 0, v.length);\n+        }\n+        return Double.NaN;\n+    }\n+    \n+    /**\n+     * Access the number transformer.\n+     * @return the number transformer.\n+     */\n+    public NumberTransformer getTransformer() {\n+        return transformer;\n+    }\n+\n+    /**\n+     * Modify the number transformer.\n+     * @param transformer the new number transformer.\n+     */\n+    public void setTransformer(NumberTransformer transformer) {\n+        this.transformer = transformer;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public synchronized void setWindowSize(int windowSize) {\n+        this.windowSize = windowSize;\n+        //Discard elements from the front of the list if the windowSize is less than \n+        // the size of the list.\n+        int extra = list.size() - windowSize;\n+        for (int i = 0; i < extra; i++) {\n+            list.remove(0);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public synchronized int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link ListUnivariateImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class ListUnivariateImplTest extends TestCase {\n+    \n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double tolerance = 10E-15;\n+    \n+    public ListUnivariateImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);\n+        suite.setName(\"Frequency Tests\");\n+        return suite;\n+    }\n+    \n+    /** test stats */\n+    public void testStats() {\n+        List<Object> externalList = new ArrayList<Object>();\n+        \n+        DescriptiveStatistics u = new ListUnivariateImpl( externalList ); \n+\n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+    \n+    public void testN0andN1Conditions() throws Exception {\n+        List<Object> list = new ArrayList<Object>();\n+        \n+        DescriptiveStatistics u = new ListUnivariateImpl( list );\n+                \n+        assertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n+        assertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n+        assertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n+\n+        list.add( Double.valueOf(one));\n+\n+        assertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n+        assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n+        assertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);  \n+    }\n+    \n+    public void testSkewAndKurtosis() {\n+        DescriptiveStatistics u = new DescriptiveStatistics();\n+        \n+        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n+                                             9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n+        for( int i = 0; i < testArray.length; i++) {\n+            u.addValue( testArray[i]);\n+        }\n+        \n+        assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+        assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+        assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+        assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());\n+        u.setWindowSize(10);\n+                \n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n+\n+        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n+        // of a discarded element\n+        for( int i = 0; i < 10; i++ ) {\n+            u.addValue( i + 2 );\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        \n+        assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n+\n+\n+    }\n+    \n+    /** test stats */\n+    public void testSerialization() {\n+        \n+        DescriptiveStatistics u = new ListUnivariateImpl();\n+        \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        \n+        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); \n+ \n+        u2.addValue(two);\n+        u2.addValue(three);\n+        \n+        assertEquals(\"N\",n,u2.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u2.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u2.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u2.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u2.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u2.getMean(),tolerance);\n+        assertEquals(\"min\",min,u2.getMin(),tolerance);\n+        assertEquals(\"max\",max,u2.getMax(),tolerance);\n+\n+        u2.clear();\n+        assertEquals(\"total count\",0,u2.getN(),tolerance);    \n+    }       \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.util.NumberTransformer;\n+import org.apache.commons.math.util.TransformerMap;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link ListUnivariateImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class MixedListUnivariateImplTest extends TestCase {\n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double tolerance = 10E-15;\n+\n+    private TransformerMap transformers = new TransformerMap();\n+    \n+    public MixedListUnivariateImplTest(String name) {\n+        super(name);\n+        transformers = new TransformerMap();\n+\n+        transformers.putTransformer(Foo.class, new FooTransformer());\n+\n+        transformers.putTransformer(Bar.class, new BarTransformer());\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);\n+        suite.setName(\"Mixed List Tests\");\n+        return suite;\n+    }\n+\n+    /** test stats */\n+    public void testStats() {\n+        List<Object> externalList = new ArrayList<Object>();\n+\n+        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);\n+\n+        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\", n, u.getN(), tolerance);\n+        assertEquals(\"sum\", sum, u.getSum(), tolerance);\n+        assertEquals(\"sumsq\", sumSq, u.getSumsq(), tolerance);\n+        assertEquals(\"var\", var, u.getVariance(), tolerance);\n+        assertEquals(\"std\", std, u.getStandardDeviation(), tolerance);\n+        assertEquals(\"mean\", mean, u.getMean(), tolerance);\n+        assertEquals(\"min\", min, u.getMin(), tolerance);\n+        assertEquals(\"max\", max, u.getMax(), tolerance);\n+        u.clear();\n+        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+    }\n+\n+    public void testN0andN1Conditions() throws Exception {\n+        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n+\n+        assertTrue(\n+            \"Mean of n = 0 set should be NaN\",\n+            Double.isNaN(u.getMean()));\n+        assertTrue(\n+            \"Standard Deviation of n = 0 set should be NaN\",\n+            Double.isNaN(u.getStandardDeviation()));\n+        assertTrue(\n+            \"Variance of n = 0 set should be NaN\",\n+            Double.isNaN(u.getVariance()));\n+\n+        u.addValue(one);\n+\n+        assertTrue(\n+            \"Mean of n = 1 set should be value of single item n1, instead it is \" + u.getMean() ,\n+            u.getMean() == one);\n+            \n+        assertTrue(\n+            \"StdDev of n = 1 set should be zero, instead it is: \"\n+                + u.getStandardDeviation(),\n+            u.getStandardDeviation() == 0);\n+        assertTrue(\n+            \"Variance of n = 1 set should be zero\",\n+            u.getVariance() == 0);\n+    }\n+\n+    public void testSkewAndKurtosis() {\n+        ListUnivariateImpl u =\n+            new ListUnivariateImpl(new ArrayList<Object>(), transformers);\n+\n+        u.addObject(\"12.5\");\n+        u.addObject(Integer.valueOf(12));\n+        u.addObject(\"11.8\");\n+        u.addObject(\"14.2\");\n+        u.addObject(new Foo());\n+        u.addObject(\"14.5\");\n+        u.addObject(Long.valueOf(21));\n+        u.addObject(\"8.2\");\n+        u.addObject(\"10.3\");\n+        u.addObject(\"11.3\");\n+        u.addObject(Float.valueOf(14.1f));\n+        u.addObject(\"9.9\");\n+        u.addObject(\"12.2\");\n+        u.addObject(new Bar());\n+        u.addObject(\"12.1\");\n+        u.addObject(\"11\");\n+        u.addObject(Double.valueOf(19.8));\n+        u.addObject(\"11\");\n+        u.addObject(\"10\");\n+        u.addObject(\"8.8\");\n+        u.addObject(\"9\");\n+        u.addObject(\"12.3\");\n+\n+\n+        assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+        assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+        assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+        assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n+        u.setWindowSize(10);\n+\n+        u.addValue(1.0);\n+        u.addValue(2.0);\n+        u.addValue(3.0);\n+        u.addValue(4.0);\n+\n+        assertEquals(\n+            \"Geometric mean not expected\",\n+            2.213364,\n+            u.getGeometricMean(),\n+            0.00001);\n+\n+        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n+        // of a discarded element\n+        for (int i = 0; i < 10; i++) {\n+            u.addValue(i + 2);\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        assertEquals(\n+            \"Geometric mean not expected\",\n+            5.755931,\n+            u.getGeometricMean(),\n+            0.00001);\n+\n+    }\n+\n+    public static final class Foo {\n+        public String heresFoo() {\n+            return \"14.9\";\n+        }\n+    }\n+\n+    public static final class FooTransformer implements NumberTransformer, Serializable {\n+        private static final long serialVersionUID = -4252248129291326127L;\n+        public double transform(Object o) {\n+            return Double.parseDouble(((Foo) o).heresFoo());\n+        }\n+    }\n+\n+    public static final class Bar {\n+        public String heresBar() {\n+            return \"12.0\";\n+        }\n+    }\n+\n+    public static final class BarTransformer implements NumberTransformer, Serializable {\n+        private static final long serialVersionUID = -1768345377764262043L;\n+        public double transform(Object o) {\n+            return Double.parseDouble(((Bar) o).heresBar());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+import java.util.Locale;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+\n+/**\n+ * Test cases for the {@link MultivariateSummaryStatistics} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class MultivariateSummaryStatisticsTest extends TestCase {\n+\n+    public MultivariateSummaryStatisticsTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MultivariateSummaryStatisticsTest.class);\n+        suite.setName(\"MultivariateSummaryStatistics tests\");\n+        return suite;\n+    }\n+\n+    protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n+        return new MultivariateSummaryStatistics(k, isCovarianceBiasCorrected);\n+    }\n+\n+    public void testSetterInjection() throws Exception {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n+        u.setMeanImpl(new StorelessUnivariateStatistic[] {\n+                        new sumMean(), new sumMean()\n+                      });\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals(4, u.getMean()[0], 1E-14);\n+        assertEquals(6, u.getMean()[1], 1E-14);\n+        u.clear();\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals(4, u.getMean()[0], 1E-14);\n+        assertEquals(6, u.getMean()[1], 1E-14);\n+        u.clear();\n+        u.setMeanImpl(new StorelessUnivariateStatistic[] {\n+                        new Mean(), new Mean()\n+                      }); // OK after clear\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals(2, u.getMean()[0], 1E-14);\n+        assertEquals(3, u.getMean()[1], 1E-14);\n+        assertEquals(2, u.getDimension());\n+    }\n+    \n+    public void testSetterIllegalState() throws Exception {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        try {\n+            u.setMeanImpl(new StorelessUnivariateStatistic[] {\n+                            new sumMean(), new sumMean()\n+                          });\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToString() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics stats = createMultivariateSummaryStatistics(2, true);\n+        stats.addValue(new double[] {1, 3});\n+        stats.addValue(new double[] {2, 2});\n+        stats.addValue(new double[] {3, 1});\n+        Locale d = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        assertEquals(\"MultivariateSummaryStatistics:\\n\" +\n+                     \"n: 3\\n\" +\n+                     \"min: 1.0, 1.0\\n\" +\n+                     \"max: 3.0, 3.0\\n\" +\n+                     \"mean: 2.0, 2.0\\n\" +\n+                     \"geometric mean: 1.817..., 1.817...\\n\" +\n+                     \"sum of squares: 14.0, 14.0\\n\" +\n+                     \"sum of logarithms: 1.791..., 1.791...\\n\" +\n+                     \"standard deviation: 1.0, 1.0\\n\" +\n+                     \"covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}\\n\",\n+                     stats.toString().replaceAll(\"([0-9]+\\\\.[0-9][0-9][0-9])[0-9]+\", \"$1...\"));\n+        Locale.setDefault(d);\n+    }\n+\n+    public void testShuffledStatistics() throws DimensionMismatchException {\n+        // the purpose of this test is only to check the get/set methods\n+        // we are aware shuffling statistics like this is really not\n+        // something sensible to do in production ...\n+        MultivariateSummaryStatistics reference = createMultivariateSummaryStatistics(2, true);\n+        MultivariateSummaryStatistics shuffled  = createMultivariateSummaryStatistics(2, true);\n+\n+        StorelessUnivariateStatistic[] tmp = shuffled.getGeoMeanImpl();\n+        shuffled.setGeoMeanImpl(shuffled.getMeanImpl());\n+        shuffled.setMeanImpl(shuffled.getMaxImpl());\n+        shuffled.setMaxImpl(shuffled.getMinImpl());\n+        shuffled.setMinImpl(shuffled.getSumImpl());\n+        shuffled.setSumImpl(shuffled.getSumsqImpl());\n+        shuffled.setSumsqImpl(shuffled.getSumLogImpl());\n+        shuffled.setSumLogImpl(tmp);\n+\n+        for (int i = 100; i > 0; --i) {\n+            reference.addValue(new double[] {i, i});\n+            shuffled.addValue(new double[] {i, i});\n+        }\n+\n+        TestUtils.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);\n+        TestUtils.assertEquals(reference.getMax(),           shuffled.getMean(),          1.0e-10);\n+        TestUtils.assertEquals(reference.getMin(),           shuffled.getMax(),           1.0e-10);\n+        TestUtils.assertEquals(reference.getSum(),           shuffled.getMin(),           1.0e-10);\n+        TestUtils.assertEquals(reference.getSumSq(),         shuffled.getSum(),           1.0e-10);\n+        TestUtils.assertEquals(reference.getSumLog(),        shuffled.getSumSq(),         1.0e-10);\n+        TestUtils.assertEquals(reference.getGeometricMean(), shuffled.getSumLog(),        1.0e-10);\n+\n+    }\n+    \n+    /**\n+     * Bogus mean implementation to test setter injection.\n+     * Returns the sum instead of the mean.\n+     */\n+    static class sumMean implements StorelessUnivariateStatistic {   \n+        private double sum = 0;\n+        private long n = 0;\n+        public double evaluate(double[] values, int begin, int length) {\n+            return 0;\n+        }\n+        public double evaluate(double[] values) {\n+            return 0;\n+        }\n+        public void clear() {\n+          sum = 0; \n+          n = 0;\n+        }\n+        public long getN() {\n+            return n;\n+        }\n+        public double getResult() {\n+            return sum;\n+        }\n+        public void increment(double d) {\n+            sum += d;\n+            n++;\n+        }\n+        public void incrementAll(double[] values, int start, int length) {\n+        }\n+        public void incrementAll(double[] values) {\n+        }   \n+        public StorelessUnivariateStatistic copy() {\n+            return new sumMean();\n+        }\n+    }\n+\n+    public void testDimension() {\n+        try {\n+            createMultivariateSummaryStatistics(2, true).addValue(new double[3]);\n+        } catch (DimensionMismatchException dme) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test stats */\n+    public void testStats() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n+        assertEquals(0, u.getN());\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 2, 3 });\n+        u.addValue(new double[] { 2, 3 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals( 4, u.getN());\n+        assertEquals( 8, u.getSum()[0], 1.0e-10);\n+        assertEquals(12, u.getSum()[1], 1.0e-10);\n+        assertEquals(18, u.getSumSq()[0], 1.0e-10);\n+        assertEquals(38, u.getSumSq()[1], 1.0e-10);\n+        assertEquals( 1, u.getMin()[0], 1.0e-10);\n+        assertEquals( 2, u.getMin()[1], 1.0e-10);\n+        assertEquals( 3, u.getMax()[0], 1.0e-10);\n+        assertEquals( 4, u.getMax()[1], 1.0e-10);\n+        assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);\n+        assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);\n+        assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);\n+        assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);\n+        assertEquals( 2, u.getMean()[0], 1.0e-10);\n+        assertEquals( 3, u.getMean()[1], 1.0e-10);\n+        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);\n+        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);\n+        u.clear();\n+        assertEquals(0, u.getN());    \n+    }     \n+\n+    public void testN0andN1Conditions() throws Exception {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);\n+        assertTrue(Double.isNaN(u.getMean()[0]));\n+        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n+\n+        /* n=1 */\n+        u.addValue(new double[] { 1 });\n+        assertEquals(1.0, u.getMean()[0], 1.0e-10);\n+        assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);\n+        assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);\n+\n+        /* n=2 */               \n+        u.addValue(new double[] { 2 });\n+        assertTrue(u.getStandardDeviation()[0] > 0);\n+\n+    }\n+\n+    public void testNaNContracts() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);\n+        assertTrue(Double.isNaN(u.getMean()[0])); \n+        assertTrue(Double.isNaN(u.getMin()[0])); \n+        assertTrue(Double.isNaN(u.getStandardDeviation()[0])); \n+        assertTrue(Double.isNaN(u.getGeometricMean()[0]));\n+\n+        u.addValue(new double[] { 1.0 });\n+        assertFalse(Double.isNaN(u.getMean()[0])); \n+        assertFalse(Double.isNaN(u.getMin()[0])); \n+        assertFalse(Double.isNaN(u.getStandardDeviation()[0])); \n+        assertFalse(Double.isNaN(u.getGeometricMean()[0]));\n+\n+    }\n+\n+    public void testSerialization() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n+        // Empty test\n+        TestUtils.checkSerializedEquality(u);\n+        MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);\n+        assertEquals(u, s);\n+\n+        // Add some data\n+        u.addValue(new double[] { 2d, 1d });\n+        u.addValue(new double[] { 1d, 1d });\n+        u.addValue(new double[] { 3d, 1d });\n+        u.addValue(new double[] { 4d, 1d });\n+        u.addValue(new double[] { 5d, 1d });\n+\n+        // Test again\n+        TestUtils.checkSerializedEquality(u);\n+        s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);\n+        assertEquals(u, s);\n+\n+    }\n+\n+    public void testEqualsAndHashCode() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n+        MultivariateSummaryStatistics t = null;\n+        int emptyHash = u.hashCode();\n+        assertTrue(u.equals(u));\n+        assertFalse(u.equals(t));\n+        assertFalse(u.equals(Double.valueOf(0)));\n+        t = createMultivariateSummaryStatistics(2, true);\n+        assertTrue(t.equals(u));\n+        assertTrue(u.equals(t));\n+        assertEquals(emptyHash, t.hashCode());\n+\n+        // Add some data to u\n+        u.addValue(new double[] { 2d, 1d });\n+        u.addValue(new double[] { 1d, 1d });\n+        u.addValue(new double[] { 3d, 1d });\n+        u.addValue(new double[] { 4d, 1d });\n+        u.addValue(new double[] { 5d, 1d });\n+        assertFalse(t.equals(u));\n+        assertFalse(u.equals(t));\n+        assertTrue(u.hashCode() != t.hashCode());\n+\n+        //Add data in same order to t\n+        t.addValue(new double[] { 2d, 1d });\n+        t.addValue(new double[] { 1d, 1d });\n+        t.addValue(new double[] { 3d, 1d });\n+        t.addValue(new double[] { 4d, 1d });\n+        t.addValue(new double[] { 5d, 1d });\n+        assertTrue(t.equals(u));\n+        assertTrue(u.equals(t));\n+        assertEquals(u.hashCode(), t.hashCode());   \n+\n+        // Clear and make sure summaries are indistinguishable from empty summary\n+        u.clear();\n+        t.clear();\n+        assertTrue(t.equals(u));\n+        assertTrue(u.equals(t));\n+        assertEquals(emptyHash, t.hashCode());\n+        assertEquals(emptyHash, u.hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+/**\n+ * Test cases for the {@link StatisticalSummaryValues} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class StatisticalSummaryValuesTest extends TestCase {\n+    \n+    \n+    public StatisticalSummaryValuesTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);\n+        suite.setName(\"StatisticalSummaryValues Tests\");\n+        return suite;\n+    }\n+      \n+    public void testSerialization() {\n+        StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n+        TestUtils.checkSerializedEquality(u); \n+        StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);\n+        verifyEquality(u, t);\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n+        StatisticalSummaryValues t = null;\n+        assertTrue(\"reflexive\", u.equals(u));\n+        assertFalse(\"non-null compared to null\", u.equals(t));\n+        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n+        t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n+        assertTrue(\"instances with same data should be equal\", t.equals(u));\n+        assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n+        \n+        u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);\n+        t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);\n+        assertFalse(\"instances based on different data should be different\", \n+                (u.equals(t) ||t.equals(u)));\n+    }\n+    \n+    private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {\n+        assertEquals(\"N\",s.getN(),u.getN());\n+        TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(), 0);\n+        TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(), 0);\n+        TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(), 0);\n+        TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(), 0);\n+        TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(), 0);\n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(), 0);   \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n+\n+/**\n+ * Test cases for {@link StorelessUnivariateStatistic} classes.\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class StorelessUnivariateStatisticAbstractTest\n+    extends UnivariateStatisticAbstractTest {\n+\n+    public StorelessUnivariateStatisticAbstractTest(String name) {\n+        super(name);\n+    }\n+    \n+    /** Small sample arrays */\n+    protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};\n+\n+    /** Return a new instance of the statistic */\n+    @Override\n+    public abstract UnivariateStatistic getUnivariateStatistic();\n+\n+    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    @Override\n+    public abstract double expectedValue();\n+    \n+    /** \n+     *  Verifies that increment() and incrementAll work properly. \n+     */\n+    public void testIncrementation() throws Exception {\n+\n+        StorelessUnivariateStatistic statistic =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        \n+        // Add testArray one value at a time and check result\n+        for (int i = 0; i < testArray.length; i++) {\n+            statistic.increment(testArray[i]);\n+        }\n+        \n+        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        assertEquals(testArray.length, statistic.getN());\n+\n+        statistic.clear();\n+        \n+        // Add testArray all at once and check again\n+        statistic.incrementAll(testArray);\n+        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        assertEquals(testArray.length, statistic.getN());\n+        \n+        statistic.clear();\n+        \n+        // Cleared\n+        assertTrue(Double.isNaN(statistic.getResult()));\n+        assertEquals(0, statistic.getN());\n+\n+    }\n+\n+    public void testSerialization() throws Exception {\n+\n+        StorelessUnivariateStatistic statistic =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        \n+        TestUtils.checkSerializedEquality(statistic);\n+\n+        statistic.clear();\n+\n+        for (int i = 0; i < testArray.length; i++) {\n+            statistic.increment(testArray[i]);\n+            if(i % 5 == 0)\n+                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic); \n+        }\n+        \n+        TestUtils.checkSerializedEquality(statistic);\n+        \n+        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+\n+        statistic.clear();\n+\n+        assertTrue(Double.isNaN(statistic.getResult()));\n+\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        StorelessUnivariateStatistic statistic =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        StorelessUnivariateStatistic statistic2 = null;\n+        \n+        assertTrue(\"non-null, compared to null\", !statistic.equals(statistic2));\n+        assertTrue(\"reflexive, non-null\", statistic.equals(statistic));\n+        \n+        int emptyHash = statistic.hashCode();\n+        statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        assertTrue(\"empty stats should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"empty stats should have the same hashcode\", \n+                emptyHash, statistic2.hashCode());\n+        \n+        statistic.increment(1d);\n+        assertTrue(\"reflexive, non-empty\", statistic.equals(statistic));\n+        assertTrue(\"non-empty, compared to empty\", !statistic.equals(statistic2));\n+        assertTrue(\"non-empty, compared to empty\", !statistic2.equals(statistic));\n+        assertTrue(\"non-empty stat should have different hashcode from empty stat\",\n+                statistic.hashCode() != emptyHash);\n+        \n+        statistic2.increment(1d);\n+        assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"stats with same data should have the same hashcode\", \n+                statistic.hashCode(), statistic2.hashCode());\n+        \n+        statistic.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(\"stats with different n's should not be equal\", !statistic2.equals(statistic));\n+        assertTrue(\"stats with different n's should have different hashcodes\",\n+                statistic.hashCode() != statistic2.hashCode());\n+        \n+        statistic2.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"stats with same data should have the same hashcode\", \n+                statistic.hashCode(), statistic2.hashCode()); \n+        \n+        statistic.clear();\n+        statistic2.clear();\n+        assertTrue(\"cleared stats should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"cleared stats should have thashcode of empty stat\", \n+                emptyHash, statistic2.hashCode());\n+        assertEquals(\"cleared stats should have thashcode of empty stat\", \n+                emptyHash, statistic.hashCode());\n+        \n+    }\n+    \n+    public void testMomentSmallSamples() {\n+        UnivariateStatistic stat = getUnivariateStatistic();\n+        if (stat instanceof SecondMoment) {\n+            SecondMoment moment = (SecondMoment) getUnivariateStatistic();\n+            assertTrue(Double.isNaN(moment.getResult()));\n+            moment.increment(1d);\n+            assertEquals(0d, moment.getResult(), 0);\n+        }\n+    }\n+    \n+    /** \n+     * Make sure that evaluate(double[]) and inrementAll(double[]), \n+     * getResult() give same results.\n+     */\n+    public void testConsistency() {\n+        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        stat.incrementAll(testArray);\n+        assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());\n+        for (int i = 0; i < smallSamples.length; i++) {\n+            stat.clear();\n+            for (int j =0; j < smallSamples[i].length; j++) {\n+                stat.increment(smallSamples[i][j]);\n+            }\n+            TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());\n+        }\n+    }\n+    \n+    /**\n+     * Verifies that copied statistics remain equal to originals when\n+     * incremented the same way.\n+     *\n+     */\n+    public void testCopyConsistency() {\n+        \n+        StorelessUnivariateStatistic master =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        \n+        StorelessUnivariateStatistic replica = null;\n+        \n+        // Randomly select a portion of testArray to load first\n+        long index = Math.round((Math.random()) * testArray.length);\n+        \n+        // Put first half in master and copy master to replica\n+        master.incrementAll(testArray, 0, (int) index);\n+        replica = master.copy();\n+        \n+        // Check same\n+        assertTrue(replica.equals(master));\n+        assertTrue(master.equals(replica));\n+        \n+        // Now add second part to both and check again\n+        master.incrementAll(testArray, \n+                (int) index, (int) (testArray.length - index));\n+        replica.incrementAll(testArray, \n+                (int) index, (int) (testArray.length - index));\n+        assertTrue(replica.equals(master));\n+        assertTrue(master.equals(replica));\n+    }\n+    \n+    public void testSerial() {\n+        StorelessUnivariateStatistic s =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        assertEquals(s, TestUtils.serializeAndRecover(s));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+/**\n+ * Test cases for the {@link SummaryStatistics} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class SummaryStatisticsTest extends TestCase {\n+\n+    private double one = 1;\n+    private float twoF = 2;\n+    private long twoL = 2;\n+    private int three = 3;\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double tolerance = 10E-15;\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SummaryStatisticsTest.class);\n+        suite.setName(\"SummaryStatistics tests\");\n+        return suite;\n+    }\n+\n+    public SummaryStatisticsTest(String name) {\n+        super(name);\n+    }\n+    \n+    protected SummaryStatistics createSummaryStatistics() {\n+        return new SummaryStatistics();\n+    }\n+\n+    /** test stats */\n+    public void testStats() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(twoF);\n+        u.addValue(twoL);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+\n+    public void testN0andN1Conditions() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        assertTrue(\"Mean of n = 0 set should be NaN\", \n+                Double.isNaN( u.getMean() ) );\n+        assertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+                Double.isNaN( u.getStandardDeviation() ) );\n+        assertTrue(\"Variance of n = 0 set should be NaN\", \n+                Double.isNaN(u.getVariance() ) );\n+\n+        /* n=1 */\n+        u.addValue(one);\n+        assertTrue(\"mean should be one (n = 1)\", \n+                u.getMean() == one);\n+        assertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(), \n+                u.getGeometricMean() == one);\n+        assertTrue(\"Std should be zero (n = 1)\", \n+                u.getStandardDeviation() == 0.0);\n+        assertTrue(\"variance should be zero (n = 1)\", \n+                u.getVariance() == 0.0);\n+\n+        /* n=2 */               \n+        u.addValue(twoF);\n+        assertTrue(\"Std should not be zero (n = 2)\", \n+                u.getStandardDeviation() != 0.0);\n+        assertTrue(\"variance should not be zero (n = 2)\", \n+                u.getVariance() != 0.0);\n+\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        assertEquals( \"Geometric mean not expected\", 2.213364, \n+                u.getGeometricMean(), 0.00001 );\n+    }\n+\n+    public void testNaNContracts() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean())); \n+        assertTrue(\"min not NaN\",Double.isNaN(u.getMin())); \n+        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation())); \n+        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance())); \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+\n+        u.addValue(1.0);\n+\n+        assertEquals( \"mean not expected\", 1.0, \n+                u.getMean(), Double.MIN_VALUE);\n+        assertEquals( \"variance not expected\", 0.0, \n+                u.getVariance(), Double.MIN_VALUE);\n+        assertEquals( \"geometric mean not expected\", 1.0, \n+                u.getGeometricMean(), Double.MIN_VALUE);\n+\n+        u.addValue(-1.0);\n+\n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+\n+        u.addValue(0.0);\n+\n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+\n+        //FiXME: test all other NaN contract specs\n+    }\n+\n+    public void testGetSummary() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        StatisticalSummary summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(1d);\n+        summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(2d);\n+        summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(2d);\n+        summary = u.getSummary();\n+        verifySummary(u, summary);     \n+    }\n+\n+    public void testSerialization() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        // Empty test\n+        TestUtils.checkSerializedEquality(u);\n+        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);\n+        StatisticalSummary summary = s.getSummary();\n+        verifySummary(u, summary);\n+\n+        // Add some data\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        u.addValue(5d);\n+\n+        // Test again\n+        TestUtils.checkSerializedEquality(u);\n+        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);\n+        summary = s.getSummary();\n+        verifySummary(u, summary);\n+\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        SummaryStatistics t = null;\n+        int emptyHash = u.hashCode();\n+        assertTrue(\"reflexive\", u.equals(u));\n+        assertFalse(\"non-null compared to null\", u.equals(t));\n+        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n+        t = createSummaryStatistics();\n+        assertTrue(\"empty instances should be equal\", t.equals(u));\n+        assertTrue(\"empty instances should be equal\", u.equals(t));\n+        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+\n+        // Add some data to u\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        assertFalse(\"different n's should make instances not equal\", t.equals(u));\n+        assertFalse(\"different n's should make instances not equal\", u.equals(t));\n+        assertTrue(\"different n's should make hashcodes different\", \n+                u.hashCode() != t.hashCode());\n+\n+        //Add data in same order to t\n+        t.addValue(2d);\n+        t.addValue(1d);\n+        t.addValue(3d);\n+        t.addValue(4d);\n+        assertTrue(\"summaries based on same data should be equal\", t.equals(u));\n+        assertTrue(\"summaries based on same data should be equal\", u.equals(t));\n+        assertEquals(\"summaries based on same data should have same hashcodes\", \n+                u.hashCode(), t.hashCode());   \n+\n+        // Clear and make sure summaries are indistinguishable from empty summary\n+        u.clear();\n+        t.clear();\n+        assertTrue(\"empty instances should be equal\", t.equals(u));\n+        assertTrue(\"empty instances should be equal\", u.equals(t));\n+        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+        assertEquals(\"empty hash code\", emptyHash, u.hashCode());\n+    }\n+    \n+    public void testCopy() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        SummaryStatistics v = new SummaryStatistics(u);\n+        assertEquals(u, v);\n+        assertEquals(v, u);\n+        assertTrue(v.geoMean == v.getGeoMeanImpl());\n+        assertTrue(v.mean == v.getMeanImpl());\n+        assertTrue(v.min == v.getMinImpl());\n+        assertTrue(v.max == v.getMaxImpl());\n+        assertTrue(v.sum == v.getSumImpl());\n+        assertTrue(v.sumsq == v.getSumsqImpl());\n+        assertTrue(v.sumLog == v.getSumLogImpl());\n+        assertTrue(v.variance == v.getVarianceImpl());\n+        \n+        // Make sure both behave the same with additional values added\n+        u.addValue(7d);\n+        u.addValue(9d);\n+        u.addValue(11d);\n+        u.addValue(23d);\n+        v.addValue(7d);\n+        v.addValue(9d);\n+        v.addValue(11d);\n+        v.addValue(23d);\n+        assertEquals(u, v);\n+        assertEquals(v, u);\n+        \n+        // Check implementation pointers are preserved\n+        u.clear();\n+        u.setSumImpl(new Sum());\n+        SummaryStatistics.copy(u,v);\n+        assertEquals(u.sum, v.sum);\n+        assertEquals(u.getSumImpl(), v.getSumImpl());\n+        \n+    }\n+\n+    private void verifySummary(SummaryStatistics u, StatisticalSummary s) {\n+        assertEquals(\"N\",s.getN(),u.getN());\n+        TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(),tolerance);\n+        TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(),tolerance);\n+        TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);\n+        TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(),tolerance);\n+        TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(),tolerance);\n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(),tolerance);   \n+    }\n+\n+    public void testSetterInjection() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        u.setMeanImpl(new Sum());\n+        u.setSumLogImpl(new Sum());\n+        u.addValue(1);\n+        u.addValue(3);\n+        assertEquals(4, u.getMean(), 1E-14);\n+        assertEquals(4, u.getSumOfLogs(), 1E-14);\n+        assertEquals(Math.exp(2), u.getGeometricMean(), 1E-14);\n+        u.clear();\n+        u.addValue(1);\n+        u.addValue(2);\n+        assertEquals(3, u.getMean(), 1E-14);\n+        u.clear();\n+        u.setMeanImpl(new Mean()); // OK after clear\n+    }\n+    \n+    public void testSetterIllegalState() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        u.addValue(1);\n+        u.addValue(3);\n+        try {\n+            u.setMeanImpl(new Sum());\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class.\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ *          2007) $\n+ */\n+public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {\n+\n+    public SynchronizedDescriptiveStatisticsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SynchronizedDescriptiveStatisticsTest.class);\n+        suite.setName(\"SynchronizedDescriptiveStatistics Tests\");\n+        return suite;\n+    }\n+\n+    protected DescriptiveStatistics createDescriptiveStatistics() {\n+        return new SynchronizedDescriptiveStatistics();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SynchronizedMultivariateSummaryStatisticsTest} class.\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ *          2007) $\n+ */\n+public final class SynchronizedMultivariateSummaryStatisticsTest extends MultivariateSummaryStatisticsTest {\n+\n+    public SynchronizedMultivariateSummaryStatisticsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SynchronizedMultivariateSummaryStatisticsTest.class);\n+        suite.setName(\"SynchronizedMultivariateSummaryStatistics Tests\");\n+        return suite;\n+    }\n+\n+    protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n+        return new SynchronizedMultivariateSummaryStatistics(k, isCovarianceBiasCorrected);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SynchronizedSummaryStatisticsTest} class.\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ *          2007) $\n+ */\n+public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {\n+\n+    public SynchronizedSummaryStatisticsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SynchronizedSummaryStatisticsTest.class);\n+        suite.setName(\"SynchronizedSummaryStatistics Tests\");\n+        return suite;\n+    }\n+\n+    @Override\n+    protected SummaryStatistics createSummaryStatistics() {\n+        return new SynchronizedSummaryStatistics();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class UnivariateStatisticAbstractTest extends TestCase {\n+\n+    protected double mean = 12.404545454545455d;\n+    protected double geoMean = 12.070589161633011d;\n+\n+    protected double var = 10.00235930735931d;\n+    protected double std = Math.sqrt(var);\n+    protected double skew = 1.437423729196190d;\n+    protected double kurt = 2.377191264804700d;\n+\n+    protected double min = 8.2d;\n+    protected double max = 21d;\n+    protected double median = 12d;\n+    protected double percentile5 = 8.29d;\n+    protected double percentile95 = 20.82d;\n+\n+    protected double product = 628096400563833396009676.9200400128d;\n+    protected double sumLog = 54.7969806116451507d;\n+    protected double sumSq = 3595.250d;\n+    protected double sum = 272.90d;\n+    protected double secondMoment = 210.04954545454547d;\n+    protected double thirdMoment = 868.0906859504136;\n+    protected double fourthMoment = 9244.080993773481;\n+\n+    protected double tolerance = 10E-12;\n+\n+    protected double[] testArray =\n+        {12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3,\n+          14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,\n+           9, 12.3 };\n+\n+    public UnivariateStatisticAbstractTest(String name) {\n+        super(name);\n+    }\n+\n+    public abstract UnivariateStatistic getUnivariateStatistic();\n+\n+    public abstract double expectedValue();\n+\n+    public double getTolerance() {\n+        return tolerance;\n+    }\n+\n+    public void testEvaluation() throws Exception {   \n+        assertEquals(\n+            expectedValue(),\n+            getUnivariateStatistic().evaluate(testArray),\n+            getTolerance());\n+    }\n+    \n+    public void testCopy() throws Exception {\n+        UnivariateStatistic original = getUnivariateStatistic();\n+        UnivariateStatistic copy = original.copy();\n+        assertEquals(\n+                expectedValue(),\n+                copy.evaluate(testArray),\n+                getTolerance());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link FirstMoment} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected FirstMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public FirstMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new FirstMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.mean;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link FourthMoment} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected FourthMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public FourthMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new FourthMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    @Override\n+    public double expectedValue() {\n+       return this.fourthMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected GeometricMean stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public GeometricMeanTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(GeometricMeanTest.class);\n+        suite.setName(\"Mean  Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new GeometricMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.geoMean;\n+    }\n+    \n+    public void testSpecialValues() {\n+        GeometricMean mean = new GeometricMean();\n+        // empty\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        \n+        // finite data\n+        mean.increment(1d);\n+        assertFalse(Double.isNaN(mean.getResult()));\n+        \n+        // add 0 -- makes log sum blow to minus infinity, should make 0\n+        mean.increment(0d);\n+        assertEquals(0d, mean.getResult(), 0);\n+        \n+        // add positive infinity - note the minus infinity above\n+        mean.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        \n+        // clear\n+        mean.clear();\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        \n+        // positive infinity by itself\n+        mean.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);\n+        \n+        // negative value -- should make NaN\n+        mean.increment(-2d);\n+        assertTrue(Double.isNaN(mean.getResult()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Kurtosis stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public KurtosisTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(KurtosisTest.class);\n+        suite.setName(\"Kurtosis  Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Kurtosis();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.kurt;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n < 4\n+     *\n+     */\n+    public void testNaN() {\n+        Kurtosis kurt = new Kurtosis();\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertFalse(Double.isNaN(kurt.getResult()));      \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class MeanTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Mean stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MeanTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MeanTest.class);\n+        suite.setName(\"Mean  Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Mean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.mean;\n+    }\n+    \n+    public void testSmallSamples() {\n+        Mean mean = new Mean();\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        mean.increment(1d);\n+        assertEquals(1d, mean.getResult(), 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link SecondMoment} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {\n+\n+    /** descriptive statistic. */\n+    protected SecondMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SecondMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new SecondMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.secondMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Skewness stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SkewnessTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Skewness();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SkewnessTest.class);\n+        suite.setName(\"Skewness Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.skew;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n < 3\n+     *\n+     */\n+    public void testNaN() {\n+        Skewness skew = new Skewness();\n+        assertTrue(Double.isNaN(skew.getResult()));\n+        skew.increment(1d);\n+        assertTrue(Double.isNaN(skew.getResult()));\n+        skew.increment(1d);\n+        assertTrue(Double.isNaN(skew.getResult()));\n+        skew.increment(1d);\n+        assertFalse(Double.isNaN(skew.getResult()));      \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected StandardDeviation stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public StandardDeviationTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new StandardDeviation();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StandardDeviationTest.class);\n+        suite.setName(\"StandardDeviation Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.std;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n = 0\n+     *\n+     */\n+    public void testNaN() {\n+        StandardDeviation std = new StandardDeviation();\n+        assertTrue(Double.isNaN(std.getResult()));\n+        std.increment(1d);\n+        assertEquals(0d, std.getResult(), 0);\n+    }\n+    \n+    /**\n+     * Test population version of variance\n+     */ \n+    public void testPopulation() {\n+        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n+        double sigma = populationStandardDeviation(values);\n+        SecondMoment m = new SecondMoment();\n+        m.evaluate(values);  // side effect is to add values\n+        StandardDeviation s1 = new StandardDeviation();\n+        s1.setBiasCorrected(false);\n+        assertEquals(sigma, s1.evaluate(values), 1E-14);\n+        s1.incrementAll(values);\n+        assertEquals(sigma, s1.getResult(), 1E-14);\n+        s1 = new StandardDeviation(false, m);\n+        assertEquals(sigma, s1.getResult(), 1E-14);     \n+        s1 = new StandardDeviation(false);\n+        assertEquals(sigma, s1.evaluate(values), 1E-14);\n+        s1.incrementAll(values);\n+        assertEquals(sigma, s1.getResult(), 1E-14);     \n+    }\n+    \n+    /**\n+     * Definitional formula for population standard deviation\n+     */\n+    protected double populationStandardDeviation(double[] v) {\n+        double mean = new Mean().evaluate(v);\n+        double sum = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            sum += (v[i] - mean) * (v[i] - mean); \n+        }\n+        return Math.sqrt(sum / v.length);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link ThirdMoment} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected ThirdMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public ThirdMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new ThirdMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    @Override\n+    public double expectedValue() {\n+      return this.thirdMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Variance stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public VarianceTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Variance();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(VarianceTest.class);\n+        suite.setName(\"Variance Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.var;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n = 0\n+     *\n+     */\n+    public void testNaN() {\n+        StandardDeviation std = new StandardDeviation();\n+        assertTrue(Double.isNaN(std.getResult()));\n+        std.increment(1d);\n+        assertEquals(0d, std.getResult(), 0);\n+    }\n+    \n+    /**\n+     * Test population version of variance\n+     */ \n+    public void testPopulation() {\n+        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n+        SecondMoment m = new SecondMoment();\n+        m.evaluate(values);  // side effect is to add values\n+        Variance v1 = new Variance();\n+        v1.setBiasCorrected(false);\n+        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n+        v1.incrementAll(values);\n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n+        v1 = new Variance(false, m);\n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);     \n+        v1 = new Variance(false);\n+        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n+        v1.incrementAll(values);\n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);     \n+    }\n+    \n+    /**\n+     * Definitional formula for population variance\n+     */\n+    protected double populationVariance(double[] v) {\n+        double mean = new Mean().evaluate(v);\n+        double sum = 0;\n+        for (int i = 0; i < v.length; i++) {\n+           sum += (v[i] - mean) * (v[i] - mean); \n+        }\n+        return sum / v.length;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class VectorialCovarianceTest\n+extends TestCase {\n+\n+    public VectorialCovarianceTest(String name) {\n+        super(name);\n+        points = null;\n+    }\n+\n+    public void testMismatch() {\n+        try {\n+            new VectorialCovariance(8, true).increment(new double[5]);\n+            fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException dme) {\n+            assertEquals(5, dme.getDimension1());\n+            assertEquals(8, dme.getDimension2());\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught: \" + e.getClass().getName());\n+        }\n+    }\n+\n+    public void testSimplistic() throws DimensionMismatchException {\n+        VectorialCovariance stat = new VectorialCovariance(2, true);\n+        stat.increment(new double[] {-1.0,  1.0});\n+        stat.increment(new double[] { 1.0, -1.0});\n+        RealMatrix c = stat.getResult();\n+        assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);\n+        assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);\n+        assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);\n+    }\n+\n+    public void testBasicStats() throws DimensionMismatchException {\n+\n+        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);\n+        for (int i = 0; i < points.length; ++i) {\n+            stat.increment(points[i]);\n+        }\n+\n+        assertEquals(points.length, stat.getN());\n+\n+        RealMatrix c = stat.getResult();\n+        double[][] refC    = new double[][] {\n+                { 8.0470, -1.9195, -3.4445},\n+                {-1.9195,  1.0470,  3.2795},\n+                {-3.4445,  3.2795, 12.2070}\n+        };\n+\n+        for (int i = 0; i < c.getRowDimension(); ++i) {\n+            for (int j = 0; j <= i; ++j) {\n+                assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);\n+            }\n+        }\n+\n+    }\n+\n+    public void testSerial(){\n+        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);\n+        assertEquals(stat, TestUtils.serializeAndRecover(stat));\n+    }\n+    \n+    @Override\n+    public void setUp() {\n+        points = new double[][] {\n+                { 1.2, 2.3,  4.5},\n+                {-0.7, 2.3,  5.0},\n+                { 3.1, 0.0, -3.1},\n+                { 6.0, 1.2,  4.2},\n+                {-0.7, 2.3,  5.0}\n+        };\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        points = null;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(VectorialCovarianceTest.class);\n+    }\n+\n+    private double [][] points;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialMeanTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class VectorialMeanTest\n+extends TestCase {\n+\n+    public VectorialMeanTest(String name) {\n+        super(name);\n+        points = null;\n+    }\n+\n+    public void testMismatch() {\n+        try {\n+            new VectorialMean(8).increment(new double[5]);\n+            fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException dme) {\n+            assertEquals(5, dme.getDimension1());\n+            assertEquals(8, dme.getDimension2());\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught: \" + e.getClass().getName());\n+        }\n+    }\n+\n+    public void testSimplistic() throws DimensionMismatchException {\n+        VectorialMean stat = new VectorialMean(2);\n+        stat.increment(new double[] {-1.0,  1.0});\n+        stat.increment(new double[] { 1.0, -1.0});\n+        double[] mean = stat.getResult();\n+        assertEquals(0.0, mean[0], 1.0e-12);\n+        assertEquals(0.0, mean[1], 1.0e-12);\n+    }\n+\n+    public void testBasicStats() throws DimensionMismatchException {\n+\n+        VectorialMean stat = new VectorialMean(points[0].length);\n+        for (int i = 0; i < points.length; ++i) {\n+            stat.increment(points[i]);\n+        }\n+\n+        assertEquals(points.length, stat.getN());\n+\n+        double[] mean = stat.getResult();\n+        double[]   refMean = new double[] { 1.78, 1.62,  3.12};\n+\n+        for (int i = 0; i < mean.length; ++i) {\n+            assertEquals(refMean[i], mean[i], 1.0e-12);\n+        }\n+\n+    }\n+\n+    public void testSerial() throws DimensionMismatchException {\n+        VectorialMean stat = new VectorialMean(points[0].length);\n+        for (int i = 0; i < points.length; ++i) {\n+            stat.increment(points[i]);\n+        }\n+        assertEquals(stat, TestUtils.serializeAndRecover(stat));\n+    }\n+    @Override\n+    public void setUp() {\n+        points = new double[][] {\n+                { 1.2, 2.3,  4.5},\n+                {-0.7, 2.3,  5.0},\n+                { 3.1, 0.0, -3.1},\n+                { 6.0, 1.2,  4.2},\n+                {-0.7, 2.3,  5.0}\n+        };\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        points = null;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(VectorialMeanTest.class);\n+    }\n+\n+    private double [][] points;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class MaxTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Max stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MaxTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MaxTest.class);\n+        suite.setName(\"Max  Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Max();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.max;\n+    }\n+    \n+    public void testSpecialValues() {\n+        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, \n+                Double.POSITIVE_INFINITY};\n+        Max max = new Max();\n+        assertTrue(Double.isNaN(max.getResult()));\n+        max.increment(testArray[0]);\n+        assertEquals(0d, max.getResult(), 0);\n+        max.increment(testArray[1]);\n+        assertEquals(0d, max.getResult(), 0);\n+        max.increment(testArray[2]);\n+        assertEquals(0d, max.getResult(), 0);\n+        max.increment(testArray[3]);\n+        assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);\n+        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     \n+    }\n+\n+    public void testNaNs() {\n+        Max max = new Max();\n+        double nan = Double.NaN;\n+        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);     \n+        assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);     \n+        assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);     \n+        assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));     \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class MedianTest extends UnivariateStatisticAbstractTest{\n+\n+    protected Median stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MedianTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MedianTest.class);\n+        suite.setName(\"Median  Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {  \n+        return new Median();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.median;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class MinTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Min stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MinTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MinTest.class);\n+        suite.setName(\"Min  Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Min();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.min;\n+    }\n+    \n+    public void testSpecialValues() {\n+        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, \n+                Double.NEGATIVE_INFINITY};\n+        Min min = new Min();\n+        assertTrue(Double.isNaN(min.getResult()));\n+        min.increment(testArray[0]);\n+        assertEquals(0d, min.getResult(), 0);\n+        min.increment(testArray[1]);\n+        assertEquals(0d, min.getResult(), 0);\n+        min.increment(testArray[2]);\n+        assertEquals(0d, min.getResult(), 0);\n+        min.increment(testArray[3]);\n+        assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);\n+        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     \n+    }\n+\n+    public void testNaNs() {\n+        Min min = new Min();\n+        double nan = Double.NaN;\n+        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);     \n+        assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);     \n+        assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);     \n+        assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));     \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class PercentileTest extends UnivariateStatisticAbstractTest{\n+\n+    protected Percentile stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public PercentileTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(PercentileTest.class);\n+        suite.setName(\"Percentile Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {   \n+        return new Percentile(95.0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.percentile95;\n+    }\n+\n+    public void testHighPercentile(){\n+        double[] d = new double[]{1, 2, 3};\n+        Percentile p = new Percentile(75);\n+        assertEquals(3.0, p.evaluate(d), 1.0e-5);\n+    }\n+    \n+    public void testPercentile() {\n+        double[] d = new double[] {1, 3, 2, 4};\n+        Percentile p = new Percentile(30);\n+        assertEquals(1.5, p.evaluate(d), 1.0e-5);\n+        p.setQuantile(25);\n+        assertEquals(1.25, p.evaluate(d), 1.0e-5);\n+        p.setQuantile(75);\n+        assertEquals(3.75, p.evaluate(d), 1.0e-5);\n+        p.setQuantile(50);\n+        assertEquals(2.5, p.evaluate(d), 1.0e-5);\n+        \n+        // invalid percentiles\n+        try {\n+            p.evaluate(d, 0, d.length, -1.0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        try {\n+            p.evaluate(d, 0, d.length, 101.0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testNISTExample() {\n+        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, \n+                95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682\n+        };\n+        Percentile p = new Percentile(90); \n+        assertEquals(95.1981, p.evaluate(d), 1.0e-4);\n+        assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);\n+    }\n+    \n+    public void test5() {\n+        Percentile percentile = new Percentile(5);\n+        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());\n+    }\n+    \n+    public void testNullEmpty() {\n+        Percentile percentile = new Percentile(50);\n+        double[] nullArray = null;\n+        double[] emptyArray = new double[] {};\n+        try {\n+            percentile.evaluate(nullArray);\n+            fail(\"Expecting IllegalArgumentException for null array\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));        \n+    }\n+    \n+    public void testSingleton() {\n+        Percentile percentile = new Percentile(50);\n+        double[] singletonArray = new double[] {1d};\n+        assertEquals(1d, percentile.evaluate(singletonArray), 0);\n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);\n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);\n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); \n+        assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));     \n+    }\n+    \n+    public void testSpecialValues() {\n+        Percentile percentile = new Percentile(50);\n+        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};\n+        assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n+        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,\n+                Double.NaN, Double.POSITIVE_INFINITY};\n+        assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n+        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, \n+                Double.POSITIVE_INFINITY};\n+        assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));\n+        specialValues = new double[] {1d, 1d, Double.NaN, \n+                Double.NaN};\n+        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n+        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, \n+                Double.NEGATIVE_INFINITY};\n+        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY\n+        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));   \n+    }\n+    \n+    public void testSetQuantile() {\n+        Percentile percentile = new Percentile(10);\n+        percentile.setQuantile(100); // OK\n+        assertEquals(100, percentile.getQuantile(), 0);      \n+        try {\n+            percentile.setQuantile(0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            new Percentile(0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class ProductTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Product stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public ProductTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ProductTest.class);\n+        suite.setName(\"Product Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Product();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getTolerance() {\n+        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.product;\n+    }\n+    \n+    public void testSpecialValues() {\n+        Product product = new Product();\n+        assertTrue(Double.isNaN(product.getResult()));\n+        product.increment(1);\n+        assertEquals(1, product.getResult(), 0);\n+        product.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);\n+        product.increment(Double.NEGATIVE_INFINITY);\n+        assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);\n+        product.increment(Double.NaN);\n+        assertTrue(Double.isNaN(product.getResult())); \n+        product.increment(1);\n+        assertTrue(Double.isNaN(product.getResult())); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected SumOfLogs stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SumLogTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SumLogTest.class);\n+        suite.setName(\"SumLog Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {        \n+        return new SumOfLogs();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.sumLog;\n+    }\n+    \n+    public void testSpecialValues() {\n+        SumOfLogs sum = new SumOfLogs();\n+        // empty\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        \n+        // finite data\n+        sum.increment(1d);\n+        assertFalse(Double.isNaN(sum.getResult()));\n+        \n+        // add negative infinity\n+        sum.increment(0d);\n+        assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);\n+        \n+        // add positive infinity -- should make NaN\n+        sum.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        \n+        // clear\n+        sum.clear();\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        \n+        // positive infinity by itself\n+        sum.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n+        \n+        // negative value -- should make NaN\n+        sum.increment(-2d);\n+        assertTrue(Double.isNaN(sum.getResult()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link SumOfSquares} class.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected SumOfSquares stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SumSqTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SumSqTest.class);\n+        suite.setName(\"SumSq Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new SumOfSquares();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.sumSq;\n+    }\n+    \n+    public void testSpecialValues() {\n+        SumOfSquares sumSq = new SumOfSquares();\n+        assertTrue(Double.isNaN(sumSq.getResult()));\n+        sumSq.increment(2d);\n+        assertEquals(4d, sumSq.getResult(), 0);\n+        sumSq.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n+        sumSq.increment(Double.NEGATIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n+        sumSq.increment(Double.NaN);\n+        assertTrue(Double.isNaN(sumSq.getResult())); \n+        sumSq.increment(1);\n+        assertTrue(Double.isNaN(sumSq.getResult())); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link Sum} class.\n+ * @version $Revision$ $Date$\n+ */\n+public class SumTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Sum stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SumTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SumTest.class);\n+        suite.setName(\"Sum Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Sum();      \n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double expectedValue() {\n+        return this.sum;\n+    }\n+    \n+    public void testSpecialValues() {\n+        Sum sum = new Sum();\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        sum.increment(1);\n+        assertEquals(1, sum.getResult(), 0);\n+        sum.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n+        sum.increment(Double.NEGATIVE_INFINITY);\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        sum.increment(1);\n+        assertTrue(Double.isNaN(sum.getResult())); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the ChiSquareTestFactory.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class ChiSquareFactoryTest extends ChiSquareTestTest {\n+\n+    public ChiSquareFactoryTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+    \tsuper.setUp();\n+        testStatistic = TestUtils.getUnknownDistributionChiSquareTest();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ChiSquareFactoryTest.class);\n+        suite.setName(\"ChiSquareTestFactory Tests\");\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the ChiSquareTestImpl class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class ChiSquareTestTest extends TestCase {\n+\n+    protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();\n+\n+    public ChiSquareTestTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ChiSquareTestTest.class);\n+        suite.setName(\"TestStatistic Tests\");\n+        return suite;\n+    }\n+\n+    public void testChiSquare() throws Exception {\n+ \n+        // Target values computed using R version 1.8.1 \n+        // Some assembly required ;-)  \n+        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n+        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n+        \n+        long[] observed = {10, 9, 11};\n+        double[] expected = {10, 10, 10};\n+        assertEquals(\"chi-square statistic\", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);\n+        assertEquals(\"chi-square p-value\", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);\n+        \n+        long[] observed1 = { 500, 623, 72, 70, 31 };\n+        double[] expected1 = { 485, 541, 82, 61, 37 };\n+        assertEquals( \"chi-square test statistic\", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);\n+        assertEquals(\"chi-square p-value\", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);\n+        assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(expected1, observed1, 0.08));\n+        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(expected1, observed1, 0.05));\n+\n+        try {\n+            testStatistic.chiSquareTest(expected1, observed1, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        long[] tooShortObs = { 0 };\n+        double[] tooShortEx = { 1 };\n+        try {\n+            testStatistic.chiSquare(tooShortEx, tooShortObs);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        // unmatched arrays\n+        long[] unMatchedObs = { 0, 1, 2, 3 };\n+        double[] unMatchedEx = { 1, 1, 2 };\n+        try {\n+            testStatistic.chiSquare(unMatchedEx, unMatchedObs);\n+            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        // 0 expected count\n+        expected[0] = 0;\n+        try {\n+            testStatistic.chiSquareTest(expected, observed, .01);\n+            fail(\"bad expected count, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        // negative observed count\n+        expected[0] = 1;\n+        observed[0] = -1;\n+        try {\n+            testStatistic.chiSquareTest(expected, observed, .01);\n+            fail(\"bad expected count, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+    }\n+\n+    public void testChiSquareIndependence() throws Exception {\n+        \n+        // Target values computed using R version 1.8.1 \n+        \n+        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n+        assertEquals( \"chi-square test statistic\", 22.709027688, testStatistic.chiSquare(counts), 1E-9);\n+        assertEquals(\"chi-square p-value\", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);\n+        assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(counts, 0.0002));\n+        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts, 0.0001));    \n+        \n+        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n+        assertEquals( \"chi-square test statistic\", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);\n+        assertEquals(\"chi-square p-value\",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);\n+        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts2, 0.1)); \n+        \n+        // ragged input array\n+        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n+        try {\n+            testStatistic.chiSquare(counts3);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        // insufficient data\n+        long[][] counts4 = {{40, 22, 43}};\n+        try {\n+            testStatistic.chiSquare(counts4);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        long[][] counts5 = {{40}, {40}, {30}, {10}};\n+        try {\n+            testStatistic.chiSquare(counts5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        // negative counts\n+        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n+        try {\n+            testStatistic.chiSquare(counts6);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        // bad alpha\n+        try {\n+            testStatistic.chiSquareTest(counts, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+    }\n+    \n+    public void testChiSquareLargeTestStatistic() throws Exception {\n+        double[] exp = new double[] {\n+            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n+            232921.0, 437665.75\n+        };\n+\n+        long[] obs = new long[] {\n+            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n+        };\n+        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n+            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n+        double cst = csti.chiSquareTest(exp, obs); \n+        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n+        assertEquals( \"chi-square test statistic\", \n+                114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);\n+    }\n+    \n+    /** Contingency table containing zeros - PR # 32531 */\n+    public void testChiSquareZeroCount() throws Exception {\n+        // Target values computed using R version 1.8.1 \n+        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n+        assertEquals( \"chi-square test statistic\", 9.67444662263,\n+                testStatistic.chiSquare(counts), 1E-9);\n+        assertEquals(\"chi-square p-value\", 0.0462835770603,\n+                testStatistic.chiSquareTest(counts), 1E-9);       \n+    }\n+    \n+    /** Target values verified using DATAPLOT version 2006.3 */\n+    public void testChiSquareDataSetsComparisonEqualCounts()\n+    throws Exception {\n+        long[] observed1 = {10, 12, 12, 10};\n+        long[] observed2 = {5, 15, 14, 10};    \n+        assertEquals(\"chi-square p value\", 0.541096, \n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2), 1E-6);\n+        assertEquals(\"chi-square test statistic\", 2.153846,\n+                testStatistic.chiSquareDataSetsComparison(\n+                observed1, observed2), 1E-6);\n+        assertFalse(\"chi-square test result\", \n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2, 0.4));\n+    }\n+    \n+    /** Target values verified using DATAPLOT version 2006.3 */\n+    public void testChiSquareDataSetsComparisonUnEqualCounts()\n+    throws Exception {\n+        long[] observed1 = {10, 12, 12, 10, 15};\n+        long[] observed2 = {15, 10, 10, 15, 5};    \n+        assertEquals(\"chi-square p value\", 0.124115, \n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2), 1E-6);\n+        assertEquals(\"chi-square test statistic\", 7.232189,\n+                testStatistic.chiSquareDataSetsComparison(\n+                observed1, observed2), 1E-6);\n+        assertTrue(\"chi-square test result\", \n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2, 0.13));\n+        assertFalse(\"chi-square test result\", \n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2, 0.12));\n+    }\n+    \n+    public void testChiSquareDataSetsComparisonBadCounts()\n+    throws Exception {\n+        long[] observed1 = {10, -1, 12, 10, 15};\n+        long[] observed2 = {15, 10, 10, 15, 5};\n+        try {\n+            testStatistic.chiSquareTestDataSetsComparison(\n+                    observed1, observed2);\n+            fail(\"Expecting IllegalArgumentException - negative count\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        long[] observed3 = {10, 0, 12, 10, 15};\n+        long[] observed4 = {15, 0, 10, 15, 5};\n+        try {\n+            testStatistic.chiSquareTestDataSetsComparison(\n+                    observed3, observed4);\n+            fail(\"Expecting IllegalArgumentException - double 0's\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        long[] observed5 = {10, 10, 12, 10, 15};\n+        long[] observed6 = {0, 0, 0, 0, 0};\n+        try {\n+            testStatistic.chiSquareTestDataSetsComparison(\n+                    observed5, observed6);\n+            fail(\"Expecting IllegalArgumentException - vanishing counts\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Test cases for the OneWayAnovaImpl class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class OneWayAnovaTest extends TestCase {\n+\n+    protected OneWayAnova testStatistic = new OneWayAnovaImpl();\n+    \n+    private double[] emptyArray = {};\n+\n+    private double[] classA =\n+            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };\n+    private double[] classB =\n+            {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };\n+    private double[] classC =\n+            {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };\n+\n+    public OneWayAnovaTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(OneWayAnovaTest.class);\n+        suite.setName(\"TestStatistic Tests\");\n+        return suite;\n+    }\n+\n+    public void testAnovaFValue() throws Exception {\n+        // Target comparison values computed using R version 2.6.0 (Linux version)\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n+        threeClasses.add(classA);\n+        threeClasses.add(classB);\n+        threeClasses.add(classC);\n+\n+        assertEquals(\"ANOVA F-value\",  24.67361709460624,\n+                 testStatistic.anovaFValue(threeClasses), 1E-12);\n+\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n+        twoClasses.add(classA);\n+        twoClasses.add(classB);\n+        \n+        assertEquals(\"ANOVA F-value\",  0.0150579150579,\n+                 testStatistic.anovaFValue(twoClasses), 1E-12);\n+\n+        List<double[]> emptyContents = new ArrayList<double[]>();\n+        emptyContents.add(emptyArray);\n+        emptyContents.add(classC);\n+        try {\n+            testStatistic.anovaFValue(emptyContents);\n+            fail(\"empty array for key classX, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+\n+        List<double[]> tooFew = new ArrayList<double[]>();\n+        tooFew.add(classA);\n+        try {\n+            testStatistic.anovaFValue(tooFew);\n+            fail(\"less than two classes, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+    }\n+    \n+\n+    public void testAnovaPValue() throws Exception {\n+        // Target comparison values computed using R version 2.6.0 (Linux version)\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n+        threeClasses.add(classA);\n+        threeClasses.add(classB);\n+        threeClasses.add(classC);\n+\n+        assertEquals(\"ANOVA P-value\", 6.959446E-06,\n+                 testStatistic.anovaPValue(threeClasses), 1E-12);\n+\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n+        twoClasses.add(classA);\n+        twoClasses.add(classB);\n+        \n+        assertEquals(\"ANOVA P-value\",  0.904212960464,\n+                 testStatistic.anovaPValue(twoClasses), 1E-12);\n+\n+    }\n+\n+    public void testAnovaTest() throws Exception {\n+        // Target comparison values computed using R version 2.3.1 (Linux version)\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n+        threeClasses.add(classA);\n+        threeClasses.add(classB);\n+        threeClasses.add(classC);\n+\n+        assertTrue(\"ANOVA Test P<0.01\", testStatistic.anovaTest(threeClasses, 0.01));\n+\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n+        twoClasses.add(classA);\n+        twoClasses.add(classB);\n+        \n+        assertFalse(\"ANOVA Test P>0.01\", testStatistic.anovaTest(twoClasses, 0.01));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the TTestTestFactory.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class TTestFactoryTest extends TTestTest {\n+\n+    public TTestFactoryTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+    \tsuper.setUp();\n+        testStatistic = TestUtils.getTTest();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(TTestFactoryTest.class);\n+        suite.setName(\"TTestFactory Tests\");\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+/**\n+ * Test cases for the TTestImpl class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class TTestTest extends TestCase {\n+\n+    protected TTest testStatistic = new TTestImpl();\n+    \n+    private double[] tooShortObs = { 1.0 };\n+    private double[] emptyObs = {};\n+    private SummaryStatistics emptyStats = new SummaryStatistics();  \n+   SummaryStatistics tooShortStats = null;  \n+\n+    public TTestTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        tooShortStats = new SummaryStatistics();\n+        tooShortStats.addValue(0d);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(TTestTest.class);\n+        suite.setName(\"TestStatistic Tests\");\n+        return suite;\n+    }\n+\n+    public void testOneSampleT() throws Exception {\n+        double[] observed =\n+            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };\n+        double mu = 100.0;\n+        SummaryStatistics sampleStats = null;\n+        sampleStats = new SummaryStatistics();\n+        for (int i = 0; i < observed.length; i++) {\n+            sampleStats.addValue(observed[i]);\n+        }\n+\n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"t statistic\",  -2.81976445346,\n+                testStatistic.t(mu, observed), 10E-10);\n+        assertEquals(\"t statistic\",  -2.81976445346,\n+                testStatistic.t(mu, sampleStats), 10E-10);\n+        assertEquals(\"p value\", 0.0136390585873,\n+                testStatistic.tTest(mu, observed), 10E-10);\n+        assertEquals(\"p value\", 0.0136390585873,\n+                testStatistic.tTest(mu, sampleStats), 10E-10);\n+\n+        try {\n+            testStatistic.t(mu, (double[]) null);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            testStatistic.t(mu, (SummaryStatistics) null);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            testStatistic.t(mu, emptyObs);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+ \n+        try {\n+            testStatistic.t(mu, emptyStats);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            testStatistic.t(mu, tooShortObs);\n+            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.tTest(mu, tooShortObs);\n+            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+           // expected\n+        }  \n+\n+        try {\n+            testStatistic.t(mu, tooShortStats);\n+            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.tTest(mu, tooShortStats);\n+            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+    }\n+    \n+    public void testOneSampleTTest() throws Exception {\n+        double[] oneSidedP =\n+            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };\n+        SummaryStatistics oneSidedPStats = new SummaryStatistics();    \n+        for (int i = 0; i < oneSidedP.length; i++) {\n+            oneSidedPStats.addValue(oneSidedP[i]);\n+        }\n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"one sample t stat\", 3.86485535541, \n+                testStatistic.t(0d, oneSidedP), 10E-10);\n+        assertEquals(\"one sample t stat\", 3.86485535541, \n+                testStatistic.t(0d, oneSidedPStats),1E-10);\n+        assertEquals(\"one sample p value\", 0.000521637019637,\n+                testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);\n+        assertEquals(\"one sample p value\", 0.000521637019637,\n+                testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);\n+        assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedP, 0.01));\n+        assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedPStats, 0.01));\n+        assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedP, 0.0001));\n+        assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));\n+         \n+        try {\n+            testStatistic.tTest(0d, oneSidedP, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            testStatistic.tTest(0d, oneSidedPStats, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+    }\n+    \n+    public void testTwoSampleTHeterscedastic() throws Exception {\n+        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n+        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n+        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        for (int i = 0; i < sample1.length; i++) {\n+            sampleStats1.addValue(sample1[i]);\n+        }\n+        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        for (int i = 0; i < sample2.length; i++) {\n+            sampleStats2.addValue(sample2[i]);\n+        }\n+         \n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+                testStatistic.t(sample1, sample2), 1E-10);\n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+                testStatistic.t(sampleStats1, sampleStats2), 1E-10);\n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n+                testStatistic.tTest(sample1, sample2), 1E-10);\n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n+                testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);     \n+        assertTrue(\"two sample heteroscedastic t-test reject\", \n+                testStatistic.tTest(sample1, sample2, 0.2));\n+        assertTrue(\"two sample heteroscedastic t-test reject\", \n+                testStatistic.tTest(sampleStats1, sampleStats2, 0.2));\n+        assertTrue(\"two sample heteroscedastic t-test accept\", \n+                !testStatistic.tTest(sample1, sample2, 0.1));\n+        assertTrue(\"two sample heteroscedastic t-test accept\", \n+                !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));\n+     \n+        try {\n+            testStatistic.tTest(sample1, sample2, .95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        try {\n+            testStatistic.tTest(sampleStats1, sampleStats2, .95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected \n+        }  \n+        \n+        try {\n+            testStatistic.tTest(sample1, tooShortObs, .01);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            testStatistic.tTest(sampleStats1, tooShortStats, .01);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            testStatistic.tTest(sample1, tooShortObs);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+           // expected\n+        }  \n+        \n+        try {\n+            testStatistic.tTest(sampleStats1, tooShortStats);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            testStatistic.t(sample1, tooShortObs);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try {\n+            testStatistic.t(sampleStats1, tooShortStats);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+           // expected\n+        }\n+    }\n+    public void testTwoSampleTHomoscedastic() throws Exception {\n+        double[] sample1 ={2, 4, 6, 8, 10, 97};\n+        double[] sample2 = {4, 6, 8, 10, 16};\n+        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        for (int i = 0; i < sample1.length; i++) {\n+            sampleStats1.addValue(sample1[i]);\n+        }\n+        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        for (int i = 0; i < sample2.length; i++) {\n+            sampleStats2.addValue(sample2[i]);\n+        }\n+        \n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086, \n+              testStatistic.homoscedasticT(sample1, sample2), 10E-11);\n+        assertEquals(\"two sample homoscedastic p value\", 0.4833963785, \n+                testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     \n+        assertTrue(\"two sample homoscedastic t-test reject\", \n+                testStatistic.homoscedasticTTest(sample1, sample2, 0.49));\n+        assertTrue(\"two sample homoscedastic t-test accept\", \n+                !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));\n+    }\n+    \n+    public void testSmallSamples() throws Exception {\n+        double[] sample1 = {1d, 3d};\n+        double[] sample2 = {4d, 5d};        \n+        \n+        // Target values computed using R, version 1.8.1 (linux version)\n+        assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),\n+                1E-10);\n+        assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),\n+                1E-10);\n+    }\n+    \n+    public void testPaired() throws Exception {\n+        double[] sample1 = {1d, 3d, 5d, 7d};\n+        double[] sample2 = {0d, 6d, 11d, 2d};\n+        double[] sample3 = {5d, 7d, 8d, 10d};\n+\n+        // Target values computed using R, version 1.8.1 (linux version)\n+        assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);\n+        assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);\n+        assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);\n+        assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));\n+        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));    \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+/**\n+ * Test cases for the TestUtils class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class TestUtilsTest extends TestCase {\n+\n+    public TestUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(TestUtilsTest.class);\n+        suite.setName(\"TestUtils Tests\");\n+        return suite;\n+    }\n+\n+    public void testChiSquare() throws Exception {\n+        \n+        // Target values computed using R version 1.8.1 \n+        // Some assembly required ;-)  \n+        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n+        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n+        \n+        long[] observed = {10, 9, 11};\n+        double[] expected = {10, 10, 10};\n+        assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n+        assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n+        \n+        long[] observed1 = { 500, 623, 72, 70, 31 };\n+        double[] expected1 = { 485, 541, 82, 61, 37 };\n+        assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n+        assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n+        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n+        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n+\n+        try {\n+            TestUtils.chiSquareTest(expected1, observed1, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        long[] tooShortObs = { 0 };\n+        double[] tooShortEx = { 1 };\n+        try {\n+            TestUtils.chiSquare(tooShortEx, tooShortObs);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        // unmatched arrays\n+        long[] unMatchedObs = { 0, 1, 2, 3 };\n+        double[] unMatchedEx = { 1, 1, 2 };\n+        try {\n+            TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n+            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        // 0 expected count\n+        expected[0] = 0;\n+        try {\n+            TestUtils.chiSquareTest(expected, observed, .01);\n+            fail(\"bad expected count, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        // negative observed count\n+        expected[0] = 1;\n+        observed[0] = -1;\n+        try {\n+            TestUtils.chiSquareTest(expected, observed, .01);\n+            fail(\"bad expected count, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+    }\n+\n+    public void testChiSquareIndependence() throws Exception {\n+        \n+        // Target values computed using R version 1.8.1 \n+        \n+        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n+        assertEquals( \"chi-square test statistic\", 22.709027688, TestUtils.chiSquare(counts), 1E-9);\n+        assertEquals(\"chi-square p-value\", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);\n+        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(counts, 0.0002));\n+        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts, 0.0001));    \n+        \n+        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n+        assertEquals( \"chi-square test statistic\", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);\n+        assertEquals(\"chi-square p-value\",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);\n+        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts2, 0.1)); \n+        \n+        // ragged input array\n+        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n+        try {\n+            TestUtils.chiSquare(counts3);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        // insufficient data\n+        long[][] counts4 = {{40, 22, 43}};\n+        try {\n+            TestUtils.chiSquare(counts4);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        long[][] counts5 = {{40}, {40}, {30}, {10}};\n+        try {\n+            TestUtils.chiSquare(counts5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        // negative counts\n+        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n+        try {\n+            TestUtils.chiSquare(counts6);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        // bad alpha\n+        try {\n+            TestUtils.chiSquareTest(counts, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+    }\n+    \n+    public void testChiSquareLargeTestStatistic() throws Exception {\n+        double[] exp = new double[] {\n+                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n+                232921.0, 437665.75\n+        };\n+\n+        long[] obs = new long[] {\n+                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n+        };\n+        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n+            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n+        double cst = csti.chiSquareTest(exp, obs); \n+        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n+        assertEquals( \"chi-square test statistic\", \n+                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n+    }\n+    \n+    /** Contingency table containing zeros - PR # 32531 */\n+    public void testChiSquareZeroCount() throws Exception {\n+        // Target values computed using R version 1.8.1 \n+        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n+        assertEquals( \"chi-square test statistic\", 9.67444662263,\n+                TestUtils.chiSquare(counts), 1E-9);\n+        assertEquals(\"chi-square p-value\", 0.0462835770603,\n+                TestUtils.chiSquareTest(counts), 1E-9);       \n+    }\n+    \n+    private double[] tooShortObs = { 1.0 };\n+    private double[] emptyObs = {};\n+    private SummaryStatistics emptyStats = new SummaryStatistics();  \n+\n+    public void testOneSampleT() throws Exception {\n+        double[] observed =\n+            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };\n+        double mu = 100.0;\n+        SummaryStatistics sampleStats = null;\n+        sampleStats = new SummaryStatistics();\n+        for (int i = 0; i < observed.length; i++) {\n+            sampleStats.addValue(observed[i]);\n+        }\n+\n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"t statistic\",  -2.81976445346,\n+                TestUtils.t(mu, observed), 10E-10);\n+        assertEquals(\"t statistic\",  -2.81976445346,\n+                TestUtils.t(mu, sampleStats), 10E-10);\n+        assertEquals(\"p value\", 0.0136390585873,\n+                TestUtils.tTest(mu, observed), 10E-10);\n+        assertEquals(\"p value\", 0.0136390585873,\n+                TestUtils.tTest(mu, sampleStats), 10E-10);\n+\n+        try {\n+            TestUtils.t(mu, (double[]) null);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            TestUtils.t(mu, (SummaryStatistics) null);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            TestUtils.t(mu, emptyObs);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try {\n+            TestUtils.t(mu, emptyStats);\n+            fail(\"arguments too short, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            TestUtils.t(mu, tooShortObs);\n+            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            TestUtils.tTest(mu, tooShortObs);\n+            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+\n+        try {\n+            TestUtils.t(mu, (SummaryStatistics) null);\n+            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            TestUtils.tTest(mu, (SummaryStatistics) null);\n+            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+    }\n+    \n+    public void testOneSampleTTest() throws Exception {\n+        double[] oneSidedP =\n+            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };\n+        SummaryStatistics oneSidedPStats = new SummaryStatistics();    \n+        for (int i = 0; i < oneSidedP.length; i++) {\n+            oneSidedPStats.addValue(oneSidedP[i]);\n+        }\n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"one sample t stat\", 3.86485535541, \n+                TestUtils.t(0d, oneSidedP), 10E-10);\n+        assertEquals(\"one sample t stat\", 3.86485535541, \n+                TestUtils.t(0d, oneSidedPStats),1E-10);\n+        assertEquals(\"one sample p value\", 0.000521637019637,\n+                TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);\n+        assertEquals(\"one sample p value\", 0.000521637019637,\n+                TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);\n+        assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedP, 0.01));\n+        assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedPStats, 0.01));\n+        assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedP, 0.0001));\n+        assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));\n+        \n+        try {\n+            TestUtils.tTest(0d, oneSidedP, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            TestUtils.tTest(0d, oneSidedPStats, 95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+    }\n+    \n+    public void testTwoSampleTHeterscedastic() throws Exception {\n+        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n+        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n+        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        for (int i = 0; i < sample1.length; i++) {\n+            sampleStats1.addValue(sample1[i]);\n+        }\n+        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        for (int i = 0; i < sample2.length; i++) {\n+            sampleStats2.addValue(sample2[i]);\n+        }\n+        \n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+                TestUtils.t(sample1, sample2), 1E-10);\n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+                TestUtils.t(sampleStats1, sampleStats2), 1E-10);\n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n+                TestUtils.tTest(sample1, sample2), 1E-10);\n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n+                TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);     \n+        assertTrue(\"two sample heteroscedastic t-test reject\", \n+                TestUtils.tTest(sample1, sample2, 0.2));\n+        assertTrue(\"two sample heteroscedastic t-test reject\", \n+                TestUtils.tTest(sampleStats1, sampleStats2, 0.2));\n+        assertTrue(\"two sample heteroscedastic t-test accept\", \n+                !TestUtils.tTest(sample1, sample2, 0.1));\n+        assertTrue(\"two sample heteroscedastic t-test accept\", \n+                !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));\n+        \n+        try {\n+            TestUtils.tTest(sample1, sample2, .95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        } \n+        \n+        try {\n+            TestUtils.tTest(sampleStats1, sampleStats2, .95);\n+            fail(\"alpha out of range, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected \n+        }  \n+        \n+        try {\n+            TestUtils.tTest(sample1, tooShortObs, .01);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            TestUtils.tTest(sample1, tooShortObs);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            TestUtils.tTest(sampleStats1, (SummaryStatistics) null);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        \n+        try {\n+            TestUtils.t(sample1, tooShortObs);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try {\n+            TestUtils.t(sampleStats1, (SummaryStatistics) null);\n+            fail(\"insufficient data, IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    public void testTwoSampleTHomoscedastic() throws Exception {\n+        double[] sample1 ={2, 4, 6, 8, 10, 97};\n+        double[] sample2 = {4, 6, 8, 10, 16};\n+        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        for (int i = 0; i < sample1.length; i++) {\n+            sampleStats1.addValue(sample1[i]);\n+        }\n+        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        for (int i = 0; i < sample2.length; i++) {\n+            sampleStats2.addValue(sample2[i]);\n+        }\n+        \n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086, \n+                TestUtils.homoscedasticT(sample1, sample2), 10E-11);\n+        assertEquals(\"two sample homoscedastic p value\", 0.4833963785, \n+                TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     \n+        assertTrue(\"two sample homoscedastic t-test reject\", \n+                TestUtils.homoscedasticTTest(sample1, sample2, 0.49));\n+        assertTrue(\"two sample homoscedastic t-test accept\", \n+                !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));\n+    }\n+    \n+    public void testSmallSamples() throws Exception {\n+        double[] sample1 = {1d, 3d};\n+        double[] sample2 = {4d, 5d};        \n+        \n+        // Target values computed using R, version 1.8.1 (linux version)\n+        assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),\n+                1E-10);\n+        assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),\n+                1E-10);\n+    }\n+    \n+    public void testPaired() throws Exception {\n+        double[] sample1 = {1d, 3d, 5d, 7d};\n+        double[] sample2 = {0d, 6d, 11d, 2d};\n+        double[] sample3 = {5d, 7d, 8d, 10d};\n+\n+        // Target values computed using R, version 1.8.1 (linux version)\n+        assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);\n+        assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);\n+        assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);\n+        assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));\n+        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));    \n+    }\n+    \n+    private double[] classA =\n+      {93.0, 103.0, 95.0, 101.0};\n+    private double[] classB =\n+      {99.0, 92.0, 102.0, 100.0, 102.0};\n+    private double[] classC =\n+      {110.0, 115.0, 111.0, 117.0, 128.0};\n+    \n+    private List<double[]> classes = new ArrayList<double[]>();\n+    private OneWayAnova oneWayAnova = new OneWayAnovaImpl();\n+    \n+    public void testOneWayAnovaUtils() throws Exception {\n+        classes.add(classA);\n+        classes.add(classB);\n+        classes.add(classC);\n+        assertEquals(oneWayAnova.anovaFValue(classes), \n+                TestUtils.oneWayAnovaFValue(classes), 10E-12);\n+        assertEquals(oneWayAnova.anovaPValue(classes), \n+                TestUtils.oneWayAnovaPValue(classes), 10E-12);\n+        assertEquals(oneWayAnova.anovaTest(classes, 0.01), \n+                TestUtils.oneWayAnovaTest(classes, 0.01));   \n+    } \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.ranking;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomGenerator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for NaturalRanking class\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NaturalRankingTest extends TestCase {\n+\n+    private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50,\n+            Double.NaN, Double.NEGATIVE_INFINITY, 17 };\n+    private final double[] tiesFirst = { 0, 0, 2, 1, 4 };\n+    private final double[] tiesLast = { 4, 4, 1, 0 };\n+    private final double[] multipleNaNs = { 0, 1, Double.NaN, Double.NaN };\n+    private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 };\n+    private final double[] allSame = { 0, 0, 0, 0 };\n+\n+    public NaturalRankingTest(String arg0) {\n+        super(arg0);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void testDefault() { // Ties averaged, NaNs maximal\n+        NaturalRanking ranking = new NaturalRanking();\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = { 5, 3, 6, 7, 3, 8, 9, 1, 3 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 3.5, 3.5, 2, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] { 1, 2, 3.5, 3.5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+\n+    public void testNaNsMaximalTiesMinimum() {\n+        NaturalRanking ranking = new NaturalRanking(TiesStrategy.MINIMUM);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = { 5, 2, 6, 7, 2, 8, 9, 1, 2 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 1, 1, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 3, 3, 2, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] { 1, 2, 3, 3 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] { 3, 2, 4, 4, 6, 6, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 1, 1, 1, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+\n+    public void testNaNsRemovedTiesSequential() {\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED,\n+                TiesStrategy.SEQUENTIAL);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = { 5, 2, 6, 7, 3, 8, 1, 4 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 1, 2, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 3, 4, 2, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] { 1, 2 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] { 3, 2, 4, 5, 6, 7, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 1, 2, 3, 4 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+\n+    public void testNaNsMinimalTiesMaximum() {\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,\n+                TiesStrategy.MAXIMUM);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = { 6, 5, 7, 8, 5, 9, 2, 2, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 2, 2, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 4, 4, 2, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] { 3, 4, 2, 2 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] { 3, 2, 5, 5, 7, 7, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 4, 4, 4, 4 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+\n+    public void testNaNsMinimalTiesAverage() {\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = { 6, 4, 7, 8, 4, 9, 1.5, 1.5, 4 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 3.5, 3.5, 2, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] { 3, 4, 1.5, 1.5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+\n+    public void testNaNsFixedTiesRandom() {\n+        RandomGenerator randomGenerator = new JDKRandomGenerator();\n+        randomGenerator.setSeed(1000);\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,\n+                randomGenerator);\n+        double[] ranks = ranking.rank(exampleData);\n+        double[] correctRanks = { 5, 4, 6, 7, 3, 8, Double.NaN, 1, 4 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 1, 1, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 3, 4, 2, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleNaNs);\n+        correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(multipleTies);\n+        correctRanks = new double[] { 3, 2, 5, 5, 7, 6, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 1, 3, 4, 4 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+\n+    public void testNaNsAndInfs() {\n+        double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN,\n+                Double.NEGATIVE_INFINITY };\n+        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL);\n+        double[] ranks = ranking.rank(data);\n+        double[] correctRanks = new double[] { 2, 3.5, 3.5, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranking = new NaturalRanking(NaNStrategy.MINIMAL);\n+        ranks = ranking.rank(data);\n+        correctRanks = new double[] { 3, 4, 1.5, 1.5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {\n+\n+    private double[] y;\n+    private double[][] x;\n+    private double[][] omega;\n+\n+    @Before\n+    @Override\n+    public void setUp(){\n+        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};\n+        x = new double[6][];\n+        x[0] = new double[]{1.0, 0, 0, 0, 0, 0};\n+        x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};\n+        x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};\n+        x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};\n+        x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};\n+        x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};\n+        omega = new double[6][];\n+        omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};\n+        omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};\n+        omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};\n+        omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};\n+        omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};\n+        omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};\n+        super.setUp();\n+    }\n+   \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddXSampleData() {\n+        createRegression().newSampleData(new double[]{}, null, null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddNullYSampleData() {\n+        createRegression().newSampleData(null, new double[][]{}, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddSampleDataWithSizeMismatch() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[1][];\n+        x[0] = new double[]{1.0, 0};\n+        createRegression().newSampleData(y, x, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddNullCovarianceData() {\n+        createRegression().newSampleData(new double[]{}, new double[][]{}, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void notEnoughData() {\n+        double[]   reducedY = new double[y.length - 1];\n+        double[][] reducedX = new double[x.length - 1][];\n+        double[][] reducedO = new double[omega.length - 1][];\n+        System.arraycopy(y,     0, reducedY, 0, reducedY.length);\n+        System.arraycopy(x,     0, reducedX, 0, reducedX.length);\n+        System.arraycopy(omega, 0, reducedO, 0, reducedO.length);\n+        createRegression().newSampleData(reducedY, reducedX, reducedO);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddCovarianceDataWithSampleSizeMismatch() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[2][];\n+        x[0] = new double[]{1.0, 0};\n+        x[1] = new double[]{0, 1.0};\n+        double[][] omega = new double[1][];\n+        omega[0] = new double[]{1.0, 0};\n+        createRegression().newSampleData(y, x, omega);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddCovarianceDataThatIsNotSquare() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[2][];\n+        x[0] = new double[]{1.0, 0};\n+        x[1] = new double[]{0, 1.0};\n+        double[][] omega = new double[3][];\n+        omega[0] = new double[]{1.0, 0};\n+        omega[1] = new double[]{0, 1.0};\n+        omega[2] = new double[]{0, 2.0};\n+        createRegression().newSampleData(y, x, omega);\n+    }\n+\n+    @Override\n+    protected GLSMultipleLinearRegression createRegression() {\n+        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();\n+        regression.newSampleData(y, x, omega);\n+        return regression;\n+    }\n+\n+    @Override\n+    protected int getNumberOfRegressors() {\n+        return x[0].length;\n+    }\n+\n+    @Override\n+    protected int getSampleSize() {\n+        return y.length;\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+\n+public abstract class MultipleLinearRegressionAbstractTest {\n+\n+    protected MultipleLinearRegression regression;\n+\n+    @Before\n+    public void setUp(){\n+        regression = createRegression();\n+    }\n+\n+    protected abstract MultipleLinearRegression createRegression();\n+    \n+    protected abstract int getNumberOfRegressors();\n+    \n+    protected abstract int getSampleSize();\n+\n+    @Test\n+    public void canEstimateRegressionParameters(){\n+        double[] beta = regression.estimateRegressionParameters();        \n+        assertEquals(getNumberOfRegressors(), beta.length);\n+    }\n+\n+    @Test\n+    public void canEstimateResiduals(){\n+        double[] e = regression.estimateResiduals();\n+        assertEquals(getSampleSize(), e.length);\n+    }\n+    \n+    @Test\n+    public void canEstimateRegressionParametersVariance(){\n+        double[][] variance = regression.estimateRegressionParametersVariance();\n+        assertEquals(getNumberOfRegressors(), variance.length);\n+    }\n+\n+    @Test\n+    public void canEstimateRegressandVariance(){\n+        if (getSampleSize() > getNumberOfRegressors()) {\n+            double variance = regression.estimateRegressandVariance();\n+            assertTrue(variance > 0.0);\n+        }\n+    }   \n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {\n+\n+    private double[] y;\n+    private double[][] x;\n+    \n+    @Before\n+    @Override\n+    public void setUp(){\n+        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};\n+        x = new double[6][];\n+        x[0] = new double[]{1.0, 0, 0, 0, 0, 0};\n+        x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};\n+        x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};\n+        x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};\n+        x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};\n+        x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected OLSMultipleLinearRegression createRegression() {\n+        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();\n+        regression.newSampleData(y, x);\n+        return regression;\n+    }\n+\n+    @Override\n+    protected int getNumberOfRegressors() {\n+        return x[0].length;\n+    }\n+\n+    @Override\n+    protected int getSampleSize() {\n+        return y.length;\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddXSampleData() {\n+        createRegression().newSampleData(new double[]{}, null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddNullYSampleData() {\n+        createRegression().newSampleData(null, new double[][]{});\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddSampleDataWithSizeMismatch() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[1][];\n+        x[0] = new double[]{1.0, 0};\n+        createRegression().newSampleData(y, x);\n+    }\n+    \n+    @Test\n+    public void testPerfectFit() {\n+        double[] betaHat = regression.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat, \n+                               new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 },\n+                               1e-14);\n+        double[] residuals = regression.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},\n+                               1e-14);\n+        RealMatrix errors =\n+            new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false);\n+        final double[] s = { 1.0, -1.0 /  2.0, -1.0 /  3.0, -1.0 /  4.0, -1.0 /  5.0, -1.0 /  6.0 };\n+        RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length);\n+        referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            @Override\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                if (row == 0) {\n+                    return s[column];\n+                }\n+                double x = s[row] * s[column];\n+                return (row == column) ? 2 * x : x;\n+            }\n+        });\n+       assertEquals(0.0,\n+                     errors.subtract(referenceVariance).getNorm(),\n+                     5.0e-16 * referenceVariance.getNorm());\n+    }\n+    \n+    \n+    /**\n+     * Test Longley dataset against certified values provided by NIST.\n+     * Data Source: J. Longley (1967) \"An Appraisal of Least Squares\n+     * Programs for the Electronic Computer from the Point of View of the User\"\n+     * Journal of the American Statistical Association, vol. 62. September,\n+     * pp. 819-841.\n+     * \n+     * Certified values (and data) are from NIST:\n+     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat\n+     */\n+    @Test\n+    public void testLongly() {\n+        // Y values are first, then independent vars\n+        // Each row is one observation\n+        double[] design = new double[] {\n+            60323,83.0,234289,2356,1590,107608,1947,\n+            61122,88.5,259426,2325,1456,108632,1948,\n+            60171,88.2,258054,3682,1616,109773,1949,\n+            61187,89.5,284599,3351,1650,110929,1950,\n+            63221,96.2,328975,2099,3099,112075,1951,\n+            63639,98.1,346999,1932,3594,113270,1952,\n+            64989,99.0,365385,1870,3547,115094,1953,\n+            63761,100.0,363112,3578,3350,116219,1954,\n+            66019,101.2,397469,2904,3048,117388,1955,\n+            67857,104.6,419180,2822,2857,118734,1956,\n+            68169,108.4,442769,2936,2798,120445,1957,\n+            66513,110.8,444546,4681,2637,121950,1958,\n+            68655,112.6,482704,3813,2552,123366,1959,\n+            69564,114.2,502601,3931,2514,125368,1960,\n+            69331,115.7,518173,4806,2572,127852,1961,\n+            70551,116.9,554894,4007,2827,130081,1962\n+        };\n+        \n+        // Transform to Y and X required by interface\n+        int nobs = 16;\n+        int nvars = 6;\n+        \n+        // Estimate the model\n+        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n+        model.newSampleData(design, nobs, nvars);\n+        \n+        // Check expected beta values from NIST\n+        double[] betaHat = model.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat, \n+          new double[]{-3482258.63459582, 15.0618722713733,\n+                -0.358191792925910E-01,-2.02022980381683,\n+                -1.03322686717359,-0.511041056535807E-01,\n+                 1829.15146461355}, 2E-8); // \n+        \n+        // Check expected residuals from R\n+        double[] residuals = model.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{\n+                267.340029759711,-94.0139423988359,46.28716775752924,\n+                -410.114621930906,309.7145907602313,-249.3112153297231,\n+                -164.0489563956039,-13.18035686637081,14.30477260005235,\n+                 455.394094551857,-17.26892711483297,-39.0550425226967,\n+                -155.5499735953195,-85.6713080421283,341.9315139607727,\n+                -206.7578251937366},\n+                      1E-8);\n+        \n+        // Check standard errors from NIST\n+        double[] errors = model.estimateRegressionParametersStandardErrors();\n+        TestUtils.assertEquals(new double[] {890420.383607373,\n+                       84.9149257747669,\n+                       0.334910077722432E-01,\n+                       0.488399681651699,\n+                       0.214274163161675,\n+                       0.226073200069370,\n+                       455.478499142212}, errors, 1E-6); \n+    }\n+    \n+    /**\n+     * Test R Swiss fertility dataset against R.\n+     * Data Source: R datasets package\n+     */\n+    @Test\n+    public void testSwissFertility() {\n+        double[] design = new double[] {\n+            80.2,17.0,15,12,9.96,\n+            83.1,45.1,6,9,84.84,\n+            92.5,39.7,5,5,93.40,\n+            85.8,36.5,12,7,33.77,\n+            76.9,43.5,17,15,5.16,\n+            76.1,35.3,9,7,90.57,\n+            83.8,70.2,16,7,92.85,\n+            92.4,67.8,14,8,97.16,\n+            82.4,53.3,12,7,97.67,\n+            82.9,45.2,16,13,91.38,\n+            87.1,64.5,14,6,98.61,\n+            64.1,62.0,21,12,8.52,\n+            66.9,67.5,14,7,2.27,\n+            68.9,60.7,19,12,4.43,\n+            61.7,69.3,22,5,2.82,\n+            68.3,72.6,18,2,24.20,\n+            71.7,34.0,17,8,3.30,\n+            55.7,19.4,26,28,12.11,\n+            54.3,15.2,31,20,2.15,\n+            65.1,73.0,19,9,2.84,\n+            65.5,59.8,22,10,5.23,\n+            65.0,55.1,14,3,4.52,\n+            56.6,50.9,22,12,15.14,\n+            57.4,54.1,20,6,4.20,\n+            72.5,71.2,12,1,2.40,\n+            74.2,58.1,14,8,5.23,\n+            72.0,63.5,6,3,2.56,\n+            60.5,60.8,16,10,7.72,\n+            58.3,26.8,25,19,18.46,\n+            65.4,49.5,15,8,6.10,\n+            75.5,85.9,3,2,99.71,\n+            69.3,84.9,7,6,99.68,\n+            77.3,89.7,5,2,100.00,\n+            70.5,78.2,12,6,98.96,\n+            79.4,64.9,7,3,98.22,\n+            65.0,75.9,9,9,99.06,\n+            92.2,84.6,3,3,99.46,\n+            79.3,63.1,13,13,96.83,\n+            70.4,38.4,26,12,5.62,\n+            65.7,7.7,29,11,13.79,\n+            72.7,16.7,22,13,11.22,\n+            64.4,17.6,35,32,16.92,\n+            77.6,37.6,15,7,4.97,\n+            67.6,18.7,25,7,8.65,\n+            35.0,1.2,37,53,42.34,\n+            44.7,46.6,16,29,50.43,\n+            42.8,27.7,22,29,58.33\n+        };\n+\n+        // Transform to Y and X required by interface\n+        int nobs = 47;\n+        int nvars = 4;\n+\n+        // Estimate the model\n+        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n+        model.newSampleData(design, nobs, nvars);\n+\n+        // Check expected beta values from R\n+        double[] betaHat = model.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat, \n+                new double[]{91.05542390271397,\n+                -0.22064551045715,\n+                -0.26058239824328,\n+                -0.96161238456030,\n+                 0.12441843147162}, 1E-12);\n+\n+        // Check expected residuals from R\n+        double[] residuals = model.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{\n+                7.1044267859730512,1.6580347433531366,\n+                4.6944952770029644,8.4548022690166160,13.6547432343186212,\n+               -9.3586864458500774,7.5822446330520386,15.5568995563859289,\n+                0.8113090736598980,7.1186762732484308,7.4251378771228724,\n+                2.6761316873234109,0.8351584810309354,7.1769991119615177,\n+               -3.8746753206299553,-3.1337779476387251,-0.1412575244091504,\n+                1.1186809170469780,-6.3588097346816594,3.4039270429434074,\n+                2.3374058329820175,-7.9272368576900503,-7.8361010968497959,\n+               -11.2597369269357070,0.9445333697827101,6.6544245101380328,\n+               -0.9146136301118665,-4.3152449403848570,-4.3536932047009183,\n+               -3.8907885169304661,-6.3027643926302188,-7.8308982189289091,\n+               -3.1792280015332750,-6.7167298771158226,-4.8469946718041754,\n+               -10.6335664353633685,11.1031134362036958,6.0084032641811733,\n+                5.4326230830188482,-7.2375578629692230,2.1671550814448222,\n+                15.0147574652763112,4.8625103516321015,-7.1597256413907706,\n+                -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},\n+                1E-12); \n+        \n+        // Check standard errors from R\n+        double[] errors = model.estimateRegressionParametersStandardErrors();\n+        TestUtils.assertEquals(new double[] {6.94881329475087,\n+                0.07360008972340,\n+                0.27410957467466,\n+                0.19454551679325,\n+                0.03726654773803}, errors, 1E-10); \n+    }\n+    \n+    /**\n+     * Test hat matrix computation\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testHat() throws Exception {\n+        \n+        /*\n+         * This example is from \"The Hat Matrix in Regression and ANOVA\", \n+         * David C. Hoaglin and Roy E. Welsch, \n+         * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.\n+         * \n+         */\n+        double[] design = new double[] {\n+                11.14, .499, 11.1,\n+                12.74, .558, 8.9,\n+                13.13, .604, 8.8,\n+                11.51, .441, 8.9,\n+                12.38, .550, 8.8,\n+                12.60, .528, 9.9,\n+                11.13, .418, 10.7,\n+                11.7, .480, 10.5,\n+                11.02, .406, 10.5,\n+                11.41, .467, 10.7\n+        };\n+        \n+        int nobs = 10;\n+        int nvars = 2;\n+        \n+        // Estimate the model\n+        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n+        model.newSampleData(design, nobs, nvars);\n+        \n+        RealMatrix hat = model.calculateHat();\n+        \n+        // Reference data is upper half of symmetric hat matrix\n+        double[] referenceData = new double[] {\n+                .418, -.002,  .079, -.274, -.046,  .181,  .128,  .222,  .050,  .242,\n+                       .242,  .292,  .136,  .243,  .128, -.041,  .033, -.035,  .004,\n+                              .417, -.019,  .273,  .187, -.126,  .044, -.153,  .004,\n+                                     .604,  .197, -.038,  .168, -.022,  .275, -.028,\n+                                            .252,  .111, -.030,  .019, -.010, -.010,\n+                                                   .148,  .042,  .117,  .012,  .111,\n+                                                          .262,  .145,  .277,  .174,\n+                                                                 .154,  .120,  .168,\n+                                                                        .315,  .148,\n+                                                                               .187\n+        };\n+        \n+        // Check against reference data and verify symmetry\n+        int k = 0;\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = i; j < 10; j++) {\n+                assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);\n+                assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);\n+                k++;  \n+            }\n+        }\n+        \n+        /* \n+         * Verify that residuals computed using the hat matrix are close to \n+         * what we get from direct computation, i.e. r = (I - H) y\n+         */\n+        double[] residuals = model.estimateResiduals();\n+        RealMatrix I = MatrixUtils.createRealIdentityMatrix(10);\n+        double[] hatResiduals = I.subtract(hat).operate(model.Y).getData();\n+        TestUtils.assertEquals(residuals, hatResiduals, 10e-12);    \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+/**\n+ * Test cases for the TestStatistic class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class SimpleRegressionTest extends TestCase {\n+\n+    /* \n+     * NIST \"Norris\" refernce data set from \n+     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n+     * Strangely, order is {y,x}\n+     */\n+    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, \n+            {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 }, \n+            {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 }, \n+            {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 }, \n+            {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 }, \n+            {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 }, \n+            {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 }, \n+            {449.2, 448.9 }, {0.2, 0.5 }\n+    };\n+\n+    /* \n+     * Correlation example from \n+     * http://www.xycoon.com/correlation.htm\n+     */\n+    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, \n+            {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 }, \n+            {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 }, \n+            {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }\n+    };\n+\n+    /*\n+     * From Moore and Mcabe, \"Introduction to the Practice of Statistics\"\n+     * Example 10.3 \n+     */\n+    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },\n+            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }\n+    };\n+    \n+    /*\n+     * Points to remove in the remove tests\n+     */\n+    private double[][] removeSingle = {infData[1]};\n+    private double[][] removeMultiple = { infData[1], infData[2] };\n+    private double removeX = infData[0][0];\n+    private double removeY = infData[0][1];\n+    \n+            \n+    /*\n+     * Data with bad linear fit\n+     */\n+    private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },\n+            {5, -1 }, {6, 12 }\n+    };\n+\n+    public SimpleRegressionTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SimpleRegressionTest.class);\n+        suite.setName(\"BivariateRegression Tests\");\n+        return suite;\n+    }\n+\n+    public void testNorris() {\n+        SimpleRegression regression = new SimpleRegression();\n+        for (int i = 0; i < data.length; i++) {\n+            regression.addData(data[i][1], data[i][0]);\n+        }\n+        // Tests against certified values from  \n+        // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n+        assertEquals(\"slope\", 1.00211681802045, regression.getSlope(), 10E-12);\n+        assertEquals(\"slope std err\", 0.429796848199937E-03,\n+                regression.getSlopeStdErr(),10E-12);\n+        assertEquals(\"number of observations\", 36, regression.getN());\n+        assertEquals( \"intercept\", -0.262323073774029,\n+            regression.getIntercept(),10E-12);\n+        assertEquals(\"std err intercept\", 0.232818234301152,\n+            regression.getInterceptStdErr(),10E-12);\n+        assertEquals(\"r-square\", 0.999993745883712,\n+            regression.getRSquare(), 10E-12);\n+        assertEquals(\"SSR\", 4255954.13232369,\n+            regression.getRegressionSumSquares(), 10E-9);\n+        assertEquals(\"MSE\", 0.782864662630069,\n+            regression.getMeanSquareError(), 10E-10);\n+        assertEquals(\"SSE\", 26.6173985294224,\n+            regression.getSumSquaredErrors(),10E-9);\n+        // ------------  End certified data tests\n+          \n+        assertEquals( \"predict(0)\",  -0.262323073774029,\n+            regression.predict(0), 10E-12);\n+        assertEquals(\"predict(1)\", 1.00211681802045 - 0.262323073774029,\n+            regression.predict(1), 10E-12);\n+    }\n+\n+    public void testCorr() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(corrData);\n+        assertEquals(\"number of observations\", 17, regression.getN());\n+        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        assertEquals(\"r\", -0.94663767742, regression.getR(), 1E-10);\n+    }\n+\n+    public void testNaNs() {\n+        SimpleRegression regression = new SimpleRegression();\n+        assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        assertTrue( \"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n+        assertTrue(\"SSE not NaN\",Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"SSTO not NaN\", Double.isNaN(regression.getTotalSumSquares()));\n+        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+\n+        regression.addData(1, 2);\n+        regression.addData(1, 3);\n+\n+        // No x variation, so these should still blow...\n+        assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        assertTrue(\"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n+        assertTrue(\"SSE not NaN\", Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+\n+        // but SSTO should be OK\n+        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+\n+        regression = new SimpleRegression();\n+\n+        regression.addData(1, 2);\n+        regression.addData(3, 3);\n+\n+        // All should be OK except MSE, s(b0), s(b1) which need one more df \n+        assertTrue(\"interceptNaN\", !Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope NaN\", !Double.isNaN(regression.getSlope()));\n+        assertTrue (\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"r NaN\", !Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square NaN\", !Double.isNaN(regression.getRSquare()));\n+        assertTrue(\"RSS NaN\", !Double.isNaN(regression.getRegressionSumSquares()));\n+        assertTrue(\"SSE NaN\", !Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+        assertTrue(\"predict NaN\", !Double.isNaN(regression.predict(0)));\n+\n+        regression.addData(1, 4);\n+\n+        // MSE, MSE, s(b0), s(b1) should all be OK now\n+        assertTrue(\"MSE NaN\", !Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"slope std err NaN\", !Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err NaN\", !Double.isNaN(regression.getInterceptStdErr()));\n+    }\n+\n+    public void testClear() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(corrData);\n+        assertEquals(\"number of observations\", 17, regression.getN());\n+        regression.clear();\n+        assertEquals(\"number of observations\", 0, regression.getN());\n+        regression.addData(corrData);\n+        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        regression.addData(data);\n+        assertEquals(\"number of observations\", 53, regression.getN());\n+    }\n+\n+    public void testInference() throws Exception {\n+        //----------  verified against R, version 1.8.1 -----\n+        // infData\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+        // infData2\n+        regression = new SimpleRegression();\n+        regression.addData(infData2);\n+        assertEquals(\"slope std err\", 1.07260253,\n+                regression.getSlopeStdErr(), 1E-8);\n+        assertEquals(\"std err intercept\",4.17718672,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 0.261829133982,\n+                regression.getSignificance(),1E-11);    \n+        assertEquals(\"slope conf interval half-width\", 2.97802204827, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+        //------------- End R-verified tests -------------------------------\n+        \n+        //FIXME: get a real example to test against with alpha = .01\n+        assertTrue(\"tighter means wider\",\n+                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));\n+     \n+        try {\n+            regression.getSlopeConfidenceInterval(1);\n+            fail(\"expecting IllegalArgumentException for alpha = 1\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }  \n+\n+    }\n+\n+    public void testPerfect() throws Exception {\n+        SimpleRegression regression = new SimpleRegression();\n+        int n = 100;\n+        for (int i = 0; i < n; i++) {\n+            regression.addData(((double) i) / (n - 1), i);\n+        }\n+        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+        assertTrue(regression.getSlope() > 0.0);\n+        assertTrue(regression.getSumSquaredErrors() >= 0.0);\n+    }\n+\n+    public void testPerfectNegative() throws Exception {\n+        SimpleRegression regression = new SimpleRegression();\n+        int n = 100;\n+        for (int i = 0; i < n; i++) {\n+            regression.addData(- ((double) i) / (n - 1), i);\n+        }\n+   \n+        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+        assertTrue(regression.getSlope() < 0.0);   \n+    }\n+\n+    public void testRandom() throws Exception {\n+        SimpleRegression regression = new SimpleRegression();\n+        Random random = new Random(1);\n+        int n = 100;\n+        for (int i = 0; i < n; i++) {\n+            regression.addData(((double) i) / (n - 1), random.nextDouble());\n+        }\n+\n+        assertTrue( 0.0 < regression.getSignificance()\n+                    && regression.getSignificance() < 1.0);       \n+    }\n+    \n+    \n+    // Jira MATH-85 = Bugzilla 39432\n+    public void testSSENonNegative() {\n+        double[] y = { 8915.102, 8919.302, 8923.502 };\n+        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };\n+        SimpleRegression reg = new SimpleRegression();\n+        for (int i = 0; i < x.length; i++) {\n+            reg.addData(x[i], y[i]);\n+        }\n+        assertTrue(reg.getSumSquaredErrors() >= 0.0);\n+    } \n+    \n+    // Test remove X,Y (single observation)\n+    public void testRemoveXY() throws Exception {\n+        // Create regression with inference data then remove to test\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        regression.removeData(removeX, removeY);\n+        regression.addData(removeX, removeY);\n+        // Use the inference assertions to make sure that everything worked\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+     }\n+    \n+    \n+    // Test remove single observation in array\n+    public void testRemoveSingle() throws Exception {\n+        // Create regression with inference data then remove to test\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        regression.removeData(removeSingle);\n+        regression.addData(removeSingle);\n+        // Use the inference assertions to make sure that everything worked\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+     }\n+    \n+    // Test remove multiple observations\n+    public void testRemoveMultiple() throws Exception {\n+        // Create regression with inference data then remove to test\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        regression.removeData(removeMultiple);\n+        regression.addData(removeMultiple);\n+        // Use the inference assertions to make sure that everything worked\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+     }\n+    \n+    // Remove observation when empty\n+    public void testRemoveObsFromEmpty() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.removeData(removeX, removeY);\n+        assertEquals(regression.getN(), 0);\n+    }\n+    \n+    // Remove single observation to empty\n+    public void testRemoveObsFromSingle() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(removeX, removeY);\n+        regression.removeData(removeX, removeY);\n+        assertEquals(regression.getN(), 0);\n+    }\n+    \n+    // Remove multiple observations to empty\n+    public void testRemoveMultipleToEmpty() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(removeMultiple);\n+        regression.removeData(removeMultiple);\n+        assertEquals(regression.getN(), 0);\n+    }\n+    \n+    // Remove multiple observations past empty (i.e. size of array > n)\n+    public void testRemoveMultiplePastEmpty() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(removeX, removeY);\n+        regression.removeData(removeMultiple);\n+        assertEquals(regression.getN(), 0);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for fast cosine transformer.\n+ * <p>\n+ * FCT algorithm is exact, the small tolerance number is used only\n+ * to account for round-off errors.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class FastCosineTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the ad hoc data.\n+     */\n+    public void testAdHocData() {\n+        FastCosineTransformer transformer = new FastCosineTransformer();\n+        double result[], tolerance = 1E-12;\n+\n+        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };\n+        double y[] = { 172.0, -105.096569476353, 27.3137084989848,\n+                      -12.9593152353742, 8.0, -5.78585076868676,\n+                       4.68629150101524, -4.15826451958632, 4.0 };\n+\n+        result = transformer.transform(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));\n+\n+        result = transformer.transform2(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform2(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastCosineTransformer transformer = new FastCosineTransformer();\n+        double min, max, result[], tolerance = 1E-12; int N = 9;\n+\n+        double expected[] = { 0.0, 3.26197262739567, 0.0,\n+                             -2.17958042710327, 0.0, -0.648846697642915,\n+                              0.0, -0.433545502649478, 0.0 };\n+        min = 0.0; max = 2.0 * Math.PI * N / (N-1);\n+        result = transformer.transform(f, min, max, N);\n+        for (int i = 0; i < N; i++) {\n+            assertEquals(expected[i], result[i], tolerance);\n+        }\n+\n+        min = -Math.PI; max = Math.PI * (N+1) / (N-1);\n+        result = transformer.transform(f, min, max, N);\n+        for (int i = 0; i < N; i++) {\n+            assertEquals(-expected[i], result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of parameters for the transformer.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastCosineTransformer transformer = new FastCosineTransformer();\n+\n+        try {\n+            // bad interval\n+            transformer.transform(f, 1, -1, 65);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 64);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for fast Fourier transformer.\n+ * <p>\n+ * FFT algorithm is exact, the small tolerance number is used only\n+ * to account for round-off errors.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class FastFourierTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the ad hoc data taken from Mathematica.\n+     */\n+    public void testAdHocData() {\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex result[]; double tolerance = 1E-12;\n+\n+        double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};\n+        Complex y[] = {\n+            new Complex(21.9, 0.0),\n+            new Complex(-2.09497474683058, 1.91507575950825),\n+            new Complex(-2.6, 2.7),\n+            new Complex(-1.10502525316942, -4.88492424049175),\n+            new Complex(0.1, 0.0),\n+            new Complex(-1.10502525316942, 4.88492424049175),\n+            new Complex(-2.6, -2.7),\n+            new Complex(-2.09497474683058, -1.91507575950825)};\n+\n+        result = transformer.transform(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i].getReal(), result[i].getReal(), tolerance);\n+            assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);\n+        }\n+\n+        result = transformer.inversetransform(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};\n+        FastFourierTransformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));\n+        Complex y2[] = y;\n+\n+        result = transformer.transform2(y2);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x2[i], result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        result = transformer.inversetransform2(x2);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);\n+            assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n+        }\n+    }\n+    \n+    public void test2DData() {\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        double tolerance = 1E-12;\n+        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n+                                                            new Complex(2, 0)},\n+                                             new Complex[] {new Complex(3, 1),\n+                                                            new Complex(4, 2)}};\n+        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,\n+                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,\n+                -1.5), new Complex(0, .5)}};\n+        Complex[][] output = (Complex[][])transformer.mdfft(input, true);\n+        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);\n+        \n+        assertEquals(input.length, output.length);\n+        assertEquals(input.length, output2.length);\n+        assertEquals(input[0].length, output[0].length);\n+        assertEquals(input[0].length, output2[0].length);\n+        assertEquals(input[1].length, output[1].length);\n+        assertEquals(input[1].length, output2[1].length);\n+        \n+        for (int i = 0; i < input.length; i++) {\n+            for (int j = 0; j < input[0].length; j++) {\n+                assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n+                             tolerance);\n+                assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n+                assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),\n+                             tolerance);\n+                assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex result[]; int N = 1 << 8;\n+        double min, max, tolerance = 1E-12;\n+\n+        min = 0.0; max = 2.0 * Math.PI;\n+        result = transformer.transform(f, min, max, N);\n+        assertEquals(0.0, result[1].getReal(), tolerance);\n+        assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n+        assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);\n+        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n+            assertEquals(0.0, result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        min = -Math.PI; max = Math.PI;\n+        result = transformer.inversetransform(f, min, max, N);\n+        assertEquals(0.0, result[1].getReal(), tolerance);\n+        assertEquals(-0.5, result[1].getImaginary(), tolerance);\n+        assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        assertEquals(0.5, result[N-1].getImaginary(), tolerance);\n+        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n+            assertEquals(0.0, result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of parameters for the transformer.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+\n+        try {\n+            // bad interval\n+            transformer.transform(f, 1, -1, 64);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 0);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 100);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit Test for HadamardTransformerTest\n+ * @see org.apache.commons.math.transform.FastHadamardTransformer\n+ */\n+public final class FastHadamardTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the a 8-point FHT (means n=8)\n+     */\n+    public void test8Points() {\n+        checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },\n+                       new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });\n+    }\n+\n+    /**\n+     * Test of transformer for the a 4-points FHT (means n=4)\n+     */\n+    public void test4Points() {\n+        checkAllTransforms(new int[] { 1, 2, 3, 4 },\n+                           new int[] { 10, -2, -4, 0 });\n+    }\n+\n+    /**\n+     * Test the inverse transform of an integer vector is not always an integer vector\n+     */\n+    public void testNoIntInverse() {\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+        double[] x = transformer.inversetransform(new double[] { 0, 1, 0, 1});\n+        assertEquals( 0.5, x[0], 0);\n+        assertEquals(-0.5, x[1], 0);\n+        assertEquals( 0.0, x[2], 0);\n+        assertEquals( 0.0, x[3], 0);\n+    }\n+\n+    /**\n+     * Test of transformer for wrong number of points\n+     */\n+    public void test3Points() {\n+        try {\n+            new FastHadamardTransformer().transform(new double[3]);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+\n+    private void checkAllTransforms(int[]x, int[] y) {\n+        checkDoubleTransform(x, y);\n+        checkInverseDoubleTransform(x, y);\n+        checkIntTransform(x, y);\n+    }\n+\n+    private void checkDoubleTransform(int[]x, int[] y) {\n+        // Initiate the transformer\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+\n+        // check double transform\n+        double[] dX = new double[x.length];\n+        for (int i = 0; i < dX.length; ++i) {\n+            dX[i] = x[i];\n+        }\n+        double dResult[] = transformer.transform(dX);\n+        for (int i = 0; i < dResult.length; i++) {\n+            // compare computed results to precomputed results\n+            assertEquals((double) y[i], dResult[i]);\n+        }\n+    }\n+\n+    private void checkIntTransform(int[]x, int[] y) {\n+        // Initiate the transformer\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+\n+        // check integer transform\n+        int iResult[] = transformer.transform(x);\n+        for (int i = 0; i < iResult.length; i++) {\n+            // compare computed results to precomputed results\n+            assertEquals(y[i], iResult[i]);\n+        }\n+\n+    }\n+    \n+    private void checkInverseDoubleTransform(int[]x, int[] y) {\n+        // Initiate the transformer\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+\n+        // check double transform\n+        double[] dY = new double[y.length];\n+        for (int i = 0; i < dY.length; ++i) {\n+            dY[i] = y[i];\n+        }\n+        double dResult[] = transformer.inversetransform(dY);\n+        for (int i = 0; i < dResult.length; i++) {\n+            // compare computed results to precomputed results\n+            assertEquals((double) x[i], dResult[i]);\n+        }\n+\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for fast sine transformer.\n+ * <p>\n+ * FST algorithm is exact, the small tolerance number is used only\n+ * to account for round-off errors.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class FastSineTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the ad hoc data.\n+     */\n+    public void testAdHocData() {\n+        FastSineTransformer transformer = new FastSineTransformer();\n+        double result[], tolerance = 1E-12;\n+\n+        double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };\n+        double y[] = { 0.0, 20.1093579685034, -9.65685424949238,\n+                       5.98642305066196, -4.0, 2.67271455167720,\n+                      -1.65685424949238, 0.795649469518633 };\n+\n+        result = transformer.transform(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));\n+\n+        result = transformer.transform2(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform2(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastSineTransformer transformer = new FastSineTransformer();\n+        double min, max, result[], tolerance = 1E-12; int N = 1 << 8;\n+\n+        min = 0.0; max = 2.0 * Math.PI;\n+        result = transformer.transform(f, min, max, N);\n+        assertEquals(N >> 1, result[2], tolerance);\n+        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n+            assertEquals(0.0, result[i], tolerance);\n+        }\n+\n+        min = -Math.PI; max = Math.PI;\n+        result = transformer.transform(f, min, max, N);\n+        assertEquals(-(N >> 1), result[2], tolerance);\n+        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n+            assertEquals(0.0, result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of parameters for the transformer.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastSineTransformer transformer = new FastSineTransformer();\n+\n+        try {\n+            // bad interval\n+            transformer.transform(f, 1, -1, 64);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 0);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 100);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/BigRealFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Test;\n+\n+public class BigRealFieldTest {\n+\n+    @Test\n+    public void testZero() {\n+        assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero());\n+    }\n+\n+    @Test\n+    public void testOne() {\n+        assertEquals(BigReal.ONE, BigRealField.getInstance().getOne());\n+    }\n+\n+    @Test\n+    public void testSerial() {\n+        // deserializing the singleton should give the singleton itself back\n+        BigRealField field = BigRealField.getInstance();\n+        assertTrue(field == TestUtils.serializeAndRecover(field));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/BigRealTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Test;\n+\n+public class BigRealTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        assertEquals(1.625, new BigReal(new BigDecimal(\"1.625\")).doubleValue(), 1.0e-15);\n+        assertEquals(-5.0, new BigReal(new BigInteger(\"-5\")).doubleValue(), 1.0e-15);\n+        assertEquals(-5.0, new BigReal(new BigInteger(\"-5\"), MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(0.125, new BigReal(new BigInteger(\"125\"), 3).doubleValue(), 1.0e-15);\n+        assertEquals(0.125, new BigReal(new BigInteger(\"125\"), 3, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15);\n+        assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15);\n+        assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(\"1.625\").doubleValue(), 1.0e-15);\n+        assertEquals(1.625, new BigReal(\"1.625\", MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testCompareTo() {\n+        BigReal first = new BigReal(1.0 / 2.0);\n+        BigReal second = new BigReal(1.0 / 3.0);\n+        BigReal third = new BigReal(1.0 / 2.0);\n+\n+        assertEquals(0, first.compareTo(first));\n+        assertEquals(0, first.compareTo(third));\n+        assertEquals(1, first.compareTo(second));\n+        assertEquals(-1, second.compareTo(first));\n+\n+    }\n+\n+    public void testAdd() {\n+        BigReal a = new BigReal(\"1.2345678\");\n+        BigReal b = new BigReal(\"8.7654321\");\n+        assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15);\n+    }\n+\n+    public void testSubtract() {\n+        BigReal a = new BigReal(\"1.2345678\");\n+        BigReal b = new BigReal(\"8.7654321\");\n+        assertEquals( -7.5308643, a.subtract(b).doubleValue(), 1.0e-15);\n+    }\n+\n+    public void testDivide() {\n+        BigReal a = new BigReal(\"1.0000000000\");\n+        BigReal b = new BigReal(\"0.0009765625\");\n+        assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15);\n+    }\n+\n+    public void testMultiply() {\n+        BigReal a = new BigReal(\"1024.0\");\n+        BigReal b = new BigReal(\"0.0009765625\");\n+        assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testDoubleValue() {\n+        assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testBigDecimalValue() {\n+        BigDecimal pi = new BigDecimal(\"3.1415926535897932384626433832795028841971693993751\");\n+        assertEquals(pi, new BigReal(pi).bigDecimalValue());\n+        assertEquals(new BigDecimal(0.5), new BigReal(1.0 / 2.0).bigDecimalValue());\n+    }\n+\n+    @Test\n+    public void testEqualsAndHashCode() {\n+        BigReal zero = new BigReal(0.0);\n+        BigReal nullReal = null;\n+        assertTrue(zero.equals(zero));\n+        assertFalse(zero.equals(nullReal));\n+        assertFalse(zero.equals(Double.valueOf(0)));\n+        BigReal zero2 = new BigReal(0.0);\n+        assertTrue(zero.equals(zero2));\n+        assertEquals(zero.hashCode(), zero2.hashCode());\n+        BigReal one = new BigReal(1.0);\n+        assertFalse((one.equals(zero) || zero.equals(one)));\n+        assertTrue(one.equals(BigReal.ONE));\n+    }\n+\n+    public void testSerial() {\n+        BigReal[] Reals = {\n+            new BigReal(3.0), BigReal.ONE, BigReal.ZERO,\n+            new BigReal(17), new BigReal(Math.PI),\n+            new BigReal(-2.5)\n+        };\n+        for (BigReal Real : Reals) {\n+            assertEquals(Real, TestUtils.serializeAndRecover(Real));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/ContinuedFractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class ContinuedFractionTest extends TestCase {\n+    /**\n+     * Constructor for ContinuedFractionTest.\n+     * @param name\n+     */\n+    public ContinuedFractionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testGoldenRatio(){\n+        ContinuedFraction cf = new ContinuedFraction() {\n+            \n+            @Override\n+            public double getA(int n, double x) {\n+                return 1.0;\n+            }\n+\n+            @Override\n+            public double getB(int n, double x) {\n+                return 1.0;\n+            }\n+        };\n+        \n+        try {\n+            double gr = cf.evaluate(0.0, 10e-9);\n+            assertEquals(1.61803399, gr, 10e-9);\n+        } catch (MathException e) {\n+            fail(e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/DefaultTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.math.BigDecimal;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class DefaultTransformerTest extends TestCase {\n+    /**\n+     * \n+     */\n+    public void testTransformDouble() throws Exception {\n+        double expected = 1.0;\n+        Double input = Double.valueOf(expected);\n+        DefaultTransformer t = new DefaultTransformer();\n+        assertEquals(expected, t.transform(input), 1.0e-4);\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testTransformNull(){\n+        DefaultTransformer t = new DefaultTransformer();\n+        try {\n+            t.transform(null);\n+            fail(\"Expection MathException\");\n+        } catch (MathException e) {\n+            // expected\n+        }\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testTransformInteger() throws Exception {\n+        double expected = 1.0;\n+        Integer input = Integer.valueOf(1);\n+        DefaultTransformer t = new DefaultTransformer();\n+        assertEquals(expected, t.transform(input), 1.0e-4);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testTransformBigDecimal() throws Exception {\n+        double expected = 1.0;\n+        BigDecimal input = new BigDecimal(\"1.0\");\n+        DefaultTransformer t = new DefaultTransformer();\n+        assertEquals(expected, t.transform(input), 1.0e-4);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testTransformString() throws Exception {\n+        double expected = 1.0;\n+        String input = \"1.0\";\n+        DefaultTransformer t = new DefaultTransformer();\n+        assertEquals(expected, t.transform(input), 1.0e-4);\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testTransformObject(){\n+        Boolean input = Boolean.TRUE;\n+        DefaultTransformer t = new DefaultTransformer();\n+        try {\n+            t.transform(input);\n+            fail(\"Expecting MathException\");\n+        } catch (MathException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSerial() {\n+        assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.stat.StatUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class DoubleArrayAbstractTest extends TestCase {\n+\n+    protected DoubleArray da = null;\n+\n+    // Array used to test rolling\n+    protected DoubleArray ra = null;\n+\n+    public DoubleArrayAbstractTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testAdd1000() {\n+\n+        for (int i = 0; i < 1000; i++) {\n+            da.addElement(i);\n+        }\n+\n+        assertEquals(\n+            \"Number of elements should be equal to 1000 after adding 1000 values\",\n+            1000,\n+            da.getNumElements());\n+\n+        assertEquals(\n+            \"The element at the 56th index should be 56\",\n+            56.0,\n+            da.getElement(56),\n+            Double.MIN_VALUE);\n+\n+    }\n+\n+    public void testGetValues() {\n+        double[] controlArray = { 2.0, 4.0, 6.0 };\n+\n+        da.addElement(2.0);\n+        da.addElement(4.0);\n+        da.addElement(6.0);\n+        double[] testArray = da.getElements();\n+\n+        for (int i = 0; i < da.getNumElements(); i++) {\n+            assertEquals(\n+                \"The testArray values should equal the controlArray values, index i: \"\n+                    + i\n+                    + \" does not match\",\n+                testArray[i],\n+                controlArray[i],\n+                Double.MIN_VALUE);\n+        }\n+\n+    }\n+\n+    public void testAddElementRolling() {\n+        ra.addElement(0.5);\n+        ra.addElement(1.0);\n+        ra.addElement(1.0);\n+        ra.addElement(1.0);\n+        ra.addElement(1.0);\n+        ra.addElement(1.0);\n+        ra.addElementRolling(2.0);\n+\n+        assertEquals(\n+            \"There should be 6 elements in the eda\",\n+            6,\n+            ra.getNumElements());\n+        assertEquals(\n+            \"The max element should be 2.0\",\n+            2.0,\n+            StatUtils.max(ra.getElements()),\n+            Double.MIN_VALUE);\n+        assertEquals(\n+            \"The min element should be 1.0\",\n+            1.0,\n+            StatUtils.min(ra.getElements()),\n+            Double.MIN_VALUE);\n+\n+        for (int i = 0; i < 1024; i++) {\n+            ra.addElementRolling(i);\n+        }\n+\n+        assertEquals(\n+            \"We just inserted 1024 rolling elements, num elements should still be 6\",\n+            6,\n+            ra.getNumElements());\n+    }\n+\n+    public void testMinMax() {\n+        da.addElement(2.0);\n+        da.addElement(22.0);\n+        da.addElement(-2.0);\n+        da.addElement(21.0);\n+        da.addElement(22.0);\n+        da.addElement(42.0);\n+        da.addElement(62.0);\n+        da.addElement(22.0);\n+        da.addElement(122.0);\n+        da.addElement(1212.0);\n+\n+        assertEquals(\"Min should be -2.0\", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);\n+        assertEquals(\n+            \"Max should be 1212.0\",\n+            1212.0,\n+            StatUtils.max(da.getElements()),\n+            Double.MIN_VALUE);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the MathUtils class.\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ *          2007) $\n+ */\n+public final class MathUtilsTest extends TestCase {\n+\n+    public MathUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MathUtilsTest.class);\n+        suite.setName(\"MathUtils Tests\");\n+        return suite;\n+    }\n+\n+    /** cached binomial coefficients */\n+    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n+\n+    /**\n+     * Exact (caching) recursive implementation to test against\n+     */\n+    private long binomialCoefficient(int n, int k) throws ArithmeticException {\n+        if (binomialCache.size() > n) {\n+            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));\n+            if (cachedResult != null) {\n+                return cachedResult.longValue();\n+            }\n+        }\n+        long result = -1;\n+        if ((n == k) || (k == 0)) {\n+            result = 1;\n+        } else if ((k == 1) || (k == n - 1)) {\n+            result = n;\n+        } else {\n+            // Reduce stack depth for larger values of n\n+            if (k < n - 100) {\n+                binomialCoefficient(n - 100, k);\n+            }\n+            if (k > 100) {\n+                binomialCoefficient(n - 100, k - 100);\n+            }\n+            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),\n+                binomialCoefficient(n - 1, k));\n+        }\n+        if (result == -1) {\n+            throw new ArithmeticException(\n+                \"error computing binomial coefficient\");\n+        }\n+        for (int i = binomialCache.size(); i < n + 1; i++) {\n+            binomialCache.add(new HashMap<Integer, Long>());\n+        }\n+        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));\n+        return result;\n+    }\n+\n+    /**\n+     * Exact direct multiplication implementation to test against\n+     */\n+    private long factorial(int n) {\n+        long result = 1;\n+        for (int i = 2; i <= n; i++) {\n+            result *= i;\n+        }\n+        return result;\n+    }\n+\n+    /** Verify that b(0,0) = 1 */\n+    public void test0Choose0() {\n+        assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n+        assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);\n+        assertEquals(MathUtils.binomialCoefficient(0, 0), 1);\n+    }\n+\n+    public void testAddAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        assertEquals(big, MathUtils.addAndCheck(big, 0));\n+        try {\n+            MathUtils.addAndCheck(big, 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+        try {\n+            MathUtils.addAndCheck(bigNeg, -1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+    }\n+\n+    public void testAddAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        assertEquals(max, MathUtils.addAndCheck(max, 0L));\n+        assertEquals(min, MathUtils.addAndCheck(min, 0L));\n+        assertEquals(max, MathUtils.addAndCheck(0L, max));\n+        assertEquals(min, MathUtils.addAndCheck(0L, min));\n+        assertEquals(1, MathUtils.addAndCheck(-1L, 2L));\n+        assertEquals(1, MathUtils.addAndCheck(2L, -1L));\n+        assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));\n+        assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));\n+        testAddAndCheckLongFailure(max, 1L);\n+        testAddAndCheckLongFailure(min, -1L);\n+        testAddAndCheckLongFailure(1L, max);\n+        testAddAndCheckLongFailure(-1L, min);\n+    }\n+\n+    private void testAddAndCheckLongFailure(long a, long b) {\n+        try {\n+            MathUtils.addAndCheck(a, b);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testBinomialCoefficient() {\n+        long[] bcoef5 = {\n+            1,\n+            5,\n+            10,\n+            10,\n+            5,\n+            1 };\n+        long[] bcoef6 = {\n+            1,\n+            6,\n+            15,\n+            20,\n+            15,\n+            6,\n+            1 };\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(\"5 choose \" + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));\n+        }\n+        for (int i = 0; i < 7; i++) {\n+            assertEquals(\"6 choose \" + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));\n+        }\n+\n+        for (int n = 1; n < 10; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));\n+                assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n+                assertEquals(n + \" choose \" + k, Math.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n+            }\n+        }\n+\n+        int[] n = { 34, 66, 100, 1500, 1500 };\n+        int[] k = { 17, 33, 10, 1500 - 4, 4 };\n+        for (int i = 0; i < n.length; i++) {\n+            long expected = binomialCoefficient(n[i], k[i]);\n+            assertEquals(n[i] + \" choose \" + k[i], expected,\n+                MathUtils.binomialCoefficient(n[i], k[i]));\n+            assertEquals(n[i] + \" choose \" + k[i], expected,\n+                MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n+            assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", Math.log(expected),\n+                MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests correctness for large n and sharpness of upper bound in API doc\n+     * JIRA: MATH-241\n+     */\n+    public void testBinomialCoefficientLarge() throws Exception {\n+        // This tests all legal and illegal values for n <= 200.\n+        for (int n = 0; n <= 200; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                long ourResult = -1;\n+                long exactResult = -1;\n+                boolean shouldThrow = false;\n+                boolean didThrow = false;\n+                try {\n+                    ourResult = MathUtils.binomialCoefficient(n, k);\n+                } catch (ArithmeticException ex) {\n+                    didThrow = true;\n+                }\n+                try {\n+                    exactResult = binomialCoefficient(n, k);\n+                } catch (ArithmeticException ex) {\n+                    shouldThrow = true;\n+                }\n+                assertEquals(n + \" choose \" + k, exactResult, ourResult);\n+                assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n+                assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n+\n+                if (!shouldThrow && exactResult > 1) {\n+                    assertEquals(n + \" choose \" + k, 1.,\n+                        MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n+                    assertEquals(n + \" choose \" + k, 1,\n+                        MathUtils.binomialCoefficientLog(n, k) / Math.log(exactResult), 1e-10);\n+                }\n+            }\n+        }\n+\n+        long ourResult = MathUtils.binomialCoefficient(300, 3);\n+        long exactResult = binomialCoefficient(300, 3);\n+        assertEquals(exactResult, ourResult);\n+\n+        ourResult = MathUtils.binomialCoefficient(700, 697);\n+        exactResult = binomialCoefficient(700, 697);\n+        assertEquals(exactResult, ourResult);\n+\n+        // This one should throw\n+        try {\n+            MathUtils.binomialCoefficient(700, 300);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // Expected\n+        }\n+\n+        int n = 10000;\n+        ourResult = MathUtils.binomialCoefficient(n, 3);\n+        exactResult = binomialCoefficient(n, 3);\n+        assertEquals(exactResult, ourResult);\n+        assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n+        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / Math.log(exactResult), 1e-10);\n+\n+    }\n+\n+    public void testBinomialCoefficientFail() {\n+        try {\n+            MathUtils.binomialCoefficient(4, 5);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            MathUtils.binomialCoefficientDouble(4, 5);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            MathUtils.binomialCoefficientLog(4, 5);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            MathUtils.binomialCoefficient(-1, -2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            MathUtils.binomialCoefficientDouble(-1, -2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            MathUtils.binomialCoefficientLog(-1, -2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            MathUtils.binomialCoefficient(67, 30);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // ignored\n+        }\n+        try {\n+            MathUtils.binomialCoefficient(67, 34);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // ignored\n+        }\n+        double x = MathUtils.binomialCoefficientDouble(1030, 515);\n+        assertTrue(\"expecting infinite binomial coefficient\", Double\n+            .isInfinite(x));\n+    }\n+\n+    public void testCompareTo() {\n+      assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));\n+      assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);\n+      assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);\n+    }\n+    \n+    public void testCosh() {\n+        double x = 3.0;\n+        double expected = 10.06766;\n+        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);\n+    }\n+\n+    public void testCoshNaN() {\n+        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n+    }\n+\n+    public void testEquals() {\n+        double[] testArray = {\n+            Double.NaN,\n+            Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY,\n+            1d,\n+            0d };\n+        for (int i = 0; i < testArray.length; i++) {\n+            for (int j = 0; j < testArray.length; j++) {\n+                if (i == j) {\n+                    assertTrue(MathUtils.equals(testArray[i], testArray[j]));\n+                    assertTrue(MathUtils.equals(testArray[j], testArray[i]));\n+                } else {\n+                    assertTrue(!MathUtils.equals(testArray[i], testArray[j]));\n+                    assertTrue(!MathUtils.equals(testArray[j], testArray[i]));\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testEqualsWithAllowedDelta() {\n+        assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));\n+        assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));\n+        assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));\n+        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1.0));\n+        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n+        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));\n+        assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));\n+    }\n+\n+    public void testEqualsWithAllowedUlps() {\n+        assertTrue(MathUtils.equals(153, 153, 1));\n+\n+        assertTrue(MathUtils.equals(153, 153.00000000000003, 1));\n+        assertFalse(MathUtils.equals(153, 153.00000000000006, 1));\n+        assertTrue(MathUtils.equals(153, 152.99999999999997, 1));\n+        assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n+        \n+        assertTrue(MathUtils.equals(-128, -127.99999999999999, 1));\n+        assertFalse(MathUtils.equals(-128, -127.99999999999997, 1));\n+        assertTrue(MathUtils.equals(-128, -128.00000000000003, 1));\n+        assertFalse(MathUtils.equals(-128, -128.00000000000006, 1));\n+\n+        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+\n+        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1));\n+\n+        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n+    \n+    public void testArrayEquals() {\n+        assertFalse(MathUtils.equals(new double[] { 1d }, null));\n+        assertFalse(MathUtils.equals(null, new double[] { 1d }));\n+        assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n+\n+        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n+        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n+        assertTrue(MathUtils.equals(new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }, new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }));\n+        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n+                                     new double[] { Double.NEGATIVE_INFINITY }));\n+        assertFalse(MathUtils.equals(new double[] { 1d },\n+                                     new double[] { MathUtils.nextAfter(1d, 2d) }));\n+\n+    }\n+\n+    public void testFactorial() {\n+        for (int i = 1; i < 21; i++) {\n+            assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n+            assertEquals(i + \"! \", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n+            assertEquals(i + \"! \", Math.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);\n+        }\n+        \n+        assertEquals(\"0\", 1, MathUtils.factorial(0));\n+        assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n+        assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n+    }\n+\n+    public void testFactorialFail() {\n+        try {\n+            MathUtils.factorial(-1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            MathUtils.factorialDouble(-1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            MathUtils.factorialLog(-1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            MathUtils.factorial(21);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // ignored\n+        }\n+        assertTrue(\"expecting infinite factorial value\", Double.isInfinite(MathUtils.factorialDouble(171)));\n+    }\n+\n+    public void testGcd() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+\n+        assertEquals(0, MathUtils.gcd(0, 0));\n+\n+        assertEquals(b, MathUtils.gcd(0, b));\n+        assertEquals(a, MathUtils.gcd(a, 0));\n+        assertEquals(b, MathUtils.gcd(0, -b));\n+        assertEquals(a, MathUtils.gcd(-a, 0));\n+\n+        assertEquals(10, MathUtils.gcd(a, b));\n+        assertEquals(10, MathUtils.gcd(-a, b));\n+        assertEquals(10, MathUtils.gcd(a, -b));\n+        assertEquals(10, MathUtils.gcd(-a, -b));\n+\n+        assertEquals(1, MathUtils.gcd(a, c));\n+        assertEquals(1, MathUtils.gcd(-a, c));\n+        assertEquals(1, MathUtils.gcd(a, -c));\n+        assertEquals(1, MathUtils.gcd(-a, -c));\n+\n+        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n+\n+        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n+        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n+        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n+        try {\n+            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n+            MathUtils.gcd(Integer.MIN_VALUE, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n+            MathUtils.gcd(0, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n+            MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    public void testHash() {\n+        double[] testArray = {\n+            Double.NaN,\n+            Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY,\n+            1d,\n+            0d,\n+            1E-14,\n+            (1 + 1E-14),\n+            Double.MIN_VALUE,\n+            Double.MAX_VALUE };\n+        for (int i = 0; i < testArray.length; i++) {\n+            for (int j = 0; j < testArray.length; j++) {\n+                if (i == j) {\n+                    assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));\n+                    assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));\n+                } else {\n+                    assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));\n+                    assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testArrayHash() {\n+        assertEquals(0, MathUtils.hash((double[]) null));\n+        assertEquals(MathUtils.hash(new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }),\n+                     MathUtils.hash(new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }));\n+        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n+                    MathUtils.hash(new double[] { MathUtils.nextAfter(1d, 2d) }));\n+        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n+                    MathUtils.hash(new double[] { 1d, 1d }));\n+    }\n+    \n+    /**\n+     * Make sure that permuted arrays do not hash to the same value.\n+     */\n+    public void testPermutedArrayHash() {\n+        double[] original = new double[10];\n+        double[] permuted = new double[10];\n+        RandomDataImpl random = new RandomDataImpl();\n+        \n+        // Generate 10 distinct random values\n+        for (int i = 0; i < 10; i++) {\n+            original[i] = random.nextUniform(i + 0.5, i + 0.75);\n+        }\n+        \n+        // Generate a random permutation, making sure it is not the identity\n+        boolean isIdentity = true;\n+        do {\n+            int[] permutation = random.nextPermutation(10, 10);\n+            for (int i = 0; i < 10; i++) {\n+                if (i != permutation[i]) {\n+                    isIdentity = false;\n+                }\n+                permuted[i] = original[permutation[i]];\n+            }\n+        } while (isIdentity);\n+        \n+        // Verify that permuted array has different hash\n+        assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));\n+    }\n+\n+    public void testIndicatorByte() {\n+        assertEquals((byte)1, MathUtils.indicator((byte)2));\n+        assertEquals((byte)1, MathUtils.indicator((byte)0));\n+        assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));\n+    }\n+\n+    public void testIndicatorDouble() {\n+        double delta = 0.0;\n+        assertEquals(1.0, MathUtils.indicator(2.0), delta);\n+        assertEquals(1.0, MathUtils.indicator(0.0), delta);\n+        assertEquals(-1.0, MathUtils.indicator(-2.0), delta);\n+        assertEquals(Double.NaN, MathUtils.indicator(Double.NaN));\n+    }\n+\n+    public void testIndicatorFloat() {\n+        float delta = 0.0F;\n+        assertEquals(1.0F, MathUtils.indicator(2.0F), delta);\n+        assertEquals(1.0F, MathUtils.indicator(0.0F), delta);\n+        assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);\n+    }\n+\n+    public void testIndicatorInt() {\n+        assertEquals(1, MathUtils.indicator((2)));\n+        assertEquals(1, MathUtils.indicator((0)));\n+        assertEquals((-1), MathUtils.indicator((-2)));\n+    }\n+\n+    public void testIndicatorLong() {\n+        assertEquals(1L, MathUtils.indicator(2L));\n+        assertEquals(1L, MathUtils.indicator(0L));\n+        assertEquals(-1L, MathUtils.indicator(-2L));\n+    }\n+\n+    public void testIndicatorShort() {\n+        assertEquals((short)1, MathUtils.indicator((short)2));\n+        assertEquals((short)1, MathUtils.indicator((short)0));\n+        assertEquals((short)(-1), MathUtils.indicator((short)(-2)));\n+    }\n+\n+    public void testLcm() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+\n+        assertEquals(0, MathUtils.lcm(0, b));\n+        assertEquals(0, MathUtils.lcm(a, 0));\n+        assertEquals(b, MathUtils.lcm(1, b));\n+        assertEquals(a, MathUtils.lcm(a, 1));\n+        assertEquals(150, MathUtils.lcm(a, b));\n+        assertEquals(150, MathUtils.lcm(-a, b));\n+        assertEquals(150, MathUtils.lcm(a, -b));\n+        assertEquals(150, MathUtils.lcm(-a, -b));\n+        assertEquals(2310, MathUtils.lcm(a, c));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n+\n+        // Special case\n+        assertEquals(0, MathUtils.lcm(0, 0));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            MathUtils.lcm(Integer.MIN_VALUE, 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+        \n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLog() {\n+        assertEquals(2.0, MathUtils.log(2, 4), 0);\n+        assertEquals(3.0, MathUtils.log(2, 8), 0);\n+        assertTrue(Double.isNaN(MathUtils.log(-1, 1)));\n+        assertTrue(Double.isNaN(MathUtils.log(1, -1)));\n+        assertTrue(Double.isNaN(MathUtils.log(0, 0)));\n+        assertEquals(0, MathUtils.log(0, 10), 0);\n+        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);\n+    }\n+\n+    public void testMulAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        assertEquals(big, MathUtils.mulAndCheck(big, 1));\n+        try {\n+            MathUtils.mulAndCheck(big, 2);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+        try {\n+            MathUtils.mulAndCheck(bigNeg, 2);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+    }\n+\n+    public void testMulAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        assertEquals(max, MathUtils.mulAndCheck(max, 1L));\n+        assertEquals(min, MathUtils.mulAndCheck(min, 1L));\n+        assertEquals(0L, MathUtils.mulAndCheck(max, 0L));\n+        assertEquals(0L, MathUtils.mulAndCheck(min, 0L));\n+        assertEquals(max, MathUtils.mulAndCheck(1L, max));\n+        assertEquals(min, MathUtils.mulAndCheck(1L, min));\n+        assertEquals(0L, MathUtils.mulAndCheck(0L, max));\n+        assertEquals(0L, MathUtils.mulAndCheck(0L, min));\n+        assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));\n+        assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));\n+        testMulAndCheckLongFailure(max, 2L);\n+        testMulAndCheckLongFailure(2L, max);\n+        testMulAndCheckLongFailure(min, 2L);\n+        testMulAndCheckLongFailure(2L, min);\n+        testMulAndCheckLongFailure(min, -1L);\n+        testMulAndCheckLongFailure(-1L, min);\n+    }\n+\n+    private void testMulAndCheckLongFailure(long a, long b) {\n+        try {\n+            MathUtils.mulAndCheck(a, b);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testNextAfter() {\n+        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000\n+        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n+\n+        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe\n+        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n+\n+        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe\n+        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n+\n+        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe\n+        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n+\n+        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001\n+        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);\n+\n+        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff\n+        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);\n+\n+        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff\n+        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);\n+\n+        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff\n+        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224\n+        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224\n+        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224\n+        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224\n+        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+\n+    }\n+\n+    public void testNextAfterSpecialCases() {\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));\n+        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY)));\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));\n+        assertEquals(Double.MIN_VALUE, MathUtils.nextAfter(0, 1), 0);\n+        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);\n+        assertEquals(0, MathUtils.nextAfter(Double.MIN_VALUE, -1), 0);\n+        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE, 1), 0);\n+    }\n+\n+    public void testScalb() {\n+        assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);\n+        assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);\n+        assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);\n+        assertEquals(Math.PI, MathUtils.scalb(Math.PI, 0), 1.0e-15);\n+        assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));\n+        assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));\n+        assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));\n+    }\n+\n+    public void testNormalizeAngle() {\n+        for (double a = -15.0; a <= 15.0; a += 0.1) {\n+            for (double b = -15.0; b <= 15.0; b += 0.2) {\n+                double c = MathUtils.normalizeAngle(a, b);\n+                assertTrue((b - Math.PI) <= c);\n+                assertTrue(c <= (b + Math.PI));\n+                double twoK = Math.rint((a - c) / Math.PI);\n+                assertEquals(c, a - twoK * Math.PI, 1.0e-14);\n+            }\n+        }\n+    }\n+\n+    public void testRoundDouble() {\n+        double x = 1.234567890;\n+        assertEquals(1.23, MathUtils.round(x, 2), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4), 0.0);\n+\n+        // JIRA MATH-151\n+        assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);\n+        assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        double xx = 39.0;\n+        xx = xx + 245d / 1000d;\n+        assertEquals(39.25, MathUtils.round(xx, 2), 0.0);\n+\n+        // BZ 35904\n+        assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);\n+        assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);\n+        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);\n+        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);\n+        assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);\n+        assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);\n+        assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);\n+        assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);\n+        assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);\n+\n+        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+\n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+\n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+\n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+\n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+\n+        try {\n+            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+\n+        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+\n+        try {\n+            MathUtils.round(1.234, 2, 1923);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        // MATH-151\n+        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        // special values\n+        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);\n+        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n+    }\n+\n+    public void testRoundFloat() {\n+        float x = 1.234567890f;\n+        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);\n+\n+        // BZ 35904\n+        assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);\n+        assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);\n+        assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);\n+        assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);\n+        assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);\n+        assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);\n+        assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);\n+\n+        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+\n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+\n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+\n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+\n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+\n+        try {\n+            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+\n+        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+\n+        try {\n+            MathUtils.round(1.234f, 2, 1923);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        // special values\n+        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);\n+        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);\n+        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n+        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n+    }\n+\n+    public void testSignByte() {\n+        assertEquals((byte) 1, MathUtils.sign((byte) 2));\n+        assertEquals((byte) 0, MathUtils.sign((byte) 0));\n+        assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));\n+    }\n+\n+    public void testSignDouble() {\n+        double delta = 0.0;\n+        assertEquals(1.0, MathUtils.sign(2.0), delta);\n+        assertEquals(0.0, MathUtils.sign(0.0), delta);\n+        assertEquals(-1.0, MathUtils.sign(-2.0), delta);\n+        TestUtils.assertSame(-0. / 0., MathUtils.sign(Double.NaN));\n+    }\n+\n+    public void testSignFloat() {\n+        float delta = 0.0F;\n+        assertEquals(1.0F, MathUtils.sign(2.0F), delta);\n+        assertEquals(0.0F, MathUtils.sign(0.0F), delta);\n+        assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);\n+        TestUtils.assertSame(Float.NaN, MathUtils.sign(Float.NaN));\n+    }\n+\n+    public void testSignInt() {\n+        assertEquals(1, MathUtils.sign(2));\n+        assertEquals(0, MathUtils.sign(0));\n+        assertEquals((-1), MathUtils.sign((-2)));\n+    }\n+\n+    public void testSignLong() {\n+        assertEquals(1L, MathUtils.sign(2L));\n+        assertEquals(0L, MathUtils.sign(0L));\n+        assertEquals(-1L, MathUtils.sign(-2L));\n+    }\n+\n+    public void testSignShort() {\n+        assertEquals((short) 1, MathUtils.sign((short) 2));\n+        assertEquals((short) 0, MathUtils.sign((short) 0));\n+        assertEquals((short) (-1), MathUtils.sign((short) (-2)));\n+    }\n+\n+    public void testSinh() {\n+        double x = 3.0;\n+        double expected = 10.01787;\n+        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);\n+    }\n+\n+    public void testSinhNaN() {\n+        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));\n+    }\n+\n+    public void testSubAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        assertEquals(big, MathUtils.subAndCheck(big, 0));\n+        assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));\n+        assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));\n+        try {\n+            MathUtils.subAndCheck(big, -1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+        try {\n+            MathUtils.subAndCheck(bigNeg, 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+    }\n+\n+    public void testSubAndCheckErrorMessage() {\n+        int big = Integer.MAX_VALUE;\n+        try {\n+            MathUtils.subAndCheck(big, -1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            assertEquals(\"overflow: subtract\", ex.getMessage());\n+        }\n+    }\n+\n+    public void testSubAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        assertEquals(max, MathUtils.subAndCheck(max, 0));\n+        assertEquals(min, MathUtils.subAndCheck(min, 0));\n+        assertEquals(-max, MathUtils.subAndCheck(0, max));\n+        assertEquals(min + 1, MathUtils.subAndCheck(min, -1));\n+        // min == -1-max\n+        assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));\n+        assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));\n+        testSubAndCheckLongFailure(0L, min);\n+        testSubAndCheckLongFailure(max, -1L);\n+        testSubAndCheckLongFailure(min, 1L);\n+    }\n+\n+    private void testSubAndCheckLongFailure(long a, long b) {\n+        try {\n+            MathUtils.subAndCheck(a, b);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+\n+    }\n+\n+    public void testPow() {\n+\n+        assertEquals(1801088541, MathUtils.pow(21, 7));\n+        assertEquals(1, MathUtils.pow(21, 0));\n+        try {\n+            MathUtils.pow(21, -7);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        assertEquals(1801088541, MathUtils.pow(21, 7l));\n+        assertEquals(1, MathUtils.pow(21, 0l));\n+        try {\n+            MathUtils.pow(21, -7l);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        assertEquals(1801088541l, MathUtils.pow(21l, 7));\n+        assertEquals(1l, MathUtils.pow(21l, 0));\n+        try {\n+            MathUtils.pow(21l, -7);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        assertEquals(1801088541l, MathUtils.pow(21l, 7l));\n+        assertEquals(1l, MathUtils.pow(21l, 0l));\n+        try {\n+            MathUtils.pow(21l, -7l);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        BigInteger twentyOne = BigInteger.valueOf(21l);\n+        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));\n+        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));\n+        try {\n+            MathUtils.pow(twentyOne, -7);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));\n+        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));\n+        try {\n+            MathUtils.pow(twentyOne, -7l);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));\n+        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));\n+        try {\n+            MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        BigInteger bigOne =\n+            new BigInteger(\"1543786922199448028351389769265814882661837148\" +\n+                           \"4763915343722775611762713982220306372888519211\" +\n+                           \"560905579993523402015636025177602059044911261\");\n+        assertEquals(bigOne, MathUtils.pow(twentyOne, 103));\n+        assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));\n+        assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));\n+        \n+    }\n+\n+    public void testL1DistanceDouble() {\n+        double[] p1 = { 2.5,  0.0 };\n+        double[] p2 = { -0.5, 4.0 };\n+        assertEquals(7.0, MathUtils.distance1(p1, p2));\n+    }\n+\n+    public void testL1DistanceInt() {\n+        int[] p1 = { 3, 0 };\n+        int[] p2 = { 0, 4 };\n+        assertEquals(7, MathUtils.distance1(p1, p2));\n+    }\n+\n+    public void testL2DistanceDouble() {\n+        double[] p1 = { 2.5,  0.0 };\n+        double[] p2 = { -0.5, 4.0 };\n+        assertEquals(5.0, MathUtils.distance(p1, p2));\n+    }\n+\n+    public void testL2DistanceInt() {\n+        int[] p1 = { 3, 0 };\n+        int[] p2 = { 0, 4 };\n+        assertEquals(5.0, MathUtils.distance(p1, p2));\n+    }\n+\n+    public void testLInfDistanceDouble() {\n+        double[] p1 = { 2.5,  0.0 };\n+        double[] p2 = { -0.5, 4.0 };\n+        assertEquals(4.0, MathUtils.distanceInf(p1, p2));\n+    }\n+\n+    public void testLInfDistanceInt() {\n+        int[] p1 = { 3, 0 };\n+        int[] p2 = { 0, 4 };\n+        assertEquals(4, MathUtils.distanceInf(p1, p2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link OpenIntToDoubleHashMap}.\n+ */\n+public class OpenIntToDoubleHashMapTest extends TestCase {\n+\n+    private Map<Integer, Double> javaMap = new HashMap<Integer, Double>();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        javaMap.put(50, 100.0);\n+        javaMap.put(75, 75.0);\n+        javaMap.put(25, 500.0);\n+        javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE);\n+        javaMap.put(0, -1.0);\n+        javaMap.put(1, 0.0);\n+        javaMap.put(33, -0.1);\n+        javaMap.put(23234234, -242343.0);\n+        javaMap.put(23321, Double.MIN_VALUE);\n+        javaMap.put(-4444, 332.0);\n+        javaMap.put(-1, -2323.0);\n+        javaMap.put(Integer.MIN_VALUE, 44.0);\n+\n+        /* Add a few more to cause the table to rehash */\n+        javaMap.putAll(generate());\n+\n+    }\n+\n+    private Map<Integer, Double> generate() {\n+        Map<Integer, Double> map = new HashMap<Integer, Double>();\n+        Random r = new Random();\n+        for (int i = 0; i < 2000; ++i)\n+            map.put(r.nextInt(), r.nextDouble());\n+        return map;\n+    }\n+\n+    private OpenIntToDoubleHashMap createFromJavaMap() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+        }\n+        return map;\n+    }\n+    \n+    public void testPutAndGetWith0ExpectedSize() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);\n+        assertPutAndGet(map);\n+    }\n+    \n+    public void testPutAndGetWithExpectedSize() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);\n+        assertPutAndGet(map);\n+    }\n+\n+    public void testPutAndGet() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        assertPutAndGet(map);\n+    }\n+\n+    private void assertPutAndGet(OpenIntToDoubleHashMap map) {\n+        assertPutAndGet(map, 0, new HashSet<Integer>());\n+    }\n+\n+    private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,\n+            Set<Integer> keysInMap) {\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            if (!keysInMap.contains(mapEntry.getKey()))\n+                ++mapSize;\n+            assertEquals(mapSize, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutAbsentOnExisting() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int size = javaMap.size();\n+        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(++size, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutOnExisting() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(javaMap.size(), map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testGetAbsent() {\n+        Map<Integer, Double> generated = generateAbsent();\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        \n+        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())\n+            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+    }\n+\n+    public void testGetFromEmpty() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        assertTrue(Double.isNaN(map.get(5)));\n+        assertTrue(Double.isNaN(map.get(0)));\n+        assertTrue(Double.isNaN(map.get(50)));\n+    }\n+\n+    public void testRemove() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int mapSize = javaMap.size();\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map);\n+    }\n+\n+    /* This time only remove some entries */\n+    public void testRemove2() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int mapSize = javaMap.size();\n+        int count = 0;\n+        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            keysInMap.remove(mapEntry.getKey());\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+            if (count++ > 5)\n+                break;\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map, mapSize, keysInMap);\n+    }\n+\n+    public void testRemoveFromEmpty() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        assertTrue(Double.isNaN(map.remove(50)));\n+    }\n+\n+    public void testRemoveAbsent() {\n+        Map<Integer, Double> generated = generateAbsent();\n+\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int mapSize = map.size();\n+        \n+        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(mapSize, map.size());\n+            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+        }\n+    }\n+\n+    /**\n+     * Returns a map with at least 100 elements where each element is absent from javaMap.\n+     */\n+    private Map<Integer, Double> generateAbsent() {\n+        Map<Integer, Double> generated = new HashMap<Integer, Double>();\n+        do {\n+            generated.putAll(generate());\n+            for (Integer key : javaMap.keySet())\n+                generated.remove(key);\n+        } while (generated.size() < 100);\n+        return generated;\n+    }\n+\n+    public void testCopy() {\n+        OpenIntToDoubleHashMap copy =\n+            new OpenIntToDoubleHashMap(createFromJavaMap());\n+        assertEquals(javaMap.size(), copy.size());\n+\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())\n+            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n+    }\n+\n+    public void testContainsKey() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            assertTrue(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n+            assertFalse(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            int key = mapEntry.getKey();\n+            assertTrue(map.containsKey(key));\n+            map.remove(key);\n+            assertFalse(map.containsKey(key));\n+        }\n+    }\n+\n+    public void testIterator() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n+        for (int i = 0; i < map.size(); ++i) {\n+            assertTrue(iterator.hasNext());\n+            iterator.advance();\n+            int key = iterator.key();\n+            assertTrue(map.containsKey(key));\n+            assertEquals(javaMap.get(key), map.get(key), 0);\n+            assertEquals(javaMap.get(key), iterator.value(), 0);\n+            assertTrue(javaMap.containsKey(key));\n+        }\n+        assertFalse(iterator.hasNext());\n+        try {\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n+        } catch (NoSuchElementException nsee) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConcurrentModification() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n+        map.put(3, 3);\n+        try {\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConcurrentModificationException cme) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Regression test for a bug in findInsertionIndex where the hashing in the second probing\n+     * loop was inconsistent with the first causing duplicate keys after the right sequence\n+     * of puts and removes.\n+     */\n+    public void testPutKeysWithCollisions() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        int key1 = -1996012590;\n+        double value1 = 1.0;\n+        map.put(key1, value1);\n+        int key2 = 835099822;\n+        map.put(key2, value1);\n+        int key3 = 1008859686;\n+        map.put(key3, value1);\n+        assertEquals(value1, map.get(key3));\n+        assertEquals(3, map.size());\n+        \n+        map.remove(key2);\n+        double value2 = 2.0;\n+        map.put(key3, value2);\n+        assertEquals(value2, map.get(key3));\n+        assertEquals(2, map.size());\n+    }\n+    \n+    /**\n+     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n+     * different manner.\n+     */\n+    public void testPutKeysWithCollision2() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        int key1 = 837989881;\n+        double value1 = 1.0;\n+        map.put(key1, value1);\n+        int key2 = 476463321;\n+        map.put(key2, value1);\n+        assertEquals(2, map.size());\n+        assertEquals(value1, map.get(key2));\n+        \n+        map.remove(key1);\n+        double value2 = 2.0;\n+        map.put(key2, value2);\n+        assertEquals(1, map.size());\n+        assertEquals(value2, map.get(key2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+import junit.framework.TestCase;\n+\n+public class OpenIntToFieldTest extends TestCase {\n+\n+    private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>();\n+    private FractionField field = FractionField.getInstance();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        javaMap.put(50, new Fraction(100.0));\n+        javaMap.put(75, new Fraction(75.0));\n+        javaMap.put(25, new Fraction(500.0));\n+        javaMap.put(Integer.MAX_VALUE, new Fraction(Integer.MAX_VALUE));\n+        javaMap.put(0, new Fraction(-1.0));\n+        javaMap.put(1, new Fraction(0.0));\n+        javaMap.put(33, new Fraction(-0.1));\n+        javaMap.put(23234234, new Fraction(-242343.0));\n+        javaMap.put(23321, new Fraction (Integer.MIN_VALUE));\n+        javaMap.put(-4444, new Fraction(332.0));\n+        javaMap.put(-1, new Fraction(-2323.0));\n+        javaMap.put(Integer.MIN_VALUE, new Fraction(44.0));\n+\n+        /* Add a few more to cause the table to rehash */\n+        javaMap.putAll(generate());\n+\n+    }\n+\n+    private Map<Integer, Fraction> generate() {\n+        Map<Integer, Fraction> map = new HashMap<Integer, Fraction>();\n+        Random r = new Random();\n+        double dd=0;\n+        for (int i = 0; i < 2000; ++i)\n+            dd = r.nextDouble(); \n+            try {\n+                map.put(r.nextInt(), new Fraction(dd));\n+            } catch (FractionConversionException e) {\n+                throw new IllegalStateException(\"Invalid :\"+dd, e);\n+            }\n+        return map;\n+    }\n+\n+    private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+        }\n+        return map;\n+    }\n+    \n+    public void testPutAndGetWith0ExpectedSize() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);\n+        assertPutAndGet(map);\n+    }\n+    \n+    public void testPutAndGetWithExpectedSize() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);\n+        assertPutAndGet(map);\n+    }\n+\n+    public void testPutAndGet() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        assertPutAndGet(map);\n+    }\n+\n+    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map) {\n+        assertPutAndGet(map, 0, new HashSet<Integer>());\n+    }\n+\n+    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize,\n+            Set<Integer> keysInMap) {\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            if (!keysInMap.contains(mapEntry.getKey()))\n+                ++mapSize;\n+            assertEquals(mapSize, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutAbsentOnExisting() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int size = javaMap.size();\n+        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(++size, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutOnExisting() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(javaMap.size(), map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testGetAbsent() {\n+        Map<Integer, Fraction> generated = generateAbsent();\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        \n+        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+    }\n+\n+    public void testGetFromEmpty() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        assertTrue(field.getZero().equals(map.get(5)));\n+        assertTrue(field.getZero().equals(map.get(0)));\n+        assertTrue(field.getZero().equals(map.get(50)));\n+    }\n+\n+    public void testRemove() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int mapSize = javaMap.size();\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map);\n+    }\n+\n+    /* This time only remove some entries */\n+    public void testRemove2() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int mapSize = javaMap.size();\n+        int count = 0;\n+        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            keysInMap.remove(mapEntry.getKey());\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+            if (count++ > 5)\n+                break;\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map, mapSize, keysInMap);\n+    }\n+\n+    public void testRemoveFromEmpty() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        assertTrue(field.getZero().equals(map.remove(50)));\n+    }\n+\n+    public void testRemoveAbsent() {\n+        Map<Integer, Fraction> generated = generateAbsent();\n+\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int mapSize = map.size();\n+        \n+        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(mapSize, map.size());\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+        }\n+    }\n+\n+    /**\n+     * Returns a map with at least 100 elements where each element is absent from javaMap.\n+     */\n+    private Map<Integer, Fraction> generateAbsent() {\n+        Map<Integer, Fraction> generated = new HashMap<Integer, Fraction>();\n+        do {\n+            generated.putAll(generate());\n+            for (Integer key : javaMap.keySet())\n+                generated.remove(key);\n+        } while (generated.size() < 100);\n+        return generated;\n+    }\n+\n+    public void testCopy() {\n+        OpenIntToFieldHashMap<Fraction> copy =\n+            new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));\n+        assertEquals(javaMap.size(), copy.size());\n+\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet())\n+            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n+    }\n+\n+    public void testContainsKey() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            assertTrue(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {\n+            assertFalse(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            int key = mapEntry.getKey();\n+            assertTrue(map.containsKey(key));\n+            map.remove(key);\n+            assertFalse(map.containsKey(key));\n+        }\n+    }\n+\n+    public void testIterator() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();\n+        for (int i = 0; i < map.size(); ++i) {\n+            assertTrue(iterator.hasNext());\n+            iterator.advance();\n+            int key = iterator.key();\n+            assertTrue(map.containsKey(key));\n+            assertEquals(javaMap.get(key), map.get(key));\n+            assertEquals(javaMap.get(key), iterator.value());\n+            assertTrue(javaMap.containsKey(key));\n+        }\n+        assertFalse(iterator.hasNext());\n+        try {\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n+        } catch (NoSuchElementException nsee) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConcurrentModification() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();\n+        map.put(3, new Fraction(3));\n+        try {\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConcurrentModificationException cme) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Regression test for a bug in findInsertionIndex where the hashing in the second probing\n+     * loop was inconsistent with the first causing duplicate keys after the right sequence\n+     * of puts and removes.\n+     */\n+    public void testPutKeysWithCollisions() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        int key1 = -1996012590;\n+        Fraction value1 = new Fraction(1);\n+        map.put(key1, value1);\n+        int key2 = 835099822;\n+        map.put(key2, value1);\n+        int key3 = 1008859686;\n+        map.put(key3, value1);\n+        assertEquals(value1, map.get(key3));\n+        assertEquals(3, map.size());\n+        \n+        map.remove(key2);\n+        Fraction value2 = new Fraction(2);\n+        map.put(key3, value2);\n+        assertEquals(value2, map.get(key3));\n+        assertEquals(2, map.size());\n+    }\n+    \n+    /**\n+     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n+     * different manner.\n+     */\n+    public void testPutKeysWithCollision2() {\n+        OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field);\n+        int key1 = 837989881;\n+        Fraction value1 = new Fraction(1);\n+        map.put(key1, value1);\n+        int key2 = 476463321;\n+        map.put(key2, value1);\n+        assertEquals(2, map.size());\n+        assertEquals(value1, map.get(key2));\n+        \n+        map.remove(key1);\n+        Fraction value2 = new Fraction(2);\n+        map.put(key2, value2);\n+        assertEquals(1, map.size());\n+        assertEquals(value2, map.get(key2));\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.random.RandomData;\n+\n+\n+/**\n+ * This class contains test cases for the ResizableDoubleArray.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {\n+    \n+    public ResizableDoubleArrayTest(String name) {\n+        super( name );\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        da = null;\n+        ra = null;\n+    }\n+       \n+    @Override\n+    protected void setUp() throws Exception {\n+        da = new ResizableDoubleArray();\n+        ra = new ResizableDoubleArray();\n+    }\n+    \n+    public void testConstructors() {\n+        float defaultExpansionFactor = 2.0f;\n+        float defaultContractionCriteria = 2.5f;\n+        int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;\n+        \n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n+        assertEquals(defaultMode, testDa.getExpansionMode());\n+        try {\n+            da = new ResizableDoubleArray(-1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        testDa = new ResizableDoubleArray(2, 2.0f);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n+        assertEquals(defaultMode, testDa.getExpansionMode());\n+        \n+        try {\n+            da = new ResizableDoubleArray(2, 0.5f);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        testDa = new ResizableDoubleArray(2, 3.0f);\n+        assertEquals(3.0f, testDa.getExpansionFactor(), 0);\n+        assertEquals(3.5f, testDa.getContractionCriteria(), 0);\n+        \n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n+        assertEquals(defaultMode, testDa.getExpansionMode());\n+        \n+        try {\n+            da = new ResizableDoubleArray(2, 2.0f, 1.5f);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n+        assertEquals(ResizableDoubleArray.ADDITIVE_MODE, \n+                testDa.getExpansionMode());\n+        \n+        try {\n+            da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        // Copy constructor\n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        testDa.addElement(2.0);\n+        testDa.addElement(3.2);\n+        ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);\n+        assertEquals(copyDa, testDa);\n+        assertEquals(testDa, copyDa);   \n+    }\n+    \n+    \n+    public void testSetElementArbitraryExpansion() {\n+        \n+        // MULTIPLICATIVE_MODE \n+        da.addElement(2.0);\n+        da.addElement(4.0);\n+        da.addElement(6.0);\n+        da.setElement(1, 3.0);\n+        \n+        // Expand the array arbitrarily to 1000 items\n+        da.setElement(1000, 3.4);\n+        \n+        assertEquals( \"The number of elements should now be 1001, it isn't\", \n+                da.getNumElements(), 1001);\n+        \n+        assertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n+                da.getElement( 760 ), Double.MIN_VALUE );\n+        \n+        assertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), \n+                Double.MIN_VALUE );\n+        assertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), \n+                Double.MIN_VALUE); \n+        \n+        // Make sure numElements and expansion work correctly for expansion boundary cases\n+        da.clear();\n+        da.addElement(2.0);\n+        da.addElement(4.0);\n+        da.addElement(6.0);\n+        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(3, da.getNumElements());\n+        da.setElement(3, 7.0);\n+        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(4, da.getNumElements());\n+        da.setElement(10, 10.0);\n+        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(11, da.getNumElements());\n+        da.setElement(9, 10.0);\n+        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(11, da.getNumElements());\n+        \n+        try {\n+            da.setElement(-2, 3);\n+            fail(\"Expecting ArrayIndexOutOfBoundsException for negative index\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        \n+        // ADDITIVE_MODE\n+        \n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(2, testDa.getInternalLength());\n+        testDa.addElement(1d);\n+        testDa.addElement(1d);\n+        assertEquals(2, testDa.getInternalLength());\n+        testDa.addElement(1d);\n+        assertEquals(4, testDa.getInternalLength());         \n+    }\n+\n+    @Override\n+    public void testAdd1000() {\n+        super.testAdd1000();\n+        assertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+                \"16 and an expansion factor of 2.0\",\n+                1024, ((ResizableDoubleArray) da).getInternalLength());\n+    }\n+\n+    @Override\n+    public void testAddElementRolling() {\n+        super.testAddElementRolling();\n+        \n+        // MULTIPLICATIVE_MODE\n+        da.clear();\n+        da.addElement(1);\n+        da.addElement(2);\n+        da.addElementRolling(3);\n+        assertEquals(3, da.getElement(1), 0);\n+        da.addElementRolling(4);\n+        assertEquals(3, da.getElement(0), 0);\n+        assertEquals(4, da.getElement(1), 0);\n+        da.addElement(5);\n+        assertEquals(5, da.getElement(2), 0);\n+        da.addElementRolling(6);\n+        assertEquals(4, da.getElement(0), 0);\n+        assertEquals(5, da.getElement(1), 0);\n+        assertEquals(6, da.getElement(2), 0);   \n+        \n+        // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)\n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(2, testDa.getInternalLength());\n+        testDa.addElement(1d); // x,0\n+        testDa.addElement(2d); // x,x\n+        testDa.addElement(3d); // x,x,x,0 -- expanded\n+        assertEquals(1d, testDa.getElement(0), 0);\n+        assertEquals(2d, testDa.getElement(1), 0);\n+        assertEquals(3d, testDa.getElement(2), 0);   \n+        assertEquals(4, testDa.getInternalLength());  // x,x,x,0 \n+        assertEquals(3, testDa.getNumElements());\n+        testDa.addElementRolling(4d);\n+        assertEquals(2d, testDa.getElement(0), 0);\n+        assertEquals(3d, testDa.getElement(1), 0);\n+        assertEquals(4d, testDa.getElement(2), 0);   \n+        assertEquals(4, testDa.getInternalLength());  // 0,x,x,x\n+        assertEquals(3, testDa.getNumElements());\n+        testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract\n+        assertEquals(3d, testDa.getElement(0), 0);\n+        assertEquals(4d, testDa.getElement(1), 0);\n+        assertEquals(5d, testDa.getElement(2), 0);   \n+        assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0     \n+        assertEquals(3, testDa.getNumElements());\n+        try {\n+            testDa.getElement(4);\n+            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected\n+        }  \n+        try {\n+            testDa.getElement(-1);\n+            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetNumberOfElements() {\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        assertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n+        \n+        ((ResizableDoubleArray) da).setNumElements( 3 );\n+        assertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n+        \n+        try {\n+            ((ResizableDoubleArray) da).setNumElements( -3 );\n+            fail( \"Setting number of elements to negative should've thrown an exception\");\n+        } catch( IllegalArgumentException iae ) {\n+        }\n+        \n+        ((ResizableDoubleArray) da).setNumElements(1024);\n+        assertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n+        assertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+        \n+    }\n+    \n+    public void testWithInitialCapacity() {\n+        \n+        ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);\n+        assertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n+        \n+        RandomData randomData = new RandomDataImpl();\n+        int iterations = randomData.nextInt(100, 1000);\n+        \n+        for( int i = 0; i < iterations; i++) {\n+            eDA2.addElement( i );\n+        }\n+        \n+        assertEquals(\"Number of elements should be equal to \" + iterations, iterations, eDA2.getNumElements());\n+        \n+        eDA2.addElement( 2.0 );\n+        \n+        assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n+                iterations + 1 , eDA2.getNumElements() );\n+    }\n+    \n+    public void testWithInitialCapacityAndExpansionFactor() {\n+        \n+        ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);\n+        assertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n+        \n+        RandomData randomData = new RandomDataImpl();\n+        int iterations = randomData.nextInt(100, 3000);\n+        \n+        for( int i = 0; i < iterations; i++) {\n+            eDA3.addElement( i );\n+        }\n+        \n+        assertEquals(\"Number of elements should be equal to \" + iterations, iterations,eDA3.getNumElements());\n+        \n+        eDA3.addElement( 2.0 );\n+        \n+        assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n+                iterations +1, eDA3.getNumElements() );\n+        \n+        assertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n+    }\n+    \n+    public void testDiscard() {\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        \n+        ((ResizableDoubleArray)da).discardFrontElements(5);\n+        assertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n+\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        assertEquals( \"Number of elements should be 10\", 10, da.getNumElements());\n+\n+        ((ResizableDoubleArray)da).discardMostRecentElements(2);\n+        assertEquals( \"Number of elements should be 8\", 8, da.getNumElements());\n+        \n+        try {\n+            ((ResizableDoubleArray)da).discardFrontElements(-1);\n+            fail( \"Trying to discard a negative number of element is not allowed\");\n+        } catch( Exception e ){\n+        }\n+\n+        try {\n+            ((ResizableDoubleArray)da).discardMostRecentElements(-1);\n+            fail( \"Trying to discard a negative number of element is not allowed\");\n+        } catch( Exception e ){\n+        }\n+\n+        try {\n+            ((ResizableDoubleArray)da).discardFrontElements( 10000 );\n+            fail( \"You can't discard more elements than the array contains\");\n+        } catch( Exception e ){\n+        }\n+\n+        try {\n+            ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );\n+            fail( \"You can't discard more elements than the array contains\");\n+        } catch( Exception e ){\n+        }\n+\n+    }\n+\n+    public void testSubstitute() {\n+    \n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        \n+        ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n+\n+        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+\n+        try {\n+            ((ResizableDoubleArray)da).discardMostRecentElements(10);\n+        } catch( Exception e ){\n+            fail( \"Trying to discard a negative number of element is not allowed\");\n+        }\n+\n+        ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n+\n+        assertEquals( \"Number of elements should be 1\", 1, da.getNumElements());\n+\n+    }\n+    \n+    public void testMutators() {\n+        ((ResizableDoubleArray)da).setContractionCriteria(10f);\n+        assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);\n+        ((ResizableDoubleArray)da).setExpansionFactor(8f);  \n+        assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);\n+        try {\n+            ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        ((ResizableDoubleArray)da).setExpansionMode(\n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(ResizableDoubleArray.ADDITIVE_MODE, \n+                ((ResizableDoubleArray)da).getExpansionMode());\n+        try {\n+            ((ResizableDoubleArray)da).setExpansionMode(-1);\n+            fail (\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() throws Exception {\n+        \n+        // Wrong type\n+        ResizableDoubleArray first = new ResizableDoubleArray();\n+        Double other = new Double(2);\n+        assertFalse(first.equals(other));\n+        \n+        // Null\n+        other = null;\n+        assertFalse(first.equals(other));\n+        \n+        // Reflexive\n+        assertTrue(first.equals(first));\n+        \n+        // Argumentless constructor\n+        ResizableDoubleArray second = new ResizableDoubleArray();\n+        verifyEquality(first, second);\n+        \n+        // Equals iff same data, same properties\n+        ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);\n+        verifyInequality(third, first);\n+        ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f);\n+        ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f);\n+        verifyEquality(third, fourth);\n+        verifyInequality(third, fifth);\n+        third.addElement(4.1);\n+        third.addElement(4.2);\n+        third.addElement(4.3);\n+        fourth.addElement(4.1);\n+        fourth.addElement(4.2);\n+        fourth.addElement(4.3);\n+        verifyEquality(third, fourth);\n+        \n+        // expand\n+        fourth.addElement(4.4);\n+        verifyInequality(third, fourth);\n+        third.addElement(4.4);\n+        verifyEquality(third, fourth);\n+        fourth.addElement(4.4);\n+        verifyInequality(third, fourth);\n+        third.addElement(4.4);\n+        verifyEquality(third, fourth);\n+        fourth.addElementRolling(4.5);\n+        third.addElementRolling(4.5);\n+        verifyEquality(third, fourth);\n+        \n+        // discard\n+        third.discardFrontElements(1);\n+        verifyInequality(third, fourth);\n+        fourth.discardFrontElements(1);\n+        verifyEquality(third, fourth);\n+        \n+        // discard recent\n+        third.discardMostRecentElements(2);\n+        fourth.discardMostRecentElements(2);\n+        verifyEquality(third, fourth);\n+        \n+        // wrong order\n+        third.addElement(18);\n+        fourth.addElement(17);\n+        third.addElement(17);\n+        fourth.addElement(18);\n+        verifyInequality(third, fourth);\n+        \n+        // copy\n+        ResizableDoubleArray.copy(fourth, fifth);\n+        verifyEquality(fourth, fifth);\n+        \n+        // Copy constructor\n+        verifyEquality(fourth, new ResizableDoubleArray(fourth));\n+        \n+        // Instance copy\n+        verifyEquality(fourth, fourth.copy());   \n+             \n+    }\n+    \n+    private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {\n+        assertTrue(b.equals(a));\n+        assertTrue(a.equals(b));\n+        assertEquals(a.hashCode(), b.hashCode());    \n+    }\n+    \n+    private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {\n+        assertFalse(b.equals(a));\n+        assertFalse(a.equals(b));\n+        assertFalse(a.hashCode() == b.hashCode());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/TestBean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class TestBean {\n+    private Double x = Double.valueOf(1.0);\n+\n+    private String y = \"1.0\";\n+\n+    /**\n+     * \n+     */\n+    public Double getX() {\n+        return x;\n+    }\n+\n+    /**\n+     * \n+     */\n+    public String getY() {\n+        return y;\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void setX(Double double1) {\n+        x = double1;\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void setY(String string) {\n+        y = string;\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public Double getZ() {\n+        throw new MathRuntimeException(\"?\");\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void setZ(Double double1) {\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/TransformerMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class TransformerMapTest extends TestCase {\n+    /**\n+     * \n+     */\n+    public void testPutTransformer(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        \n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertEquals(expected, map.getTransformer(TransformerMapTest.class));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testContainsClass(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertTrue(map.containsClass(TransformerMapTest.class));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testContainsTransformer(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertTrue(map.containsTransformer(expected));\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void testRemoveTransformer(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        \n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertTrue(map.containsClass(TransformerMapTest.class));\n+        assertTrue(map.containsTransformer(expected));\n+        map.removeTransformer(TransformerMapTest.class);\n+        assertFalse(map.containsClass(TransformerMapTest.class));\n+        assertFalse(map.containsTransformer(expected));\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void testClear(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        \n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertTrue(map.containsClass(TransformerMapTest.class));\n+        map.clear();\n+        assertFalse(map.containsClass(TransformerMapTest.class));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testClasses(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertTrue(map.classes().contains(TransformerMapTest.class));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testTransformers(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertTrue(map.transformers().contains(expected));\n+    }\n+\n+    public void testSerial(){\n+        NumberTransformer expected = new DefaultTransformer();\n+        TransformerMap map = new TransformerMap();\n+        map.putTransformer(TransformerMapTest.class, expected);\n+        assertEquals(map, TestUtils.serializeAndRecover(map));\n+    }\n+\n+}", "timestamp": 1249137848, "metainfo": ""}