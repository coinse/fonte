{"sha": "1f89e226f2b7dc9b3b498d63c5a5bd5bc23a46b6", "log": "wrap lines *after* operator, to keep checkstyle happy  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator\n     { \"minimal step size ({0}) reached, integration needs {1}\",\n       \"pas minimal ({0}) atteint, l''int\\u00e9gration n\\u00e9cessite {1}\" },\n-    { \"dimensions mismatch: state vector has dimension {0},\"\n-    + \" absolute tolerance vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\"\n-    + \" et le vecteur de tol\\u00e9rance absolue ({1})\" },\n-    { \"dimensions mismatch: state vector has dimension {0},\"\n-    + \" relative tolerance vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\"\n-    + \" et le vecteur de tol\\u00e9rance relative ({1})\" },\n+    { \"dimensions mismatch: state vector has dimension {0},\" +\n+      \" absolute tolerance vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n+      \" et le vecteur de tol\\u00e9rance absolue ({1})\" },\n+    { \"dimensions mismatch: state vector has dimension {0},\" +\n+      \" relative tolerance vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n+      \" et le vecteur de tol\\u00e9rance relative ({1})\" },\n \n     // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator,\n     // org.apache.commons.math.ode.RungeKuttaIntegrator\n-    { \"dimensions mismatch: ODE problem has dimension {0},\"\n-    + \" initial state vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\"\n-    + \" et le vecteur d''\\u00e9tat initial ({1})\" },\n-    { \"dimensions mismatch: ODE problem has dimension {0},\"\n-    + \" final state vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\"\n-    + \" et le vecteur d''\\u00e9tat final ({1})\" },\n+    { \"dimensions mismatch: ODE problem has dimension {0},\" +\n+      \" initial state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n+      \" et le vecteur d''\\u00e9tat initial ({1})\" },\n+    { \"dimensions mismatch: ODE problem has dimension {0},\" +\n+      \" final state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n+      \" et le vecteur d''\\u00e9tat final ({1})\" },\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         if (((initial - min) * (max -initial)) < 0) {\n-            throw new IllegalArgumentException(\"Initial guess is not in search\"\n-                    + \" interval.\" + \"  Initial: \" + initial\n-                    +  \"  Endpoints: [\" + min + \",\" + max + \"]\");\n+            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n+                      \" interval.\" + \"  Initial: \" + initial +\n+                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n         }\n \n         // return the initial guess if it is good enough\n--- a/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n         if (x < 0) {\n             ret = 0.0;\n         } else {\n-            ret = MathUtils.binomialCoefficientDouble(x\n-                + getNumberOfSuccesses() - 1, getNumberOfSuccesses() - 1)\n-                * Math.pow(getProbabilityOfSuccess(), getNumberOfSuccesses())\n-                * Math.pow(1.0 - getProbabilityOfSuccess(), x);\n+            ret = MathUtils.binomialCoefficientDouble(x +\n+                  getNumberOfSuccesses() - 1, getNumberOfSuccesses() - 1) *\n+                  Math.pow(getProbabilityOfSuccess(), getNumberOfSuccesses()) *\n+                  Math.pow(1.0 - getProbabilityOfSuccess(), x);\n         }\n         return ret;\n     }\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n             previous = cost;\n             updateResidualsAndCost();\n \n-        } while ((getCostEvaluations() < 2)\n-                || (Math.abs(previous - cost) > (cost * steadyStateThreshold)\n-                        && (Math.abs(cost) > convergence)));\n+        } while ((getCostEvaluations() < 2) ||\n+                 (Math.abs(previous - cost) > (cost * steadyStateThreshold) &&\n+                  (Math.abs(cost) > convergence)));\n \n     }\n \n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n         xNorm = Math.sqrt(xNorm);\n         \n         // initialize the step bound delta\n-        delta = (xNorm == 0)\n-              ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n+        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n  \n       }\n \n         }\n    \n         // tests for convergence.\n-        if (((Math.abs(actRed) <= costRelativeTolerance)\n-            && (preRed <= costRelativeTolerance)\n-            && (ratio <= 2.0))\n-            || (delta <= parRelativeTolerance * xNorm)) {\n+        if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+             (preRed <= costRelativeTolerance) &&\n+             (ratio <= 2.0)) ||\n+             (delta <= parRelativeTolerance * xNorm)) {\n           return;\n         }\n \n         // tests for termination and stringent tolerances\n         // (2.2204e-16 is the machine epsilon for IEEE754)\n-        if ((Math.abs(actRed) <= 2.2204e-16)\n-            && (preRed <= 2.2204e-16)\n-            && (ratio <= 2.0)) {\n-          throw new EstimationException(\"cost relative tolerance is too small ({0}),\"\n-                                      + \" no further reduction in the\"\n-                                      + \" sum of squares is possible\",\n+        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n+          throw new EstimationException(\"cost relative tolerance is too small ({0}),\" +\n+                                        \" no further reduction in the\" +\n+                                        \" sum of squares is possible\",\n                                         new Object[] { new Double(costRelativeTolerance) });\n         } else if (delta <= 2.2204e-16 * xNorm) {\n-          throw new EstimationException(\"parameters relative tolerance is too small\"\n-                                      + \" ({0}), no further improvement in\"\n-                                      + \" the approximate solution is possible\",\n+          throw new EstimationException(\"parameters relative tolerance is too small\" +\n+                                        \" ({0}), no further improvement in\" +\n+                                        \" the approximate solution is possible\",\n                                         new Object[] { new Double(parRelativeTolerance) });\n         } else if (maxCosine <= 2.2204e-16)  {\n-          throw new EstimationException(\"orthogonality tolerance is too small ({0}),\"\n-                                      + \" solution is orthogonal to the jacobian\",\n+          throw new EstimationException(\"orthogonality tolerance is too small ({0}),\" +\n+                                        \" solution is orthogonal to the jacobian\",\n                                         new Object[] { new Double(orthoTolerance) });\n         }\n \n \n       // if the function is small enough, accept the current value\n       // of lmPar, also test for the exceptional cases where parl is zero\n-      if ((Math.abs(fp) <= 0.1 * delta)\n-          || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n+      if ((Math.abs(fp) <= 0.1 * delta) ||\n+          ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n         return;\n       }\n  \n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n     throws NotARotationMatrixException {\n \n     // dimension check\n-    if ((m.length != 3) || (m[0].length != 3)\n-        || (m[1].length != 3) || (m[2].length != 3)) {\n-      throw new NotARotationMatrixException(\"a {0}x{1} matrix\"\n-                                            + \" cannot be a rotation matrix\",\n+    if ((m.length != 3) || (m[0].length != 3) ||\n+        (m[1].length != 3) || (m[2].length != 3)) {\n+      throw new NotARotationMatrixException(\"a {0}x{1} matrix\" +\n+                                            \" cannot be a rotation matrix\",\n                                             new String[] {\n                                               Integer.toString(m.length),\n                                               Integer.toString(m[0].length)\n     double[][] ort = orthogonalizeMatrix(m, threshold);\n \n     // check the sign of the determinant\n-    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2])\n-               - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2])\n-               + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n+    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n+                 ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n+                 ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n     if (det < 0.0) {\n-      throw new NotARotationMatrixException(\"the closest orthogonal matrix\"\n-                                            + \" has a negative determinant {0}\",\n+      throw new NotARotationMatrixException(\"the closest orthogonal matrix\" +\n+                                            \" has a negative determinant {0}\",\n                                             new String[] {\n                                               Double.toString(det)\n                                             });\n   Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n                             dz1 * dx2 - dx1 * dz2,\n                             dx1 * dy2 - dy1 * dx2);\n-  double c = k.getX() * (u1y * u2z - u1z * u2y)\n-           + k.getY() * (u1z * u2x - u1x * u2z)\n-           + k.getZ() * (u1x * u2y - u1y * u2x);\n+  double c = k.getX() * (u1y * u2z - u1z * u2y) +\n+             k.getY() * (u1z * u2x - u1x * u2z) +\n+             k.getZ() * (u1x * u2y - u1y * u2x);\n \n   if (c == 0) {\n     // the (q1, q2, q3) vector is in the (u1, u2) plane\n     k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n                      dz1 * dx3 - dx1 * dz3,\n                      dx1 * dy3 - dy1 * dx3);\n-    c = k.getX() * (u1y * u3z - u1z * u3y)\n-      + k.getY() * (u1z * u3x - u1x * u3z)\n-      + k.getZ() * (u1x * u3y - u1y * u3x);\n+    c = k.getX() * (u1y * u3z - u1z * u3y) +\n+        k.getY() * (u1z * u3x - u1x * u3z) +\n+        k.getZ() * (u1x * u3y - u1y * u3x);\n \n     if (c == 0) {\n       // the (q1, q2, q3) vector is aligned with u1:\n       k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n                        dz2 * dx3 - dx2 * dz3,\n                        dx2 * dy3 - dy2 * dx3);\n-      c = k.getX() * (u2y * u3z - u2z * u3y)\n-        + k.getY() * (u2z * u3x - u2x * u3z)\n-        + k.getZ() * (u2x * u3y - u2y * u3x);\n+      c = k.getX() * (u2y * u3z - u2z * u3y) +\n+          k.getY() * (u2z * u3x - u2x * u3z) +\n+          k.getZ() * (u2x * u3y - u2y * u3x);\n \n       if (c == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n       double corr22 = o2[2] - m2[2];\n \n       // Frobenius norm of the correction\n-      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02\n-          + corr10 * corr10 + corr11 * corr11 + corr12 * corr12\n-          + corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n+            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n+            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n \n       // convergence test\n       if (Math.abs(fn1 - fn) <= threshold)\n     }\n \n     // the algorithm did not converge after 10 iterations\n-    throw new NotARotationMatrixException(\"unable to orthogonalize matrix\"\n-                                          + \" in {0} iterations\",\n+    throw new NotARotationMatrixException(\"unable to orthogonalize matrix\" +\n+                                          \" in {0} iterations\",\n                                           new String[] {\n                                             Integer.toString(i - 1)\n                                           });\n--- a/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n     double coeff4    = s * ((-fourTheta - 1) * theta - 1);\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                            + coeff1  * yDotK[0][i]\n-                            + coeff23 * (yDotK[1][i] + yDotK[2][i])\n-                            + coeff4  * yDotK[3][i];\n+      interpolatedState[i] = currentState[i] +\n+                             coeff1  * yDotK[0][i] +\n+                             coeff23 * (yDotK[1][i] + yDotK[2][i]) +\n+                             coeff4  * yDotK[3][i];\n      }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n           double dt1 = time - tMax;\n           double dt2 = time - tMed;\n           double dt3 = time - tMin;\n-          double iLagrange = (  (dt2 * dt3 * d23) * iMax\n-                              - (dt1 * dt3 * d13) * iMed\n-                              + (dt1 * dt2 * d12) * iMin)\n-                           / (d12 * d23 * d13);\n+          double iLagrange = ((dt2 * dt3 * d23) * iMax -\n+                              (dt1 * dt3 * d13) * iMed +\n+                              (dt1 * dt2 * d12) * iMin) /\n+                             (d12 * d23 * d13);\n           index = (int) Math.rint(iLagrange);\n         }\n \n \n       // now the table slice is very small, we perform an iterative search\n       index = iMin;\n-      while ((index <= iMax)\n-             && (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {\n+      while ((index <= iMax) &&\n+             (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {\n         ++index;\n       }\n \n       si.setInterpolatedTime(time);\n \n     } catch (DerivativeException de) {\n-      throw new RuntimeException(\"unexpected DerivativeException caught: \"\n-                                 + de.getMessage());\n+      throw new RuntimeException(\"unexpected DerivativeException caught: \" +\n+                                 de.getMessage());\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n     double error = 0;\n \n     for (int j = 0; j < y0.length; ++j) {\n-      double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j]\n-                    + e4 * yDotK[3][j] +  e5 * yDotK[4][j]\n-                    + e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+      double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +\n+                      e4 * yDotK[3][j] +  e5 * yDotK[4][j] +\n+                      e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n \n       double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n-      double tol = (vecAbsoluteTolerance == null)\n-        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n-        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double tol = (vecAbsoluteTolerance == null) ?\n+                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                   (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n       double ratio  = h * errSum / tol;\n       error += ratio * ratio;\n \n--- a/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n \n       // we need to compute the interpolation vectors for this time step\n       for (int i = 0; i < interpolatedState.length; ++i) {\n-        v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i]\n-                     + a74 * yDotK[4][i] + a75 * yDotK[5][i]);\n+        v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i] +\n+                     a74 * yDotK[4][i] + a75 * yDotK[5][i]);\n         v2[i] = h * yDotK[0][i] - v1[i];\n         v3[i] = v1[i] - v2[i] - h * yDotK[6][i];\n-        v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i]\n-                     + d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);\n+        v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i] +\n+                     d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);\n       }\n \n       vectorsInitialized = true;\n     // interpolate\n     double eta = oneMinusThetaH / h;\n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                           - eta * (v1[i]\n-                                    - theta * (v2[i]\n-                                               + theta * (v3[i]\n-                                                          + eta * v4[i])));\n+      interpolatedState[i] = currentState[i] -\n+          eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n     double error2 = 0;\n \n     for (int j = 0; j < y0.length; ++j) {\n-      double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j]\n-                     + e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j]\n-                     + e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j]\n-                     + e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n-      double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j]\n-                     + e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j]\n-                     + e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j]\n-                     + e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+      double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +\n+                       e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +\n+                       e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +\n+                       e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n+      double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +\n+                       e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +\n+                       e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +\n+                       e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n \n       double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n-      double tol = (vecAbsoluteTolerance == null)\n-        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n-        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double tol = (vecAbsoluteTolerance == null) ?\n+                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                   (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n       double ratio1  = errSum1 / tol;\n       error1        += ratio1 * ratio1;\n       double ratio2  = errSum2 / tol;\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n \n       // compute the interpolation vectors for this time step\n       for (int i = 0; i < interpolatedState.length; ++i) {\n-        v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i]\n-                     + b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i]\n-                     + b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);\n+        v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i] +\n+                       b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i] +\n+                       b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);\n         v[1][i] = h * yDotK[0][i] - v[0][i];\n         v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];\n         for (int k = 0; k < d.length; ++k) {\n-          v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i]\n-                         + d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i]\n-                         + d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i]\n-                         + d[k][9]  * yDotKLast[0][i]\n-                         + d[k][10] * yDotKLast[1][i]\n-                         + d[k][11] * yDotKLast[2][i]);\n+          v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i] +\n+                           d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i] +\n+                           d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i] +\n+                           d[k][9]  * yDotKLast[0][i] +\n+                           d[k][10] * yDotKLast[1][i] +\n+                           d[k][11] * yDotKLast[2][i]);\n         }\n       }\n \n     double eta = oneMinusThetaH / h;\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                           -   eta * (v[0][i]\n-                           - theta * (v[1][i]\n-                           + theta * (v[2][i]\n-                           +   eta * (v[3][i]\n-                           + theta * (v[4][i]\n-                           +   eta * (v[5][i]\n-                           + theta * (v[6][i])))))));\n+      interpolatedState[i] =\n+          currentState[i] - eta * (v[0][i] - theta * (v[1][i] +\n+                  theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] +\n+                          eta * (v[5][i] + theta * (v[6][i])))))));\n     }\n \n   }\n \n     // k14\n     for (int j = 0; j < currentState.length; ++j) {\n-      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j]\n-        + k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j]\n-        + k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j] +\n+          k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j] +\n+          k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n     equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n \n     // k15\n     for (int j = 0; j < currentState.length; ++j) {\n-     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j]\n-       + k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j]\n-       + k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j]\n-       + k15_14 * yDotKLast[0][j];\n+     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j] +\n+         k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j] +\n+         k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j] +\n+         k15_14 * yDotKLast[0][j];\n      yTmp[j] = currentState[j] + h * s;\n     }\n     equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n \n     // k16\n     for (int j = 0; j < currentState.length; ++j) {\n-      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j]\n-        + k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j]\n-        + k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j]\n-        + k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j] +\n+          k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j] +\n+          k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j] +\n+          k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n     equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n--- a/src/java/org/apache/commons/math/ode/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/EmbeddedRungeKuttaIntegrator.java\n         stepSize = hNew;\n \n         // step adjustment near bounds\n-        if ((forward && (stepStart + stepSize > t))\n-            || ((! forward) && (stepStart + stepSize < t))) {\n+        if ((forward && (stepStart + stepSize > t)) ||\n+            ((! forward) && (stepStart + stepSize < t))) {\n           stepSize = t - stepStart;\n         }\n \n--- a/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n     double coeff4    = s * (1 + theta * (1 + fourTheta));\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                            - coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]\n-                            - coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+      interpolatedState[i] = currentState[i] -\n+                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -\n+                             coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n      }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n                                       double scalAbsoluteTolerance,\n                                       double scalRelativeTolerance) {\n     super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n-    denseOutput = (handler.requiresDenseOutput()\n-                   || (! switchesHandler.isEmpty()));\n+    denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n                                       double[] vecAbsoluteTolerance,\n                                       double[] vecRelativeTolerance) {\n     super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n-    denseOutput = (handler.requiresDenseOutput()\n-                   || (! switchesHandler.isEmpty()));\n+    denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n   public void setStepHandler (StepHandler handler) {\n \n     super.setStepHandler(handler);\n-    denseOutput = (handler.requiresDenseOutput()\n-                   || (! switchesHandler.isEmpty()));\n+    denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));\n \n     // reinitialize the arrays\n     initializeArrays();\n                                    double convergence,\n                                    int maxIterationCount) {\n     super.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);\n-    denseOutput = (handler.requiresDenseOutput()\n-                   || (! switchesHandler.isEmpty()));\n+    denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));\n \n     // reinitialize the arrays\n     initializeArrays();\n     for (int j = 1; j < k; ++j) {\n       for (int i = 0; i < last.length; ++i) {\n         // Aitken-Neville's recursive formula\n-        diag[k-j-1][i] = diag[k-j][i]\n-                       + coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n+        diag[k-j-1][i] = diag[k-j][i] +\n+                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n       }\n     }\n \n     rescale(y, y, scale);\n \n     // initial order selection\n-    double log10R = Math.log(Math.max(1.0e-10,\n-                                      (vecRelativeTolerance == null)\n-                                      ? scalRelativeTolerance\n-                                      : vecRelativeTolerance[0]))\n-                  / Math.log(10.0);\n+    double tol =\n+        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n+    double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);\n     int targetIter = Math.max(1,\n                               Math.min(sequence.length - 2,\n                                        (int) Math.floor(0.5 - 0.6 * log10R)));\n       stepSize = hNew;\n \n       // step adjustment near bounds\n-      if ((forward && (stepStart + stepSize > t))\n-          || ((! forward) && (stepStart + stepSize < t))) {\n+      if ((forward && (stepStart + stepSize > t)) ||\n+          ((! forward) && (stepStart + stepSize < t))) {\n         stepSize = t - stepStart;\n       }\n       double nextT = stepStart + stepSize;\n                     // estimate if there is a chance convergence will\n                     // be reached on next iteration, using the\n                     // asymptotic evolution of error\n-                    double ratio = ((double) sequence [k] * sequence[k+1])\n-                                 / (sequence[0] * sequence[0]);\n+                    double ratio = ((double) sequence [k] * sequence[k+1]) /\n+                                   (sequence[0] * sequence[0]);\n                     if (error > ratio * ratio) {\n                       // we don't expect to converge on next iteration\n                       // we reject the step immediately and reduce order\n                       reject = true;\n                       loop   = false;\n                       targetIter = k;\n-                      if ((targetIter > 1)\n-                          && (costPerTimeUnit[targetIter-1]\n-                              < orderControl1 * costPerTimeUnit[targetIter])) {\n+                      if ((targetIter > 1) &&\n+                          (costPerTimeUnit[targetIter-1] <\n+                           orderControl1 * costPerTimeUnit[targetIter])) {\n                         --targetIter;\n                       }\n                       hNew = optimalStep[targetIter];\n                     // we reject the step immediately\n                     reject = true;\n                     loop = false;\n-                    if ((targetIter > 1)\n-                        && (costPerTimeUnit[targetIter-1]\n-                            < orderControl1 * costPerTimeUnit[targetIter])) {\n+                    if ((targetIter > 1) &&\n+                        (costPerTimeUnit[targetIter-1] <\n+                         orderControl1 * costPerTimeUnit[targetIter])) {\n                       --targetIter;\n                     }\n                     hNew = optimalStep[targetIter];\n               case 1 :\n                 if (error > 1.0) {\n                   reject = true;\n-                  if ((targetIter > 1)\n-                      && (costPerTimeUnit[targetIter-1]\n-                          < orderControl1 * costPerTimeUnit[targetIter])) {\n+                  if ((targetIter > 1) &&\n+                      (costPerTimeUnit[targetIter-1] <\n+                       orderControl1 * costPerTimeUnit[targetIter])) {\n                     --targetIter;\n                   }\n                   hNew = optimalStep[targetIter];\n           }\n         } else {\n           optimalIter = k - 1;\n-          if ((k > 2)\n-              && (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n+          if ((k > 2) &&\n+              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n             optimalIter = k - 2;\n           }\n           if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n           if (optimalIter <= k) {\n             hNew = optimalStep[optimalIter];\n           } else {\n-            if ((k < targetIter)\n-                && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n-              hNew = filterStep(optimalStep[k]\n-                                * costPerStep[optimalIter+1] / costPerStep[k],\n+            if ((k < targetIter) &&\n+                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n+              hNew = filterStep(optimalStep[k] *\n+                                costPerStep[optimalIter+1] / costPerStep[k],\n                                 false);\n             } else {\n-              hNew = filterStep(optimalStep[k]\n-                                * costPerStep[optimalIter] / costPerStep[k],\n+              hNew = filterStep(optimalStep[k] *\n+                                costPerStep[optimalIter] / costPerStep[k],\n                                 false);\n             }\n           }\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n             for (int j = 4; j <= mu; ++j) {\n               double fac1 = 0.5 * j * (j - 1);\n               double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n-              polynoms[j+4][i] = 16 * (yMidDots[j][i]\n-                                       + fac1 * polynoms[j+2][i]\n-                                       - fac2 * polynoms[j][i]);\n+              polynoms[j+4][i] =\n+                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);\n             }\n \n           }\n     t4 = t4 * t4;\n \n     for (int i = 0; i < dimension; ++i) {\n-      interpolatedState[i] = polynoms[0][i]\n-        + theta * (polynoms[1][i]\n-                   + oneMinusTheta * (polynoms[2][i] * theta\n-                                      + polynoms[3][i] * oneMinusTheta));\n+      interpolatedState[i] = polynoms[0][i] +\n+        theta * (polynoms[1][i] +\n+                 oneMinusTheta * (polynoms[2][i] * theta +\n+                                  polynoms[3][i] * oneMinusTheta));\n \n       if (currentDegree > 3) {\n         double c = polynoms[currentDegree][i];\n--- a/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n       }\n \n       double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n-      double tol = (vecAbsoluteTolerance == null)\n-        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n-        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double tol = (vecAbsoluteTolerance == null) ?\n+                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                   (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n       double ratio  = h * errSum / tol;\n       error += ratio * ratio;\n \n--- a/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n     double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                           + b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i]\n-                           + b4 * yDotK[4][i] + b5 * yDotK[5][i];\n+      interpolatedState[i] = currentState[i] +\n+                             b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i] +\n+                             b4 * yDotK[4][i] + b5 * yDotK[5][i];\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n     double coeff2 = oneMinusThetaH * (1.0 + theta);\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                           + coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];\n+      interpolatedState[i] = currentState[i] +\n+                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/SwitchState.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchState.java\n     pendingEvent      = false;\n     pendingEventTime  = Double.NaN;\n \n-    return (nextAction == SwitchingFunction.RESET_STATE)\n-        || (nextAction == SwitchingFunction.RESET_DERIVATIVES);\n+    return (nextAction == SwitchingFunction.RESET_STATE) ||\n+           (nextAction == SwitchingFunction.RESET_DERIVATIVES);\n \n   }\n \n--- a/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n     double coeff4     = s * (1 + theta + fourTheta2);\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i]\n-                            - coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]\n-                            - coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+      interpolatedState[i] = currentState[i] -\n+                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -\n+                             coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n      }\n \n   }\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n \n         // return the found point given the lowest cost\n         if (minima[0] == null) {\n-            throw new ConvergenceException(\"none of the {0} start points\"\n-                    + \" lead to convergence\",\n-                    new String[] {\n-                            Integer.toString(starts)\n-                    });\n+            throw new ConvergenceException(\"none of the {0} start points\" +\n+                                           \" lead to convergence\",\n+                                           new Object[] {\n+                                             Integer.toString(starts)\n+                                           });\n         }\n         return minima[0];\n ", "timestamp": 1200846954, "metainfo": ""}