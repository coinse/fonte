{"sha": "5a8be77a303c9e2f8c19d029e8628d7697fb581d", "log": "MATH-707 Renamed \"RealPointValuePair\" to \"PointValuePair\" and made it a subclass of \"Pair<double[], Double>\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateMultiStartOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateMultiStartOptimizer.java\n     /** Random generator for multi-start. */\n     private RandomVectorGenerator generator;\n     /** Found optima. */\n-    private RealPointValuePair[] optima;\n+    private PointValuePair[] optima;\n \n     /**\n      * Create a multi-start optimizer from a single-start optimizer.\n      * #optimize(int,MultivariateFunction,GoalType,double[]) optimize}\n      * has not been called.\n      */\n-    public RealPointValuePair[] getOptima() {\n+    public PointValuePair[] getOptima() {\n         if (optima == null) {\n             throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n+    public ConvergenceChecker<PointValuePair> getConvergenceChecker() {\n         return optimizer.getConvergenceChecker();\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public RealPointValuePair optimize(int maxEval, final FUNC f,\n+    public PointValuePair optimize(int maxEval, final FUNC f,\n                                        final GoalType goal,\n                                        double[] startPoint) {\n         maxEvaluations = maxEval;\n         RuntimeException lastException = null;\n-        optima = new RealPointValuePair[starts];\n+        optima = new PointValuePair[starts];\n         totalEvaluations = 0;\n \n         // Multi-start loop.\n      * @param goal Goal type.\n      */\n     private void sortPairs(final GoalType goal) {\n-        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n-                public int compare(final RealPointValuePair o1,\n-                                   final RealPointValuePair o2) {\n+        Arrays.sort(optima, new Comparator<PointValuePair>() {\n+                public int compare(final PointValuePair o1,\n+                                   final PointValuePair o2) {\n                     if (o1 == null) {\n                         return (o2 == null) ? 0 : 1;\n                     } else if (o2 == null) {\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateOptimizer.java\n  * @since 3.0\n  */\n public interface BaseMultivariateOptimizer<FUNC extends MultivariateFunction>\n-    extends BaseOptimizer<RealPointValuePair> {\n+    extends BaseOptimizer<PointValuePair> {\n     /**\n      * Optimize an objective function.\n      *\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n      */\n-    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                 double[] startPoint);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateSimpleBoundsOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateSimpleBoundsOptimizer.java\n      * @throws org.apache.commons.math.exception.NumberIsTooLargeException if any\n      * of the initial values is greater than its upper bound.\n      */\n-    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                 double[] startPoint,\n                                 double[] lowerBound, double[] upperBound);\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/PointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.Pair;\n+\n+/**\n+ * This class holds a point and the value of an objective function at\n+ * that point.\n+ *\n+ * @see org.apache.commons.math.analysis.MultivariateFunction\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class PointValuePair extends Pair<double[], Double> {\n+    /**\n+     * Builds a point/objective function value pair.\n+     *\n+     * @param point Point coordinates (this instance will store\n+     * a copy of the array, not the array passed as argument).\n+     * @param value Value of the objective function at the point.\n+     */\n+    public PointValuePair(final double[] point,\n+                          final double value) {\n+        this(point, value, true);\n+    }\n+\n+    /**\n+     * Builds a point/objective function value pair.\n+     *\n+     * @param point Point coordinates.\n+     * @param value Value of the objective function at the point.\n+     * @param copyArray if {@code true}, the input array will be copied,\n+     * otherwise it will be referenced.\n+     */\n+    public PointValuePair(final double[] point,\n+                          final double value,\n+                          final boolean copyArray) {\n+        super(copyArray ? ((point == null) ? null :\n+                           point.clone()) :\n+              point,\n+              value);\n+    }\n+\n+    /**\n+     * Gets the point.\n+     *\n+     * @return a copy of the stored point.\n+     */\n+    public double[] getPoint() {\n+        return getKey().clone();\n+    }\n+\n+    /**\n+     * Gets a reference to the point.\n+     *\n+     * @return a reference to the internal array storing the point.\n+     */\n+    public double[] getPointRef() {\n+        return getKey();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n  * @since 3.0\n  */\n public class SimpleRealPointChecker\n-    extends AbstractConvergenceChecker<RealPointValuePair> {\n+    extends AbstractConvergenceChecker<PointValuePair> {\n     /**\n      * Build an instance with default threshold.\n      */\n      */\n     @Override\n     public boolean converged(final int iteration,\n-                             final RealPointValuePair previous,\n-                             final RealPointValuePair current) {\n+                             final PointValuePair previous,\n+                             final PointValuePair current) {\n         final double[] p = previous.getPoint();\n         final double[] c = current.getPoint();\n         for (int i = 0; i < p.length; ++i) {\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n  * @since 3.0\n  */\n public class SimpleScalarValueChecker\n-    extends AbstractConvergenceChecker<RealPointValuePair> {\n+    extends AbstractConvergenceChecker<PointValuePair> {\n     /**\n      * Build an instance with default thresholds.\n      */\n      */\n     @Override\n     public boolean converged(final int iteration,\n-                             final RealPointValuePair previous,\n-                             final RealPointValuePair current) {\n+                             final PointValuePair previous,\n+                             final PointValuePair current) {\n         final double p = previous.getValue();\n         final double c = current.getValue();\n         final double difference = FastMath.abs(p - c);\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n /**\n  * This class holds a point and the vectorial value of an objective function at this point.\n  * <p>This is a simple immutable container.</p>\n- * @see RealPointValuePair\n+ * @see PointValuePair\n  * @see org.apache.commons.math.analysis.MultivariateVectorFunction\n  * @version $Id$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n \n /**\n  * This class implements the simplex concept.\n  */\n public abstract class AbstractSimplex {\n     /** Simplex. */\n-    private RealPointValuePair[] simplex;\n+    private PointValuePair[] simplex;\n     /** Start simplex configuration. */\n     private double[][] startConfiguration;\n     /** Simplex dimension (must be equal to {@code simplex.length - 1}). */\n      * if the algorithm fails to converge.\n      */\n     public abstract void iterate(final MultivariateFunction evaluationFunction,\n-                                 final Comparator<RealPointValuePair> comparator);\n+                                 final Comparator<PointValuePair> comparator);\n \n     /**\n      * Build an initial simplex.\n         }\n \n         // Set first vertex.\n-        simplex = new RealPointValuePair[dimension + 1];\n-        simplex[0] = new RealPointValuePair(startPoint, Double.NaN);\n+        simplex = new PointValuePair[dimension + 1];\n+        simplex[0] = new PointValuePair(startPoint, Double.NaN);\n \n         // Set remaining vertices.\n         for (int i = 0; i < dimension; i++) {\n             for (int k = 0; k < dimension; k++) {\n                 vertexI[k] = startPoint[k] + confI[k];\n             }\n-            simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);\n+            simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n         }\n     }\n \n      * if the maximal number of evaluations is exceeded.\n      */\n     public void evaluate(final MultivariateFunction evaluationFunction,\n-                         final Comparator<RealPointValuePair> comparator) {\n+                         final Comparator<PointValuePair> comparator) {\n         // Evaluate the objective function at all non-evaluated simplex points.\n         for (int i = 0; i < simplex.length; i++) {\n-            final RealPointValuePair vertex = simplex[i];\n+            final PointValuePair vertex = simplex[i];\n             final double[] point = vertex.getPointRef();\n             if (Double.isNaN(vertex.getValue())) {\n-                simplex[i] = new RealPointValuePair(point, evaluationFunction.value(point), false);\n+                simplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\n             }\n         }\n \n      * @param comparator Comparator to use for sorting the simplex vertices\n      * from best to worst.\n      */\n-    protected void replaceWorstPoint(RealPointValuePair pointValuePair,\n-                                     final Comparator<RealPointValuePair> comparator) {\n+    protected void replaceWorstPoint(PointValuePair pointValuePair,\n+                                     final Comparator<PointValuePair> comparator) {\n         for (int i = 0; i < dimension; i++) {\n             if (comparator.compare(simplex[i], pointValuePair) > 0) {\n-                RealPointValuePair tmp = simplex[i];\n+                PointValuePair tmp = simplex[i];\n                 simplex[i] = pointValuePair;\n                 pointValuePair = tmp;\n             }\n      *\n      * @return all the simplex points.\n      */\n-    public RealPointValuePair[] getPoints() {\n-        final RealPointValuePair[] copy = new RealPointValuePair[simplex.length];\n+    public PointValuePair[] getPoints() {\n+        final PointValuePair[] copy = new PointValuePair[simplex.length];\n         System.arraycopy(simplex, 0, copy, 0, simplex.length);\n         return copy;\n     }\n      * @param index Location.\n      * @return the point at location {@code index}.\n      */\n-    public RealPointValuePair getPoint(int index) {\n+    public PointValuePair getPoint(int index) {\n         if (index < 0 ||\n             index >= simplex.length) {\n             throw new OutOfRangeException(index, 0, simplex.length - 1);\n      * @param index Location.\n      * @param point New value.\n      */\n-    protected void setPoint(int index, RealPointValuePair point) {\n+    protected void setPoint(int index, PointValuePair point) {\n         if (index < 0 ||\n             index >= simplex.length) {\n             throw new OutOfRangeException(index, 0, simplex.length - 1);\n      *\n      * @param points New Points.\n      */\n-    protected void setPoints(RealPointValuePair[] points) {\n+    protected void setPoints(PointValuePair[] points) {\n         if (points.length != simplex.length) {\n             throw new DimensionMismatchException(points.length, simplex.length);\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n \n /**\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected PointValuePair doOptimize() {\n         final double[] lowerBound = getLowerBound();\n         final double[] upperBound = getUpperBound();\n \n \n         final double value = bobyqa(lowerBound, upperBound);\n \n-        return new RealPointValuePair(currentBest.getDataRef(),\n+        return new PointValuePair(currentBest.getDataRef(),\n                                       isMinimize ? value : -value);\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateOptimizer.java\n import org.apache.commons.math.optimization.BaseMultivariateOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n /**\n     /** Evaluations counter. */\n     protected final Incrementor evaluations = new Incrementor();\n     /** Convergence checker. */\n-    private ConvergenceChecker<RealPointValuePair> checker;\n+    private ConvergenceChecker<PointValuePair> checker;\n     /** Type of optimization. */\n     private GoalType goal;\n     /** Initial guess. */\n     /**\n      * @param checker Convergence checker.\n      */\n-    protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n+    protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n         this.checker = checker;\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n+    public ConvergenceChecker<PointValuePair> getConvergenceChecker() {\n         return checker;\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                        double[] startPoint) {\n         // Checks.\n         if (f == null) {\n      * @return the point/value pair giving the optimal value for the\n      * objective function.\n      */\n-    protected abstract RealPointValuePair doOptimize();\n+    protected abstract PointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n import org.apache.commons.math.optimization.BaseMultivariateOptimizer;\n import org.apache.commons.math.optimization.BaseMultivariateSimpleBoundsOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n     /**\n      * @param checker Convergence checker.\n      */\n-    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n+    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\n         super(checker);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                        double[] startPoint) {\n         return optimize(maxEval, f, goalType, startPoint, null, null);\n     }\n \n     /** {@inheritDoc} */\n-    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                        double[] startPoint,\n                                        double[] lower, double[] upper) {\n         // Checks.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n import org.apache.commons.math.random.MersenneTwister;\n import org.apache.commons.math.random.RandomGenerator;\n                           double[][] boundaries, int maxIterations, double stopFitness,\n                           boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                           RandomGenerator random, boolean generateStatistics,\n-                          ConvergenceChecker<RealPointValuePair> checker) {\n+                          ConvergenceChecker<PointValuePair> checker) {\n         super(checker);\n         this.lambda = lambda;\n         this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected PointValuePair doOptimize() {\n         checkParameters();\n          // -------------------- Initialization --------------------------------\n         isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n         iterations = 0;\n         double bestValue = fitfun.value(guess);\n         push(fitnessHistory, bestValue);\n-        RealPointValuePair optimum = new RealPointValuePair(getStartPoint(),\n+        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                 isMinimize ? bestValue : -bestValue);\n-        RealPointValuePair lastResult = null;\n+        PointValuePair lastResult = null;\n \n         // -------------------- Generation Loop --------------------------------\n \n                 if (bestValue > bestFitness) {\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n-                    optimum = new RealPointValuePair(\n+                    optimum = new PointValuePair(\n                             fitfun.decode(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                 }\n                 // user defined termination\n                 if (getConvergenceChecker() != null) {\n-                    RealPointValuePair current =\n-                        new RealPointValuePair(bestArx.getColumn(0),\n+                    PointValuePair current =\n+                        new PointValuePair(bestArx.getColumn(0),\n                                 isMinimize ? bestFitness : -bestFitness);\n                     if (lastResult != null &&\n                         getConvergenceChecker().converged(iterations, current, lastResult)) {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateFunction;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n \n /**\n  * This class implements the multi-directional direct search method.\n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator) {\n+                        final Comparator<PointValuePair> comparator) {\n         // Save the original simplex.\n-        final RealPointValuePair[] original = getPoints();\n-        final RealPointValuePair best = original[0];\n+        final PointValuePair[] original = getPoints();\n+        final PointValuePair best = original[0];\n \n         // Perform a reflection step.\n-        final RealPointValuePair reflected = evaluateNewSimplex(evaluationFunction,\n+        final PointValuePair reflected = evaluateNewSimplex(evaluationFunction,\n                                                                 original, 1, comparator);\n         if (comparator.compare(reflected, best) < 0) {\n             // Compute the expanded simplex.\n-            final RealPointValuePair[] reflectedSimplex = getPoints();\n-            final RealPointValuePair expanded = evaluateNewSimplex(evaluationFunction,\n+            final PointValuePair[] reflectedSimplex = getPoints();\n+            final PointValuePair expanded = evaluateNewSimplex(evaluationFunction,\n                                                                    original, khi, comparator);\n             if (comparator.compare(reflected, expanded) <= 0) {\n                 // Keep the reflected simplex.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n-    private RealPointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\n-                                                  final RealPointValuePair[] original,\n+    private PointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\n+                                                  final PointValuePair[] original,\n                                                   final double coeff,\n-                                                  final Comparator<RealPointValuePair> comparator) {\n+                                                  final Comparator<PointValuePair> comparator) {\n         final double[] xSmallest = original[0].getPointRef();\n         // Perform a linear transformation on all the simplex points,\n         // except the first one.\n             for (int j = 0; j < dim; j++) {\n                 xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n             }\n-            setPoint(i, new RealPointValuePair(xTransformed, Double.NaN, false));\n+            setPoint(i, new PointValuePair(xTransformed, Double.NaN, false));\n         }\n \n         // Evaluate the simplex.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.analysis.MultivariateFunction;\n \n /**\n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator) {\n+                        final Comparator<PointValuePair> comparator) {\n         // The simplex has n + 1 points if dimension is n.\n         final int n = getDimension();\n \n         // Interesting values.\n-        final RealPointValuePair best = getPoint(0);\n-        final RealPointValuePair secondBest = getPoint(n - 1);\n-        final RealPointValuePair worst = getPoint(n);\n+        final PointValuePair best = getPoint(0);\n+        final PointValuePair secondBest = getPoint(n - 1);\n+        final PointValuePair worst = getPoint(n);\n         final double[] xWorst = worst.getPointRef();\n \n         // Compute the centroid of the best vertices (dismissing the worst\n         for (int j = 0; j < n; j++) {\n             xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n         }\n-        final RealPointValuePair reflected\n-            = new RealPointValuePair(xR, evaluationFunction.value(xR), false);\n+        final PointValuePair reflected\n+            = new PointValuePair(xR, evaluationFunction.value(xR), false);\n \n         if (comparator.compare(best, reflected) <= 0 &&\n             comparator.compare(reflected, secondBest) < 0) {\n             for (int j = 0; j < n; j++) {\n                 xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n             }\n-            final RealPointValuePair expanded\n-                = new RealPointValuePair(xE, evaluationFunction.value(xE), false);\n+            final PointValuePair expanded\n+                = new PointValuePair(xE, evaluationFunction.value(xE), false);\n \n             if (comparator.compare(expanded, reflected) < 0) {\n                 // Accept the expansion point.\n                 for (int j = 0; j < n; j++) {\n                     xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                 }\n-                final RealPointValuePair outContracted\n-                    = new RealPointValuePair(xC, evaluationFunction.value(xC), false);\n+                final PointValuePair outContracted\n+                    = new PointValuePair(xC, evaluationFunction.value(xC), false);\n                 if (comparator.compare(outContracted, reflected) <= 0) {\n                     // Accept the contraction point.\n                     replaceWorstPoint(outContracted, comparator);\n                 for (int j = 0; j < n; j++) {\n                     xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                 }\n-                final RealPointValuePair inContracted\n-                    = new RealPointValuePair(xC, evaluationFunction.value(xC), false);\n+                final PointValuePair inContracted\n+                    = new PointValuePair(xC, evaluationFunction.value(xC), false);\n \n                 if (comparator.compare(inContracted, worst) < 0) {\n                     // Accept the contraction point.\n                 for (int j = 0; j < n; j++) {\n                     x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n                 }\n-                setPoint(i, new RealPointValuePair(x, Double.NaN, false));\n+                setPoint(i, new PointValuePair(x, Double.NaN, false));\n             }\n             evaluate(evaluationFunction, comparator);\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n import org.apache.commons.math.optimization.univariate.BracketFinder;\n import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n-import org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair;\n+import org.apache.commons.math.optimization.univariate.UnivariatePointValuePair;\n \n /**\n  * Powell algorithm.\n      */\n     public PowellOptimizer(double rel,\n                            double abs,\n-                           ConvergenceChecker<RealPointValuePair> checker) {\n+                           ConvergenceChecker<PointValuePair> checker) {\n         super(checker);\n \n         if (rel < MIN_RELATIVE_TOLERANCE) {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected PointValuePair doOptimize() {\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n             direc[i][i] = 1;\n         }\n \n-        final ConvergenceChecker<RealPointValuePair> checker\n+        final ConvergenceChecker<PointValuePair> checker\n             = getConvergenceChecker();\n \n         double[] x = guess;\n \n                 fX2 = fVal;\n \n-                final UnivariateRealPointValuePair optimum = line.search(x, d);\n+                final UnivariatePointValuePair optimum = line.search(x, d);\n                 fVal = optimum.getValue();\n                 alphaMin = optimum.getPoint();\n                 final double[][] result = newPointAndDirection(x, d, alphaMin);\n                 (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                  absoluteThreshold);\n \n-            final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n-            final RealPointValuePair current = new RealPointValuePair(x, fVal);\n+            final PointValuePair previous = new PointValuePair(x1, fX);\n+            final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n                     stop = checker.converged(iter, previous, current);\n                 t -= delta * temp * temp;\n \n                 if (t < 0.0) {\n-                    final UnivariateRealPointValuePair optimum = line.search(x, d);\n+                    final UnivariatePointValuePair optimum = line.search(x, d);\n                     fVal = optimum.getValue();\n                     alphaMin = optimum.getPoint();\n                     final double[][] result = newPointAndDirection(x, d, alphaMin);\n          * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n          * if the number of evaluations is exceeded.\n          */\n-        public UnivariateRealPointValuePair search(final double[] p, final double[] d) {\n+        public UnivariatePointValuePair search(final double[] p, final double[] d) {\n             final int n = p.length;\n             final UnivariateFunction f = new UnivariateFunction() {\n                     public double value(double alpha) {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n \n     /**\n      * @param checker Convergence checker.\n      */\n-    public SimplexOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n+    public SimplexOptimizer(ConvergenceChecker<PointValuePair> checker) {\n         super(checker);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected PointValuePair doOptimize() {\n         if (simplex == null) {\n             throw new NullArgumentException();\n         }\n             };\n \n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n-        final Comparator<RealPointValuePair> comparator\n-            = new Comparator<RealPointValuePair>() {\n-            public int compare(final RealPointValuePair o1,\n-                               final RealPointValuePair o2) {\n+        final Comparator<PointValuePair> comparator\n+            = new Comparator<PointValuePair>() {\n+            public int compare(final PointValuePair o1,\n+                               final PointValuePair o2) {\n                 final double v1 = o1.getValue();\n                 final double v2 = o2.getValue();\n                 return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n         simplex.build(getStartPoint());\n         simplex.evaluate(evalFunc, comparator);\n \n-        RealPointValuePair[] previous = null;\n+        PointValuePair[] previous = null;\n         int iteration = 0;\n-        final ConvergenceChecker<RealPointValuePair> checker = getConvergenceChecker();\n+        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n             if (iteration > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n-                    RealPointValuePair prev = previous[i];\n+                    PointValuePair prev = previous[i];\n                     converged &= checker.converged(iteration, prev, simplex.getPoint(i));\n                 }\n                 if (converged) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n import org.apache.commons.math.optimization.DifferentiableMultivariateOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer;\n \n /**\n     /**\n      * @param checker Convergence checker.\n      */\n-    protected AbstractScalarDifferentiableOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n+    protected AbstractScalarDifferentiableOptimizer(ConvergenceChecker<PointValuePair> checker) {\n         super(checker);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public RealPointValuePair optimize(int maxEval,\n+    public PointValuePair optimize(int maxEval,\n                                        final DifferentiableMultivariateFunction f,\n                                        final GoalType goalType,\n                                        final double[] startPoint) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.util.FastMath;\n      * @param checker Convergence checker.\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n-                                               ConvergenceChecker<RealPointValuePair> checker) {\n+                                               ConvergenceChecker<PointValuePair> checker) {\n         this(updateFormula,\n              checker,\n              new BrentSolver(),\n      * @param lineSearchSolver Solver to use during line search.\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n-                                               ConvergenceChecker<RealPointValuePair> checker,\n+                                               ConvergenceChecker<PointValuePair> checker,\n                                                final UnivariateSolver lineSearchSolver) {\n         this(updateFormula,\n              checker,\n      * @param preconditioner Preconditioner.\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n-                                               ConvergenceChecker<RealPointValuePair> checker,\n+                                               ConvergenceChecker<PointValuePair> checker,\n                                                final UnivariateSolver lineSearchSolver,\n                                                final Preconditioner preconditioner) {\n         super(checker);\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n-        final ConvergenceChecker<RealPointValuePair> checker = getConvergenceChecker();\n+    protected PointValuePair doOptimize() {\n+        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         point = getStartPoint();\n         final GoalType goal = getGoalType();\n         final int n = point.length;\n             delta += r[i] * searchDirection[i];\n         }\n \n-        RealPointValuePair current = null;\n+        PointValuePair current = null;\n         int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n             ++iter;\n \n             final double objective = computeObjectiveValue(point);\n-            RealPointValuePair previous = current;\n-            current = new RealPointValuePair(point, objective);\n+            PointValuePair previous = current;\n+            current = new PointValuePair(point, objective);\n             if (previous != null) {\n                 if (checker.converged(iter, previous, current)) {\n                     // We have found an optimum.\n--- a/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n \n /**\n  * Base class for implementing linear optimizers.\n     }\n \n     /** {@inheritDoc} */\n-    public RealPointValuePair optimize(final LinearObjectiveFunction f,\n+    public PointValuePair optimize(final LinearObjectiveFunction f,\n                                        final Collection<LinearConstraint> constraints,\n                                        final GoalType goalType, final boolean restrictToNonNegative)\n          throws MathIllegalStateException {\n      * @exception MathIllegalStateException if no solution fulfilling the constraints\n      * can be found in the allowed number of iterations\n      */\n-    protected abstract RealPointValuePair doOptimize()\n+    protected abstract PointValuePair doOptimize()\n         throws MathIllegalStateException;\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n \n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n \n /**\n  * This interface represents an optimization algorithm for linear problems.\n      * @exception MathIllegalStateException if no solution fulfilling the constraints\n      * can be found in the allowed number of iterations\n      */\n-   RealPointValuePair optimize(LinearObjectiveFunction f, Collection<LinearConstraint> constraints,\n+   PointValuePair optimize(LinearObjectiveFunction f, Collection<LinearConstraint> constraints,\n                                GoalType goalType, boolean restrictToNonNegative)\n         throws MathIllegalStateException;\n \n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n import java.util.List;\n \n import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.util.Precision;\n \n \n \n     /** {@inheritDoc} */\n     @Override\n-    public RealPointValuePair doOptimize()\n+    public PointValuePair doOptimize()\n         throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n         final SimplexTableau tableau =\n             new SimplexTableau(function, linearConstraints, goal, nonNegative,\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.util.Precision;\n \n /**\n      *\n      * @return current solution\n      */\n-    protected RealPointValuePair getSolution() {\n+    protected PointValuePair getSolution() {\n       int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n       Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n                   (restrictToNonNegative ? 0 : mostNegative);\n           }\n       }\n-      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n+      return new PointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseAbstractUnivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseAbstractUnivariateOptimizer.java\n public abstract class BaseAbstractUnivariateOptimizer\n     implements UnivariateRealOptimizer {\n     /** Convergence checker. */\n-    private final ConvergenceChecker<UnivariateRealPointValuePair> checker;\n+    private final ConvergenceChecker<UnivariatePointValuePair> checker;\n     /** Evaluations counter. */\n     private final Incrementor evaluations = new Incrementor();\n     /** Optimization type */\n     /**\n      * @param checker Convergence checking procedure.\n      */\n-    protected BaseAbstractUnivariateOptimizer(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+    protected BaseAbstractUnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\n         this.checker = checker;\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(int maxEval, UnivariateFunction f,\n+    public UnivariatePointValuePair optimize(int maxEval, UnivariateFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max,\n                                                  double startValue) {\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(int maxEval,\n+    public UnivariatePointValuePair optimize(int maxEval,\n                                                  UnivariateFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max){\n     /**\n      * {@inheritDoc}\n      */\n-    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n+    public ConvergenceChecker<UnivariatePointValuePair> getConvergenceChecker() {\n         return checker;\n     }\n \n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n      */\n-    protected abstract UnivariateRealPointValuePair doOptimize();\n+    protected abstract UnivariatePointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateOptimizer.java\n  * @since 3.0\n  */\n public interface BaseUnivariateOptimizer<FUNC extends UnivariateFunction>\n-    extends BaseOptimizer<UnivariateRealPointValuePair> {\n+    extends BaseOptimizer<UnivariatePointValuePair> {\n     /**\n      * Find an optimum in the given interval.\n      *\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n      */\n-    UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    UnivariatePointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                           double min, double max);\n \n     /**\n      * @throws org.apache.commons.math.exception.NullArgumentException if any\n      * argument is {@code null}.\n      */\n-    UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+    UnivariatePointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                           double min, double max,\n                                           double startValue);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n      */\n     public BrentOptimizer(double rel,\n                           double abs,\n-                          ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n         super(checker);\n \n         if (rel < MIN_RELATIVE_TOLERANCE) {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealPointValuePair doOptimize() {\n+    protected UnivariatePointValuePair doOptimize() {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final double lo = getMin();\n         final double mid = getStartValue();\n         final double hi = getMax();\n \n         // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariateRealPointValuePair> checker\n+        final ConvergenceChecker<UnivariatePointValuePair> checker\n             = getConvergenceChecker();\n \n         double a;\n         double fv = fx;\n         double fw = fx;\n \n-        UnivariateRealPointValuePair previous = null;\n-        UnivariateRealPointValuePair current\n-            = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n+        UnivariatePointValuePair previous = null;\n+        UnivariatePointValuePair current\n+            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n \n         int iter = 0;\n         while (true) {\n                 }\n \n                 previous = current;\n-                current = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n+                current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n \n                 // User-defined convergence checker.\n                 if (checker != null) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateMultiStartOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateMultiStartOptimizer.java\n     /** Random generator for multi-start. */\n     private RandomGenerator generator;\n     /** Found optima. */\n-    private UnivariateRealPointValuePair[] optima;\n+    private UnivariatePointValuePair[] optima;\n \n     /**\n      * Create a multi-start optimizer from a single-start optimizer.\n     /**\n      * {@inheritDoc}\n      */\n-    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n+    public ConvergenceChecker<UnivariatePointValuePair> getConvergenceChecker() {\n         return optimizer.getConvergenceChecker();\n     }\n \n      * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n      * has not been called.\n      */\n-    public UnivariateRealPointValuePair[] getOptima() {\n+    public UnivariatePointValuePair[] getOptima() {\n         if (optima == null) {\n             throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(int maxEval, final FUNC f,\n+    public UnivariatePointValuePair optimize(int maxEval, final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max) {\n         return optimize(maxEval, f, goal, min, max, min + 0.5 * (max - min));\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(int maxEval, final FUNC f,\n+    public UnivariatePointValuePair optimize(int maxEval, final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max,\n                                                  final double startValue) {\n         RuntimeException lastException = null;\n-        optima = new UnivariateRealPointValuePair[starts];\n+        optima = new UnivariatePointValuePair[starts];\n         totalEvaluations = 0;\n \n         // Multi-start loop.\n      * @param goal Goal type.\n      */\n     private void sortPairs(final GoalType goal) {\n-        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n-                public int compare(final UnivariateRealPointValuePair o1,\n-                                   final UnivariateRealPointValuePair o2) {\n+        Arrays.sort(optima, new Comparator<UnivariatePointValuePair>() {\n+                public int compare(final UnivariatePointValuePair o1,\n+                                   final UnivariatePointValuePair o2) {\n                     if (o1 == null) {\n                         return (o2 == null) ? 0 : 1;\n                     } else if (o2 == null) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariatePointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class holds a point and the value of an objective function at this\n+ * point.\n+ * This is a simple immutable container.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class UnivariatePointValuePair implements Serializable {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+    /** Point. */\n+    private final double point;\n+    /** Value of the objective function at the point. */\n+    private final double value;\n+\n+    /**\n+     * Build a point/objective function value pair.\n+     *\n+     * @param point Point.\n+     * @param value Value of an objective function at the point\n+     */\n+    public UnivariatePointValuePair(final double point,\n+                                        final double value) {\n+        this.point = point;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Get the point.\n+     *\n+     * @return the point.\n+     */\n+    public double getPoint() {\n+        return point;\n+    }\n+\n+    /**\n+     * Get the value of the objective function.\n+     *\n+     * @return the stored value of the objective function.\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateMultiStartOptimizerTest.java\n                                                   new GaussianRandomGenerator(g));\n         DifferentiableMultivariateMultiStartOptimizer optimizer =\n             new DifferentiableMultivariateMultiStartOptimizer(underlying, 10, generator);\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         Assert.assertEquals(200, optimizer.getMaxEvaluations());\n-        RealPointValuePair[] optima = optimizer.getOptima();\n-        for (RealPointValuePair o : optima) {\n+        PointValuePair[] optima = optimizer.getOptima();\n+        for (PointValuePair o : optima) {\n             Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);\n             Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n             Assert.assertEquals(96.075902096, center.x, 1.0e-8);\n--- a/src/test/java/org/apache/commons/math/optimization/MultivariateMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultivariateMultiStartOptimizerTest.java\n             new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));\n         MultivariateMultiStartOptimizer optimizer =\n             new MultivariateMultiStartOptimizer(underlying, 10, generator);\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n         Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.junit.Assert;\n import org.junit.Test;\n \n     public void testRosen() {\n         double[] startPoint = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected = new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 2000, expected);\n     public void testMaximize() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected = new RealPointValuePair(point(DIM,0.0),1.0);\n+        PointValuePair expected = new PointValuePair(point(DIM,0.0),1.0);\n         doTest(new MinusElli(), startPoint, boundaries,\n                 GoalType.MAXIMIZE, \n                 2e-10, 5e-6, 1000, expected);\n     public void testEllipse() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Elli(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 1000, expected);\n     public void testElliRotated() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new ElliRotated(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-12, 1e-6, 10000, expected);\n     public void testCigar() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Cigar(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 100, expected);\n     public void testTwoAxes() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new TwoAxes(), startPoint, boundaries,\n                 GoalType.MINIMIZE, 2*\n                 1e-13, 1e-6, 100, expected);\n     public void testCigTab() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new CigTab(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 5e-5, 100, expected);\n     public void testSphere() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Sphere(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 100, expected);\n     public void testTablet() {\n         double[] startPoint = point(DIM,1.0); \n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Tablet(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 100, expected);\n     public void testDiffPow() {\n         double[] startPoint = point(DIM/2,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM/2,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM/2,0.0),0.0);\n         doTest(new DiffPow(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-8, 1e-1, 12000, expected);\n     public void testSsDiffPow() {\n         double[] startPoint = point(DIM/2,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM/2,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM/2,0.0),0.0);\n         doTest(new SsDiffPow(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-2, 1.3e-1, 50000, expected);\n     public void testAckley() {\n         double[] startPoint = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Ackley(), startPoint, boundaries,\n                 GoalType.MINIMIZE,\n                 1e-8, 1e-5, 1000, expected);\n         double[] startPoint = point(DIM,1.0);\n \n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Rastrigin(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 1000, expected);\n         double[] startPoint = point(DIM,0.1);\n \n         double[][] boundaries = boundaries(DIM,-1,2);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, boundaries,\n                 GoalType.MINIMIZE,\n                 1e-13, 1e-6, 2000, expected);\n     public void testConstrainedRosenWithMoreInterpolationPoints() {\n         final double[] startPoint = point(DIM, 0.1);\n         final double[][] boundaries = boundaries(DIM, -1, 2);\n-        final RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n+        final PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0);\n \n         // This should have been 78 because in the code the hard limit is\n         // said to be\n                         double fTol,\n                         double pointTol,\n                         int maxEvaluations,\n-                        RealPointValuePair expected) {\n+                        PointValuePair expected) {\n         doTest(func,\n                startPoint,\n                boundaries,\n                         double pointTol,\n                         int maxEvaluations,\n                         int additionalInterpolationPoints,\n-                        RealPointValuePair expected,\n+                        PointValuePair expected,\n                         String assertMsg) {\n \n         System.out.println(func.getClass().getName() + \" BEGIN\"); // XXX\n         int dim = startPoint.length;\n //        MultivariateOptimizer optim =\n //            new PowellOptimizer(1e-13, Math.ulp(1d));\n-//        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);\n+//        PointValuePair result = optim.optimize(100000, func, goal, startPoint);\n         final double[] lB = boundaries == null ? null : boundaries[0];\n         final double[] uB = boundaries == null ? null : boundaries[1];\n         final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints;\n         BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints);\n-        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n+        PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n //        System.out.println(func.getClass().getName() + \" = \" \n //              + optim.getEvaluations() + \" f(\");\n //        for (double x: result.getPoint())  System.out.print(x + \" \");\n--- a/src/test/java/org/apache/commons/math/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/CMAESOptimizerTest.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.random.MersenneTwister;\n import org.junit.Assert;\n import org.junit.Test;\n         double[] startPoint = point(DIM,3);\n         double[] insigma = null;\n         double[][] boundaries = boundaries(DIM,-1,2);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,0.5);\n         double[] insigma = null;\n         double[][] boundaries = boundaries(DIM+1,-1,2);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] insigma = null;\n         double[][] boundaries = boundaries(DIM,-1,2);\n         boundaries[1] = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,0.5);\n         double[] insigma = point(DIM,-0.5);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,0.5);\n         double[] insigma = point(DIM, 1.1);\n         double[][] boundaries = boundaries(DIM,-0.5,0.5);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,0.5);\n         double[] insigma = point(DIM+1,-0.5);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,0.1);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),1.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),1.0);\n         doTest(new MinusElli(), startPoint, insigma, boundaries,\n                 GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,\n                 2e-10, 5e-6, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Elli(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Cigar(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 200000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 200000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.3);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new CigTab(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 5e-5, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Sphere(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Tablet(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new DiffPow(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                 1e-8, 1e-1, 100000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                 1e-4, 1e-1, 200000, expected);\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Ackley(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                 1e-9, 1e-5, 100000, expected);\n         double[] startPoint = point(DIM,0.1);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n         doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13,\n                 1e-13, 1e-6, 200000, expected);\n         double[] startPoint = point(DIM,0.1);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = boundaries(DIM,-1,2);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                 1e-13, 1e-6, 100000, expected);\n         double[] startPoint = point(DIM,0.1);\n         double[] insigma = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n                 GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,\n                 1e-10, 1e-4, 1000000, expected);\n             double fTol,\n             double pointTol,\n             int maxEvaluations,\n-            RealPointValuePair expected) {\n+            PointValuePair expected) {\n         int dim = startPoint.length;\n         // test diagonalOnly = 0 - slow but normally fewer feval#\n         MultivariateOptimizer optim =\n             new CMAESOptimizer(\n                     lambda, inSigma, boundaries, 30000,\n                     stopValue, isActive, diagonalOnly, 0, new MersenneTwister(),false);\n-        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);\n+        PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);\n         Assert.assertEquals(expected.getValue(),\n                 result.getValue(), fTol);\n         for (int i = 0; i < dim; i++) {\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionMappingAdapterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionMappingAdapterTest.java\n \n import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.junit.Assert;\n import org.junit.Test;\n \n             wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n         }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(300, wrapped, GoalType.MINIMIZE,\n                                  wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n             wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n         }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(100, wrapped, GoalType.MINIMIZE,\n                                  wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n             wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n         }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(300, wrapped, GoalType.MINIMIZE,\n                                  wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n             wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n         }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(200, wrapped, GoalType.MINIMIZE,\n                                  wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n         final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapterTest.java\n \n import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleRealPointChecker;\n import org.junit.Assert;\n import org.junit.Test;\n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { 1.5, 2.25 });\n \n         Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n \n         Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n         SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-11, 1.0e-20));\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(600, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n \n         Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n \n         Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n         SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-10, 1.0e-20));\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(400, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n \n         Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n--- a/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n import org.apache.commons.math.analysis.SumSincFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.junit.Assert;\n import org.junit.Test;\n \n                         double pointTol) {\n         final MultivariateOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));\n \n-        final RealPointValuePair result = optim.optimize(1000, func, goal, init);\n+        final PointValuePair result = optim.optimize(1000, func, goal, init);\n         final double[] found = result.getPoint();\n \n         for (int i = 0, dim = optimum.length; i < dim; i++) {\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n \n import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6);\n         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             =  optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7);\n         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7);\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[][] {\n                     { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n                 }));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n \n         Assert.assertEquals(count, optimizer.getEvaluations());\n         count = 0;\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n         optimizer.setSimplex(new MultiDirectionalSimplex(4));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(1000, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n         Assert.assertEquals(count, optimizer.getEvaluations());\n         Assert.assertTrue(optimizer.getEvaluations() > 800);\n         SimplexOptimizer optimizer = new SimplexOptimizer();\n         optimizer.setSimplex(new MultiDirectionalSimplex(2));\n         final Gaussian2D function = new Gaussian2D(0, 0, 1);\n-        RealPointValuePair estimate = optimizer.optimize(1000, function,\n+        PointValuePair estimate = optimizer.optimize(1000, function,\n                                                          GoalType.MAXIMIZE, function.getMaximumPosition());\n         final double EPSILON = 1e-5;\n         final double expectedMaximum = function.getMaximum();\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.LeastSquaresConverter;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);\n         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6);\n         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 });\n         Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5);\n         Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n-        final RealPointValuePair optimum\n+        final PointValuePair optimum\n             = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n         Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6);\n         Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n                     { -1.2,  1 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n                 }));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n \n         Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n         Powell powell = new Powell();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n         optimizer.setSimplex(new NelderMeadSimplex(4));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(200, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n         Assert.assertEquals(powell.getCount(), optimizer.getEvaluations());\n         Assert.assertTrue(optimizer.getEvaluations() > 110);\n             }, new double[] { 2.0, -3.0 });\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n         Assert.assertEquals( 2, optimum.getPointRef()[0], 3e-5);\n         Assert.assertEquals(-3, optimum.getPointRef()[1], 4e-4);\n             }, new double[] { 2, -3 }, new double[] { 10, 0.1 });\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n         Assert.assertEquals( 2, optimum.getPointRef()[0], 5e-5);\n         Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n                 }));\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n         Assert.assertEquals( 2, optimum.getPointRef()[0], 2e-3);\n         Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n import org.junit.Assert;\n import org.junit.Test;\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 });\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         for (int i = 0; i < problem.target.length; ++i) {\n             Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n                                                     new BrentSolver(),\n                                                     preconditioner);\n                                                     \n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n                 optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertTrue(optimum.getValue() > 0.5);\n     }\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-13, 1e-13),\n                                                     new BrentSolver(1e-15, 1e-15));\n-        RealPointValuePair optimum1 =\n+        PointValuePair optimum1 =\n             optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);\n         Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4);\n                 {  8.00, 5.98, 9.89, 9.00 },\n                 {  6.99, 4.99, 9.00, 9.98 }\n         }, new double[] { 32, 23, 33, 31 });\n-        RealPointValuePair optimum2 =\n+        PointValuePair optimum2 =\n             optimizer.optimize(200, problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);\n         Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n     }\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n         Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-6, 1e-6));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertTrue(optimum.getValue() > 0.1);\n \n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n                                                     new SimpleScalarValueChecker(1e-30, 1e-30),\n                                                     new BrentSolver(1e-15, 1e-13));\n-        RealPointValuePair optimum =\n+        PointValuePair optimum =\n             optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n import java.util.Collection;\n \n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.PointValuePair;\n import org.apache.commons.math.util.Precision;\n import org.junit.Test;\n \n \n         double epsilon = 1e-6;\n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n \n         Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0);\n         Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);\n \n         double epsilon = 1e-6;\n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n \n         Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon);\n         Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon);\n         constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n         \n         Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);\n         Assert.assertEquals(0.0050, solution.getValue(), epsilon);\n \n         double epsilon = 1e-7;\n         SimplexSolver simplex = new SimplexSolver();\n-        RealPointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        PointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);\n         \n         Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);\n         Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);        \n         constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n \n         Assert.assertEquals(0.0, solution.getPoint()[0], .0000001);\n         Assert.assertEquals(1.0, solution.getPoint()[1], .0000001);\n         constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n \n         Assert.assertEquals(25.8, solution.getValue(), .0000001);\n         Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001);\n         constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n         Assert.assertEquals(13.6, solution.getValue(), .0000001);\n     }\n \n         constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n         Assert.assertEquals(10.0, solution.getValue(), .0000001);\n     }\n \n         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n         constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0));\n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n         Assert.assertEquals(0, solution.getValue(), .0000001);\n         Assert.assertEquals(0, solution.getPoint()[0], .0000001);\n         Assert.assertEquals(0, solution.getPoint()[1], .0000001);\n       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));\n \n       SimplexSolver solver = new SimplexSolver();\n-      RealPointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+      PointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n \n       Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);\n       Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);\n       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));\n       constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));\n \n-      RealPointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+      PointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n       Assert.assertEquals(40.57143, solution2.getValue(), .0001);\n     }\n \n         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n         Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);\n         Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);\n         Assert.assertEquals(57.0, solution.getValue(), 0.0);\n         constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n         Assert.assertEquals(10.0, solution.getPoint()[0], 0.0);\n         Assert.assertEquals(30.0, solution.getValue(), 0.0);\n     }\n         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n         Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);\n         Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);\n         Assert.assertEquals(50.0, solution.getValue(), 0.0);\n         constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n         Assert.assertEquals(4.0, solution.getPoint()[0], 0.0);\n         Assert.assertEquals(0.0, solution.getPoint()[1], 0.0);\n         Assert.assertEquals(-13.0, solution.getValue(), 0.0);\n         constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n         Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0);\n         Assert.assertEquals(8.0, solution.getPoint()[1], 0.0);\n         Assert.assertEquals(12.0, solution.getValue(), 0.0);\n         constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n         Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);\n         Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001);\n         Assert.assertEquals(0.0, solution.getPoint()[2], .0000001);\n       constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10));\n \n       SimplexSolver solver = new SimplexSolver();\n-      RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+      PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n       Assert.assertEquals(1.0, solution.getPoint()[0], 0.0);\n       Assert.assertEquals(1.0, solution.getPoint()[1], 0.0);\n       Assert.assertEquals(0.0, solution.getPoint()[2], 0.0);\n         constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n         Assert.assertEquals(0, solution.getValue(), .0000001);\n     }\n \n         constraints.add(equationFromString(objective.length, \"x204 - x192 = 0\"));\n \n         SimplexSolver solver = new SimplexSolver();\n-        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n         Assert.assertEquals(7518.0, solution.getValue(), .0000001);\n     }\n \n--- a/src/test/java/org/apache/commons/math/optimization/univariate/UnivariateMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/UnivariateMultiStartOptimizerTest.java\n         UnivariateMultiStartOptimizer<UnivariateFunction> optimizer =\n             new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 10, g);\n         optimizer.optimize(300, f, GoalType.MINIMIZE, -100.0, 100.0);\n-        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n+        UnivariatePointValuePair[] optima = optimizer.getOptima();\n         for (int i = 1; i < optima.length; ++i) {\n             double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);\n             Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);\n         UnivariateMultiStartOptimizer<UnivariateFunction> optimizer =\n             new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 5, g);\n \n-        UnivariateRealPointValuePair optimum\n+        UnivariatePointValuePair optimum\n             = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n         Assert.assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n         Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n \n-        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n+        UnivariatePointValuePair[] optima = optimizer.getOptima();\n         for (int i = 0; i < optima.length; ++i) {\n             Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n         }", "timestamp": 1329007043, "metainfo": ""}