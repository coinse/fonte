{"sha": "d792ae74c63831f254e87a0c169ff6dd4a2f8e74", "log": "fixed findbugs warnings and added more explanation about the corresponding behavior in javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/sampling/MultistepStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/MultistepStepInterpolator.java\n     }\n \n     /** Reinitialize the instance\n+     * <p>Beware that all arrays <em>must</em> be references to integrator\n+     * arrays, in order to ensure proper update without copy.</p>\n      * @param y reference to the integrator array holding the state at\n      * the end of the step\n      * @param previousT reference to the integrator array holding the times\n--- a/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n  * handlers can use these objects to retrieve the state vector at\n  * intermediate times between the previous and the current grid points\n  * (this feature is often called dense output).</p>\n+ * <p>One important thing to note is that the step handlers may be so\n+ * tightly bound to the integrators that they often share some internal\n+ * state arrays. This imply that one should <em>never</em> use a direct\n+ * reference to a step interpolator outside of the step handler, either\n+ * for future use or for use in another thread. If such a need arise, the\n+ * step interpolator <em>must</em> be copied using the dedicated\n+ * {@link #copy()} method.\n+ * </p>\n  *\n  * @see FirstOrderIntegrator\n  * @see SecondOrderIntegrator", "timestamp": 1238958644, "metainfo": ""}