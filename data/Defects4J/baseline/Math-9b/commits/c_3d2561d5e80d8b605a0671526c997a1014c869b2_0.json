{"sha": "3d2561d5e80d8b605a0671526c997a1014c869b2", "log": "Added vector-only weights for multivariate vector optimizers.  JIRA: MATH-924  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/CurveFitter.java\n \n import java.util.ArrayList;\n import java.util.List;\n+\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.analysis.ParametricUnivariateFunction;\n+import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n-import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;\n import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;\n import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;\n+import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;\n import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n \n /**\n  * Fitter for parametric univariate real functions y = f(x).\n                                  model.getModelFunction(),\n                                  model.getModelFunctionJacobian(),\n                                  new Target(target),\n-                                 new Weight(weights),\n+                                 new NonCorrelatedWeight(weights),\n                                  new InitialGuess(initialGuess));\n         // Extract the coefficients.\n         return optimum.getPointRef();\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.java\n  */\n package org.apache.commons.math3.optim.nonlinear.vector;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n+\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealVector;\n-import org.apache.commons.math3.linear.ArrayRealVector;\n-import org.apache.commons.math3.random.RandomVectorGenerator;\n import org.apache.commons.math3.optim.BaseMultiStartMultivariateOptimizer;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n+import org.apache.commons.math3.random.RandomVectorGenerator;\n \n /**\n  * Multi-start optimizer for a (vector) model function.\n     private Comparator<PointVectorValuePair> getPairComparator() {\n         return new Comparator<PointVectorValuePair>() {\n             private final RealVector target = new ArrayRealVector(optimizer.getTarget(), false);\n-            private final RealMatrix weight = optimizer.getWeight();\n+            private final double[] weight   = optimizer.getNonCorrelatedWeight();\n \n             public int compare(final PointVectorValuePair o1,\n                                final PointVectorValuePair o2) {\n             private double weightedResidual(final PointVectorValuePair pv) {\n                 final RealVector v = new ArrayRealVector(pv.getValueRef(), false);\n                 final RealVector r = target.subtract(v);\n-                return r.dotProduct(weight.operate(r));\n+                double sum = 0;\n+                for (int i = 0; i < r.getDimension(); ++i) {\n+                    final double ri = r.getEntry(i);\n+                    sum += ri * weight[i] * ri;\n+                }\n+                return sum;\n             }\n         };\n     }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java\n \n package org.apache.commons.math3.optim.nonlinear.vector;\n \n+import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.optim.OptimizationData;\n+import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.optim.BaseMultivariateOptimizer;\n import org.apache.commons.math3.optim.ConvergenceChecker;\n+import org.apache.commons.math3.optim.OptimizationData;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n-import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer;\n \n /**\n  * Base class for a multivariate vector function optimizer.\n     extends BaseMultivariateOptimizer<PointVectorValuePair> {\n     /** Target values for the model function at optimum. */\n     private double[] target;\n-    /** Weight matrix. */\n+    /** Weight matrix.\n+     * @deprecated as of 3.1.1, replaced by weight\n+     */\n+    @Deprecated\n     private RealMatrix weightMatrix;\n+    /** Weight vector. */\n+    private double[] weight;\n     /** Model function. */\n     private MultivariateVectorFunction model;\n \n \n     /**\n      * {@inheritDoc}\n-     *\n+     * <p>\n+     * Note that for version 3.1 of Apache Commons Math, a general <code>Weight</code>\n+     * data was looked for, which could hold arbitrary square matrices and not only\n+     * vector as the current {@link NonCorrelatedWeight} does. This was flawed as some\n+     * optimizers like {@link GaussNewtonOptimizer} only considered the diagonal elements.\n+     * This feature was deprecated. If users need non-diagonal weights to handle correlated\n+     * observations, they will have to implement it by themselves using pre-multiplication\n+     * by a matrix in both their function implementation and observation vectors. There is\n+     * no direct support for this anymore in the Apache Commons Math library. The only\n+     * feature that is supported here is a convenience feature for non-correlated observations,\n+     * with vector only weights (i.e. weight[i] is the weight for observation i).\n+     * </p>\n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n      *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>\n      *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n      *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n      *  <li>{@link Target}</li>\n-     *  <li>{@link Weight}</li>\n+     *  <li>{@link NonCorrelatedWeight}</li>\n      *  <li>{@link ModelFunction}</li>\n      * </ul>\n      * @return {@inheritDoc}\n      * Gets the weight matrix of the observations.\n      *\n      * @return the weight matrix.\n-     */\n+     * @deprecated as of 3.1.1, replaced by {@link #getNonCorrelatedWeight()}\n+     */\n+    @Deprecated\n     public RealMatrix getWeight() {\n         return weightMatrix.copy();\n+    }\n+\n+    /**\n+     * Gets the weights of the observations.\n+     *\n+     * @return the weights.\n+     * @since 3.1.1\n+     */\n+    public double[] getNonCorrelatedWeight() {\n+        return weight.clone();\n     }\n     /**\n      * Gets the observed values to be matched by the objective vector\n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n      *  <li>{@link Target}</li>\n-     *  <li>{@link Weight}</li>\n+     *  <li>{@link NonCorrelatedWeight}</li>\n      *  <li>{@link ModelFunction}</li>\n      * </ul>\n      */\n                 target = ((Target) data).getTarget();\n                 continue;\n             }\n+            if (data instanceof NonCorrelatedWeight) {\n+                weight = ((NonCorrelatedWeight) data).getWeight();\n+                continue;\n+            }\n+            // TODO: remove this for 4.0, when the Weight class will be removed\n             if (data instanceof Weight) {\n                 weightMatrix = ((Weight) data).getWeight();\n+                weight = new double[weightMatrix.getColumnDimension()];\n+                for (int i = 0; i < weight.length; ++i) {\n+                    // extract the diagonal of the matrix\n+                    weight[i] = weightMatrix.getEntry(i, i);\n+                }\n                 continue;\n             }\n         }\n      * Check parameters consistency.\n      *\n      * @throws DimensionMismatchException if {@link #target} and\n-     * {@link #weightMatrix} have inconsistent dimensions.\n+     * {@link #weight} have inconsistent dimensions.\n      */\n     private void checkParameters() {\n-        if (target.length != weightMatrix.getColumnDimension()) {\n-            throw new DimensionMismatchException(target.length,\n-                                                 weightMatrix.getColumnDimension());\n+        if (target.length != weight.length) {\n+            throw new DimensionMismatchException(target.length, weight.length);\n         }\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/NonCorrelatedWeight.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.optim.nonlinear.vector;\n+\n+import org.apache.commons.math3.optim.OptimizationData;\n+\n+/**\n+ * Weight of the residuals between model and observations, when\n+ * observations are non-correlated.\n+ * <br/>\n+ * Immutable class.\n+ *\n+ * @version $Id$\n+ * @since 3.1.1\n+ */\n+public class NonCorrelatedWeight implements OptimizationData {\n+\n+    /** Weight. */\n+    private final double[] weight;\n+\n+    /**\n+     * Creates a weight vector.\n+     *\n+     * @param weight weight of the observations\n+     */\n+    public NonCorrelatedWeight(final double[] weight) {\n+        this.weight = weight.clone();\n+    }\n+\n+    /**\n+     * Gets the weight.\n+     *\n+     * @return a fresh copy of the weight.\n+     */\n+    public double[] getWeight() {\n+        return weight.clone();\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n  *\n  * @version $Id: Weight.java 1416643 2012-12-03 19:37:14Z tn $\n  * @since 3.1\n+ * @deprecated as of 3.1.1, replaced by {@link NonCorrelatedWeight}\n  */\n+@Deprecated\n public class Weight implements OptimizationData {\n     /** Weight matrix. */\n     private final RealMatrix weightMatrix;\n \n     /**\n-     * Creates a diagonal weight matrix.\n+     * Creates a weight matrix.\n      *\n-     * @param weight List of the values of the diagonal.\n+     * @param weight matrix elements.\n      */\n-    public Weight(double[] weight) {\n-        final int dim = weight.length;\n-        weightMatrix = MatrixUtils.createRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+    public Weight(double[][] weight) {\n+        weightMatrix = MatrixUtils.createRealMatrix(weight);\n     }\n \n     /**\n     }\n \n     /**\n-     * Gets the initial guess.\n+     * Gets the weight.\n      *\n-     * @return the initial guess.\n+     * @return a fresh copy of the weight.\n      */\n     public RealMatrix getWeight() {\n         return weightMatrix.copy();\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.linear.ArrayRealVector;\n-import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n+import org.apache.commons.math3.linear.EigenDecomposition;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n-import org.apache.commons.math3.linear.EigenDecomposition;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.optim.ConvergenceChecker;\n import org.apache.commons.math3.optim.OptimizationData;\n-import org.apache.commons.math3.optim.ConvergenceChecker;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n+import org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n-import org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n  */\n public abstract class AbstractLeastSquaresOptimizer\n     extends JacobianMultivariateVectorOptimizer {\n-    /** Square-root of the weight matrix. */\n+    /** Square-root of the weight matrix.\n+     * @deprecated as of 3.1.1, replaced by {@link #weight}\n+     */\n+    @Deprecated\n     private RealMatrix weightMatrixSqrt;\n+    /** Square-root of the weight vector. */\n+    private double[] weightSquareRoot;\n     /** Cost value (square root of the sum of the residuals). */\n     private double cost;\n \n      * match problem dimension.\n      */\n     protected RealMatrix computeWeightedJacobian(double[] params) {\n-        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n+\n+        final double[][] jacobian = computeJacobian(params);\n+\n+        if (weightSquareRoot != null) {\n+            for (int i = 0; i < jacobian.length; ++i) {\n+                final double wi = weightSquareRoot[i];\n+                final double[] row = jacobian[i];\n+                for (int j = 0; j < row.length; ++j) {\n+                    row[j] *= wi;\n+                }\n+            }\n+            return MatrixUtils.createRealMatrix(jacobian);\n+        } else {\n+            // TODO: remove for 4.0, when the {@link Weight} class will be removed\n+            return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobian));\n+        }\n+\n     }\n \n     /**\n      */\n     protected double computeCost(double[] residuals) {\n         final ArrayRealVector r = new ArrayRealVector(residuals);\n-        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n+        final double[] weight = getNonCorrelatedWeight();\n+        double sum = 0;\n+        for (int i = 0; i < r.getDimension(); ++i) {\n+            final double ri = r.getEntry(i);\n+            sum += ri * weight[i] * ri;\n+        }\n+        return FastMath.sqrt(sum);\n     }\n \n     /**\n      * Gets the square-root of the weight matrix.\n      *\n      * @return the square-root of the weight matrix.\n-     */\n+     * @deprecated as of 3.1.1, replaced with {@link MultivariateVectorOptimizer#getNonCorrelatedWeight()}\n+     */\n+    @Deprecated\n     public RealMatrix getWeightSquareRoot() {\n         return weightMatrixSqrt.copy();\n     }\n      *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>\n      *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Target}</li>\n-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>\n+     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunction}</li>\n      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian}</li>\n      * </ul>\n     /**\n      * Scans the list of (required and optional) optimization data that\n      * characterize the problem.\n-     * If the weight matrix is specified, the {@link #weightMatrixSqrt}\n-     * field is recomputed.\n+     * If the weight is specified, the {@link #weightSquareRoot} field is recomputed.\n      *\n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n         // not provided in the argument list.\n         for (OptimizationData data : optData) {\n             if (data instanceof Weight) {\n-                weightMatrixSqrt = squareRoot(((Weight) data).getWeight());\n-                // If more data must be parsed, this statement _must_ be\n-                // changed to \"continue\".\n-                break;\n+                // TODO: remove for 4.0, when the {@link Weight} class will be removed\n+                weightSquareRoot = null;\n+                final RealMatrix w = ((Weight) data).getWeight();\n+                final EigenDecomposition dec = new EigenDecomposition(w);\n+                weightMatrixSqrt = dec.getSquareRoot();\n+            } else if (data instanceof NonCorrelatedWeight) {\n+                weightSquareRoot = ((NonCorrelatedWeight) data).getWeight();\n+                for (int i = 0; i < weightSquareRoot.length; ++i) {\n+                    weightSquareRoot[i] = FastMath.sqrt(weightSquareRoot[i]);\n+                }\n+                weightMatrixSqrt = null;\n             }\n         }\n     }\n \n-    /**\n-     * Computes the square-root of the weight matrix.\n-     *\n-     * @param m Symmetric, positive-definite (weight) matrix.\n-     * @return the square-root of the weight matrix.\n-     */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-        final EigenDecomposition dec = new EigenDecomposition(m);\n-        return dec.getSquareRoot();\n-    }\n }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n         final double[] targetValues = getTarget();\n         final int nR = targetValues.length; // Number of observed data.\n \n-        final RealMatrix weightMatrix = getWeight();\n-        // Diagonal of the weight matrix.\n-        final double[] residualsWeights = new double[nR];\n-        for (int i = 0; i < nR; i++) {\n-            residualsWeights[i] = weightMatrix.getEntry(i, i);\n-        }\n+        final double[] residualsWeights = getNonCorrelatedWeight();\n \n         final double[] currentPoint = getStartPoint();\n         final int nC = currentPoint.length;\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n import java.util.Arrays;\n+\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.optim.ConvergenceChecker;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n-import org.apache.commons.math3.optim.ConvergenceChecker;\n-import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Precision;\n-import org.apache.commons.math3.util.FastMath;\n \n \n /**\n         double[] work2   = new double[nC];\n         double[] work3   = new double[nC];\n \n-        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n+        final double[] weight = getNonCorrelatedWeight();\n \n         // Evaluate the function at the starting point and calculate its norm.\n         double[] currentObjective = computeObjectiveValue(currentPoint);\n             // QR decomposition of the jacobian matrix\n             qrDecomposition(computeWeightedJacobian(currentPoint));\n \n-            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n+            weightedResidual = new double[currentResiduals.length];\n+            for (int i = 0; i < weightedResidual.length; ++i) {\n+                weightedResidual[i] = FastMath.sqrt(weight[i]) * currentResiduals[i];\n+            }\n             for (int i = 0; i < nR; i++) {\n                 qtf[i] = weightedResidual[i];\n             }\n--- a/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java\n         checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false);\n     }\n \n+    @Test\n+    public void testLargeSample() {\n+        Random randomizer = new Random(0x5551480dca5b369bl);\n+        double maxError = 0;\n+        for (int degree = 0; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n+            for (int i = 0; i < 40000; ++i) {\n+                double x = -1.0 + i / 20000.0;\n+                fitter.addObservedPoint(1.0, x,\n+                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n+            }\n+\n+            final double[] init = new double[degree + 1];\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n+\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n+                              (1.0 + FastMath.abs(p.value(x)));\n+                maxError = FastMath.max(maxError, error);\n+                Assert.assertTrue(FastMath.abs(error) < 0.01);\n+            }\n+        }\n+        Assert.assertTrue(maxError > 0.001);\n+    }\n+\n     private void checkUnsolvableProblem(MultivariateVectorOptimizer optimizer,\n                                         boolean solvable) {\n         Random randomizer = new Random(1248788532l);\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java\n  */\n package org.apache.commons.math3.optim.nonlinear.vector;\n \n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.SimpleVectorValueChecker;\n import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer;\n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  problem.getTarget(),\n-                                 new Weight(new double[] { 1 }),\n+                                 new NonCorrelatedWeight(new double[] { 1 }),\n                                  new InitialGuess(new double[] { 0 }));\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10);\n         Assert.assertEquals(3.0, optimum.getValue()[0], 1e-10);\n             = new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator);\n         optimizer.optimize(new MaxEval(100),\n                            new Target(new double[] { 0 }),\n-                           new Weight(new double[] { 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1 }),\n                            new InitialGuess(new double[] { 0 }),\n                            new ModelFunction(new MultivariateVectorFunction() {\n                                    public double[] value(double[] point) {\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java\n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n import java.io.IOException;\n-import java.io.Serializable;\n import java.util.Arrays;\n+\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n+import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;\n import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;\n+import org.apache.commons.math3.optim.nonlinear.vector.Target;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1 }),\n                                new InitialGuess(new double[] { 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10);\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                                new InitialGuess(new double[] { 0, 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(7, optimum.getPoint()[0], 1e-10);\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1, 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1, 1 }),\n                                new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         for (int i = 0; i < problem.target.length; ++i) {\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                                new InitialGuess(new double[] { 0, 0, 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(1, optimum.getPoint()[0], 1e-10);\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1, 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1, 1 }),\n                                new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(3, optimum.getPoint()[0], 1e-10);\n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            problem.getTarget(),\n-                           new Weight(new double[] { 1, 1, 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                            new InitialGuess(new double[] { 0, 0, 0 }));\n     }\n \n                                problem1.getModelFunction(),\n                                problem1.getModelFunctionJacobian(),\n                                problem1.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1 }),\n                                new InitialGuess(new double[] { 0, 1, 2, 3 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(1, optimum1.getPoint()[0], 1e-10);\n                                problem2.getModelFunction(),\n                                problem2.getModelFunctionJacobian(),\n                                problem2.getTarget(), \n-                               new Weight(new double[] { 1, 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1 }),\n                                new InitialGuess(new double[] { 0, 1, 2, 3 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(-81, optimum2.getPoint()[0], 1e-8);\n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            problem.getTarget(),\n-                           new Weight(new double[] { 1, 1, 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                            new InitialGuess(new double[] { 7, 6, 5, 4 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n     }\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),\n                                new InitialGuess(new double[] { 2, 2, 2, 2, 2, 2 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(3, optimum.getPointRef()[2], 1e-10);\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                                new InitialGuess(new double[] { 1, 1 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(2, optimum.getPointRef()[0], 1e-10);\n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            problem.getTarget(),\n-                           new Weight(new double[] { 1, 1, 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                            new InitialGuess(new double[] { 1, 1 }));\n         Assert.assertTrue(optimizer.getRMS() > 0.1);\n     }\n                                problem.getModelFunction(),\n                                problem.getModelFunctionJacobian(),\n                                problem.getTarget(),\n-                               new Weight(new double[] { 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1 }),\n                                new InitialGuess(new double[] { 0, 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(-1, optimum.getPoint()[0], 1e-10);\n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            problem.getTarget(),\n-                           new Weight(new double[] { 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1 }),\n                            new InitialGuess(new double[] { 0, 0 }));\n     }\n \n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  problem.getTarget(),\n-                                 new Weight(new double[] { 1, 1 }),\n+                                 new NonCorrelatedWeight(new double[] { 1, 1 }),\n                                  new InitialGuess(new double[] { 0, 0 }));\n         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n         Assert.assertEquals(-1, optimum.getPoint()[0], 1e-10);\n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            new Target(new double[] { 1 }),\n-                           new Weight(new double[] { 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1 }),\n                            new InitialGuess(new double[] { 0, 0 }));\n     }\n \n                                  circle.getModelFunction(),\n                                  circle.getModelFunctionJacobian(),\n                                  new Target(new double[] { 0, 0, 0, 0, 0 }),\n-                                 new Weight(new double[] { 1, 1, 1, 1, 1 }),\n+                                 new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),\n                                  new InitialGuess(new double[] { 98.680, 47.345 }));\n         Assert.assertTrue(optimizer.getEvaluations() < 10);\n         double rms = optimizer.getRMS();\n                                      circle.getModelFunction(),\n                                      circle.getModelFunctionJacobian(),\n                                      new Target(target),\n-                                     new Weight(weights),\n+                                     new NonCorrelatedWeight(weights),\n                                      new InitialGuess(new double[] { 98.680, 47.345 }));\n         cov = optimizer.computeCovariances(optimum.getPoint(), 1e-14);\n         Assert.assertEquals(0.0016, cov[0][0], 0.001);\n                                  circle.getModelFunction(),\n                                  circle.getModelFunctionJacobian(),\n                                  new Target(target),\n-                                 new Weight(weights),\n+                                 new NonCorrelatedWeight(weights),\n                                  new InitialGuess(new double[] { -12, -12 }));\n         Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         Assert.assertTrue(optimizer.getEvaluations() < 25);\n                                circle.getModelFunction(),\n                                circle.getModelFunctionJacobian(),\n                                new Target(target),\n-                               new Weight(weights),\n+                               new NonCorrelatedWeight(weights),\n                                new InitialGuess(new double[] { 0, 0 }));\n         Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1e-6);\n         Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1e-6);\n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  new Target(data[1]),\n-                                 new Weight(w),\n+                                 new NonCorrelatedWeight(w),\n                                  new InitialGuess(initial));\n \n         final double[] actual = optimum.getPoint();\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.java\n \n import java.io.IOException;\n import java.util.Arrays;\n-import org.apache.commons.math3.optim.PointVectorValuePair;\n+\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n-import org.junit.Assert;\n \n public class AbstractLeastSquaresOptimizerTest {\n \n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            new Target(y),\n-                           new Weight(w),\n+                           new NonCorrelatedWeight(w),\n                            new InitialGuess(a));\n         final double expected = dataset.getResidualSumOfSquares();\n         final double actual = optimizer.getChiSquare();\n                            problem.getModelFunction(),\n                            problem.getModelFunctionJacobian(),\n                            new Target(y),\n-                           new Weight(w),\n+                           new NonCorrelatedWeight(w),\n                            new InitialGuess(a));\n \n         final double expected = FastMath\n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  new Target(y),\n-                                 new Weight(w),\n+                                 new NonCorrelatedWeight(w),\n                                  new InitialGuess(a));\n \n         final double[] sig = optimizer.computeSigma(optimum.getPoint(), 1e-14);\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.java\n  */\n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n-import java.util.ArrayList;\n-import java.awt.geom.Point2D;\n-import org.apache.commons.math3.optim.PointVectorValuePair;\n+\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n+import org.apache.commons.math3.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n-import org.apache.commons.math3.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n-import org.junit.Assert;\n \n /**\n  * This class demonstrates the main functionality of the\n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  new Target(problem.target()),\n-                                 new Weight(problem.weight()),\n+                                 new NonCorrelatedWeight(problem.weight()),\n                                  new InitialGuess(init));\n             final double[] sigma = optim.computeSigma(optimum.getPoint(), 1e-14);\n \n                        problem.getModelFunction(),\n                        problem.getModelFunctionJacobian(),\n                        new Target(t),\n-                       new Weight(w),\n+                       new NonCorrelatedWeight(w),\n                        new InitialGuess(params));\n \n         return optim.getChiSquare() / (t.length - params.length);\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java\n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n import java.io.IOException;\n+\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n-import org.apache.commons.math3.optim.SimpleVectorValueChecker;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.SimpleVectorValueChecker;\n import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;\n-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.junit.Test;\n \n /**\n                            circle.getModelFunction(),\n                            circle.getModelFunctionJacobian(),\n                            new Target(new double[] { 0, 0, 0, 0, 0 }),\n-                           new Weight(new double[] { 1, 1, 1, 1, 1 }),\n+                           new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),\n                            new InitialGuess(new double[] { 98.680, 47.345 }));\n     }\n \n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java\n \n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n-import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.math3.optim.PointVectorValuePair;\n-import org.apache.commons.math3.optim.InitialGuess;\n-import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;\n-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;\n+\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.linear.SingularMatrixException;\n+import org.apache.commons.math3.optim.InitialGuess;\n+import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.PointVectorValuePair;\n+import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;\n+import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;\n+import org.apache.commons.math3.optim.nonlinear.vector.Target;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n-import org.junit.Ignore;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  problem.getTarget(),\n-                                 new Weight(new double[] { 1, 1, 1 }),\n+                                 new NonCorrelatedWeight(new double[] { 1, 1, 1 }),\n                                  new InitialGuess(new double[] { 0, 0, 0 }));\n         Assert.assertTrue(FastMath.sqrt(optimizer.getTargetSize()) * optimizer.getRMS() > 0.6);\n \n                                problem,\n                                problemJacobian,\n                                new Target(new double[] { 0, 0, 0, 0, 0 }),\n-                               new Weight(new double[] { 1, 1, 1, 1, 1 }),\n+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),\n                                new InitialGuess(new double[] { 98.680, 47.345 }));\n             Assert.assertTrue(!shouldFail);\n         } catch (DimensionMismatchException ee) {\n                                  problem.getModelFunction(),\n                                  problem.getModelFunctionJacobian(),\n                                  new Target(dataPoints[1]),\n-                                 new Weight(weights),\n+                                 new NonCorrelatedWeight(weights),\n                                  new InitialGuess(new double[] { 10, 900, 80, 27, 225 }));\n \n         final double[] solution = optimum.getPoint();\n                                                                 circle.getModelFunction(),\n                                                                 circle.getModelFunctionJacobian(),\n                                                                 new Target(circle.target()),\n-                                                                new Weight(circle.weight()),\n+                                                                new NonCorrelatedWeight(circle.weight()),\n                                                                 new InitialGuess(init));\n \n         final double[] paramFound = optimum.getPoint();\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.java\n \n package org.apache.commons.math3.optim.nonlinear.vector.jacobian;\n \n-import java.io.Serializable;\n import java.util.Arrays;\n+\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n-import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.nonlinear.vector.Target;\n-import org.apache.commons.math3.optim.nonlinear.vector.Weight;\n+import org.apache.commons.math3.optim.PointVectorValuePair;\n import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;\n import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;\n+import org.apache.commons.math3.optim.nonlinear.vector.Target;\n+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n                                      function.getModelFunction(),\n                                      function.getModelFunctionJacobian(),\n                                      new Target(function.getTarget()),\n-                                     new Weight(function.getWeight()),\n+                                     new NonCorrelatedWeight(function.getWeight()),\n                                      new InitialGuess(function.getStartPoint()));\n             Assert.assertFalse(exceptionExpected);\n             function.checkTheoreticalMinCost(optimizer.getRMS());", "timestamp": 1356725798, "metainfo": ""}