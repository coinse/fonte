{"sha": "b9ff3cc758ca15b15ea7aec490f78fdc5c57fbe4", "log": "MATH-621 All \"for\" loops are 0-based (thanks to Dietmar Wolz). \"FortranArray\" replaced by \"ArrayRealVector\"; \"FortranMatrix\" replaced by \"Array2DRowRealMatrix\"; auxiliary classes deleted. \"INDEX_OFFSET\" removed.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n public class BOBYQAOptimizer\n     extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n     implements MultivariateRealOptimizer {\n-    private static final int INDEX_OFFSET = 1; // XXX to become \"0\" when all loops are 0-based.\n     private static final double ZERO = 0d;\n     private static final double ONE = 1d;\n     private static final double TWO = 2d;\n         // requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the\n         // space that is taken by the last array in the argument list of BOBYQB.\n \n-        final FortranArray xbase = new FortranArray(n);\n-        final FortranMatrix xpt = new FortranMatrix(npt, n);\n-        final FortranArray fval = new FortranArray(npt);\n-        final FortranArray xopt = new FortranArray(n);\n-        final FortranArray gopt = new FortranArray(n);\n-        final FortranArray hq = new FortranArray(n * np / 2);\n-        final FortranArray pq = new FortranArray(npt);\n-        final FortranMatrix bmat = new FortranMatrix(ndim, n);\n-        final FortranMatrix zmat = new FortranMatrix(npt, (npt - np));\n+        final ArrayRealVector xbase = new ArrayRealVector(n);\n+        final Array2DRowRealMatrix xpt = new Array2DRowRealMatrix(npt, n);\n+        final ArrayRealVector fval = new ArrayRealVector(npt);\n+        final ArrayRealVector xopt = new ArrayRealVector(n);\n+        final ArrayRealVector gopt = new ArrayRealVector(n);\n+        final ArrayRealVector hq = new ArrayRealVector(n * np / 2);\n+        final ArrayRealVector pq = new ArrayRealVector(npt);\n+        final Array2DRowRealMatrix bmat = new Array2DRowRealMatrix(ndim, n);\n+        final Array2DRowRealMatrix zmat = new Array2DRowRealMatrix(npt, (npt - np));\n         final ArrayRealVector sl = new ArrayRealVector(n);\n         final ArrayRealVector su = new ArrayRealVector(n);\n-        final FortranArray xnew = new FortranArray(n);\n-        final FortranArray xalt = new FortranArray(n);\n-        final FortranArray d__ = new FortranArray(n);\n-        final FortranArray vlag = new FortranArray(ndim);\n+        final ArrayRealVector xnew = new ArrayRealVector(n);\n+        final ArrayRealVector xalt = new ArrayRealVector(n);\n+        final ArrayRealVector d__ = new ArrayRealVector(n);\n+        final ArrayRealVector vlag = new ArrayRealVector(ndim);\n \n         // Return if there is insufficient space between the bounds. Modify the\n         // initial X if necessary in order to avoid conflicts between the bounds\n                       pq,\n                       bmat,\n                       zmat,\n-                      new FortranArray(sl),\n-                      new FortranArray(su),\n+                      sl,\n+                      su,\n                       xnew,\n                       xalt,\n                       d__,\n      * @return\n      */\n     private double bobyqb(\n-            FortranArray xbase, \n-            FortranMatrix xpt,\n-            FortranArray fval,\n-            FortranArray xopt,\n-            FortranArray gopt,\n-            FortranArray hq,\n-            FortranArray pq,\n-            FortranMatrix bmat,\n-            FortranMatrix zmat,\n-            FortranArray sl,\n-            FortranArray su,\n-            FortranArray xnew,\n-            FortranArray xalt,\n-            FortranArray d__,\n-            FortranArray vlag\n+            ArrayRealVector xbase, \n+            Array2DRowRealMatrix xpt,\n+            ArrayRealVector fval,\n+            ArrayRealVector xopt,\n+            ArrayRealVector gopt,\n+            ArrayRealVector hq,\n+            ArrayRealVector pq,\n+            Array2DRowRealMatrix bmat,\n+            Array2DRowRealMatrix zmat,\n+            ArrayRealVector sl,\n+            ArrayRealVector su,\n+            ArrayRealVector xnew,\n+            ArrayRealVector xalt,\n+            ArrayRealVector d__,\n+            ArrayRealVector vlag\n     ) {\n         // System.out.println(\"bobyqb\"); // XXX\n \n         final int nptm = npt - np;\n         final int nh = n * np / 2;\n \n-        final FortranArray work1 = new FortranArray(n);\n-        final FortranArray work2 = new FortranArray(npt);\n-        final FortranArray work3 = new FortranArray(npt);\n+        final ArrayRealVector work1 = new ArrayRealVector(n);\n+        final ArrayRealVector work2 = new ArrayRealVector(npt);\n+        final ArrayRealVector work3 = new ArrayRealVector(npt);\n \n         double cauchy = Double.NaN;\n         double alpha = Double.NaN;\n                xpt, fval, gopt, hq, pq, bmat,\n                 zmat, sl, su);\n         double xoptsq = ZERO;\n-        for (int i = 1; i <= n; i++) {\n+        for (int i = 0; i < n; i++) {\n             xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n             // Computing 2nd power\n             final double deltaOne = xopt.getEntry(i);\n             xoptsq += deltaOne * deltaOne;\n         }\n-        fsave = fval.getEntry(INDEX_OFFSET);\n-        kbase = 1;\n+        fsave = fval.getEntry(0);\n+        kbase = 0;\n \n         // Complete the settings that are required for the iterative procedure.\n \n         case 20: {\n             if (trustRegionCenterInterpolationPointIndex != kbase) {\n                 ih = 0;\n-                for (int j = 1; j <= n; j++) {\n-                    for (int i = 1; i <= j; i++) {\n-                        ++ih;\n+                for (int j = 0; j < n; j++) {\n+                    for (int i = 0; i <= j; i++) {\n                         if (i < j) {\n                             gopt.setEntry(j,  gopt.getEntry(j) + hq.getEntry(ih) * xopt.getEntry(i));\n                         }\n                         gopt.setEntry(i,  gopt.getEntry(i) + hq.getEntry(ih) * xopt.getEntry(j));\n+                        ih++;\n                     }\n                 }\n                 if (getEvaluations() > npt) {\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         temp = ZERO;\n-                        for (int j = 1; j <= n; j++) {\n+                        for (int j = 0; j < n; j++) {\n                             temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n                         }\n                         temp = pq.getEntry(k) * temp;\n-                        for (int i = 1; i <= n; i++) {\n+                        for (int i = 0; i < n; i++) {\n                             gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n                         }\n                     }\n \n         }\n         case 60: {\n-            final FortranArray gnew = new FortranArray(n);\n-            final FortranArray xbdi = new FortranArray(n);\n-            final FortranArray s = new FortranArray(n);\n-            final FortranArray hs = new FortranArray(n);\n-            final FortranArray hred = new FortranArray(n);\n+            final ArrayRealVector gnew = new ArrayRealVector(n);\n+            final ArrayRealVector xbdi = new ArrayRealVector(n);\n+            final ArrayRealVector s = new ArrayRealVector(n);\n+            final ArrayRealVector hs = new ArrayRealVector(n);\n+            final ArrayRealVector hred = new ArrayRealVector(n);\n \n             final double[] dsqCrvmin = trsbox(xpt, xopt, gopt, hq, pq, sl,\n                                               su, delta, xnew, d__, gnew, xbdi, s,\n                     state = 650; break;\n                 }\n                 bdtol = errbig / rho;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     bdtest = bdtol;\n                     if (xnew.getEntry(j) == sl.getEntry(j)) {\n                         bdtest = work1.getEntry(j);\n                         bdtest = -work1.getEntry(j);\n                     }\n                     if (bdtest < bdtol) {\n-                        curv = hq.getEntry((j + j * j) / 2);\n-                        for (int k = 1; k <= npt; k++) {\n+                        curv = hq.getEntry((j + j * j) / 2 - 1);\n+                        for (int k = 0; k < npt; k++) {\n                             // Computing 2nd power\n                             final double d1 = xpt.getEntry(k, j);\n                             curv += pq.getEntry(k) * (d1 * d1);\n             if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                 fracsq = xoptsq * ONE_OVER_FOUR;\n                 sumpq = ZERO;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sumpq += pq.getEntry(k);\n                     sum = -HALF * xoptsq;\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         sum += xpt.getEntry(k, i) * xopt.getEntry(i);\n                     }\n                     work2.setEntry(k, sum);\n                     temp = fracsq - HALF * sum;\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         work1.setEntry(i, bmat.getEntry(k, i));\n                         vlag.setEntry(i, sum * xpt.getEntry(k, i) + temp * xopt.getEntry(i));\n                         ip = npt + i;\n-                        for (int j = 1; j <= i; j++) {\n+                        for (int j = 0; j <= i; j++) {\n                             bmat.setEntry(ip, j,\n                                           bmat.getEntry(ip, j)\n                                           + work1.getEntry(i) * vlag.getEntry(j)\n \n                 // Then the revisions of BMAT that depend on ZMAT are calculated.\n \n-                for (int m = 1; m <= nptm; m++) {\n+                for (int m = 0; m < nptm; m++) {\n                     sumz = ZERO;\n                     sumw = ZERO;\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         sumz += zmat.getEntry(k, m);\n                         vlag.setEntry(k, work2.getEntry(k) * zmat.getEntry(k, m));\n                         sumw += vlag.getEntry(k);\n                     }\n-                    for (int j = 1; j <= n; j++) {\n+                    for (int j = 0; j < n; j++) {\n                         sum = (fracsq * sumz - HALF * sumw) * xopt.getEntry(j);\n-                        for (int k = 1; k <= npt; k++) {\n+                        for (int k = 0; k < npt; k++) {\n                             sum += vlag.getEntry(k) * xpt.getEntry(k, j);\n                         }\n                         work1.setEntry(j, sum);\n-                        for (int k = 1; k <= npt; k++) {\n+                        for (int k = 0; k < npt; k++) {\n                             bmat.setEntry(k, j,\n                                           bmat.getEntry(k, j)\n                                           + sum * zmat.getEntry(k, m));\n                         }\n                     }\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         ip = i + npt;\n                         temp = work1.getEntry(i);\n-                        for (int j = 1; j <= i; j++) {\n+                        for (int j = 0; j <= i; j++) {\n                             bmat.setEntry(ip, j,\n                                           bmat.getEntry(ip, j)\n                                           + temp * work1.getEntry(j));\n                 // to the second derivative parameters of the quadratic model.\n \n                 ih = 0;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     work1.setEntry(j, -HALF * sumpq * xopt.getEntry(j));\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         work1.setEntry(j, work1.getEntry(j) + pq.getEntry(k) * xpt.getEntry(k, j));\n                         xpt.setEntry(k, j, xpt.getEntry(k, j) - xopt.getEntry(j));\n                     }\n-                    for (int i = 1; i <= j; i++) {\n-                        ++ih;\n-                        hq.setEntry(ih,\n+                    for (int i = 0; i <= j; i++) {\n+                         hq.setEntry(ih,\n                                     hq.getEntry(ih)\n                                     + work1.getEntry(i) * xopt.getEntry(j)\n                                     + xopt.getEntry(i) * work1.getEntry(j));\n                         bmat.setEntry(npt + i, j, bmat.getEntry(npt + j, i));\n-                    }\n-                }\n-                for (int i = 1; i <= n; i++) {\n+                        ih++;\n+                    }\n+                }\n+                for (int i = 0; i < n; i++) {\n                     xbase.setEntry(i, xbase.getEntry(i) + xopt.getEntry(i));\n                     xnew.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n                     sl.setEntry(i, sl.getEntry(i) - xopt.getEntry(i));\n \n             xoptsq = ZERO;\n             if (trustRegionCenterInterpolationPointIndex != kbase) {\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n                     // Computing 2nd power\n                     final double d1 = xopt.getEntry(i);\n             alpha = alphaCauchy[0];\n             cauchy = alphaCauchy[1];\n \n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n             }\n \n \n         }\n         case 230: {\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 suma = ZERO;\n                 sumb = ZERO;\n                 sum = ZERO;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     suma += xpt.getEntry(k, j) * d__.getEntry(j);\n                     sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n                     sum += bmat.getEntry(k, j) * d__.getEntry(j);\n                 work2.setEntry(k, suma);\n             }\n             beta = ZERO;\n-            for (int m = 1; m <= nptm; m++) {\n+            for (int m = 0; m < nptm; m++) {\n                 sum = ZERO;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sum += zmat.getEntry(k, m) * work3.getEntry(k);\n                 }\n                 beta -= sum * sum;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     vlag.setEntry(k, vlag.getEntry(k) + sum * zmat.getEntry(k, m));\n                 }\n             }\n             dsq = ZERO;\n             bsum = ZERO;\n             dx = ZERO;\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 // Computing 2nd power\n                 final double d1 = d__.getEntry(j);\n                 dsq += d1 * d1;\n                 sum = ZERO;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sum += work3.getEntry(k) * bmat.getEntry(k, j);\n                 }\n                 bsum += sum * d__.getEntry(j);\n                 jp = npt + j;\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     sum += bmat.getEntry(jp, i) * d__.getEntry(i);\n                 }\n                 vlag.setEntry(jp, sum);\n                 d__1 = vlag.getEntry(knew); // XXX Same statement as a few lines below?\n                 denom = d__1 * d__1 + alpha * beta;\n                 if (denom < cauchy && cauchy > ZERO) {\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         xnew.setEntry(i, xalt.getEntry(i));\n                         d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n                     }\n                 scaden = ZERO;\n                 biglsq = ZERO;\n                 knew = 0;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     if (k == trustRegionCenterInterpolationPointIndex) {\n                         continue;\n                     }\n                     hdiag = ZERO;\n-                    for (int m = 1; m <= nptm; m++) {\n+                    for (int m = 0; m < nptm; m++) {\n                         // Computing 2nd power\n                         final double d1 = zmat.getEntry(k, m);\n                         hdiag += d1 * d1;\n                     d__1 = vlag.getEntry(k);\n                     den = beta * hdiag + d__1 * d__1;\n                     distsq = ZERO;\n-                    for (int j = 1; j <= n; j++) {\n+                    for (int j = 0; j < n; j++) {\n                         // Computing 2nd power\n                         final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n                         distsq += d1 * d1;\n \n         }\n         case 360: {\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 // Computing MIN\n                 // Computing MAX\n-                d__3 = lowerBound[f2jai(i)];\n+                d__3 = lowerBound[i];\n                 d__4 = xbase.getEntry(i) + xnew.getEntry(i);\n                 d__1 = Math.max(d__3, d__4);\n-                d__2 = upperBound[f2jai(i)];\n-                currentBest.setEntry(f2jai(i), Math.min(d__1, d__2));\n+                d__2 = upperBound[i];\n+                currentBest.setEntry(i, Math.min(d__1, d__2));\n                 if (xnew.getEntry(i) == sl.getEntry(i)) {\n-                    currentBest.setEntry(f2jai(i), lowerBound[f2jai(i)]);\n+                    currentBest.setEntry(i, lowerBound[i]);\n                 }\n                 if (xnew.getEntry(i) == su.getEntry(i)) {\n-                    currentBest.setEntry(f2jai(i), upperBound[f2jai(i)]);\n+                    currentBest.setEntry(i, upperBound[i]);\n                 }\n             }\n \n             f = computeObjectiveValue(currentBest.getData());\n-\n+            \n             if (!isMinimize)\n                 f = -f;\n             if (ntrits == -1) {\n             fopt = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n             vquad = ZERO;\n             ih = 0;\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 vquad += d__.getEntry(j) * gopt.getEntry(j);\n-                for (int i = 1; i <= j; i++) {\n-                    ++ih;\n-                    temp = d__.getEntry(i) * d__.getEntry(j);\n+                for (int i = 0; i <= j; i++) {\n+                     temp = d__.getEntry(i) * d__.getEntry(j);\n                     if (i == j) {\n                         temp = HALF * temp;\n                     }\n                     vquad += hq.getEntry(ih) * temp;\n-                }\n-            }\n-            for (int k = 1; k <= npt; k++) {\n+                    ih++;\n+               }\n+            }\n+            for (int k = 0; k < npt; k++) {\n                 // Computing 2nd power\n                 final double d1 = work2.getEntry(k);\n                 final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                     scaden = ZERO;\n                     biglsq = ZERO;\n                     knew = 0;\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         hdiag = ZERO;\n-                        for (int m = 1; m <= nptm; m++) {\n+                        for (int m = 0; m < nptm; m++) {\n                             // Computing 2nd power\n                             final double d1 = zmat.getEntry(k, m);\n                             hdiag += d1 * d1;\n                         d__1 = vlag.getEntry(k);\n                         den = beta * hdiag + d__1 * d__1;\n                         distsq = ZERO;\n-                        for (int j = 1; j <= n; j++) {\n+                        for (int j = 0; j < n; j++) {\n                             // Computing 2nd power\n                             final double d1 = xpt.getEntry(k, j) - xnew.getEntry(j);\n                             distsq += d1 * d1;\n             ih = 0;\n             pqold = pq.getEntry(knew);\n             pq.setEntry(knew, ZERO);\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 temp = pqold * xpt.getEntry(knew, i);\n-                for (int j = 1; j <= i; j++) {\n-                    ++ih;\n+                for (int j = 0; j <= i; j++) {\n                     hq.setEntry(ih, hq.getEntry(ih) + temp * xpt.getEntry(knew, j));\n-                }\n-            }\n-            for (int m = 1; m <= nptm; m++) {\n+                    ih++;\n+                }\n+            }\n+            for (int m = 0; m < nptm; m++) {\n                 temp = diff * zmat.getEntry(knew, m);\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     pq.setEntry(k, pq.getEntry(k) + temp * zmat.getEntry(k, m));\n                 }\n             }\n             // the old XOPT that are caused by the updating of the quadratic model.\n \n             fval.setEntry(knew,  f);\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 xpt.setEntry(knew, i, xnew.getEntry(i));\n                 work1.setEntry(i, bmat.getEntry(knew, i));\n             }\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 suma = ZERO;\n-                for (int m = 1; m <= nptm; m++) {\n+                for (int m = 0; m < nptm; m++) {\n                     suma += zmat.getEntry(knew, m) * zmat.getEntry(k, m);\n                 }\n                 sumb = ZERO;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n                 }\n                 temp = suma * sumb;\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     work1.setEntry(i, work1.getEntry(i) + temp * xpt.getEntry(k, i));\n                 }\n             }\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 gopt.setEntry(i, gopt.getEntry(i) + diff * work1.getEntry(i));\n             }\n \n                 trustRegionCenterInterpolationPointIndex = knew;\n                 xoptsq = ZERO;\n                 ih = 0;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     xopt.setEntry(j, xnew.getEntry(j));\n                     // Computing 2nd power\n                     final double d1 = xopt.getEntry(j);\n                     xoptsq += d1 * d1;\n-                    for (int i = 1; i <= j; i++) {\n-                        ++ih;\n+                    for (int i = 0; i <= j; i++) {\n                         if (i < j) {\n                             gopt.setEntry(j, gopt.getEntry(j) + hq.getEntry(ih) * d__.getEntry(i));\n                         }\n                         gopt.setEntry(i, gopt.getEntry(i) + hq.getEntry(ih) * d__.getEntry(j));\n-                    }\n-                }\n-                for (int k = 1; k <= npt; k++) {\n+                        ih++;\n+                    }\n+                }\n+                for (int k = 0; k < npt; k++) {\n                     temp = ZERO;\n-                    for (int j = 1; j <= n; j++) {\n+                    for (int j = 0; j < n; j++) {\n                         temp += xpt.getEntry(k, j) * d__.getEntry(j);\n                     }\n                     temp = pq.getEntry(k) * temp;\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n                     }\n                 }\n             // into VLAG(NPT+I), I=1,2,...,N.\n \n             if (ntrits > 0) {\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     vlag.setEntry(k, fval.getEntry(k) - fval.getEntry(trustRegionCenterInterpolationPointIndex));\n                     work3.setEntry(k, ZERO);\n                 }\n-                for (int j = 1; j <= nptm; j++) {\n+                for (int j = 0; j < nptm; j++) {\n                     sum = ZERO;\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         sum += zmat.getEntry(k, j) * vlag.getEntry(k);\n                     }\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         work3.setEntry(k, work3.getEntry(k) + sum * zmat.getEntry(k, j));\n                     }\n                 }\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sum = ZERO;\n-                    for (int j = 1; j <= n; j++) {\n+                    for (int j = 0; j < n; j++) {\n                         sum += xpt.getEntry(k, j) * xopt.getEntry(j);\n                     }\n                     work2.setEntry(k, work3.getEntry(k));\n                 }\n                 gqsq = ZERO;\n                 gisq = ZERO;\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     sum = ZERO;\n-                    for (int k = 1; k <= npt; k++) {\n+                    for (int k = 0; k < npt; k++) {\n                         sum += bmat.getEntry(k, i) *\n                             vlag.getEntry(k) + xpt.getEntry(k, i) * work3.getEntry(k);\n                     }\n                     itest = 0;\n                 }\n                 if (itest >= 3) {\n-                    for (int i = 1, max = Math.max(npt, nh); i <= max; i++) {\n-                        if (i <= n) {\n+                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n+                        if (i < n) {\n                             gopt.setEntry(i, vlag.getEntry(npt + i));\n                         }\n-                        if (i <= npt) {\n+                        if (i < npt) {\n                             pq.setEntry(i, work2.getEntry(i));\n                         }\n-                        if (i <= nh) {\n+                        if (i < nh) {\n                             hq.setEntry(i, ZERO);\n                         }\n                         itest = 0;\n             distsq = Math.max(d__1, d__2);\n         }\n         case 650: {\n-            knew = 0;\n-            for (int k = 1; k <= npt; k++) {\n+            knew = -1;\n+            for (int k = 0; k < npt; k++) {\n                 sum = ZERO;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     // Computing 2nd power\n                     final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n                     sum += d1 * d1;\n             // another trust region iteration, unless the calculations with the\n             // current RHO are complete.\n \n-            if (knew > 0) {\n+            if (knew >= 0) {\n                 dist = Math.sqrt(distsq);\n                 if (ntrits == -1) {\n                     // Computing MIN\n         }\n         case 720: {\n             if (fval.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     // Computing MIN\n                     // Computing MAX\n-                    d__3 = lowerBound[f2jai(i)];\n+                    d__3 = lowerBound[i];\n                     d__4 = xbase.getEntry(i) + xopt.getEntry(i);\n                     d__1 = Math.max(d__3, d__4);\n-                    d__2 = upperBound[f2jai(i)];\n-                    currentBest.setEntry(f2jai(i), Math.min(d__1, d__2));\n+                    d__2 = upperBound[i];\n+                    currentBest.setEntry(i, Math.min(d__1, d__2));\n                     if (xopt.getEntry(i) == sl.getEntry(i)) {\n-                        currentBest.setEntry(f2jai(i), lowerBound[f2jai(i)]);\n+                        currentBest.setEntry(i, lowerBound[i]);\n                     }\n                     if (xopt.getEntry(i) == su.getEntry(i)) {\n-                        currentBest.setEntry(f2jai(i), upperBound[f2jai(i)]);\n+                        currentBest.setEntry(i, upperBound[i]);\n                     }\n                 }\n                 f = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n      * @param xalt\n      */\n     private double[] altmov(\n-            FortranMatrix xpt,\n-            FortranArray xopt,\n-            FortranMatrix bmat,\n-            FortranMatrix zmat,\n-            FortranArray sl,\n-            FortranArray su,\n+            Array2DRowRealMatrix xpt,\n+            ArrayRealVector xopt,\n+            Array2DRowRealMatrix bmat,\n+            Array2DRowRealMatrix zmat,\n+            ArrayRealVector sl,\n+            ArrayRealVector su,\n             int knew,\n             double adelt,\n-            FortranArray xnew,\n-            FortranArray xalt\n+            ArrayRealVector xnew,\n+            ArrayRealVector xalt\n     ) {\n         // System.out.println(\"altmov\"); // XXX\n \n         final int npt = numberOfInterpolationPoints;\n         final int ndim = bmat.getRowDimension();\n \n-        final FortranArray glag = new FortranArray(n);\n-        final FortranArray hcol = new FortranArray(npt);\n-\n-        final FortranArray work1 = new FortranArray(n);\n-        final FortranArray work2 = new FortranArray(n);\n+        final ArrayRealVector glag = new ArrayRealVector(n);\n+        final ArrayRealVector hcol = new ArrayRealVector(npt);\n+\n+        final ArrayRealVector work1 = new ArrayRealVector(n);\n+        final ArrayRealVector work2 = new ArrayRealVector(n);\n \n         double alpha = Double.NaN;\n         double cauchy = Double.NaN;\n \n         // Function Body\n         const__ = ONE + Math.sqrt(2.);\n-        for (int k = 1; k <= npt; k++) {\n+        for (int k = 0; k < npt; k++) {\n             hcol.setEntry(k, ZERO);\n         }\n-        for (int j = 1, max = npt - n - 1; j <= max; j++) {\n+        for (int j = 0, max = npt - n - 1; j < max; j++) {\n             temp = zmat.getEntry(knew, j);\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 hcol.setEntry(k, hcol.getEntry(k) + temp * zmat.getEntry(k, j));\n             }\n         }\n \n         // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n \n-        for (int i = 1; i <= n; i++) {\n+        for (int i = 0; i < n; i++) {\n             glag.setEntry(i, bmat.getEntry(knew, i));\n         }\n-        for (int k = 1; k <= npt; k++) {\n+        for (int k = 0; k < npt; k++) {\n             temp = ZERO;\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n             }\n             temp = hcol.getEntry(k) * temp;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 glag.setEntry(i, glag.getEntry(i) + temp * xpt.getEntry(k, i));\n             }\n         }\n         // will be set to the largest admissible value of PREDSQ that occurs.\n \n         presav = ZERO;\n-        for (int k = 1; k <= npt; k++) {\n+        for (int k = 0; k < npt; k++) {\n             if (k == trustRegionCenterInterpolationPointIndex) {\n                 continue;\n             }\n             dderiv = ZERO;\n             distsq = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 temp = xpt.getEntry(k, i) - xopt.getEntry(i);\n                 dderiv += glag.getEntry(i) * temp;\n                 distsq += temp * temp;\n \n             // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n \n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 temp = xpt.getEntry(k, i) - xopt.getEntry(i);\n                 if (temp > ZERO) {\n                     if (slbd * temp < sl.getEntry(i) - xopt.getEntry(i)) {\n                         slbd = (sl.getEntry(i) - xopt.getEntry(i)) / temp;\n-                        ilbd = -i;\n+                        ilbd = -i - 1;\n                     }\n                     if (subd * temp > su.getEntry(i) - xopt.getEntry(i)) {\n                         // Computing MAX\n                         d__1 = sumin;\n                         d__2 = (su.getEntry(i) - xopt.getEntry(i)) / temp;\n                         subd = Math.max(d__1, d__2);\n-                        iubd = i;\n+                        iubd = i+1;\n                     }\n                 } else if (temp < ZERO) {\n                     if (slbd * temp > su.getEntry(i) - xopt.getEntry(i)) {\n                         slbd = (su.getEntry(i) - xopt.getEntry(i)) / temp;\n-                        ilbd = i;\n+                        ilbd = i+1;\n                     }\n                     if (subd * temp < sl.getEntry(i) - xopt.getEntry(i)) {\n                         // Computing MAX\n                         d__1 = sumin;\n                         d__2 = (sl.getEntry(i) - xopt.getEntry(i)) / temp;\n                         subd = Math.max(d__1, d__2);\n-                        iubd = -i;\n+                        iubd = -i - 1;\n                     }\n                 }\n             }\n \n         // Construct XNEW in a way that satisfies the bound constraints exactly.\n \n-        for (int i = 1; i <= n; i++) {\n+        for (int i = 0; i < n; i++) {\n             temp = xopt.getEntry(i) + stpsav * (xpt.getEntry(ksav, i) - xopt.getEntry(i));\n             // Computing MAX\n             // Computing MIN\n             xnew.setEntry(i, Math.max(d__1, d__2));\n         }\n         if (ibdsav < 0) {\n-            xnew.setEntry(-ibdsav, sl.getEntry(-ibdsav));\n+            xnew.setEntry(-ibdsav - 1, sl.getEntry(-ibdsav - 1));\n         }\n         if (ibdsav > 0) {\n-            xnew.setEntry(ibdsav, su.getEntry(ibdsav));\n+            xnew.setEntry(ibdsav - 1, su.getEntry(ibdsav - 1));\n         }\n \n         // Prepare for the iterative method that assembles the constrained Cauchy\n         L100: for(;;) {\n             wfixsq = ZERO;\n             ggfree = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 work1.setEntry(i, ZERO);\n                 // Computing MIN\n                 d__1 = xopt.getEntry(i) - sl.getEntry(i);\n                     wsqsav = wfixsq;\n                     step = Math.sqrt(temp / ggfree);\n                     ggfree = ZERO;\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         if (work1.getEntry(i) == bigstp) {\n                             temp = xopt.getEntry(i) - step * glag.getEntry(i);\n                             if (temp <= sl.getEntry(i)) {\n             // except that W may be scaled later.\n \n             gw = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 if (work1.getEntry(i) == bigstp) {\n                     work1.setEntry(i, -step * glag.getEntry(i));\n                     final double min = Math.min(su.getEntry(i),\n             // the square of this function.\n \n             curv = ZERO;\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 temp = ZERO;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     temp += xpt.getEntry(k, j) * work1.getEntry(j);\n                 }\n                 curv += hcol.getEntry(k) * temp * temp;\n             }\n             if (curv > -gw && curv < -const__ * gw) {\n                 scale = -gw / curv;\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     temp = xopt.getEntry(i) + scale * work1.getEntry(i);\n                     // Computing MAX\n                     // Computing MIN\n             // is chosen is the one that gives the larger value of CAUCHY.\n \n             if (iflag == 0) {\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     glag.setEntry(i, -glag.getEntry(i));\n                     work2.setEntry(i, xalt.getEntry(i));\n                 }\n                 break L100;\n             }} // end L100\n         if (csave > cauchy) {\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 xalt.setEntry(i, work2.getEntry(i));\n             }\n             cauchy = csave;\n      */\n     private void prelim(\n             ArrayRealVector currentBest,\n-            FortranArray xbase,\n-            FortranMatrix xpt,\n-            FortranArray fval,\n-            FortranArray gopt,\n-            FortranArray hq,\n-            FortranArray pq,\n-            FortranMatrix bmat,\n-            FortranMatrix zmat,\n-            FortranArray sl,\n-            FortranArray su\n+            ArrayRealVector xbase,\n+            Array2DRowRealMatrix xpt,\n+            ArrayRealVector fval,\n+            ArrayRealVector gopt,\n+            ArrayRealVector hq,\n+            ArrayRealVector pq,\n+            Array2DRowRealMatrix bmat,\n+            Array2DRowRealMatrix zmat,\n+            ArrayRealVector sl,\n+            ArrayRealVector su\n     ) {\n         // System.out.println(\"prelim\"); // XXX\n \n         // Set XBASE to the initial vector of variables, and set the initial\n         // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n \n-        for (int j = 1; j <= n; j++) {\n-            xbase.setEntry(j, currentBest.getEntry(f2jai(j)));\n-            for (int k = 1; k <= npt; k++) {\n+        for (int j = 0; j < n; j++) {\n+            xbase.setEntry(j, currentBest.getEntry(j));\n+            for (int k = 0; k < npt; k++) {\n                 xpt.setEntry(k, j, ZERO);\n             }\n-            for (int i = 1; i <= ndim; i++) {\n+            for (int i = 0; i < ndim; i++) {\n                 bmat.setEntry(i, j, ZERO);\n             }\n         }\n-        for (int i = 1, max = n * np / 2; i <= max; i++) {\n+        for (int i = 0, max = n * np / 2; i < max; i++) {\n             hq.setEntry(i, ZERO);\n         }\n-        for (int k = 1; k <= npt; k++) {\n+        for (int k = 0; k < npt; k++) {\n             pq.setEntry(k, ZERO);\n-            for (int j = 1, max = npt - np; j <= max; j++) {\n+            for (int j = 0, max = npt - np; j < max; j++) {\n                 zmat.setEntry(k, j, ZERO);\n             }\n         }\n         do {\n             nfm = getEvaluations();\n             nfx = getEvaluations() - n;\n-            final int curNumEvalPlusOne = getEvaluations() + 1;\n+            final int nfmm = nfm - 1;\n+            final int nfxm = nfx - 1;\n             if (nfm <= n << 1) {\n                 if (nfm >= 1 && nfm <= n) {\n                     stepa = initialTrustRegionRadius;\n-                    if (su.getEntry(nfm) == ZERO) {\n+                    if (su.getEntry(nfmm) == ZERO) {\n                         stepa = -stepa;\n                     }\n-                    xpt.setEntry(curNumEvalPlusOne, nfm, stepa);\n+                    xpt.setEntry(nfm, nfmm, stepa);\n                 } else if (nfm > n) {\n-                    stepa = xpt.getEntry(curNumEvalPlusOne - n, nfx);\n+                    stepa = xpt.getEntry(nfx, nfxm);\n                     stepb = -initialTrustRegionRadius;\n-                    if (sl.getEntry(nfx) == ZERO) {\n+                    if (sl.getEntry(nfxm) == ZERO) {\n                         // Computing MIN\n                         final double d1 = TWO * initialTrustRegionRadius;\n-                        stepb = Math.min(d1, su.getEntry(nfx));\n-                    }\n-                    if (su.getEntry(nfx) == ZERO) {\n+                        stepb = Math.min(d1, su.getEntry(nfxm));\n+                    }\n+                    if (su.getEntry(nfxm) == ZERO) {\n                         // Computing MAX\n                         final double d1 = -TWO * initialTrustRegionRadius;\n-                        stepb = Math.max(d1, sl.getEntry(nfx));\n-                    }\n-                    xpt.setEntry(curNumEvalPlusOne, nfx, stepb);\n+                        stepb = Math.max(d1, sl.getEntry(nfxm));\n+                    }\n+                    xpt.setEntry(nfm, nfxm, stepb);\n                 }\n             } else {\n                 itemp = (nfm - np) / n;\n                     jpt = ipt - n;\n                     ipt = itemp;\n                 }\n-                xpt.setEntry(curNumEvalPlusOne, ipt, xpt.getEntry(ipt + 1, ipt));\n-                xpt.setEntry(curNumEvalPlusOne, jpt, xpt.getEntry(jpt + 1, jpt));\n+                xpt.setEntry(nfm, ipt, xpt.getEntry(ipt, ipt));\n+                xpt.setEntry(nfm, jpt, xpt.getEntry(jpt, jpt));\n             }\n \n             // Calculate the next value of F. The least function value so far and\n             // its index are required.\n \n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 // Computing MIN\n                 // Computing MAX\n-                d__3 = lowerBound[f2jai(j)];\n-                d__4 = xbase.getEntry(j) + xpt.getEntry(curNumEvalPlusOne, j);\n+                d__3 = lowerBound[j];\n+                d__4 = xbase.getEntry(j) + xpt.getEntry(nfm, j);\n                 d__1 = Math.max(d__3, d__4);\n-                d__2 = upperBound[f2jai(j)];\n-                currentBest.setEntry(f2jai(j), Math.min(d__1, d__2));\n-                if (xpt.getEntry(curNumEvalPlusOne, j) == sl.getEntry(j)) {\n-                    currentBest.setEntry(f2jai(j), lowerBound[f2jai(j)]);\n-                }\n-                if (xpt.getEntry(curNumEvalPlusOne, j) == su.getEntry(j)) {\n-                    currentBest.setEntry(f2jai(j), upperBound[f2jai(j)]);\n+                d__2 = upperBound[j];\n+                currentBest.setEntry(j, Math.min(d__1, d__2));\n+                if (xpt.getEntry(nfm, j) == sl.getEntry(j)) {\n+                    currentBest.setEntry(j, lowerBound[j]);\n+                }\n+                if (xpt.getEntry(nfm, j) == su.getEntry(j)) {\n+                    currentBest.setEntry(j, upperBound[j]);\n                 }\n             }\n \n \n             if (!isMinimize)\n                 f = -f;\n-            fval.setEntry(getEvaluations(), f);\n+            fval.setEntry(nfm, f);\n             if (getEvaluations() == 1) {\n                 fbeg = f;\n-                trustRegionCenterInterpolationPointIndex = 1;\n+                trustRegionCenterInterpolationPointIndex = 0;\n             } else if (f < fval.getEntry(trustRegionCenterInterpolationPointIndex)) {\n-                trustRegionCenterInterpolationPointIndex = getEvaluations();\n+                trustRegionCenterInterpolationPointIndex = nfm;\n             }\n \n             // Set the nonzero initial elements of BMAT and the quadratic model in the\n \n             if (getEvaluations() <= (n << 1) + 1) {\n                 if (getEvaluations() >= 2 && getEvaluations() <= n + 1) {\n-                    gopt.setEntry( nfm, (f - fbeg) / stepa);\n+                    gopt.setEntry(nfmm, (f - fbeg) / stepa);\n                     if (npt < getEvaluations() + n) {\n-                        bmat.setEntry(INDEX_OFFSET, nfm, -ONE / stepa);\n-                        bmat.setEntry( getEvaluations(), nfm, ONE / stepa);\n-                        bmat.setEntry( npt + nfm, nfm, -HALF * rhosq);\n+                        bmat.setEntry(0, nfmm, -ONE / stepa);\n+                        bmat.setEntry(nfm, nfmm, ONE / stepa);\n+                        bmat.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                     }\n                 } else if (getEvaluations() >= n + 2) {\n-                    ih = nfx * (nfx + 1) / 2;\n+                    ih = nfx * (nfx + 1) / 2 - 1;\n                     temp = (f - fbeg) / stepb;\n                     diff = stepb - stepa;\n-                    hq.setEntry(ih, TWO * (temp - gopt.getEntry(nfx)) / diff);\n-                    gopt.setEntry(nfx, (gopt.getEntry(nfx) * stepb - temp * stepa) / diff);\n+                    hq.setEntry(ih, TWO * (temp - gopt.getEntry(nfxm)) / diff);\n+                    gopt.setEntry(nfxm, (gopt.getEntry(nfxm) * stepb - temp * stepa) / diff);\n                     if (stepa * stepb < ZERO) {\n-                        if (f < fval.getEntry(getEvaluations() - n)) {\n-                            fval.setEntry(getEvaluations(), fval.getEntry(getEvaluations() - n));\n-                            fval.setEntry(getEvaluations() - n, f);\n-                            if (trustRegionCenterInterpolationPointIndex == getEvaluations()) {\n-                                trustRegionCenterInterpolationPointIndex = getEvaluations() - n;\n+                        if (f < fval.getEntry(nfm - n)) {\n+                            fval.setEntry(nfm, fval.getEntry(nfm - n));\n+                            fval.setEntry(nfm - n, f);\n+                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n+                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                             }\n-                            xpt.setEntry(getEvaluations() - n, nfx, stepb);\n-                            xpt.setEntry(getEvaluations(), nfx, stepa);\n+                            xpt.setEntry(nfm - n, nfxm, stepb);\n+                            xpt.setEntry(nfm, nfxm, stepa);\n                         }\n                     }\n-                    bmat.setEntry(INDEX_OFFSET, nfx, -(stepa + stepb) / (stepa * stepb));\n-                    bmat.setEntry( getEvaluations(), nfx, -HALF /\n-                                   xpt.getEntry(getEvaluations() - n, nfx));\n-                    bmat.setEntry( getEvaluations() - n, nfx, -bmat.getEntry(INDEX_OFFSET, nfx) -\n-                                   bmat.getEntry( getEvaluations(), nfx));\n-                    zmat.setEntry(INDEX_OFFSET, nfx, Math.sqrt(TWO) / (stepa * stepb));\n-                    zmat.setEntry( getEvaluations(), nfx, Math.sqrt(HALF) / rhosq);\n-                    zmat.setEntry( getEvaluations() - n, nfx, -zmat.getEntry(INDEX_OFFSET, nfx) -\n-                                   zmat.getEntry( getEvaluations(), nfx));\n+                    bmat.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n+                    bmat.setEntry(nfm, nfxm, -HALF /\n+                                   xpt.getEntry(nfm - n, nfxm));\n+                    bmat.setEntry(nfm - n, nfxm, -bmat.getEntry(0, nfxm) -\n+                                   bmat.getEntry(nfm, nfxm));\n+                    zmat.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n+                    zmat.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n+                    zmat.setEntry(nfm - n, nfxm, -zmat.getEntry(0, nfxm) -\n+                                   zmat.getEntry(nfm, nfxm));\n                 }\n \n                 // Set the off-diagonal second derivatives of the Lagrange functions and\n                 // the initial quadratic model.\n \n             } else {\n-                ih = ipt * (ipt - 1) / 2 + jpt;\n-                zmat.setEntry(INDEX_OFFSET, nfx, recip);\n-                zmat.setEntry( getEvaluations(), nfx, recip);\n-                zmat.setEntry(ipt + 1, nfx, -recip);\n-                zmat.setEntry( jpt + 1, nfx, -recip);\n-                temp = xpt.getEntry(getEvaluations(), ipt) * xpt.getEntry(getEvaluations(), jpt);\n-                hq.setEntry(ih, (fbeg - fval.getEntry(ipt + 1) - fval.getEntry(jpt + 1) + f) / temp);\n+                ih = ipt * (ipt - 1) / 2 + jpt - 1;\n+                zmat.setEntry(0, nfxm, recip);\n+                zmat.setEntry(nfm, nfxm, recip);\n+                zmat.setEntry(ipt, nfxm, -recip);\n+                zmat.setEntry(jpt, nfxm, -recip);\n+                temp = xpt.getEntry(nfm, ipt - 1) * xpt.getEntry(nfm, jpt - 1);\n+                hq.setEntry(ih, (fbeg - fval.getEntry(ipt) - fval.getEntry(jpt) + f) / temp);\n             }\n         } while (getEvaluations() < npt);\n     } // prelim\n      * @param vlag\n      */\n     private void rescue(\n-            FortranArray xbase,\n-            FortranMatrix xpt,\n-            FortranArray fval,\n-            FortranArray xopt,\n-            FortranArray gopt,\n-            FortranArray hq,\n-            FortranArray pq,\n-            FortranMatrix bmat,\n-            FortranMatrix zmat,\n-            FortranArray sl,\n-            FortranArray su,\n+            ArrayRealVector xbase,\n+            Array2DRowRealMatrix xpt,\n+            ArrayRealVector fval,\n+            ArrayRealVector xopt,\n+            ArrayRealVector gopt,\n+            ArrayRealVector hq,\n+            ArrayRealVector pq,\n+            Array2DRowRealMatrix bmat,\n+            Array2DRowRealMatrix zmat,\n+            ArrayRealVector sl,\n+            ArrayRealVector su,\n             double delta,\n-            FortranArray vlag\n+            ArrayRealVector vlag\n     ) {\n         // System.out.println(\"rescue\"); // XXX\n \n         final int npt = numberOfInterpolationPoints;\n         final int ndim = bmat.getRowDimension();\n \n-        final FortranMatrix ptsaux = new FortranMatrix(n, 2);\n-        final FortranArray ptsid = new FortranArray(npt);\n-\n-        final FortranArray work1 = new FortranArray(npt); // Originally: w(1 .. npt).\n-        final FortranArray work2 = new FortranArray(n); // Originally: w(npt+1 .. npt+n).\n-        final FortranArray work3 = new FortranArray(npt); // Originally: w(npt+n+1 .. npt+n+npt).\n+        final Array2DRowRealMatrix ptsaux = new Array2DRowRealMatrix(n, 2);\n+        final ArrayRealVector ptsid = new ArrayRealVector(npt);\n+\n+        final ArrayRealVector work1 = new ArrayRealVector(npt); // Originally: w(1 .. npt).\n+        final ArrayRealVector work2 = new ArrayRealVector(n); // Originally: w(npt+1 .. npt+n).\n+        final ArrayRealVector work3 = new ArrayRealVector(npt); // Originally: w(npt+n+1 .. npt+n+npt).\n \n         final int np = n + 1;\n         final double sfrac = HALF / (double) np;\n \n         sumpq = ZERO;\n         winc = ZERO;\n-        for (int k = 1; k <= npt; k++) {\n+        for (int k = 0; k < npt; k++) {\n             distsq = ZERO;\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 xpt.setEntry(k, j, xpt.getEntry(k, j) - xopt.getEntry(j));\n                 // Computing 2nd power\n                 final double d1 = xpt.getEntry(k, j);\n             sumpq += pq.getEntry(k);\n             work3.setEntry(k, distsq);\n             winc = Math.max(winc, distsq);\n-            for (int j = 1; j <= nptm; j++) {\n+            for (int j = 0; j < nptm; j++) {\n                 zmat.setEntry(k, j, ZERO);\n             }\n         }\n         // after XBASE has been shifted to the trust region centre.\n \n         ih = 0;\n-        for (int j = 1; j <= n; j++) {\n+        for (int j = 0; j < n; j++) {\n             work2.setEntry(j, HALF * sumpq * xopt.getEntry(j));\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 work2.setEntry(j, work2.getEntry(j) + pq.getEntry(k) * xpt.getEntry(k, j));\n             }\n-            for (int i = 1; i <= j; i++) {\n-                ++ih;\n+            for (int i = 0; i <= j; i++) {\n                 hq.setEntry(ih, hq.getEntry(ih) + work2.getEntry(i) * xopt.getEntry(j) + work2.getEntry(j) * xopt.getEntry(i));\n+                ih++;\n             }\n         }\n \n         // Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and\n         // also set the elements of PTSAUX.\n \n-        for (int j = 1; j <= n; j++) {\n+        for (int j = 0; j < n; j++) {\n             xbase.setEntry(j, xbase.getEntry(j) + xopt.getEntry(j));\n             sl.setEntry(j, sl.getEntry(j) - xopt.getEntry(j));\n             su.setEntry(j, su.getEntry(j) - xopt.getEntry(j));\n             // Computing MIN\n             d__1 = delta;\n             d__2 = su.getEntry(j);\n-            ptsaux.setEntry(j, INDEX_OFFSET, Math.min(d__1, d__2));\n+            ptsaux.setEntry(j, 0, Math.min(d__1, d__2));\n             // Computing MAX\n             d__1 = -delta;\n             d__2 = sl.getEntry(j);\n-            ptsaux.setEntry(j, INDEX_OFFSET + 1, Math.max(d__1, d__2));\n-            if (ptsaux.getEntry(j, INDEX_OFFSET) + ptsaux.getEntry(j, INDEX_OFFSET + 1) < ZERO) {\n-                temp = ptsaux.getEntry(j, INDEX_OFFSET);\n-                ptsaux.setEntry(j, INDEX_OFFSET, ptsaux.getEntry(j, INDEX_OFFSET + 1));\n-                ptsaux.setEntry(j, INDEX_OFFSET + 1, temp);\n-            }\n-            d__2 = ptsaux.getEntry(j, INDEX_OFFSET + 1);\n-            d__1 = ptsaux.getEntry(j, INDEX_OFFSET);\n+            ptsaux.setEntry(j, 1, Math.max(d__1, d__2));\n+            if (ptsaux.getEntry(j, 0) + ptsaux.getEntry(j, 1) < ZERO) {\n+                temp = ptsaux.getEntry(j, 0);\n+                ptsaux.setEntry(j, 0, ptsaux.getEntry(j, 1));\n+                ptsaux.setEntry(j, 1, temp);\n+            }\n+            d__2 = ptsaux.getEntry(j, 1);\n+            d__1 = ptsaux.getEntry(j, 0);\n             if (Math.abs(d__2) < HALF * Math.abs(d__1)) {\n-                ptsaux.setEntry(j, INDEX_OFFSET + 1, HALF * ptsaux.getEntry(j, INDEX_OFFSET));\n-            }\n-            for (int i = 1; i <= ndim; i++) {\n+                ptsaux.setEntry(j, 1, HALF * ptsaux.getEntry(j, 0));\n+            }\n+            for (int i = 0; i < ndim; i++) {\n                 bmat.setEntry(i, j, ZERO);\n             }\n         }\n         // along a coordinate direction from XOPT, and set the corresponding\n         // nonzero elements of BMAT and ZMAT.\n \n-        ptsid.setEntry(INDEX_OFFSET, sfrac);\n-        for (int j = 1; j <= n; j++) {\n+        ptsid.setEntry(0, sfrac);\n+        for (int j = 0; j < n; j++) {\n             jp = j + 1;\n             jpn = jp + n;\n-            ptsid.setEntry(jp, (double) j + sfrac);\n+            ptsid.setEntry(jp, 1.0 + j + sfrac);\n             if (jpn <= npt) {\n-                ptsid.setEntry(jpn, (double) j / (double) np + sfrac);\n-                temp = ONE / (ptsaux.getEntry(j, INDEX_OFFSET) - ptsaux.getEntry(j, INDEX_OFFSET + 1));\n-                bmat.setEntry(jp, j, -temp + ONE / ptsaux.getEntry(j, INDEX_OFFSET));\n-                bmat.setEntry(jpn, j, temp + ONE / ptsaux.getEntry(j, INDEX_OFFSET + 1));\n-                bmat.setEntry(INDEX_OFFSET, j, -bmat.getEntry(jp, j) - bmat.getEntry(jpn, j));\n-                final double d1 = ptsaux.getEntry(j, INDEX_OFFSET) * ptsaux.getEntry(j, INDEX_OFFSET + 1);\n-                zmat.setEntry(INDEX_OFFSET, j,  Math.sqrt(TWO) / Math.abs(d1));\n-                zmat.setEntry(jp, j, zmat.getEntry(INDEX_OFFSET, j) *\n-                        ptsaux.getEntry(j, INDEX_OFFSET + 1) * temp);\n-                zmat.setEntry(jpn, j, -zmat.getEntry(INDEX_OFFSET, j) *\n-                        ptsaux.getEntry(j, INDEX_OFFSET) * temp);\n+                ptsid.setEntry(jpn, (1.0+j) / (double) np + sfrac);\n+                temp = ONE / (ptsaux.getEntry(j, 0) - ptsaux.getEntry(j, 1));\n+                bmat.setEntry(jp, j, -temp + ONE / ptsaux.getEntry(j, 0));\n+                bmat.setEntry(jpn, j, temp + ONE / ptsaux.getEntry(j, 1));\n+                bmat.setEntry(0, j, -bmat.getEntry(jp, j) - bmat.getEntry(jpn, j));\n+                final double d1 = ptsaux.getEntry(j, 0) * ptsaux.getEntry(j, 1);\n+                zmat.setEntry(0, j,  Math.sqrt(TWO) / Math.abs(d1));\n+                zmat.setEntry(jp, j, zmat.getEntry(0, j) *\n+                        ptsaux.getEntry(j, 1) * temp);\n+                zmat.setEntry(jpn, j, -zmat.getEntry(0, j) *\n+                        ptsaux.getEntry(j, 0) * temp);\n             } else {\n-                bmat.setEntry(INDEX_OFFSET, j, -ONE / ptsaux.getEntry(j, INDEX_OFFSET));\n-                bmat.setEntry(jp, j, ONE / ptsaux.getEntry(j, INDEX_OFFSET));\n+                bmat.setEntry(0, j, -ONE / ptsaux.getEntry(j, 0));\n+                bmat.setEntry(jp, j, ONE / ptsaux.getEntry(j, 0));\n                 // Computing 2nd power\n-                final double d1 = ptsaux.getEntry(j, INDEX_OFFSET);\n+                final double d1 = ptsaux.getEntry(j, 0);\n                 bmat.setEntry(j + npt, j, -HALF * (d1 * d1));\n             }\n         }\n         // Set any remaining identifiers with their nonzero elements of ZMAT.\n \n         if (npt >= n + np) {\n-            for (int k = np << 1; k <= npt; k++) {\n+           for (int k = np << 1; k <= npt; k++) {\n                 int iw = (int) (((double) (k - np) - HALF) / (double) n);\n                 ip = k - np - iw * n;\n                 iq = ip + iw;\n                 }\n                 ptsid.setEntry(k, (double) ip + (double) iq / (double) np +\n                         sfrac);\n-                temp = ONE / (ptsaux.getEntry(ip, INDEX_OFFSET) * ptsaux.getEntry(iq, INDEX_OFFSET));\n-                zmat.setEntry(INDEX_OFFSET, (k - np), temp);\n+                temp = ONE / (ptsaux.getEntry(ip, 0) * ptsaux.getEntry(iq, 0));\n+                zmat.setEntry(0, (k - np), temp);\n                 zmat.setEntry(ip + 1, k - np, -temp);\n                 zmat.setEntry(iq + 1, k - np, -temp);\n                 zmat.setEntry(k, k - np, temp);\n         int state = 80;\n         for(;;) switch (state) {\n         case 80: {\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 temp = bmat.getEntry(kold, j);\n                 bmat.setEntry(kold, j, bmat.getEntry(knew, j));\n                 bmat.setEntry(knew, j, temp);\n             }\n-            for (int j = 1; j <= nptm; j++) {\n+            for (int j = 0; j < nptm; j++) {\n                 temp = zmat.getEntry(kold, j);\n                 zmat.setEntry(kold, j, zmat.getEntry(knew, j));\n                 zmat.setEntry(knew, j, temp);\n                 if (nrem == 0) {\n                     return;\n                 }\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     work3.setEntry(k, Math.abs(work3.getEntry(k)));\n                 }\n             }\n         }\n         case 120: {\n             dsqmin = ZERO;\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 final double v1 = work3.getEntry(k);\n                 if (v1 > ZERO) {\n                     if (dsqmin == ZERO ||\n \n             // Form the W-vector of the chosen original interpolation point.\n \n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 work2.setEntry(j, xpt.getEntry(knew, j));\n             }\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 sum = ZERO;\n                 if (k == trustRegionCenterInterpolationPointIndex) {\n                 } else if (ptsid.getEntry(k) == ZERO) {\n-                    for (int j = 1; j <= n; j++) {\n+                    for (int j = 0; j < n; j++) {\n                         sum += work2.getEntry(j) * xpt.getEntry(k, j);\n                     }\n                 } else {\n                     ip = (int) ptsid.getEntry(k);\n                     if (ip > 0) {\n-                        sum = work2.getEntry(ip) * ptsaux.getEntry(ip, INDEX_OFFSET);\n+                        sum = work2.getEntry(ip - 1) * ptsaux.getEntry(ip - 1, 0);\n                     }\n                     iq = (int) ((double) np * ptsid.getEntry(k) - (double) (ip * np));\n                     if (iq > 0) {\n-                        int iw = INDEX_OFFSET;\n+                        int iw = 0;\n                         if (ip == 0) {\n-                            iw = INDEX_OFFSET + 1;\n+                            iw = 1;\n                         }\n-                        sum += work2.getEntry(iq) * ptsaux.getEntry(iq, iw);\n+                        sum += work2.getEntry(iq - 1) * ptsaux.getEntry(iq - 1, iw);\n                     }\n                 }\n                 work1.setEntry(k, HALF * sum * sum);\n             // Calculate VLAG and BETA for the required updating of the H matrix if\n             // XPT(KNEW,.) is reinstated in the set of interpolation points.\n \n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 sum = ZERO;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     sum += bmat.getEntry(k, j) * work2.getEntry(j);\n                 }\n                 vlag.setEntry(k, sum);\n             }\n             beta = ZERO;\n-            for (int j = 1; j <= nptm; j++) {\n+            for (int j = 0; j < nptm; j++) {\n                 sum = ZERO;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sum += zmat.getEntry(k, j) * work1.getEntry(k);\n                 }\n                 beta -= sum * sum;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     vlag.setEntry(k, vlag.getEntry(k) + sum * zmat.getEntry(k, j));\n                 }\n             }\n             bsum = ZERO;\n             distsq = ZERO;\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 sum = ZERO;\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sum += bmat.getEntry(k, j) * work1.getEntry(k);\n                 }\n                 jp = j + npt;\n                 bsum += sum * work2.getEntry(j);\n-                for (int k = 1; k <= n; k++) {\n+                for (int k = 0; k < n; k++) {\n                     sum += bmat.getEntry(npt + k, j) * work2.getEntry(k);\n                 }\n                 bsum += sum * work2.getEntry(j);\n \n             denom = ZERO;\n             vlmxsq = ZERO;\n-            for (int k = 1; k <= npt; k++) {\n+            for (int k = 0; k < npt; k++) {\n                 if (ptsid.getEntry(k) != ZERO) {\n                     hdiag = ZERO;\n-                    for (int j = 1; j <= nptm; j++) {\n+                    for (int j = 0; j < nptm; j++) {\n                         // Computing 2nd power\n                         final double d1 = zmat.getEntry(k, j);\n                         hdiag += d1 * d1;\n \n         }\n         case 260: {\n-            for (kpt = 1; kpt <= npt; kpt++) {\n+            for (kpt = 0; kpt < npt; kpt++) {\n                 if (ptsid.getEntry(kpt) == ZERO) {\n                     continue;\n                 }\n                 ih = 0;\n-                for (int j = 1; j <= n; j++) {\n+                for (int j = 0; j < n; j++) {\n                     work2.setEntry(j, xpt.getEntry(kpt, j));\n                     xpt.setEntry(kpt, j, ZERO);\n                     temp = pq.getEntry(kpt) * work2.getEntry(j);\n-                    for (int i = 1; i <= j; i++) {\n-                        ++ih;\n+                    for (int i = 0; i <= j; i++) {\n                         hq.setEntry(ih, hq.getEntry(ih) + temp * work2.getEntry(i));\n+                        ih++;\n                     }\n                 }\n                 pq.setEntry(kpt, ZERO);\n                 ip = (int) ptsid.getEntry(kpt);\n                 iq = (int) ((double) np * ptsid.getEntry(kpt) - (double) (ip * np));\n                 if (ip > 0) {\n-                    xp = ptsaux.getEntry(ip, INDEX_OFFSET);\n-                    xpt.setEntry(kpt, ip, xp);\n+                    xp = ptsaux.getEntry(ip - 1, 0);\n+                    xpt.setEntry(kpt, ip - 1, xp);\n                 }\n                 if (iq > 0) {\n-                    xq = ptsaux.getEntry(iq, INDEX_OFFSET);\n+                    xq = ptsaux.getEntry(iq - 1, 0);\n                     if (ip == 0) {\n-                        xq = ptsaux.getEntry(iq, INDEX_OFFSET + 1);\n-                    }\n-                    xpt.setEntry(kpt, iq, xq);\n+                        xq = ptsaux.getEntry(iq - 1, 1);\n+                    }\n+                    xpt.setEntry(kpt, iq - 1, xq);\n                 }\n \n                 // Set VQUAD to the value of the current model at the new point.\n                 vquad = fbase;\n                 if (ip > 0) {\n                     ihp = (ip + ip * ip) / 2;\n-                    vquad += xp * (gopt.getEntry(ip) + HALF * xp * hq.getEntry(ihp));\n+                    vquad += xp * (gopt.getEntry(ip - 1) + HALF * xp * hq.getEntry(ihp - 1));\n                 }\n                 if (iq > 0) {\n                     int ihq = (iq + iq * iq) / 2;\n-                    vquad += xq * (gopt.getEntry(iq) + HALF * xq * hq.getEntry(ihq));\n+                    vquad += xq * (gopt.getEntry(iq - 1) + HALF * xq * hq.getEntry(ihq - 1));\n                     if (ip > 0) {\n                         int iiw = Math.max(ihp, ihq) - Math.abs(ip - iq);\n-                        vquad += xp * xq * hq.getEntry(iiw);\n-                    }\n-                }\n-                for (int k = 1; k <= npt; k++) {\n+                        vquad += xp * xq * hq.getEntry(iiw - 1);\n+                    }\n+                }\n+                for (int k = 0; k < npt; k++) {\n                     temp = ZERO;\n                     if (ip > 0) {\n-                        temp += xp * xpt.getEntry(k, ip);\n+                        temp += xp * xpt.getEntry(k, ip - 1);\n                     }\n                     if (iq > 0) {\n-                        temp += xq * xpt.getEntry(k, iq);\n+                        temp += xq * xpt.getEntry(k, iq - 1);\n                     }\n                     vquad += HALF * pq.getEntry(k) * temp * temp;\n                 }\n                 // that is going to multiply the KPT-th Lagrange function when the model\n                 // is updated to provide interpolation to the new function value.\n \n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     // Computing MIN\n                     // Computing MAX\n-                    d__3 = lowerBound[f2jai(i)];\n+                    d__3 = lowerBound[i];\n                     d__4 = xbase.getEntry(i) + xpt.getEntry(kpt, i);\n                     d__1 = Math.max(d__3, d__4);\n-                    d__2 = upperBound[f2jai(i)];\n+                    d__2 = upperBound[i];\n                     work2.setEntry(i, Math.min(d__1, d__2));\n                     if (xpt.getEntry(kpt, i) == sl.getEntry(i)) {\n-                        work2.setEntry(i, lowerBound[f2jai(i)]);\n+                        work2.setEntry(i, lowerBound[i]);\n                     }\n                     if (xpt.getEntry(kpt, i) == su.getEntry(i)) {\n-                        work2.setEntry(i, upperBound[f2jai(i)]);\n+                        work2.setEntry(i, upperBound[i]);\n                     }\n                 }\n \n                 // Update the quadratic model. The RETURN from the subroutine occurs when\n                 // all the new interpolation points are included in the model.\n \n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     gopt.setEntry(i, gopt.getEntry(i) + diff * bmat.getEntry(kpt, i));\n                 }\n-                for (int k = 1; k <= npt; k++) {\n+                for (int k = 0; k < npt; k++) {\n                     sum = ZERO;\n-                    for (int j = 1; j <= nptm; j++) {\n+                    for (int j = 0; j < nptm; j++) {\n                         sum += zmat.getEntry(k, j) * zmat.getEntry(kpt, j);\n                     }\n                     temp = diff * sum;\n                         int ihq = (iq * iq + iq) / 2;\n                         if (ip == 0) {\n                             // Computing 2nd power\n-                            final double d1 = ptsaux.getEntry(iq, INDEX_OFFSET + 1);\n-                            hq.setEntry(ihq, hq.getEntry(ihq) + temp * (d1 * d1));\n+                            final double d1 = ptsaux.getEntry(iq - 1, 1);\n+                            hq.setEntry(ihq - 1, hq.getEntry(ihq - 1) + temp * (d1 * d1));\n                         } else {\n                             ihp = (ip * ip + ip) / 2;\n                             // Computing 2nd power\n-                            final double d1 = ptsaux.getEntry(ip, INDEX_OFFSET);\n-                            hq.setEntry(ihp, hq.getEntry(ihp) + temp * (d1 * d1));\n+                            final double d1 = ptsaux.getEntry(ip - 1, 0);\n+                            hq.setEntry(ihp - 1, hq.getEntry(ihp - 1) + temp * (d1 * d1));\n                             if (iq > 0) {\n                                 // Computing 2nd power\n-                                final double d2 = ptsaux.getEntry(iq, INDEX_OFFSET);\n-                                hq.setEntry(ihq, hq.getEntry(ihq) + temp * (d2 * d2));\n+                                final double d2 = ptsaux.getEntry(iq - 1, 0);\n+                                hq.setEntry(ihq - 1, hq.getEntry(ihq - 1) + temp * (d2 * d2));\n                                 int iw = Math.max(ihp,ihq) - Math.abs(iq - ip);\n-                                hq.setEntry(iw, hq.getEntry(iw)\n-                                            + temp * ptsaux.getEntry(ip, INDEX_OFFSET) * ptsaux.getEntry(iq, INDEX_OFFSET));\n+                                hq.setEntry(iw - 1, hq.getEntry(iw - 1)\n+                                            + temp * ptsaux.getEntry(ip - 1, 0) * ptsaux.getEntry(iq - 1, 0));\n                             }\n                         }\n                     }\n      * @param hred\n      */\n     private double[] trsbox(\n-            FortranMatrix xpt,\n-            FortranArray xopt,\n-            FortranArray gopt,\n-            FortranArray hq,\n-            FortranArray pq,\n-            FortranArray sl,\n-            FortranArray su,\n+            Array2DRowRealMatrix xpt,\n+            ArrayRealVector xopt,\n+            ArrayRealVector gopt,\n+            ArrayRealVector hq,\n+            ArrayRealVector pq,\n+            ArrayRealVector sl,\n+            ArrayRealVector su,\n             double delta,\n-            FortranArray xnew,\n-            FortranArray d__,\n-            FortranArray gnew,\n-            FortranArray xbdi,\n-            FortranArray s,\n-            FortranArray hs,\n-            FortranArray hred\n+            ArrayRealVector xnew,\n+            ArrayRealVector d__,\n+            ArrayRealVector gnew,\n+            ArrayRealVector xbdi,\n+            ArrayRealVector s,\n+            ArrayRealVector hs,\n+            ArrayRealVector hred\n     ) {\n         // System.out.println(\"trsbox\"); // XXX\n \n         double ds;\n         int iu;\n         double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;\n-        int iact = 0, nact = 0;\n+        int iact = -1; \n+        int nact = 0;\n         double angt = 0, qred;\n         int isav;\n         double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n \n         iterc = 0;\n         nact = 0;\n-        for (int i = 1; i <= n; i++) {\n+        for (int i = 0; i < n; i++) {\n             xbdi.setEntry(i, ZERO);\n             if (xopt.getEntry(i) <= sl.getEntry(i)) {\n                 if (gopt.getEntry(i) >= ZERO) {\n         }\n         case 30: {\n             stepsq = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) != ZERO) {\n                     s.setEntry(i, ZERO);\n                 } else if (beta == ZERO) {\n             resid = delsq;\n             ds = ZERO;\n             shs = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     // Computing 2nd power\n                     final double d1 = d__.getEntry(i);\n             // Reduce STPLEN if necessary in order to preserve the simple bounds,\n             // letting IACT be the index of the new constrained variable.\n \n-            iact = 0;\n-            for (int i = 1; i <= n; i++) {\n+            iact = -1;\n+            for (int i = 0; i < n; i++) {\n                 if (s.getEntry(i) != ZERO) {\n                     xsum = xopt.getEntry(i) + d__.getEntry(i);\n                     if (s.getEntry(i) > ZERO) {\n             if (stplen > ZERO) {\n                 ++iterc;\n                 temp = shs / stepsq;\n-                if (iact == 0 && temp > ZERO) {\n+                if (iact == -1 && temp > ZERO) {\n                     crvmin = Math.min(crvmin,temp);\n                     if (crvmin == MINUS_ONE) {\n                         crvmin = temp;\n                 }\n                 ggsav = gredsq;\n                 gredsq = ZERO;\n-                for (int i = 1; i <= n; i++) {\n+                for (int i = 0; i < n; i++) {\n                     gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                     if (xbdi.getEntry(i) == ZERO) {\n                         // Computing 2nd power\n \n             // Restart the conjugate gradient method if it has hit a new bound.\n \n-            if (iact > 0) {\n+            if (iact >= 0) {\n                 ++nact;\n                 xbdi.setEntry(iact, ONE);\n                 if (s.getEntry(iact) < ZERO) {\n             dredsq = ZERO;\n             dredg = ZERO;\n             gredsq = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     // Computing 2nd power\n                     double d1 = d__.getEntry(i);\n                 state = 190; break;\n             }\n             temp = Math.sqrt(temp);\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     s.setEntry(i, (dredg * d__.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                 } else {\n             // bound, there is a branch back to label 100 after fixing that variable.\n \n             angbd = ONE;\n-            iact = 0;\n-            for (int i = 1; i <= n; i++) {\n+            iact = -1;\n+            for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     tempa = xopt.getEntry(i) + d__.getEntry(i) - sl.getEntry(i);\n                     tempb = su.getEntry(i) - xopt.getEntry(i) - d__.getEntry(i);\n             shs = ZERO;\n             dhs = ZERO;\n             dhd = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 if (xbdi.getEntry(i) == ZERO) {\n                     shs += s.getEntry(i) * hs.getEntry(i);\n                     dhs += d__.getEntry(i) * hs.getEntry(i);\n             // the alternative iteration.\n \n             redmax = ZERO;\n-            isav = 0;\n+            isav = -1;\n             redsav = ZERO;\n             iu = (int) (angbd * 17. + 3.1);\n-            for (int i = 1; i <= iu; i++) {\n+            for (int i = 0; i < iu; i++) {\n                 angt = angbd * (double) i / (double) iu;\n                 sth = (angt + angt) / (ONE + angt * angt);\n                 temp = shs + angt * (angt * dhd - dhs - dhs);\n             // Return if the reduction is zero. Otherwise, set the sine and cosine\n             // of the angle of the alternative iteration, and calculate SDEC.\n \n-            if (isav == 0) {\n+            if (isav < 0) {\n                 state = 190; break;\n             }\n             if (isav < iu) {\n \n             dredg = ZERO;\n             gredsq = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                 if (xbdi.getEntry(i) == ZERO) {\n                     d__.setEntry(i, cth * d__.getEntry(i) + sth * s.getEntry(i));\n                 hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n             }\n             qred += sdec;\n-            if (iact > 0 && isav == iu) {\n+            if (iact >= 0 && isav == iu) {\n                 ++nact;\n                 xbdi.setEntry(iact, xsav);\n                 state = 100; break;\n         }\n         case 190: {\n             dsq = ZERO;\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 // Computing MAX\n                 // Computing MIN\n                 final double min = Math.min(xopt.getEntry(i) + d__.getEntry(i),\n         }\n         case 210: {\n             ih = 0;\n-            for (int j = 1; j <= n; j++) {\n+            for (int j = 0; j < n; j++) {\n                 hs.setEntry(j, ZERO);\n-                for (int i = 1; i <= j; i++) {\n-                    ++ih;\n+                for (int i = 0; i <= j; i++) {\n                     if (i < j) {\n                         hs.setEntry(j, hs.getEntry(j) + hq.getEntry(ih) * s.getEntry(i));\n                     }\n                     hs.setEntry(i, hs.getEntry(i) + hq.getEntry(ih) * s.getEntry(j));\n-                }\n-            }\n-            for (int k = 1; k <= npt; k++) {\n+                    ih++;\n+                }\n+            }\n+            for (int k = 0; k < npt; k++) {\n                 if (pq.getEntry(k) != ZERO) {\n                     temp = ZERO;\n-                    for (int j = 1; j <= n; j++) {\n+                    for (int j = 0; j < n; j++) {\n                         temp += xpt.getEntry(k, j) * s.getEntry(j);\n                     }\n                     temp *= pq.getEntry(k);\n-                    for (int i = 1; i <= n; i++) {\n+                    for (int i = 0; i < n; i++) {\n                         hs.setEntry(i, hs.getEntry(i) + temp * xpt.getEntry(k, i));\n                     }\n                 }\n             if (iterc > itcsav) {\n                 state = 150; break;\n             }\n-            for (int i = 1; i <= n; i++) {\n+            for (int i = 0; i < n; i++) {\n                 hred.setEntry(i, hs.getEntry(i));\n             }\n             state = 120; break;\n      * @param knew\n      */\n     private void update(\n-            FortranMatrix bmat,\n-            FortranMatrix zmat,\n-            FortranArray vlag,\n+            Array2DRowRealMatrix bmat,\n+            Array2DRowRealMatrix zmat,\n+            ArrayRealVector vlag,\n             double beta,\n             double denom,\n             int knew\n         final int nptm = npt - n - 1;\n \n         // XXX Should probably be split into two arrays.\n-        final FortranArray work = new FortranArray(npt + n);\n+        final ArrayRealVector work = new ArrayRealVector(npt + n);\n \n \n         // System generated locals\n         // Function Body\n \n         ztest = ZERO;\n-        for (int k = 1; k <= npt; k++) {\n-            for (int j = 1; j <= nptm; j++) {\n+        for (int k = 0; k < npt; k++) {\n+            for (int j = 0; j < nptm; j++) {\n                 // Computing MAX\n                 ztest = Math.max(ztest, Math.abs(zmat.getEntry(k, j)));\n             }\n \n         // Apply the rotations that put zeros in the KNEW-th row of ZMAT.\n \n-        for (int j = 2; j <= nptm; j++) {\n+        for (int j = 1; j < nptm; j++) {\n             d__1 = zmat.getEntry(knew, j);\n             if (Math.abs(d__1) > ztest) {\n                 // Computing 2nd power\n-                d__1 = zmat.getEntry(knew, INDEX_OFFSET);\n+                d__1 = zmat.getEntry(knew, 0);\n                 // Computing 2nd power\n                 d__2 = zmat.getEntry(knew, j);\n                 temp = Math.sqrt(d__1 * d__1 + d__2 * d__2);\n-                tempa = zmat.getEntry(knew, INDEX_OFFSET) / temp;\n+                tempa = zmat.getEntry(knew, 0) / temp;\n                 tempb = zmat.getEntry(knew, j) / temp;\n-                for (int i = 1; i <= npt; i++) {\n-                    temp = tempa * zmat.getEntry(i, INDEX_OFFSET) + tempb * zmat.getEntry(i, j);\n+                for (int i = 0; i < npt; i++) {\n+                    temp = tempa * zmat.getEntry(i, 0) + tempb * zmat.getEntry(i, j);\n                     zmat.setEntry(i, j, tempa * zmat.getEntry(i, j) -\n-                                  tempb * zmat.getEntry(i, INDEX_OFFSET));\n-                    zmat.setEntry(i, INDEX_OFFSET, temp);\n+                                  tempb * zmat.getEntry(i, 0));\n+                    zmat.setEntry(i, 0, temp);\n                 }\n             }\n             zmat.setEntry(knew, j, ZERO);\n         // Put the first NPT components of the KNEW-th column of HLAG into W,\n         // and calculate the parameters of the updating formula.\n \n-        for (int i = 1; i <= npt; i++) {\n-            work.setEntry(i, zmat.getEntry(knew, INDEX_OFFSET) * zmat.getEntry(i, INDEX_OFFSET));\n+        for (int i = 0; i < npt; i++) {\n+            work.setEntry(i, zmat.getEntry(knew, 0) * zmat.getEntry(i, 0));\n         }\n         alpha = work.getEntry(knew);\n         tau = vlag.getEntry(knew);\n         // Complete the updating of ZMAT.\n \n         temp = Math.sqrt(denom);\n-        tempb = zmat.getEntry(knew, INDEX_OFFSET) / temp;\n+        tempb = zmat.getEntry(knew, 0) / temp;\n         tempa = tau / temp;\n-        for (int i= 1; i <= npt; i++) {\n-            zmat.setEntry(i, INDEX_OFFSET, tempa * zmat.getEntry(i, INDEX_OFFSET) -\n-                    tempb * vlag.getEntry(i));\n+        for (int i = 0; i < npt; i++) {\n+            zmat.setEntry(i, 0,\n+                          tempa * zmat.getEntry(i, 0) - tempb * vlag.getEntry(i));\n         }\n \n         // Finally, update the matrix BMAT.\n \n-        for (int j = 1; j <= n; j++) {\n+        for (int j = 0; j < n; j++) {\n             jp = npt + j;\n             work.setEntry(jp, bmat.getEntry(knew, j));\n             tempa = (alpha * vlag.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n             tempb = (-beta * work.getEntry(jp) - tau * vlag.getEntry(jp)) / denom;\n-            for (int i = 1; i <= jp; i++) {\n+            for (int i = 0; i <= jp; i++) {\n                 bmat.setEntry(i, j, bmat.getEntry(i, j) + tempa *\n                         vlag.getEntry(i) + tempb * work.getEntry(i));\n-                if (i > npt) {\n+                if (i >= npt) {\n                     bmat.setEntry(jp, (i - npt), bmat.getEntry(i, j));\n                 }\n             }\n             throw new DimensionMismatchException(upperBound.length, dimension);\n         }\n \n-        for (int i = 0; i < dimension; i++) {\n+       for (int i = 0; i < dimension; i++) {\n             final double v = init[i];\n             final double lo = lowerBound[i];\n             final double hi = upperBound[i];\n \n         double requiredMinDiff = 2 * initialTrustRegionRadius;\n         double minDiff = Double.POSITIVE_INFINITY;\n-        for (int i = 0; i < dimension; i++) {\n+       for (int i = 0; i < dimension; i++) {\n             boundDifference[i] = upperBound[i] - lowerBound[i];\n             minDiff = Math.min(minDiff, boundDifference[i]);\n         }\n         if (minDiff < requiredMinDiff) {\n             initialTrustRegionRadius = minDiff / 3.0;\n-        }\n-    }\n-\n-\n-    // auxiliary subclasses\n-\n-    /**\n-     * 1-based indexing vector\n-     */\n-    private static class FortranArray extends ArrayRealVector {\n-        public FortranArray(int size) {\n-            super(size);\n-        }\n-        public FortranArray(ArrayRealVector data) {\n-            super(data, false);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double getEntry(int index) {\n-            return super.getEntry(index - INDEX_OFFSET);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void setEntry(int index, double value) {\n-            super.setEntry(index - INDEX_OFFSET, value);\n-        }\n-    }\n-\n-    /**\n-     * 1-based indexing matrix\n-     */\n-    private static class FortranMatrix extends Array2DRowRealMatrix {\n-        public FortranMatrix(int row, int column) {\n-            super(row, column);\n-        }\n-        /** {@inheritDoc} */\n-        public double getEntry(int row, int col) {\n-            return super.getEntry(row - INDEX_OFFSET, col - INDEX_OFFSET);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void setEntry(int row, int col, double value) {\n-            super.setEntry(row - INDEX_OFFSET, col - INDEX_OFFSET, value);\n         }\n     }\n \n         Arrays.fill(ds, value);\n         return ds;\n     }\n-\n-    // Fortan (1-based) to Java (0-based) array index.\n-    // For use in Fortran-like 1-based loops.  Calls to this offset\n-    // function will be removed when all loops are converted to 0-base.\n-    private static int f2jai(int j) {\n-        return j - INDEX_OFFSET;\n-    }\n }", "timestamp": 1313443017, "metainfo": ""}