{"sha": "7cf0c980d5d814daf187502bc07da0542ed7a828", "log": "clarified the ODE package by breaking in into several sub-packages and renaming classes. This also prepares future work for non-stiff solvers.  SwitchingFunctions is now known as EventHandler SwitchingFunctionsHandler is now known as CombinedEventsManager  The user manual as also been slightly improved, both to reflect these changes and to make it easier to grasp the underlying principles in our implementation of ODE solving   ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n package org.apache.commons.math.ode;\n \n import java.util.Collection;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.DummyStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n /**\n  * This abstract class holds the common part of all adaptive\n    * @param scalAbsoluteTolerance allowed absolute error\n    * @param scalRelativeTolerance allowed relative error\n    */\n-  public AdaptiveStepsizeIntegrator(double minStep, double maxStep,\n-                                    double scalAbsoluteTolerance,\n-                                    double scalRelativeTolerance) {\n+  public AdaptiveStepsizeIntegrator(final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n \n     this.minStep     = minStep;\n     this.maxStep     = maxStep;\n     // set the default step handler\n     handler = DummyStepHandler.getInstance();\n \n-    switchesHandler = new SwitchingFunctionsHandler();\n+    eventsHandlersManager = new CombinedEventsManager();\n \n     resetInternalState();\n \n    * @param vecAbsoluteTolerance allowed absolute error\n    * @param vecRelativeTolerance allowed relative error\n    */\n-  public AdaptiveStepsizeIntegrator(double minStep, double maxStep,\n-                                    double[] vecAbsoluteTolerance,\n-                                    double[] vecRelativeTolerance) {\n+  public AdaptiveStepsizeIntegrator(final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n \n     this.minStep     = minStep;\n     this.maxStep     = maxStep;\n     // set the default step handler\n     handler = DummyStepHandler.getInstance();\n \n-    switchesHandler = new SwitchingFunctionsHandler();\n+    eventsHandlersManager = new CombinedEventsManager();\n \n     resetInternalState();\n \n    * outside of the min/max step interval will lead the integrator to\n    * ignore the value and compute the initial step size by itself)\n    */\n-  public void setInitialStepSize(double initialStepSize) {\n+  public void setInitialStepSize(final double initialStepSize) {\n     if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n       initialStep = -1.0;\n     } else {\n     }\n   }\n \n-  /** Set the step handler for this integrator.\n-   * The handler will be called by the integrator for each accepted\n-   * step.\n-   * @param handler handler for the accepted steps\n-   */\n-  public void setStepHandler (StepHandler handler) {\n+  /** {@inheritDoc} */\n+  public void setStepHandler (final StepHandler handler) {\n     this.handler = handler;\n   }\n \n-  /** Get the step handler for this integrator.\n-   * @return the step handler for this integrator\n-   */\n+  /** {@inheritDoc} */\n   public StepHandler getStepHandler() {\n     return handler;\n   }\n \n-  /** Add a switching function to the integrator.\n-   * @param function switching function\n-   * @param maxCheckInterval maximal time interval between switching\n-   * function checks (this interval prevents missing sign changes in\n-   * case the integration steps becomes very large)\n-   * @param convergence convergence threshold in the event time search\n-   * @param maxIterationCount upper limit of the iteration count in\n-   * the event time search\n-   * @see #getSwitchingFunctions()\n-   * @see #clearSwitchingFunctions()\n-   */\n-  public void addSwitchingFunction(SwitchingFunction function,\n-                                   double maxCheckInterval,\n-                                   double convergence,\n-                                   int maxIterationCount) {\n-    switchesHandler.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);\n-  }\n-\n-  /** Get all the switching functions that have been added to the integrator.\n-   * @return an unmodifiable collection of the added switching functions\n-   * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n-   * @see #clearSwitchingFunctions()\n-   */\n-  public Collection<SwitchingFunction> getSwitchingFunctions() {\n-      return switchesHandler.getSwitchingFunctions();\n-  }\n-\n-  /** Remove all the switching functions that have been added to the integrator.\n-   * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n-   * @see #getSwitchingFunctions()\n-   */\n-  public void clearSwitchingFunctions() {\n-      switchesHandler.clearSwitchingFunctions();\n+  /** {@inheritDoc} */\n+  public void addEventHandler(final EventHandler function,\n+                              final double maxCheckInterval,\n+                              final double convergence,\n+                              final int maxIterationCount) {\n+    eventsHandlersManager.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public Collection<EventHandler> getEventsHandlers() {\n+      return eventsHandlersManager.getEventsHandlers();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void clearEventsHandlers() {\n+      eventsHandlersManager.clearEventsHandlers();\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n    * @param y placeholder where to put the state vector\n    * @exception IntegratorException if some inconsistency is detected\n    */\n-  protected void sanityChecks(FirstOrderDifferentialEquations equations,\n-                              double t0, double[] y0, double t, double[] y)\n-    throws IntegratorException {\n+  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                              final double t0, final double[] y0, final double t, final double[] y)\n+      throws IntegratorException {\n       if (equations.getDimension() != y0.length) {\n           throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n                                         \" initial state vector has dimension {1}\",\n    * @exception DerivativeException this exception is propagated to\n    * the caller if the underlying user function triggers one\n    */\n-  public double initializeStep(FirstOrderDifferentialEquations equations,\n-                               boolean forward, int order, double[] scale,\n-                               double t0, double[] y0, double[] yDot0,\n-                               double[] y1, double[] yDot1)\n-    throws DerivativeException {\n+  public double initializeStep(final FirstOrderDifferentialEquations equations,\n+                               final boolean forward, final int order, final double[] scale,\n+                               final double t0, final double[] y0, final double[] yDot0,\n+                               final double[] y1, final double[] yDot1)\n+      throws DerivativeException {\n \n     if (initialStep > 0) {\n       // use the user provided value\n \n     // step size is computed such that\n     // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n-    double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n-    double h1 = (maxInv2 < 1.0e-15) ?\n-                Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n-                Math.pow(0.01 / maxInv2, 1.0 / order);\n+    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    final double h1 = (maxInv2 < 1.0e-15) ?\n+                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n+                      Math.pow(0.01 / maxInv2, 1.0 / order);\n     h = Math.min(100.0 * Math.abs(h), h1);\n     h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n     if (h < getMinStep()) {\n    * @return a bounded integration step (h if no bound is reach, or a bounded value)\n    * @exception IntegratorException if the step is too small and acceptSmall is false\n    */\n-  protected double filterStep(double h, boolean acceptSmall)\n+  protected double filterStep(final double h, final boolean acceptSmall)\n     throws IntegratorException {\n \n-    if (Math.abs(h) < minStep) {\n-      if (acceptSmall) {\n-        h = (h < 0) ? -minStep : minStep;\n-      } else {\n-        throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n-                                      \" integration needs {1}\",\n-                                      new Object[] {\n-                                        Double.valueOf(minStep),\n-                                        Double.valueOf(Math.abs(h))\n-                                      });\n-      }\n-    }\n-\n-    if (h > maxStep) {\n-      h = maxStep;\n-    } else if (h < -maxStep) {\n-      h = -maxStep;\n-    }\n-\n-    return h;\n-\n-  }\n-\n-  /** Integrate the differential equations up to the given time.\n-   * <p>This method solves an Initial Value Problem (IVP).</p>\n-   * <p>Since this method stores some internal state variables made\n-   * available in its public interface during integration ({@link\n-   * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n-   * @param equations differential equations to integrate\n-   * @param t0 initial time\n-   * @param y0 initial value of the state vector at t0\n-   * @param t target time for the integration\n-   * (can be set to a value smaller than <code>t0</code> for backward integration)\n-   * @param y placeholder where to put the state vector at each successful\n-   *  step (and hence at the end of integration), can be the same object as y0\n-   * @throws IntegratorException if the integrator cannot perform integration\n-   * @throws DerivativeException this exception is propagated to the caller if\n-   * the underlying user function triggers one\n-   */\n+      double filteredH = h;\n+      if (Math.abs(h) < minStep) {\n+          if (acceptSmall) {\n+              filteredH = (filteredH < 0) ? -minStep : minStep;\n+          } else {\n+              throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n+                                            \" integration needs {1}\",\n+                                            new Object[] {\n+                                                Double.valueOf(minStep),\n+                                                Double.valueOf(Math.abs(h))\n+                                            });\n+          }\n+      }\n+\n+      if (filteredH > maxStep) {\n+          filteredH = maxStep;\n+      } else if (h < -maxStep) {\n+          filteredH = -maxStep;\n+      }\n+\n+      return filteredH;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n   public abstract void integrate (FirstOrderDifferentialEquations equations,\n                                   double t0, double[] y0,\n                                   double t, double[] y)\n     throws DerivativeException, IntegratorException;\n \n-  /** Get the current value of the step start time t<sub>i</sub>.\n-   * <p>This method can be called during integration (typically by\n-   * the object implementing the {@link FirstOrderDifferentialEquations\n-   * differential equations} problem) if the value of the current step that\n-   * is attempted is needed.</p>\n-   * <p>The result is undefined if the method is called outside of\n-   * calls to {@link #integrate}</p>\n-   * @return current value of the step start time t<sub>i</sub>\n-   */\n+  /** {@inheritDoc} */\n   public double getCurrentStepStart() {\n     return stepStart;\n   }\n \n-  /** Get the current signed value of the integration stepsize.\n-   * <p>This method can be called during integration (typically by\n-   * the object implementing the {@link FirstOrderDifferentialEquations\n-   * differential equations} problem) if the signed value of the current stepsize\n-   * that is tried is needed.</p>\n-   * <p>The result is undefined if the method is called outside of\n-   * calls to {@link #integrate}</p>\n-   * @return current signed value of the stepsize\n-   */\n+  /** {@inheritDoc} */\n   public double getCurrentSignedStepsize() {\n     return stepSize;\n   }\n   /** Step handler. */\n   protected StepHandler handler;\n \n-  /** Switching functions handler. */\n-  protected SwitchingFunctionsHandler switchesHandler;\n+  /** Events handlers manager. */\n+  protected CombinedEventsManager eventsHandlersManager;\n \n   /** Current step start time. */\n   protected double stepStart;\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n import java.util.ArrayList;\n import java.util.List;\n import java.io.Serializable;\n+\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n  * This class stores all information provided by an ODE integrator\n    * compatible with the instance (dimension of the state vector,\n    * propagation direction, hole between the dates)\n    */\n-  public void append(ContinuousOutputModel model)\n+  public void append(final ContinuousOutputModel model)\n     throws DerivativeException {\n \n     if (model.steps.size() == 0) {\n         throw new IllegalArgumentException(\"propagation direction mismatch\");\n       }\n \n-      StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n-      double current  = lastInterpolator.getCurrentTime();\n-      double previous = lastInterpolator.getPreviousTime();\n-      double step = current - previous;\n-      double gap = model.getInitialTime() - current;\n+      final StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n+      final double current  = lastInterpolator.getCurrentTime();\n+      final double previous = lastInterpolator.getPreviousTime();\n+      final double step = current - previous;\n+      final double gap = model.getInitialTime() - current;\n       if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n         throw new IllegalArgumentException(\"hole between time ranges\");\n       }\n    * @throws DerivativeException this exception is propagated to the\n    * caller if the underlying user function triggers one\n    */\n-  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n     throws DerivativeException {\n \n     if (steps.size() == 0) {\n    * near the interval endpoints.</p>\n    * @param time time of the interpolated point\n    */\n-  public void setInterpolatedTime(double time) {\n+  public void setInterpolatedTime(final double time) {\n \n     try {\n       // initialize the search with the complete steps table\n       int iMin = 0;\n-      StepInterpolator sMin = steps.get(iMin);\n+      final StepInterpolator sMin = steps.get(iMin);\n       double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());\n \n       int iMax = steps.size() - 1;\n-      StepInterpolator sMax = steps.get(iMax);\n+      final StepInterpolator sMax = steps.get(iMax);\n       double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());\n \n       // handle points outside of the integration interval\n       while (iMax - iMin > 5) {\n \n         // use the last estimated index as the splitting index\n-        StepInterpolator si = steps.get(index);\n-        int location = locatePoint(time, si);\n+        final StepInterpolator si = steps.get(index);\n+        final int location = locatePoint(time, si);\n         if (location < 0) {\n           iMax = index;\n           tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n         }\n \n         // compute a new estimate of the index in the reduced table slice\n-        int iMed = (iMin + iMax) / 2;\n-        StepInterpolator sMed = steps.get(iMed);\n-        double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n+        final int iMed = (iMin + iMax) / 2;\n+        final StepInterpolator sMed = steps.get(iMed);\n+        final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n \n         if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n           // too close to the bounds, we estimate using a simple dichotomy\n           // estimate the index using a reverse quadratic polynom\n           // (reverse means we have i = P(t), thus allowing to simply\n           // compute index = P(time) rather than solving a quadratic equation)\n-          double d12 = tMax - tMed;\n-          double d23 = tMed - tMin;\n-          double d13 = tMax - tMin;\n-          double dt1 = time - tMax;\n-          double dt2 = time - tMed;\n-          double dt3 = time - tMin;\n-          double iLagrange = ((dt2 * dt3 * d23) * iMax -\n-                              (dt1 * dt3 * d13) * iMed +\n-                              (dt1 * dt2 * d12) * iMin) /\n-                             (d12 * d23 * d13);\n+          final double d12 = tMax - tMed;\n+          final double d23 = tMed - tMin;\n+          final double d13 = tMax - tMin;\n+          final double dt1 = time - tMax;\n+          final double dt2 = time - tMed;\n+          final double dt3 = time - tMin;\n+          final double iLagrange = ((dt2 * dt3 * d23) * iMax -\n+                                    (dt1 * dt3 * d13) * iMed +\n+                                    (dt1 * dt2 * d12) * iMin) /\n+                                   (d12 * d23 * d13);\n           index = (int) Math.rint(iLagrange);\n         }\n \n         // force the next size reduction to be at least one tenth\n-        int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n-        int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n+        final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n+        final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n         if (index < low) {\n           index = low;\n         } else if (index > high) {\n    * the interval, and +1 if it is after the interval, according to\n    * the interval direction\n    */\n-  private int locatePoint(double time, StepInterpolator interval) {\n+  private int locatePoint(final double time, final StepInterpolator interval) {\n     if (forward) {\n       if (time < interval.getPreviousTime()) {\n         return -1;\n--- a/src/java/org/apache/commons/math/ode/DerivativeException.java\n+++ b/src/java/org/apache/commons/math/ode/DerivativeException.java\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public DerivativeException(String specifier, Object[] parts) {\n+  public DerivativeException(final String specifier, final Object[] parts) {\n     super(specifier, parts);\n   }\n \n   /** Build an instance from an underlying cause.\n    * @param cause cause for the exception\n    */\n-  public DerivativeException(Throwable cause) {\n+  public DerivativeException(final Throwable cause) {\n     super(cause);\n   }\n \n--- a/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n    * Build a converter around a second order equations set.\n    * @param equations second order equations set to convert\n    */\n-  public FirstOrderConverter (SecondOrderDifferentialEquations equations) {\n+  public FirstOrderConverter (final SecondOrderDifferentialEquations equations) {\n       this.equations = equations;\n       dimension      = equations.getDimension();\n       z              = new double[dimension];\n    * @throws DerivativeException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n-  public void computeDerivatives(double t, double[] y, double[] yDot)\n-  throws DerivativeException {\n+  public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n+      throws DerivativeException {\n \n     // split the state vector in two\n     System.arraycopy(y, 0,         z,    0, dimension);\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n import java.io.Serializable;\n import java.util.Collection;\n \n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n /** This interface represents a first order integrator for\n  * differential equations.\n \n  *\n  * @see FirstOrderDifferentialEquations\n  * @see StepHandler\n- * @see SwitchingFunction\n+ * @see EventHandler\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n    */\n   public StepHandler getStepHandler();\n \n-  /** Add a switching function to the integrator.\n-   * @param function switching function\n+  /** Add an event handler to the integrator.\n+   * @param handler event handler\n    * @param maxCheckInterval maximal time interval between switching\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n    * @param maxIterationCount upper limit of the iteration count in\n    * the event time search\n-   * @see #getSwitchingFunctions()\n-   * @see #clearSwitchingFunctions()\n+   * @see #getEventsHandlers()\n+   * @see #clearEventsHandlers()\n    */\n-  public void addSwitchingFunction(SwitchingFunction function,\n-                                   double maxCheckInterval,\n-                                   double convergence,\n-                                   int maxIterationCount);\n+  public void addEventHandler(EventHandler handler, double maxCheckInterval,\n+                              double convergence, int maxIterationCount);\n \n-  /** Get all the switching functions that have been added to the integrator.\n-   * @return an unmodifiable collection of the added switching functions\n-   * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n-   * @see #clearSwitchingFunctions()\n+  /** Get all the events handlers that have been added to the integrator.\n+   * @return an unmodifiable collection of the added events handlers\n+   * @see #addEventHandler(EventHandler, double, double, int)\n+   * @see #clearEventsHandlers()\n    */\n-  public Collection<SwitchingFunction> getSwitchingFunctions();\n+  public Collection<EventHandler> getEventsHandlers();\n \n-  /** Remove all the switching functions that have been added to the integrator.\n-   * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n-   * @see #getSwitchingFunctions()\n+  /** Remove all the events handlers that have been added to the integrator.\n+   * @see #addEventHandler(EventHandler, double, double, int)\n+   * @see #getEventsHandlers()\n    */\n-  public void clearSwitchingFunctions();\n+  public void clearEventsHandlers();\n \n   /** Integrate the differential equations up to the given time.\n    * <p>This method solves an Initial Value Problem (IVP).</p>\n--- a/src/java/org/apache/commons/math/ode/IntegratorException.java\n+++ b/src/java/org/apache/commons/math/ode/IntegratorException.java\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public IntegratorException(String specifier, Object[] parts) {\n+  public IntegratorException(final String specifier, final Object[] parts) {\n     super(specifier, parts);\n   }\n \n    * Create an exception with a given root cause.\n    * @param cause  the exception or error that caused this exception to be thrown\n    */\n-  public IntegratorException(Throwable cause) {\n+  public IntegratorException(final Throwable cause) {\n     super(cause);\n   }\n \n--- a/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n /** This interface represents a second order integrator for\n  * differential equations.\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class manages several {@link EventHandler event handlers} during integration.\n+ *\n+ * @see EventHandler\n+ * @see EventState\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class CombinedEventsManager implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4151965151236441261L;\n+\n+    /** Events states. */\n+    private final List<EventState> states;\n+\n+    /** First active event. */\n+    private EventState first;\n+\n+    /** Initialization indicator. */\n+    private boolean initialized;\n+\n+    /** Simple constructor.\n+     * Create an empty manager\n+     */\n+    public CombinedEventsManager() {\n+        states      = new ArrayList<EventState>();\n+        first       = null;\n+        initialized = false;\n+    }\n+\n+    /** Add an events handler.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between events\n+     * checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     * @see #getEventsHandlers()\n+     * @see #clearEventsHandlers()\n+     */\n+    public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\n+                                final double convergence, final int maxIterationCount) {\n+        states.add(new EventState(handler, maxCheckInterval,\n+                                   convergence, maxIterationCount));\n+    }\n+\n+    /** Get all the events handlers that have been added to the manager.\n+     * @return an unmodifiable collection of the added event handlers\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #clearEventsHandlers()\n+     */\n+    public Collection<EventHandler> getEventsHandlers() {\n+        final List<EventHandler> list = new ArrayList<EventHandler>();\n+        for (EventState state : states) {\n+            list.add(state.getEventHandler());\n+        }\n+        return Collections.unmodifiableCollection(list);\n+    }\n+\n+    /** Remove all the events handlers that have been added to the manager.\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #getEventsHandlers()\n+     */\n+    public void clearEventsHandlers() {\n+        states.clear();\n+    }\n+\n+    /** Check if the manager does not manage any event handlers.\n+     * @return true if manager is empty\n+     */\n+    public boolean isEmpty() {\n+        return states.isEmpty();\n+    }\n+\n+    /** Evaluate the impact of the proposed step on all managed\n+     * event handlers.\n+     * @param interpolator step interpolator for the proposed step\n+     * @return true if at least one event handler triggers an event\n+     * before the end of the proposed step (this implies the step should\n+     * be rejected)\n+     * @exception DerivativeException if the interpolator fails to\n+     * compute the function somewhere within the step\n+     * @exception IntegratorException if an event cannot be located\n+     */\n+    public boolean evaluateStep(final StepInterpolator interpolator)\n+    throws DerivativeException, IntegratorException {\n+\n+        try {\n+\n+            first = null;\n+            if (states.isEmpty()) {\n+                // there is nothing to do, return now to avoid setting the\n+                // interpolator time (and hence avoid unneeded calls to the\n+                // user function due to interpolator finalization)\n+                return false;\n+            }\n+\n+            if (! initialized) {\n+\n+                // initialize the events states\n+                final double t0 = interpolator.getPreviousTime();\n+                interpolator.setInterpolatedTime(t0);\n+                final double [] y = interpolator.getInterpolatedState();\n+                for (EventState state : states) {\n+                    state.reinitializeBegin(t0, y);\n+                }\n+\n+                initialized = true;\n+\n+            }\n+\n+            // check events occurrence\n+            for (EventState state : states) {\n+\n+                if (state.evaluateStep(interpolator)) {\n+                    if (first == null) {\n+                        first = state;\n+                    } else {\n+                        if (interpolator.isForward()) {\n+                            if (state.getEventTime() < first.getEventTime()) {\n+                                first = state;\n+                            }\n+                        } else {\n+                            if (state.getEventTime() > first.getEventTime()) {\n+                                first = state;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            }\n+\n+            return first != null;\n+\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        } catch (ConvergenceException ce) {\n+            throw new IntegratorException(ce);\n+        }\n+\n+    }\n+\n+    /** Get the occurrence time of the first event triggered in the\n+     * last evaluated step.\n+     * @return occurrence time of the first event triggered in the last\n+     * evaluated step, or </code>Double.NaN</code> if no event is\n+     * triggered\n+     */\n+    public double getEventTime() {\n+        return (first == null) ? Double.NaN : first.getEventTime();\n+    }\n+\n+    /** Inform the event handlers that the step has been accepted\n+     * by the integrator.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * end of the step\n+     * @param y array containing the current value of the state vector\n+     * at the end of the step\n+     * @exception IntegratorException if the value of one of the\n+     * events states cannot be evaluated\n+     */\n+    public void stepAccepted(final double t, final double[] y)\n+    throws IntegratorException {\n+        try {\n+            for (EventState state : states) {\n+                state.stepAccepted(t, y);\n+            }\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        }\n+    }\n+\n+    /** Check if the integration should be stopped at the end of the\n+     * current step.\n+     * @return true if the integration should be stopped\n+     */\n+    public boolean stop() {\n+        for (EventState state : states) {\n+            if (state.stop()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** Let the event handlers reset the state if they want.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * beginning of the next step\n+     * @param y array were to put the desired state vector at the beginning\n+     * of the next step\n+     * @return true if the integrator should reset the derivatives too\n+     * @exception IntegratorException if one of the events states\n+     * that should reset the state fails to do it\n+     */\n+    public boolean reset(final double t, final double[] y)\n+        throws IntegratorException {\n+        try {\n+            boolean resetDerivatives = false;\n+            for (EventState state : states) {\n+                if (state.reset(t, y)) {\n+                    resetDerivatives = true;\n+                }\n+            }\n+            return resetDerivatives;\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/EventException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered by {@link EventHandler}\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EventException extends MathException {\n+\n+    /** Serialization UID. */\n+    private static final long serialVersionUID = -898215297400035290L;\n+\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public EventException(final String specifier, final Object[] parts) {\n+        super(specifier, parts);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public EventException(final Throwable cause) {\n+        super(cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/EventHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/** This interface represents a handler for discrete events triggered\n+ * during ODE integration.\n+ *\n+ * <p>Some events can be triggered at discrete times as an ODE problem\n+ * is solved. These occurs for example when the integration process\n+ * should be stopped as some state is reached (G-stop facility) when the\n+ * precise date is unknown a priori, or when the derivatives have\n+ * discontinuities, or simply when the user wants to monitor some\n+ * states boundaries crossings.\n+ * </p>\n+ * \n+ * <p>These events are defined as occurring when a <code>g</code>\n+ * switching function sign changes.</p>\n+ *\n+ * <p>Since events are only problem-dependent and are triggered by the\n+ * independent <i>time</i> variable and the state vector, they can\n+ * occur at virtually any time, unknown in advance. The integrators will\n+ * take care to avoid sign changes inside the steps, they will reduce\n+ * the step size when such an event is detected in order to put this\n+ * event exactly at the end of the current step. This guarantees that\n+ * step interpolation (which always has a one step scope) is relevant\n+ * even in presence of discontinuities. This is independent from the\n+ * stepsize control provided by integrators that monitor the local\n+ * error (this event handling feature is available for all integrators,\n+ * including fixed step ones).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface EventHandler extends Serializable {\n+\n+  /** Stop indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should be\n+   * stopped after the event ending the current step.</p>\n+   */\n+  public static final int STOP = 0;\n+\n+  /** Reset state indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new state\n+   * vector (which will be retrieved thanks to the {@link #resetState\n+   * resetState} method).</p>\n+   */\n+  public static final int RESET_STATE = 1;\n+\n+  /** Reset derivatives indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new derivatives\n+   * vector (which will be retrieved thanks to the {@link\n+   * FirstOrderDifferentialEquations#computeDerivatives} method).</p>\n+   */\n+  public static final int RESET_DERIVATIVES = 2;\n+\n+  /** Continue indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should go\n+   * on after the event ending the current step.</p>\n+   */\n+  public static final int CONTINUE = 3;\n+\n+  /** Compute the value of the switching function.\n+\n+   * <p>The discrete events are generated when the sign of this \n+   * switching function changes. The integrator will take care to change\n+   * the stepsize in such a way these events occur exactly at step boundaries.\n+   * The switching function must be continuous in its roots neighborhood\n+   * (but not necessarily smooth), as the integrator will need to find its\n+   * roots to locate precisely the events.</p>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return value of the g switching function\n+   * @exception EventException if the switching function cannot be evaluated\n+   */\n+  public double g(double t, double[] y) throws EventException;\n+\n+  /** Handle an event and choose what to do next.\n+\n+   * <p>This method is called when the integrator has accepted a step\n+   * ending exactly on a sign change of the function, just before the\n+   * step handler itself is called. It allows the user to update his\n+   * internal data to acknowledge the fact the event has been handled\n+   * (for example setting a flag in the {@link\n+   * FirstOrderDifferentialEquations differential equations} to switch\n+   * the derivatives computation in case of discontinuity), or to\n+   * direct the integrator to either stop or continue integration,\n+   * possibly with a reset state or derivatives.</p>\n+\n+   * <ul>\n+   *   <li>if {@link #STOP} is returned, the step handler will be called\n+   *   with the <code>isLast</code> flag of the {@link\n+   *   StepHandler#handleStep handleStep} method set to true and the\n+   *   integration will be stopped,</li>\n+   *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n+   *   resetState} method will be called once the step handler has\n+   *   finished its task, and the integrator will also recompute the\n+   *   derivatives,</li>\n+   *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n+   *   will recompute the derivatives,\n+   *   <li>if {@link #CONTINUE} is returned, no specific action will\n+   *   be taken (apart from having called this method) and integration\n+   *   will continue.</li>\n+   * </ul>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return indication of what the integrator should do next, this\n+   * value must be one of {@link #STOP}, {@link #RESET_STATE},\n+   * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n+   * @exception EventException if the event occurrence triggers an error\n+   */\n+  public int eventOccurred(double t, double[] y) throws EventException;\n+  \n+  /** Reset the state prior to continue the integration.\n+\n+   * <p>This method is called after the step handler has returned and\n+   * before the next step is started, but only when {@link\n+   * #eventOccurred} has itself returned the {@link #RESET_STATE}\n+   * indicator. It allows the user to reset the state vector for the\n+   * next step, without perturbing the step handler of the finishing\n+   * step. If the {@link #eventOccurred} never returns the {@link\n+   * #RESET_STATE} indicator, this function will never be called, and it is\n+   * safe to leave its body empty.</p>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * the new state should be put in the same array\n+   * @exception EventException if the state cannot be reseted\n+   */\n+  public void resetState(double t, double[] y) throws EventException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/EventState.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.BrentSolver;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealSolver;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class handles the state for one {@link EventHandler\n+ * event handler} during integration steps.\n+ *\n+ * <p>Each time the integrator proposes a step, the event handler\n+ * switching function should be checked. This class handles the state\n+ * of one handler during one integration step, with references to the\n+ * state at the end of the preceding step. This information is used to\n+ * decide if the handler should trigger an event or not during the\n+ * proposed step (and hence the step should be reduced to ensure the\n+ * event occurs at a bound rather than inside the step).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+class EventState implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7307007422156119622L;\n+\n+    /** Event handler. */\n+    private final EventHandler handler;\n+\n+    /** Maximal time interval between events handler checks. */\n+    private final double maxCheckInterval;\n+\n+    /** Convergence threshold for event localization. */\n+    private final double convergence;\n+\n+    /** Upper limit in the iteration count for event localization. */\n+    private final int maxIterationCount;\n+\n+    /** Time at the beginning of the step. */\n+    private double t0;\n+\n+    /** Value of the events handler at the beginning of the step. */\n+    private double g0;\n+\n+    /** Simulated sign of g0 (we cheat when crossing events). */\n+    private boolean g0Positive;\n+\n+    /** Indicator of event expected during the step. */\n+    private boolean pendingEvent;\n+\n+    /** Occurrence time of the pending event. */\n+    private double pendingEventTime;\n+\n+    /** Occurrence time of the previous event. */\n+    private double previousEventTime;\n+\n+    /** Variation direction around pending event.\n+     *  (this is considered with respect to the integration direction)\n+     */\n+    private boolean increasing;\n+\n+    /** Next action indicator. */\n+    private int nextAction;\n+\n+    /** Simple constructor.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between switching\n+     * function checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     */\n+    public EventState(final EventHandler handler, final double maxCheckInterval,\n+                      final double convergence, final int maxIterationCount) {\n+        this.handler           = handler;\n+        this.maxCheckInterval  = maxCheckInterval;\n+        this.convergence       = Math.abs(convergence);\n+        this.maxIterationCount = maxIterationCount;\n+\n+        // some dummy values ...\n+        t0                = Double.NaN;\n+        g0                = Double.NaN;\n+        g0Positive        = true;\n+        pendingEvent      = false;\n+        pendingEventTime  = Double.NaN;\n+        previousEventTime = Double.NaN;\n+        increasing        = true;\n+        nextAction        = EventHandler.CONTINUE;\n+\n+    }\n+\n+    /** Get the underlying event handler.\n+     * @return underlying event handler\n+     */\n+    public EventHandler getEventHandler() {\n+        return handler;\n+    }\n+\n+    /** Reinitialize the beginning of the step.\n+     * @param t0 value of the independent <i>time</i> variable at the\n+     * beginning of the step\n+     * @param y0 array containing the current value of the state vector\n+     * at the beginning of the step\n+     * @exception EventException if the event handler\n+     * value cannot be evaluated at the beginning of the step\n+     */\n+    public void reinitializeBegin(final double t0, final double[] y0)\n+        throws EventException {\n+        this.t0 = t0;\n+        g0 = handler.g(t0, y0);\n+        g0Positive = (g0 >= 0);\n+    }\n+\n+    /** Evaluate the impact of the proposed step on the event handler.\n+     * @param interpolator step interpolator for the proposed step\n+     * @return true if the event handler triggers an event before\n+     * the end of the proposed step (this implies the step should be\n+     * rejected)\n+     * @exception DerivativeException if the interpolator fails to\n+     * compute the switching function somewhere within the step\n+     * @exception EventException if the switching function\n+     * cannot be evaluated\n+     * @exception ConvergenceException if an event cannot be located\n+     */\n+    public boolean evaluateStep(final StepInterpolator interpolator)\n+        throws DerivativeException, EventException, ConvergenceException {\n+\n+        try {\n+\n+            final double t1 = interpolator.getCurrentTime();\n+            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+            final double h  = (t1 - t0) / n;\n+\n+            double ta = t0;\n+            double ga = g0;\n+            double tb = t0 + ((t1 > t0) ? convergence : -convergence);\n+            for (int i = 0; i < n; ++i) {\n+\n+                // evaluate handler value at the end of the substep\n+                tb += h;\n+                interpolator.setInterpolatedTime(tb);\n+                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n+\n+                // check events occurrence\n+                if (g0Positive ^ (gb >= 0)) {\n+                    // there is a sign change: an event is expected during this step\n+\n+                    // variation direction, with respect to the integration direction\n+                    increasing = (gb >= ga);\n+\n+                    final UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {\n+                        public double value(final double t) throws FunctionEvaluationException {\n+                            try {\n+                                interpolator.setInterpolatedTime(t);\n+                                return handler.g(t, interpolator.getInterpolatedState());\n+                            } catch (DerivativeException e) {\n+                                throw new FunctionEvaluationException(t, e);\n+                            } catch (EventException e) {\n+                                throw new FunctionEvaluationException(t, e);\n+                            }\n+                        }\n+                    });\n+                    solver.setAbsoluteAccuracy(convergence);\n+                    solver.setMaximalIterationCount(maxIterationCount);\n+                    final double root = solver.solve(ta, tb);\n+                    if (Double.isNaN(previousEventTime) ||\n+                        (Math.abs(previousEventTime - root) > convergence)) {\n+                        pendingEventTime = root;\n+                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                            // we were already waiting for this event which was\n+                            // found during a previous call for a step that was\n+                            // rejected, this step must now be accepted since it\n+                            // properly ends exactly at the event occurrence\n+                            return false;\n+                        }\n+                        // either we were not waiting for the event or it has\n+                        // moved in such a way the step cannot be accepted\n+                        pendingEvent = true;\n+                        return true;\n+                    }\n+\n+                } else {\n+                    // no sign change: there is no event for now\n+                    ta = tb;\n+                    ga = gb;\n+                }\n+\n+            }\n+\n+            // no event during the whole step\n+            pendingEvent     = false;\n+            pendingEventTime = Double.NaN;\n+            return false;\n+\n+        } catch (FunctionEvaluationException e) {\n+            final Throwable cause = e.getCause();\n+            if ((cause != null) && (cause instanceof DerivativeException)) {\n+                throw (DerivativeException) cause;\n+            } else if ((cause != null) && (cause instanceof EventException)) {\n+                throw (EventException) cause;\n+            }\n+            throw new EventException(e);\n+        }\n+\n+    }\n+\n+    /** Get the occurrence time of the event triggered in the current\n+     * step.\n+     * @return occurrence time of the event triggered in the current\n+     * step.\n+     */\n+    public double getEventTime() {\n+        return pendingEventTime;\n+    }\n+\n+    /** Acknowledge the fact the step has been accepted by the integrator.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * end of the step\n+     * @param y array containing the current value of the state vector\n+     * at the end of the step\n+     * @exception EventException if the value of the event\n+     * handler cannot be evaluated\n+     */\n+    public void stepAccepted(final double t, final double[] y)\n+        throws EventException {\n+\n+        t0 = t;\n+        g0 = handler.g(t, y);\n+\n+        if (pendingEvent) {\n+            // force the sign to its value \"just after the event\"\n+            previousEventTime = t;\n+            g0Positive        = increasing;\n+            nextAction        = handler.eventOccurred(t, y);\n+        } else {\n+            g0Positive = (g0 >= 0);\n+            nextAction = EventHandler.CONTINUE;\n+        }\n+    }\n+\n+    /** Check if the integration should be stopped at the end of the\n+     * current step.\n+     * @return true if the integration should be stopped\n+     */\n+    public boolean stop() {\n+        return nextAction == EventHandler.STOP;\n+    }\n+\n+    /** Let the event handler reset the state if it wants.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * beginning of the next step\n+     * @param y array were to put the desired state vector at the beginning\n+     * of the next step\n+     * @return true if the integrator should reset the derivatives too\n+     * @exception EventException if the state cannot be reseted by the event\n+     * handler\n+     */\n+    public boolean reset(final double t, final double[] y)\n+        throws EventException {\n+\n+        if (! pendingEvent) {\n+            return false;\n+        }\n+\n+        if (nextAction == EventHandler.RESET_STATE) {\n+            handler.resetState(t, y);\n+        }\n+        pendingEvent      = false;\n+        pendingEventTime  = Double.NaN;\n+\n+        return (nextAction == EventHandler.RESET_STATE) ||\n+        (nextAction == EventHandler.RESET_DERIVATIVES);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the classical fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations (it is the most\n+ * often used Runge-Kutta method).\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/2 | 1/2   0    0    0\n+ *   1/2 |  0   1/2   0    0\n+ *    1  |  0    0    1    0\n+ *       |--------------------\n+ *       | 1/6  1/3  1/3  1/6\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ClassicalRungeKuttaIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -8987762131146169612L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"classical Runge-Kutta\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { 0.0, 1.0 / 2.0 },\n+    { 0.0, 0.0, 1.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Runge-Kutta integrator with the given\n+   * step.\n+   * @param step integration step\n+   */\n+  public ClassicalRungeKuttaIntegrator(final double step) {\n+    super(c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the classical fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    + (1 - theta) (h/6) [ (-4 theta^2 + 5 theta - 1) y'_1\n+ *                                          +(4 theta^2 - 2 theta - 2) (y'_2 + y'_3)\n+ *                                          -(4 theta^2 +   theta + 1) y'_4\n+ *                                        ]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class ClassicalRungeKuttaStepInterpolator\n+    extends RungeKuttaStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6576285612589783992L;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link RungeKuttaStepInterpolator#reinitialize} method should be\n+     * called before using the instance in order to initialize the\n+     * internal arrays. This constructor is used only in order to delay\n+     * the initialization in some cases. The {@link RungeKuttaIntegrator}\n+     * class uses the prototyping design pattern to create the step\n+     * interpolators by cloning an uninitialized model and latter initializing\n+     * the copy.\n+     */\n+    public ClassicalRungeKuttaStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public ClassicalRungeKuttaStepInterpolator(final ClassicalRungeKuttaStepInterpolator interpolator) {\n+        super(interpolator);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected StepInterpolator doCopy() {\n+        return new ClassicalRungeKuttaStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeInterpolatedState(final double theta,\n+                                            final double oneMinusThetaH)\n+        throws DerivativeException {\n+\n+        final double fourTheta = 4 * theta;\n+        final double s         = oneMinusThetaH / 6.0;\n+        final double coeff1    = s * ((-fourTheta + 5) * theta - 1);\n+        final double coeff23   = s * (( fourTheta - 2) * theta - 2);\n+        final double coeff4    = s * ((-fourTheta - 1) * theta - 1);\n+\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] = currentState[i] +\n+            coeff1  * yDotK[0][i] +\n+            coeff23 * (yDotK[1][i] + yDotK[2][i]) +\n+            coeff4  * yDotK[3][i];\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 5(4) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step. However, since this\n+ * is an <i>fsal</i>, the last evaluation of one step is the same as\n+ * the first evaluation of the next step and hence can be avoided. So\n+ * the cost is really 6 functions evaluations per step.</p>\n+ *\n+ * <p>This method has been published (whithout the continuous output\n+ * that was added by Shampine in 1986) in the following article :\n+ * <pre>\n+ *  A family of embedded Runge-Kutta formulae\n+ *  J. R. Dormand and P. J. Prince\n+ *  Journal of Computational and Applied Mathematics\n+ *  volume 6, no 1, 1980, pp. 19-26\n+ * </pre></p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DormandPrince54Integrator\n+  extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -5346655668732043826L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"Dormand-Prince 5(4)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+    {1.0/5.0},\n+    {3.0/40.0, 9.0/40.0},\n+    {44.0/45.0, -56.0/15.0, 32.0/9.0},\n+    {19372.0/6561.0, -25360.0/2187.0, 64448.0/6561.0,  -212.0/729.0},\n+    {9017.0/3168.0, -355.0/33.0, 46732.0/5247.0, 49.0/176.0, -5103.0/18656.0},\n+    {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+    35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n+  };\n+\n+  /** Error array, element 1. */\n+  private static final double e1 =     71.0 / 57600.0;\n+\n+  // element 2 is zero, so it is neither stored nor used\n+\n+  /** Error array, element 3. */\n+  private static final double e3 =    -71.0 / 16695.0;\n+\n+  /** Error array, element 4. */\n+  private static final double e4 =     71.0 / 1920.0;\n+\n+  /** Error array, element 5. */\n+  private static final double e5 = -17253.0 / 339200.0;\n+\n+  /** Error array, element 6. */\n+  private static final double e6 =     22.0 / 525.0;\n+\n+  /** Error array, element 7. */\n+  private static final double e7 =     -1.0 / 40.0;\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(final double minStep, final double maxStep,\n+                                   final double scalAbsoluteTolerance,\n+                                   final double scalRelativeTolerance) {\n+    super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(final double minStep, final double maxStep,\n+                                   final double[] vecAbsoluteTolerance,\n+                                   final double[] vecRelativeTolerance) {\n+    super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+        final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +\n+                              e4 * yDotK[3][j] +  e5 * yDotK[4][j] +\n+                              e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+\n+        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+        final double tol = (vecAbsoluteTolerance == null) ?\n+                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+        final double ratio  = h * errSum / tol;\n+        error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince54Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class DormandPrince54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince54StepInterpolator() {\n+    super();\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince54StepInterpolator(final DormandPrince54StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.v1 == null) {\n+\n+      v1 = null;\n+      v2 = null;\n+      v3 = null;\n+      v4 = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      v1 = (double[]) interpolator.v1.clone();\n+      v2 = (double[]) interpolator.v2.clone();\n+      v3 = (double[]) interpolator.v3.clone();\n+      v4 = (double[]) interpolator.v4.clone();\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new DormandPrince54StepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+    super.reinitialize(equations, y, yDotK, forward);\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void storeTime(final double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v1 == null) {\n+        v1 = new double[interpolatedState.length];\n+        v2 = new double[interpolatedState.length];\n+        v3 = new double[interpolatedState.length];\n+        v4 = new double[interpolatedState.length];\n+      }\n+\n+      // no step finalization is needed for this interpolator\n+\n+      // we need to compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+        v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i] +\n+                     a74 * yDotK[4][i] + a75 * yDotK[5][i]);\n+        v2[i] = h * yDotK[0][i] - v1[i];\n+        v3[i] = v1[i] - v2[i] - h * yDotK[6][i];\n+        v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i] +\n+                     d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    // interpolate\n+    final double eta = oneMinusThetaH / h;\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] -\n+          eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n+    }\n+\n+  }\n+\n+  /** First vector for interpolation. */\n+  private double[] v1;\n+\n+  /** Second vector for interpolation. */\n+  private double[] v2;\n+\n+  /** Third vector for interpolation. */\n+  private double[] v3;\n+\n+  /** Fourth vector for interpolation. */\n+  private double[] v4;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  /** Last row of the Butcher-array internal weights, element 0. */\n+  private static final double a70 =    35.0 /  384.0;\n+\n+  // element 1 is zero, so it is neither stored nor used\n+\n+  /** Last row of the Butcher-array internal weights, element 2. */\n+  private static final double a72 =   500.0 / 1113.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 3. */\n+  private static final double a73 =   125.0 /  192.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 4. */\n+  private static final double a74 = -2187.0 / 6784.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 5. */\n+  private static final double a75 =    11.0 /   84.0;\n+\n+  /** Shampine (1986) Dense output, element 0. */\n+  private static final double d0 =  -12715105075.0 /  11282082432.0;\n+\n+  // element 1 is zero, so it is neither stored nor used\n+\n+  /** Shampine (1986) Dense output, element 2. */\n+  private static final double d2 =   87487479700.0 /  32700410799.0;\n+\n+  /** Shampine (1986) Dense output, element 3. */\n+  private static final double d3 =  -10690763975.0 /   1880347072.0;\n+\n+  /** Shampine (1986) Dense output, element 4. */\n+  private static final double d4 =  701980252875.0 / 199316789632.0;\n+\n+  /** Shampine (1986) Dense output, element 5. */\n+  private static final double d5 =   -1453857185.0 /    822651844.0;\n+\n+  /** Shampine (1986) Dense output, element 6. */\n+  private static final double d6 =      69997945.0 /     29380423.0;\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 4104157279605906956L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 12 functions evaluations per step for integration and 4\n+ * evaluations for interpolation. However, since the first\n+ * interpolation evaluation is the same as the first integration\n+ * evaluation of the next step, we have included it in the integrator\n+ * rather than in the interpolator and specified the method was an\n+ * <i>fsal</i>. Hence, despite we have 13 stages here, the cost is\n+ * really 12 evaluations per step even if no interpolation is done,\n+ * and the overcost of interpolation is only 3 evaluations.</p>\n+ *\n+ * <p>This method is based on an 8(6) method by Dormand and Prince\n+ * (i.e. order 8 for the integration and order 6 for error estimation)\n+ * modified by Hairer and Wanner to use a 5th order error estimator\n+ * with 3rd order correction. This modification was introduced because\n+ * the original method failed in some cases (wrong steps can be\n+ * accepted when step size is too large, for example in the\n+ * Brusselator problem) and also had <i>severe difficulties when\n+ * applied to problems with discontinuities</i>. This modification is\n+ * explained in the second edition of the first volume (Nonstiff\n+ * Problems) of the reference book by Hairer, Norsett and Wanner:\n+ * <i>Solving Ordinary Differential Equations</i> (Springer-Verlag,\n+ * ISBN 3-540-56670-8).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DormandPrince853Integrator\n+  extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 6175337145090754336L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"Dormand-Prince 8 (5, 3)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    (12.0 - 2.0 * Math.sqrt(6.0)) / 135.0, (6.0 - Math.sqrt(6.0)) / 45.0, (6.0 - Math.sqrt(6.0)) / 30.0,\n+    (6.0 + Math.sqrt(6.0)) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n+    6.0/7.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+\n+    // k2\n+    {(12.0 - 2.0 * Math.sqrt(6.0)) / 135.0},\n+\n+    // k3\n+    {(6.0 - Math.sqrt(6.0)) / 180.0, (6.0 - Math.sqrt(6.0)) / 60.0},\n+\n+    // k4\n+    {(6.0 - Math.sqrt(6.0)) / 120.0, 0.0, (6.0 - Math.sqrt(6.0)) / 40.0},\n+\n+    // k5\n+    {(462.0 + 107.0 * Math.sqrt(6.0)) / 3000.0, 0.0,\n+     (-402.0 - 197.0 * Math.sqrt(6.0)) / 1000.0, (168.0 + 73.0 * Math.sqrt(6.0)) / 375.0},\n+\n+    // k6\n+    {1.0 / 27.0, 0.0, 0.0, (16.0 + Math.sqrt(6.0)) / 108.0, (16.0 - Math.sqrt(6.0)) / 108.0},\n+\n+    // k7\n+    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * Math.sqrt(6.0)) / 1024.0,\n+     (118.0 - 23.0 * Math.sqrt(6.0)) / 1024.0, -9.0 / 512.0},\n+\n+    // k8\n+    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * Math.sqrt(6.0)) / 371293.0,\n+     (51544.0 - 4784.0 * Math.sqrt(6.0)) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n+\n+    // k9\n+    {58656157643.0 / 93983540625.0, 0.0, 0.0,\n+     (-1324889724104.0 - 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     (-1324889724104.0 + 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,\n+     -165125654.0 / 3796875.0},\n+\n+    // k10\n+    {8909899.0 / 18653125.0, 0.0, 0.0,\n+     (-4521408.0 - 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     (-4521408.0 + 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,\n+     -4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},\n+\n+    // k11\n+    {-20401265806.0 / 21769653311.0, 0.0, 0.0,\n+     (354216.0 + 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     (354216.0 - 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     -43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,\n+     14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,\n+     -1477884375.0 / 485066827.0},\n+\n+    // k12\n+    {39815761.0 / 17514443.0, 0.0, 0.0,\n+     (-3457480.0 - 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     (-3457480.0 + 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     -844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,\n+     -2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,\n+     226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},\n+\n+    // k13 should be for interpolation only, but since it is the same\n+    // stage as the first evaluation of the next step, we perform it\n+    // here at no cost by specifying this is an fsal method\n+    {104257.0/1920240.0, 0.0, 0.0, 0.0, 0.0, 3399327.0/763840.0,\n+     66578432.0/35198415.0, -1674902723.0/288716400.0,\n+     54980371265625.0/176692375811392.0, -734375.0/4826304.0,\n+     171414593.0/851261400.0, 137909.0/3084480.0}\n+\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+      104257.0/1920240.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      3399327.0/763840.0,\n+      66578432.0/35198415.0,\n+      -1674902723.0/288716400.0,\n+      54980371265625.0/176692375811392.0,\n+      -734375.0/4826304.0,\n+      171414593.0/851261400.0,\n+      137909.0/3084480.0,\n+      0.0\n+  };\n+\n+  /** First error weights array, element 1. */\n+  private static final double e1_01 =         116092271.0 / 8848465920.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** First error weights array, element 6. */\n+  private static final double e1_06 =          -1871647.0 / 1527680.0;\n+\n+  /** First error weights array, element 7. */\n+  private static final double e1_07 =         -69799717.0 / 140793660.0;\n+\n+  /** First error weights array, element 8. */\n+  private static final double e1_08 =     1230164450203.0 / 739113984000.0;\n+\n+  /** First error weights array, element 9. */\n+  private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;\n+\n+  /** First error weights array, element 10. */\n+  private static final double e1_10 =         464500805.0 / 1389975552.0;\n+\n+  /** First error weights array, element 11. */\n+  private static final double e1_11 =     1606764981773.0 / 19613062656000.0;\n+\n+  /** First error weights array, element 12. */\n+  private static final double e1_12 =           -137909.0 / 6168960.0;\n+\n+\n+  /** Second error weights array, element 1. */\n+  private static final double e2_01 =           -364463.0 / 1920240.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Second error weights array, element 6. */\n+  private static final double e2_06 =           3399327.0 / 763840.0;\n+\n+  /** Second error weights array, element 7. */\n+  private static final double e2_07 =          66578432.0 / 35198415.0;\n+\n+  /** Second error weights array, element 8. */\n+  private static final double e2_08 =       -1674902723.0 / 288716400.0;\n+\n+  /** Second error weights array, element 9. */\n+  private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;\n+\n+  /** Second error weights array, element 10. */\n+  private static final double e2_10 =           -734375.0 / 4826304.0;\n+\n+  /** Second error weights array, element 11. */\n+  private static final double e2_11 =         171414593.0 / 851261400.0;\n+\n+  /** Second error weights array, element 12. */\n+  private static final double e2_12 =             69869.0 / 3084480.0;\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n+    super(true, staticC, staticA, staticB,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n+    super(true, staticC, staticA, staticB,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public int getOrder() {\n+    return 8;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+    double error1 = 0;\n+    double error2 = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      final double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +\n+                             e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +\n+                             e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +\n+                             e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n+      final double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +\n+                             e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +\n+                             e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +\n+                             e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+\n+      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double tol = (vecAbsoluteTolerance == null) ?\n+                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      final double ratio1  = errSum1 / tol;\n+      error1        += ratio1 * ratio1;\n+      final double ratio2  = errSum2 / tol;\n+      error2        += ratio2 * ratio2;\n+    }\n+\n+    double den = error1 + 0.01 * error2;\n+    if (den <= 0.0) {\n+      den = 1.0;\n+    }\n+\n+    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 8(5,3) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince853Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class DormandPrince853StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince853StepInterpolator() {\n+    super();\n+    yDotKLast = null;\n+    v         = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState == null) {\n+\n+      yDotKLast = null;\n+      v         = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      final int dimension = interpolator.currentState.length;\n+\n+      yDotKLast    = new double[3][];\n+      for (int k = 0; k < yDotKLast.length; ++k) {\n+        yDotKLast[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n+                         dimension);\n+      }\n+\n+      v = new double[7][];\n+      for (int k = 0; k < v.length; ++k) {\n+        v[k] = new double[dimension];\n+        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n+      }\n+\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new DormandPrince853StepInterpolator(this);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+\n+    super.reinitialize(equations, y, yDotK, forward);\n+\n+    final int dimension = currentState.length;\n+\n+    yDotKLast = new double[3][];\n+    for (int k = 0; k < yDotKLast.length; ++k) {\n+      yDotKLast[k] = new double[dimension];\n+    }\n+\n+    v = new double[7][];\n+    for (int k = 0; k < v.length; ++k) {\n+      v[k]  = new double[dimension];\n+    }\n+\n+    vectorsInitialized = false;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void storeTime(final double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v == null) {\n+        v = new double[7][];\n+        for (int k = 0; k < 7; ++k) {\n+          v[k] = new double[interpolatedState.length];\n+        }\n+      }\n+\n+      // perform the last evaluations if they have not been done yet\n+      finalizeStep();\n+\n+      // compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+        v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i] +\n+                       b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i] +\n+                       b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);\n+        v[1][i] = h * yDotK[0][i] - v[0][i];\n+        v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];\n+        for (int k = 0; k < d.length; ++k) {\n+          v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i] +\n+                           d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i] +\n+                           d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i] +\n+                           d[k][9]  * yDotKLast[0][i] +\n+                           d[k][10] * yDotKLast[1][i] +\n+                           d[k][11] * yDotKLast[2][i]);\n+        }\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    final double eta = oneMinusThetaH / h;\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] =\n+          currentState[i] - eta * (v[0][i] - theta * (v[1][i] +\n+                  theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] +\n+                          eta * (v[5][i] + theta * (v[6][i])))))));\n+    }\n+\n+  }\n+ \n+  /** {@inheritDoc} */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+\n+    if (currentState == null) {\n+      // we are finalizing an uninitialized instance\n+      return;\n+    }\n+\n+    double s;\n+    final double[] yTmp = new double[currentState.length];\n+\n+    // k14\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j] +\n+          k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j] +\n+          k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+\n+    // k15\n+    for (int j = 0; j < currentState.length; ++j) {\n+     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j] +\n+         k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j] +\n+         k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j] +\n+         k15_14 * yDotKLast[0][j];\n+     yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+\n+    // k16\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j] +\n+          k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j] +\n+          k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j] +\n+          k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    try {\n+      // save the local attributes\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+    out.writeInt(currentState.length);\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(yDotKLast[0][i]);\n+      out.writeDouble(yDotKLast[1][i]);\n+      out.writeDouble(yDotKLast[2][i]);\n+    }\n+\n+    // save the state of the base class\n+    super.writeExternal(out);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the local attributes\n+    yDotKLast = new double[3][];\n+    final int dimension = in.readInt();\n+    yDotKLast[0] = new double[dimension];\n+    yDotKLast[1] = new double[dimension];\n+    yDotKLast[2] = new double[dimension];\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      yDotKLast[0][i] = in.readDouble();\n+      yDotKLast[1][i] = in.readDouble();\n+      yDotKLast[2][i] = in.readDouble();\n+    }\n+\n+    // read the base state\n+    super.readExternal(in);\n+\n+  }\n+\n+  /** Last evaluations. */\n+  private double[][] yDotKLast;\n+\n+  /** Vectors for interpolation. */\n+  private double[][] v;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  /** Propagation weights, element 1. */\n+  private static final double b_01 =         104257.0 / 1920240.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Propagation weights, element 6. */\n+  private static final double b_06 =        3399327.0 / 763840.0;\n+\n+  /** Propagation weights, element 7. */\n+  private static final double b_07 =       66578432.0 / 35198415.0;\n+\n+  /** Propagation weights, element 8. */\n+  private static final double b_08 =    -1674902723.0 / 288716400.0;\n+\n+  /** Propagation weights, element 9. */\n+  private static final double b_09 = 54980371265625.0 / 176692375811392.0;\n+\n+  /** Propagation weights, element 10. */\n+  private static final double b_10 =        -734375.0 / 4826304.0;\n+\n+  /** Propagation weights, element 11. */\n+  private static final double b_11 =      171414593.0 / 851261400.0;\n+\n+  /** Propagation weights, element 12. */\n+  private static final double b_12 =         137909.0 / 3084480.0;\n+\n+  /** Time step for stage 14 (interpolation only). */\n+  private static final double c14    = 1.0 / 10.0;\n+\n+  /** Internal weights for stage 14, element 1. */\n+  private static final double k14_01 =       13481885573.0 / 240030000000.0      - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 14, element 6. */\n+  private static final double k14_06 =                 0.0                       - b_06;\n+\n+  /** Internal weights for stage 14, element 7. */\n+  private static final double k14_07 =      139418837528.0 / 549975234375.0      - b_07;\n+\n+  /** Internal weights for stage 14, element 8. */\n+  private static final double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;\n+\n+  /** Internal weights for stage 14, element 9. */\n+  private static final double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;\n+\n+  /** Internal weights for stage 14, element 10. */\n+  private static final double k14_10 =          57799439.0 / 377055000.0         - b_10;\n+\n+  /** Internal weights for stage 14, element 11. */\n+  private static final double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;\n+\n+  /** Internal weights for stage 14, element 12. */\n+  private static final double k14_12 =        1458939311.0 / 192780000000.0      - b_12;\n+\n+  /** Internal weights for stage 14, element 13. */\n+  private static final double k14_13 =             -4149.0 / 500000.0;\n+\n+  /** Time step for stage 15 (interpolation only). */\n+  private static final double c15    = 1.0 / 5.0;\n+\n+\n+  /** Internal weights for stage 15, element 1. */\n+  private static final double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 15, element 6. */\n+  private static final double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;\n+\n+  /** Internal weights for stage 15, element 7. */\n+  private static final double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;\n+\n+  /** Internal weights for stage 15, element 8. */\n+  private static final double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;\n+\n+  /** Internal weights for stage 15, element 9. */\n+  private static final double k15_09 =                 0.0                       - b_09;\n+\n+  /** Internal weights for stage 15, element 10. */\n+  private static final double k15_10 =                 0.0                       - b_10;\n+\n+  /** Internal weights for stage 15, element 11. */\n+  private static final double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;\n+\n+  /** Internal weights for stage 15, element 12. */\n+  private static final double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;\n+\n+  /** Internal weights for stage 15, element 13. */\n+  private static final double k15_13 =      -11518334563.0 / 33831184612500.0;\n+\n+  /** Internal weights for stage 15, element 14. */\n+  private static final double k15_14 =        1912306948.0 / 13532473845.0;\n+\n+  /** Time step for stage 16 (interpolation only). */\n+  private static final double c16    = 7.0 / 9.0;\n+\n+\n+  /** Internal weights for stage 16, element 1. */\n+  private static final double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 16, element 6. */\n+  private static final double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;\n+\n+  /** Internal weights for stage 16, element 7. */\n+  private static final double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;\n+\n+  /** Internal weights for stage 16, element 8. */\n+  private static final double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;\n+\n+  /** Internal weights for stage 16, element 9. */\n+  private static final double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;\n+\n+  /** Internal weights for stage 16, element 10. */\n+  private static final double k16_10 =                 0.0                       - b_10;\n+\n+  /** Internal weights for stage 16, element 11. */\n+  private static final double k16_11 =                 0.0                       - b_11;\n+\n+  /** Internal weights for stage 16, element 12. */\n+  private static final double k16_12 =                 0.0                       - b_12;\n+\n+  /** Internal weights for stage 16, element 13. */\n+  private static final double k16_13 =       -1199007803.0 / 857031517296.0;\n+\n+  /** Internal weights for stage 16, element 14. */\n+  private static final double k16_14 =      157882067000.0 / 53564469831.0;\n+\n+  /** Internal weights for stage 16, element 15. */\n+  private static final double k16_15 =     -290468882375.0 / 31741908048.0;\n+\n+  /** Interpolation weights.\n+   * (beware that only the non-null values are in the table)\n+   */\n+  private static final double[][] d = {\n+\n+    {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n+            -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n+      3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n+            2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n+                  -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n+                -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n+\n+    {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n+           19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n+     -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n+          -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n+                  2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n+                -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n+\n+    {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n+          -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n+      -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n+             -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n+                -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n+                519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n+\n+    {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n+            -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n+      2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n+              53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n+                 -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n+                 -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n+\n+  };\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 7152276390558450974L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+\n+/**\n+ * This class implements the common part of all embedded Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These methods are embedded explicit Runge-Kutta methods with two\n+ * sets of coefficients allowing to estimate the error, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ *       |  b'1  b'2 ...   b's-1 b's\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>In fact, we rather use the array defined by ej = bj - b'j to\n+ * compute directly the error rather than computing two estimates and\n+ * then comparing them.</p>\n+ *\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public abstract class EmbeddedRungeKuttaIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(final boolean fsal,\n+                                         final double[] c, final double[][] a, final double[] b,\n+                                         final RungeKuttaStepInterpolator prototype,\n+                                         final double minStep, final double maxStep,\n+                                         final double scalAbsoluteTolerance,\n+                                         final double scalRelativeTolerance) {\n+\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(final boolean fsal,\n+                                         final double[] c, final double[][] a, final double[] b,\n+                                         final RungeKuttaStepInterpolator prototype,\n+                                         final double   minStep, final double maxStep,\n+                                         final double[] vecAbsoluteTolerance,\n+                                         final double[] vecRelativeTolerance) {\n+\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract String getName();\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public abstract int getOrder();\n+\n+  /** Get the safety factor for stepsize control.\n+   * @return safety factor\n+   */\n+  public double getSafety() {\n+    return safety;\n+  }\n+\n+  /** Set the safety factor for stepsize control.\n+   * @param safety safety factor\n+   */\n+  public void setSafety(final double safety) {\n+    this.safety = safety;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void integrate(final FirstOrderDifferentialEquations equations,\n+                        final double t0, final double[] y0,\n+                        final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    final double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    final double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    stepStart  = t0;\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    boolean lastStep;\n+    handler.reset();\n+    do {\n+\n+      interpolator.shift();\n+\n+      double error = 0;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(stepStart, y, yDotK[0]);\n+        }\n+\n+        if (firstTime) {\n+          final double[] scale;\n+          if (vecAbsoluteTolerance != null) {\n+            scale = vecAbsoluteTolerance;\n+          } else {\n+            scale = new double[y0.length];\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = scalAbsoluteTolerance;\n+            }\n+          }\n+          hNew = initializeStep(equations, forward, getOrder(), scale,\n+                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+          firstTime = false;\n+        }\n+\n+        stepSize = hNew;\n+\n+        // step adjustment near bounds\n+        if ((forward && (stepStart + stepSize > t)) ||\n+            ((! forward) && (stepStart + stepSize < t))) {\n+          stepSize = t - stepStart;\n+        }\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n+        if (error <= 1.0) {\n+\n+          // Discrete events handling\n+          interpolator.storeTime(stepStart + stepSize);\n+          if (eventsHandlersManager.evaluateStep(interpolator)) {\n+            // reject the step to match exactly the next switch time\n+            hNew = eventsHandlersManager.getEventTime() - stepStart;\n+          } else {\n+            // accept the step\n+            loop = false;\n+          }\n+\n+        } else {\n+          // reject the step and attempt to reduce error by stepsize control\n+          final double factor =\n+              Math.min(maxGrowth,\n+                       Math.max(minReduction, safety * Math.pow(error, exp)));\n+          hNew = filterStep(stepSize * factor, false);\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      final double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      eventsHandlersManager.stepAccepted(nextStep, y);\n+      if (eventsHandlersManager.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = forward ? (nextStep >= t) : (nextStep <= t);\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      handler.handleStep(interpolator, lastStep);\n+      stepStart = nextStep;\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n+        // some event handler has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      if (! lastStep) {\n+        // stepsize control for next step\n+        final double factor = Math.min(maxGrowth,\n+                                       Math.max(minReduction,\n+                                                safety * Math.pow(error, exp)));\n+        final double  scaledH    = stepSize * factor;\n+        final double  nextT      = stepStart + scaledH;\n+        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+        hNew = filterStep(scaledH, nextIsLast);\n+      }\n+\n+    } while (! lastStep);\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Get the minimal reduction factor for stepsize control.\n+   * @return minimal reduction factor\n+   */\n+  public double getMinReduction() {\n+    return minReduction;\n+  }\n+\n+  /** Set the minimal reduction factor for stepsize control.\n+   * @param minReduction minimal reduction factor\n+   */\n+  public void setMinReduction(final double minReduction) {\n+    this.minReduction = minReduction;\n+  }\n+\n+  /** Get the maximal growth factor for stepsize control.\n+   * @return maximal growth factor\n+   */\n+  public double getMaxGrowth() {\n+    return maxGrowth;\n+  }\n+\n+  /** Set the maximal growth factor for stepsize control.\n+   * @param maxGrowth maximal growth factor\n+   */\n+  public void setMaxGrowth(final double maxGrowth) {\n+    this.maxGrowth = maxGrowth;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected abstract double estimateError(double[][] yDotK,\n+                                          double[] y0, double[] y1,\n+                                          double h);\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Stepsize control exponent. */\n+  private double exp;\n+\n+  /** Safety factor for stepsize control. */\n+  private double safety;\n+\n+  /** Minimal reduction factor for stepsize control. */\n+  private double minReduction;\n+\n+  /** Maximal growth factor for stepsize control. */\n+  private double maxGrowth;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements a simple Euler integrator for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>The Euler algorithm is the simplest one that can be used to\n+ * integrate ordinary differential equations. It is a simple inversion\n+ * of the forward difference expression :\n+ * <code>f'=(f(t+h)-f(t))/h</code> which leads to\n+ * <code>f(t+h)=f(t)+hf'</code>. The interpolation scheme used for\n+ * dense output is the linear scheme already used for integration.</p>\n+ *\n+ * <p>This algorithm looks cheap because it needs only one function\n+ * evaluation per step. However, as it uses linear estimates, it needs\n+ * very small steps to achieve high accuracy, and small steps lead to\n+ * numerical errors and instabilities.</p>\n+ *\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a comparison reference for more useful\n+ * integrators.</p>\n+ *\n+ * @see MidpointIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class EulerIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -3378479003330094013L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"Euler\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build an Euler integrator with the given step.\n+   * @param step integration step\n+   */\n+  public EulerIntegrator(final double step) {\n+    super(c, a, b, new EulerStepInterpolator(), step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a linear interpolator for step.\n+ *\n+ * <p>This interpolator allow to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y' is the evaluation of\n+ * the derivatives already computed during the step.</p>\n+ *\n+ * @see EulerIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class EulerStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public EulerStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public EulerStepInterpolator(final EulerStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new EulerStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -7179861704951334960L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the Gill fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations .\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |    0        0       0      0\n+ *   1/2 |   1/2       0       0      0\n+ *   1/2 | (q-1)/2  (2-q)/2    0      0\n+ *    1  |    0       -q/2  (2+q)/2   0\n+ *       |-------------------------------\n+ *       |   1/6    (2-q)/6 (2+q)/6  1/6\n+ * </pre>\n+ * where q = sqrt(2)</p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GillIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -3270987073897562791L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"Gill\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { (Math.sqrt(2.0) - 1.0) / 2.0, (2.0 - Math.sqrt(2.0)) / 2.0 },\n+    { 0.0, -Math.sqrt(2.0) / 2.0, (2.0 + Math.sqrt(2.0)) / 2.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 6.0, (2.0 - Math.sqrt(2.0)) / 6.0, (2.0 + Math.sqrt(2.0)) / 6.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Gill integrator with the given step.\n+   * @param step integration step\n+   */\n+  public GillIntegrator(final double step) {\n+    super(c, a, b, new GillStepInterpolator(), step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the Gill fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n+ *                                        + (1 - theta) (1 + 2 theta) ((2-q) y'_2 + (2+q) y'_3)\n+ *                                        + (1 + theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n+ * are the four evaluations of the derivatives already computed during\n+ * the step.</p>\n+ *\n+ * @see GillIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class GillStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public GillStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GillStepInterpolator(final GillStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new GillStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double fourTheta = 4 * theta;\n+    final double s         = oneMinusThetaH / 6.0;\n+    final double soMt      = s * (1 - theta);\n+    final double c23       = soMt * (1 + 2 * theta);\n+    final double coeff1    = soMt * (1 - fourTheta);\n+    final double coeff2    = c23  * tMq;\n+    final double coeff3    = c23  * tPq;\n+    final double coeff4    = s * (1 + theta * (1 + fourTheta));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] -\n+                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -\n+                             coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  /** First Gill coefficient. */\n+  private static final double tMq = 2 - Math.sqrt(2.0);\n+\n+  /** Second Gill coefficient. */\n+  private static final double tPq = 2 + Math.sqrt(2.0);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -107804074496313322L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements a Gragg-Bulirsch-Stoer integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient\n+ * ones currently available for smooth problems. It uses Richardson\n+ * extrapolation to estimate what would be the solution if the step\n+ * size could be decreased down to zero.</p>\n+ *\n+ * <p>\n+ * This method changes both the step size and the order during\n+ * integration, in order to minimize computation cost. It is\n+ * particularly well suited when a very high precision is needed. The\n+ * limit where this method becomes more efficient than high-order\n+ * embedded Runge-Kutta methods like {@link DormandPrince853Integrator\n+ * Dormand-Prince 8(5,3)} depends on the problem. Results given in the\n+ * Hairer, Norsett and Wanner book show for example that this limit\n+ * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz\n+ * equations (the authors note this problem is <i>extremely sensitive\n+ * to the errors in the first integration steps</i>), and around 1e-11\n+ * for a two dimensional celestial mechanics problems with seven\n+ * bodies (pleiades problem, involving quasi-collisions for which\n+ * <i>automatic step size control is essential</i>).\n+ * </p>\n+ *\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+ *\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+ *\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+ *\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GraggBulirschStoerIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -1263159462413447366L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"Gragg-Bulirsch-Stoer\";\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n+                                      final double scalAbsoluteTolerance,\n+                                      final double scalRelativeTolerance) {\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n+                                      final double[] vecAbsoluteTolerance,\n+                                      final double[] vecRelativeTolerance) {\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Set the stability check controls.\n+   * <p>The stability check is performed on the first few iterations of\n+   * the extrapolation scheme. If this test fails, the step is rejected\n+   * and the stepsize is reduced.</p>\n+   * <p>By default, the test is performed, at most during two\n+   * iterations at each step, and at most once for each of these\n+   * iterations. The default stepsize reduction factor is 0.5.</p>\n+   * @param performTest if true, stability check will be performed,\n+     if false, the check will be skipped\n+   * @param maxIter maximal number of iterations for which checks are\n+   * performed (the number of iterations is reset to default if negative\n+   * or null)\n+   * @param maxChecks maximal number of checks for each iteration\n+   * (the number of checks is reset to default if negative or null)\n+   * @param stabilityReduction stepsize reduction factor in case of\n+   * failure (the factor is reset to default if lower than 0.0001 or\n+   * greater than 0.9999)\n+   */\n+  public void setStabilityCheck(final boolean performTest,\n+                                final int maxIter, final int maxChecks,\n+                                final double stabilityReduction) {\n+\n+    this.performTest = performTest;\n+    this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;\n+    this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;\n+\n+    if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {\n+      this.stabilityReduction = 0.5;\n+    } else {\n+      this.stabilityReduction = stabilityReduction;\n+    }\n+\n+  }\n+\n+  /** Set the step size control factors.\n+\n+   * <p>The new step size hNew is computed from the old one h by:\n+   * <pre>\n+   * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))\n+   * </pre>\n+   * where err is the scaled error and k the iteration number of the\n+   * extrapolation scheme (counting from 0). The default values are\n+   * 0.65 for stepControl1 and 0.94 for stepControl2.</p>\n+   * <p>The step size is subject to the restriction:\n+   * <pre>\n+   * stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))\n+   * </pre>\n+   * The default values are 0.02 for stepControl3 and 4.0 for\n+   * stepControl4.</p>\n+   * @param stepControl1 first stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl2 second stepsize control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl3 third stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl4 fourth stepsize control factor (the factor\n+   * is reset to default if lower than 1.0001 or greater than 999.9)\n+   */\n+  public void setStepsizeControl(final double stepControl1, final double stepControl2,\n+                                 final double stepControl3, final double stepControl4) {\n+\n+    if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {\n+      this.stepControl1 = 0.65;\n+    } else {\n+      this.stepControl1 = stepControl1;\n+    }\n+\n+    if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {\n+      this.stepControl2 = 0.94;\n+    } else {\n+      this.stepControl2 = stepControl2;\n+    }\n+\n+    if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {\n+      this.stepControl3 = 0.02;\n+    } else {\n+      this.stepControl3 = stepControl3;\n+    }\n+\n+    if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {\n+      this.stepControl4 = 4.0;\n+    } else {\n+      this.stepControl4 = stepControl4;\n+    }\n+\n+  }\n+\n+  /** Set the order control parameters.\n+   * <p>The Gragg-Bulirsch-Stoer method changes both the step size and\n+   * the order during integration, in order to minimize computation\n+   * cost. Each extrapolation step increases the order by 2, so the\n+   * maximal order that will be used is always even, it is twice the\n+   * maximal number of columns in the extrapolation table.</p>\n+   * <pre>\n+   * order is decreased if w(k-1) <= w(k)   * orderControl1\n+   * order is increased if w(k)   <= w(k-1) * orderControl2\n+   * </pre>\n+   * <p>where w is the table of work per unit step for each order\n+   * (number of function calls divided by the step length), and k is\n+   * the current order.</p>\n+   * <p>The default maximal order after construction is 18 (i.e. the\n+   * maximal number of columns is 9). The default values are 0.8 for\n+   * orderControl1 and 0.9 for orderControl2.</p>\n+   * @param maxOrder maximal order in the extrapolation table (the\n+   * maximal order is reset to default if order <= 6 or odd)\n+   * @param orderControl1 first order control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param orderControl2 second order control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   */\n+  public void setOrderControl(final int maxOrder,\n+                              final double orderControl1, final double orderControl2) {\n+\n+    if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {\n+      this.maxOrder = 18;\n+    }\n+\n+    if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {\n+      this.orderControl1 = 0.8;\n+    } else {\n+      this.orderControl1 = orderControl1;\n+    }\n+\n+    if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {\n+      this.orderControl2 = 0.9;\n+    } else {\n+      this.orderControl2 = orderControl2;\n+    }\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (final StepHandler handler) {\n+\n+    super.setStepHandler(handler);\n+    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void addEventHandler(final EventHandler function,\n+                              final double maxCheckInterval,\n+                              final double convergence,\n+                              final int maxIterationCount) {\n+    super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n+    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Initialize the integrator internal arrays. */\n+  private void initializeArrays() {\n+\n+    final int size = maxOrder / 2;\n+\n+    if ((sequence == null) || (sequence.length != size)) {\n+      // all arrays should be reallocated with the right size\n+      sequence        = new int[size];\n+      costPerStep     = new int[size];\n+      coeff           = new double[size][];\n+      costPerTimeUnit = new double[size];\n+      optimalStep     = new double[size];\n+    }\n+\n+    if (denseOutput) {\n+      // step size sequence: 2, 6, 10, 14, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 4 * k + 2;\n+      }\n+    } else {\n+      // step size sequence: 2, 4, 6, 8, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 2 * (k + 1); \n+      }\n+    }\n+\n+    // initialize the order selection cost array\n+    // (number of function calls for each column of the extrapolation table)\n+    costPerStep[0] = sequence[0] + 1;\n+    for (int k = 1; k < size; ++k) {\n+      costPerStep[k] = costPerStep[k-1] + sequence[k];\n+    }\n+\n+    // initialize the extrapolation tables\n+    for (int k = 0; k < size; ++k) {\n+      coeff[k] = (k > 0) ? new double[k] : null;\n+      for (int l = 0; l < k; ++l) {\n+        final double ratio = ((double) sequence[k]) / sequence[k-l-1];\n+        coeff[k][l] = 1.0 / (ratio * ratio - 1.0);\n+      }\n+    }\n+\n+  }\n+\n+  /** Set the interpolation order control parameter.\n+   * The interpolation order for dense output is 2k - mudif + 1. The\n+   * default value for mudif is 4 and the interpolation error is used\n+   * in stepsize control by default.\n+\n+   * @param useInterpolationError if true, interpolation error is used\n+   * for stepsize control\n+   * @param mudif interpolation order control parameter (the parameter\n+   * is reset to default if <= 0 or >= 7)\n+   */\n+  public void setInterpolationControl(final boolean useInterpolationError,\n+                                      final int mudif) {\n+\n+    this.useInterpolationError = useInterpolationError;\n+\n+    if ((mudif <= 0) || (mudif >= 7)) {\n+      this.mudif = 4;\n+    } else {\n+      this.mudif = mudif;\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Update scaling array.\n+   * @param y1 first state vector to use for scaling\n+   * @param y2 second state vector to use for scaling\n+   * @param scale scaling array to update\n+   */\n+  private void rescale(final double[] y1, final double[] y2, final double[] scale) {\n+    if (vecAbsoluteTolerance == null) {\n+      for (int i = 0; i < scale.length; ++i) {\n+        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n+      }\n+    } else {\n+      for (int i = 0; i < scale.length; ++i) {\n+        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n+      }\n+    }\n+  }\n+\n+  /** Perform integration over one step using substeps of a modified\n+   * midpoint method.\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param step global step\n+   * @param k iteration number (from 0 to sequence.length - 1)\n+   * @param scale scaling array\n+   * @param f placeholder where to put the state vector derivatives at each substep\n+   *          (element 0 already contains initial derivative)\n+   * @param yMiddle placeholder where to put the state vector at the middle of the step\n+   * @param yEnd placeholder where to put the state vector at the end\n+   * @param yTmp placeholder for one state vector\n+   * @return true if computation was done properly,\n+   *         false if stability check failed before end of computation\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  private boolean tryStep(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0, final double step, final int k,\n+                          final double[] scale, final double[][] f,\n+                          final double[] yMiddle, final double[] yEnd,\n+                          final double[] yTmp)\n+    throws DerivativeException {\n+\n+    final int    n        = sequence[k];\n+    final double subStep  = step / n;\n+    final double subStep2 = 2 * subStep;\n+\n+    // first substep\n+    double t = t0 + subStep;\n+    for (int i = 0; i < y0.length; ++i) {\n+      yTmp[i] = y0[i];\n+      yEnd[i] = y0[i] + subStep * f[0][i];\n+    }\n+    equations.computeDerivatives(t, yEnd, f[1]);\n+\n+    // other substeps\n+    for (int j = 1; j < n; ++j) {\n+\n+      if (2 * j == n) {\n+        // save the point at the middle of the step\n+        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n+      }\n+\n+      t += subStep;\n+      for (int i = 0; i < y0.length; ++i) {\n+        final double middle = yEnd[i];\n+        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n+        yTmp[i]       = middle;\n+      }\n+\n+      equations.computeDerivatives(t, yEnd, f[j+1]);\n+\n+      // stability check\n+      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n+        double initialNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          final double ratio = f[0][l] / scale[l];\n+          initialNorm += ratio * ratio;\n+        }\n+        double deltaNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n+          deltaNorm += ratio * ratio;\n+        }\n+        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {\n+          return false;\n+        }\n+      }\n+\n+    }\n+\n+    // correction of the last substep (at t0 + step)\n+    for (int i = 0; i < y0.length; ++i) {\n+      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  /** Extrapolate a vector.\n+   * @param offset offset to use in the coefficients table\n+   * @param k index of the last updated point\n+   * @param diag working diagonal of the Aitken-Neville's\n+   * triangle, without the last element\n+   * @param last last element\n+   */\n+  private void extrapolate(final int offset, final int k,\n+                           final double[][] diag, final double[] last) {\n+\n+    // update the diagonal\n+    for (int j = 1; j < k; ++j) {\n+      for (int i = 0; i < last.length; ++i) {\n+        // Aitken-Neville's recursive formula\n+        diag[k-j-1][i] = diag[k-j][i] +\n+                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n+      }\n+    }\n+\n+    // update the last element\n+    for (int i = 0; i < last.length; ++i) {\n+      // Aitken-Neville's recursive formula\n+      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);\n+    }\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void integrate(final FirstOrderDifferentialEquations equations,\n+                        final double t0, final double[] y0, final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final double[] yDot0   = new double[y0.length];\n+    final double[] y1      = new double[y0.length];\n+    final double[] yTmp    = new double[y0.length];\n+    final double[] yTmpDot = new double[y0.length];\n+\n+    final double[][] diagonal = new double[sequence.length-1][];\n+    final double[][] y1Diag = new double[sequence.length-1][];\n+    for (int k = 0; k < sequence.length-1; ++k) {\n+      diagonal[k] = new double[y0.length];\n+      y1Diag[k] = new double[y0.length];\n+    }\n+\n+    final double[][][] fk  = new double[sequence.length][][];\n+    for (int k = 0; k < sequence.length; ++k) {\n+\n+      fk[k]    = new double[sequence[k] + 1][];\n+\n+      // all substeps start at the same point, so share the first array\n+      fk[k][0] = yDot0;\n+\n+      for (int l = 0; l < sequence[k]; ++l) {\n+        fk[k][l+1] = new double[y0.length];\n+      }\n+\n+    }\n+\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+\n+    double[] yDot1      = null;\n+    double[][] yMidDots = null;\n+    if (denseOutput) {\n+      yDot1    = new double[y0.length];\n+      yMidDots = new double[1 + 2 * sequence.length][];\n+      for (int j = 0; j < yMidDots.length; ++j) {\n+        yMidDots[j] = new double[y0.length];\n+      }\n+    } else {\n+      yMidDots    = new double[1][];\n+      yMidDots[0] = new double[y0.length];\n+    }\n+\n+    // initial scaling\n+    final double[] scale = new double[y0.length];\n+    rescale(y, y, scale);\n+\n+    // initial order selection\n+    final double tol =\n+        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n+    final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);\n+    int targetIter = Math.max(1,\n+                              Math.min(sequence.length - 2,\n+                                       (int) Math.floor(0.5 - 0.6 * log10R)));\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator = null;\n+    if (denseOutput || (! eventsHandlersManager.isEmpty())) {\n+      interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n+                                                            y1, yDot1,\n+                                                            yMidDots, forward);\n+    } else {\n+      interpolator = new DummyStepInterpolator(y, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    stepStart = t0;\n+    double  hNew             = 0;\n+    double  maxError         = Double.MAX_VALUE;\n+    boolean previousRejected = false;\n+    boolean firstTime        = true;\n+    boolean newStep          = true;\n+    boolean lastStep         = false;\n+    boolean firstStepAlreadyComputed = false;\n+    handler.reset();\n+    costPerTimeUnit[0] = 0;\n+    while (! lastStep) {\n+\n+      double error;\n+      boolean reject = false;\n+\n+      if (newStep) {\n+\n+        interpolator.shift();\n+\n+        // first evaluation, at the beginning of the step\n+        if (! firstStepAlreadyComputed) {\n+          equations.computeDerivatives(stepStart, y, yDot0);\n+        }\n+\n+        if (firstTime) {\n+\n+          hNew = initializeStep(equations, forward,\n+                                2 * targetIter + 1, scale,\n+                                stepStart, y, yDot0, yTmp, yTmpDot);\n+\n+          if (! forward) {\n+            hNew = -hNew;\n+          }\n+\n+        }\n+\n+        newStep = false;\n+\n+      }\n+\n+      stepSize = hNew;\n+\n+      // step adjustment near bounds\n+      if ((forward && (stepStart + stepSize > t)) ||\n+          ((! forward) && (stepStart + stepSize < t))) {\n+        stepSize = t - stepStart;\n+      }\n+      final double nextT = stepStart + stepSize;\n+      lastStep = forward ? (nextT >= t) : (nextT <= t);\n+\n+      // iterate over several substep sizes\n+      int k = -1;\n+      for (boolean loop = true; loop; ) {\n+\n+        ++k;\n+\n+        // modified midpoint integration with the current substep\n+        if ( ! tryStep(equations, stepStart, y, stepSize, k, scale, fk[k],\n+                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n+                       (k == 0) ? y1 : y1Diag[k-1],\n+                       yTmp)) {\n+\n+          // the stability check failed, we reduce the global step\n+          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));\n+          reject = true;\n+          loop   = false;\n+\n+        } else {\n+\n+          // the substep was computed successfully\n+          if (k > 0) {\n+\n+            // extrapolate the state at the end of the step\n+            // using last iteration data\n+            extrapolate(0, k, y1Diag, y1);\n+            rescale(y, y1, scale);\n+\n+            // estimate the error at the end of the step.\n+            error = 0;\n+            for (int j = 0; j < y0.length; ++j) {\n+              final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n+              error += e * e;\n+            }\n+            error = Math.sqrt(error / y0.length);\n+\n+            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n+              // error is too big, we reduce the global step\n+              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));\n+              reject = true;\n+              loop   = false;\n+            } else {\n+\n+              maxError = Math.max(4 * error, 1.0);\n+\n+              // compute optimal stepsize for this order\n+              final double exp = 1.0 / (2 * k + 1);\n+              double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n+              final double pow = Math.pow(stepControl3, exp);\n+              fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n+              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, true));\n+              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n+\n+              // check convergence\n+              switch (k - targetIter) {\n+\n+              case -1 :\n+                if ((targetIter > 1) && ! previousRejected) {\n+\n+                  // check if we can stop iterations now\n+                  if (error <= 1.0) {\n+                    // convergence have been reached just before targetIter\n+                    loop = false;\n+                  } else {\n+                    // estimate if there is a chance convergence will\n+                    // be reached on next iteration, using the\n+                    // asymptotic evolution of error\n+                    final double ratio = ((double) sequence [k] * sequence[k+1]) /\n+                                         (sequence[0] * sequence[0]);\n+                    if (error > ratio * ratio) {\n+                      // we don't expect to converge on next iteration\n+                      // we reject the step immediately and reduce order\n+                      reject = true;\n+                      loop   = false;\n+                      targetIter = k;\n+                      if ((targetIter > 1) &&\n+                          (costPerTimeUnit[targetIter-1] <\n+                           orderControl1 * costPerTimeUnit[targetIter])) {\n+                        --targetIter;\n+                      }\n+                      hNew = optimalStep[targetIter];\n+                    }\n+                  }\n+                }\n+                break;\n+\n+              case 0:\n+                if (error <= 1.0) {\n+                  // convergence has been reached exactly at targetIter\n+                  loop = false;\n+                } else {\n+                  // estimate if there is a chance convergence will\n+                  // be reached on next iteration, using the\n+                  // asymptotic evolution of error\n+                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n+                  if (error > ratio * ratio) {\n+                    // we don't expect to converge on next iteration\n+                    // we reject the step immediately\n+                    reject = true;\n+                    loop = false;\n+                    if ((targetIter > 1) &&\n+                        (costPerTimeUnit[targetIter-1] <\n+                         orderControl1 * costPerTimeUnit[targetIter])) {\n+                      --targetIter;\n+                    }\n+                    hNew = optimalStep[targetIter];\n+                  }\n+                }\n+                break;\n+\n+              case 1 :\n+                if (error > 1.0) {\n+                  reject = true;\n+                  if ((targetIter > 1) &&\n+                      (costPerTimeUnit[targetIter-1] <\n+                       orderControl1 * costPerTimeUnit[targetIter])) {\n+                    --targetIter;\n+                  }\n+                  hNew = optimalStep[targetIter];\n+                }\n+                loop = false;\n+                break;\n+\n+              default :\n+                if ((firstTime || lastStep) && (error <= 1.0)) {\n+                  loop = false;\n+                }\n+                break;\n+\n+              }\n+\n+            }\n+          }\n+        }\n+      }\n+\n+      // dense output handling\n+      double hInt = getMaxStep();\n+      if (denseOutput && ! reject) {\n+\n+        // extrapolate state at middle point of the step\n+        for (int j = 1; j <= k; ++j) {\n+          extrapolate(0, j, diagonal, yMidDots[0]);\n+        }\n+\n+        // derivative at end of step\n+        equations.computeDerivatives(stepStart + stepSize, y1, yDot1);\n+\n+        final int mu = 2 * k - mudif + 3;\n+\n+        for (int l = 0; l < mu; ++l) {\n+\n+          // derivative at middle point of the step\n+          final int l2 = l / 2;\n+          double factor = Math.pow(0.5 * sequence[l2], l);\n+          int middleIndex = fk[l2].length / 2;\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n+          }\n+          for (int j = 1; j <= k - l2; ++j) {\n+            factor = Math.pow(0.5 * sequence[j + l2], l);\n+            middleIndex = fk[l2+j].length / 2;\n+            for (int i = 0; i < y0.length; ++i) {\n+              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n+            }\n+            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n+          }\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] *= stepSize;\n+          }\n+\n+          // compute centered differences to evaluate next derivatives\n+          for (int j = (l + 1) / 2; j <= k; ++j) {\n+            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n+              for (int i = 0; i < y0.length; ++i) {\n+                fk[j][m][i] -= fk[j][m-2][i];\n+              }\n+            }\n+          }\n+\n+        }\n+\n+        if (mu >= 0) {\n+\n+          // estimate the dense output coefficients\n+          final GraggBulirschStoerStepInterpolator gbsInterpolator\n+            = (GraggBulirschStoerStepInterpolator) interpolator;\n+          gbsInterpolator.computeCoefficients(mu, stepSize);\n+\n+          if (useInterpolationError) {\n+            // use the interpolation error to limit stepsize\n+            final double interpError = gbsInterpolator.estimateError(scale);\n+            hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+                                                0.01));\n+            if (interpError > 10.0) {\n+              hNew = hInt;\n+              reject = true;\n+            }\n+          }\n+\n+          // Discrete events handling\n+          if (!reject) {\n+            interpolator.storeTime(stepStart + stepSize);\n+            if (eventsHandlersManager.evaluateStep(interpolator)) {\n+              reject = true;\n+              hNew = Math.abs(eventsHandlersManager.getEventTime() - stepStart);\n+            }\n+          }\n+\n+        }\n+\n+        if (!reject) {\n+          // we will reuse the slope for the beginning of next step\n+          firstStepAlreadyComputed = true;\n+          System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n+        }\n+\n+      }\n+\n+      if (! reject) {\n+\n+        // store end of step state\n+        final double nextStep = stepStart + stepSize;\n+        System.arraycopy(y1, 0, y, 0, y0.length);\n+\n+        eventsHandlersManager.stepAccepted(nextStep, y);\n+        if (eventsHandlersManager.stop()) {\n+          lastStep = true;\n+        }\n+\n+        // provide the step data to the step handler\n+        interpolator.storeTime(nextStep);\n+        handler.handleStep(interpolator, lastStep);\n+        stepStart = nextStep;\n+\n+        if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n+          // some switching function has triggered changes that\n+          // invalidate the derivatives, we need to recompute them\n+          firstStepAlreadyComputed = false;\n+        }\n+\n+        int optimalIter;\n+        if (k == 1) {\n+          optimalIter = 2;\n+          if (previousRejected) {\n+            optimalIter = 1;\n+          }\n+        } else if (k <= targetIter) {\n+          optimalIter = k;\n+          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n+            optimalIter = k-1;\n+          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n+            optimalIter = Math.min(k+1, sequence.length - 2);\n+          }\n+        } else {\n+          optimalIter = k - 1;\n+          if ((k > 2) &&\n+              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n+            optimalIter = k - 2;\n+          }\n+          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n+            optimalIter = Math.min(k, sequence.length - 2);\n+          }\n+        }\n+\n+        if (previousRejected) {\n+          // after a rejected step neither order nor stepsize\n+          // should increase\n+          targetIter = Math.min(optimalIter, k);\n+          hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]);\n+        } else {\n+          // stepsize control\n+          if (optimalIter <= k) {\n+            hNew = optimalStep[optimalIter];\n+          } else {\n+            if ((k < targetIter) &&\n+                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n+              hNew = filterStep(optimalStep[k] *\n+                                costPerStep[optimalIter+1] / costPerStep[k],\n+                                false);\n+            } else {\n+              hNew = filterStep(optimalStep[k] *\n+                                costPerStep[optimalIter] / costPerStep[k],\n+                                false);\n+            }\n+          }\n+\n+          targetIter = optimalIter;\n+\n+        }\n+\n+        newStep = true;\n+\n+      }\n+\n+      hNew = Math.min(hNew, hInt);\n+      if (! forward) {\n+        hNew = -hNew;\n+      }\n+\n+      firstTime = false;\n+\n+      if (reject) {\n+        lastStep = false;\n+        previousRejected = true;\n+      } else {\n+        previousRejected = false;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** maximal order. */\n+  private int maxOrder;\n+\n+  /** step size sequence. */\n+  private int[] sequence;\n+\n+  /** overall cost of applying step reduction up to iteration k+1,\n+   *  in number of calls.\n+   */\n+  private int[] costPerStep;\n+\n+  /** cost per unit step. */\n+  private double[] costPerTimeUnit;\n+\n+  /** optimal steps for each order. */\n+  private double[] optimalStep;\n+\n+  /** extrapolation coefficients. */\n+  private double[][] coeff;\n+\n+  /** stability check enabling parameter. */\n+  private boolean performTest;\n+\n+  /** maximal number of checks for each iteration. */\n+  private int maxChecks;\n+\n+  /** maximal number of iterations for which checks are performed. */\n+  private int maxIter;\n+\n+  /** stepsize reduction factor in case of stability check failure. */\n+  private double stabilityReduction;\n+\n+  /** first stepsize control factor. */\n+  private double stepControl1;\n+\n+  /** second stepsize control factor. */\n+  private double stepControl2;\n+\n+  /** third stepsize control factor. */\n+  private double stepControl3;\n+\n+  /** fourth stepsize control factor. */\n+  private double stepControl4;\n+\n+  /** first order control factor. */\n+  private double orderControl1;\n+\n+  /** second order control factor. */\n+  private double orderControl2;\n+\n+  /** dense outpute required. */\n+  private boolean denseOutput;\n+\n+  /** use interpolation error in stepsize control. */\n+  private boolean useInterpolationError;\n+\n+  /** interpolation order control parameter. */\n+  private int mudif;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n+ * integrator.\n+ *\n+ * <p>This interpolator compute dense output inside the last step\n+ * produced by a Gragg-Bulirsch-Stoer integrator.</p>\n+ *\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+ *\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+ *\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+ *\n+ * @see GraggBulirschStoerIntegrator\n+ * @version $Revision$ $Date$\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @since 1.2\n+ */\n+\n+class GraggBulirschStoerStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Slope at the beginning of the step. */\n+  private double[] y0Dot;\n+\n+  /** State at the end of the step. */\n+  private double[] y1;\n+\n+  /** Slope at the end of the step. */\n+  private double[] y1Dot;\n+\n+  /** Derivatives at the middle of the step.\n+   * element 0 is state at midpoint, element 1 is first derivative ...\n+   */\n+  private double[][] yMidDots;\n+\n+  /** Interpolation polynoms. */\n+  private double[][] polynoms;\n+\n+  /** Error coefficients for the interpolation. */\n+  private double[] errfac;\n+\n+  /** Degree of the interpolation polynoms. */\n+  private int currentDegree;\n+\n+  /** Reallocate the internal tables.\n+   * Reallocate the internal tables in order to be able to handle\n+   * interpolation polynoms up to the given degree\n+   * @param maxDegree maximal degree to handle\n+   */\n+  private void resetTables(final int maxDegree) {\n+\n+    if (maxDegree < 0) {\n+      polynoms      = null;\n+      errfac        = null;\n+      currentDegree = -1;\n+    } else {\n+\n+      final double[][] newPols = new double[maxDegree + 1][];\n+      if (polynoms != null) {\n+        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);\n+        for (int i = polynoms.length; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      } else {\n+        for (int i = 0; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      }\n+      polynoms = newPols;\n+\n+      // initialize the error factors array for interpolation\n+      if (maxDegree <= 4) {\n+        errfac = null;\n+      } else {\n+        errfac = new double[maxDegree - 4];\n+        for (int i = 0; i < errfac.length; ++i) {\n+          final int ip5 = i + 5;\n+          errfac[i] = 1.0 / (ip5 * ip5);\n+          final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);\n+          for (int j = 0; j <= i; ++j) {\n+            errfac[i] *= e / (j + 1);\n+          }\n+        }\n+      }\n+\n+      currentDegree = 0;\n+\n+    }\n+\n+  }\n+\n+  /** Simple constructor.\n+   * This constructor should not be used directly, it is only intended\n+   * for the serialization process.\n+   */\n+  public GraggBulirschStoerStepInterpolator() {\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+    resetTables(-1);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the current state\n+   * @param y0Dot reference to the integrator array holding the slope\n+   * at the beginning of the step\n+   * @param y1 reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param y1Dot reference to the integrator array holding the slope\n+   * at theend of the step\n+   * @param yMidDots reference to the integrator array holding the\n+   * derivatives at the middle point of the step\n+   * @param forward integration direction indicator\n+   */\n+  public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,\n+                                            final double[] y1, final double[] y1Dot,\n+                                            final double[][] yMidDots,\n+                                            final boolean forward) {\n+\n+    super(y, forward);\n+    this.y0Dot    = y0Dot;\n+    this.y1       = y1;\n+    this.y1Dot    = y1Dot;\n+    this.yMidDots = yMidDots;\n+\n+    resetTables(yMidDots.length + 4);\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GraggBulirschStoerStepInterpolator\n+    (final GraggBulirschStoerStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    final int dimension = currentState.length;\n+\n+    // the interpolator has been finalized,\n+    // the following arrays are not needed anymore\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+\n+    // copy the interpolation polynoms (up to the current degree only)\n+    if (interpolator.polynoms == null) {\n+      polynoms = null;\n+      currentDegree = -1;\n+    } else {\n+      resetTables(interpolator.currentDegree);\n+      for (int i = 0; i < polynoms.length; ++i) {\n+        polynoms[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynoms[i], 0,\n+                         polynoms[i], 0, dimension);\n+      }\n+      currentDegree = interpolator.currentDegree;\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new GraggBulirschStoerStepInterpolator(this);\n+  }\n+\n+\n+  /** Compute the interpolation coefficients for dense output.\n+   * @param mu degree of the interpolation polynom\n+   * @param h current step\n+   */\n+  public void computeCoefficients(final int mu, final double h) {\n+\n+    if ((polynoms == null) || (polynoms.length <= (mu + 4))) {\n+      resetTables(mu + 4);\n+    }\n+\n+    currentDegree = mu + 4;\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+\n+      final double yp0   = h * y0Dot[i];\n+      final double yp1   = h * y1Dot[i];\n+      final double ydiff = y1[i] - currentState[i];\n+      final double aspl  = ydiff - yp1;\n+      final double bspl  = yp0 - ydiff;\n+\n+      polynoms[0][i] = currentState[i];\n+      polynoms[1][i] = ydiff;\n+      polynoms[2][i] = aspl;\n+      polynoms[3][i] = bspl;\n+\n+      if (mu < 0) {\n+        return;\n+      }\n+\n+      // compute the remaining coefficients\n+      final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);\n+      polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);\n+\n+      if (mu > 0) {\n+        final double ph1 = ydiff + 0.25 * (aspl - bspl);\n+        polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);\n+\n+        if (mu > 1) {\n+          final double ph2 = yp1 - yp0;\n+          polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);\n+\n+          if (mu > 2) {\n+            final double ph3 = 6 * (bspl - aspl);\n+            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);\n+\n+            for (int j = 4; j <= mu; ++j) {\n+              final double fac1 = 0.5 * j * (j - 1);\n+              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n+              polynoms[j+4][i] =\n+                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);\n+            }\n+\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Estimate interpolation error.\n+   * @param scale scaling array\n+   * @return estimate of the interpolation error\n+   */\n+  public double estimateError(final double[] scale) {\n+    double error = 0;\n+    if (currentDegree >= 5) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        final double e = polynoms[currentDegree][i] / scale[i];\n+        error += e * e;\n+      }\n+      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];\n+    }\n+    return error;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final int dimension = currentState.length;\n+\n+    final double oneMinusTheta = 1.0 - theta;\n+    final double theta05       = theta - 0.5;\n+    double t4                  = theta * oneMinusTheta;\n+    t4 = t4 * t4;\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      interpolatedState[i] = polynoms[0][i] +\n+        theta * (polynoms[1][i] +\n+                 oneMinusTheta * (polynoms[2][i] * theta +\n+                                  polynoms[3][i] * oneMinusTheta));\n+\n+      if (currentDegree > 3) {\n+        double c = polynoms[currentDegree][i];\n+        for (int j = currentDegree - 1; j > 3; --j) {\n+          c = polynoms[j][i] + c * theta05 / (j - 3);\n+        }\n+        interpolatedState[i] += t4 * c;\n+      }\n+    }\n+\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    final int dimension = currentState.length;\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes (but not the temporary vectors)\n+    out.writeInt(currentDegree);\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        out.writeDouble(polynoms[k][l]);\n+      }\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+    final int dimension = currentState.length;\n+\n+    // read the local attributes\n+    final int degree = in.readInt();\n+    resetTables(degree);\n+    currentDegree = degree;\n+\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        polynoms[k][l] = in.readDouble();\n+      }\n+    }\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 7320613236731409847L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 5(4) Higham and Hall integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class HighamHall54Integrator\n+  extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -1499486749907617454L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"Higham-Hall 5(4)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+    {2.0/9.0},\n+    {1.0/12.0, 1.0/4.0},\n+    {1.0/8.0, 0.0, 3.0/8.0},\n+    {91.0/500.0, -27.0/100.0, 78.0/125.0, 8.0/125.0},\n+    {-11.0/20.0, 27.0/20.0, 12.0/5.0, -36.0/5.0, 5.0},\n+    {1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0}\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+    1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n+  };\n+\n+  /** Error weights Butcher array. */\n+  private static final double[] staticE = {\n+    -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(final double minStep, final double maxStep,\n+                                final double scalAbsoluteTolerance,\n+                                final double scalRelativeTolerance) {\n+    super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(final double minStep, final double maxStep,\n+                                final double[] vecAbsoluteTolerance,\n+                                final double[] vecRelativeTolerance) {\n+    super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = staticE[0] * yDotK[0][j];\n+      for (int l = 1; l < staticE.length; ++l) {\n+        errSum += staticE[l] * yDotK[l][j];\n+      }\n+\n+      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double tol = (vecAbsoluteTolerance == null) ?\n+                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      final double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Higham and Hall integrator.\n+ *\n+ * @see HighamHall54Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class HighamHall54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public HighamHall54StepInterpolator() {\n+    super();\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public HighamHall54StepInterpolator(final HighamHall54StepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new HighamHall54StepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double theta2 = theta * theta;\n+\n+    final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n+    final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+    final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n+    final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+    final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] +\n+                             b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i] +\n+                             b4 * yDotK[4][i] + b5 * yDotK[5][i];\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3583240427587318654L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements a second order Runge-Kutta integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0\n+ *   1/2 | 1/2   0\n+ *       |----------\n+ *       |  0    1\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class MidpointIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1871083451154005310L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"midpoint\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    0.0, 1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a midpoint integrator with the given step.\n+   * @param step integration step\n+   */\n+  public MidpointIntegrator(final double step) {\n+    super(c, a, b, new MidpointStepInterpolator(), step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for second order\n+ * Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allow to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class MidpointStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public MidpointStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public MidpointStepInterpolator(final MidpointStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new MidpointStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double coeff1 = oneMinusThetaH * theta;\n+    final double coeff2 = oneMinusThetaH * (1.0 + theta);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] +\n+                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -865524111506042509L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepHandler;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements the common part of all fixed step Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These methods are explicit Runge-Kutta methods, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public abstract class RungeKuttaIntegrator\n+  implements FirstOrderIntegrator {\n+\n+  /** Simple constructor.\n+   * Build a Runge-Kutta integrator with the given\n+   * step. The default step handler does nothing.\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param step integration step\n+   */\n+  protected RungeKuttaIntegrator(final double[] c, final double[][] a, final double[] b,\n+                                 final RungeKuttaStepInterpolator prototype,\n+                                 final double step) {\n+    this.c          = c;\n+    this.a          = a;\n+    this.b          = b;\n+    this.prototype  = prototype;\n+    this.step       = step;\n+    handler         = DummyStepHandler.getInstance();\n+    eventsHandlersManager = new CombinedEventsManager();\n+    resetInternalState();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract String getName();\n+\n+  /** {@inheritDoc} */\n+  public void setStepHandler (final StepHandler handler) {\n+    this.handler = handler;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public StepHandler getStepHandler() {\n+    return handler;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void addEventHandler(final EventHandler function,\n+                              final double maxCheckInterval,\n+                              final double convergence,\n+                              final int maxIterationCount) {\n+    eventsHandlersManager.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public Collection<EventHandler> getEventsHandlers() {\n+      return eventsHandlersManager.getEventsHandlers();\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void clearEventsHandlers() {\n+      eventsHandlersManager.clearEventsHandlers();\n+  }\n+\n+  /** Perform some sanity checks on the integration parameters.\n+   * @param equations differential equations set\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param t target time for the integration\n+   * @param y placeholder where to put the state vector\n+   * @exception IntegratorException if some inconsistency is detected\n+   */\n+  private void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0, final double t, final double[] y)\n+    throws IntegratorException {\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n+                                    \" initial state vector has dimension {1}\",\n+                                    new Object[] {\n+                                      Integer.valueOf(equations.getDimension()),\n+                                      Integer.valueOf(y0.length)\n+                                    });\n+    }\n+    if (equations.getDimension() != y.length) {\n+        throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n+                                      \" final state vector has dimension {1}\",\n+                                      new Object[] {\n+                                        Integer.valueOf(equations.getDimension()),\n+                                        Integer.valueOf(y.length)\n+                                      });\n+      }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new Object[] { Double.valueOf(Math.abs(t - t0)) });\n+    }      \n+  }\n+\n+  /** {@inheritDoc} */\n+  public void integrate(final FirstOrderDifferentialEquations equations,\n+                        final double t0, final double[] y0,\n+                        final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    final double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    final double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // recompute the step\n+    long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));\n+    boolean lastStep  = false;\n+    stepStart = t0;\n+    stepSize  = (t - t0) / nbStep;\n+    handler.reset();\n+    for (long i = 0; ! lastStep; ++i) {\n+\n+      interpolator.shift();\n+\n+      boolean needUpdate = false;\n+      for (boolean loop = true; loop;) {\n+\n+        // first stage\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // Discrete events handling\n+        interpolator.storeTime(stepStart + stepSize);\n+        if (eventsHandlersManager.evaluateStep(interpolator)) {\n+          needUpdate = true;\n+          stepSize = eventsHandlersManager.getEventTime() - stepStart;\n+        } else {\n+          loop = false;\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      final double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      eventsHandlersManager.stepAccepted(nextStep, y);\n+      if (eventsHandlersManager.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = (i == (nbStep - 1));\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      handler.handleStep(interpolator, lastStep);\n+      stepStart = nextStep;\n+\n+      if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n+        // some events handler has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      if (needUpdate) {\n+        // an event handler has changed the step\n+        // we need to recompute stepsize\n+        nbStep = Math.max(1l, Math.abs(Math.round((t - stepStart) / step)));\n+        stepSize = (t - stepStart) / nbStep;\n+        i = -1;\n+      }\n+\n+    }\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double getCurrentStepStart() {\n+    return stepStart;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double getCurrentSignedStepsize() {\n+    return stepSize;\n+  }\n+\n+  /** Reset internal state to dummy values. */\n+  private void resetInternalState() {\n+    stepStart = Double.NaN;\n+    stepSize  = Double.NaN;\n+  }\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Integration step. */\n+  private double step;\n+\n+  /** Step handler. */\n+  private StepHandler handler;\n+\n+  /** Events handlers manager. */\n+  protected CombinedEventsManager eventsHandlersManager;\n+\n+  /** Current step start time. */\n+  private double stepStart;\n+\n+  /** Current stepsize. */\n+  private double stepSize;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for Runge-Kutta and embedded Runge-Kutta integrators.\n+ *\n+ * @see RungeKuttaIntegrator\n+ * @see EmbeddedRungeKuttaIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+abstract class RungeKuttaStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} and {@link\n+   * EmbeddedRungeKuttaIntegrator} classes uses the prototyping design\n+   * pattern to create the step interpolators by cloning an\n+   * uninitialized model and latter initializing the copy.\n+   */\n+  protected RungeKuttaStepInterpolator() {\n+    super();\n+    yDotK     = null;\n+    equations = null;\n+  }\n+\n+  /** Copy constructor.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * @param interpolator interpolator to copy from.\n+\n+  */\n+  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState != null) {\n+      final int dimension = currentState.length;\n+\n+      yDotK = new double[interpolator.yDotK.length][];\n+      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n+        yDotK[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotK[k], 0,\n+                         yDotK[k], 0, dimension);\n+      }\n+\n+    } else {\n+      yDotK = null;\n+    }\n+\n+    // we cannot keep any reference to the equations in the copy\n+    // the interpolator should have been finalized before\n+    equations = null;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n+   * than their counterpart step interpolators. So the interpolator\n+   * should perform the last evaluations they need by themselves. The\n+   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n+   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n+   * abstract classes call this method in order to let the step\n+   * interpolator perform the evaluations it needs. These evaluations\n+   * will be performed during the call to <code>doFinalize</code> if\n+   * any, i.e. only if the step handler either calls the {@link\n+   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n+   * {@link AbstractStepInterpolator#getInterpolatedState\n+   * getInterpolatedState} method (for an interpolator which needs a\n+   * finalization) or if it clones the step interpolator.</p>\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+    reinitialize(y, forward);\n+    this.yDotK = yDotK;\n+    this.equations = equations;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes\n+    out.writeInt(yDotK.length);\n+    for (int k = 0; k < yDotK.length; ++k) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        out.writeDouble(yDotK[k][i]);\n+      }\n+    }\n+\n+    // we do not save any reference to the equations\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+\n+    // read the local attributes\n+    final int kMax = in.readInt();\n+    yDotK = new double[kMax][];\n+    for (int k = 0; k < kMax; ++k) {\n+      yDotK[k] = new double[currentState.length];\n+      for (int i = 0; i < currentState.length; ++i) {\n+        yDotK[k][i] = in.readDouble();\n+      }\n+    }\n+\n+    equations = null;\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Slopes at the intermediate points */\n+  protected double[][] yDotK;\n+\n+  /** Reference to the differential equations beeing integrated. */\n+  protected FirstOrderDifferentialEquations equations;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 3/8 fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations.\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/3 | 1/3   0    0    0\n+ *   2/3 |-1/3   1    0    0\n+ *    1  |  1   -1    1    0\n+ *       |--------------------\n+ *       | 1/8  3/8  3/8  1/8\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ThreeEighthesIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -5738562635641912717L;\n+\n+  /** Integrator method name. */\n+  private static final String methodName = \"3/8\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 3.0, 2.0 / 3.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    {  1.0 / 3.0 },\n+    { -1.0 / 3.0, 1.0 },\n+    {  1.0, -1.0, 1.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a 3/8 integrator with the given step.\n+   * @param step integration step\n+   */\n+  public ThreeEighthesIntegrator(final double step) {\n+    super(c, a, b, new ThreeEighthesStepInterpolator(), step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the 3/8 fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n+ *                                      + 3 (1 +   theta - 4 theta^2) y'_2\n+ *                                      + 3 (1 +   theta)             y'_3\n+ *                                      +   (1 +   theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class ThreeEighthesStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public ThreeEighthesStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ThreeEighthesStepInterpolator(final ThreeEighthesStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new ThreeEighthesStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+      throws DerivativeException {\n+\n+      final double fourTheta2 = 4 * theta * theta;\n+      final double s          = oneMinusThetaH / 8.0;\n+      final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n+      final double coeff2     = 3 * s * (1 + theta - fourTheta2);\n+      final double coeff3     = 3 * s * (1 + theta);\n+      final double coeff4     = s * (1 + theta + fourTheta2);\n+\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          interpolatedState[i] = currentState[i] -\n+          coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -\n+          coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+      }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3345024435978721931L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+\n+/** This abstract class represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects extending this class\n+ * to the step handlers. The handlers can use these objects to\n+ * retrieve the state vector at intermediate times between the\n+ * previous and the current grid points (dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public abstract class AbstractStepInterpolator\n+  implements StepInterpolator {\n+\n+  /** previous time */\n+  protected double previousTime;\n+\n+  /** current time */\n+  protected double currentTime;\n+\n+  /** current time step */\n+  protected double h;\n+\n+  /** current state */\n+  protected double[] currentState;\n+\n+  /** interpolated time */\n+  protected double interpolatedTime;\n+\n+  /** interpolated state */\n+  protected double[] interpolatedState;\n+\n+  /** indicate if the step has been finalized or not. */\n+  private boolean finalized;\n+\n+  /** integration direction. */\n+  private boolean forward;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  protected AbstractStepInterpolator() {\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+    currentState      = null;\n+    interpolatedState = null;\n+    finalized         = false;\n+    this.forward      = true;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState      = y;\n+    interpolatedState = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any derivative computation and will throw a {@link\n+   * NullPointerException} later. Since we don't want this constructor\n+   * to throw the exceptions finalization may involve and since we\n+   * don't want this method to modify the state of the copied\n+   * interpolator, finalization is <strong>not</strong> done\n+   * automatically, it remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n+\n+    previousTime      = interpolator.previousTime;\n+    currentTime       = interpolator.currentTime;\n+    h                 = interpolator.h;\n+    interpolatedTime  = interpolator.interpolatedTime;\n+\n+    if (interpolator.currentState != null) {\n+      currentState      = (double[]) interpolator.currentState.clone();\n+      interpolatedState = (double[]) interpolator.interpolatedState.clone();\n+    } else {\n+      currentState      = null;\n+      interpolatedState = null;\n+    }\n+\n+    finalized = interpolator.finalized;\n+    forward   = interpolator.forward;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected void reinitialize(final double[] y, final boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState      = y;\n+    interpolatedState = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy the instance.\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   public StepInterpolator copy() throws DerivativeException {\n+\n+     // finalize the step before performing copy\n+     finalizeStep();\n+\n+     // create the new independent instance\n+     return doCopy();\n+\n+   }\n+\n+   /** Really copy the finalized instance.\n+    * <p>This method is called by {@link #copy()} after the\n+    * step has been finalized. It must perform a deep copy\n+    * to have an new instance completely independent for the\n+    * original instance.\n+    * @return a copy of the finalized instance\n+    */\n+   protected abstract StepInterpolator doCopy();\n+\n+  /** Shift one step forward.\n+   * Copy the current time into the previous time, hence preparing the\n+   * interpolator for future calls to {@link #storeTime storeTime}\n+   */\n+  public void shift() {\n+    previousTime = currentTime;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(final double t) {\n+\n+    currentTime      = t;\n+    h                = currentTime - previousTime;\n+    interpolatedTime = t;\n+    System.arraycopy(currentState, 0, interpolatedState, 0,\n+                     currentState.length);\n+\n+    // the step is not finalized anymore\n+    finalized = false;\n+\n+  }\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime() {\n+    return previousTime;\n+  }\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime() {\n+    return currentTime;\n+  }\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime() {\n+    return interpolatedTime;\n+  }\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed\n+   * (it was not allowed up to version 5.4 of Mantissa), but should be\n+   * used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(final double time)\n+      throws DerivativeException {\n+      interpolatedTime = time;\n+      final double oneMinusThetaH = currentTime - interpolatedTime;\n+      computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);\n+  }\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by the\n+   * integrator itself, it avoid some nasty problems in degenerated\n+   * cases like null steps due to cancellation at step initialization,\n+   * step control or discrete events triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward() {\n+    return forward;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected abstract void computeInterpolatedState(double theta,\n+                                                   double oneMinusThetaH)\n+    throws DerivativeException;\n+    \n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState() {\n+    return (double[]) interpolatedState.clone();\n+  }\n+\n+\n+  /**\n+   * Finalize the step.\n+\n+   * <p>Some embedded Runge-Kutta integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. These\n+   * interpolators should perform the last evaluations they need by\n+   * themselves only if they need them. This method triggers these\n+   * extra evaluations. It can be called directly by the user step\n+   * handler and it is called automatically if {@link\n+   * #setInterpolatedTime} is called.</p>\n+\n+   * <p>Once this method has been called, <strong>no</strong> other\n+   * evaluation will be performed on this step. If there is a need to\n+   * have some side effects between the step handler and the\n+   * differential equations (for example update some data in the\n+   * equations once the step has been done), it is advised to call\n+   * this method explicitly from the step handler before these side\n+   * effects are set up. If the step handler induces no side effect,\n+   * then this method can safely be ignored, it will be called\n+   * transparently as needed.</p>\n+\n+   * <p><strong>Warning</strong>: since the step interpolator provided\n+   * to the step handler as a parameter of the {@link\n+   * StepHandler#handleStep handleStep} is valid only for the duration\n+   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n+   * simply store a reference and reuse it later. One should first\n+   * finalize the instance, then copy this finalized instance into a\n+   * new object that can be kept.</p>\n+\n+   * <p>This method calls the protected <code>doFinalize</code> method\n+   * if it has never been called during this step and set a flag\n+   * indicating that it has been called once. It is the <code>\n+   * doFinalize</code> method which should perform the evaluations.\n+   * This wrapping prevents from calling <code>doFinalize</code> several\n+   * times and hence evaluating the differential equations too often.\n+   * Therefore, subclasses are not allowed not reimplement it, they\n+   * should rather reimplement <code>doFinalize</code>.</p>\n+\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+\n+   */\n+  public final void finalizeStep()\n+    throws DerivativeException {\n+    if (! finalized) {\n+      doFinalize();\n+      finalized = true;\n+    }\n+  }\n+\n+  /**\n+   * Really finalize the step.\n+   * The default implementation of this method does nothing.\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+  }\n+\n+  /** Write the instance to an output channel.\n+   * @param out output channel\n+   * @exception IOException if the instance cannot be written\n+   */\n+  public abstract void writeExternal(ObjectOutput out)\n+    throws IOException;\n+\n+  /** Read the instance from an input channel.\n+   * @param in input channel\n+   * @exception IOException if the instance cannot be read\n+   */\n+  public abstract void readExternal(ObjectInput in)\n+    throws IOException;\n+\n+  /** Save the base state of the instance.\n+   * This method performs step finalization if it has not been done\n+   * before.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  protected void writeBaseExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    out.writeInt(currentState.length);\n+    out.writeDouble(previousTime);\n+    out.writeDouble(currentTime);\n+    out.writeDouble(h);\n+    out.writeBoolean(forward);\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(currentState[i]);\n+    }\n+\n+    out.writeDouble(interpolatedTime);\n+\n+    // we do not store the interpolated state,\n+    // it will be recomputed as needed after reading\n+\n+    // finalize the step (and don't bother saving the now true flag)\n+    try {\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Read the base state of the instance.\n+   * This method does <strong>neither</strong> set the interpolated\n+   * time nor state. It is up to the derived class to reset it\n+   * properly calling the {@link #setInterpolatedTime} method later,\n+   * once all rest of the object state has been set up properly.\n+   * @param in stream where to read the state from\n+   * @return interpolated time be set later by the caller\n+   * @exception IOException in case of read error\n+   */\n+  protected double readBaseExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    final int dimension = in.readInt();\n+    previousTime  = in.readDouble();\n+    currentTime   = in.readDouble();\n+    h             = in.readDouble();\n+    forward       = in.readBoolean();\n+\n+    currentState  = new double[dimension];\n+    for (int i = 0; i < currentState.length; ++i) {\n+      currentState[i] = in.readDouble();\n+    }\n+\n+    // we do NOT handle the interpolated time and state here\n+    interpolatedTime  = Double.NaN;\n+    interpolatedState = new double[dimension];\n+\n+    finalized = true;\n+\n+    return in.readDouble();\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class is a step handler that do nothing.\n+\n+ * <p>This class is provided as a convenience for users who are only\n+ * interested in the final state of an integration and not in the\n+ * intermediate steps. Its handleStep method does nothing.</p>\n+ *\n+ * <p>Since this class has no internal state, it is implemented using\n+ * the Singleton design pattern. This means that only one instance is\n+ * ever created, which can be retrieved using the getInstance\n+ * method. This explains why there is no public constructor.</p>\n+ *\n+ * @see StepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepHandler\n+  implements StepHandler, Serializable {\n+\n+  /** Private constructor.\n+   * The constructor is private to prevent users from creating\n+   * instances (Singleton design-pattern).\n+   */\n+  private DummyStepHandler() {\n+  }\n+\n+  /** Get the only instance.\n+   * @return the only instance\n+   */\n+  public static DummyStepHandler getInstance() {\n+    return instance;\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * Since this handler does nothing, it does not require dense output.\n+   * @return always false\n+   */\n+  public boolean requiresDenseOutput() {\n+    return false;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+  }\n+\n+  /**\n+   * Handle the last accepted step.\n+   * This method does nothing in this class.\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+  }\n+\n+  /** The only instance. */\n+  private static DummyStepHandler instance = new DummyStepHandler();\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 2731635121223090252L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+\n+/** This class is a step interpolator that does nothing.\n+ *\n+ * <p>This class is used when the {@link StepHandler \"step handler\"}\n+ * set up by the user does not need step interpolation. It does not\n+ * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime\n+ * setInterpolatedTime} is called. This implies the interpolated state\n+ * is always the state at the end of the current step.</p>\n+ *\n+ * @see StepHandler\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * <code>AbstractStepInterpolator.reinitialize</code> protected method\n+   * should be called before using the instance in order to initialize\n+   * the internal arrays. This constructor is used only in order to delay\n+   * the initialization in some cases. As an example, the {@link\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  public DummyStepInterpolator() {\n+    super();\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  public DummyStepInterpolator(final double[] y, final boolean forward) {\n+    super(y, forward);\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DummyStepInterpolator(final DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** Really copy the finalized instance.\n+   * @return a copy of the finalized instance\n+   */\n+  protected StepInterpolator doCopy() {\n+    return new DummyStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * In this class, this method does nothing: the interpolated state\n+   * is always the state at the end of the current step.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(final double theta, final double oneMinusThetaH)\n+    throws DerivativeException {\n+      System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n+  }\n+    \n+  /** Write the instance to an output channel.\n+   * @param out output channel\n+   * @exception IOException if the instance cannot be written\n+   */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+  }\n+\n+  /** Read the instance from an input channel.\n+   * @param in input channel\n+   * @exception IOException if the instance cannot be read\n+   */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 1708010296707839488L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful fixed step.\n+\n+ * <p>This interface should be implemented by anyone who is interested\n+ * in getting the solution of an ordinary differential equation at\n+ * fixed time steps. Objects implementing this interface should be\n+ * wrapped within an instance of {@link StepNormalizer} that itself\n+ * is used as the general {@link StepHandler} by the integrator. The\n+ * {@link StepNormalizer} object is called according to the integrator\n+ * internal algorithms and it calls objects implementing this\n+ * interface as necessary at fixed time steps.</p>\n+ *\n+ * @see StepHandler\n+ * @see StepNormalizer\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface FixedStepHandler {\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param t time of the current step\n+\n+   * @param y state vector at t. For efficiency purposes, the {@link\n+   * StepNormalizer} class reuse the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(double t, double[] y, boolean isLast);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful step.\n+ *\n+ * <p>The ODE integrators compute the evolution of the state vector at\n+ * some grid points that depend on their own internal algorithm. Once\n+ * they have found a new grid point (possibly after having computed\n+ * several evaluation of the derivative at intermediate points), they\n+ * provide it to objects implementing this interface. These objects\n+ * typically either ignore the intermediate steps and wait for the\n+ * last one, store the points in an ephemeris, or forward them to\n+ * specialized processing or output methods.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepInterpolator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface StepHandler extends Serializable {\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>This method allows the integrator to avoid performing extra\n+   * computation if the handler does not need dense output. If this\n+   * method returns false, the integrator will call the {@link\n+   * #handleStep} method with a {@link DummyStepInterpolator} rather\n+   * than a custom interpolator.</p>\n+   * @return true if the handler needs dense output\n+   */\n+  public boolean requiresDenseOutput();\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset();\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range, as the\n+   * {@link ContinuousOutputModel ContinuousOutputModel} class does),\n+   * it should build a local copy using the clone method of the\n+   * interpolator and store this copy. Keeping only a reference to the\n+   * interpolator and reusing it will result in unpredictable\n+   * behaviour (potentially crashing the application).\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Externalizable;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+\n+/** This interface represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects implementing this\n+ * interface to the step handlers. These objects are often custom\n+ * objects tightly bound to the integrator internal algorithms. The\n+ * handlers can use these objects to retrieve the state vector at\n+ * intermediate times between the previous and the current grid points\n+ * (this feature is often called dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface StepInterpolator\n+  extends Externalizable {\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime();\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime();\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime();\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed, but\n+   * should be used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * <p>Setting the time changes the instance internal state. If a\n+   * specific state must be preserved, a copy of the instance must be\n+   * created using {@link #copy()}.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(double time)\n+    throws DerivativeException;\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState();\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by\n+   * the integrator itself, it avoid some nasty problems in\n+   * degenerated cases like null steps due to cancellation at step\n+   * initialization, step control or discrete events\n+   * triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward();\n+\n+  /** Copy the instance.\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   public StepInterpolator copy() throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This class wraps an object implementing {@link FixedStepHandler}\n+ * into a {@link StepHandler}.\n+\n+ * <p>This wrapper allows to use fixed step handlers with general\n+ * integrators which cannot guaranty their integration steps will\n+ * remain constant and therefore only accept general step\n+ * handlers.</p>\n+ *\n+ * <p>The stepsize used is selected at construction time. The {@link\n+ * FixedStepHandler#handleStep handleStep} method of the underlying\n+ * {@link FixedStepHandler} object is called at the beginning time of\n+ * the integration t0 and also at times t0+h, t0+2h, ... If the\n+ * integration range is an integer multiple of the stepsize, then the\n+ * last point handled will be the endpoint of the integration tend, if\n+ * not, the last point will belong to the interval [tend - h ;\n+ * tend].</p>\n+ *\n+ * <p>There is no constraint on the integrator, it can use any\n+ * timestep it needs (time steps longer or shorter than the fixed time\n+ * step and non-integer ratios are all allowed).</p>\n+ *\n+ * @see StepHandler\n+ * @see FixedStepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class StepNormalizer implements StepHandler {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -973517244031912577L;\n+\n+    /** Fixed time step. */\n+    private double h;\n+\n+    /** Underlying step handler. */\n+    private final FixedStepHandler handler;\n+\n+    /** Last step time. */\n+    private double lastTime;\n+\n+    /** Last State vector. */\n+    private double[] lastState;\n+\n+    /** Integration direction indicator. */\n+    private boolean forward;\n+\n+    /** Simple constructor.\n+     * @param h fixed time step (sign is not used)\n+     * @param handler fixed time step handler to wrap\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler) {\n+        this.h       = Math.abs(h);\n+        this.handler = handler;\n+        reset();\n+    }\n+\n+    /** Determines whether this handler needs dense output.\n+     * This handler needs dense output in order to provide data at\n+     * regularly spaced steps regardless of the steps the integrator\n+     * uses, so this method always returns true.\n+     * @return always true\n+     */\n+    public boolean requiresDenseOutput() {\n+        return true;\n+    }\n+\n+    /** Reset the step handler.\n+     * Initialize the internal data as required before the first step is\n+     * handled.\n+     */\n+    public void reset() {\n+        lastTime  = Double.NaN;\n+        lastState = null;\n+        forward   = true;\n+    }\n+\n+    /**\n+     * Handle the last accepted step\n+     * @param interpolator interpolator for the last accepted step. For\n+     * efficiency purposes, the various integrators reuse the same\n+     * object on each call, so if the instance wants to keep it across\n+     * all calls (for example to provide at the end of the integration a\n+     * continuous model valid throughout the integration range), it\n+     * should build a local copy using the clone method and store this\n+     * copy.\n+     * @param isLast true if the step is the last one\n+     * @throws DerivativeException this exception is propagated to the\n+     * caller if the underlying user function triggers one\n+     */\n+    public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n+        throws DerivativeException {\n+\n+        if (lastState == null) {\n+\n+            lastTime = interpolator.getPreviousTime();\n+            interpolator.setInterpolatedTime(lastTime);\n+\n+            final double[] state = interpolator.getInterpolatedState();\n+            lastState = (double[]) state.clone();\n+\n+            // take the integration direction into account\n+            forward = (interpolator.getCurrentTime() >= lastTime);\n+            if (! forward) {\n+                h = -h;\n+            }\n+\n+        }\n+\n+        double nextTime = lastTime + h;\n+        boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+        while (nextInStep) {\n+\n+            // output the stored previous step\n+            handler.handleStep(lastTime, lastState, false);\n+\n+            // store the next step\n+            lastTime = nextTime;\n+            interpolator.setInterpolatedTime(lastTime);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                             lastState, 0, lastState.length);\n+\n+            nextTime  += h;\n+            nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+\n+        }\n+\n+        if (isLast) {\n+            // there will be no more steps,\n+            // the stored one should be flagged as being the last\n+            handler.handleStep(lastTime, lastState, true);\n+        }\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/random/JDKRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/JDKRandomGenerator.java\n  * {@link RandomGenerator}.\n  *\n  * @since 1.1\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public class JDKRandomGenerator extends Random implements RandomGenerator {\n     /** Serializable version identifier */\n--- a/src/java/org/apache/commons/math/random/RandomAdaptor.java\n+++ b/src/java/org/apache/commons/math/random/RandomAdaptor.java\n  * {@link RandomGenerator}.   \n  *\n  * @since 1.1\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public class RandomAdaptor extends Random implements RandomGenerator {\n     \n--- a/src/java/org/apache/commons/math/random/RandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/RandomGenerator.java\n  * implemented by {@link AbstractRandomGenerator}.  \n  *\n  * @since 1.1\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public interface RandomGenerator extends Serializable {\n     \n--- a/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n  * threads is required.</p>\n  *\n  * @since 1.2\n- * @version $Revision: 618097 $ $Date: 2008-02-03 22:39:08 +0100 (dim., 03 f\u00e9vr. 2008) $\n+ * @version $Revision$ $Date$\n  */\n public class MultivariateSummaryStatistics\n   implements StatisticalMultivariateSummary, Serializable {\n--- a/src/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n  *  Reporting interface for basic multivariate statistics.\n  *\n  * @since 1.2\n- * @version $Revision: 480440 $ $Date: 2006-11-29 08:14:12 +0100 (mer., 29 nov. 2006) $\n+ * @version $Revision$ $Date$\n  */\n public interface StatisticalMultivariateSummary {\n     /** \n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n  * thread is computing a statistic from the instance, no other thread can modify\n  * the instance nor compute another statistic.\n  * @since 1.2\n- * @version $Revision: 618097 $ $Date: 2008-02-03 22:39:08 +0100 (dim., 03 f\u00e9vr. 2008) $\n+ * @version $Revision$ $Date$\n  */\n public class SynchronizedMultivariateSummaryStatistics\n   extends MultivariateSummaryStatistics {\n--- a/src/mantissa/src/org/spaceroots/mantissa/MantissaException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MantissaException.java\n  * standard exceptions are thrown rather than the mantissa specific\n  * ones.</p>\n \n- * @version $Id: MantissaException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n import java.util.ListResourceBundle;\n \n /** This class gather the message resources for the mantissa library.\n- * @version $Id: MessagesResources.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n import java.util.ListResourceBundle;\n \n /** This class gather the message resources for the mantissa library.\n- * @version $Id: MessagesResources_fr.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n public class MessagesResources_fr\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n  *  T<sub>k+1</sub>(X) = 2X T<sub>k</sub>(X) - T<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Chebyshev.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n  *  H<sub>k+1</sub>(X) = 2X H<sub>k</sub>(X) - 2k H<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Hermite.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n  *  (k+1) L<sub>k+1</sub>(X) = (2k + 1 - X) L<sub>k</sub>(X) - k L<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Laguerre.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n  *  (k+1) P<sub>k+1</sub>(X) = (2k+1) X P<sub>k</sub>(X) - k P<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Legendre.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n  * a<sub>4,k</sub> are simple expressions which either are\n  * constants or depend on k.</p>\n \n- * @version $Id: OrthogonalPolynomial.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n \n  * <p>Instances of this class are immutable.</p>\n \n- * @version $Id: Polynomial.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n  * rational coefficients.\n  * <p>Instances of this class are immutable.</p>\n \n- * @version $Id: PolynomialFraction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n  * This class implements reduced rational numbers.\n  * <p>Instances of this class are immutable.</p>\n \n- * @version $Id: RationalNumber.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n  * sub-classes to define the precise shape of the curve they\n  * represent.</p>\n \n- * @version $Id: AbstractCurveFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n  * @see FFPIterator\n  * @see HarmonicCoefficientsGuesser\n \n- * @version $Id: F2FP2Iterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/FFPIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/FFPIterator.java\n  * @see F2FP2Iterator\n  * @see HarmonicCoefficientsGuesser\n \n- * @version $Id: FFPIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n  * estimations, these operations run in O(n) time, where n is the\n  * number of measurements.</p>\n \n- * @version $Id: HarmonicCoefficientsGuesser.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n  * <p>This class <emph>is by no means optimized</emph>, neither versus\n  * space nor versus time performance.</p>\n \n- * @version $Id: HarmonicFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialCoefficient.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialCoefficient.java\n \n  * @see PolynomialFitter\n \n- * @version $Id: PolynomialCoefficient.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n \n  * @see PolynomialCoefficient\n \n- * @version $Id: PolynomialFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/ExhaustedSampleException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/ExhaustedSampleException.java\n \n /** This class represents exceptions thrown by sample iterators.\n \n- * @version $Id: ExhaustedSampleException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/FunctionException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/FunctionException.java\n \n /** This class represents exceptions thrown by scalar functions.\n \n- * @version $Id: FunctionException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: BasicSampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n  * @see org.spaceroots.mantissa.quadrature.scalar.ComputableFunctionIntegrator\n  * @see SampledFunction\n \n- * @version $Id: ComputableFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSampler.java\n \n  * @see ComputableFunction\n \n- * @version $Id: ComputableFunctionSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n  * @see ComputableFunctionSampler\n  * @see ComputableFunction\n \n- * @version $Id: SampledFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: SampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ScalarValuedPair.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ScalarValuedPair.java\n  * @see SampledFunction\n  * @see org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair\n \n- * @version $Id: ScalarValuedPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: BasicSampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n  * @see org.spaceroots.mantissa.quadrature.vectorial.ComputableFunctionIntegrator\n  * @see SampledFunction\n \n- * @version $Id: ComputableFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSampler.java\n \n  * @see ComputableFunction\n \n- * @version $Id: ComputableFunctionSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n  * @see ComputableFunctionSampler\n  * @see ComputableFunction\n \n- * @version $Id: SampledFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: SampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n  * @see SampledFunction\n  * @see org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair\n \n- * @version $Id: VectorialValuedPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n \n /** This class implements diagonal matrices of linear algebra.\n \n- * @version $Id: DiagonalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n  * <p>This class is the basic implementation of matrices to use when\n  * nothing special is known about the structure of the matrix.</p>\n \n- * @version $Id: GeneralMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n \n /** This class implements general square matrices of linear algebra.\n \n- * @version $Id: GeneralSquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n \n /** This class implements lower triangular matrices of linear algebra.\n \n- * @version $Id: LowerTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n  * specific shape to the general algorithms implemented by this\n  * abstract class.</p>\n \n- * @version $Id: Matrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/MatrixFactory.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/MatrixFactory.java\n  * <p>This is a utility class, no instance of this class should be\n  * built, so the constructor is explicitly made private.</p>\n \n- * @version $Id: MatrixFactory.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n  * coincidence. Therefore, the range (in row/columns count)\n  * corresponding to third row will span from 0 to 2, not from 1 to 2.</p>\n \n- * @version $Id: NonNullRange.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SingularMatrixException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SingularMatrixException.java\n \n /** This class represent exceptions thrown by some matrix operations.\n \n- * @version $Id: SingularMatrixException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n  * implementations. It extends the {@link Matrix} class with methods\n  * specific to square matrices.</p>\n \n- * @version $Id: SquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n \n /** This class implements symetrical matrices of linear algebra.\n \n- * @version $Id: SymetricalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n \n /** This class implements upper triangular matrices of linear algebra.\n \n- * @version $Id: UpperTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/ComputableFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/ComputableFunctionIntegrator.java\n \n  * @see org.spaceroots.mantissa.functions.scalar.ComputableFunction\n \n- * @version $Id: ComputableFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegrator.java\n  * points. If it is used on a regular sample, it behaves exactly as a\n  * traditional Simpson integrator.</p>\n \n- * @version $Id: EnhancedSimpsonIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegratorSampler.java\n \n  * @see EnhancedSimpsonIntegrator\n \n- * @version $Id: EnhancedSimpsonIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegrator.java\n  * boundary points, which means it can be undefined at these\n  * points.</p>\n \n- * @version $Id: GaussLegendreIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegrator.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: RiemannIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegratorSampler.java\n \n  * @see RiemannIntegrator\n \n- * @version $Id: RiemannIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/SampledFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/SampledFunctionIntegrator.java\n  * @see org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator\n  * @see ComputableFunctionIntegrator\n \n- * @version $Id: SampledFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegrator.java\n  * <p>A trapezoid integrator is a very simple one that assumes the\n  * function is linear over the integration step.</p>\n \n- * @version $Id: TrapezoidIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegratorSampler.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: TrapezoidIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/ComputableFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/ComputableFunctionIntegrator.java\n \n  * @see org.spaceroots.mantissa.functions.vectorial.ComputableFunction\n \n- * @version $Id: ComputableFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n  * points. If it is used on a regular sample, it behaves exactly as a\n  * traditional Simpson integrator.</p>\n \n- * @version $Id: EnhancedSimpsonIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n \n  * @see EnhancedSimpsonIntegrator\n \n- * @version $Id: EnhancedSimpsonIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegrator.java\n  * boundary points, which means it can be undefined at these\n  * points.</p>\n \n- * @version $Id: GaussLegendreIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: RiemannIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n \n  * @see RiemannIntegrator\n \n- * @version $Id: RiemannIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/SampledFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/SampledFunctionIntegrator.java\n  * @see org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator\n  * @see ComputableFunctionIntegrator\n \n- * @version $Id: SampledFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n  * <p>A trapezoid integrator is a very simple one that assumes the\n  * function is linear over the integration step.</p>\n \n- * @version $Id: TrapezoidIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: TrapezoidIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/ScalarSampleStatistics.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/ScalarSampleStatistics.java\n package org.spaceroots.mantissa.random;\n \n /** This class compute basic statistics on a scalar sample.\n- * @version $Id: ScalarSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n public class ScalarSampleStatistics {\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n \n /** This class compute basic statistics on a scalar sample.\n- * @version $Id: VectorialSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n public class VectorialSampleStatistics {\n--- a/src/mantissa/src/org/spaceroots/mantissa/roots/BrentSolver.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/BrentSolver.java\n  * implementation found at netlib (<a\n  * href=\"http://www.netlib.org/fmm/zeroin.f\">zeroin.f</a>).\n \n- * @version $Id: BrentSolver.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/roots/ConvergenceChecker.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/ConvergenceChecker.java\n  * to allow the root-finding algorithm to stop its search according to\n  * the problem at hand.\n \n- * @version $Id: ConvergenceChecker.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/roots/RootsFinder.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/RootsFinder.java\n /** This interface specifies root-finding methods for scalar\n  * functions.\n \n- * @version $Id: RootsFinder.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n \n  * @see ArraySliceMappable\n \n- * @version $Id: ArrayMapper.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapperEntry.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapperEntry.java\n  * This class is a simple container for an offset and an\n  * {@link ArraySliceMappable} object.\n \n- * @version $Id: ArrayMapperEntry.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArraySliceMappable.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArraySliceMappable.java\n \n  * @see ArrayMapper\n  *\n- * @version $Id: ArraySliceMappable.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  *\n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/Interval.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/Interval.java\n \n  * @see IntervalsList\n  * @author Luc Maisonobe\n- * @version $Id: Interval.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  */\n public class Interval {\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/IntervalsList.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/IntervalsList.java\n  * intersection.</p>\n  * @see Interval\n  * @author Luc Maisonobe\n- * @version $Id: IntervalsList.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  */\n public class IntervalsList {\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n  * Wrapper class around an array in order to have it implement the\n  * {@link ArraySliceMappable} interface.\n \n- * @version $Id: MappableArray.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableScalar.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableScalar.java\n  * Wrapper class around a scalar in order to have it implement the\n  * {@link ArraySliceMappable} interface.\n \n- * @version $Id: MappableScalar.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n import java.util.Locale;\n \n /**\n- * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $\n+ * @version $Revision$ $Date$\n  */\n public class ConvergenceExceptionTest extends TestCase {\n \n--- a/src/test/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/MonitoredFunction.java\n /**\n  * Wrapper class for counting functions calls.\n  *\n- * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $ \n+ * @version $Revision$ $Date$ \n  */\n public class MonitoredFunction implements UnivariateRealFunction {\n \n--- a/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n  * \n- * @version $Revision: 1.8 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n+ * @version $Revision$ $Date$\n  */\n public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n     \n--- a/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.DormandPrince54Integrator;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.nonstiff.TestProblem3;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n public class ContinuousOutputModelTest\n   extends TestCase {\n--- a/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n \n package org.apache.commons.math.ode;\n \n-import org.apache.commons.math.ode.ClassicalRungeKuttaIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderConverter;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n \n import junit.framework.*;\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ClassicalRungeKuttaIntegratorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSanityChecks() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()+10],\n+                                                        1.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+    try  {\n+        TestProblem1 pb = new TestProblem1();\n+        new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                          0.0, new double[pb.getDimension()],\n+                                                          1.0, new double[pb.getDimension()+10]);\n+          fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        fail(\"wrong exception caught\");\n+      } catch(IntegratorException ie) {\n+      }\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()],\n+                                                        0.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.setStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        assertEquals(functions.length, integ.getEventsHandlers().size());\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        integ.clearEventsHandlers();\n+        assertEquals(0, integ.getEventsHandlers().size());\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = 7510061424396717277L;\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+    private double maxError = 0;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n+\n+public class ClassicalRungeKuttaStepInterpolatorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince54IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,\n+                                                                           1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 vecAbsoluteTolerance,\n+                                                                 vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testSmallLastStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract pb = new TestProblem5();\n+    double minStep = 1.25;\n+    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+    double scalAbsoluteTolerance = 6.0e-4;\n+    double scalRelativeTolerance = 6.0e-4;\n+\n+    AdaptiveStepsizeIntegrator integ =\n+      new DormandPrince54Integrator(minStep, maxStep,\n+                                    scalAbsoluteTolerance,\n+                                    scalRelativeTolerance);\n+\n+    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);\n+    integ.setStepHandler(handler);\n+    integ.setInitialStepSize(1.7);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(handler.wasLastSeen());\n+    assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+\n+  }\n+\n+  private static class DP54SmallLastHandler implements StepHandler {\n+\n+    private static final long serialVersionUID = -8168590945325629799L;\n+\n+    public DP54SmallLastHandler(double minStep) {\n+      lastSeen = false;\n+      this.minStep = minStep;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+      if (isLast) {\n+        lastSeen = true;\n+        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n+        assertTrue(Math.abs(h) < minStep);\n+      }\n+    }\n+\n+    public boolean wasLastSeen() {\n+      return lastSeen;\n+    }\n+\n+    private boolean lastSeen;\n+    private double  minStep;\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      EmbeddedRungeKuttaIntegrator integ =\n+          new DormandPrince54Integrator(minStep, maxStep,\n+                                        scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setSafety(0.8);\n+      integ.setMaxGrowth(5.0);\n+      integ.setMinReduction(0.3);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      assertEquals(0.8, integ.getSafety(), 1.0e-12);\n+      assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);\n+      assertEquals(0.3, integ.getMinReduction(), 1.0e-12);\n+\n+      // the 0.7 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventsHandlers();\n+    assertEquals(0, integ.getEventsHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2800);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new VariableHandler());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = -1645853847806655456L;\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 7.0e-10);\n+        assertTrue(nbSteps < 400);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    private static final long serialVersionUID = -5196650833828379228L;\n+    public VariableHandler() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 450.0));\n+        assertTrue(maxStep > (1.0 / 4.2));\n+      }\n+    }  \n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class DormandPrince54StepInterpolatorTest\n+  extends TestCase {\n+\n+  public DormandPrince54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 119500);\n+    assertTrue(bos.size () < 120500);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 7.0e-10);\n+\n+  }\n+\n+  public void testClone()\n+    throws DerivativeException, IntegratorException {\n+      TestProblem3 pb = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = scalAbsoluteTolerance;\n+      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+      integ.setStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = -6768136169276197L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+          throws DerivativeException {\n+              StepInterpolator cloned = interpolator.copy();\n+              double tA = cloned.getPreviousTime();\n+              double tB = cloned.getCurrentTime();\n+              double halfStep = Math.abs(tB - tA) / 2;\n+              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+              for (int i = 0; i < 10; ++i) {\n+                  double t = (i * tB + (9 - i) * tA) / 9;\n+                  interpolator.setInterpolatedTime(t);\n+                  assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                  cloned.setInterpolatedTime(t);\n+                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                  double[] referenceState = interpolator.getInterpolatedState();\n+                  double[] cloneState     = cloned.getInterpolatedState();\n+                  for (int j = 0; j < referenceState.length; ++j) {\n+                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                  }\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return true;\n+          }\n+          public void reset() {\n+          }\n+      });\n+      integ.integrate(pb,\n+              pb.getInitialTime(), pb.getInitialState(),\n+              pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.DummyStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince853IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince853IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  vecAbsoluteTolerance,\n+                                                                  vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-9;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventsHandlers();\n+    assertEquals(0, integ.getEventsHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2900);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new VariableHandler());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  public void testNoDenseOutput()\n+    throws DerivativeException, IntegratorException {\n+    TestProblem1 pb1 = new TestProblem1();\n+    TestProblem1 pb2 = (TestProblem1) pb1.clone();\n+    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n+    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-4;\n+    double scalRelativeTolerance = 1.0e-4;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.setStepHandler(DummyStepHandler.getInstance());\n+    integ.integrate(pb1,\n+                    pb1.getInitialTime(), pb1.getInitialState(),\n+                    pb1.getFinalTime(), new double[pb1.getDimension()]);\n+    int callsWithoutDenseOutput = pb1.getCalls();\n+\n+    integ.setStepHandler(new InterpolatingStepHandler());\n+    integ.integrate(pb2,\n+                    pb2.getInitialTime(), pb2.getInitialState(),\n+                    pb2.getFinalTime(), new double[pb2.getDimension()]);\n+    int callsWithDenseOutput = pb2.getCalls();\n+\n+    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n+\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = -1752092987112788459L;\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.4e-10);\n+        assertTrue(nbSteps < 150);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    private static final long serialVersionUID = 5542665697103383623L;\n+    public VariableHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 100.0));\n+        assertTrue(maxStep > (1.0 / 2.0));\n+      }\n+    }\n+    private boolean firstTime = true;\n+    private double  minStep = 0;\n+    private double  maxStep = 0;\n+  }\n+\n+  private static class InterpolatingStepHandler implements StepHandler {\n+    private static final long serialVersionUID = -5272695044664350727L;\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+      double prev = interpolator.getPreviousTime();\n+      double curr = interpolator.getCurrentTime();\n+      interpolator.setInterpolatedTime(0.5*(prev + curr));\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class DormandPrince853StepInterpolatorTest\n+  extends TestCase {\n+\n+  public DormandPrince853StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 86000);\n+    assertTrue(bos.size () < 87000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 2.4e-10);\n+\n+  }\n+\n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = 2209212559670665268L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.EulerIntegrator;\n+\n+public class EulerIntegratorTest\n+  extends TestCase {\n+\n+  public EulerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new EulerIntegrator(0.01).integrate(pb,\n+                                          0.0, new double[pb.getDimension()+10],\n+                                          1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new EulerIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.setStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-4);\n+   assertTrue(handler.getMaximalValueError() < 1.0e-3);\n+   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+   assertEquals(\"Euler\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalValueError() > 0.2);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(EulerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.EulerIntegrator;\n+import org.apache.commons.math.ode.nonstiff.EulerStepInterpolator;\n+\n+public class EulerStepInterpolatorTest\n+  extends TestCase {\n+\n+  public EulerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoReset() {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationAtBounds()\n+    throws DerivativeException {\n+\n+    double   t0 = 0;\n+    double[] y0 = {0.0, 1.0, -2.0};\n+\n+    double[] y = (double[]) y0.clone();\n+    double[][] yDot = { new double[y0.length] };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(t0);\n+\n+    double dt = 1.0;\n+    y[0] =  1.0;\n+    y[1] =  3.0;\n+    y[2] = -4.0;\n+    yDot[0][0] = (y[0] - y0[0]) / dt;\n+    yDot[0][1] = (y[1] - y0[1]) / dt;\n+    yDot[0][2] = (y[2] - y0[2]) / dt;\n+    interpolator.shift();\n+    interpolator.storeTime(t0 + dt);\n+\n+    interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationInside()\n+    throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 82000);\n+    assertTrue(bos.size () < 83000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.001);\n+\n+  }\n+\n+  private static class DummyEquations\n+    implements FirstOrderDifferentialEquations {\n+    private static final long serialVersionUID = 291437140744677100L;\n+    public int getDimension() {\n+      return 0;\n+    }\n+    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EulerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class GillIntegratorTest\n+  extends TestCase {\n+\n+  public GillIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new GillIntegrator(0.01).integrate(pb,\n+                                         0.0, new double[pb.getDimension()+10],\n+                                         1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 5; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new GillIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.setStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 5) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"Gill\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    integ.setStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ = new GillIntegrator(0.3);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    private static final long serialVersionUID = 1250933165809631538L;\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.001);\n+      }\n+    }\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+\n+public class GillStepInterpolatorTest\n+  extends TestCase {\n+\n+  public GillStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.003);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class GraggBulirschStoerIntegratorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      AdaptiveStepsizeIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem5 pb  = new TestProblem5();\n+      double minStep   = 0.1 * Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep   = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };\n+      double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         vecAbsoluteTolerance, vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -4; ++i) {\n+      TestProblem1 pb     = new TestProblem1();\n+      double minStep      = 0;\n+      double maxStep      = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = Math.pow(10.0, i);\n+      double relTolerance = absTolerance;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the coefficients are only valid for this test\n+      // and have been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      double ratio =  handler.getMaximalValueError() / absTolerance;\n+      assertTrue(ratio < 2.4);\n+      assertTrue(ratio > 0.02);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testIntegratorControls()\n+  throws DerivativeException, IntegratorException {\n+\n+    TestProblem3 pb = new TestProblem3(0.999);\n+    GraggBulirschStoerIntegrator integ =\n+        new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),\n+                1.0e-8, 1.0e-10);\n+\n+    double errorWithDefaultSettings = getMaxError(integ, pb);\n+\n+    // stability control\n+    integ.setStabilityCheck(true, 2, 1, 0.99);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setStabilityCheck(true, -1, -1, -1);\n+\n+    integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setStepsizeControl(-1, -1, -1, -1);\n+\n+    integ.setOrderControl(10, 0.7, 0.95);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setOrderControl(-1, -1, -1);\n+\n+    integ.setInterpolationControl(true, 3);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setInterpolationControl(true, -1);\n+\n+  }\n+\n+  private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n+    throws DerivativeException, IntegratorException {\n+      TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n+      integrator.setStepHandler(handler);\n+      integrator.integrate(pb,\n+                           pb.getInitialTime(), pb.getInitialState(),\n+                           pb.getFinalTime(), new double[pb.getDimension()]);\n+      return handler.getMaximalValueError();\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-10;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventsHandlers();\n+    assertEquals(0, integ.getEventsHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-6;\n+    double relTolerance   = 1.0e-6;\n+\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2150);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-8;\n+    double relTolerance   = 1.0e-8;\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new VariableStepHandler());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  public void testUnstableDerivative()\n+    throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    private static final long serialVersionUID = -8231434585284002546L;\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 100; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((100 - a) * prev + a * curr) / 100;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.7e-6);\n+        assertTrue(nbSteps < 80);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static class VariableStepHandler implements StepHandler {\n+    private static final long serialVersionUID = -5955452449048688985L;\n+    public VariableStepHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < 8.2e-3);\n+        assertTrue(maxStep > 1.7);\n+      }\n+    }\n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class GraggBulirschStoerStepInterpolatorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 34000);\n+    assertTrue(bos.size () < 35000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 5.0e-11);\n+\n+  }\n+\n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                          scalAbsoluteTolerance,\n+                                                                          scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = -5947183291381232297L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class HighamHall54IntegratorTest\n+  extends TestCase {\n+\n+  public HighamHall54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testWrongDerivative() {\n+    try {\n+      HighamHall54Integrator integrator =\n+          new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      FirstOrderDifferentialEquations equations =\n+          new FirstOrderDifferentialEquations() {\n+            private static final long serialVersionUID = -1157081786301178032L;\n+            public void computeDerivatives(double t, double[] y, double[] dot)\n+            throws DerivativeException {\n+            if (t < -0.5) {\n+                throw new DerivativeException(\"{0}\", new String[] { \"oops\" });\n+            } else {\n+                throw new DerivativeException(new RuntimeException(\"oops\"));\n+           }\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      };\n+\n+      try  {\n+        integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);\n+        fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        // expected behavior\n+      }\n+\n+      try  {\n+        integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);\n+        fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        // expected behavior\n+      }\n+\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());        \n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              vecAbsoluteTolerance,\n+                                                              vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 1.0e-7);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventsHandlers();\n+    assertEquals(0, integ.getEventsHandlers().size());\n+\n+  }\n+\n+  public void testEventsErrors()\n+    throws DerivativeException, IntegratorException {\n+\n+      final TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ =\n+          new HighamHall54Integrator(minStep, maxStep,\n+                                     scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+\n+      integ.addEventHandler(new EventHandler() {\n+        public int eventOccurred(double t, double[] y) {\n+          return EventHandler.CONTINUE;\n+        }\n+        public double g(double t, double[] y) throws EventException {\n+          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+          double offset = t - middle;\n+          if (offset > 0) {\n+            throw new EventException(\"Evaluation failed for argument = {0}\",\n+                                      new Object[] { Double.valueOf(t) });\n+          }\n+          return offset;\n+        }\n+        public void resetState(double t, double[] y) {\n+        }\n+        private static final long serialVersionUID = 935652725339916361L;\n+      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+\n+      try {\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+      }\n+\n+  }\n+\n+  public void testEventsNoConvergence()\n+  throws DerivativeException, IntegratorException {\n+\n+    final TestProblem1 pb = new TestProblem1();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ =\n+        new HighamHall54Integrator(minStep, maxStep,\n+                                   scalAbsoluteTolerance, scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+\n+    integ.addEventHandler(new EventHandler() {\n+      public int eventOccurred(double t, double[] y) {\n+        return EventHandler.CONTINUE;\n+      }\n+      public double g(double t, double[] y) {\n+        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+        double offset = t - middle;\n+        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);\n+      }\n+      public void resetState(double t, double[] y) {\n+      }\n+      private static final long serialVersionUID = 935652725339916361L;\n+    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);\n+\n+    try {\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch (IntegratorException ie) {\n+       assertTrue(ie.getCause() != null);\n+       assertTrue(ie.getCause() instanceof ConvergenceException);\n+    } catch (Exception e) {\n+      fail(\"wrong exception type caught\");\n+    }\n+\n+}\n+\n+  public void testSanityChecks() {\n+    try {\n+      final TestProblem3 pb  = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), new double[6],\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[6]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getInitialTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };\n+    double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            vecAbsoluteTolerance,\n+                                                            vecRelativeTolerance);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = 3200246026175251943L;\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      ++nbSteps;\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 4e-11);\n+        assertTrue(nbSteps < 670);\n+      }\n+    }\n+    private TestProblem3 pb;\n+    private int nbSteps;\n+    private double maxError;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class HighamHall54StepInterpolatorTest\n+  extends TestCase {\n+\n+  public HighamHall54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 158000);\n+    assertTrue(bos.size () < 159000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.6e-10);\n+\n+  }\n+\n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = 9111679755950880352L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;\n+\n+public class MidpointIntegratorTest\n+  extends TestCase {\n+\n+  public MidpointIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new MidpointIntegrator(0.01).integrate(pb,\n+                                             0.0, new double[pb.getDimension()+10],\n+                                             1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+        FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.setStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-7);\n+    assertTrue(handler.getMaximalValueError() < 1.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"midpoint\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalValueError() > 0.05);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;\n+\n+public class MidpointStepInterpolatorTest\n+  extends TestCase {\n+\n+  public MidpointStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 98000);\n+    assertTrue(bos.size () < 99000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-6);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/StepProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+\n+public class StepProblem\n+  implements FirstOrderDifferentialEquations, EventHandler {\n+\n+  public StepProblem(double rateBefore, double rateAfter,\n+                     double switchTime) {\n+    this.rateAfter  = rateAfter;\n+    this.switchTime = switchTime;\n+    setRate(rateBefore);\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] = rate;\n+  }\n+\n+  public int getDimension() {\n+    return 1;\n+  }\n+\n+  public void setRate(double rate) {\n+    this.rate = rate;\n+  }\n+\n+  public int eventOccurred(double t, double[] y) {\n+    setRate(rateAfter);\n+    return RESET_DERIVATIVES;\n+  }\n+\n+  public double g(double t, double[] y) {\n+    return t - switchTime;\n+  }\n+\n+  public void resetState(double t, double[] y) {\n+  }\n+\n+  private double rate;\n+  private double rateAfter;\n+  private double switchTime;\n+\n+  private static final long serialVersionUID = 7590601995477504318L;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem1.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = -y\n+ * </pre>\n+ * the solution of this equation is a simple exponential function :\n+ * <pre>\n+ *   y (t) = y (t0) exp (t0-t)\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem1\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1977870815289373164L;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem1() {\n+    super();\n+    double[] y0 = { 1.0, 0.1 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(4.0);\n+    double[] errorScale = { 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem1(TestProblem1 problem) {\n+    super(problem);\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem1(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = -y[i];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double c = Math.exp (t0 - t);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c * y0[i];\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = t^3 - t y\n+ * </pre>\n+ * with the initial condition y (0) = 0. The solution of this equation\n+ * is the following function :\n+ * <pre>\n+ *   y (t) = t^2 + 2 (ext (- t^2 / 2) - 1)\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem2\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 8330741783213512366L;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem2() {\n+    super();\n+    double[] y0 = { 0.0 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(1.0);\n+    double[] errorScale = { 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem2(TestProblem2 problem) {\n+    super(problem);\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem2(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = t * (t * t - y[i]);\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double t2 = t * t;\n+    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c;\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem3.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0\n+ *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))\n+ *    r = sqrt (y1^2 + y2^2), e = 0.9\n+ * </pre>\n+ * This is a two-body problem in the plane which can be solved by\n+ * Kepler's equation\n+ * <pre>\n+ *   y1 (t) = ...\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem3\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 8567328542728919999L;\n+\n+  /** Eccentricity */\n+  double e;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   * @param e eccentricity\n+   */\n+  public TestProblem3(double e) {\n+    super();\n+    this.e = e;\n+    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(20.0);\n+    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem3() {\n+    this(0.1);\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem3(TestProblem3 problem) {\n+    super(problem);\n+    e = problem.e;\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem3(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // current radius\n+    double r2 = y[0] * y[0] + y[1] * y[1];\n+    double invR3 = 1 / (r2 * Math.sqrt(r2));\n+\n+    // compute the derivatives\n+    yDot[0] = y[2];\n+    yDot[1] = y[3];\n+    yDot[2] = -invR3  * y[0];\n+    yDot[3] = -invR3  * y[1];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+\n+    // solve Kepler's equation\n+    double E = t;\n+    double d = 0;\n+    double corr = 0;\n+    do {\n+      double f2  = e * Math.sin(E);\n+      double f0  = d - f2;\n+      double f1  = 1 - e * Math.cos(E);\n+      double f12 = f1 + f1;\n+      corr  = f0 * f12 / (f1 * f12 - f0 * f2);\n+      d -= corr;\n+      E = t + d;\n+    } while (Math.abs(corr) > 1.0e-12);\n+\n+    double cosE = Math.cos(E);\n+    double sinE = Math.sin(E);\n+\n+    y[0] = cosE - e;\n+    y[1] = Math.sqrt(1 - e * e) * sinE;\n+    y[2] = -sinE / (1 - e * cosE);\n+    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n+\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem4.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    x'' = -x\n+ * </pre>\n+ * And when x decreases down to 0, the state should be changed as follows :\n+ * <pre>\n+ *   x' -> -x'\n+ * </pre>\n+ * The theoretical solution of this problem is x = |sin(t+a)|\n+ * </p>\n+\n+ */\n+public class TestProblem4\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -5910438521889015745L;\n+\n+  /** Time offset. */\n+  private double a;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /** Simple constructor. */\n+  public TestProblem4() {\n+    super();\n+    a = 1.2;\n+    double[] y0 = { Math.sin(a), Math.cos(a) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(15);\n+    double[] errorScale = { 1.0, 0.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem4(TestProblem4 problem) {\n+    super(problem);\n+    a = problem.a;\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem4(this);\n+  }\n+\n+  public EventHandler[] getEventsHandlers() {\n+    return new EventHandler[] { new Bounce(), new Stop() };\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] =  y[1];\n+    yDot[1] = -y[0];\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double sin = Math.sin(t + a);\n+    double cos = Math.cos(t + a);\n+    y[0] = Math.abs(sin);\n+    y[1] = (sin >= 0) ? cos : -cos;\n+    return y;\n+  }\n+\n+  private static class Bounce implements EventHandler {\n+\n+    private static final long serialVersionUID = 1356097180027801200L;\n+    private int sign;\n+\n+    public Bounce() {\n+      sign = +1;\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return sign * y[0];\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      // this sign change is needed because the state will be reset soon\n+      sign = -sign;\n+      return EventHandler.RESET_STATE;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+      y[1] = -y[1];\n+    }\n+\n+  }\n+\n+  private static class Stop implements EventHandler {\n+\n+    private static final long serialVersionUID = 6975050568227951931L;\n+\n+    public Stop() {\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return t - 12.0;\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      return EventHandler.STOP;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem5.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ * <p>This is the same as problem 1 except integration is done\n+ * backward in time</p>\n+ */\n+public class TestProblem5\n+  extends TestProblem1 {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 7579233102411804237L;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem5() {\n+    super();\n+    setFinalConditions(2 * t0 - t1);\n+  }\n+ \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemAbstract.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+/**\n+ * This class is used as the base class of the problems that are\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+public abstract class TestProblemAbstract\n+  implements FirstOrderDifferentialEquations, Cloneable {\n+\n+  /** Dimension of the problem. */\n+  protected int n;\n+\n+  /** Number of functions calls. */\n+  protected int calls;\n+\n+  /** Initial time */\n+  protected double t0;\n+\n+  /** Initial state */\n+  protected double[] y0;\n+\n+  /** Final time */\n+  protected double t1;\n+\n+  /** Error scale */\n+  protected double[] errorScale;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  protected TestProblemAbstract() {\n+    n          = 0;\n+    calls      = 0;\n+    t0         = 0;\n+    y0         = null;\n+    t1         = 0;\n+    errorScale = null;\n+  }\n+\n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  protected TestProblemAbstract(TestProblemAbstract problem) {\n+    n     = problem.n;\n+    calls = problem.calls;\n+    t0    = problem.t0;\n+    if (problem.y0 == null) {\n+      y0 = null;\n+    } else {\n+      y0 = (double[]) problem.y0.clone();\n+    }\n+    if (problem.errorScale == null) {\n+      errorScale = null;\n+    } else {\n+      errorScale = (double[]) problem.errorScale.clone();\n+    }\n+    t1 = problem.t1;\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public abstract Object clone();\n+\n+  /**\n+   * Set the initial conditions\n+   * @param t0 initial time\n+   * @param y0 initial state vector\n+   */\n+  protected void setInitialConditions(double t0, double[] y0) {\n+    calls     = 0;\n+    n         = y0.length;\n+    this.t0   = t0;\n+    this.y0   = (double[]) y0.clone(); \n+   }\n+\n+  /**\n+   * Set the final conditions.\n+   * @param t1 final time\n+   */\n+  protected void setFinalConditions(double t1) {\n+    this.t1 = t1;\n+  }\n+\n+  /**\n+   * Set the error scale\n+   * @param errorScale error scale\n+   */\n+  protected void setErrorScale(double[] errorScale) {\n+    this.errorScale = (double[]) errorScale.clone(); \n+  }\n+\n+  public int getDimension() {\n+    return n;\n+  }\n+\n+  /**\n+   * Get the initial time.\n+   * @return initial time\n+   */\n+  public double getInitialTime() {\n+    return t0;\n+  }\n+\n+  /**\n+   * Get the initial state vector.\n+   * @return initial state vector\n+   */\n+  public double[] getInitialState() {\n+    return y0;\n+  }\n+\n+  /**\n+   * Get the final time.\n+   * @return final time\n+   */\n+  public double getFinalTime() {\n+    return t1;\n+  }\n+\n+  /**\n+   * Get the error scale.\n+   * @return error scale\n+   */\n+  public double[] getErrorScale() {\n+    return errorScale;\n+  }\n+\n+  /**\n+   * Get the events handlers.\n+   * @return events handlers   */\n+  public EventHandler[] getEventsHandlers() {\n+    return new EventHandler[0];\n+  }\n+\n+  /**\n+   * Get the number of calls.\n+   * @return nuber of calls\n+   */\n+  public int getCalls() {\n+    return calls;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    ++calls;\n+    doComputeDerivatives(t, y, yDot);\n+  }\n+\n+  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);\n+\n+  /**\n+   * Compute the theoretical state at the specified time.\n+   * @param t time at which the state is required\n+   * @return state vector at time t\n+   */\n+  abstract public double[] computeTheoreticalState(double t);\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ */\n+class TestProblemFactory {\n+\n+  /** Problems pool. */\n+  private static TestProblemAbstract[] pool = {\n+    new TestProblem1(),\n+    new TestProblem2(),\n+    new TestProblem3(),\n+    new TestProblem4(),\n+    new TestProblem5()\n+  };\n+\n+  /**\n+   * Private constructor.\n+   * This is a utility class, so there are no instance at all.\n+   */\n+  private TestProblemFactory() {\n+  }\n+\n+  /**\n+   * Get the problems.\n+   * @return array of problems to solve\n+   */\n+  public static TestProblemAbstract[] getProblems() {\n+    return pool;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class is used to handle steps for the test problems\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+class TestProblemHandler\n+  implements StepHandler {\n+\n+  /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3589490480549900461L;\n+\n+/** Associated problem. */\n+  private TestProblemAbstract problem;\n+\n+  /** Maximal errors encountered during the integration. */\n+  private double maxValueError;\n+  private double maxTimeError;\n+\n+  /** Error at the end of the integration. */\n+  private double lastError;\n+\n+  /** Time at the end of integration. */\n+  private double lastTime;\n+\n+  /** ODE solver used. */\n+  private FirstOrderIntegrator integrator;\n+\n+  /** Expected start for step. */\n+  private double expectedStepStart;\n+\n+  /**\n+   * Simple constructor.\n+   * @param problem problem for which steps should be handled\n+   * @param integrator ODE solver used\n+   */\n+  public TestProblemHandler(TestProblemAbstract problem, FirstOrderIntegrator integrator) {\n+    this.problem = problem;\n+    this.integrator = integrator;\n+    reset();\n+  }\n+\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  public void reset() {\n+    maxValueError = 0;\n+    maxTimeError  = 0;\n+    lastError     = 0;\n+    expectedStepStart = problem.getInitialTime();\n+  }\n+\n+  public void handleStep(StepInterpolator interpolator,\n+                         boolean isLast)\n+    throws DerivativeException {\n+\n+    double start = integrator.getCurrentStepStart();\n+    maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));\n+    expectedStepStart = start + integrator.getCurrentSignedStepsize();\n+\n+    double pT = interpolator.getPreviousTime();\n+    double cT = interpolator.getCurrentTime();\n+    double[] errorScale = problem.getErrorScale();\n+\n+    // store the error at the last step\n+    if (isLast) {\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(cT);\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > lastError) {\n+          lastError = error;\n+        }\n+      }\n+      lastTime = cT;\n+    }\n+\n+    // walk through the step\n+    for (int k = 0; k <= 20; ++k) {\n+\n+      double time = pT + (k * (cT - pT)) / 20;\n+      interpolator.setInterpolatedTime(time);\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());\n+\n+      // update the errors\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > maxValueError) {\n+          maxValueError = error;\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  /**\n+   * Get the maximal value error encountered during integration.\n+   * @return maximal value error\n+   */\n+  public double getMaximalValueError() {\n+    return maxValueError;\n+  }\n+\n+  /**\n+   * Get the maximal time error encountered during integration.\n+   * @return maximal time error\n+   */\n+  public double getMaximalTimeError() {\n+    return maxTimeError;\n+  }\n+\n+  /**\n+   * Get the error at the end of the integration.\n+   * @return error at the end of the integration\n+   */\n+  public double getLastError() {\n+    return lastError;\n+  }\n+\n+  /**\n+   * Get the time at the end of the integration.\n+   * @return time at the end of the integration.\n+   */\n+  public double getLastTime() {\n+    return lastTime;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ThreeEighthesIntegratorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ThreeEighthesIntegrator(0.01).integrate(pb,\n+                                                  0.0, new double[pb.getDimension()+10],\n+                                                  1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+    \n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.setStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+ public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"3/8\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+\n+    private static final long serialVersionUID = 4400497468419540899L;\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      maxError = 0;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+      maxError = 0;\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+\n+    private TestProblem3 pb;\n+    private double maxError = 0;\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;\n+\n+public class ThreeEighthesStepInterpolatorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import junit.framework.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+\n+public class DummyStepInterpolatorTest\n+  extends TestCase {\n+\n+  public DummyStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoReset() {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testFixedState()\n+    throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testSerialization()\n+  throws DerivativeException, IntegratorException,\n+         IOException, ClassNotFoundException {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(interpolator);\n+\n+    assertTrue(bos.size () > 150);\n+    assertTrue(bos.size () < 250);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();\n+\n+    dsi.setInterpolatedTime(0.5);\n+    double[] result = dsi.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testImpossibleSerialization()\n+  throws DerivativeException, IntegratorException,\n+         IOException, ClassNotFoundException {\n+\n+    double[] y = { 0.0, 1.0, -2.0 };\n+    AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    try {\n+        oos.writeObject(interpolator);\n+        fail(\"an exception should have been thrown\");\n+    } catch (IOException ioe) {\n+        // expected behavior\n+        assertNull(ioe.getMessage());\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  private static class BadStepInterpolator extends DummyStepInterpolator {\n+      public BadStepInterpolator() {\n+          super();\n+      }\n+      public BadStepInterpolator(double[] y, boolean forward) {\n+          super(y, forward);\n+      }\n+      protected void doFinalize()\n+      throws DerivativeException {\n+          throw new DerivativeException(null);\n+      }\n+  };\n+\n+\n+  public void testSerializationError()\n+  throws DerivativeException, IntegratorException,\n+         IOException, ClassNotFoundException {\n+\n+    double[] y = { 0.0, 1.0, -2.0 };\n+    ErrorGeneratingInterpolator interpolator =\n+        new ErrorGeneratingInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(interpolator);\n+\n+    assertTrue(bos.size () > 300);\n+    assertTrue(bos.size () < 350);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    try {\n+        ois.readObject();\n+        fail(\"an exception should have been thrown\");\n+    } catch (IOException ioe) {\n+        // expected behavior\n+        assertNull(ioe.getMessage());\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  private static class ErrorGeneratingInterpolator extends DummyStepInterpolator {\n+      public ErrorGeneratingInterpolator() {\n+          super();\n+      }\n+      protected ErrorGeneratingInterpolator(double[] y, boolean forward) {\n+          super(y, forward);\n+      }\n+      public void computeInterpolatedState(double theta, double oneMinusThetaH)\n+      throws DerivativeException {\n+          throw new DerivativeException(null);\n+      }\n+      private static final long serialVersionUID = 0x3f6ab636f0c93571L;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DummyStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.TestProblem3;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.StepNormalizer;\n+\n+import junit.framework.*;\n+\n+public class StepNormalizerTest\n+  extends TestCase {\n+\n+  public StepNormalizerTest(String name) {\n+    super(name);\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.setStepHandler(new StepNormalizer(range / 10.0,\n+                                       new FixedStepHandler() {\n+                                         private boolean firstCall = true;\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                boolean isLast) {\n+                                           if (firstCall) {\n+                                             checkValue(t, pb.getInitialTime());\n+                                             firstCall = false;\n+                                           }\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t, pb.getFinalTime());\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void testBeforeEnd()\n+    throws DerivativeException, IntegratorException {\n+    final double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.setStepHandler(new StepNormalizer(range / 10.5,\n+                                       new FixedStepHandler() {\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                boolean isLast) {\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t,\n+                                                        pb.getFinalTime() - range / 21.0);\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public void setLastSeen(boolean lastSeen) {\n+    this.lastSeen = lastSeen;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(StepNormalizerTest.class);\n+  }\n+\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);\n+    lastSeen = false;\n+  }\n+\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+  boolean lastSeen;\n+\n+}\n--- a/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n /**\n  * Test cases for the DescriptiveStatistics class.\n  * \n- * @version $Revision: 592121 $ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n public class DescriptiveStatisticsTest extends TestCase {\n--- a/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n /**\n  * Test cases for the {@link MultivariateSummaryStatistics} class.\n  *\n- * @version $Revision: 566833 $ $Date: 2007-08-16 13:36:33 -0700 (Thu, 16 Aug 2007) $\n+ * @version $Revision$ $Date$\n  */\n \n public class MultivariateSummaryStatisticsTest extends TestCase {\n--- a/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n /**\n  * Test cases for the {@link SummaryStatistics} class.\n  *\n- * @version $Revision: 566833 $ $Date: 2007-08-16 13:36:33 -0700 (Thu, 16 Aug 2007) $\n+ * @version $Revision$ $Date$\n  */\n \n public class SummaryStatisticsTest extends TestCase {\n--- a/src/test/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n \n /**\n  * Test cases for the {@link SynchronizedSummaryStatisticsTest} class.\n- * @version $Revision: 592121 $ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {", "timestamp": 1214208098, "metainfo": ""}