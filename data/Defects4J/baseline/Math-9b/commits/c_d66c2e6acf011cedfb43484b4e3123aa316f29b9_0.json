{"sha": "d66c2e6acf011cedfb43484b4e3123aa316f29b9", "log": "removed TAB characters that crept in as of r762194 two weeks ago  ", "commit": "\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n  */\n public class RandomDataImpl implements RandomData, Serializable {\n \n-\t/** Serializable version identifier */\n-\tprivate static final long serialVersionUID = -626730818244969716L;\n-\n-\t/** underlying random number generator */\n-\tprivate RandomGenerator rand = null;\n-\n-\t/** underlying secure random number generator */\n-\tprivate SecureRandom secRand = null;\n-\n-\t/**\n-\t * Construct a RandomDataImpl.\n-\t */\n-\tpublic RandomDataImpl() {\n-\t}\n-\n-\t/**\n-\t * Construct a RandomDataImpl using the supplied {@link RandomGenerator} as\n-\t * the source of (non-secure) random data.\n-\t * \n-\t * @param rand\n-\t *            the source of (non-secure) random data\n-\t * @since 1.1\n-\t */\n-\tpublic RandomDataImpl(RandomGenerator rand) {\n-\t\tsuper();\n-\t\tthis.rand = rand;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t * <p>\n-\t * <strong>Algorithm Description:</strong> hex strings are generated using a\n-\t * 2-step process.\n-\t * <ol>\n-\t * <li>\n-\t * len/2+1 binary bytes are generated using the underlying Random</li>\n-\t * <li>\n-\t * Each binary byte is translated into 2 hex digits</li>\n-\t * </ol>\n-\t * </p>\n-\t * \n-\t * @param len\n-\t *            the desired string length.\n-\t * @return the random string.\n-\t */\n-\tpublic String nextHexString(int len) {\n-\t\tif (len <= 0) {\n-\t\t\tthrow new IllegalArgumentException(\"length must be positive\");\n-\t\t}\n-\n-\t\t// Get a random number generator\n-\t\tRandomGenerator ran = getRan();\n-\n-\t\t// Initialize output buffer\n-\t\tStringBuffer outBuffer = new StringBuffer();\n-\n-\t\t// Get int(len/2)+1 random bytes\n-\t\tbyte[] randomBytes = new byte[(len / 2) + 1];\n-\t\tran.nextBytes(randomBytes);\n-\n-\t\t// Convert each byte to 2 hex digits\n-\t\tfor (int i = 0; i < randomBytes.length; i++) {\n-\t\t\tInteger c = Integer.valueOf(randomBytes[i]);\n-\n-\t\t\t/*\n-\t\t\t * Add 128 to byte value to make interval 0-255 before doing hex\n-\t\t\t * conversion. This guarantees <= 2 hex digits from toHexString()\n-\t\t\t * toHexString would otherwise add 2^32 to negative arguments.\n-\t\t\t */\n-\t\t\tString hex = Integer.toHexString(c.intValue() + 128);\n-\n-\t\t\t// Make sure we add 2 hex digits for each byte\n-\t\t\tif (hex.length() == 1) {\n-\t\t\t\thex = \"0\" + hex;\n-\t\t\t}\n-\t\t\toutBuffer.append(hex);\n-\t\t}\n-\t\treturn outBuffer.toString().substring(0, len);\n-\t}\n-\n-\t/**\n-\t * Generate a random int value uniformly distributed between\n-\t * <code>lower</code> and <code>upper</code>, inclusive.\n-\t * \n-\t * @param lower\n-\t *            the lower bound.\n-\t * @param upper\n-\t *            the upper bound.\n-\t * @return the random integer.\n-\t */\n-\tpublic int nextInt(int lower, int upper) {\n-\t\tif (lower >= upper) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"upper bound must be > lower bound\");\n-\t\t}\n-\t\tRandomGenerator rand = getRan();\n-\t\tdouble r = rand.nextDouble();\n-\t\treturn (int) ((r * upper) + ((1.0 - r) * lower) + r);\n-\t}\n-\n-\t/**\n-\t * Generate a random long value uniformly distributed between\n-\t * <code>lower</code> and <code>upper</code>, inclusive.\n-\t * \n-\t * @param lower\n-\t *            the lower bound.\n-\t * @param upper\n-\t *            the upper bound.\n-\t * @return the random integer.\n-\t */\n-\tpublic long nextLong(long lower, long upper) {\n-\t\tif (lower >= upper) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"upper bound must be > lower bound\");\n-\t\t}\n-\t\tRandomGenerator rand = getRan();\n-\t\tdouble r = rand.nextDouble();\n-\t\treturn (long) ((r * upper) + ((1.0 - r) * lower) + r);\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t * <p>\n-\t * <strong>Algorithm Description:</strong> hex strings are generated in\n-\t * 40-byte segments using a 3-step process.\n-\t * <ol>\n-\t * <li>\n-\t * 20 random bytes are generated using the underlying\n-\t * <code>SecureRandom</code>.</li>\n-\t * <li>\n-\t * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n-\t * <li>\n-\t * Each byte of the binary digest is converted to 2 hex digits.</li>\n-\t * </ol>\n-\t * </p>\n-\t * \n-\t * @param len\n-\t *            the length of the generated string\n-\t * @return the random string\n-\t */\n-\tpublic String nextSecureHexString(int len) {\n-\t\tif (len <= 0) {\n-\t\t\tthrow new IllegalArgumentException(\"length must be positive\");\n-\t\t}\n-\n-\t\t// Get SecureRandom and setup Digest provider\n-\t\tSecureRandom secRan = getSecRan();\n-\t\tMessageDigest alg = null;\n-\t\ttry {\n-\t\t\talg = MessageDigest.getInstance(\"SHA-1\");\n-\t\t} catch (NoSuchAlgorithmException ex) {\n-\t\t\treturn null; // gulp FIXME? -- this *should* never fail.\n-\t\t}\n-\t\talg.reset();\n-\n-\t\t// Compute number of iterations required (40 bytes each)\n-\t\tint numIter = (len / 40) + 1;\n-\n-\t\tStringBuffer outBuffer = new StringBuffer();\n-\t\tfor (int iter = 1; iter < numIter + 1; iter++) {\n-\t\t\tbyte[] randomBytes = new byte[40];\n-\t\t\tsecRan.nextBytes(randomBytes);\n-\t\t\talg.update(randomBytes);\n-\n-\t\t\t// Compute hash -- will create 20-byte binary hash\n-\t\t\tbyte hash[] = alg.digest();\n-\n-\t\t\t// Loop over the hash, converting each byte to 2 hex digits\n-\t\t\tfor (int i = 0; i < hash.length; i++) {\n-\t\t\t\tInteger c = Integer.valueOf(hash[i]);\n-\n-\t\t\t\t/*\n-\t\t\t\t * Add 128 to byte value to make interval 0-255 This guarantees\n-\t\t\t\t * <= 2 hex digits from toHexString() toHexString would\n-\t\t\t\t * otherwise add 2^32 to negative arguments\n-\t\t\t\t */\n-\t\t\t\tString hex = Integer.toHexString(c.intValue() + 128);\n-\n-\t\t\t\t// Keep strings uniform length -- guarantees 40 bytes\n-\t\t\t\tif (hex.length() == 1) {\n-\t\t\t\t\thex = \"0\" + hex;\n-\t\t\t\t}\n-\t\t\t\toutBuffer.append(hex);\n-\t\t\t}\n-\t\t}\n-\t\treturn outBuffer.toString().substring(0, len);\n-\t}\n-\n-\t/**\n-\t * Generate a random int value uniformly distributed between\n-\t * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n-\t * a secure random number generator.\n-\t * \n-\t * @param lower\n-\t *            the lower bound.\n-\t * @param upper\n-\t *            the upper bound.\n-\t * @return the random integer.\n-\t */\n-\tpublic int nextSecureInt(int lower, int upper) {\n-\t\tif (lower >= upper) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"lower bound must be < upper bound\");\n-\t\t}\n-\t\tSecureRandom sec = getSecRan();\n-\t\treturn lower + (int) (sec.nextDouble() * (upper - lower + 1));\n-\t}\n-\n-\t/**\n-\t * Generate a random long value uniformly distributed between\n-\t * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n-\t * a secure random number generator.\n-\t * \n-\t * @param lower\n-\t *            the lower bound.\n-\t * @param upper\n-\t *            the upper bound.\n-\t * @return the random integer.\n-\t */\n-\tpublic long nextSecureLong(long lower, long upper) {\n-\t\tif (lower >= upper) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"lower bound must be < upper bound\");\n-\t\t}\n-\t\tSecureRandom sec = getSecRan();\n-\t\treturn lower + (long) (sec.nextDouble() * (upper - lower + 1));\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t * <p>\n-\t * <strong>Algorithm Description</strong>: For small means, uses simulation\n-\t * of a Poisson process using Uniform deviates, as described <a\n-\t * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n-\t * </p>\n-\t * <p>\n-\t * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n-\t * </p>\n-\t * \n-\t * <p>\n-\t * For large means, uses a reject method as described in <a\n-\t * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n-\t * Variate Generation</a>\n-\t * </p>\n-\t * \n-\t * <p>\n-\t * References:\n-\t * <ul>\n-\t * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n-\t * New York, NY. Springer-Verlag</li>\n-\t * </ul>\n-\t * </p>\n-\t * \n-\t * @param mean\n-\t *            mean of the Poisson distribution.\n-\t * @return the random Poisson value.\n-\t */\n-\tpublic long nextPoisson(double mean) {\n-\t\tif (mean <= 0) {\n-\t\t\tthrow new IllegalArgumentException(\"Poisson mean must be > 0\");\n-\t\t}\n-\n-\t\tRandomGenerator rand = getRan();\n-\n-\t\tdouble pivot = 6.0;\n-\t\tif (mean < pivot) {\n-\t\t\tdouble p = Math.exp(-mean);\n-\t\t\tlong n = 0;\n-\t\t\tdouble r = 1.0d;\n-\t\t\tdouble rnd = 1.0d;\n-\n-\t\t\twhile (n < 1000 * mean) {\n-\t\t\t\trnd = rand.nextDouble();\n-\t\t\t\tr = r * rnd;\n-\t\t\t\tif (r >= p) {\n-\t\t\t\t\tn++;\n-\t\t\t\t} else {\n-\t\t\t\t\treturn n;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn n;\n-\t\t} else {\n-\t\t\tdouble mu = Math.floor(mean);\n-\t\t\tdouble delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n-\t\t\t// between 6\n-\t\t\t// and mean\n-\t\t\tdouble mu2delta = 2.0 * mu + delta;\n-\t\t\tdouble muDeltaHalf = mu + delta / 2.0;\n-\t\t\tdouble logMeanMu = Math.log(mean / mu);\n-\n-\t\t\tdouble muFactorialLog = MathUtils.factorialLog((int) mu);\n-\n-\t\t\tdouble c1 = Math.sqrt(Math.PI * mu / 2.0);\n-\t\t\tdouble c2 = c1\n-\t\t\t\t\t+ Math.sqrt(Math.PI * muDeltaHalf\n-\t\t\t\t\t\t\t/ (2.0 * Math.exp(1.0 / mu2delta)));\n-\t\t\tdouble c3 = c2 + 2.0;\n-\t\t\tdouble c4 = c3 + Math.exp(1.0 / 78.0);\n-\t\t\tdouble c = c4 + 2.0 / delta * mu2delta\n-\t\t\t\t\t* Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n-\n-\t\t\tdouble y = 0.0;\n-\t\t\tdouble x = 0.0;\n-\t\t\tdouble w = Double.POSITIVE_INFINITY;\n-\n-\t\t\tboolean accept = false;\n-\t\t\twhile (!accept) {\n-\t\t\t\tdouble u = nextUniform(0.0, c);\n-\t\t\t\tdouble e = nextExponential(mean);\n-\n-\t\t\t\tif (u <= c1) {\n-\t\t\t\t\tdouble z = nextGaussian(0.0, 1.0);\n-\t\t\t\t\ty = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n-\t\t\t\t\tx = Math.floor(y);\n-\t\t\t\t\tw = -z * z / 2.0 - e - x * logMeanMu;\n-\t\t\t\t\tif (x < -mu) {\n-\t\t\t\t\t\tw = Double.POSITIVE_INFINITY;\n-\t\t\t\t\t}\n-\t\t\t\t} else if (c1 < u && u <= c2) {\n-\t\t\t\t\tdouble z = nextGaussian(0.0, 1.0);\n-\t\t\t\t\ty = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n-\t\t\t\t\tx = Math.ceil(y);\n-\t\t\t\t\tw = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n-\t\t\t\t\tif (x > delta) {\n-\t\t\t\t\t\tw = Double.POSITIVE_INFINITY;\n-\t\t\t\t\t}\n-\t\t\t\t} else if (c2 < u && u <= c3) {\n-\t\t\t\t\tx = 0.0;\n-\t\t\t\t\tw = -e;\n-\t\t\t\t} else if (c3 < u && u <= c4) {\n-\t\t\t\t\tx = 1.0;\n-\t\t\t\t\tw = -e - logMeanMu;\n-\t\t\t\t} else if (c4 < u) {\n-\t\t\t\t\tdouble v = nextExponential(mean);\n-\t\t\t\t\ty = delta + v * 2.0 / delta * mu2delta;\n-\t\t\t\t\tx = Math.ceil(y);\n-\t\t\t\t\tw = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n-\t\t\t\t}\n-\t\t\t\taccept = (w <= x * Math.log(mu)\n-\t\t\t\t\t\t- MathUtils.factorialLog((int) (mu + x))\n-\t\t\t\t\t\t/ muFactorialLog);\n-\t\t\t}\n-\t\t\t// cast to long is acceptable because both x and mu are whole\n-\t\t\t// numbers.\n-\t\t\treturn (long) (x + mu);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Generate a random value from a Normal (a.k.a. Gaussian) distribution with\n-\t * the given mean, <code>mu</code> and the given standard deviation,\n-\t * <code>sigma</code>.\n-\t * \n-\t * @param mu\n-\t *            the mean of the distribution\n-\t * @param sigma\n-\t *            the standard deviation of the distribution\n-\t * @return the random Normal value\n-\t */\n-\tpublic double nextGaussian(double mu, double sigma) {\n-\t\tif (sigma <= 0) {\n-\t\t\tthrow new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n-\t\t}\n-\t\tRandomGenerator rand = getRan();\n-\t\treturn sigma * rand.nextGaussian() + mu;\n-\t}\n-\n-\t/**\n-\t * Returns a random value from an Exponential distribution with the given\n-\t * mean.\n-\t * <p>\n-\t * <strong>Algorithm Description</strong>: Uses the <a\n-\t * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n-\t * Method</a> to generate exponentially distributed random values from\n-\t * uniform deviates.\n-\t * </p>\n-\t * \n-\t * @param mean\n-\t *            the mean of the distribution\n-\t * @return the random Exponential value\n-\t */\n-\tpublic double nextExponential(double mean) {\n-\t\tif (mean < 0.0) {\n-\t\t\tthrow new IllegalArgumentException(\"Exponential mean must be >= 0\");\n-\t\t}\n-\t\tRandomGenerator rand = getRan();\n-\t\tdouble unif = rand.nextDouble();\n-\t\twhile (unif == 0.0d) {\n-\t\t\tunif = rand.nextDouble();\n-\t\t}\n-\t\treturn -mean * Math.log(unif);\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t * <p>\n-\t * <strong>Algorithm Description</strong>: scales the output of\n-\t * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n-\t * random double if Random.nextDouble() returns 0). This is necessary to\n-\t * provide a symmetric output interval (both endpoints excluded).\n-\t * </p>\n-\t * \n-\t * @param lower\n-\t *            the lower bound.\n-\t * @param upper\n-\t *            the upper bound.\n-\t * @return a uniformly distributed random value from the interval (lower,\n-\t *         upper)\n-\t */\n-\tpublic double nextUniform(double lower, double upper) {\n-\t\tif (lower >= upper) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"lower bound must be < upper bound\");\n-\t\t}\n-\t\tRandomGenerator rand = getRan();\n-\n-\t\t// ensure nextDouble() isn't 0.0\n-\t\tdouble u = rand.nextDouble();\n-\t\twhile (u <= 0.0) {\n-\t\t\tu = rand.nextDouble();\n-\t\t}\n-\n-\t\treturn lower + u * (upper - lower);\n-\t}\n-\n-\t/**\n-\t * Returns the RandomGenerator used to generate non-secure random data.\n-\t * <p>\n-\t * Creates and initializes a default generator if null.\n-\t * </p>\n-\t * \n-\t * @return the Random used to generate random data\n-\t * @since 1.1\n-\t */\n-\tprivate RandomGenerator getRan() {\n-\t\tif (rand == null) {\n-\t\t\trand = new JDKRandomGenerator();\n-\t\t\trand.setSeed(System.currentTimeMillis());\n-\t\t}\n-\t\treturn rand;\n-\t}\n-\n-\t/**\n-\t * Returns the SecureRandom used to generate secure random data.\n-\t * <p>\n-\t * Creates and initializes if null.\n-\t * </p>\n-\t * \n-\t * @return the SecureRandom used to generate secure random data\n-\t */\n-\tprivate SecureRandom getSecRan() {\n-\t\tif (secRand == null) {\n-\t\t\tsecRand = new SecureRandom();\n-\t\t\tsecRand.setSeed(System.currentTimeMillis());\n-\t\t}\n-\t\treturn secRand;\n-\t}\n-\n-\t/**\n-\t * Reseeds the random number generator with the supplied seed.\n-\t * <p>\n-\t * Will create and initialize if null.\n-\t * </p>\n-\t * \n-\t * @param seed\n-\t *            the seed value to use\n-\t */\n-\tpublic void reSeed(long seed) {\n-\t\tif (rand == null) {\n-\t\t\trand = new JDKRandomGenerator();\n-\t\t}\n-\t\trand.setSeed(seed);\n-\t}\n-\n-\t/**\n-\t * Reseeds the secure random number generator with the current time in\n-\t * milliseconds.\n-\t * <p>\n-\t * Will create and initialize if null.\n-\t * </p>\n-\t */\n-\tpublic void reSeedSecure() {\n-\t\tif (secRand == null) {\n-\t\t\tsecRand = new SecureRandom();\n-\t\t}\n-\t\tsecRand.setSeed(System.currentTimeMillis());\n-\t}\n-\n-\t/**\n-\t * Reseeds the secure random number generator with the supplied seed.\n-\t * <p>\n-\t * Will create and initialize if null.\n-\t * </p>\n-\t * \n-\t * @param seed\n-\t *            the seed value to use\n-\t */\n-\tpublic void reSeedSecure(long seed) {\n-\t\tif (secRand == null) {\n-\t\t\tsecRand = new SecureRandom();\n-\t\t}\n-\t\tsecRand.setSeed(seed);\n-\t}\n-\n-\t/**\n-\t * Reseeds the random number generator with the current time in\n-\t * milliseconds.\n-\t */\n-\tpublic void reSeed() {\n-\t\tif (rand == null) {\n-\t\t\trand = new JDKRandomGenerator();\n-\t\t}\n-\t\trand.setSeed(System.currentTimeMillis());\n-\t}\n-\n-\t/**\n-\t * Sets the PRNG algorithm for the underlying SecureRandom instance using\n-\t * the Security Provider API. The Security Provider API is defined in <a\n-\t * href =\n-\t * \"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n-\t * Java Cryptography Architecture API Specification & Reference.</a>\n-\t * <p>\n-\t * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n-\t * overhead and may take several seconds to execute.\n-\t * </p>\n-\t * \n-\t * @param algorithm\n-\t *            the name of the PRNG algorithm\n-\t * @param provider\n-\t *            the name of the provider\n-\t * @throws NoSuchAlgorithmException\n-\t *             if the specified algorithm is not available\n-\t * @throws NoSuchProviderException\n-\t *             if the specified provider is not installed\n-\t */\n-\tpublic void setSecureAlgorithm(String algorithm, String provider)\n-\t\t\tthrows NoSuchAlgorithmException, NoSuchProviderException {\n-\t\tsecRand = SecureRandom.getInstance(algorithm, provider);\n-\t}\n-\n-\t/**\n-\t * Generates an integer array of length <code>k</code> whose entries are\n-\t * selected randomly, without repetition, from the integers\n-\t * <code>0 through n-1</code> (inclusive).\n-\t * <p>\n-\t * Generated arrays represent permutations of <code>n</code> taken\n-\t * <code>k</code> at a time.\n-\t * </p>\n-\t * <p>\n-\t * <strong>Preconditions:</strong>\n-\t * <ul>\n-\t * <li> <code>k <= n</code></li>\n-\t * <li> <code>n > 0</code></li>\n-\t * </ul>\n-\t * If the preconditions are not met, an IllegalArgumentException is thrown.\n-\t * </p>\n-\t * <p>\n-\t * Uses a 2-cycle permutation shuffle. The shuffling process is described <a\n-\t * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n-\t * here</a>.\n-\t * </p>\n-\t * \n-\t * @param n\n-\t *            domain of the permutation (must be positive)\n-\t * @param k\n-\t *            size of the permutation (must satisfy 0 < k <= n).\n-\t * @return the random permutation as an int array\n-\t */\n-\tpublic int[] nextPermutation(int n, int k) {\n-\t\tif (k > n) {\n-\t\t\tthrow new IllegalArgumentException(\"permutation k exceeds n\");\n-\t\t}\n-\t\tif (k == 0) {\n-\t\t\tthrow new IllegalArgumentException(\"permutation k must be > 0\");\n-\t\t}\n-\n-\t\tint[] index = getNatural(n);\n-\t\tshuffle(index, n - k);\n-\t\tint[] result = new int[k];\n-\t\tfor (int i = 0; i < k; i++) {\n-\t\t\tresult[i] = index[n - i - 1];\n-\t\t}\n-\n-\t\treturn result;\n-\t}\n-\n-\t/**\n-\t * Uses a 2-cycle permutation shuffle to generate a random permutation.\n-\t * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n-\t * shuffle to generate a random permutation of <code>c.size()</code> and\n-\t * then returns the elements whose indexes correspond to the elements of the\n-\t * generated permutation. This technique is described, and proven to\n-\t * generate random samples, <a\n-\t * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n-\t * here</a>\n-\t * \n-\t * @param c\n-\t *            Collection to sample from.\n-\t * @param k\n-\t *            sample size.\n-\t * @return the random sample.\n-\t */\n-\tpublic Object[] nextSample(Collection<?> c, int k) {\n-\t\tint len = c.size();\n-\t\tif (k > len) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"sample size exceeds collection size\");\n-\t\t}\n-\t\tif (k == 0) {\n-\t\t\tthrow new IllegalArgumentException(\"sample size must be > 0\");\n-\t\t}\n-\n-\t\tObject[] objects = c.toArray();\n-\t\tint[] index = nextPermutation(len, k);\n-\t\tObject[] result = new Object[k];\n-\t\tfor (int i = 0; i < k; i++) {\n-\t\t\tresult[i] = objects[index[i]];\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t// ------------------------Private methods----------------------------------\n-\n-\t/**\n-\t * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n-\t * of list.\n-\t * \n-\t * @param list\n-\t *            list to be shuffled\n-\t * @param end\n-\t *            element past which shuffling begins\n-\t */\n-\tprivate void shuffle(int[] list, int end) {\n-\t\tint target = 0;\n-\t\tfor (int i = list.length - 1; i >= end; i--) {\n-\t\t\tif (i == 0) {\n-\t\t\t\ttarget = 0;\n-\t\t\t} else {\n-\t\t\t\ttarget = nextInt(0, i);\n-\t\t\t}\n-\t\t\tint temp = list[target];\n-\t\t\tlist[target] = list[i];\n-\t\t\tlist[i] = temp;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Returns an array representing n.\n-\t * \n-\t * @param n\n-\t *            the natural number to represent\n-\t * @return array with entries = elements of n\n-\t */\n-\tprivate int[] getNatural(int n) {\n-\t\tint[] natural = new int[n];\n-\t\tfor (int i = 0; i < n; i++) {\n-\t\t\tnatural[i] = i;\n-\t\t}\n-\t\treturn natural;\n-\t}\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -626730818244969716L;\n+\n+    /** underlying random number generator */\n+    private RandomGenerator rand = null;\n+\n+    /** underlying secure random number generator */\n+    private SecureRandom secRand = null;\n+\n+    /**\n+     * Construct a RandomDataImpl.\n+     */\n+    public RandomDataImpl() {\n+    }\n+\n+    /**\n+     * Construct a RandomDataImpl using the supplied {@link RandomGenerator} as\n+     * the source of (non-secure) random data.\n+     * \n+     * @param rand\n+     *            the source of (non-secure) random data\n+     * @since 1.1\n+     */\n+    public RandomDataImpl(RandomGenerator rand) {\n+        super();\n+        this.rand = rand;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description:</strong> hex strings are generated using a\n+     * 2-step process.\n+     * <ol>\n+     * <li>\n+     * len/2+1 binary bytes are generated using the underlying Random</li>\n+     * <li>\n+     * Each binary byte is translated into 2 hex digits</li>\n+     * </ol>\n+     * </p>\n+     * \n+     * @param len\n+     *            the desired string length.\n+     * @return the random string.\n+     */\n+    public String nextHexString(int len) {\n+        if (len <= 0) {\n+            throw new IllegalArgumentException(\"length must be positive\");\n+        }\n+\n+        // Get a random number generator\n+        RandomGenerator ran = getRan();\n+\n+        // Initialize output buffer\n+        StringBuffer outBuffer = new StringBuffer();\n+\n+        // Get int(len/2)+1 random bytes\n+        byte[] randomBytes = new byte[(len / 2) + 1];\n+        ran.nextBytes(randomBytes);\n+\n+        // Convert each byte to 2 hex digits\n+        for (int i = 0; i < randomBytes.length; i++) {\n+            Integer c = Integer.valueOf(randomBytes[i]);\n+\n+            /*\n+             * Add 128 to byte value to make interval 0-255 before doing hex\n+             * conversion. This guarantees <= 2 hex digits from toHexString()\n+             * toHexString would otherwise add 2^32 to negative arguments.\n+             */\n+            String hex = Integer.toHexString(c.intValue() + 128);\n+\n+            // Make sure we add 2 hex digits for each byte\n+            if (hex.length() == 1) {\n+                hex = \"0\" + hex;\n+            }\n+            outBuffer.append(hex);\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+\n+    /**\n+     * Generate a random int value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public int nextInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException(\n+                    \"upper bound must be > lower bound\");\n+        }\n+        RandomGenerator rand = getRan();\n+        double r = rand.nextDouble();\n+        return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n+    }\n+\n+    /**\n+     * Generate a random long value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public long nextLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException(\n+                    \"upper bound must be > lower bound\");\n+        }\n+        RandomGenerator rand = getRan();\n+        double r = rand.nextDouble();\n+        return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description:</strong> hex strings are generated in\n+     * 40-byte segments using a 3-step process.\n+     * <ol>\n+     * <li>\n+     * 20 random bytes are generated using the underlying\n+     * <code>SecureRandom</code>.</li>\n+     * <li>\n+     * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n+     * <li>\n+     * Each byte of the binary digest is converted to 2 hex digits.</li>\n+     * </ol>\n+     * </p>\n+     * \n+     * @param len\n+     *            the length of the generated string\n+     * @return the random string\n+     */\n+    public String nextSecureHexString(int len) {\n+        if (len <= 0) {\n+            throw new IllegalArgumentException(\"length must be positive\");\n+        }\n+\n+        // Get SecureRandom and setup Digest provider\n+        SecureRandom secRan = getSecRan();\n+        MessageDigest alg = null;\n+        try {\n+            alg = MessageDigest.getInstance(\"SHA-1\");\n+        } catch (NoSuchAlgorithmException ex) {\n+            return null; // gulp FIXME? -- this *should* never fail.\n+        }\n+        alg.reset();\n+\n+        // Compute number of iterations required (40 bytes each)\n+        int numIter = (len / 40) + 1;\n+\n+        StringBuffer outBuffer = new StringBuffer();\n+        for (int iter = 1; iter < numIter + 1; iter++) {\n+            byte[] randomBytes = new byte[40];\n+            secRan.nextBytes(randomBytes);\n+            alg.update(randomBytes);\n+\n+            // Compute hash -- will create 20-byte binary hash\n+            byte hash[] = alg.digest();\n+\n+            // Loop over the hash, converting each byte to 2 hex digits\n+            for (int i = 0; i < hash.length; i++) {\n+                Integer c = Integer.valueOf(hash[i]);\n+\n+                /*\n+                 * Add 128 to byte value to make interval 0-255 This guarantees\n+                 * <= 2 hex digits from toHexString() toHexString would\n+                 * otherwise add 2^32 to negative arguments\n+                 */\n+                String hex = Integer.toHexString(c.intValue() + 128);\n+\n+                // Keep strings uniform length -- guarantees 40 bytes\n+                if (hex.length() == 1) {\n+                    hex = \"0\" + hex;\n+                }\n+                outBuffer.append(hex);\n+            }\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+\n+    /**\n+     * Generate a random int value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n+     * a secure random number generator.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public int nextSecureInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException(\n+                    \"lower bound must be < upper bound\");\n+        }\n+        SecureRandom sec = getSecRan();\n+        return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+\n+    /**\n+     * Generate a random long value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n+     * a secure random number generator.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public long nextSecureLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException(\n+                    \"lower bound must be < upper bound\");\n+        }\n+        SecureRandom sec = getSecRan();\n+        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description</strong>: For small means, uses simulation\n+     * of a Poisson process using Uniform deviates, as described <a\n+     * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * </p>\n+     * <p>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n+     * </p>\n+     * \n+     * <p>\n+     * For large means, uses a reject method as described in <a\n+     * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n+     * Variate Generation</a>\n+     * </p>\n+     * \n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n+     * New York, NY. Springer-Verlag</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param mean\n+     *            mean of the Poisson distribution.\n+     * @return the random Poisson value.\n+     */\n+    public long nextPoisson(double mean) {\n+        if (mean <= 0) {\n+            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n+        }\n+\n+        RandomGenerator rand = getRan();\n+\n+        double pivot = 6.0;\n+        if (mean < pivot) {\n+            double p = Math.exp(-mean);\n+            long n = 0;\n+            double r = 1.0d;\n+            double rnd = 1.0d;\n+\n+            while (n < 1000 * mean) {\n+                rnd = rand.nextDouble();\n+                r = r * rnd;\n+                if (r >= p) {\n+                    n++;\n+                } else {\n+                    return n;\n+                }\n+            }\n+            return n;\n+        } else {\n+            double mu = Math.floor(mean);\n+            double delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n+            // between 6\n+            // and mean\n+            double mu2delta = 2.0 * mu + delta;\n+            double muDeltaHalf = mu + delta / 2.0;\n+            double logMeanMu = Math.log(mean / mu);\n+\n+            double muFactorialLog = MathUtils.factorialLog((int) mu);\n+\n+            double c1 = Math.sqrt(Math.PI * mu / 2.0);\n+            double c2 = c1\n+                    + Math.sqrt(Math.PI * muDeltaHalf\n+                            / (2.0 * Math.exp(1.0 / mu2delta)));\n+            double c3 = c2 + 2.0;\n+            double c4 = c3 + Math.exp(1.0 / 78.0);\n+            double c = c4 + 2.0 / delta * mu2delta\n+                    * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n+\n+            double y = 0.0;\n+            double x = 0.0;\n+            double w = Double.POSITIVE_INFINITY;\n+\n+            boolean accept = false;\n+            while (!accept) {\n+                double u = nextUniform(0.0, c);\n+                double e = nextExponential(mean);\n+\n+                if (u <= c1) {\n+                    double z = nextGaussian(0.0, 1.0);\n+                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n+                    x = Math.floor(y);\n+                    w = -z * z / 2.0 - e - x * logMeanMu;\n+                    if (x < -mu) {\n+                        w = Double.POSITIVE_INFINITY;\n+                    }\n+                } else if (c1 < u && u <= c2) {\n+                    double z = nextGaussian(0.0, 1.0);\n+                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n+                    x = Math.ceil(y);\n+                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n+                    if (x > delta) {\n+                        w = Double.POSITIVE_INFINITY;\n+                    }\n+                } else if (c2 < u && u <= c3) {\n+                    x = 0.0;\n+                    w = -e;\n+                } else if (c3 < u && u <= c4) {\n+                    x = 1.0;\n+                    w = -e - logMeanMu;\n+                } else if (c4 < u) {\n+                    double v = nextExponential(mean);\n+                    y = delta + v * 2.0 / delta * mu2delta;\n+                    x = Math.ceil(y);\n+                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n+                }\n+                accept = (w <= x * Math.log(mu)\n+                        - MathUtils.factorialLog((int) (mu + x))\n+                        / muFactorialLog);\n+            }\n+            // cast to long is acceptable because both x and mu are whole\n+            // numbers.\n+            return (long) (x + mu);\n+        }\n+    }\n+\n+    /**\n+     * Generate a random value from a Normal (a.k.a. Gaussian) distribution with\n+     * the given mean, <code>mu</code> and the given standard deviation,\n+     * <code>sigma</code>.\n+     * \n+     * @param mu\n+     *            the mean of the distribution\n+     * @param sigma\n+     *            the standard deviation of the distribution\n+     * @return the random Normal value\n+     */\n+    public double nextGaussian(double mu, double sigma) {\n+        if (sigma <= 0) {\n+            throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n+        }\n+        RandomGenerator rand = getRan();\n+        return sigma * rand.nextGaussian() + mu;\n+    }\n+\n+    /**\n+     * Returns a random value from an Exponential distribution with the given\n+     * mean.\n+     * <p>\n+     * <strong>Algorithm Description</strong>: Uses the <a\n+     * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n+     * Method</a> to generate exponentially distributed random values from\n+     * uniform deviates.\n+     * </p>\n+     * \n+     * @param mean\n+     *            the mean of the distribution\n+     * @return the random Exponential value\n+     */\n+    public double nextExponential(double mean) {\n+        if (mean < 0.0) {\n+            throw new IllegalArgumentException(\"Exponential mean must be >= 0\");\n+        }\n+        RandomGenerator rand = getRan();\n+        double unif = rand.nextDouble();\n+        while (unif == 0.0d) {\n+            unif = rand.nextDouble();\n+        }\n+        return -mean * Math.log(unif);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description</strong>: scales the output of\n+     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n+     * random double if Random.nextDouble() returns 0). This is necessary to\n+     * provide a symmetric output interval (both endpoints excluded).\n+     * </p>\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return a uniformly distributed random value from the interval (lower,\n+     *         upper)\n+     */\n+    public double nextUniform(double lower, double upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException(\n+                    \"lower bound must be < upper bound\");\n+        }\n+        RandomGenerator rand = getRan();\n+\n+        // ensure nextDouble() isn't 0.0\n+        double u = rand.nextDouble();\n+        while (u <= 0.0) {\n+            u = rand.nextDouble();\n+        }\n+\n+        return lower + u * (upper - lower);\n+    }\n+\n+    /**\n+     * Returns the RandomGenerator used to generate non-secure random data.\n+     * <p>\n+     * Creates and initializes a default generator if null.\n+     * </p>\n+     * \n+     * @return the Random used to generate random data\n+     * @since 1.1\n+     */\n+    private RandomGenerator getRan() {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+            rand.setSeed(System.currentTimeMillis());\n+        }\n+        return rand;\n+    }\n+\n+    /**\n+     * Returns the SecureRandom used to generate secure random data.\n+     * <p>\n+     * Creates and initializes if null.\n+     * </p>\n+     * \n+     * @return the SecureRandom used to generate secure random data\n+     */\n+    private SecureRandom getSecRan() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+            secRand.setSeed(System.currentTimeMillis());\n+        }\n+        return secRand;\n+    }\n+\n+    /**\n+     * Reseeds the random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     * \n+     * @param seed\n+     *            the seed value to use\n+     */\n+    public void reSeed(long seed) {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+        }\n+        rand.setSeed(seed);\n+    }\n+\n+    /**\n+     * Reseeds the secure random number generator with the current time in\n+     * milliseconds.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     */\n+    public void reSeedSecure() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(System.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Reseeds the secure random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     * \n+     * @param seed\n+     *            the seed value to use\n+     */\n+    public void reSeedSecure(long seed) {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(seed);\n+    }\n+\n+    /**\n+     * Reseeds the random number generator with the current time in\n+     * milliseconds.\n+     */\n+    public void reSeed() {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+        }\n+        rand.setSeed(System.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Sets the PRNG algorithm for the underlying SecureRandom instance using\n+     * the Security Provider API. The Security Provider API is defined in <a\n+     * href =\n+     * \"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n+     * Java Cryptography Architecture API Specification & Reference.</a>\n+     * <p>\n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n+     * overhead and may take several seconds to execute.\n+     * </p>\n+     * \n+     * @param algorithm\n+     *            the name of the PRNG algorithm\n+     * @param provider\n+     *            the name of the provider\n+     * @throws NoSuchAlgorithmException\n+     *             if the specified algorithm is not available\n+     * @throws NoSuchProviderException\n+     *             if the specified provider is not installed\n+     */\n+    public void setSecureAlgorithm(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        secRand = SecureRandom.getInstance(algorithm, provider);\n+    }\n+\n+    /**\n+     * Generates an integer array of length <code>k</code> whose entries are\n+     * selected randomly, without repetition, from the integers\n+     * <code>0 through n-1</code> (inclusive).\n+     * <p>\n+     * Generated arrays represent permutations of <code>n</code> taken\n+     * <code>k</code> at a time.\n+     * </p>\n+     * <p>\n+     * <strong>Preconditions:</strong>\n+     * <ul>\n+     * <li> <code>k <= n</code></li>\n+     * <li> <code>n > 0</code></li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is thrown.\n+     * </p>\n+     * <p>\n+     * Uses a 2-cycle permutation shuffle. The shuffling process is described <a\n+     * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>.\n+     * </p>\n+     * \n+     * @param n\n+     *            domain of the permutation (must be positive)\n+     * @param k\n+     *            size of the permutation (must satisfy 0 < k <= n).\n+     * @return the random permutation as an int array\n+     */\n+    public int[] nextPermutation(int n, int k) {\n+        if (k > n) {\n+            throw new IllegalArgumentException(\"permutation k exceeds n\");\n+        }\n+        if (k == 0) {\n+            throw new IllegalArgumentException(\"permutation k must be > 0\");\n+        }\n+\n+        int[] index = getNatural(n);\n+        shuffle(index, n - k);\n+        int[] result = new int[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = index[n - i - 1];\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Uses a 2-cycle permutation shuffle to generate a random permutation.\n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n+     * shuffle to generate a random permutation of <code>c.size()</code> and\n+     * then returns the elements whose indexes correspond to the elements of the\n+     * generated permutation. This technique is described, and proven to\n+     * generate random samples, <a\n+     * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>\n+     * \n+     * @param c\n+     *            Collection to sample from.\n+     * @param k\n+     *            sample size.\n+     * @return the random sample.\n+     */\n+    public Object[] nextSample(Collection<?> c, int k) {\n+        int len = c.size();\n+        if (k > len) {\n+            throw new IllegalArgumentException(\n+                    \"sample size exceeds collection size\");\n+        }\n+        if (k == 0) {\n+            throw new IllegalArgumentException(\"sample size must be > 0\");\n+        }\n+\n+        Object[] objects = c.toArray();\n+        int[] index = nextPermutation(len, k);\n+        Object[] result = new Object[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = objects[index[i]];\n+        }\n+        return result;\n+    }\n+\n+    // ------------------------Private methods----------------------------------\n+\n+    /**\n+     * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n+     * of list.\n+     * \n+     * @param list\n+     *            list to be shuffled\n+     * @param end\n+     *            element past which shuffling begins\n+     */\n+    private void shuffle(int[] list, int end) {\n+        int target = 0;\n+        for (int i = list.length - 1; i >= end; i--) {\n+            if (i == 0) {\n+                target = 0;\n+            } else {\n+                target = nextInt(0, i);\n+            }\n+            int temp = list[target];\n+            list[target] = list[i];\n+            list[i] = temp;\n+        }\n+    }\n+\n+    /**\n+     * Returns an array representing n.\n+     * \n+     * @param n\n+     *            the natural number to represent\n+     * @return array with entries = elements of n\n+     */\n+    private int[] getNatural(int n) {\n+        int[] natural = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            natural[i] = i;\n+        }\n+        return natural;\n+    }\n }", "timestamp": 1240159380, "metainfo": ""}