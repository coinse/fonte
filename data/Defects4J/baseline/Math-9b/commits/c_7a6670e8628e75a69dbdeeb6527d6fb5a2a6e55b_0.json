{"sha": "7a6670e8628e75a69dbdeeb6527d6fb5a2a6e55b", "log": "prevent root bracketing to be attempted outside of search interval  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n         // find a very small interval bracketing the root\n         final double step = FastMath.max(bracketing.getAbsoluteAccuracy(),\n                                          FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n-        double xLo        = baseRoot - step;\n+        double xLo        = FastMath.max(min, baseRoot - step);\n         double fLo        = f.value(xLo);\n-        double xHi        = baseRoot + step;\n+        double xHi        = FastMath.min(max, baseRoot + step);\n         double fHi        = f.value(xHi);\n         int remainingEval = maxEval - 2;\n-        while ((remainingEval > 0) && (xLo >= min) && (xHi <= max)) {\n-\n-            if ((fLo > 0 && fHi < 0) || (fLo < 0 && fHi > 0)) {\n+        while (remainingEval > 0) {\n+\n+            if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n                 // compute the root on the selected side\n                 return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolutions);\n             }\n \n             // update the lower bound\n             if (changeLo) {\n-                xLo -= step;\n+                xLo = FastMath.max(min, xLo - step);\n                 fLo  = f.value(xLo);\n                 remainingEval--;\n             }\n \n             // update the higher bound\n             if (changeHi) {\n-                xHi += step;\n+                xHi = FastMath.min(max, xHi + step);\n                 fHi  = f.value(xHi);\n                 remainingEval--;\n             }", "timestamp": 1310313891, "metainfo": ""}