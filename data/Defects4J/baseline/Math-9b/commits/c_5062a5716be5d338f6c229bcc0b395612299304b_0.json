{"sha": "5062a5716be5d338f6c229bcc0b395612299304b", "log": "Speed improvements to o.a.c.m.transform.FastFourierTransformer. Patch contributed by Kurt Ostfeld (MATH-732).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n \n import java.io.Serializable;\n import java.lang.reflect.Array;\n+import java.util.Arrays;\n \n import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n-import org.apache.commons.math.complex.RootsOfUnity;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n public class FastFourierTransformer implements Serializable {\n \n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120501L;\n+    static final long serialVersionUID = 20120802L;\n+\n+    /**\n+     * {@code W_SUB_N_R[i]} is the real part of\n+     * {@code exp(- 2 * i * pi / n)}:\n+     * {@code W_SUB_N_R[i] = cos(2 * pi/ n)}, where {@code n = 2^i}.\n+     */\n+    private static final double[] W_SUB_N_R =\n+            {  0x1.0p0, -0x1.0p0, 0x1.1a62633145c07p-54, 0x1.6a09e667f3bcdp-1\n+            , 0x1.d906bcf328d46p-1, 0x1.f6297cff75cbp-1, 0x1.fd88da3d12526p-1, 0x1.ff621e3796d7ep-1\n+            , 0x1.ffd886084cd0dp-1, 0x1.fff62169b92dbp-1, 0x1.fffd8858e8a92p-1, 0x1.ffff621621d02p-1\n+            , 0x1.ffffd88586ee6p-1, 0x1.fffff62161a34p-1, 0x1.fffffd8858675p-1, 0x1.ffffff621619cp-1\n+            , 0x1.ffffffd885867p-1, 0x1.fffffff62161ap-1, 0x1.fffffffd88586p-1, 0x1.ffffffff62162p-1\n+            , 0x1.ffffffffd8858p-1, 0x1.fffffffff6216p-1, 0x1.fffffffffd886p-1, 0x1.ffffffffff621p-1\n+            , 0x1.ffffffffffd88p-1, 0x1.fffffffffff62p-1, 0x1.fffffffffffd9p-1, 0x1.ffffffffffff6p-1\n+            , 0x1.ffffffffffffep-1, 0x1.fffffffffffffp-1, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0, 0x1.0p0\n+            , 0x1.0p0, 0x1.0p0, 0x1.0p0 };\n+\n+    /**\n+     * {@code W_SUB_N_I[i]} is the imaginary part of\n+     * {@code exp(- 2 * i * pi / n)}:\n+     * {@code W_SUB_N_I[i] = -sin(2 * pi/ n)}, where {@code n = 2^i}.\n+     */\n+    private static final double[] W_SUB_N_I =\n+            {  0x1.1a62633145c07p-52, -0x1.1a62633145c07p-53, -0x1.0p0, -0x1.6a09e667f3bccp-1\n+            , -0x1.87de2a6aea963p-2, -0x1.8f8b83c69a60ap-3, -0x1.917a6bc29b42cp-4, -0x1.91f65f10dd814p-5\n+            , -0x1.92155f7a3667ep-6, -0x1.921d1fcdec784p-7, -0x1.921f0fe670071p-8, -0x1.921f8becca4bap-9\n+            , -0x1.921faaee6472dp-10, -0x1.921fb2aecb36p-11, -0x1.921fb49ee4ea6p-12, -0x1.921fb51aeb57bp-13\n+            , -0x1.921fb539ecf31p-14, -0x1.921fb541ad59ep-15, -0x1.921fb5439d73ap-16, -0x1.921fb544197ap-17\n+            , -0x1.921fb544387bap-18, -0x1.921fb544403c1p-19, -0x1.921fb544422c2p-20, -0x1.921fb54442a83p-21\n+            , -0x1.921fb54442c73p-22, -0x1.921fb54442cefp-23, -0x1.921fb54442d0ep-24, -0x1.921fb54442d15p-25\n+            , -0x1.921fb54442d17p-26, -0x1.921fb54442d18p-27, -0x1.921fb54442d18p-28, -0x1.921fb54442d18p-29\n+            , -0x1.921fb54442d18p-30, -0x1.921fb54442d18p-31, -0x1.921fb54442d18p-32, -0x1.921fb54442d18p-33\n+            , -0x1.921fb54442d18p-34, -0x1.921fb54442d18p-35, -0x1.921fb54442d18p-36, -0x1.921fb54442d18p-37\n+            , -0x1.921fb54442d18p-38, -0x1.921fb54442d18p-39, -0x1.921fb54442d18p-40, -0x1.921fb54442d18p-41\n+            , -0x1.921fb54442d18p-42, -0x1.921fb54442d18p-43, -0x1.921fb54442d18p-44, -0x1.921fb54442d18p-45\n+            , -0x1.921fb54442d18p-46, -0x1.921fb54442d18p-47, -0x1.921fb54442d18p-48, -0x1.921fb54442d18p-49\n+            , -0x1.921fb54442d18p-50, -0x1.921fb54442d18p-51, -0x1.921fb54442d18p-52, -0x1.921fb54442d18p-53\n+            , -0x1.921fb54442d18p-54, -0x1.921fb54442d18p-55, -0x1.921fb54442d18p-56, -0x1.921fb54442d18p-57\n+            , -0x1.921fb54442d18p-58, -0x1.921fb54442d18p-59, -0x1.921fb54442d18p-60 };\n \n     /**\n      * {@code true} if the unitary version of the DFT should be used.\n      * @see #createUnitary()\n      */\n     private final boolean unitary;\n-\n-    /** The roots of unity. */\n-    private RootsOfUnity roots = new RootsOfUnity();\n \n     /**\n      * Creates a new instance of this class, with various normalization\n         return new FastFourierTransformer(true);\n     }\n \n+    public static void bitReversalShuffle2(double[] a, double[] b) {\n+        final int n = a.length;\n+        assert(b.length == n);\n+        final int halfOfN = n >> 1;\n+\n+        int j = 0;\n+        for (int i = 0; i < n; i++) {\n+            if (i < j) {\n+                // swap indices i & j\n+                double temp = a[i];\n+                a[i] = a[j];\n+                a[j] = temp;\n+\n+                temp = b[i];\n+                b[i] = b[j];\n+                b[j] = temp;\n+            }\n+\n+            int k = halfOfN;\n+            while (k <= j && k > 0) {\n+                j -= k;\n+                k >>= 1;\n+            }\n+            j += k;\n+        }\n+    }\n+\n+    /**\n+     * Computes the standard transform of the specified complex data. The\n+     * computation is done in place. The input data is laid out as follows\n+     * <ul>\n+     * <li>{@code dataRI[0][i]} is the real part of the {@code i}-th data point,\n+     * </li>\n+     * <li>{@code dataRI[1][i]} is the imaginary part of the {@code i}-th data\n+     * point.</li>\n+     * </ul>\n+     *\n+     * @param dataRI the two dimensional array of real and imaginary parts of\n+     * the data\n+     * @param inverse {@code true} if the inverse standard transform must be\n+     * performed\n+     * @throws DimensionMismatchException if the number of rows of the specified\n+     * array is not two, or the array is not rectangular\n+     * @throws MathIllegalArgumentException if the number of data points is not\n+     * a power of two\n+     */\n+    public static void transformInPlace(final double[][] dataRI,\n+        boolean inverse) throws\n+        DimensionMismatchException, MathIllegalArgumentException {\n+\n+        if (dataRI.length != 2) {\n+            throw new DimensionMismatchException(dataRI.length, 2);\n+        }\n+        final double[] dataR = dataRI[0];\n+        final double[] dataI = dataRI[1];\n+        if (dataR.length != dataI.length) {\n+            throw new DimensionMismatchException(dataI.length, dataR.length);\n+        }\n+\n+        final int n = dataR.length;\n+        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n+            throw new MathIllegalArgumentException(\n+                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n+                Integer.valueOf(n));\n+        }\n+\n+        if (n == 1) {\n+            return;\n+        } else if (n == 2) {\n+            final double srcR0 = dataR[0];\n+            final double srcI0 = dataI[0];\n+            final double srcR1 = dataR[1];\n+            final double srcI1 = dataI[1];\n+\n+            // X_0 = x_0 + x_1\n+            dataR[0] = srcR0 + srcR1;\n+            dataI[0] = srcI0 + srcI1;\n+            // X_1 = x_0 - x_1\n+            dataR[1] = srcR0 - srcR1;\n+            dataI[1] = srcI0 - srcI1;\n+\n+            if (inverse) {\n+                dataR[0] /= 2;\n+                dataI[0] /= 2;\n+                dataR[1] /= 2;\n+                dataI[1] /= 2;\n+            }\n+            return;\n+        }\n+\n+        bitReversalShuffle2(dataR, dataI);\n+\n+        // Do 4-term DFT.\n+        if (inverse) {\n+            for (int i0 = 0; i0 < n; i0 += 4) {\n+                final int i1 = i0 + 1;\n+                final int i2 = i0 + 2;\n+                final int i3 = i0 + 3;\n+\n+                final double srcR0 = dataR[i0];\n+                final double srcI0 = dataI[i0];\n+                final double srcR1 = dataR[i2];\n+                final double srcI1 = dataI[i2];\n+                final double srcR2 = dataR[i1];\n+                final double srcI2 = dataI[i1];\n+                final double srcR3 = dataR[i3];\n+                final double srcI3 = dataI[i3];\n+\n+                // 4-term DFT\n+                // X_0 = x_0 + x_1 + x_2 + x_3\n+                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n+                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n+                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n+                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n+                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n+                // X_2 = x_0 - x_1 + x_2 - x_3\n+                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n+                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n+                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n+                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n+                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n+            }\n+        } else {\n+            for (int i0 = 0; i0 < n; i0 += 4) {\n+                final int i1 = i0 + 1;\n+                final int i2 = i0 + 2;\n+                final int i3 = i0 + 3;\n+\n+                final double srcR0 = dataR[i0];\n+                final double srcI0 = dataI[i0];\n+                final double srcR1 = dataR[i2];\n+                final double srcI1 = dataI[i2];\n+                final double srcR2 = dataR[i1];\n+                final double srcI2 = dataI[i1];\n+                final double srcR3 = dataR[i3];\n+                final double srcI3 = dataI[i3];\n+\n+                // 4-term DFT\n+                // X_0 = x_0 + x_1 + x_2 + x_3\n+                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n+                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n+                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n+                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n+                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n+                // X_2 = x_0 - x_1 + x_2 - x_3\n+                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n+                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n+                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n+                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n+                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n+            }\n+        }\n+\n+        int lastN0 = 4;\n+        int lastLogN0 = 2;\n+        while (lastN0 < n) {\n+            int n0 = lastN0 << 1;\n+            int logN0 = lastLogN0 + 1;\n+            double wSubN0R = W_SUB_N_R[logN0];\n+            double wSubN0I = W_SUB_N_I[logN0];\n+            if (inverse) {\n+                wSubN0I = -wSubN0I;\n+            }\n+\n+            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n+            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n+                int destOddStartIndex = destEvenStartIndex + lastN0;\n+\n+                double wSubN0ToRR = 1;\n+                double wSubN0ToRI = 0;\n+\n+                for (int r = 0; r < lastN0; r++) {\n+                    double grR = dataR[destEvenStartIndex + r];\n+                    double grI = dataI[destEvenStartIndex + r];\n+                    double hrR = dataR[destOddStartIndex + r];\n+                    double hrI = dataI[destOddStartIndex + r];\n+\n+                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n+                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n+                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n+                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\n+                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI * hrI);\n+                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n+\n+                    // WsubN0ToR *= WsubN0R\n+                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n+                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n+                    wSubN0ToRR = nextWsubN0ToRR;\n+                    wSubN0ToRI = nextWsubN0ToRI;\n+                }\n+            }\n+\n+            lastN0 = n0;\n+            lastLogN0 = logN0;\n+        }\n+\n+        if (inverse) {\n+            final double scaleFactor = 1.0 / ((double) n);\n+            for (int i = 0; i < n; i++) {\n+                dataR[i] *= scaleFactor;\n+                dataI[i] *= scaleFactor;\n+            }\n+        }\n+    }\n \n     /**\n      * Returns the forward transform of the specified real data set.\n      * not a power of two\n      */\n     public Complex[] transform(double[] f) {\n+        final double[][] dataRI = new double[][] {\n+            Arrays.copyOf(f, f.length), new double[f.length]\n+        };\n+\n+        transformInPlace(dataRI, false);\n+\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(f.length);\n-            return TransformUtils.scaleArray(fft(f, false), s);\n-        }\n-        return fft(f, false);\n+            TransformUtils.scaleArray(dataRI[0], s);\n+            TransformUtils.scaleArray(dataRI[1], s);\n+        }\n+\n+        return TransformUtils.createComplexArray(dataRI);\n     }\n \n     /**\n             double min, double max, int n) {\n \n         final double[] data = FunctionUtils.sample(f, min, max, n);\n-        if (unitary) {\n-            final double s = 1.0 / FastMath.sqrt(n);\n-            return TransformUtils.scaleArray(fft(data, false), s);\n-        }\n-        return fft(data, false);\n+        return transform(data);\n     }\n \n     /**\n      * not a power of two\n      */\n     public Complex[] transform(Complex[] f) {\n-        roots.computeRoots(-f.length);\n+        final double[][] dataRI = TransformUtils.createRealImaginaryArray(f);\n+\n+        transformInPlace(dataRI, false);\n+\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(f.length);\n-            return TransformUtils.scaleArray(fft(f), s);\n-        }\n-        return fft(f);\n+            TransformUtils.scaleArray(dataRI[0], s);\n+            TransformUtils.scaleArray(dataRI[1], s);\n+        }\n+\n+        return TransformUtils.createComplexArray(dataRI);\n     }\n \n     /**\n      * not a power of two\n      */\n     public Complex[] inverseTransform(double[] f) {\n-        final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n-        return TransformUtils.scaleArray(fft(f, true), s);\n+        final double[][] dataRI = new double[][] {\n+            Arrays.copyOf(f, f.length), new double[f.length]\n+        };\n+\n+        transformInPlace(dataRI, true);\n+\n+        if (unitary) {\n+            final double s = FastMath.sqrt(f.length);\n+            TransformUtils.scaleArray(dataRI[0], s);\n+            TransformUtils.scaleArray(dataRI[1], s);\n+        }\n+\n+        return TransformUtils.createComplexArray(dataRI);\n     }\n \n     /**\n     public Complex[] inverseTransform(UnivariateFunction f,\n             double min, double max, int n) {\n         final double[] data = FunctionUtils.sample(f, min, max, n);\n-        final double s = 1.0 / (unitary ? FastMath.sqrt(n) : n);\n-        return TransformUtils.scaleArray(fft(data, true), s);\n+        return inverseTransform(data);\n     }\n \n     /**\n      * not a power of two\n      */\n     public Complex[] inverseTransform(Complex[] f) {\n-        roots.computeRoots(f.length);\n-        final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n-        return TransformUtils.scaleArray(fft(f), s);\n-    }\n-\n-    /**\n-     * Returns the FFT of the specified real data set. Performs the base-4\n-     * Cooley-Tukey FFT algorithm.\n-     *\n-     * @param f the real data array to be transformed\n-     * @param isInverse {@code true} if inverse transform is to be carried out\n-     * @return the complex transformed array\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n-     */\n-    protected Complex[] fft(double[] f, boolean isInverse) {\n-\n-        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n-                    Integer.valueOf(f.length));\n-        }\n-        Complex[] transformed = new Complex[f.length];\n-        if (f.length == 1) {\n-            transformed[0] = new Complex(f[0], 0.0);\n-            return transformed;\n-        }\n-\n-        // Rather than the naive real to complex conversion, pack 2N\n-        // real numbers into N complex numbers for better performance.\n-        int n = f.length >> 1;\n-        Complex[] repacked = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            repacked[i] = new Complex(f[2 * i], f[2 * i + 1]);\n-        }\n-        roots.computeRoots(isInverse ? n : -n);\n-        Complex[] z = fft(repacked);\n-\n-        // reconstruct the FFT result for the original array\n-        roots.computeRoots(isInverse ? 2 * n : -2 * n);\n-        transformed[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n-        transformed[n] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n-        for (int i = 1; i < n; i++) {\n-            Complex a = z[n - i].conjugate();\n-            Complex b = z[i].add(a);\n-            Complex c = z[i].subtract(a);\n-            //Complex D = roots.getOmega(i).multiply(Complex.I);\n-            Complex d = new Complex(-roots.getImaginary(i),\n-                                    roots.getReal(i));\n-            transformed[i] = b.subtract(c.multiply(d));\n-            transformed[2 * n - i] = transformed[i].conjugate();\n-        }\n-\n-        return TransformUtils.scaleArray(transformed, 0.5);\n-    }\n-\n-    /**\n-     * Returns the FFT of the specified complex data set. Performs the base-4\n-     * Cooley-Tukey FFT algorithm.\n-     *\n-     * @param data the complex data array to be transformed\n-     * @return the complex transformed array\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n-     */\n-    protected Complex[] fft(Complex[] data) {\n-\n-        if (!ArithmeticUtils.isPowerOfTwo(data.length)) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n-                    Integer.valueOf(data.length));\n-        }\n-\n-        final int n = data.length;\n-        final Complex[] f = new Complex[n];\n-\n-        // initial simple cases\n-        if (n == 1) {\n-            f[0] = data[0];\n-            return f;\n-        }\n-        if (n == 2) {\n-            f[0] = data[0].add(data[1]);\n-            f[1] = data[0].subtract(data[1]);\n-            return f;\n-        }\n-\n-        // permute original data array in bit-reversal order\n-        int ii = 0;\n-        for (int i = 0; i < n; i++) {\n-            f[i] = data[ii];\n-            int k = n >> 1;\n-            while (ii >= k && k > 0) {\n-                ii -= k; k >>= 1;\n-            }\n-            ii += k;\n-        }\n-\n-        // the bottom base-4 round\n-        for (int i = 0; i < n; i += 4) {\n-            final Complex a = f[i].add(f[i + 1]);\n-            final Complex b = f[i + 2].add(f[i + 3]);\n-            final Complex c = f[i].subtract(f[i + 1]);\n-            final Complex d = f[i + 2].subtract(f[i + 3]);\n-            final Complex e1 = c.add(d.multiply(Complex.I));\n-            final Complex e2 = c.subtract(d.multiply(Complex.I));\n-            f[i] = a.add(b);\n-            f[i + 2] = a.subtract(b);\n-            // omegaCount indicates forward or inverse transform\n-            f[i + 1] = roots.isCounterClockWise() ? e1 : e2;\n-            f[i + 3] = roots.isCounterClockWise() ? e2 : e1;\n-        }\n-\n-        // iterations from bottom to top take O(N*logN) time\n-        for (int i = 4; i < n; i <<= 1) {\n-            final int m = n / (i << 1);\n-            for (int j = 0; j < n; j += i << 1) {\n-                for (int k = 0; k < i; k++) {\n-                    //z = f[i+j+k].multiply(roots.getOmega(k*m));\n-                    final int km = k * m;\n-                    final double omegaKmReal = roots.getReal(km);\n-                    final double omegaKmImag = roots.getImaginary(km);\n-                    //z = f[i+j+k].multiply(omega[k*m]);\n-                    final Complex z = new Complex(\n-                        f[i + j + k].getReal() * omegaKmReal -\n-                        f[i + j + k].getImaginary() * omegaKmImag,\n-                        f[i + j + k].getReal() * omegaKmImag +\n-                        f[i + j + k].getImaginary() * omegaKmReal);\n-\n-                    f[i + j + k] = f[j + k].subtract(z);\n-                    f[j + k] = f[j + k].add(z);\n-                }\n-            }\n-        }\n-        return f;\n+        final double[][] dataRI = TransformUtils.createRealImaginaryArray(f);\n+        final double[] dataR = dataRI[0];\n+        final double[] dataI = dataRI[1];\n+\n+        transformInPlace(dataRI, true);\n+\n+        if (unitary) {\n+            final double s = FastMath.sqrt(f.length);\n+            TransformUtils.scaleArray(dataR, s);\n+            TransformUtils.scaleArray(dataI, s);\n+        }\n+\n+        return TransformUtils.createComplexArray(dataRI);\n     }\n \n     /**\n      * @return transform of {@code mdca} as a Multi-Dimensional Complex Array\n      * id est {@code Complex[][][][]}\n      * @throws IllegalArgumentException if any dimension is not a power of two\n-     * @deprecated see\n-     * <a href=\"https://issues.apache.org/jira/browse/MATH-736\">MATH-736</a>\n-     */\n-    @Deprecated\n+     */\n     public Object mdfft(Object mdca, boolean forward) {\n         MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n                 new MultiDimensionalComplexMatrix(mdca).clone();\n      * eventually be replaced by jsr-83 of the java community process\n      * http://jcp.org/en/jsr/detail?id=83\n      * may require additional exception throws for other basic requirements.\n-     *\n-     * @deprecated see MATH-736\n-     */\n-    @Deprecated\n+     */\n     private static class MultiDimensionalComplexMatrix\n         implements Cloneable {\n \n--- a/src/main/java/org/apache/commons/math/transform/TransformUtils.java\n+++ b/src/main/java/org/apache/commons/math/transform/TransformUtils.java\n  */\n package org.apache.commons.math.transform;\n \n+import java.util.Arrays;\n+\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * Useful functions for the implementation of various transforms.\n  * @since 3.0\n  */\n public class TransformUtils {\n+    /**\n+     * Table of the powers of 2 to facilitate binary search lookup.\n+     *\n+     * @see #exactLog2(int)\n+     */\n+    private static final int[] POWERS_OF_TWO = {\n+        0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020,\n+        0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800,\n+        0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000,\n+        0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,\n+        0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000,\n+        0x40000000\n+    };\n+\n     /** Private constructor. */\n     private TransformUtils() {\n         super();\n         return f;\n     }\n \n+\n+    /**\n+     * Builds a new two dimensional array of {@code double} filled with the real\n+     * and imaginary parts of the specified {@link Complex} numbers. In the\n+     * returned array {@code dataRI}, the data is laid out as follows\n+     * <ul>\n+     * <li>{@code dataRI[0][i] = dataC[i].getReal()},</li>\n+     * <li>{@code dataRI[1][i] = dataC[i].getImaginary()}.</li>\n+     * </ul>\n+     *\n+     * @param dataC the array of {@link Complex} data to be transformed\n+     * @return a two dimensional array filled with the real and imaginary parts\n+     * of the specified complex input\n+     */\n+    public static double[][] createRealImaginaryArray(final Complex[] dataC) {\n+        final double[][] dataRI = new double[2][dataC.length];\n+        final double[] dataR = dataRI[0];\n+        final double[] dataI = dataRI[1];\n+        for (int i = 0; i < dataC.length; i++) {\n+            final Complex c = dataC[i];\n+            dataR[i] = c.getReal();\n+            dataI[i] = c.getImaginary();\n+        }\n+        return dataRI;\n+    }\n+\n+    /**\n+     * Builds a new array of {@link Complex} from the specified two dimensional\n+     * array of real and imaginary parts. In the returned array {@code dataC},\n+     * the data is laid out as follows\n+     * <ul>\n+     * <li>{@code dataC[i].getReal() = dataRI[0][i]},</li>\n+     * <li>{@code dataC[i].getImaginary() = dataRI[1][i]}.</li>\n+     * </ul>\n+     *\n+     * @param dataRI the array of real and imaginary parts to be transformed\n+     * @return an array of {@link Complex} with specified real and imaginary\n+     * parts.\n+     * @throws DimensionMismatchException if the number of rows of the specified\n+     * array is not two, or the array is not rectangular\n+     */\n+    public static Complex[] createComplexArray(final double[][] dataRI)\n+        throws DimensionMismatchException{\n+\n+        if (dataRI.length != 2) {\n+            throw new DimensionMismatchException(dataRI.length, 2);\n+        }\n+        final double[] dataR = dataRI[0];\n+        final double[] dataI = dataRI[1];\n+        if (dataR.length != dataI.length) {\n+            throw new DimensionMismatchException(dataI.length, dataR.length);\n+        }\n+\n+        final int n = dataR.length;\n+        final Complex[] c = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            c[i] = new Complex(dataR[i], dataI[i]);\n+        }\n+        return c;\n+    }\n+\n+\n+    /**\n+     * Returns the base-2 logarithm of the specified {@code int}. Throws an\n+     * exception if {@code n} is not a power of two.\n+     *\n+     * @param n the {@code int} whose base-2 logarithm is to be evaluated\n+     * @return the base-2 logarithm of {@code n}\n+     * @throws MathIllegalArgumentException if {@code n} is not a power of two\n+     */\n+    public static int exactLog2(final int n)\n+        throws MathIllegalArgumentException {\n+\n+        int index = Arrays.binarySearch(TransformUtils.POWERS_OF_TWO, n);\n+        if (index < 0) {\n+            throw new MathIllegalArgumentException(\n+                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n+                    Integer.valueOf(n));\n+        }\n+        return index;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n         doTestTransformComplex(8, 1.0E-14, forward, standard);\n         doTestTransformComplex(16, 1.0E-13, forward, standard);\n         doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-12, forward, standard);\n         doTestTransformComplex(128, 1.0E-12, forward, standard);\n     }\n \n         doTestTransformComplex(8, 1.0E-14, forward, standard);\n         doTestTransformComplex(16, 1.0E-13, forward, standard);\n         doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-12, forward, standard);\n         doTestTransformComplex(128, 1.0E-12, forward, standard);\n     }\n \n     public void testUnitaryInverseTransformComplex() {\n         final boolean forward = false;\n         final boolean standard = false;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(2, 1.0E-14, forward, standard);\n         doTestTransformComplex(4, 1.0E-14, forward, standard);\n         doTestTransformComplex(8, 1.0E-14, forward, standard);\n         doTestTransformComplex(16, 1.0E-13, forward, standard);", "timestamp": 1328688656, "metainfo": ""}