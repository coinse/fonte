{"sha": "23ed9b90e6cbfa1ab4ef95f0534e717537287602", "log": "improved test coverage  ", "commit": "\n--- a/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n \n   }\n \n+  public void testModelsMerging()\n+    throws DerivativeException, IntegratorException {\n+\n+      // theoretical solution: y[0] = cos(t), y[1] = sin(t)\n+      FirstOrderDifferentialEquations problem =\n+          new FirstOrderDifferentialEquations() {\n+          public void computeDerivatives(double t, double[] y, double[] dot)\n+          throws DerivativeException {\n+              dot[0] = -y[1];\n+              dot[1] =  y[0];\n+          }\n+          public int getDimension() {\n+              return 2;\n+          }\n+      };\n+\n+      // integrate backward from &pi; to 0;\n+      ContinuousOutputModel cm1 = new ContinuousOutputModel();\n+      FirstOrderIntegrator integ1 =\n+          new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);\n+      integ1.setStepHandler(cm1);\n+      integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 },\n+                       0, new double[2]);\n+\n+      // integrate backward from 2&pi; to &pi;\n+      ContinuousOutputModel cm2 = new ContinuousOutputModel();\n+      FirstOrderIntegrator integ2 =\n+          new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);\n+      integ2.setStepHandler(cm2);\n+      integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 },\n+                       Math.PI, new double[2]);\n+\n+      // merge the two half circles\n+      ContinuousOutputModel cm = new ContinuousOutputModel();\n+      cm.append(cm2);\n+      cm.append(new ContinuousOutputModel());\n+      cm.append(cm1);\n+\n+      // check circle\n+      assertEquals(2.0 * Math.PI, cm.getInitialTime(), 1.0e-12);\n+      assertEquals(0, cm.getFinalTime(), 1.0e-12);\n+      assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);\n+      for (double t = 0; t < 2.0 * Math.PI; t += 0.1) {\n+          cm.setInterpolatedTime(t);\n+          double[] y = cm.getInterpolatedState();\n+          assertEquals(Math.cos(t), y[0], 1.0e-7);\n+          assertEquals(Math.sin(t), y[1], 1.0e-7);\n+      }\n+      \n+  }\n+\n+  public void testErrorConditions()\n+    throws DerivativeException {\n+\n+      ContinuousOutputModel cm = new ContinuousOutputModel();\n+      cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);\n+      \n+      // dimension mismatch\n+      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));\n+\n+      // hole between time ranges\n+      assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));\n+\n+      // propagation direction mismatch\n+      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));\n+\n+      // no errors\n+      assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));\n+\n+  }\n+\n+  private boolean checkAppendError(ContinuousOutputModel cm,\n+                                   double t0, double[] y0, double t1)\n+  throws DerivativeException {\n+      try {\n+          ContinuousOutputModel otherCm = new ContinuousOutputModel();\n+          otherCm.handleStep(buildInterpolator(t0, y0, t1), true);\n+          cm.append(otherCm);\n+      } catch(IllegalArgumentException iae) {\n+          //expected behavior\n+          return true;\n+      }\n+      return false;\n+  }\n+\n+  private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) {\n+      DummyStepInterpolator interpolator  = new DummyStepInterpolator(y0, t1 >= t0);\n+      interpolator.storeTime(t0);\n+      interpolator.shift();\n+      interpolator.storeTime(t1);\n+      return interpolator;\n+  }\n+\n   public void checkValue(double value, double reference) {\n     assertTrue(Math.abs(value - reference) < 1.0e-10);\n   }", "timestamp": 1193407191, "metainfo": ""}