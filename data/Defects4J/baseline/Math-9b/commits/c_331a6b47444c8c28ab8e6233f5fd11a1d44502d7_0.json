{"sha": "331a6b47444c8c28ab8e6233f5fd11a1d44502d7", "log": "Added documentation.   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n /**\n  * Computes a natural spline interpolation for the data set.\n  *\n- * @version $Revision: 1.10 $ $Date: 2003/11/19 03:28:23 $\n+ * @version $Revision: 1.11 $ $Date: 2003/12/27 15:22:34 $\n  *\n  */\n public class SplineInterpolator implements UnivariateRealInterpolator, Serializable {\n             throw new IllegalArgumentException(\"Dataset arrays must have same length.\");\n         }\n \n+        // TODO: What's this good for? Did I really write this???\n         if (c == null) {\n             // Number of intervals. The number of data points is N+1.\n             int n = xval.length - 1;\n             // Check whether the xval vector has ascending values.\n-            // Separation should be checked too (not implemented: which criteria?).\n+            // TODO: Separation should be checked too (not implemented: which criteria?).\n             for (int i = 0; i < n; i++) {\n                 if (xval[i] >= xval[i + 1]) {\n                     throw new IllegalArgumentException(\"Dataset must specify sorted, ascending x values.\");\n             }\n             // Vectors for the equation system. There are n-1 equations for the unknowns s[i] (1<=i<=N-1),\n             // which are second order derivatives for the spline at xval[i]. At the end points, s[0]=s[N]=0.\n-            // Vectors are offset by -1, except the lower diagonal vector which is offset by -2. Layout:\n+            // Vector indices are offset by -1, except for the lower diagonal vector where the offset is -2. Layout of the equation system:\n             // d[0]*s[1]+u[0]*s[2]                                           = b[0]\n             // l[0]*s[1]+d[1]*s[2]+u[1]*s[3]                                 = b[1]\n             //           l[1]*s[2]+d[2]*s[3]+u[2]*s[4]                       = b[2]\n             // Setup right hand side and diagonal.\n             double dquot = (yval[1] - yval[0]) / (xval[1] - xval[0]);\n             for (int i = 0; i < n - 1; i++) {\n-                // TODO avoid recomputing the term\n-                //    (yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1])\n-                // take it from the previous loop pass. Note: the interesting part of performance\n-                // loss is the range check in the array access, not the computation itself.\n                 double dquotNext = \n                     (yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1]);\n                 b[i] = 6.0 * (dquotNext - dquot);\n             }\n             // u[] and l[] (for the upper and lower diagonal respectively) are not\n             // really needed, the computation is folded into the system solving loops.\n-            // Keep this for documentation purposes:\n+            // Keep this for documentation purposes. The computation is folded into\n+            // the loops computing the solution.\n             //double u[] = new double[n - 2]; // upper diagonal\n             //double l[] = new double[n - 2]; // lower diagonal\n             // Set up upper and lower diagonal. Keep the offsets in mind.", "timestamp": 1072538554, "metainfo": ""}