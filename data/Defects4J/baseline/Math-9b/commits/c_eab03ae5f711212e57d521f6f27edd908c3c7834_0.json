{"sha": "eab03ae5f711212e57d521f6f27edd908c3c7834", "log": "Fixed some checkstyle warnings.  Added some unit tests.   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n  * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">bisection algorithm</a>\n  *  for finding zeros of univariate real functions.  This algorithm will find only one zero in the given interval.\n  * The function should be continuous but not necessarily smooth.\n- * @version $Revision: 1.14 $ $Date: 2004/04/27 04:37:58 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/27 16:42:33 $\n  */\n public class BisectionSolver extends UnivariateRealSolverImpl implements Serializable {\n+    \n     /**\n      * Construct a solver for the given function.\n      * @param f function to solve.\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n  * Provide a default implementation for several functions useful to generic\n  * solvers.\n  *  \n- * @version $Revision: 1.11 $ $Date: 2004/04/23 18:20:12 $\n+ * @version $Revision: 1.12 $ $Date: 2004/04/27 16:42:33 $\n  */\n public abstract class UnivariateRealSolverImpl\n     implements UnivariateRealSolver, Serializable {\n      * @param f the function to solve.\n      * @param defaultAbsoluteAccuracy maximum absolue error.\n      * @param defaultMaximalIterationCount maximum number of iterations.\n+     * @throws IllegalArgumentException if function is null.\n      */\n     protected UnivariateRealSolverImpl(\n         UnivariateRealFunction f,\n         double defaultAbsoluteAccuracy) {\n         \n         super();\n+        \n+        if (f == null) {\n+            throw new IllegalArgumentException(\"function can not be null.\");\n+        }\n         \n         this.f = f;\n         this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n  * using method {@link #setCdfAlgorithm}. The deafault is the Cody algorithm \n  * {@link org.apache.commons.math.distribution.NormalCDFPreciseAlgorithm}\n  * \n- * @version $Revision: 1.5 $ $Date: 2004/04/27 04:37:58 $\n+ * @version $Revision: 1.6 $ $Date: 2004/04/27 16:42:34 $\n  */\n public class NormalDistributionImpl extends AbstractContinuousDistribution \n \t\timplements NormalDistribution, Serializable {\n \t * @param sd standard deviation for this distribution\n \t */\n \tpublic void setStandardDeviation(double sd) {\n-\t\tif (sd < 0.0) {\n-\t\t\tthrow new IllegalArgumentException(\"Standard deviation must be\" +\n-\t\t\t\t\"positive or zero.\");\n+\t\tif (sd <= 0.0) {\n+\t\t\tthrow new IllegalArgumentException(\n+                \"Standard deviation must be positive.\");\n \t\t}\t\t\n \t\tstandardDeviation = sd;\n \t}\n \t * @return CDF evaluted at <code>x</code>. \n \t */\n \tpublic double cumulativeProbability(double x) {\n-\t\tdouble z = x;\n-\t\tif(standardDeviation > 0){\n-\t\t\tz = (x - mean) / standardDeviation;\n-\t\t}else{\n-\t\t\treturn 0.0;\n-\t\t}\n+\t\tdouble z = (x - mean) / standardDeviation;\n \t\treturn cdfAlgorithm.cdf(z);\n \t}\n \n \t\t\t\t\t\"p must be between 0.0 and 1.0, inclusive.\");\n \t\t}\n \t\t\n-\t\t//TODO is this ok?\n-\t\tif(standardDeviation == 0){\n-\t\t\treturn mean;\n-\t\t}\n-\t\t\n \t\tdouble r, val;\t\t\n \t\tdouble q = p - 0.5;\n \n \t\t\t\t\t\t   33430.575583588128105) * r + 67265.770927008700853) * r +\n \t\t\t\t\t\t 45921.953931549871457) * r + 13731.693765509461125) * r +\n \t\t\t\t\t   1971.5909503065514427) * r + 133.14166789178437745) * r +\n-\t\t\t\t\t 3.387132872796366608)\n-\t\t\t\t/ (((((((r * 5226.495278852854561 +\n+\t\t\t\t\t 3.387132872796366608) /\n+                     (((((((r * 5226.495278852854561 +\n \t\t\t\t\t\t 28729.085735721942674) * r + 39307.89580009271061) * r +\n \t\t\t\t\t   21213.794301586595867) * r + 5394.1960214247511077) * r +\n \t\t\t\t\t 687.1870074920579083) * r + 42.313330701600911252) * r + 1.);\n-\t\t}else { //closer than 0.075 from {0,1} boundary\n-\t\tif (q > 0) {\n-\t\t\tr = 1 - p;\n-\t\t} else {\n-\t\t\tr = p;\n-\t\t}\n-\t\tr = Math.sqrt(- Math.log(r));\n-\t\tif (r <= 5.0) {\n-\t\t\tr += -1.6;\n-\t\t\tval = (((((((r * 7.7454501427834140764e-4 +\n-\t\t\t\t\t   0.0227238449892691845833) * r + 0.24178072517745061177) *\n-\t\t\t\t\t r + 1.27045825245236838258) * r +\n-\t\t\t\t\t3.64784832476320460504) * r + 5.7694972214606914055) *\n-\t\t\t\t  r + 4.6303378461565452959) * r +\n-\t\t\t\t 1.42343711074968357734)\n-\t\t\t\t/ (((((((r *\n-\t\t\t\t\t\t 1.05075007164441684324e-9 + 5.475938084995344946e-4) *\n-\t\t\t\t\t\tr + 0.0151986665636164571966) * r +\n-\t\t\t\t\t   0.14810397642748007459) * r + 0.68976733498510000455) *\n-\t\t\t\t\t r + 1.6763848301838038494) * r +\n-\t\t\t\t\t2.05319162663775882187) * r + 1.0);\n-\t\t}else { //very close to  0 or 1\n-\t\t\tr += -5.;\n-\t\t\tval = (((((((r * 2.01033439929228813265e-7 +\n-\t\t\t\t\t   2.71155556874348757815e-5) * r +\n-\t\t\t\t\t  0.0012426609473880784386) * r + 0.026532189526576123093) *\n-\t\t\t\t\tr + 0.29656057182850489123) * r +\n-\t\t\t\t   1.7848265399172913358) * r + 5.4637849111641143699) *\n-\t\t\t\t r + 6.6579046435011037772) /\n-\t\t\t\t (((((((r *\n-\t\t\t\t\t\t 2.04426310338993978564e-15 + 1.4215117583164458887e-7)*\n-\t\t\t\t\t\tr + 1.8463183175100546818e-5) * r +\n-\t\t\t\t\t   7.868691311456132591e-4) * r + 0.0148753612908506148525) *\n-\t\t\t\t\t   r + 0.13692988092273580531) * r +\n-\t\t\t\t\t0.59983220655588793769) * r + 1.0);\n-\t\t}\n-\t\tif(q < 0.0)\n-\t\t\tval = -val;\n+\t\t} else { //closer than 0.075 from {0,1} boundary\n+    \t\tif (q > 0) {\n+    \t\t\tr = 1 - p;\n+    \t\t} else {\n+    \t\t\tr = p;\n+    \t\t}\n+    \t\tr = Math.sqrt(- Math.log(r));\n+    \t\tif (r <= 5.0) {\n+    \t\t\tr += -1.6;\n+    \t\t\tval = (((((((r * 7.7454501427834140764e-4 +\n+    \t\t\t\t\t   0.0227238449892691845833) * r + 0.24178072517745061177) *\n+    \t\t\t\t\t r + 1.27045825245236838258) * r +\n+    \t\t\t\t\t3.64784832476320460504) * r + 5.7694972214606914055) *\n+    \t\t\t\t  r + 4.6303378461565452959) * r +\n+    \t\t\t\t 1.42343711074968357734) /\n+                     (((((((r *\n+    \t\t\t\t\t\t 1.05075007164441684324e-9 + 5.475938084995344946e-4) *\n+    \t\t\t\t\t\tr + 0.0151986665636164571966) * r +\n+    \t\t\t\t\t   0.14810397642748007459) * r + 0.68976733498510000455) *\n+    \t\t\t\t\t r + 1.6763848301838038494) * r +\n+    \t\t\t\t\t2.05319162663775882187) * r + 1.0);\n+    \t\t} else { //very close to  0 or 1\n+    \t\t\tr += -5.;\n+    \t\t\tval = (((((((r * 2.01033439929228813265e-7 +\n+    \t\t\t\t\t   2.71155556874348757815e-5) * r +\n+    \t\t\t\t\t  0.0012426609473880784386) * r + 0.026532189526576123093) *\n+    \t\t\t\t\tr + 0.29656057182850489123) * r +\n+    \t\t\t\t   1.7848265399172913358) * r + 5.4637849111641143699) *\n+    \t\t\t\t r + 6.6579046435011037772) /\n+    \t\t\t\t (((((((r *\n+    \t\t\t\t\t\t 2.04426310338993978564e-15 + 1.4215117583164458887e-7)*\n+    \t\t\t\t\t\tr + 1.8463183175100546818e-5) * r +\n+    \t\t\t\t\t   7.868691311456132591e-4) * r + 0.0148753612908506148525) *\n+    \t\t\t\t\t   r + 0.13692988092273580531) * r +\n+    \t\t\t\t\t0.59983220655588793769) * r + 1.0);\n+    \t\t}\n+    \t\tif(q < 0.0) {\n+    \t\t\tval = -val;\n+            }\n \t\t}\n \t\treturn mean + standardDeviation * val;\n \t}\n--- a/src/java/org/apache/commons/math/stat/inference/TestStatisticImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TestStatisticImpl.java\n /**\n  * Implements test statistics defined in the TestStatistic interface.\n  *\n- * @version $Revision: 1.4 $ $Date: 2004/04/12 02:27:49 $\n+ * @version $Revision: 1.5 $ $Date: 2004/04/27 16:42:34 $\n  */\n public class TestStatisticImpl implements TestStatistic, Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 3357444126133491679L;\n-\n-    /**\n-     * Default constructor\n-     */\n-    public TestStatisticImpl() {\n-    }\n \n     /**\n      * @param observed array of observed frequency counts\n             throw new IllegalArgumentException(\"observed, expected array lengths incorrect\");\n         }\n         if ((StatUtils.min(expected) <= 0) || (StatUtils.min(observed) < 0)) {\n-            throw new IllegalArgumentException( \"observed counts must be non-negative,\"\n-                    + \" expected counts must be postive\");\n+            throw new IllegalArgumentException(\n+                \"observed counts must be non-negative expected counts must be postive\");\n         }\n         for (int i = 0; i < observed.length; i++) {\n             dev = (observed[i] - expected[i]);\n      */\n     public double t(double[] sample1, double[] sample2)\n         throws IllegalArgumentException {\n-        if ((sample1 == null) || (sample2 == null\n-                || Math.min(sample1.length, sample2.length) < 5)) {\n+        if ((sample1 == null) || (sample2 == null ||\n+                Math.min(sample1.length, sample2.length) < 5)) {\n             throw new IllegalArgumentException(\"insufficient data for t statistic\");\n         }\n         return t(StatUtils.mean(sample1), StatUtils.mean(sample2), StatUtils.variance(sample1),\n      */\n     public double tTest(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException {\n-        if ((sample1 == null) || (sample2 == null\n-                || Math.min(sample1.length, sample2.length) < 5)) {\n+        if ((sample1 == null) || (sample2 == null ||\n+                Math.min(sample1.length, sample2.length) < 5)) {\n             throw new IllegalArgumentException(\"insufficient data\");\n         }\n         return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2), StatUtils.variance(sample1),\n      */\n     public double t(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)\n         throws IllegalArgumentException {\n-        if ((sampleStats1 == null)\n-            || (sampleStats2 == null\n-                || Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n+        if ((sampleStats1 == null) ||\n+            (sampleStats2 == null ||\n+                Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n             throw new IllegalArgumentException(\"insufficient data for t statistic\");\n         }\n         return t(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),\n      */\n     public double tTest(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)\n         throws IllegalArgumentException, MathException {\n-        if ((sampleStats1 == null) || (sampleStats2 == null\n-                || Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n+        if ((sampleStats1 == null) || (sampleStats2 == null ||\n+                Math.min(sampleStats1.getN(), sampleStats2.getN()) < 5)) {\n             throw new IllegalArgumentException(\"insufficient data for t statistic\");\n         }\n         return tTest(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),\n      * @return approximate degrees of freedom\n      */\n     private double df(double v1, double v2, double n1, double n2) {\n-        return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2)))\n-            / ((v1 * v1) / (n1 * n1 * (n1 - 1d))\n-                + (v2 * v2) / (n2 * n2 * (n2 - 1d)));\n+        return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2))) /\n+            ((v1 * v1) / (n1 * n1 * (n1 - 1d)) + (v2 * v2) /\n+                (n2 * n2 * (n2 - 1d)));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/multivariate/BivariateRegression.java\n+++ b/src/java/org/apache/commons/math/stat/multivariate/BivariateRegression.java\n  * the necessary computations to return the requested statistic.</li>\n  * </ul>\n  *\n- * @version $Revision: 1.1 $ $Date: 2004/04/11 21:52:28 $\n+ * @version $Revision: 1.2 $ $Date: 2004/04/27 16:42:34 $\n  */\n public class BivariateRegression implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -3004689053607543335L;\n \n     /** sum of x values */\n      * Bivariate Normal Distribution</a>.\n      *\n      * @return half-width of 95% confidence interval for the slope estimate\n+     * \n+     * @exception MathException if the confidence interval can not be computed.\n      */\n     public double getSlopeConfidenceInterval() throws MathException {\n         return getSlopeConfidenceInterval(0.05d);\n      *\n      * @param alpha the desired significance level \n      * @return half-width of 95% confidence interval for the slope estimate\n+     * @exception MathException if the confidence interval can not be computed.\n      */\n     public double getSlopeConfidenceInterval(double alpha)\n         throws MathException {\n         if (alpha >= 1 || alpha <= 0) {\n             throw new IllegalArgumentException();\n         }\n-        return getSlopeStdErr()\n-            * getTDistribution().inverseCumulativeProbability(1d - alpha / 2d);\n+        return getSlopeStdErr() *\n+            getTDistribution().inverseCumulativeProbability(1d - alpha / 2d);\n     }\n \n     /**\n      * <code>Double.NaN</code>.\n      *\n      * @return significance level for slope/correlation\n+     * @exception MathException if the significance level can not be computed.\n      */\n     public double getSignificance() throws MathException {\n         return (\n-            1d\n-                - getTDistribution().cumulativeProbability(\n+            1.0 - getTDistribution().cumulativeProbability(\n                     Math.abs(getSlope()) / getSlopeStdErr()));\n     }\n \n--- a/src/java/org/apache/commons/math/stat/univariate/AbstractUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/AbstractUnivariateStatistic.java\n  * Abstract Implementation for UnivariateStatistics.\n  * Provides the ability to extend polymophically so that\n  * indiviual statistics do not need to implement these methods.\n- * @version $Revision: 1.15 $ $Date: 2004/04/12 05:22:11 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/27 16:42:34 $\n  */\n public abstract class AbstractUnivariateStatistic\n     implements UnivariateStatistic {\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[])\n      */\n     public double evaluate(final double[] values) {\n+        test(values, 0, 0);\n         return evaluate(values, 0, values.length);\n     }\n \n         final int begin,\n         final int length) {\n \n+        if (values == null) {\n+            throw new IllegalArgumentException(\"input value array is null\");\n+        }\n+        \n         if (begin < 0) {\n             throw new IllegalArgumentException(\"start position cannot be negative\");\n         }\n             throw new IllegalArgumentException(\"length cannot be negative\");\n         }\n         \n-        if (values == null) {\n-            throw new IllegalArgumentException(\"input value array is null\");\n-        }\n-\n         if (begin + length > values.length) {\n             throw new IllegalArgumentException(\n                 \"begin + length > values.length\");\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.13 $ $Date: 2004/02/21 21:35:15 $\n+ * @version $Revision: 1.14 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class FirstMoment extends AbstractStorelessUnivariateStatistic implements Serializable{\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -803343206421984070L; \n     \n     /** count of values that have been added */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.15 $ $Date: 2004/02/21 21:35:15 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class FourthMoment extends ThirdMoment implements Serializable{\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 4763990447117157611L;\n         \n     /** fourth moment of values that have been added */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n /**\n  * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n  * geometric mean </a> of the available values\n- * @version $Revision: 1.17 $ $Date: 2004/03/04 04:25:09 $\n+ * @version $Revision: 1.18 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class GeometricMean extends SumOfLogs implements Serializable{\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -8178734905303459453L;  \n       \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n  *  <p>\n  *  where n is the number of values, mean is the {@link Mean} and std is the {@link StandardDeviation}\n  * \n- * @version $Revision: 1.18 $ $Date: 2004/03/21 00:22:26 $\n+ * @version $Revision: 1.19 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class Kurtosis extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 2784465764798260919L;  \n       \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n /**\n  * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n  * arithmetic mean </a> of the available values.\n- * @version $Revision: 1.16 $ $Date: 2004/03/04 04:25:09 $\n+ * @version $Revision: 1.17 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class Mean extends AbstractStorelessUnivariateStatistic implements Serializable{\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -1296043746617791564L;    \n     \n     /** first moment of values that have been added */\n         final int begin,\n         final int length) {\n         if (test(values, begin, length)) {\n-            return sum.evaluate(values) / ((double) length);\n+            return sum.evaluate(values, begin, length) / ((double) length);\n         }\n         return Double.NaN;\n     }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.14 $ $Date: 2004/02/21 21:35:15 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class SecondMoment extends FirstMoment implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 3942403127395076445L;  \n       \n     /** second moment of values that have been added */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n  *  <p>\n  *  where n is the number of values, mean is the {@link Mean} and std is the {@link StandardDeviation}\n  * \n- * @version $Revision: 1.19 $ $Date: 2004/03/21 00:23:29 $\n+ * @version $Revision: 1.20 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 7101857578996691352L;    \n     \n     /** */\n      * Returns the value of the statistic based on the values that have been added.\n      * <p>\n      * See {@link Skewness} for the definition used in the computation.\n+     * \n+     * @return the skewness of the available values.\n      */\n     public double getResult() {\n         if (n < moment.n) {\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n \n /**\n  *\n- * @version $Revision: 1.15 $ $Date: 2004/03/04 04:25:09 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class StandardDeviation extends Variance implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 5728716329662425188L;    \n     \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.14 $ $Date: 2004/02/21 21:35:15 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class ThirdMoment extends SecondMoment implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -7818711964045118679L;  \n       \n     /** third moment of values that have been added */\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n  * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n  * vol. 22 no. 9, pp. 526-531.</a>.\n  * \n- * @version $Revision: 1.18 $ $Date: 2004/03/04 04:25:09 $\n+ * @version $Revision: 1.19 $ $Date: 2004/04/27 16:42:30 $\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -9111962718267217978L;  \n       \n     /** SecondMoment is used in incremental calculation of Variance*/\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n /**\n  * Returns the maximum of the available values.\n  * \n- * @version $Revision: 1.15 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/27 16:42:33 $\n  */\n public class Max extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -5593383832225844641L;    \n     \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Median.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Median.java\n  * Returns the <a href=\"http://www.xycoon.com/median_2.htm\">median</a> of the\n  * available values.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/27 16:42:33 $\n  */\n public class Median extends Percentile implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -3961477041290915687L;    \n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n /**\n  * Returns the minimum of the available values.\n  * \n- * @version $Revision: 1.15 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/27 16:42:33 $\n  */\n public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -2941995784909003131L;  \n       \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n  * follows the first estimation procedure presented\n  * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\">here.</a>\n  * \n- * @version $Revision: 1.17 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.18 $ $Date: 2004/04/27 16:42:33 $\n  */\n public class Percentile extends AbstractUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -8091216485095130416L; \n        \n     /** Determines what percentile is computed when evaluate() is activated with no quantile argument */\n      * if the array is empty\n      */\n     public double evaluate(final double[] values, final double p) {\n+        test(values, 0, 0);\n         return evaluate(values, 0, values.length, p);\n     }\n \n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n /**\n  * Returns the product for this collection of values.\n  * \n- * @version $Revision: 1.16 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.17 $ $Date: 2004/04/27 16:42:32 $\n  */\n public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 2824226005990582538L;   \n      \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n /**\n  * The sum of the values that have been added to Univariate.\n  * \n- * @version $Revision: 1.18 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.19 $ $Date: 2004/04/27 16:42:32 $\n  */\n public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -8231831954703408316L;  \n       \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n /**\n  * Returns the sum of the natural logs for this collection of values.\n  * \n- * @version $Revision: 1.16 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.17 $ $Date: 2004/04/27 16:42:32 $\n  */\n public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -370076995648386763L;    \n \n     /** */\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n /**\n  * Returns the sum of the squares of the available values.\n  * \n- * @version $Revision: 1.16 $ $Date: 2004/04/26 19:15:48 $\n+ * @version $Revision: 1.17 $ $Date: 2004/04/27 16:42:32 $\n  */\n public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 1460986908574398008L;  \n       \n     /** */\n--- a/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n  * internal storage array is swapped.\n  * </p>\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/02/21 21:35:16 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/27 16:42:34 $\n  */\n public class ContractableDoubleArray extends ExpandableDoubleArray implements Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -3485529955529426875L; \n    \n     /** The contraction criteria defines the conditions under which this\n--- a/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n  * expand the array 10 times - first from 2 -> 4. then 4 -> 8, 8 -> 16,\n  * and so on until we reach 4096 which is sufficient to hold 3546 elements.\n  * </p>\n- * @version $Revision: 1.13 $ $Date: 2004/02/21 21:35:16 $\n+ * @version $Revision: 1.14 $ $Date: 2004/04/27 16:42:34 $\n  */\n public class ExpandableDoubleArray implements Serializable, DoubleArray {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = -5697417774251632284L;    \n    \n     // TODO: expansionFactor is valuable, by if I only need storage\n--- a/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n  * \"fixed\" in memory, this implementation will never allocate, or copy\n  * the internal storage array to a new array instance.\n  * </p>\n- * @version $Revision: 1.14 $ $Date: 2004/02/21 21:35:16 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/27 16:42:34 $\n  */\n public class FixedDoubleArray implements DoubleArray, Serializable {\n \n+    /** Serializable version identifier */\n     static final long serialVersionUID = 1247853239629842963L;    \n     \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImplTest.java\n+/*\n+ *\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2004/04/27 16:42:32 $\n+ */\n+public class UnivariateRealSolverFactoryImplTest extends TestCase {\n+    \n+    /** solver factory */\n+    private UnivariateRealSolverFactory factory;\n+    \n+    /** function */\n+    private DifferentiableUnivariateRealFunction function;\n+    /**\n+     * @throws java.lang.Exception\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        factory = new UnivariateRealSolverFactoryImpl();\n+        function = new SinFunction();\n+    }\n+    \n+    /**\n+     * @throws java.lang.Exception\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        factory = null;\n+        function = null;\n+        super.tearDown();\n+    }\n+\n+    public void testNewBisectionSolverNull() {\n+        try {\n+            UnivariateRealSolver solver = factory.newBisectionSolver(null);\n+            fail();\n+        } catch(IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testNewBisectionSolverValid() {\n+        UnivariateRealSolver solver = factory.newBisectionSolver(function);\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof BisectionSolver);\n+    }\n+\n+    public void testNewNewtonSolverNull() {\n+        try {\n+            UnivariateRealSolver solver = factory.newNewtonSolver(null);\n+            fail();\n+        } catch(IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testNewNewtonSolverValid() {\n+        UnivariateRealSolver solver = factory.newNewtonSolver(function);\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof NewtonSolver);\n+    }\n+\n+    public void testNewBrentSolverNull() {\n+        try {\n+            UnivariateRealSolver solver = factory.newBrentSolver(null);\n+            fail();\n+        } catch(IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testNewBrentSolverValid() {\n+        UnivariateRealSolver solver = factory.newBrentSolver(function);\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof BrentSolver);\n+    }\n+\n+    public void testNewSecantSolverNull() {\n+        try {\n+            UnivariateRealSolver solver = factory.newSecantSolver(null);\n+            fail();\n+        } catch(IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testNewSecantSolverValid() {\n+        UnivariateRealSolver solver = factory.newSecantSolver(function);\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof SecantSolver);\n+    }\n+}\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.univariate.DescriptiveStatistics;\n \n /**\n  * Test cases for the {@link StatUtils} class.\n- * @version $Revision: 1.14 $ $Date: 2004/04/12 02:27:49 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/27 16:42:31 $\n  */\n \n public final class StatUtilsTest extends TestCase {\n         }\n \n     }\n+    \n+    public void testSumSq() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.sumSq(x);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.sumSq(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);\n+    }\n+    \n+    public void testProduct() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.product(x);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.product(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);\n+    }\n+    \n+    public void testSumLog() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.sumLog(x);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.sumLog(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);\n+    }\n+    \n+    public void testMean() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.mean(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);\n+    }\n+    \n+    public void testVariance() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.variance(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);\n+    }\n+    \n+    public void testMax() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.max(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);\n+    }\n+    \n+    public void testMin() {\n+        double[] x = null;\n+        \n+        try {\n+            StatUtils.min(x, 0, 4);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);\n+    }\n+    \n+    public void testPercentile() {\n+        double[] x = null;\n+        \n+        // test null\n+        try {\n+            StatUtils.percentile(x, .25);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            StatUtils.percentile(x, 0, 4, 0.25);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        // test empty\n+        x = new double[] {};\n+        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);\n+        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);\n+        \n+        // test one\n+        x = new double[] {two};\n+        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);\n+        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);\n+        \n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);\n+        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);\n+    }\n }\n--- a/src/test/org/apache/commons/math/stat/univariate/DescriptiveStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/univariate/DescriptiveStatisticsTest.java\n /**\n  * Test cases for the {@link Univariate} class.\n  *\n- * @version $Revision: 1.1 $ $Date: 2004/04/12 02:27:50 $\n+ * @version $Revision: 1.2 $ $Date: 2004/04/27 16:42:32 $\n  */\n \n public final class DescriptiveStatisticsTest extends TestCase {\n         u2.clear();\n         assertEquals(\"total count\",0,u2.getN(),tolerance);    \n     }       \n-                                   \n+\n+    public void testNewInstanceStringNull() {\n+        try {\n+            DescriptiveStatistics u = DescriptiveStatistics.newInstance((String)null);\n+            fail(\"null is not a valid descriptive statistics class name\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        } catch (Exception ex) {\n+            fail();\n+        }\n+        \n+    }\n+    public void testNewInstanceStringValid() {\n+        try {\n+            DescriptiveStatistics u = DescriptiveStatistics.newInstance(\n+            \"org.apache.commons.math.stat.univariate.DescriptiveStatisticsImpl\");\n+            assertNotNull(u);\n+            assertTrue(u instanceof DescriptiveStatisticsImpl);\n+        } catch (Exception ex) {\n+            fail();\n+        }\n+    }\n+\n+    public void testNewInstanceClassNull() {\n+        try {\n+            DescriptiveStatistics u = DescriptiveStatistics.newInstance((Class)null);\n+            fail(\"null is not a valid descriptive statistics class\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        } catch (Exception ex) {\n+            fail();\n+        }\n+        \n+    }\n+    public void testNewInstanceClassValid() {\n+        try {\n+            DescriptiveStatistics u = DescriptiveStatistics.newInstance(\n+                DescriptiveStatisticsImpl.class);\n+            assertNotNull(u);\n+            assertTrue(u instanceof DescriptiveStatisticsImpl);\n+        } catch (Exception ex) {\n+            fail();\n+        }\n+    }\n }\n \n--- a/src/test/org/apache/commons/math/stat/univariate/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/univariate/StorelessUnivariateStatisticAbstractTest.java\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n- * @version $Revision: 1.11 $ $Date: 2004/02/21 21:35:17 $\n+ * @version $Revision: 1.12 $ $Date: 2004/04/27 16:42:32 $\n  */\n public abstract class StorelessUnivariateStatisticAbstractTest\n     extends UnivariateStatisticAbstractTest {\n     public abstract UnivariateStatistic getUnivariateStatistic();\n \n     public abstract double expectedValue();\n-\n+    \n     public void testIncrementation() throws Exception {\n \n         StorelessUnivariateStatistic statistic =\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/univariate/moment/FirstMomentTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.univariate.moment;\n+\n+import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.univariate.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/04/27 16:42:33 $\n+ */\n+public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected FirstMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public FirstMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+       \n+        if(stat == null)\n+            stat = new FirstMoment();\n+            \n+        return stat;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.mean;\n+    }\n+\n+}", "timestamp": 1083084154, "metainfo": ""}