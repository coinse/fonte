{"sha": "a5de7d5a689569db3233ef4de8fc8443650b7c8c", "log": "Added static direct aggregation method to AggregateSummaryStatistics.  JIRA: MATH-224.  ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n package org.apache.commons.math.stat.descriptive;\n \n import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n \n /**\n  * <p>\n     }\n     \n     /**\n+     * Computes aggregate summary statistics. This method can be used to combine statistics\n+     * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n+     * should contain the same values that would have been obtained by computing a single\n+     * StatisticalSummary over the combined dataset.\n+     * <p>\n+     * Returns null if the collection is empty or null.\n+     * </p>\n+     * \n+     * @param statistics collection of SummaryStatistics to aggregate\n+     * @return summary statistics for the combined dataset\n+     */\n+    public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics) {\n+        if (statistics == null) {\n+            return null;\n+        }\n+        Iterator<SummaryStatistics> iterator = statistics.iterator();\n+        if (!iterator.hasNext()) {\n+            return null;\n+        }\n+        SummaryStatistics current = iterator.next();\n+        long n = current.getN();\n+        double min = current.getMin();\n+        double sum = current.getSum();\n+        double max = current.getMax();\n+        double m2 = current.getSecondMoment();\n+        double mean = current.getMean();\n+        while (iterator.hasNext()) {\n+            current = iterator.next();\n+            if (current.getMin() < min || Double.isNaN(min)) {\n+                min = current.getMin();\n+            }\n+            if (current.getMax() > max || Double.isNaN(max)) {\n+                max = current.getMax();\n+            }\n+            sum += current.getSum();\n+            final double oldN = n;\n+            final long curN = current.getN();\n+            n += curN;\n+            final double meanDiff = current.getMean() - mean;\n+            mean = sum / n;\n+            m2 = m2 + current.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n; \n+        }\n+        final double variance;\n+        if (n == 0) {\n+            variance = Double.NaN;\n+        } else if (n == 1) {\n+            variance = 0d;\n+        } else {\n+            variance = m2 / (n - 1);\n+        }\n+        return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n+    }\n+    \n+    /**\n      * A SummaryStatistics that also forwards all values added to it to a second\n      * {@code SummaryStatistics} for aggregation.\n      *\n         public int hashCode() {\n             return 123 + super.hashCode() + aggregateStatistics.hashCode();\n         }\n-\n     }\n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import java.util.Collection;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.TestUtils;\n+\n \n /**\n  * Test cases for {@link AggregateSummaryStatistics}\n  *\n  */\n public class AggregateSummaryStatisticsTest extends TestCase {\n+    \n+    /**\n+     * Creates and returns a {@code Test} representing all the test cases in this\n+     * class\n+     *\n+     * @return a {@code Test} representing all the test cases in this class\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AggregateSummaryStatisticsTest.class);\n+        suite.setName(\"AggregateSummaryStatistics tests\");\n+        return suite;\n+    }\n     \n     /**\n      * Tests the standard aggregation behavior\n         assertEquals(\"Wrong number of aggregate values\", 8, aggregate.getN());\n         assertEquals(\"Wrong aggregate sum\", 42.0, aggregate.getSum());\n     }\n+    \n+    public void testAggregate() throws Exception {\n+        \n+        // Generate a random sample and random partition\n+        double[] totalSample = generateSample();\n+        double[][] subSamples = generatePartition(totalSample);\n+        int nSamples = subSamples.length;\n+       \n+        // Compute combined stats directly\n+        SummaryStatistics totalStats = new SummaryStatistics();\n+        for (int i = 0; i < totalSample.length; i++) {\n+            totalStats.addValue(totalSample[i]);\n+        }\n+        \n+        // Now compute subsample stats individually and aggregate\n+        SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];\n+        for (int i = 0; i < nSamples; i++) {\n+            subSampleStats[i] = new SummaryStatistics();\n+        }\n+        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n+        for (int i = 0; i < nSamples; i++) {\n+            for (int j = 0; j < subSamples[i].length; j++) { \n+                subSampleStats[i].addValue(subSamples[i][j]);\n+            }\n+            aggregate.add(subSampleStats[i]);\n+        }\n+        \n+        // Compare values\n+        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n+        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n+    }\n+    \n+    /**\n+     * Verifies that two StatisticalSummaryValues report the same values up\n+     * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values\n+     * have to agree exactly, delta is used only for sum, mean, variance, std dev.\n+     */\n+    protected static void assertEquals(StatisticalSummary expected, StatisticalSummaryValues observed, double delta) {\n+        TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0);\n+        TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0);\n+        assertEquals(expected.getN(), observed.getN());\n+        TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta);\n+        TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta);\n+        TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta);\n+        TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta);\n+    }\n \n+    \n     /**\n-     * Creates and returns a {@code Test} representing all the test cases in this\n-     * class\n-     *\n-     * @return a {@code Test} representing all the test cases in this class\n+     * Generates a random sample of double values.\n+     * Sample size is random, between 10 and 100 and values are \n+     * uniformly distributed over [-100, 100].\n+     * \n+     * @return array of random double values\n      */\n-    public static Test suite() {\n-        TestSuite suite = new TestSuite(AggregateSummaryStatisticsTest.class);\n-        suite.setName(\"AggregateSummaryStatistics tests\");\n-        return suite;\n+    private double[] generateSample() {\n+        final RandomData randomData = new RandomDataImpl();\n+        final int sampleSize = randomData.nextInt(10,100);\n+        double[] out = new double[sampleSize];\n+        for (int i = 0; i < out.length; i++) {\n+            out[i] = randomData.nextUniform(-100, 100);\n+        }\n+        return out;     \n+    }\n+    \n+    /**\n+     * Generates a partition of <sample> into up to 5 sequentially selected\n+     * subsamples with randomly selected partition points.\n+     * \n+     * @param sample array to partition\n+     * @return rectangular array with rows = subsamples\n+     */\n+    private double[][] generatePartition(double[] sample) {\n+        final int length = sample.length;\n+        final double[][] out = new double[5][];\n+        final RandomData randomData = new RandomDataImpl();\n+        int cur = 0;\n+        int offset = 0;\n+        int sampleCount = 0;\n+        for (int i = 0; i < 5; i++) {\n+            if (cur == length || offset == length) {\n+                break;\n+            }\n+            final int next = (i == 4 || cur == length - 1) ? length - 1 : randomData.nextInt(cur, length - 1);\n+            final int subLength = next - cur + 1;\n+            out[i] = new double[subLength];\n+            System.arraycopy(sample, offset, out[i], 0, subLength);\n+            cur = next + 1;\n+            sampleCount++;\n+            offset += subLength;\n+        }\n+        if (sampleCount < 5) {\n+            double[][] out2 = new double[sampleCount][];\n+            for (int j = 0; j < sampleCount; j++) {\n+                final int curSize = out[j].length;\n+                out2[j] = new double[curSize];\n+                System.arraycopy(out[j], 0, out2[j], 0, curSize);\n+            }\n+            return out2;\n+        } else {\n+            return out;\n+        }\n     }\n     \n }", "timestamp": 1246935836, "metainfo": ""}