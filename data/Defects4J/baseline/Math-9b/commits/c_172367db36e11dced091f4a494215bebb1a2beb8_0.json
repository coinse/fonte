{"sha": "172367db36e11dced091f4a494215bebb1a2beb8", "log": "fixed functions names (minimizes -> minimize)  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n  * multi-start mode. Multi-start is a traditional way to try to avoid\n  * being trapped in a local minimum and miss the global minimum of a\n  * function. It can also be used to verify the convergence of an\n- * algorithm. The various multi-start-enabled <code>minimizes</code>\n+ * algorithm. The various multi-start-enabled <code>minimize</code>\n  * methods return the best minimum found after all starts, and the\n  * {@link #getMinima getMinima} method can be used to retrieve all\n  * minima from all starts (including the one already provided by the\n- * {@link #minimizes(CostFunction, int, ConvergenceChecker, double[],\n- * double[]) minimizes} method).</p>\n+ * {@link #minimize(CostFunction, int, ConvergenceChecker, double[],\n+ * double[]) minimize} method).</p>\n  *\n  * <p>This class is the base class performing the boilerplate simplex\n  * initialization and handling. The simplex update by itself is\n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n-                                   ConvergenceChecker checker,\n-                                   double[] vertexA, double[] vertexB)\n+    public PointCostPair minimize(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker,\n+                                  double[] vertexA, double[] vertexB)\n     throws CostException, ConvergenceException {\n \n         // set up optimizer\n         setSingleStart();\n \n         // compute minimum\n-        return minimizes(f, maxEvaluations, checker);\n+        return minimize(f, maxEvaluations, checker);\n \n     }\n \n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n-                                   ConvergenceChecker checker,\n-                                   double[] vertexA, double[] vertexB,\n-                                   int starts, long seed)\n+    public PointCostPair minimize(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker,\n+                                  double[] vertexA, double[] vertexB,\n+                                  int starts, long seed)\n     throws CostException, ConvergenceException {\n \n         // set up the simplex traveling around the box\n         setMultiStart(starts, rvg);\n \n         // compute minimum\n-        return minimizes(f, maxEvaluations, checker);\n+        return minimize(f, maxEvaluations, checker);\n \n     }\n \n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n-                                   ConvergenceChecker checker,\n-                                   double[][] vertices)\n+    public PointCostPair minimize(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker,\n+                                  double[][] vertices)\n     throws CostException, ConvergenceException {\n \n         // set up optimizer\n         setSingleStart();\n \n         // compute minimum\n-        return minimizes(f, maxEvaluations, checker);\n+        return minimize(f, maxEvaluations, checker);\n \n     }\n \n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n-                                   ConvergenceChecker checker,\n-                                   double[][] vertices,\n-                                   int starts, long seed)\n+    public PointCostPair minimize(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker,\n+                                  double[][] vertices,\n+                                  int starts, long seed)\n     throws NotPositiveDefiniteMatrixException,\n     CostException, ConvergenceException {\n \n             setMultiStart(starts, rvg);\n \n             // compute minimum\n-            return minimizes(f, maxEvaluations, checker);\n+            return minimize(f, maxEvaluations, checker);\n \n         } catch (DimensionMismatchException dme) {\n             // this should not happen\n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n-                                   ConvergenceChecker checker,\n-                                   RandomVectorGenerator generator)\n+    public PointCostPair minimize(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker,\n+                                  RandomVectorGenerator generator)\n     throws CostException, ConvergenceException {\n \n         // set up optimizer\n         setSingleStart();\n \n         // compute minimum\n-        return minimizes(f, maxEvaluations, checker);\n+        return minimize(f, maxEvaluations, checker);\n \n     }\n \n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n-                                   ConvergenceChecker checker,\n-                                   RandomVectorGenerator generator,\n-                                   int starts)\n+    public PointCostPair minimize(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker,\n+                                  RandomVectorGenerator generator,\n+                                  int starts)\n     throws CostException, ConvergenceException {\n \n         // set up optimizer\n         setMultiStart(starts, generator);\n \n         // compute minimum\n-        return minimizes(f, maxEvaluations, checker);\n+        return minimize(f, maxEvaluations, checker);\n \n     }\n \n     }\n \n     /** Get all the minima found during the last call to {@link\n-     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n-     * minimizes}.\n+     * #minimize(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimize}.\n      * <p>The optimizer stores all the minima found during a set of\n      * restarts when multi-start mode is enabled. The {@link\n-     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n-     * minimizes} method returns the best point only. This method\n+     * #minimize(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimize} method returns the best point only. This method\n      * returns all the points found at the end of each starts, including\n-     * the best one already returned by the {@link #minimizes(CostFunction,\n-     * int, ConvergenceChecker, double[], double[]) minimizes} method.\n+     * the best one already returned by the {@link #minimize(CostFunction,\n+     * int, ConvergenceChecker, double[], double[]) minimize} method.\n      * The array as one element for each start as specified in the constructor\n      * (it has one element only if optimizer has been set up for single-start).</p>\n      * <p>The array containing the minima is ordered with the results\n      * from the runs that did converge first, sorted from lowest to\n      * highest minimum cost, and null elements corresponding to the runs\n      * that did not converge (all elements will be null if the {@link\n-     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n-     * minimizes} method did throw a {@link ConvergenceException\n+     * #minimize(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimize} method did throw a {@link ConvergenceException\n      * ConvergenceException}).</p>\n      * @return array containing the minima, or null if {@link\n-     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n-     * minimizes} has not been called\n+     * #minimize(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimize} has not been called\n      */\n     public PointCostPair[] getMinima() {\n         return (PointCostPair[]) minima.clone();\n      * @exception ConvergenceException if none of the starts did\n      * converge (it is not thrown if at least one start did converge)\n      */\n-    private PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+    private PointCostPair minimize(CostFunction f, int maxEvaluations,\n                                     ConvergenceChecker checker)\n     throws CostException, ConvergenceException {\n \n--- a/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n             }\n       };\n       try {\n-          new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n-                                           new double[] { -0.5 }, new double[] { 0.5 });\n+          new MultiDirectional(1.9, 0.4).minimize(wrong, 10, new ValueChecker(1.0e-3),\n+                                                  new double[] { -0.5 }, new double[] { 0.5 });\n           fail(\"an exception should have been thrown\");\n       } catch (CostException ce) {\n           // expected behavior\n           fail(\"wrong exception caught: \" + e.getMessage());\n       } \n       try {\n-          new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n-                                           new double[] { 0.5 }, new double[] { 1.5 });\n+          new MultiDirectional(1.9, 0.4).minimize(wrong, 10, new ValueChecker(1.0e-3),\n+                                                  new double[] { 0.5 }, new double[] { 1.5 });\n           fail(\"an exception should have been thrown\");\n       } catch (CostException ce) {\n           // expected behavior\n \n     count = 0;\n     PointCostPair optimum =\n-      new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n-                                       new double[][] {\n-                                         { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n-                                       });\n+      new MultiDirectional().minimize(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                                      new double[][] {\n+                                        { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+                                      });\n \n     assertTrue(count > 60);\n     assertTrue(optimum.getCost() > 0.01);\n \n     count = 0;\n     PointCostPair optimum =\n-      new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),\n-                                       new double[] {  3.0, -1.0, 0.0, 1.0 },\n-                                       new double[] {  4.0,  0.0, 1.0, 2.0 });\n+      new MultiDirectional().minimize(powell, 1000, new ValueChecker(1.0e-3),\n+                                      new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                                      new double[] {  4.0,  0.0, 1.0, 2.0 });\n     assertTrue(count > 850);\n     assertTrue(optimum.getCost() > 0.015);\n \n--- a/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n             }\n       };\n       try {\n-          new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n-                                                       new double[] { -0.5 }, new double[] { 0.5 });\n+          new NelderMead(0.9, 1.9, 0.4, 0.6).minimize(wrong, 10, new ValueChecker(1.0e-3),\n+                                                      new double[] { -0.5 }, new double[] { 0.5 });\n           fail(\"an exception should have been thrown\");\n       } catch (CostException ce) {\n           // expected behavior\n           fail(\"wrong exception caught: \" + e.getMessage());\n       } \n       try {\n-          new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n-                                                       new double[] { 0.5 }, new double[] { 1.5 });\n+          new NelderMead(0.9, 1.9, 0.4, 0.6).minimize(wrong, 10, new ValueChecker(1.0e-3),\n+                                                      new double[] { 0.5 }, new double[] { 1.5 });\n           fail(\"an exception should have been thrown\");\n       } catch (CostException ce) {\n           // expected behavior\n     count = 0;\n     NelderMead nm = new NelderMead();\n     try {\n-      nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n-                   new double[][] {\n-                     { -1.2, 1.0 }, { 3.5, -2.3 }, { 0.4, 1.5 }\n-                   }, 1, 5384353l);\n+      nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                  new double[][] {\n+                    { -1.2, 1.0 }, { 3.5, -2.3 }, { 0.4, 1.5 }\n+                  }, 1, 5384353l);\n       fail(\"an exception should have been thrown\");\n     } catch (ConvergenceException ce) {\n         // expected behavior\n \n     count = 0;\n     PointCostPair optimum =\n-        nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n-                     new double[][] {\n-                       { -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 }\n-                     }, 10, 1642738l);\n+        nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                    new double[][] {\n+                      { -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 }\n+                    }, 10, 1642738l);\n \n     assertTrue(count > 700);\n     assertTrue(count < 800);\n                                               new double[] { 0.2, 0.2 },\n                                               new UniformRandomGenerator(rg));\n     optimum =\n-        nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);\n+        nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);\n     assertEquals(0.0, optimum.getCost(), 2.0e-4);\n     optimum =\n-        nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);\n+        nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);\n     assertEquals(0.0, optimum.getCost(), 3.0e-5);\n \n   }\n     count = 0;\n     NelderMead nm = new NelderMead();\n     PointCostPair optimum =\n-      nm.minimizes(powell, 200, new ValueChecker(1.0e-3),\n-                   new double[] {  3.0, -1.0, 0.0, 1.0 },\n-                   new double[] {  4.0,  0.0, 1.0, 2.0 },\n-                   1, 1642738l);\n+      nm.minimize(powell, 200, new ValueChecker(1.0e-3),\n+                  new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                  new double[] {  4.0,  0.0, 1.0, 2.0 },\n+                  1, 1642738l);\n     assertTrue(count < 150);\n     assertEquals(0.0, optimum.getCost(), 6.0e-4);\n     assertEquals(0.0, optimum.getPoint()[0], 0.07);", "timestamp": 1203071508, "metainfo": ""}