{"sha": "d6e8487dad60638a2e0a7dc478964513731e297d", "log": "fixed a forgotten scaling factor in inverse Hadamard transform added integer Hadamard transform note that the integer transform inverse is not always an integer transform  ", "commit": "\n--- a/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n /**\n  * Implements the <a href=\"http://www.archive.chipcenter.com/dsp/DSP000517F1.html\">Fast Hadamard Transform</a> (FHT).\n  * Transformation of an input vector x to the output vector y.\n+ * <p>In addition to transformation of real vectors, the Hadamard transform can\n+ * transform integer vectors into integer vectors. However, this integer transform\n+ * cannot be inverted directly. Due to a scaling factor it may lead to rational results.\n+ * As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational\n+ * vector (1/2, -1/2, 0, 0).</p>\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class FastHadamardTransformer implements RealTransformer {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -710169279109099264L;\n-\n-    /** {@inheritDoc} */\n-    public double[] transform(double f[]) throws IllegalArgumentException {\n+    private static final long serialVersionUID = -720498949613305350L;\n+\n+    /** {@inheritDoc} */\n+    public double[] transform(double f[])\n+        throws IllegalArgumentException {\n         return fht(f);\n     }\n \n     /** {@inheritDoc} */\n     public double[] inversetransform(double f[])\n     throws IllegalArgumentException {\n-        return fht(f);\n-    }\n+        return FastFourierTransformer.scaleArray(fht(f), 1.0 / f.length);\n+   }\n \n     /** {@inheritDoc} */\n     public double[] inversetransform(UnivariateRealFunction f,\n                                      double min, double max, int n)\n         throws FunctionEvaluationException, IllegalArgumentException {\n-        return fht(FastFourierTransformer.sample(f, min, max, n));\n+        final double[] unscaled =\n+            fht(FastFourierTransformer.sample(f, min, max, n));\n+        return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>The integer transform cannot be inverted directly, due to a scaling\n+     * factor it may lead to double results.</p>\n+     * @param f the integer data array to be transformed (signal)\n+     * @return the integer transformed array (spectrum)\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public int[] transform(int f[])\n+        throws IllegalArgumentException {\n+        return fht(f);\n     }\n \n     /**\n      * \n      * @param x input vector\n      * @return y output vector\n-     * @throws IllegalArgumentException\n+     * @exception IllegalArgumentException if input array is not a poer of 2\n      */\n     protected double[] fht(double x[]) throws IllegalArgumentException {\n \n         return yCurrent;\n \n     }\n+    /**\n+     * The FHT (Fast Hadamard Transformation) which uses only subtraction and addition.\n+     * @param x input vector\n+     * @return y output vector\n+     * @exception IllegalArgumentException if input array is not a poer of 2\n+     */\n+    protected int[] fht(int x[]) throws IllegalArgumentException {\n+\n+        // n is the row count of the input vector x\n+        final int n     = x.length;\n+        final int halfN = n / 2;\n+\n+        // n has to be of the form n = 2^p !!\n+        if (!FastFourierTransformer.isPowerOf2(n)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2\",\n+                                                                      new Object[] { n });\n+        }\n+\n+        // Instead of creating a matrix with p+1 columns and n rows\n+        // we will use two single dimension arrays which we will use in an alternating way.\n+        int[] yPrevious = new int[n];\n+        int[] yCurrent  = x.clone();\n+\n+        // iterate from left to right (column)\n+        for (int j = 1; j < n; j <<= 1) {\n+\n+            // switch columns\n+            final int[] yTmp = yCurrent;\n+            yCurrent  = yPrevious;\n+            yPrevious = yTmp;\n+\n+            // iterate from top to bottom (row)\n+            for (int i = 0; i < halfN; ++i) { \n+                // D<sub>top</sub>\n+                // The top part works with addition\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n+            }\n+            for (int i = halfN; i < n; ++i) { \n+                // D<sub>bottom</sub>   \n+                // The bottom part works with subtraction\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n+            }\n+        }\n+\n+        // return the last computed output vector y\n+        return yCurrent;\n+\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+++ b/src/test/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n      * Test of transformer for the a 8-point FHT (means n=8)\n      */\n     public void test8Points() {\n-        checkTransform(new double[] { 1.0, 4.0, -2.0, 3.0, 0.0, 1.0, 4.0, -1.0 },\n-                       new double[] { 10.0, -4.0, 2.0, -4.0, 2.0, -12.0, 6.0, 8.0 });\n+        checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },\n+                       new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });\n     }\n \n     /**\n      * Test of transformer for the a 4-points FHT (means n=4)\n      */\n     public void test4Points() {\n-        checkTransform(new double[] { 1.0, 2.0, 3.0, 4.0 },\n-                       new double[] { 10.0, -2.0, -4.0, 0.0 });\n+        checkAllTransforms(new int[] { 1, 2, 3, 4 },\n+                           new int[] { 10, -2, -4, 0 });\n+    }\n+\n+    /**\n+     * Test the inverse transform of an integer vector is not always an integer vector\n+     */\n+    public void testNoIntInverse() {\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+        double[] x = transformer.inversetransform(new double[] { 0, 1, 0, 1});\n+        assertEquals( 0.5, x[0], 0);\n+        assertEquals(-0.5, x[1], 0);\n+        assertEquals( 0.0, x[2], 0);\n+        assertEquals( 0.0, x[3], 0);\n     }\n \n     /**\n         }\n     }\n \n-    private void checkTransform(double[]x, double[] y) {\n+    private void checkAllTransforms(int[]x, int[] y) {\n+        checkDoubleTransform(x, y);\n+        checkInverseDoubleTransform(x, y);\n+        checkIntTransform(x, y);\n+    }\n+\n+    private void checkDoubleTransform(int[]x, int[] y) {\n         // Initiate the transformer\n         FastHadamardTransformer transformer = new FastHadamardTransformer();\n \n-        // transform input vector x to output vector\n-        double result[] = transformer.transform(x);\n+        // check double transform\n+        double[] dX = new double[x.length];\n+        for (int i = 0; i < dX.length; ++i) {\n+            dX[i] = (double) x[i];\n+        }\n+        double dResult[] = transformer.transform(dX);\n+        for (int i = 0; i < dResult.length; i++) {\n+            // compare computed results to precomputed results\n+            assertEquals((double) y[i], dResult[i]);\n+        }\n+    }\n \n-        for (int i=0;i<result.length;i++) {\n+    private void checkIntTransform(int[]x, int[] y) {\n+        // Initiate the transformer\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+\n+        // check integer transform\n+        int iResult[] = transformer.transform(x);\n+        for (int i = 0; i < iResult.length; i++) {\n             // compare computed results to precomputed results\n-            assertEquals(y[i], result[i]);\n+            assertEquals(y[i], iResult[i]);\n         }\n+\n+    }\n+    \n+    private void checkInverseDoubleTransform(int[]x, int[] y) {\n+        // Initiate the transformer\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+\n+        // check double transform\n+        double[] dY = new double[y.length];\n+        for (int i = 0; i < dY.length; ++i) {\n+            dY[i] = (double) y[i];\n+        }\n+        double dResult[] = transformer.inversetransform(dY);\n+        for (int i = 0; i < dResult.length; i++) {\n+            // compare computed results to precomputed results\n+            assertEquals((double) x[i], dResult[i]);\n+        }\n+\n     }\n     \n }", "timestamp": 1230544578, "metainfo": ""}