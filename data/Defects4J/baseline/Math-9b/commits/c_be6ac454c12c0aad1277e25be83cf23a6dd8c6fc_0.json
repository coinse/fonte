{"sha": "be6ac454c12c0aad1277e25be83cf23a6dd8c6fc", "log": "[MATH-854] fill throws clause for genetics package.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/genetics/AbstractListChromosome.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/AbstractListChromosome.java\n      * @param representation inner representation of the chromosome\n      * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n-    public AbstractListChromosome(final List<T> representation) {\n+    public AbstractListChromosome(final List<T> representation) throws InvalidRepresentationException {\n         checkValidity(representation);\n         this.representation = Collections.unmodifiableList(new ArrayList<T> (representation));\n     }\n     /**\n      * Constructor.\n      * @param representation inner representation of the chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n-    public AbstractListChromosome(final T[] representation) {\n+    public AbstractListChromosome(final T[] representation) throws InvalidRepresentationException {\n         this(Arrays.asList(representation));\n     }\n \n--- a/src/main/java/org/apache/commons/math3/genetics/BinaryChromosome.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/BinaryChromosome.java\n      * @param representation list of {0,1} values representing the chromosome\n      * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n-    public BinaryChromosome(List<Integer> representation) {\n+    public BinaryChromosome(List<Integer> representation) throws InvalidRepresentationException {\n         super(representation);\n     }\n \n      * @param representation array of {0,1} values representing the chromosome\n      * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n-    public BinaryChromosome(Integer[] representation) {\n+    public BinaryChromosome(Integer[] representation) throws InvalidRepresentationException {\n         super(representation);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    protected void checkValidity(List<Integer> chromosomeRepresentation)\n-        throws InvalidRepresentationException {\n+    protected void checkValidity(List<Integer> chromosomeRepresentation) throws InvalidRepresentationException {\n         for (int i : chromosomeRepresentation) {\n             if (i < 0 || i >1) {\n                 throw new InvalidRepresentationException(LocalizedFormats.INVALID_BINARY_DIGIT,\n         return rList;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     protected boolean isSame(Chromosome another) {\n         // type check\n--- a/src/main/java/org/apache/commons/math3/genetics/BinaryMutation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/BinaryMutation.java\n      * @return the mutated chromosome.\n      * @throws MathIllegalArgumentException if <code>original</code> is not an instance of {@link BinaryChromosome}.\n      */\n-    public Chromosome mutate(Chromosome original) {\n+    public Chromosome mutate(Chromosome original) throws MathIllegalArgumentException {\n         if (!(original instanceof BinaryChromosome)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_BINARY_CHROMOSOME);\n         }\n--- a/src/main/java/org/apache/commons/math3/genetics/CrossoverPolicy.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/CrossoverPolicy.java\n  */\n package org.apache.commons.math3.genetics;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+\n /**\n  * Policy used to create a pair of new chromosomes by performing a crossover\n  * operation on a source pair of chromosomes.\n      * @param first the first chromosome.\n      * @param second the second chromosome.\n      * @return the pair of new chromosomes that resulted from the crossover.\n+     * @throws MathIllegalArgumentException if the given chromosomes are not compatible with this {@link CrossoverPolicy}\n      */\n-    ChromosomePair crossover(Chromosome first, Chromosome second);\n+    ChromosomePair crossover(Chromosome first, Chromosome second) throws MathIllegalArgumentException;\n }\n--- a/src/main/java/org/apache/commons/math3/genetics/CycleCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/CycleCrossover.java\n \n     /**\n      * {@inheritDoc}\n+     *\n+     * @throws MathIllegalArgumentException if the chromosomes are not an instance of {@link AbstractListChromosome}\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second)\n+        throws DimensionMismatchException, MathIllegalArgumentException {\n+\n         if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n         }\n      * @return the pair of new chromosomes that resulted from the crossover\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n-    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second) {\n+    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n+        throws DimensionMismatchException {\n+\n         final int length = first.getLength();\n         if (length != second.getLength()) {\n             throw new DimensionMismatchException(second.getLength(), length);\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n import java.util.Collections;\n import java.util.List;\n \n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n      * @param chromosomes list of chromosomes in the population\n      * @param populationLimit maximal size of the population\n      * @param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]\n+     * @throws NullArgumentException if the list of chromosomes is {@code null}\n+     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n+     * @throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n-    public ElitisticListPopulation(final List<Chromosome> chromosomes,\n-                                   final int populationLimit,\n-                                   final double elitismRate) {\n+    public ElitisticListPopulation(final List<Chromosome> chromosomes, final int populationLimit,\n+                                   final double elitismRate)\n+        throws NullArgumentException, NotPositiveException, NumberIsTooLargeException, OutOfRangeException {\n+\n         super(chromosomes, populationLimit);\n         setElitismRate(elitismRate);\n+\n     }\n \n     /**\n      *\n      * @param populationLimit maximal size of the population\n      * @param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]\n+     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n-    public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n+    public ElitisticListPopulation(final int populationLimit, final double elitismRate)\n+        throws NotPositiveException, OutOfRangeException {\n+\n         super(populationLimit);\n         setElitismRate(elitismRate);\n+\n     }\n \n     /**\n      * @param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n-    public void setElitismRate(final double elitismRate) {\n+    public void setElitismRate(final double elitismRate) throws OutOfRangeException {\n         if (elitismRate < 0 || elitismRate > 1) {\n             throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n         }\n--- a/src/main/java/org/apache/commons/math3/genetics/FixedElapsedTime.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/FixedElapsedTime.java\n      * @param maxTime maximum number of seconds generations are allowed to evolve\n      * @throws NumberIsTooSmallException if the provided time is &lt; 0\n      */\n-    public FixedElapsedTime(final long maxTime) {\n+    public FixedElapsedTime(final long maxTime) throws NumberIsTooSmallException {\n         this(maxTime, TimeUnit.SECONDS);\n     }\n \n      * @param unit {@link TimeUnit} of the maxTime argument\n      * @throws NumberIsTooSmallException if the provided time is &lt; 0\n      */\n-    public FixedElapsedTime(final long maxTime, final TimeUnit unit) {\n+    public FixedElapsedTime(final long maxTime, final TimeUnit unit) throws NumberIsTooSmallException {\n         if (maxTime < 0) {\n             throw new NumberIsTooSmallException(maxTime, 0, true);\n         }\n--- a/src/main/java/org/apache/commons/math3/genetics/FixedGenerationCount.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/FixedGenerationCount.java\n      * @param maxGenerations number of generations to evolve\n      * @throws NumberIsTooSmallException if the number of generations is &lt; 1\n      */\n-    public FixedGenerationCount(final int maxGenerations) {\n+    public FixedGenerationCount(final int maxGenerations) throws NumberIsTooSmallException {\n         if (maxGenerations <= 0) {\n             throw new NumberIsTooSmallException(maxGenerations, 1, true);\n         }\n--- a/src/main/java/org/apache/commons/math3/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/GeneticAlgorithm.java\n                             final double crossoverRate,\n                             final MutationPolicy mutationPolicy,\n                             final double mutationRate,\n-                            final SelectionPolicy selectionPolicy) {\n+                            final SelectionPolicy selectionPolicy) throws OutOfRangeException {\n \n         if (crossoverRate < 0 || crossoverRate > 1) {\n             throw new OutOfRangeException(LocalizedFormats.CROSSOVER_RATE,\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n      * @param populationLimit maximal size of the population\n      * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n      */\n-    public ListPopulation(final int populationLimit) {\n+    public ListPopulation(final int populationLimit) throws NotPositiveException {\n         this(Collections.<Chromosome> emptyList(), populationLimit);\n     }\n \n      * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n      * @throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit\n      */\n-    public ListPopulation(final List<Chromosome> chromosomes, final int populationLimit) {\n+    public ListPopulation(final List<Chromosome> chromosomes, final int populationLimit)\n+        throws NullArgumentException, NotPositiveException, NumberIsTooLargeException {\n+\n         if (chromosomes == null) {\n             throw new NullArgumentException();\n         }\n      * @deprecated use {@link #addChromosomes(Collection)} instead\n      */\n     @Deprecated\n-    public void setChromosomes(final List<Chromosome> chromosomes) {\n+    public void setChromosomes(final List<Chromosome> chromosomes)\n+        throws NullArgumentException, NumberIsTooLargeException {\n+\n         if (chromosomes == null) {\n             throw new NullArgumentException();\n         }\n      * Add a {@link Collection} of chromosomes to this {@link Population}.\n      * @param chromosomeColl a {@link Collection} of chromosomes\n      * @throws NumberIsTooLargeException if the population would exceed the population limit when\n-     * adding this chromosome\n-     */\n-    public void addChromosomes(final Collection<Chromosome> chromosomeColl) {\n+     *   adding this chromosome\n+     */\n+    public void addChromosomes(final Collection<Chromosome> chromosomeColl) throws NumberIsTooLargeException {\n         if (chromosomes.size() + chromosomeColl.size() > populationLimit) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE,\n                                                 chromosomes.size(), populationLimit, false);\n      * @throws NumberIsTooLargeException if the population would exceed the {@code populationLimit} after\n      *   adding this chromosome\n      */\n-    public void addChromosome(final Chromosome chromosome) {\n+    public void addChromosome(final Chromosome chromosome) throws NumberIsTooLargeException {\n         if (chromosomes.size() >= populationLimit) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE,\n                                                 chromosomes.size(), populationLimit, false);\n      * @throws NumberIsTooSmallException if the new population size is smaller than the current number\n      *   of chromosomes in the population\n      */\n-    public void setPopulationLimit(final int populationLimit) {\n+    public void setPopulationLimit(final int populationLimit) throws NotPositiveException, NumberIsTooSmallException {\n         if (populationLimit <= 0) {\n             throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n         }\n--- a/src/main/java/org/apache/commons/math3/genetics/MutationPolicy.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/MutationPolicy.java\n  */\n package org.apache.commons.math3.genetics;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+\n /**\n  * Algorithm used to mutate a chromosome.\n  *\n      * Mutate the given chromosome.\n      * @param original the original chromosome.\n      * @return the mutated chromosome.\n+     * @throws MathIllegalArgumentException if the given chromosome is not compatible with this {@link MutationPolicy}\n      */\n-    Chromosome mutate(Chromosome original);\n+    Chromosome mutate(Chromosome original) throws MathIllegalArgumentException;\n }\n--- a/src/main/java/org/apache/commons/math3/genetics/NPointCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/NPointCrossover.java\n      * @param crossoverPoints the number of crossover points\n      * @throws NotStrictlyPositiveException if the number of {@code crossoverPoints} is not strictly positive\n      */\n-    public NPointCrossover(final int crossoverPoints) {\n+    public NPointCrossover(final int crossoverPoints) throws NotStrictlyPositiveException {\n         if (crossoverPoints <= 0) {\n             throw new NotStrictlyPositiveException(crossoverPoints);\n         }\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n-    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second)\n+        throws DimensionMismatchException, MathIllegalArgumentException {\n+\n         if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n         }\n      * @throws NumberIsTooLargeException if the number of crossoverPoints is too large for the actual chromosomes\n      */\n     private ChromosomePair mate(final AbstractListChromosome<T> first,\n-                                final AbstractListChromosome<T> second) {\n+                                final AbstractListChromosome<T> second)\n+        throws DimensionMismatchException, NumberIsTooLargeException {\n+\n         final int length = first.getLength();\n         if (length != second.getLength()) {\n             throw new DimensionMismatchException(second.getLength(), length);\n--- a/src/main/java/org/apache/commons/math3/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/OnePointCrossover.java\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n-    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second)\n+        throws DimensionMismatchException, MathIllegalArgumentException {\n+\n         if (! (first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n         }\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     private ChromosomePair crossover(final AbstractListChromosome<T> first,\n-                                     final AbstractListChromosome<T> second) {\n+                                     final AbstractListChromosome<T> second) throws DimensionMismatchException {\n         final int length = first.getLength();\n         if (length != second.getLength()) {\n             throw new DimensionMismatchException(second.getLength(), length);\n--- a/src/main/java/org/apache/commons/math3/genetics/OrderedCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/OrderedCrossover.java\n \n     /**\n      * {@inheritDoc}\n+     *\n+     * @throws MathIllegalArgumentException iff one of the chromosomes is\n+     *   not an instance of {@link AbstractListChromosome}\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second)\n+        throws DimensionMismatchException, MathIllegalArgumentException {\n+\n         if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n         }\n      * @return the pair of new chromosomes that resulted from the crossover\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n-    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second) {\n+    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n+        throws DimensionMismatchException {\n+\n         final int length = first.getLength();\n         if (length != second.getLength()) {\n             throw new DimensionMismatchException(second.getLength(), length);\n--- a/src/main/java/org/apache/commons/math3/genetics/Population.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/Population.java\n  * limitations under the License.\n  */\n package org.apache.commons.math3.genetics;\n+\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n \n \n /**\n     /**\n      * Add the given chromosome to the population.\n      * @param chromosome the chromosome to add.\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException if the population would exceed\n-     *   the population limit when adding this chromosome\n+     * @throws NumberIsTooLargeException if the population would exceed the population limit when adding\n+     *   this chromosome\n      */\n-    void addChromosome(Chromosome chromosome);\n+    void addChromosome(Chromosome chromosome) throws NumberIsTooLargeException;\n \n     /**\n      * Access the fittest chromosome in this population.\n--- a/src/main/java/org/apache/commons/math3/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/RandomKey.java\n      * Constructor.\n      *\n      * @param representation list of [0,1] values representing the permutation\n-     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n-     *   a valid chromosome\n-     */\n-    public RandomKey(final List<Double> representation) {\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n+     */\n+    public RandomKey(final List<Double> representation) throws InvalidRepresentationException {\n         super(representation);\n         // store the sorted representation\n         List<Double> sortedRepr = new ArrayList<Double> (getRepresentation());\n      * Constructor.\n      *\n      * @param representation array of [0,1] values representing the permutation\n-     */\n-    public RandomKey(final Double[] representation) {\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n+     */\n+    public RandomKey(final Double[] representation) throws InvalidRepresentationException {\n         this(Arrays.asList(representation));\n     }\n \n      *   <code>representation</code> or <code>sortedRepr</code> lists are not equal\n      */\n     private static <S> List<S> decodeGeneric(final List<S> sequence, List<Double> representation,\n-                                             final List<Double> sortedRepr) {\n+                                             final List<Double> sortedRepr)\n+        throws DimensionMismatchException {\n+\n         int l = sequence.size();\n \n         // the size of the three lists must be equal\n      */\n     public static <S> List<Double> comparatorPermutation(final List<S> data,\n                                                          final Comparator<S> comparator) {\n-        List<S> sortedData = new ArrayList<S> (data);\n+        List<S> sortedData = new ArrayList<S>(data);\n         Collections.sort(sortedData, comparator);\n \n         return inducedPermutation(data, sortedData);\n      *   <code>originalData</code> lists contain different data\n      */\n     public static <S> List<Double> inducedPermutation(final List<S> originalData,\n-                                                      final List<S> permutedData) {\n+                                                      final List<S> permutedData)\n+        throws DimensionMismatchException, MathIllegalArgumentException {\n \n         if (originalData.size() != permutedData.size()) {\n             throw new DimensionMismatchException(permutedData.size(), originalData.size());\n--- a/src/main/java/org/apache/commons/math3/genetics/RandomKeyMutation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/RandomKeyMutation.java\n      *\n      * @throws MathIllegalArgumentException if <code>original</code> is not a {@link RandomKey} instance\n      */\n-    public Chromosome mutate(final Chromosome original) {\n+    public Chromosome mutate(final Chromosome original) throws MathIllegalArgumentException {\n         if (!(original instanceof RandomKey<?>)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS,\n                                                    original.getClass().getSimpleName());\n--- a/src/main/java/org/apache/commons/math3/genetics/SelectionPolicy.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/SelectionPolicy.java\n  */\n package org.apache.commons.math3.genetics;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+\n /**\n  * Algorithm used to select a chromosome pair from a population.\n  *\n      * Select two chromosomes from the population.\n      * @param population the population from which the chromosomes are choosen.\n      * @return the selected chromosomes.\n+     * @throws MathIllegalArgumentException if the population is not compatible with this {@link SelectionPolicy}\n      */\n-    ChromosomePair select(Population population);\n+    ChromosomePair select(Population population) throws MathIllegalArgumentException;\n }\n--- a/src/main/java/org/apache/commons/math3/genetics/TournamentSelection.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/TournamentSelection.java\n      *\n      * @param population the population from which the chromosomes are chosen.\n      * @return the selected chromosomes.\n+     * @throws MathIllegalArgumentException if the tournament arity is bigger than the population size\n      */\n-    public ChromosomePair select(final Population population) {\n+    public ChromosomePair select(final Population population) throws MathIllegalArgumentException {\n         return new ChromosomePair(tournament((ListPopulation) population),\n                                   tournament((ListPopulation) population));\n     }\n      * @return the selected chromosome.\n      * @throws MathIllegalArgumentException if the tournament arity is bigger than the population size\n      */\n-    private Chromosome tournament(final ListPopulation population) {\n+    private Chromosome tournament(final ListPopulation population) throws MathIllegalArgumentException {\n         if (population.getPopulationSize() < this.arity) {\n             throw new MathIllegalArgumentException(LocalizedFormats.TOO_LARGE_TOURNAMENT_ARITY,\n                                                    arity, population.getPopulationSize());\n--- a/src/main/java/org/apache/commons/math3/genetics/UniformCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/UniformCrossover.java\n      * @param ratio the mixing ratio\n      * @throws OutOfRangeException if the mixing ratio is outside the [0, 1] range\n      */\n-    public UniformCrossover(final double ratio) {\n+    public UniformCrossover(final double ratio) throws OutOfRangeException {\n         if (ratio < 0.0d || ratio > 1.0d) {\n             throw new OutOfRangeException(LocalizedFormats.CROSSOVER_RATE, ratio, 0.0d, 1.0d);\n         }\n \n     /**\n      * {@inheritDoc}\n+     *\n+     * @throws MathIllegalArgumentException iff one of the chromosomes is\n+     *   not an instance of {@link AbstractListChromosome}\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second)\n+        throws DimensionMismatchException, MathIllegalArgumentException {\n+\n         if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n         }\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     private ChromosomePair mate(final AbstractListChromosome<T> first,\n-                                final AbstractListChromosome<T> second) {\n+                                final AbstractListChromosome<T> second) throws DimensionMismatchException {\n         final int length = first.getLength();\n         if (length != second.getLength()) {\n             throw new DimensionMismatchException(second.getLength(), length);", "timestamp": 1347811557, "metainfo": ""}