{"sha": "5ef7821b1cda166aee88071f7a9356584d167c57", "log": "MATH-707 Class name change:   \"MultiStartDifferentiableMultivariateVectorialOptimizer\" -> \"DifferentiableMultivariateVectorMultiStartOptimizer\"   \"DifferentiableMultivariateVectorialOptimizer\" -> \"DifferentiableMultivariateVectorOptimizer\"   \"BaseMultiStartMultivariateVectorialOptimizer\" -> \"BaseMultivariateVectorMultiStartOptimizer\"   \"BaseMultivariateVectorialOptimizer\" -> \"BaseMultivariateVectorOptimizer\"   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorMultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.analysis.MultivariateVectorFunction;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Base class for all implementations of a multi-start optimizer.\n+ *\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * {@link DifferentiableMultivariateVectorMultiStartOptimizer}.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class BaseMultivariateVectorMultiStartOptimizer<FUNC extends MultivariateVectorFunction>\n+    implements BaseMultivariateVectorOptimizer<FUNC> {\n+    /** Underlying classical optimizer. */\n+    private final BaseMultivariateVectorOptimizer<FUNC> optimizer;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+    /** Number of starts to go. */\n+    private int starts;\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+    /** Found optima. */\n+    private VectorialPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform. If {@code starts == 1},\n+     * the {@link #optimize(int,MultivariateVectorFunction,double[],double[],double[])\n+     * optimize} will return the same solution as {@code optimizer} would.\n+     * @param generator Random vector generator to use for restarts.\n+     * @throws NullArgumentException if {@code optimizer} or {@code generator}\n+     * is {@code null}.\n+     * @throws NotStrictlyPositiveException if {@code starts < 1}.\n+     */\n+    protected BaseMultivariateVectorMultiStartOptimizer(final BaseMultivariateVectorOptimizer<FUNC> optimizer,\n+                                                           final int starts,\n+                                                           final RandomVectorGenerator generator) {\n+        if (optimizer == null ||\n+            generator == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (starts < 1) {\n+            throw new NotStrictlyPositiveException(starts);\n+        }\n+\n+        this.optimizer = optimizer;\n+        this.starts = starts;\n+        this.generator = generator;\n+    }\n+\n+    /**\n+     * Get all the optima found during the last call to {@link\n+     * #optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize}.\n+     * The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(int,MultivariateVectorFunction,double[],double[],double[])\n+     * optimize} method returns the best point only. This method\n+     * returns all the points found at the end of each starts, including\n+     * the best one already returned by the {@link\n+     * #optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} method.\n+     * <br/>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e. in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link\n+     * #optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} method did\n+     * throw a {@link ConvergenceException}). This also means that if\n+     * the first element is not {@code null}, it is the best point found\n+     * across all starts.\n+     *\n+     * @return array containing the optima\n+     * @throws MathIllegalStateException if {@link\n+     * #optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} has not been\n+     * called.\n+     */\n+    public VectorialPointValuePair[] getOptima() {\n+        if (optima == null) {\n+            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public VectorialPointValuePair optimize(int maxEval, final FUNC f,\n+                                            double[] target, double[] weights,\n+                                            double[] startPoint) {\n+        maxEvaluations = maxEval;\n+        RuntimeException lastException = null;\n+        optima = new VectorialPointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // Multi-start loop.\n+        for (int i = 0; i < starts; ++i) {\n+\n+            // CHECKSTYLE: stop IllegalCatch\n+            try {\n+                optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, target, weights,\n+                                               i == 0 ? startPoint : generator.nextVector());\n+            } catch (ConvergenceException oe) {\n+                optima[i] = null;\n+            } catch (RuntimeException mue) {\n+                lastException = mue;\n+                optima[i] = null;\n+            }\n+            // CHECKSTYLE: resume IllegalCatch\n+\n+            totalEvaluations += optimizer.getEvaluations();\n+        }\n+\n+        sortPairs(target, weights);\n+\n+        if (optima[0] == null) {\n+            throw lastException; // cannot be null if starts >=1\n+        }\n+\n+        // Return the found point given the best objective function value.\n+        return optima[0];\n+    }\n+\n+    /**\n+     * Sort the optima from best to worst, followed by {@code null} elements.\n+     *\n+     * @param target Target value for the objective functions at optimum.\n+     * @param weights Weights for the least-squares cost computation.\n+     */\n+    private void sortPairs(final double[] target,\n+                           final double[] weights) {\n+        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n+                public int compare(final VectorialPointValuePair o1,\n+                                   final VectorialPointValuePair o2) {\n+                    if (o1 == null) {\n+                        return (o2 == null) ? 0 : 1;\n+                    } else if (o2 == null) {\n+                        return -1;\n+                    }\n+                    return Double.compare(weightedResidual(o1), weightedResidual(o2));\n+                }\n+                private double weightedResidual(final VectorialPointValuePair pv) {\n+                    final double[] value = pv.getValueRef();\n+                    double sum = 0;\n+                    for (int i = 0; i < value.length; ++i) {\n+                        final double ri = value[i] - target[i];\n+                        sum += weights[i] * ri * ri;\n+                    }\n+                    return sum;\n+                }\n+            });\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.MultivariateVectorFunction;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface BaseMultivariateVectorOptimizer<FUNC extends MultivariateVectorFunction>\n+    extends BaseOptimizer<VectorialPointValuePair> {\n+    /**\n+     * Optimize an objective function.\n+     * Optimization is considered to be a weighted least-squares minimization.\n+     * The cost function to be minimized is\n+     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n+     *\n+     * @param f Objective function.\n+     * @param target Target value for the objective functions at optimum.\n+     * @param weight Weights for the least squares cost computation.\n+     * @param startPoint Start point for optimization.\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the start point dimension is wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * any argument is {@code null}.\n+     */\n+    VectorialPointValuePair optimize(int maxEval, FUNC f, double[] target,\n+                                     double[] weight, double[] startPoint);\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n  * <ul>\n  *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer}</li>\n  *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer}</li>\n- *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer}</li>\n  *  <li>{@link org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer}</li>\n  * </ul>\n  *\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n  * maximize or minimize} an objective function.\n  *\n  * @see MultivariateRealOptimizer\n- * @see DifferentiableMultivariateVectorialOptimizer\n+ * @see DifferentiableMultivariateVectorOptimizer\n  *\n  * @version $Id$\n  * @since 2.0\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorMultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Special implementation of the {@link DifferentiableMultivariateVectorOptimizer}\n+ * interface addind multi-start features to an existing optimizer.\n+ *\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ *\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public class DifferentiableMultivariateVectorMultiStartOptimizer\n+    extends BaseMultivariateVectorMultiStartOptimizer<DifferentiableMultivariateVectorFunction>\n+    implements DifferentiableMultivariateVectorOptimizer {\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n+     */\n+    public DifferentiableMultivariateVectorMultiStartOptimizer(\n+                final DifferentiableMultivariateVectorOptimizer optimizer,\n+                final int starts,\n+                final RandomVectorGenerator generator) {\n+        super(optimizer, starts, generator);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction;\n+\n+/**\n+ * This interface represents an optimization algorithm for\n+ * {@link DifferentiableMultivariateVectorFunction vectorial differentiable\n+ * objective functions}.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface DifferentiableMultivariateVectorOptimizer\n+    extends BaseMultivariateVectorOptimizer<DifferentiableMultivariateVectorFunction> {}\n--- a/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n  * maximize or minimize} an objective function.</p>\n  *\n  * @see DifferentiableMultivariateRealOptimizer\n- * @see DifferentiableMultivariateVectorialOptimizer\n+ * @see DifferentiableMultivariateVectorOptimizer\n  * @version $Id$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n package org.apache.commons.math.optimization;\n \n /** This interface specifies how to check if a {@link\n- * DifferentiableMultivariateVectorialOptimizer optimization algorithm} has converged.\n+ * DifferentiableMultivariateVectorOptimizer optimization algorithm} has converged.\n  *\n  * <p>Deciding if convergence has been reached is a problem-dependent issue. The\n  * user should provide a class implementing this interface to allow the optimization\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math.optimization.BaseMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.BaseMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n  * @since 3.0\n  */\n public abstract class BaseAbstractVectorialOptimizer<FUNC extends MultivariateVectorFunction>\n-    implements BaseMultivariateVectorialOptimizer<FUNC> {\n+    implements BaseMultivariateVectorOptimizer<FUNC> {\n     /** Evaluations counter. */\n     protected final Incrementor evaluations = new Incrementor();\n     /** Convergence checker. */\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction;\n import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /** Fitter for parametric univariate real functions y = f(x).\n  */\n public class CurveFitter {\n     /** Optimizer to use for the fitting. */\n-    private final DifferentiableMultivariateVectorialOptimizer optimizer;\n+    private final DifferentiableMultivariateVectorOptimizer optimizer;\n     /** Observed points. */\n     private final List<WeightedObservedPoint> observations;\n \n     /** Simple constructor.\n      * @param optimizer optimizer to use for the fitting\n      */\n-    public CurveFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+    public CurveFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n         this.optimizer = optimizer;\n         observations = new ArrayList<WeightedObservedPoint>();\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n import org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n \n      *\n      * @param optimizer Optimizer to use for the fitting.\n      */\n-    public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n+    public GaussianFitter(DifferentiableMultivariateVectorOptimizer optimizer) {\n         super(optimizer);\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math.analysis.function.HarmonicOscillator;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n      * Simple constructor.\n      * @param optimizer Optimizer to use for the fitting.\n      */\n-    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+    public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n         super(optimizer);\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n \n /** This class implements a curve fitting specialized for polynomials.\n  * <p>Polynomial fitting is a very simple case of curve fitting. The\n      * @param degree Maximal degree of the polynomial.\n      * @param optimizer Optimizer to use for the fitting.\n      */\n-    public PolynomialFitter(int degree, final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+    public PolynomialFitter(int degree, final DifferentiableMultivariateVectorOptimizer optimizer) {\n         super(optimizer);\n         this.degree = degree;\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer;\n import org.apache.commons.math.util.FastMath;\n  */\n public abstract class AbstractLeastSquaresOptimizer\n     extends BaseAbstractVectorialOptimizer<DifferentiableMultivariateVectorFunction>\n-    implements DifferentiableMultivariateVectorialOptimizer {\n+    implements DifferentiableMultivariateVectorOptimizer {\n     /** Singularity threshold (cf. {@link #getCovariances(double)}). */\n     private static final double DEFAULT_SINGULARITY_THRESHOLD = 1e-14;\n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/package-info.java\n+++ b/src/main/java/org/apache/commons/math/optimization/package-info.java\n  *      DifferentiableMultivariateRealOptimizer} for {@link\n  *      org.apache.commons.math.analysis.DifferentiableMultivariateFunction\n  *      differentiable multivariate real functions}</li>\n- *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer\n- *      DifferentiableMultivariateVectorialOptimizer} for {@link\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer\n+ *      DifferentiableMultivariateVectorOptimizer} for {@link\n  *      org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction\n  *      differentiable multivariate vectorial functions}</li>\n  * </ul>\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorMultiStartOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class DifferentiableMultivariateVectorMultiStartOptimizerTest {\n+\n+    @Test\n+    public void testTrivial() {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        DifferentiableMultivariateVectorOptimizer underlyingOptimizer =\n+            new GaussNewtonOptimizer(true,\n+                                     new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(16069223052l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));\n+        DifferentiableMultivariateVectorMultiStartOptimizer optimizer =\n+            new DifferentiableMultivariateVectorMultiStartOptimizer(underlyingOptimizer,\n+                                                                       10, generator);\n+\n+        // no optima before first optimization attempt\n+        try {\n+            optimizer.getOptima();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalStateException ise) {\n+            // expected\n+        }\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+        VectorialPointValuePair[] optima = optimizer.getOptima();\n+        Assert.assertEquals(10, optima.length);\n+        for (int i = 0; i < optima.length; ++i) {\n+            Assert.assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);\n+            Assert.assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);\n+        }\n+        Assert.assertTrue(optimizer.getEvaluations() > 20);\n+        Assert.assertTrue(optimizer.getEvaluations() < 50);\n+        Assert.assertEquals(100, optimizer.getMaxEvaluations());\n+    }\n+\n+    @Test(expected=TestException.class)\n+    public void testNoOptimum() {\n+        DifferentiableMultivariateVectorOptimizer underlyingOptimizer =\n+            new GaussNewtonOptimizer(true,\n+                                     new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(12373523445l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));\n+        DifferentiableMultivariateVectorMultiStartOptimizer optimizer =\n+            new DifferentiableMultivariateVectorMultiStartOptimizer(underlyingOptimizer,\n+                                                                       10, generator);\n+        optimizer.optimize(100, new DifferentiableMultivariateVectorFunction() {\n+                public MultivariateMatrixFunction jacobian() {\n+                    return null;\n+                }\n+                public double[] value(double[] point) {\n+                    throw new TestException();\n+                }\n+            }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });\n+    }\n+\n+    private static class TestException extends RuntimeException {\n+        private static final long serialVersionUID = -7809988995389067683L;\n+    }\n+\n+    private static class LinearProblem implements DifferentiableMultivariateVectorFunction {\n+\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new BlockRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        public double[] value(double[] variables) {\n+            return factors.operate(variables);\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n \n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.exception.ConvergenceException;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n     @Test\n     public void testRedundantUnsolvable() {\n         // Gauss-Newton should not be able to solve redundant information\n-        DifferentiableMultivariateVectorialOptimizer optimizer =\n+        DifferentiableMultivariateVectorOptimizer optimizer =\n             new GaussNewtonOptimizer(true);\n         checkUnsolvableProblem(optimizer, false);\n     }\n \n-    private void checkUnsolvableProblem(DifferentiableMultivariateVectorialOptimizer optimizer,\n+    private void checkUnsolvableProblem(DifferentiableMultivariateVectorOptimizer optimizer,\n                                         boolean solvable) {\n         Random randomizer = new Random(1248788532l);\n         for (int degree = 0; degree < 10; ++degree) {", "timestamp": 1323433330, "metainfo": ""}