{"sha": "c422db8ac25e93712db663f1e9701d44458a90e1", "log": "Removed too aggressive checks for impossible errors.  The checks were added recently as part of throws declaration updates. In theses cases, the exception cannot be triggered. No throws declarations are needed and in fact wrapping the impossible exceptions in MathInternalError is simply too much.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n import java.util.List;\n \n import org.apache.commons.math3.FieldElement;\n-import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathUtils;\n-import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Representation of a Complex number, i.e. a number which has both a\n      * @since 1.2\n      */\n     public Complex acos() {\n-        try {\n-            if (isNaN) {\n-                return NaN;\n-            }\n-\n-            return this.add(this.sqrt1z().multiply(I)).log()\n-                    .multiply(I.negate());\n-        } catch (NullArgumentException e) {\n-            // this should never happen as intermediat results are not null\n-            throw new MathInternalError(e);\n-        }\n+        if (isNaN) {\n+            return NaN;\n+        }\n+\n+        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n     }\n \n     /**\n      * @since 1.2\n      */\n     public Complex asin() {\n-        try {\n-            if (isNaN) {\n-                return NaN;\n-            }\n-\n-            return sqrt1z().add(this.multiply(I)).log()\n-                    .multiply(I.negate());\n-        } catch (NullArgumentException e) {\n-            // this should never happen as intermediat results are not null\n-            throw new MathInternalError(e);\n-        }\n+        if (isNaN) {\n+            return NaN;\n+        }\n+\n+        return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n     }\n \n     /**\n      * @since 1.2\n      */\n     public Complex atan() {\n-        try {\n-            if (isNaN) {\n-                return NaN;\n-            }\n-\n-            return this.add(I).divide(I.subtract(this)).log()\n-                    .multiply(I.divide(createComplex(2.0, 0.0)));\n-        } catch (NullArgumentException e) {\n-            // this should never happen as intermediat results are not null\n-            throw new MathInternalError(e);\n-        }\n+        if (isNaN) {\n+            return NaN;\n+        }\n+\n+        return this.add(I).divide(I.subtract(this)).log()\n+                .multiply(I.divide(createComplex(2.0, 0.0)));\n     }\n \n     /**\n      * @since 1.2\n      */\n     public Complex sqrt1z() {\n-        try {\n-            return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n-        } catch (NullArgumentException e) {\n-            // this should never happen as intermediat results are not null\n-            throw new MathInternalError(e);\n-        }\n+        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/complex/ComplexFormat.java\n+++ b/src/main/java/org/apache/commons/math3/complex/ComplexFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MathParseException;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NullArgumentException;\n      * @param pos On input: an alignment field, if desired. On output: the\n      * offsets of the alignment field.\n      * @return the value passed in as toAppendTo.\n-     * @throws MathInternalError if {@code absIm} is not positive.\n      */\n     private StringBuffer formatImaginary(double absIm,\n                                          StringBuffer toAppendTo,\n                                          FieldPosition pos) {\n-        if (absIm < 0) {\n-            throw new MathInternalError();\n-        }\n-\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n      * @return the complex format specific to the given locale.\n      */\n     public static ComplexFormat getInstance(Locale locale) {\n-        try {\n-            NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n-            return new ComplexFormat(f);\n-        } catch (NullArgumentException nae) {\n-            // this should never happen\n-            throw new MathInternalError(nae);\n-        }\n+        NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n+        return new ComplexFormat(f);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n  */\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n-import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.geometry.Vector;\n import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        try {\n-            return new Line(zero, zero.subtract(direction));\n-        } catch (MathIllegalArgumentException miae) {\n-            // this should never happen has the instance was already built without error\n-            throw new MathInternalError(miae);\n-        }\n+        return new Line(zero, zero.subtract(direction));\n     }\n \n     /** Get the normalized direction vector.\n      * @return true if the lines are similar\n      */\n     public boolean isSimilarTo(final Line line) {\n-        try {\n-            final double angle = Vector3D.angle(direction, line.direction);\n-            return ((angle < 1.0e-10) || (angle > (FastMath.PI - 1.0e-10))) && contains(line.zero);\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as directions are non-zero vectors\n-            throw new MathInternalError(mae);\n-        }\n+        final double angle = Vector3D.angle(direction, line.direction);\n+        return ((angle < 1.0e-10) || (angle > (FastMath.PI - 1.0e-10))) && contains(line.zero);\n     }\n \n     /** Check if the instance contains a point.\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n import org.apache.commons.math3.exception.MathArithmeticException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.geometry.Vector;\n import org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\n     /** Reset the plane frame.\n      */\n     private void setFrame() {\n-        try {\n-            origin = new Vector3D(-originOffset, w);\n-            u = w.orthogonal();\n-            v = Vector3D.crossProduct(w, u);\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as w is built to be non-zero\n-            throw new MathInternalError(mae);\n-        }\n+        origin = new Vector3D(-originOffset, w);\n+        u = w.orthogonal();\n+        v = Vector3D.crossProduct(w, u);\n     }\n \n     /** Get the origin point of the plane frame.\n      * @return true if the planes are similar\n      */\n     public boolean isSimilarTo(final Plane plane) {\n-        try {\n-            final double angle = Vector3D.angle(w, plane.w);\n-            return ((angle < 1.0e-10) && (FastMath.abs(originOffset - plane.originOffset) < 1.0e-10)) ||\n-                    ((angle > (FastMath.PI - 1.0e-10)) && (FastMath.abs(originOffset + plane.originOffset) < 1.0e-10));\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as w vectors are built to be non-zero\n-            throw new MathInternalError(mae);\n-        }\n+        final double angle = Vector3D.angle(w, plane.w);\n+        return ((angle < 1.0e-10) && (FastMath.abs(originOffset - plane.originOffset) < 1.0e-10)) ||\n+               ((angle > (FastMath.PI - 1.0e-10)) && (FastMath.abs(originOffset + plane.originOffset) < 1.0e-10));\n     }\n \n     /** Rotate the plane around the specified point.\n      */\n     public Plane rotate(final Vector3D center, final Rotation rotation) {\n \n-        try {\n-            final Vector3D delta = origin.subtract(center);\n-            final Plane plane = new Plane(center.add(rotation.applyTo(delta)),\n-                                          rotation.applyTo(w));\n-\n-            // make sure the frame is transformed as desired\n-            plane.u = rotation.applyTo(u);\n-            plane.v = rotation.applyTo(v);\n-\n-            return plane;\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as w vector is built to be non-zero\n-            throw new MathInternalError(mae);\n-        }\n+        final Vector3D delta = origin.subtract(center);\n+        final Plane plane = new Plane(center.add(rotation.applyTo(delta)),\n+                                      rotation.applyTo(w));\n+\n+        // make sure the frame is transformed as desired\n+        plane.u = rotation.applyTo(u);\n+        plane.v = rotation.applyTo(v);\n+\n+        return plane;\n \n     }\n \n      */\n     public Plane translate(final Vector3D translation) {\n \n-        try {\n-            final Plane plane = new Plane(origin.add(translation), w);\n-\n-            // make sure the frame is transformed as desired\n-            plane.u = u;\n-            plane.v = v;\n-\n-            return plane;\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as w vector is built to be non-zero\n-            throw new MathInternalError(mae);\n-        }\n+        final Plane plane = new Plane(origin.add(translation), w);\n+\n+        // make sure the frame is transformed as desired\n+        plane.u = u;\n+        plane.v = v;\n+\n+        return plane;\n \n     }\n \n      * other plane (really a {@link Line Line} instance)\n      */\n     public Line intersection(final Plane other) {\n-        try {\n-            final Vector3D direction = Vector3D.crossProduct(w, other.w);\n-            if (direction.getNorm() < 1.0e-10) {\n-                return null;\n-            }\n-            final Vector3D point = intersection(this, other, new Plane(direction));\n-            return new Line(point, point.add(direction));\n-        } catch (MathIllegalArgumentException miae) {\n-            // this should never happen as direction has been checked to have non-zero norm\n-            throw new MathInternalError(miae);\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as direction has been checked to have non-zero norm\n-            throw new MathInternalError(mae);\n+        final Vector3D direction = Vector3D.crossProduct(w, other.w);\n+        if (direction.getNorm() < 1.0e-10) {\n+            return null;\n         }\n+        final Vector3D point = intersection(this, other, new Plane(direction));\n+        return new Line(point, point.add(direction));\n     }\n \n     /** Get the intersection point of three planes.\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n import java.awt.geom.AffineTransform;\n import java.util.Collection;\n \n-import org.apache.commons.math3.exception.MathArithmeticException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.geometry.Vector;\n import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math3.geometry.euclidean.twod.SubLine;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n+import org.apache.commons.math3.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math3.geometry.partitioning.BSPTree;\n import org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor;\n import org.apache.commons.math3.geometry.partitioning.BoundaryAttribute;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n import org.apache.commons.math3.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math3.geometry.partitioning.Transform;\n-import org.apache.commons.math3.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math3.util.FastMath;\n \n /** This class represents a 3D region: a set of polyhedrons.\n     private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax,\n                                                       final double yMin, final double yMax,\n                                                       final double zMin, final double zMax) {\n-        try {\n-            final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I);\n-            final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I);\n-            final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J);\n-            final Plane pyMax = new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J);\n-            final Plane pzMin = new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K);\n-            final Plane pzMax = new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K);\n-            @SuppressWarnings(\"unchecked\")\n-            final Region<Euclidean3D> boundary =\n-                    new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\n-            return boundary.getTree(false);\n-        } catch (MathArithmeticException mae) {\n-            // this should never happen as provided normals are all non-zero\n-            throw new MathInternalError(mae);\n-        }\n+        final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I);\n+        final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I);\n+        final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J);\n+        final Plane pyMax = new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J);\n+        final Plane pzMin = new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K);\n+        final Plane pzMax = new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K);\n+        @SuppressWarnings(\"unchecked\")\n+        final Region<Euclidean3D> boundary =\n+        new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\n+        return boundary.getTree(false);\n     }\n \n     /** {@inheritDoc} */\n                                         tP00.getX(), tP00.getY());\n \n                 cachedOriginal  = (Plane) original;\n-                try {\n-                    cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n-                } catch (MathIllegalArgumentException miae) {\n-                    // this should never happen as the transform built on p00, p10, p01 is invertible\n-                    throw new MathInternalError(miae);\n-                }\n+                cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n \n             }\n             return ((SubLine) sub).applyTransform(cachedTransform);\n                     AffineTransform.getTranslateInstance(shift.getX(), shift.getY());\n \n                 cachedOriginal  = (Plane) original;\n-                try {\n-                    cachedTransform =\n-                            org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n-                } catch (MathIllegalArgumentException miae) {\n-                    // this should never happen as a translation is always invertible\n-                    throw new MathInternalError(miae);\n-                }\n+                cachedTransform =\n+                        org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n \n             }\n \n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n \n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n    */\n   public Rotation(RotationOrder order,\n                   double alpha1, double alpha2, double alpha3) {\n-      try {\n-          Rotation r1 = new Rotation(order.getA1(), alpha1);\n-          Rotation r2 = new Rotation(order.getA2(), alpha2);\n-          Rotation r3 = new Rotation(order.getA3(), alpha3);\n-          Rotation composed = r1.applyTo(r2.applyTo(r3));\n-          q0 = composed.q0;\n-          q1 = composed.q1;\n-          q2 = composed.q2;\n-          q3 = composed.q3;\n-      } catch (MathIllegalArgumentException miae) {\n-          // this should never happen as RotationOrder axes are all normalized,\n-          // and hence never null\n-          throw new MathInternalError(miae);\n-      }\n+      Rotation r1 = new Rotation(order.getA1(), alpha1);\n+      Rotation r2 = new Rotation(order.getA2(), alpha2);\n+      Rotation r3 = new Rotation(order.getA3(), alpha3);\n+      Rotation composed = r1.applyTo(r2.applyTo(r3));\n+      q0 = composed.q0;\n+      q1 = composed.q1;\n+      q2 = composed.q2;\n+      q3 = composed.q3;\n   }\n \n   /** Convert an orthogonal rotation matrix to a quaternion.\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n import org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;\n import org.apache.commons.math3.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n                                 final double maxCheckInterval,\n                                 final double convergence,\n                                 final int maxIterationCount) {\n-        try {\n-            addEventHandler(handler, maxCheckInterval, convergence,\n-                            maxIterationCount,\n-                            new BracketingNthOrderBrentSolver(convergence, 5));\n-        } catch (NumberIsTooSmallException ntse) {\n-            // this should never happen\n-            throw new MathInternalError();\n-        }\n+        addEventHandler(handler, maxCheckInterval, convergence,\n+                        maxIterationCount,\n+                        new BracketingNthOrderBrentSolver(convergence, 5));\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math3/ode/JacobianMatrices.java\n+++ b/src/main/java/org/apache/commons/math3/ode/JacobianMatrices.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n                     for (int k = 0 ; (!found) && (k < jacobianProviders.size()); ++k) {\n                         final ParameterJacobianProvider provider = jacobianProviders.get(k);\n                         if (provider.isSupported(param.getParameterName())) {\n-                            try {\n-                                provider.computeParameterJacobian(t, y, yDot,\n-                                                                  param.getParameterName(), dFdP);\n-                            } catch (UnknownParameterException upe) {\n-                                // this should never happen as we have check support beforehand\n-                                throw new MathInternalError(upe);\n-                            }\n+                            provider.computeParameterJacobian(t, y, yDot,\n+                                                              param.getParameterName(), dFdP);\n                             for (int i = 0; i < stateDim; ++i) {\n                                 final double[] dFdYi = dFdY[i];\n                                 int zIndex = startIndex;\n--- a/src/main/java/org/apache/commons/math3/ode/ParameterJacobianWrapper.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ParameterJacobianWrapper.java\n import java.util.Map;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n \n /** Wrapper class to compute Jacobian matrices by finite differences for ODE\n \n         final int n = fode.getDimension();\n         if (pode.isSupported(paramName)) {\n-            try {\n-                final double[] tmpDot = new double[n];\n+            final double[] tmpDot = new double[n];\n \n-                // compute the jacobian df/dp w.r.t. parameter\n-                final double p  = pode.getParameter(paramName);\n-                final double hP = hParam.get(paramName);\n-                pode.setParameter(paramName, p + hP);\n-                fode.computeDerivatives(t, y, tmpDot);\n-                for (int i = 0; i < n; ++i) {\n-                    dFdP[i] = (tmpDot[i] - yDot[i]) / hP;\n-                }\n-                pode.setParameter(paramName, p);\n-            } catch (MathIllegalArgumentException miae) {\n-                // this should never happen as we have checked the parameter is supported\n-                throw new MathInternalError(miae);\n+            // compute the jacobian df/dp w.r.t. parameter\n+            final double p  = pode.getParameter(paramName);\n+            final double hP = hParam.get(paramName);\n+            pode.setParameter(paramName, p + hP);\n+            fode.computeDerivatives(t, y, tmpDot);\n+            for (int i = 0; i < n; ++i) {\n+                dFdP[i] = (tmpDot[i] - yDot[i]) / hP;\n             }\n+            pode.setParameter(paramName, p);\n         } else {\n             Arrays.fill(dFdP, 0, n, 0.0);\n         }\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853StepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.ode.AbstractIntegrator;\n import org.apache.commons.math3.ode.EquationsMapper;\n   @Override\n   protected void doFinalize() throws MaxCountExceededException {\n \n-      try {\n-          if (currentState == null) {\n-              // we are finalizing an uninitialized instance\n-              return;\n-          }\n-\n-          double s;\n-          final double[] yTmp = new double[currentState.length];\n-          final double pT = getGlobalPreviousTime();\n-\n-          // k14\n-          for (int j = 0; j < currentState.length; ++j) {\n-              s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n-                      K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n-                      K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n-              yTmp[j] = currentState[j] + h * s;\n-          }\n-          integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n-\n-          // k15\n-          for (int j = 0; j < currentState.length; ++j) {\n-              s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n-                      K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n-                      K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n-                      K15_14 * yDotKLast[0][j];\n-              yTmp[j] = currentState[j] + h * s;\n-          }\n-          integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n-\n-          // k16\n-          for (int j = 0; j < currentState.length; ++j) {\n-              s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n-                      K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n-                      K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n-                      K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n-              yTmp[j] = currentState[j] + h * s;\n-          }\n-          integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n-      } catch (DimensionMismatchException dme) {\n-          throw new MathInternalError(dme);\n-      }\n+      if (currentState == null) {\n+          // we are finalizing an uninitialized instance\n+          return;\n+      }\n+\n+      double s;\n+      final double[] yTmp = new double[currentState.length];\n+      final double pT = getGlobalPreviousTime();\n+\n+      // k14\n+      for (int j = 0; j < currentState.length; ++j) {\n+          s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n+                  K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n+                  K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n+          yTmp[j] = currentState[j] + h * s;\n+      }\n+      integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n+\n+      // k15\n+      for (int j = 0; j < currentState.length; ++j) {\n+          s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n+                  K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n+                  K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n+                  K15_14 * yDotKLast[0][j];\n+          yTmp[j] = currentState[j] + h * s;\n+      }\n+      integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n+\n+      // k16\n+      for (int j = 0; j < currentState.length; ++j) {\n+          s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n+                  K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n+                  K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n+                  K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n+          yTmp[j] = currentState[j] + h * s;\n+      }\n+      integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n \n   }\n \n--- a/src/main/java/org/apache/commons/math3/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/sampling/AbstractStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.ode.EquationsMapper;\n \n   /** {@inheritDoc} */\n   public double[] getInterpolatedState() throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      try {\n-          primaryMapper.extractEquationData(interpolatedState,\n-                                            interpolatedPrimaryState);\n-      } catch (DimensionMismatchException dme) {\n-          // this should never happen\n-          throw new MathInternalError(dme);\n-      }\n+      primaryMapper.extractEquationData(interpolatedState,\n+                                        interpolatedPrimaryState);\n       return interpolatedPrimaryState;\n   }\n \n   /** {@inheritDoc} */\n   public double[] getInterpolatedDerivatives() throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      try {\n-          primaryMapper.extractEquationData(interpolatedDerivatives,\n-                                            interpolatedPrimaryDerivatives);\n-      } catch (DimensionMismatchException dme) {\n-          // this should never happen\n-          throw new MathInternalError(dme);\n-      }\n+      primaryMapper.extractEquationData(interpolatedDerivatives,\n+                                        interpolatedPrimaryDerivatives);\n       return interpolatedPrimaryDerivatives;\n   }\n \n   /** {@inheritDoc} */\n   public double[] getInterpolatedSecondaryState(final int index) throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      try {\n-          secondaryMappers[index].extractEquationData(interpolatedState,\n-                                                      interpolatedSecondaryState[index]);\n-      } catch (DimensionMismatchException dme) {\n-          // this should never happen\n-          throw new MathInternalError(dme);\n-      }\n+      secondaryMappers[index].extractEquationData(interpolatedState,\n+                                                  interpolatedSecondaryState[index]);\n       return interpolatedSecondaryState[index];\n   }\n \n   /** {@inheritDoc} */\n   public double[] getInterpolatedSecondaryDerivatives(final int index) throws MaxCountExceededException {\n       evaluateCompleteInterpolatedState();\n-      try {\n-          secondaryMappers[index].extractEquationData(interpolatedDerivatives,\n-                                                      interpolatedSecondaryDerivatives[index]);\n-      } catch (DimensionMismatchException dme) {\n-          // this should never happen\n-          throw new MathInternalError(dme);\n-      }\n+      secondaryMappers[index].extractEquationData(interpolatedDerivatives,\n+                                                  interpolatedSecondaryDerivatives[index]);\n       return interpolatedSecondaryDerivatives[index];\n   }\n \n--- a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n package org.apache.commons.math3.util;\n \n import org.apache.commons.math3.exception.ConvergenceException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n      * @throws ConvergenceException if the algorithm fails to converge.\n      */\n     public double evaluate(double x) throws ConvergenceException {\n-        try {\n-            return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n-        } catch (MaxCountExceededException e) {\n-            // this should never happen as integers never exceed MAX_VALUE\n-            throw new MathInternalError(e);\n-        }\n+        return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n \n     /**\n      * @throws ConvergenceException if the algorithm fails to converge.\n      */\n     public double evaluate(double x, double epsilon) throws ConvergenceException {\n-        try {\n-            return evaluate(x, epsilon, Integer.MAX_VALUE);\n-        } catch (MaxCountExceededException e) {\n-            // this should never happen as integers never exceed MAX_VALUE\n-            throw new MathInternalError(e);\n-        }\n+        return evaluate(x, epsilon, Integer.MAX_VALUE);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n     public static boolean isMonotonic(double[] val,\n                                       OrderDirection dir,\n                                       boolean strict) {\n-        try {\n-            return checkOrder(val, dir, strict, false);\n-        } catch (NonMonotonicSequenceException e) {\n-            // this should never happen as abort is set to false\n-            throw new MathInternalError(e);\n-        }\n+        return checkOrder(val, dir, strict, false);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n package org.apache.commons.math3.util;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n \n /**\n  * Converter between unidimensional storage structure and multidimensional\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < dimension; i++) {\n-            try {\n-                sb.append(\"[\").append(getCount(i)).append(\"]\");\n-            } catch (OutOfRangeException e) {\n-                // this should never happen\n-                throw new MathInternalError(e);\n-            } catch (DimensionMismatchException e) {\n-                // this should never happen\n-                throw new MathInternalError(e);\n-            }\n+            sb.append(\"[\").append(getCount(i)).append(\"]\");\n         }\n         return sb.toString();\n     }\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n package org.apache.commons.math3.util;\n \n import java.math.BigDecimal;\n+\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n      * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n      */\n     public static float round(float x, int scale) {\n-        try {\n         return round(x, scale, BigDecimal.ROUND_HALF_UP);\n-        } catch (MathArithmeticException e) {\n-            // should never happen as we don't use BigDecimal.ROUND_UNNECESSARY\n-            throw new MathInternalError(e);\n-        } catch (MathIllegalArgumentException e) {\n-            // should never happen as we use a valid rounding\n-            throw new MathInternalError(e);\n-        }\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n-import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n      * @since 2.0\n      */\n     public synchronized ResizableDoubleArray copy() {\n-        try {\n-            ResizableDoubleArray result = new ResizableDoubleArray();\n-            copy(this, result);\n-            return result;\n-        } catch (NullArgumentException e) {\n-            // this should never happen\n-            throw new MathInternalError(e);\n-        }\n+        ResizableDoubleArray result = new ResizableDoubleArray();\n+        copy(this, result);\n+        return result;\n     }\n \n     /**", "timestamp": 1347287847, "metainfo": ""}