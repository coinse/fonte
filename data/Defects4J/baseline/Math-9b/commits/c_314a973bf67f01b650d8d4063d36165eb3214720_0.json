{"sha": "314a973bf67f01b650d8d4063d36165eb3214720", "log": "Formatting, Javadoc, \"final\" keyword.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n  * @version $Id$\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n-\n-    /** additive expansion mode */\n+    /** Additive expansion mode. */\n     public static final int ADDITIVE_MODE = 1;\n-\n-    /** multiplicative expansion mode */\n+    /** Multiplicative expansion mode. */\n     public static final int MULTIPLICATIVE_MODE = 0;\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -3485529955529426875L;\n \n     /**\n     /**\n      * Adds an element to the end of this expandable array.\n      *\n-     * @param value to be added to end of array\n+     * @param value Value to be added to end of array.\n      */\n     public synchronized void addElement(double value) {\n         if (internalArray.length <= startIndex + numElements) {\n     /**\n      * Adds several element to the end of this expandable array.\n      *\n-     * @param values to be added to end of array\n+     * @param values Values to be added to end of array.\n      * @since 2.2\n      */\n     public synchronized void addElements(double[] values) {\n      * the entries 2, 3, 4, 5 and the value returned is 1.\n      * </p>\n      *\n-     * @param value the value to be added to the array\n+     * @param value Value to be added to the array.\n      * @return the value which has been discarded or \"pushed\" out of the array\n-     *         by this rolling insert\n+     * by this rolling insert.\n      */\n     public synchronized double addElementRolling(double value) {\n         double discarded = internalArray[startIndex];\n      * Returns the value that has been replaced. If the array is empty (i.e.\n      * if {@link #numElements} is zero), an IllegalStateException is thrown.\n      *\n-     * @param value new value to substitute for the most recently added value\n-     * @return value that has been replaced in the array\n+     * @param value New value to substitute for the most recently added value\n+     * @return the value that has been replaced in the array.\n      * @throws MathIllegalStateException if the array is empty\n      * @since 2.0\n      */\n-    public synchronized double substituteMostRecentElement(double value) throws MathIllegalStateException {\n+    public synchronized double substituteMostRecentElement(double value)\n+        throws MathIllegalStateException {\n         if (numElements < 1) {\n             throw new MathIllegalStateException(\n                     LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n      * @param expansion factor to be checked\n      * @param contraction criteria to be checked\n      * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     *         the expansionCriteria.\n-     */\n-    protected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {\n+     * the expansionCriteria.\n+     */\n+    protected void checkContractExpand(float contraction, float expansion)\n+        throws MathIllegalArgumentException {\n \n         if (contraction < expansion) {\n             throw new MathIllegalArgumentException(\n      * zero.\n      */\n     public synchronized void contract() {\n-        double[] tempArray = new double[numElements + 1];\n+        final double[] tempArray = new double[numElements + 1];\n \n         // Copy and swap - copy only the element array from the src array.\n         System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {\n-\n+    public synchronized void discardFrontElements(int i)\n+        throws MathIllegalArgumentException {\n         discardExtremeElements(i,true);\n-\n     }\n \n     /**\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n-\n+    public synchronized void discardMostRecentElements(int i)\n+        throws MathIllegalArgumentException {\n         discardExtremeElements(i,false);\n-\n     }\n \n     /**\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    private synchronized void discardExtremeElements(int i,boolean front) throws MathIllegalArgumentException {\n+    private synchronized void discardExtremeElements(int i,\n+                                                     boolean front)\n+        throws MathIllegalArgumentException {\n         if (i > numElements) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY,\n      * </p>\n      */\n     protected synchronized void expand() {\n-\n         // notice the use of FastMath.ceil(), this guarantees that we will always\n         // have an array of at least currentSize + 1.   Assume that the\n         // current initial capacity is 1 and the expansion factor\n         } else {\n             newSize = internalArray.length + FastMath.round(expansionFactor);\n         }\n-        double[] tempArray = new double[newSize];\n+        final double[] tempArray = new double[newSize];\n \n         // Copy and swap\n         System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n     /**\n      * Expands the internal storage array to the specified size.\n      *\n-     * @param size Size of the new internal storage array\n+     * @param size Size of the new internal storage array.\n      */\n     private synchronized void expandTo(int size) {\n-        double[] tempArray = new double[size];\n+        final double[] tempArray = new double[size];\n         // Copy and swap\n         System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n         internalArray = tempArray;\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n      * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n-     *         zero or is greater than <code>getNumElements() - 1</code>.\n+     * zero or is greater than <code>getNumElements() - 1</code>.\n      */\n     public synchronized double getElement(int index) {\n         if (index >= numElements) {\n      * @return the double array.\n      */\n     public synchronized double[] getElements() {\n-        double[] elementArray = new double[numElements];\n-        System.arraycopy( internalArray, startIndex, elementArray, 0,\n-                numElements);\n+        final double[] elementArray = new double[numElements];\n+        System.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\n         return elementArray;\n     }\n \n      * Returns the number of elements currently in the array.  Please note\n      * that this is different from the length of the internal storage array.\n      *\n-     * @return number of elements\n+     * @return the number of elements.\n      */\n     public synchronized int getNumElements() {\n         return numElements;\n      * @throws MathIllegalArgumentException if the contractionCriteria is less than\n      *         the expansionCriteria.\n      */\n-    public void setContractionCriteria(float contractionCriteria) throws MathIllegalArgumentException {\n+    public void setContractionCriteria(float contractionCriteria)\n+        throws MathIllegalArgumentException {\n         checkContractExpand(contractionCriteria, getExpansionFactor());\n         synchronized(this) {\n             this.contractionCriteria = contractionCriteria;\n      *\n      * @param index index to store a value in\n      * @param value value to store at the specified index\n-     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n-     *         zero.\n+     * @throws ArrayIndexOutOfBoundsException if {@code index < 0}.\n      */\n     public synchronized void setElement(int index, double value) {\n         if (index < 0) {\n      * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n      *\n      * @param expansionMode The expansionMode to set.\n-     * @throws MathIllegalArgumentException if the specified mode value is not valid\n-     */\n-    public void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {\n+     * @throws MathIllegalArgumentException if the specified mode value is not valid.\n+     */\n+    public void setExpansionMode(int expansionMode)\n+        throws MathIllegalArgumentException {\n         if (expansionMode != MULTIPLICATIVE_MODE &&\n-                expansionMode != ADDITIVE_MODE) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.UNSUPPORTED_EXPANSION_MODE,\n-                    expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n-                    ADDITIVE_MODE, \"ADDITIVE_MODE\");\n+            expansionMode != ADDITIVE_MODE) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode,\n+                                                   MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n+                                                   ADDITIVE_MODE, \"ADDITIVE_MODE\");\n         }\n         synchronized(this) {\n             this.expansionMode = expansionMode;\n      *\n      * @param initialCapacity of the array\n      * @throws MathIllegalArgumentException if <code>initialCapacity</code> is not\n-     *         positive.\n-     */\n-    protected void setInitialCapacity(int initialCapacity) throws MathIllegalArgumentException {\n+     * positive.\n+     */\n+    protected void setInitialCapacity(int initialCapacity)\n+        throws MathIllegalArgumentException {\n         if (initialCapacity > 0) {\n             synchronized(this) {\n                 this.initialCapacity = initialCapacity;\n             }\n         } else {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE,\n-                    initialCapacity);\n+            throw new MathIllegalArgumentException(LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE,\n+                                                   initialCapacity);\n         }\n     }\n \n      * @param i a new number of elements\n      * @throws MathIllegalArgumentException if <code>i</code> is negative.\n      */\n-    public synchronized void setNumElements(int i) throws MathIllegalArgumentException {\n-\n-        // If index is negative thrown an error\n+    public synchronized void setNumElements(int i)\n+        throws MathIllegalArgumentException {\n+        // If index is negative thrown an error.\n         if (i < 0) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.INDEX_NOT_POSITIVE,\n         }\n \n         // Test the new num elements, check to see if the array needs to be\n-        // expanded to accommodate this new number of elements\n+        // expanded to accommodate this new number of elements.\n         if ((startIndex + i) > internalArray.length) {\n             expandTo(startIndex + i);\n         }\n \n-        // Set the new number of elements to new value\n+        // Set the new number of elements to new value.\n         numElements = i;\n     }\n \n      * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n      * </code>\n      *\n-     * @return starting index\n+     * @return the starting index.\n      */\n     public synchronized int start() {\n         return startIndex;\n      * @since 2.0\n      *\n      */\n-    public static void copy(ResizableDoubleArray source, ResizableDoubleArray dest)\n+    public static void copy(ResizableDoubleArray source,\n+                            ResizableDoubleArray dest)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(source);\n         MathUtils.checkNotNull(dest);\n      * @since 2.0\n      */\n     public synchronized ResizableDoubleArray copy() {\n-        ResizableDoubleArray result = new ResizableDoubleArray();\n+        final ResizableDoubleArray result = new ResizableDoubleArray();\n         copy(this, result);\n         return result;\n     }\n         if (object == this ) {\n             return true;\n         }\n-       if (object instanceof ResizableDoubleArray == false) {\n+        if (object instanceof ResizableDoubleArray == false) {\n             return false;\n         }\n-       synchronized(this) {\n-           synchronized(object) {\n-               boolean result = true;\n-               ResizableDoubleArray other = (ResizableDoubleArray) object;\n-               result = result && (other.initialCapacity == initialCapacity);\n-               result = result && (other.contractionCriteria == contractionCriteria);\n-               result = result && (other.expansionFactor == expansionFactor);\n-               result = result && (other.expansionMode == expansionMode);\n-               result = result && (other.numElements == numElements);\n-               result = result && (other.startIndex == startIndex);\n-               if (!result) {\n-                   return false;\n-               } else {\n-                   return Arrays.equals(internalArray, other.internalArray);\n-               }\n-           }\n-       }\n+        synchronized(this) {\n+            synchronized(object) {\n+                boolean result = true;\n+                final ResizableDoubleArray other = (ResizableDoubleArray) object;\n+                result = result && (other.initialCapacity == initialCapacity);\n+                result = result && (other.contractionCriteria == contractionCriteria);\n+                result = result && (other.expansionFactor == expansionFactor);\n+                result = result && (other.expansionMode == expansionMode);\n+                result = result && (other.numElements == numElements);\n+                result = result && (other.startIndex == startIndex);\n+                if (!result) {\n+                    return false;\n+                } else {\n+                    return Arrays.equals(internalArray, other.internalArray);\n+                }\n+            }\n+        }\n     }\n \n     /**\n      * Returns a hash code consistent with equals.\n      *\n-     * @return hash code representing this ResizableDoubleArray\n+     * @return the hash code representing this {@code ResizableDoubleArray}.\n      * @since 2.0\n      */\n     @Override\n     public synchronized int hashCode() {\n-        int[] hashData = new int[7];\n+        final int[] hashData = new int[7];\n         hashData[0] = new Float(expansionFactor).hashCode();\n         hashData[1] = new Float(contractionCriteria).hashCode();\n         hashData[2] = expansionMode;\n-            hashData[3] = Arrays.hashCode(internalArray);\n-            hashData[4] = initialCapacity;\n-            hashData[5] = numElements;\n-            hashData[6] = startIndex;\n+        hashData[3] = Arrays.hashCode(internalArray);\n+        hashData[4] = initialCapacity;\n+        hashData[5] = numElements;\n+        hashData[6] = startIndex;\n         return Arrays.hashCode(hashData);\n     }\n ", "timestamp": 1352736216, "metainfo": ""}