{"sha": "cc3b4cac2bb748b52e79099523814f771be78e9c", "log": "Updated source code to reflect Jakarta source code guidelines specifically tab characters.  Changes were driven by Checkstyle report on http://jakarta.apache.org/commons/sandbox/math   ", "commit": "\n--- a/src/java/org/apache/commons/math/AbstractStoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/AbstractStoreUnivariate.java\n  */\n public abstract class AbstractStoreUnivariate implements StoreUnivariate {\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getMode()\n-\t */\n-\tpublic double getMode() {\n-\t\t// Mode depends on a refactor Freq class\n-\t\tthrow new UnsupportedOperationException(\"getMode() is not yet implemented\");\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getSkewness()\n-\t */\n-\tpublic double getSkewness() {\n-\t\t// Initialize the skewness\n-\t\tdouble skewness = Double.NaN;\n-\t\t\n-\t\t// Get the mean and the standard deviation\n-\t\tdouble mean = getMean();\n-\t\tdouble stdDev = getStandardDeviation();\n-\n-\t\t// Sum the cubes of the distance from the mean divided by the standard deviation\n-\t\tdouble accum = 0.0;\n-\t\tfor( int i = 0; i < getN(); i++ ) {\n-\t\t\taccum += Math.pow( (getElement(i) - mean) / stdDev, 3.0);\n-\t\t}\n-\t\t\n-\t\t// Get N\n-\t\tdouble n = getN();\n-\t\t\n-\t\t// Calculate skewness\n-\t\tskewness = ( n / ( (n-1) * (n-2) ) ) * accum;\n-\n-\t\treturn skewness;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getKurtosis()\n-\t */\n-\tpublic double getKurtosis() {\n-\t\t// Initialize the kurtosis\n-\t\tdouble kurtosis = Double.NaN;\n-\t\t\n-\t\t// Get the mean and the standard deviation\n-\t\tdouble mean = getMean();\n-\t\tdouble stdDev = getStandardDeviation();\n-\n-\t\t// Sum the ^4 of the distance from the mean divided by the standard deviation\n-\t\tdouble accum = 0.0;\n-\t\tfor( int i = 0; i < getN(); i++ ) {\n-\t\t\taccum += Math.pow( (getElement(i) - mean) / stdDev, 4.0);\n-\t\t}\n-\t\t\n-\t\t// Get N\n-\t\tdouble n = getN();\n-\t\t\n-\t\tdouble coefficientOne = ( n * (n+1)) / ( (n-1) * (n-2) * (n-3) );\n-\t\tdouble termTwo = (  ( 3 * Math.pow( n - 1, 2.0)) /  ( (n-2) * (n-3) ) ); \n-\t\t// Calculate kurtosis\n-\t\tkurtosis = ( coefficientOne * accum ) - termTwo;\n-\n-\t\treturn kurtosis;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getKurtosisClass()\n-\t */\n-\tpublic int getKurtosisClass() {\n-\n-\t\tint kClass = StoreUnivariate.MESOKURTIC;\n-\t\t\n-\t\tdouble kurtosis = getKurtosis();\n-\t\tif( kurtosis > 0 ) {\n-\t\t\tkClass = StoreUnivariate.LEPTOKURTIC;\n-\t\t} else if( kurtosis < 0 ) {\n-\t\t\tkClass = StoreUnivariate.PLATYKURTIC;\n-\t\t}\n-\t\t\n-\t\treturn( kClass );\n-\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getMean()\n-\t */\n-\tpublic double getMean() {\n-\t\tdouble arithMean = getSum() / getN();\n-\t\treturn arithMean;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getVariance()\n-\t */\n-\tpublic double getVariance() {\n-\t\t// Initialize variance\n-\t\tdouble variance = Double.NaN;\n-\n-\t\tif( getN() == 1 ) {\n-\t\t\t// If this is a single value\n-\t\t\tvariance = 0;\n-\t\t} else if( getN() > 1 ) {\n-\t\t\t// Get the mean\n-\t\t\tdouble mean = getMean();\n-\n-\t\t\t// Calculate the sum of the squares of the distance between each value and the mean\n-\t\t\tdouble accum = 0.0;\t\t\n-\t\t\tfor( int i = 0; i < getN(); i++ ){\n-\t\t\t\t\taccum += Math.pow( (getElement(i) - mean), 2.0 );\n-\t\t\t}\n-\t\t\n-\t\t\t// Divide the accumulator by N - Hmmm... unbiased or biased?\n-\t\t\tvariance = accum / (getN() - 1);\n-\t\t }\n-\t\t\n-\t\treturn variance;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getStandardDeviation()\n-\t */\n-\tpublic double getStandardDeviation() {\n-\t\tdouble stdDev = Double.NaN;\n-\t\tif( getN() != 0 ) {\n-\t\t\tstdDev = Math.sqrt( getVariance() );\n-\t\t}\n-\t\treturn( stdDev );\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getMax()\n-\t */\n-\tpublic double getMax() {\n-\t\t\n-\t\t// Initialize maximum to NaN\n-\t\tdouble max = Double.NaN;\n-\t\t\n-\t\tfor( int i = 0; i < getN(); i++) {\n-\t\t\tif( i == 0 ) {\n-\t\t\t\tmax = getElement(i);\n-\t\t\t} else {\n-\t\t\t\tif( getElement(i) > max ) {\n-\t\t\t\t\tmax = getElement(i);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn max;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getMin()\n-\t */\n-\tpublic double getMin() {\n-\t\t// Initialize minimum to NaN\n-\t\tdouble min = Double.NaN;\n-\t\t\n-\t\tfor( int i = 0; i < getN(); i++) {\n-\t\t\tif( i == 0 ) {\n-\t\t\t\tmin = getElement(i);\n-\t\t\t} else {\n-\t\t\t\tif( getElement(i) < min ) {\n-\t\t\t\t\tmin = getElement(i);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn min;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getSum()\n-\t */\n-\tpublic double getSum() {\n-\t\tdouble accum = 0.0;\n-\t\tfor( int i = 0; i < getN(); i++) {\n-\t\t\taccum += getElement(i);\n-\t\t}\n-\t\treturn accum;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getSumsq()\n-\t */\n-\tpublic double getSumsq() {\n-\t\tdouble accum = 0.0;\n-\t\tfor( int i = 0; i < getN(); i++) {\n-\t\t\taccum += Math.pow(getElement(i), 2.0);\n-\t\t}\n-\t\treturn accum;\n-\t}\n+    /** \n+     * Returns the most frequently occuring value\n+     * @see org.apache.commons.math.StoreUnivariate#getMode()\n+     */\n+    public double getMode() {\n+        // Mode depends on a refactor Freq class\n+        String msg = \"getMode() is not yet implemented\";\n+        throw new UnsupportedOperationException(msg);\n+    }\n+\n+    /**\n+     * Returns the skewness of this collection of values\n+     * @see org.apache.commons.math.StoreUnivariate#getSkewness()\n+     */\n+    public double getSkewness() {\n+        // Initialize the skewness\n+        double skewness = Double.NaN;\n+\n+        // Get the mean and the standard deviation\n+        double mean = getMean();\n+        double stdDev = getStandardDeviation();\n+\n+        // Sum the cubes of the distance from the mean divided by the \n+        // standard deviation\n+        double accum = 0.0;\n+        for (int i = 0; i < getN(); i++) {\n+            accum += Math.pow((getElement(i) - mean) / stdDev, 3.0);\n+        }\n+\n+        // Get N\n+        double n = getN();\n+\n+        // Calculate skewness\n+        skewness = (n / ((n - 1) * (n - 2))) * accum;\n+\n+        return skewness;\n+    }\n+\n+    /**\n+     * Returns the kurtosis for this collection of values\n+     * @see org.apache.commons.math.StoreUnivariate#getKurtosis()\n+     */\n+    public double getKurtosis() {\n+        // Initialize the kurtosis\n+        double kurtosis = Double.NaN;\n+\n+        // Get the mean and the standard deviation\n+        double mean = getMean();\n+        double stdDev = getStandardDeviation();\n+\n+        // Sum the ^4 of the distance from the mean divided by the \n+        // standard deviation\n+        double accum = 0.0;\n+        for (int i = 0; i < getN(); i++) {\n+            accum += Math.pow((getElement(i) - mean) / stdDev, 4.0);\n+        }\n+\n+        // Get N\n+        double n = getN();\n+\n+        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n+        double termTwo = ((3 * Math.pow(n - 1, 2.0)) \n+                           / ((n - 2) * (n - 3))); \n+        // Calculate kurtosis\n+        kurtosis = (coefficientOne * accum) - termTwo;\n+\n+        return kurtosis;\n+    }\n+\n+    /**\n+     * Returns the type or class of kurtosis that this collection of \n+     * values exhibits\n+     * @see org.apache.commons.math.StoreUnivariate#getKurtosisClass()\n+     */\n+    public int getKurtosisClass() {\n+\n+        int kClass = StoreUnivariate.MESOKURTIC;\n+\n+        double kurtosis = getKurtosis();\n+        if (kurtosis > 0) {\n+            kClass = StoreUnivariate.LEPTOKURTIC;\n+        } else if (kurtosis < 0) {\n+            kClass = StoreUnivariate.PLATYKURTIC;\n+        }\n+\n+        return (kClass);\n+\n+    }\n+\n+    /**\n+     * Returns the mean for this collection of values\n+     * @see org.apache.commons.math.Univariate#getMean()\n+     */\n+    public double getMean() {\n+        double arithMean = getSum() / getN();\n+        return arithMean;\n+    }\n+\n+    /**\n+     * Returns the variance for this collection of values\n+     * @see org.apache.commons.math.Univariate#getVariance()\n+     */\n+    public double getVariance() {\n+        // Initialize variance\n+        double variance = Double.NaN;\n+\n+        if (getN() == 1) {\n+            // If this is a single value\n+            variance = 0;\n+        } else if (getN() > 1) {\n+            // Get the mean\n+            double mean = getMean();\n+\n+            // Calculate the sum of the squares of the distance between each \n+            // value and the mean\n+            double accum = 0.0;\t\t\n+            for (int i = 0; i < getN(); i++){\n+                accum += Math.pow((getElement(i) - mean), 2.0);\n+            }\n+\n+            // Divide the accumulator by N - Hmmm... unbiased or biased?\n+            variance = accum / (getN() - 1);\n+        }\n+\n+        return variance;\n+    }\n+\n+    /**\n+     * Returns the standard deviation for this collection of values\n+     * @see org.apache.commons.math.Univariate#getStandardDeviation()\n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() != 0) {\n+            stdDev = Math.sqrt(getVariance());\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the maximum value contained herein.\n+     * @see org.apache.commons.math.Univariate#getMax()\n+     */\n+    public double getMax() {\n+\n+        // Initialize maximum to NaN\n+        double max = Double.NaN;\n+\n+        for (int i = 0; i < getN(); i++) {\n+            if (i == 0) {\n+                max = getElement(i);\n+            } else {\n+                if (getElement(i) > max) {\n+                    max = getElement(i);\n+                }\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * Returns the minimum value contained herein\n+     * @see org.apache.commons.math.Univariate#getMin()\n+     */\n+    public double getMin() {\n+        // Initialize minimum to NaN\n+        double min = Double.NaN;\n+\n+        for (int i = 0; i < getN(); i++) {\n+            if (i == 0) {\n+                min = getElement(i);\n+            } else {\n+                if (getElement(i) < min) {\n+                    min = getElement(i);\n+                }\n+            }\n+        }\n+\n+        return min;\n+    }\n+\n+    /**\n+     * Returns the sum of all values contained herein\n+     * @see org.apache.commons.math.Univariate#getSum()\n+     */\n+    public double getSum() {\n+        double accum = 0.0;\n+        for (int i = 0; i < getN(); i++) {\n+            accum += getElement(i);\n+        }\n+        return accum;\n+    }\n+\n+    /**\n+     * Returns the sun of the squares of all values contained herein\n+     * @see org.apache.commons.math.Univariate#getSumsq()\n+     */\n+    public double getSumsq() {\n+        double accum = 0.0;\n+        for (int i = 0; i < getN(); i++) {\n+            accum += Math.pow(getElement(i), 2.0);\n+        }\n+        return accum;\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ContractableDoubleArray.java\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n-public class ContractableDoubleArray extends ExpandableDoubleArray implements Serializable {\n-\n-\t// The contraction criteria is related to the expansion factor.  Since this array is allowed to contract\n-\t// \n-\tprotected float contractionCriteria = 2.5f;\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * default initial capactiy of 16, an expansion factor of 2.00, and a contractionCriteria of 2.5\n-\t */\n-\tpublic ContractableDoubleArray() {\n-\t\tsuper();\n-\t}\t\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * specified initial capacity, the defult expansion factor of 2.00, and a contractionCriteria of 2.5\n-\t * \n-\t * @param initialCapacity The initial size of the internal storage array\n-\t */\n-\tpublic ContractableDoubleArray(int initialCapacity) {\n-\t\tsuper( initialCapacity );\n-\t}\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * specificed initial capacity and expand factor, with a contractionCriteria of 2.5\n-\t * \n-\t * @param initialCapacity The initial size of the internal storage array\n-\t * @param expansionFactor the array will be expanded based on this parameter\n-\t */\n-\tpublic ContractableDoubleArray(int initialCapacity, float expansionFactor) {\n-\t\tthis.expansionFactor = expansionFactor;\n-\t\tsetInitialCapacity( initialCapacity );\n-\t\tinternalArray = new double[initialCapacity];\n-\t\tcheckContractExpand(getContractionCriteria(), expansionFactor);\n-\t}\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * specificed initial capacity, expand factor, and contractionCriteria\n-\t * \n-\t * @param initialCapacity The initial size of the internal storage array\n-\t * @param expansionFactor the array will be expanded based on this parameter\n-\t */\n-\tpublic ContractableDoubleArray(int initialCapacity, float expansionFactor, float contractionCriteria) {\n-\t\tthis.contractionCriteria = contractionCriteria;\n-\t\tthis.expansionFactor = expansionFactor;\n-\t\tsetInitialCapacity( initialCapacity );\n-\t\tinternalArray = new double[initialCapacity];\n-\t\tcheckContractExpand(contractionCriteria, expansionFactor);\n-\t}\n-\n-\t/**\n-\t * Contracts the storage array to the (size of the element set) + 1 - to avoid a zero length array.\n-\t * This function also resets the startIndex to zero \n-\t */\n-\tpublic synchronized void contract() {\n-\t\tdouble[] tempArray = new double[numElements + 1];\n-\n-\t\t// Copy and swap - copy only the element array from the src array.\n-\t\tSystem.arraycopy(internalArray,startIndex,tempArray,0,numElements);\n-\t\tinternalArray = tempArray;\n-\t\t\n-\t\t// Reset the start index to zero\n-\t\tstartIndex = 0;\n-\t}\n-\n-\t/**\n-\t * Adds an element to the end of this expandable array\n-\t * \n-\t * @return value to be added to end of array\n-\t */\n-\tpublic synchronized void addElement(double value) {\n-\t\tsuper.addElement( value );\n-\t\tif( shouldContract() ) {\n-\t\t\tcontract();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Adds an element to the end of this expandable array\n-\t * \n-\t * @return value to be added to end of array\n-\t */\n-\tpublic synchronized double addElementRolling(double value) {\n-\t\tdouble discarded = super.addElementRolling(value);\n-\t\t// Check the contraction criteria\n-\t\tif( shouldContract() ) {\n-\t\t\tcontract();\n-\t\t}\n-\t\treturn discarded;\n-\t}\n-\t\n-\t/**\n-\t * Should contract returns true if the ratio of (internal storage length) to (number of elements)\n-\t * is larger than the contractionCriteria value.  In other words, using the default value\n-\t * of 2.5, if the internal storage array provides more than 2.5x the space needed to store\n-\t * numElements, then this function returns true\n-\t * \n-\t * @return true if array satisfies the contraction criteria\n-\t */\n-\tprivate synchronized boolean shouldContract() {\n-\t\tboolean shouldContract = false;\n-\t\tif( ( internalArray.length / numElements ) > contractionCriteria ) {\n-\t\t\tshouldContract = true;\n-\t\t}\n-\t\treturn shouldContract;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.ExpandableDoubleArray#setElement(int, double)\n-\t */\n-\tpublic synchronized void setElement(int index, double value) {\n-\t\tsuper.setElement(index, value);\n-\t\tif( shouldContract() ) {\n-\t\t\tcontract();\n-\t\t}\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.ExpandableDoubleArray#setExpansionFactor(float)\n-\t */\n-\tpublic void setExpansionFactor(float expansionFactor) {\n-\t\tcheckContractExpand(getContractionCriteria(), expansionFactor);\n-\t\tsuper.setExpansionFactor(expansionFactor);\n-\t}\n-\n-\t/**\n-\t * The contraction criteria defines when the internal array will contract to store only the\n-\t * number of elements in the element array.  This contractionCriteria gaurantees that\n-\t * the internal storage array will never exceed this factor more than the space needed\n-\t * to store numElements.\n-\t * \n-\t * @return the contraction criteria used to reclaim memory when array is empty\n-\t */\n-\tpublic float getContractionCriteria() {\n-\t\treturn contractionCriteria;\n-\t}\n-\n-\t/**\n-\t * Sets the contraction criteria for this ExpandContractDoubleArray. \n-\t * \n-\t * @param new contraction criteria\n-\t */\n-\tpublic void setContractionCriteria(float contractionCriteria) {\n-\t\tcheckContractExpand( contractionCriteria, getExpansionFactor() );\n-\t\t\n-\t\tthis.contractionCriteria = contractionCriteria;\n-\t}\n-\t\n-\t/**\n-\t * Checks the expansion factor and the contraction criteria and throws an IllegalArgumentException\n-\t * if the contractionCriteria is less than the expansionCriteria\n-\t * \n-\t * @param expansionFactor \n-\t * @param contractionCriteria\n-\t */\n-\tprotected void checkContractExpand( float contractionCritera, float expansionFactor ) {\n-\t\t\n-\t\tif( contractionCritera < expansionFactor ) {\n-\t\t\tthrow new IllegalArgumentException( \"Contraction criteria can never be smaller than \" +\n-\t\t\t\t\"the expansion factor.  This would lead to a never ending loop of expansion and \" +\n-\t\t\t\t\"contraction as a newly expanded internal storage array would immediately \" +\n-\t\t\t\t\"satisfy the criteria for contraction\");\n-\t\t} \n-\n-\t\tif( contractionCriteria <= 1.0 ) {\n-\t\t\tthrow new IllegalArgumentException( \"The contraction criteria must be a number larger than\" +\n-\t\t\t\t\" one.  If the contractionCriteria is less than or equal to one an endless loop of contraction \" +\n-\t\t\t\t\"and expansion would ensue as an internalArray.length == numElements would satisfy \" +\n-\t\t\t\t\"the contraction criteria\");\n-\t\t}\n-\t\t\n-\t\tif (expansionFactor < 1.0) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"The expansion factor must be a number greater than\" + \"1.0\");\n-\t\t}\n-\n-\t\t\n-\t}\n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.ExpandableDoubleArray#discardFrontElements(int)\n-\t */\n-\tpublic synchronized void discardFrontElements(int i) {\n-\t\tsuper.discardFrontElements(i);\n-\t\tif( shouldContract() ) {\n-\t\t\tcontract();\n-\t\t}\n-\n-\t}\n-\n+public class ContractableDoubleArray \n+    extends ExpandableDoubleArray \n+    implements Serializable {\n+\n+    // The contraction criteria defines the conditions under which this\n+    // object will \"resize\" the internal array to the number of elements\n+    // contained in the element array + 1\n+    protected float contractionCriteria = 2.5f;\n+\n+    /**\n+     * Create an expandable double array with the default initial capacity of \n+     * 16, an expansion factor of 2.00, and a contractionCriteria of 2.5\n+     */\n+    public ContractableDoubleArray() {\n+        super();\n+    }\n+\n+    /**\n+     * Create an expandable double array with the specified initial capacity, \n+     * the defult expansion factor of 2.00, and a contractionCriteria of 2.5\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     */\n+    public ContractableDoubleArray(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Create an expandable double array with the specificed initial capacity \n+     * and expand factor, with a contractionCriteria of 2.5\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     */\n+    public ContractableDoubleArray(int initialCapacity, \n+                                   float expansionFactor) {\n+        this.expansionFactor = expansionFactor;\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+        checkContractExpand(getContractionCriteria(), expansionFactor);\n+    }\n+\n+    /**\n+     * Create an expandable double array with the\n+     * specificed initial capacity, expand factor, and contractionCriteria\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     */\n+    public ContractableDoubleArray(int initialCapacity, \n+                                   float expansionFactor, \n+                                   float contractionCriteria) {\n+        this.contractionCriteria = contractionCriteria;\n+        this.expansionFactor = expansionFactor;\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+        checkContractExpand(contractionCriteria, expansionFactor);\n+    }\n+\n+    /**\n+     * Contracts the storage array to the (size of the element set) + 1 - to \n+     * avoid a zero length array. This function also resets the startIndex to \n+     * zero. \n+     */\n+    public synchronized void contract() {\n+        double[] tempArray = new double[numElements + 1];\n+\n+        // Copy and swap - copy only the element array from the src array.\n+        System.arraycopy(internalArray,startIndex,tempArray,0,numElements);\n+        internalArray = tempArray;\n+\n+        // Reset the start index to zero\n+        startIndex = 0;\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @return value to be added to end of array\n+     */\n+    public synchronized void addElement(double value) {\n+        super.addElement(value);\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @return value to be added to end of array\n+     */\n+    public synchronized double addElementRolling(double value) {\n+        double discarded = super.addElementRolling(value);\n+        // Check the contraction criteria\n+        if (shouldContract()) {\n+            contract();\n+        }\n+        return discarded;\n+    }\n+\n+    /**\n+     * Should contract returns true if the ratio of (internal storage length) \n+     * to (number of elements) is larger than the contractionCriteria value.  \n+     * In other words, using the default value of 2.5, if the internal storage\n+     * array provides more than 2.5x the space needed to store numElements, \n+     * then this function returns true\n+     * \n+     * @return true if array satisfies the contraction criteria\n+     */\n+    private synchronized boolean shouldContract() {\n+        boolean shouldContract = false;\n+        if ((internalArray.length / numElements) > contractionCriteria) {\n+            shouldContract = true;\n+        }\n+        return shouldContract;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.ExpandableDoubleArray#setElement(int, double)\n+     */\n+    public synchronized void setElement(int index, double value) {\n+        super.setElement(index, value);\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.ExpandableDoubleArray#setExpansionFactor(float)\n+     */\n+    public void setExpansionFactor(float expansionFactor) {\n+        checkContractExpand(getContractionCriteria(), expansionFactor);\n+        super.setExpansionFactor(expansionFactor);\n+    }\n+\n+    /**\n+     * The contraction criteria defines when the internal array will contract \n+     * to store only the number of elements in the element array.  This \n+     * contractionCriteria gaurantees that the internal storage array will \n+     * never exceed this factor more than the space needed to store \n+     * numElements.\n+     * \n+     * @return the contraction criteria used to reclaim memory when array is \n+     *         empty\n+     */\n+    public float getContractionCriteria() {\n+        return contractionCriteria;\n+    }\n+\n+    /**\n+     * Sets the contraction criteria for this ExpandContractDoubleArray. \n+     * \n+     * @param new contraction criteria\n+     */\n+    public void setContractionCriteria(float contractionCriteria) {\n+        checkContractExpand(contractionCriteria, getExpansionFactor());\n+\n+        this.contractionCriteria = contractionCriteria;\n+    }\n+\n+    /**\n+     * Checks the expansion factor and the contraction criteria and throws an \n+     * IllegalArgumentException if the contractionCriteria is less than the \n+     * expansionCriteria\n+     * \n+     * @param expansionFactor \n+     * @param contractionCriteria\n+     */\n+    protected void checkContractExpand(float contractionCritera, \n+                                        float expansionFactor) {\n+\n+        if (contractionCritera < expansionFactor) {\n+            String msg = \"Contraction criteria can never be smaller than \" +\n+                \"the expansion factor.  This would lead to a never ending \" +\n+                \"loop of expansion and contraction as a newly expanded \" +\n+                \"internal storage array would immediately satisfy the \" +\n+                \"criteria for contraction\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        if (contractionCriteria <= 1.0) {\n+            String msg = \"The contraction criteria must be a number larger \" +\n+                \"than one.  If the contractionCriteria is less than or \" +\n+                \"equal to one an endless loop of contraction and expansion \" +\n+                \"would ensue as an internalArray.length == numElements \" +\n+                \"would satisfy the contraction criteria\";\n+            throw new IllegalArgumentException(msg); \n+        }\n+\n+        if (expansionFactor < 1.0) {\n+            String msg = \"The expansion factor must be a number greater \" +\n+                \"than 1.0\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.ExpandableDoubleArray#discardFrontElements(int)\n+     */\n+    public synchronized void discardFrontElements(int i) {\n+        super.discardFrontElements(i);\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/math/DoubleArray.java\n+++ b/src/java/org/apache/commons/math/DoubleArray.java\n  */\n public interface DoubleArray {\n \n-\t/**\n-\t * Returns the number of elements currently in the array.  Please note\n-\t * that this is different from the length of the internal storage array.  \n-\t * @return number of elements\n-\t */\n-\tpublic abstract int getNumElements();\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this is different from the length of the internal storage array.  \n+     * @return number of elements\n+     */\n+    int getNumElements();\n \n-\t/**\n-\t * Returns the element at the specified index\n-\t * \n-\t * @param index index to fetch a value from\n-\t * @return value stored at the specified index\n-\t */\n-\tpublic abstract double getElement(int index) throws NoSuchElementException;\n+    //TODO: Throwing a NoSuchElementException might not be the right\n+    //thing to do, it may be more helpful to just throw ArrayOutOfBounds...\n \n-\t/**\n-\t * Sets the element at the specified index.  This method will expand the internal storage array to\n-\t * accomodate the insertion of a value at an index beyond the current capacity.\n-\t * @param index index to store a value in\n-\t * @param value value to store at the specified index\n-\t */\n-\tpublic abstract void setElement(int index, double value);\n+    /**\n+     * Returns the element at the specified index\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     * @throws NoSuchElementException exception thrown if the array index\n+     *         exceeds the known boundaries of this array.  \n+     *\n+     */\n+    double getElement(int index) throws NoSuchElementException;\n \n-\t/**\n-\t * Adds an element to the end of this expandable array\n-\t * \n-\t * @return value to be added to end of array\n-\t */\n-\tpublic abstract void addElement(double value);\n+    /**\n+     * Sets the element at the specified index.  This method will expand the \n+     * internal storage array to accomodate the insertion of a value at an \n+     * index beyond the current capacity.\n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     */\n+    void setElement(int index, double value);\n \n-\t/**\n-\t * Adds an element and moves the window of elements up one.  This\n-\t * has the effect of a FIFO.  when you \"roll\" the array an element is removed \n-\t * from the array.  The return value of this function is the discarded double.\n-\t * \n-\t * @return the value which has been discarded or \"pushed\" out of the array\n-\t * \t  by this rolling insert.\n-\t */\n-\tpublic abstract double addElementRolling(double value);\n-\t\n-\t/**\n-\t * Returns a double[] of elements\n-\t */\n-\tpublic abstract double[] getElements();\n-\t\n-\t/**\n-\t * Clear the double array\n-\t */\n-\tpublic abstract void clear();\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @param value to be added to end of array\n+     */\n+    void addElement(double value);\n \n-\t/**\n-\t * Discards values from the front of the list.  This function removes n elements from\n-\t * the front of the array.\n-\t * \n-\t * @param i number of elements to discard from the front of the array.\n-\t */\n-\tpublic abstract void discardFrontElements(int i);\n-\t\n-\t/**\n-\t * Returns the minimum value stored in this array\n-\t */\n-\tpublic abstract double getMin();\n+    /**\n+     * Adds an element and moves the window of elements up one.  This\n+     * has the effect of a FIFO.  when you \"roll\" the array an element is \n+     * removed from the array.  The return value of this function is the \n+     * discarded double.\n+     * \n+     * @param value the value to be added to the array\n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     *         by this rolling insert.\n+     */\n+    double addElementRolling(double value);\n \n-\t/**\n-\t * Returns the maximum value stored in this array\n-\t */\n-\tpublic abstract double getMax();\n-}\n+    /**\n+     * Returns a double[] of elements\n+     *\n+     * @return all elements added to the array\n+     */\n+    double[] getElements();\n+\n+    /**\n+     * Clear the double array\n+     */\n+    void clear();\n+\n+    /**\n+     * Discards values from the front of the list.  This function removes n \n+     * elements from the front of the array.\n+     * \n+     *@param i number of elements to discard from the front of the array.\n+     */\n+    void discardFrontElements(int i);\n+\n+    /**\n+     * Returns the minimum value stored in this array\n+     *\n+     * @return minimum value contained in this array\n+     */\n+    double getMin();\n+\n+    /**\n+     * Returns the maximum value stored in this array\n+     *\n+     * @return maximum value contained in this array\n+     */\n+    double getMax();\n+}\n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n  */\n public class ExpandableDoubleArray implements Serializable, DoubleArray {\n \n-\t// This is the internal storage array.\n-\tprotected double[] internalArray;\n-\n-\t// Number of elements in the array\n-\tprotected int numElements = 0;\n+    // This is the internal storage array.\n+    protected double[] internalArray;\n+\n+    // Number of elements in the array\n+    protected int numElements = 0;\n+\n+    // Keeps track of a starting index\n+    protected int startIndex = 0;\n+\n+    // The initial capacity of the array. \n+    // Initial capacity is not exposed as a property as it is only meaningful\n+    // when passed to a constructor.\n+    protected int initialCapacity = 16;\n+\n+    // The expand factor of the array.  When the array need to be expanded, \n+    // the new array size will be internalArray.length * expandFactor \n+    protected float expansionFactor = 2.0f;\n+\n+    /**\n+     * Create an expandable double array with the\n+     * default initial capactiy of 16 and an expansion factor of 2.00\n+     */\n+    public ExpandableDoubleArray() {\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Create an expandable double array with the\n+     * specified initial capacity and the defult expansion factor of 2.00\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     */\n+    public ExpandableDoubleArray(int initialCapacity) {\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[this.initialCapacity];\n+    }\n+\n+    /**\n+     * Create an expandable double array with the\n+     * specificed initial capacity and expand factor.\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     */\n+    public ExpandableDoubleArray(int initialCapacity, float expansionFactor) {\n+        setInitialCapacity(initialCapacity);\n+        setExpansionFactor(expansionFactor);\n+        this.initialCapacity = initialCapacity;\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * The expansion factor controls the size of a new aray when an array \n+     * needs to be expanded. When a value is inserted into a full array, the \n+     * new array size is calculated as the current array size times this \n+     * expansion factor.  The default expansion factor is 2.0\n+     * \n+     * @return the expansion factor of this expandable double array\n+     */\n+    public float getExpansionFactor() {\n+        return expansionFactor;\n+    }\n+\n+    /**\n+     * Sets the expansion factor for this expandable double array.  \n+     * The expansion factor will affect the next expansion of this array.\n+     * \n+     * @param expansionFactor the expansion factor of this array\n+     */\n+    public void setExpansionFactor(float expansionFactor) {\n+\n+        // The expansion factor *must* be larger than 1.0, otherwise we'll \n+        // have an inconsistency upon expansion we'll start shrinking which \n+        // will lead to ArrayOutOfBound exceptions.\n+        if (expansionFactor > 1.0) {\n+            this.expansionFactor = expansionFactor;\n+        } else {\n+            String msg = \"The expansion factor must be a number greater \" +\n+                \"than 1.0\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    /**\n+     * Sets the initial capacity\n+     * \n+     * @param initialCapacity\n+     */\n+    public void setInitialCapacity(int initialCapacity) {\n+        if (initialCapacity > 0) {\n+            this.initialCapacity = initialCapacity;\n+        } else {\n+            String msg = \"The initial capacity supplied: \" + initialCapacity +\n+                \"must be a positive integer\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    /**\n+     * Returns the internal storage array\n+     * \n+     * @return the internal storage array used by this object\n+     */\n+    protected double[] getValues() {\n+        return (internalArray);\n+    }\n+\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this is different from the length of the internal storage array.  \n+     * @return number of elements\n+     */\n+    public int getNumElements() {\n+        return (numElements);\n+    }\n+\n+    /**\n+     * This function allows you to control the number of elements contained \n+     * in this array, and can be used to \"throw\" out the last n values in an \n+     * array.  This feature is mainly targetted at the subclasses of this \n+     * array class.  Note that this function will also expand the internal \n+     * array as needed.\n+     * \n+     * @param a new number of elements\n+     */\n+    public synchronized void setNumElements(int i) {\n+\n+        // If index is negative thrown an error\n+        if (i <  0) {\n+            String msg = \"Number of elements must be zero or a positive \" +\n+                \"integer\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        // Test the new num elements, check to see if the array needs to be \n+        // expanded to accomodate this new number of elements\n+        if ((startIndex + i) > internalArray.length) {\n+            expandTo(startIndex + i);\n+        }\n+\n+        // Set the new number of elements to new value\n+        numElements = i;\n+    }\n+\n+    /**\n+     * Returns the element at the specified index\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     */\n+    public double getElement(int index) throws NoSuchElementException {\n+        double value = Double.NaN;\n+        if (index >= numElements) {\n+            String msg = \"The index specified: \" + index + \n+                \" is larger than the current number of elements\";\n+            throw new NoSuchElementException(msg);\n+        } else if (index >= 0) {\n+            value = internalArray[startIndex + index];\n+        } else {\n+            String msg = \"Elements cannot be retrieved from a negative \" +\n+                \"array index\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the element at the specified index.  This method will expand the \n+     * internal storage array to accomodate the insertion of a value at an \n+     * index beyond the current capacity.\n+     *\n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     */\n+    public synchronized void setElement(int index, double value) {\n+\t\t\n+\t\tif (index < 0) {\n+            String msg = \"Cannot set an element at a negative index\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        if ((startIndex + index) >= internalArray.length) {\n+            expandTo(startIndex + (index + 1));\n+            numElements = index + 1;\n+        }\n+        internalArray[startIndex + index] = value;\n+    }\n+\n+    /**\n+     * Expands the internal storage array to the specified size.\n+     * \n+     * @param size Size of the new internal storage array\n+     */\n+    private synchronized void expandTo(int size) {\n+        double[] tempArray = new double[size];\n+        // Copy and swap\n+        System.arraycopy(internalArray,0,tempArray,0,internalArray.length);\n+        internalArray = tempArray;\n+    }\n+\n+    /**\n+     * Expands the internal storage array using the expansion factor\n+     */\n+    protected synchronized void expand() {\n+\n+\t\t// notice the use of Math.ceil(), this gaurantees that we will always \n+        // have an array of at least currentSize + 1.   Assume that the \n+        // current initial capacity is 1 and the expansion factor\n+\t\t// is 1.000000000000000001.  The newly calculated size will be \n+        // rounded up to 2 after the multiplication is performed.\n+        int newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n+        double[] tempArray = new double[newSize];\n+\n+        // Copy and swap\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+        internalArray = tempArray;\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @return value to be added to end of array\n+     */\n+    public synchronized void addElement(double value) {\n+        numElements++;\n+        if ((startIndex + numElements) > internalArray.length) {\n+            expand();\n+        }\n+        internalArray[startIndex + (numElements - 1)] = value;\n+    }\n+\n+    /**\n+     * Adds an element and moves the window of elements up one.  This\n+     * has the effect of a FIFO.  when you \"roll\" the array an element is \n+     * removed from the array.  The return value of this function is the \n+     * discarded double.\n+     * \n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     * \t  by this rolling insert.\n+     */\n+    public synchronized double addElementRolling(double value) {\n+        double discarded = internalArray[startIndex];\n+\n+        if ((startIndex + (numElements+1)) > internalArray.length) {\n+            expand();\n+        }\n+        // Increment the start index\n+        startIndex += 1;\n+\n+        // Add the new value\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        return discarded;\n+    }\n+\n+    /**\n+     * Notice the package scope on this method.   This method is simply here \n+     * for the JUnit test, it allows us check if the expansion is working \n+     * properly after a number of expansions.  This is not meant to be a part \n+     * of the public interface of this class.\n+     * \n+     * @return the length of the internal storage array.\n+     */\n+    int getInternalLength() {\n+        return (internalArray.length);\n+    }\n \t\n-\t// Keeps track of a starting index\n-\tprotected int startIndex = 0;\n-\n-\t// The initial capacity of the array. \n-\t// Initial capacity is not exposed as a property as it is only meaningful\n-\t// when passed to a constructor.\n-\tprotected int initialCapacity = 16;\n-\n-\t// The expand factor of the array.  When the array need to be expanded, the new array size\n-\t// will be internalArray.length * expandFactor \n-\tprotected float expansionFactor = 2.0f;\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * default initial capactiy of 16 and an expansion factor of 2.00\n-\t */\n-\tpublic ExpandableDoubleArray() {\n-\t\tinternalArray = new double[initialCapacity];\n-\t}\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * specified initial capacity and the defult expansion factor of 2.00\n-\t * \n-\t * @param initialCapacity The initial size of the internal storage array\n-\t */\n-\tpublic ExpandableDoubleArray(int initialCapacity) {\n-\t\tsetInitialCapacity(initialCapacity);\n-\t\tinternalArray = new double[this.initialCapacity];\n-\t}\n-\n-\t/**\n-\t * Create an expandable double array with the\n-\t * specificed initial capacity and expand factor.\n-\t * \n-\t * @param initialCapacity The initial size of the internal storage array\n-\t * @param expansionFactor the array will be expanded based on this parameter\n-\t */\n-\tpublic ExpandableDoubleArray(int initialCapacity, float expansionFactor) {\n-\t\tsetInitialCapacity( initialCapacity );\n-\t\tsetExpansionFactor(expansionFactor);\n-\t\tthis.initialCapacity = initialCapacity;\n-\t\tinternalArray = new double[initialCapacity];\n-\t}\n-\n-\t/**\n-\t * The expansion factor controls the size of a new aray when an array needs to be expanded.\n-\t * When a value is inserted into a full array, the new array size is calculated as the \n-\t * current array size times this expansion factor.  The default expansion factor is 2.0\n-\t * \n-\t * @return the expansion factor of this expandable double array\n-\t */\n-\tpublic float getExpansionFactor() {\n-\t\treturn expansionFactor;\n-\t}\n-\n-\t/**\n-\t * Sets the expansion factor for this expandable double array.  The expansion factor will\n-\t * affect the next expansion of this array.\n-\t * \n-\t * @param expansionFactor the expansion factor of this array\n-\t */\n-\tpublic void setExpansionFactor(float expansionFactor) {\n-\n-\t\t// The expansion factor *must* be larger than 1.0, otherwise we'll have an inconsistency\n-\t\t// upon expansion we'll start shrinking which will lead to ArrayOutOfBound exceptions.\n-\t\tif (expansionFactor > 1.0) {\n-\t\t\tthis.expansionFactor = expansionFactor;\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"The expansion factor must be a number greater than\" + \"1.0\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Sets the initial capacity\n-\t * \n-\t * @param initialCapacity\n-\t */\n-\tpublic void setInitialCapacity(int initialCapacity) {\n-\t\tif (initialCapacity > 0) {\n-\t\t\tthis.initialCapacity = initialCapacity;\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"The initial capacity supplied: \"\n-\t\t\t\t\t+ initialCapacity\n-\t\t\t\t\t+ \"must be a positive integer\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Returns the internal storage array\n-\t * \n-\t * @return the internal storage array used by this object\n-\t */\n-\tprotected double[] getValues() {\n-\t\treturn (internalArray);\n-\t}\n-\n-\t/**\n-\t * Returns the number of elements currently in the array.  Please note\n-\t * that this is different from the length of the internal storage array.  \n-\t * @return number of elements\n-\t */\n-\tpublic int getNumElements() {\n-\t\treturn (numElements);\n-\t}\n-\n-\t/**\n-\t * This function allows you to control the number of elements contained in this\n-\t * array, and can be used to \"throw\" out the last n values in an array.  This\n-\t * feature is mainly targetted at the subclasses of this array class.  Note\n-\t * that this function will also expand the internal array as needed.\n-\t * \n-\t * @param a new number of elements\n-\t */\n-\tpublic synchronized void setNumElements(int i) {\n+    /**\n+     * Clear the array, reset the size to the initialCapacity and the number \n+     * of elements to zero.\n+     */\n+    public synchronized void clear() {\n+        numElements = 0;\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Discards values from the front of the list.  This function removes n \n+     * elements from the front of the array.\n+     * \n+     * @param i number of elements to discard from the front of the array.\n+     */\n+    public synchronized void discardFrontElements(int i) {\n+\n+        if (i > numElements) {\n+            String msg = \"Cannot discard more elements than are\" +\n+                \"contained in this array.\";\n+            throw new IllegalArgumentException(msg);\n+        } else if (i < 0) {\n+            String msg = \"Cannot discard a negative number of elements.\";\n+            throw new IllegalArgumentException(msg);\n+        } else {\n+            // \"Subtract\" this number of discarded from numElements \n+            numElements -= i;\n+            startIndex += i;\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getElements()\n+     */\n+    public double[] getElements() {\n+        double[] elementArray = new double[numElements];\n+        System.arraycopy(internalArray, startIndex, \n+                         elementArray, 0, numElements);\n+        return elementArray;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getMax()\n+     */\n+    public double getMax() {\n+        double max = internalArray[startIndex];\n \t\t\n-\t\t// If index is negative thrown an error\n-\t\tif( i <  0 ) {\n-\t\t\tthrow new IllegalArgumentException( \"Number of elements must be zero or a positive integer\");\n-\t\t} \n-\t\t\n-\t\t// Test the new num elements, check to see if the array needs to be expanded to\n-\t\t// accomodate this new number of elements\n-\t\tif( (startIndex + i) > internalArray.length ) {\n-\t\t\texpandTo( startIndex + i );\n-\t\t}\n-\t\t\n-\t\t// Set the new number of elements to new value\n-\t\tnumElements = i;\n-\t}\n-\n-\n-\t/**\n-\t * Returns the element at the specified index\n-\t * \n-\t * @param index index to fetch a value from\n-\t * @return value stored at the specified index\n-\t */\n-\tpublic double getElement(int index) throws NoSuchElementException {\n-\t\tdouble value = Double.NaN;\n-\t\tif (index >= numElements) {\n-\t\t\tthrow new NoSuchElementException(\n-\t\t\t\t\"The index specified: \"\n-\t\t\t\t\t+ index\n-\t\t\t\t\t+ \" is larger than the \"\n-\t\t\t\t\t+ \"current number of elements\");\n-\t\t} else if (index >= 0) {\n-\t\t\tvalue = internalArray[startIndex + index];\n-\t\t} else {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"Elements cannot be retrieved from a negative array index\");\n-\t\t}\n-\t\treturn value;\n-\t}\n-\n-\t/**\n-\t * Sets the element at the specified index.  This method will expand the internal storage array to\n-\t * accomodate the insertion of a value at an index beyond the current capacity.\n-\t * @param index index to store a value in\n-\t * @param value value to store at the specified index\n-\t */\n-\tpublic synchronized void setElement(int index, double value) {\n-\t\t\n-\t\tif( index < 0 ) {\n-\t\t\tthrow new IllegalArgumentException( \"Cannot set an element at a negative index\");\n-\t\t}\n-\t\t\n-\t\tif ( (startIndex + index) >= internalArray.length) {\n-\t\t\texpandTo( startIndex + (index + 1));\n-\t\t\tnumElements = index + 1;\n-\t\t}\n-\t\tinternalArray[startIndex + index] = value;\n-\t}\n-\n-\t/**\n-\t * Expands the internal storage array to the specified size.\n-\t * \n-\t * @param size Size of the new internal storage array\n-\t */\n-\tprivate synchronized void expandTo(int size) {\n-\t\tdouble[] tempArray = new double[size];\n-\t\t// Copy and swap\n-\t\tSystem.arraycopy(internalArray,0,tempArray,0,internalArray.length);\n-\t\tinternalArray = tempArray;\n-\t}\n-\n-\t/**\n-\t * Expands the internal storage array using the expansion factor\n-\t */\n-\tprotected synchronized void expand() {\n-\n-\t\t// notice the use of Math.ceil(), this gaurantees that we will always have an array of at least\n-\t\t// currentSize + 1.   Assume that the current initial capacity is 1 and the expansion factor\n-\t\t// is 1.000000000000000001.  The newly calculated size will be rounded up to 2 after\n-\t\t// the multiplication is performed.\n-\t\tint newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n-\t\tdouble[] tempArray =\n-\t\t\tnew double[newSize];\n-\n-\t\t// Copy and swap\n-\t\tSystem.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n-\t\tinternalArray = tempArray;\n-\t}\n-\n-\t/**\n-\t * Adds an element to the end of this expandable array\n-\t * \n-\t * @return value to be added to end of array\n-\t */\n-\tpublic synchronized void addElement(double value) {\n-\t\tnumElements++;\n-\t\tif ( (startIndex + numElements) > internalArray.length) {\n-\t\t\texpand();\n-\t\t}\n-\t\tinternalArray[startIndex + (numElements - 1)] = value;\n-\t}\n-\t\n-\t/**\n-\t * Adds an element and moves the window of elements up one.  This\n-\t * has the effect of a FIFO.  when you \"roll\" the array an element is removed \n-\t * from the array.  The return value of this function is the discarded double.\n-\t * \n-\t * @return the value which has been discarded or \"pushed\" out of the array\n-\t * \t  by this rolling insert.\n-\t */\n-\tpublic synchronized double addElementRolling(double value) {\n-\t\tdouble discarded = internalArray[startIndex];\n-\t\t\n-\t\tif ( (startIndex + (numElements+1) ) > internalArray.length) {\n-\t\t\texpand();\n-\t\t}\n-\t\t// Increment the start index\n-\t\tstartIndex += 1;\n-\t\t\n-\t\t// Add the new value\n-\t\tinternalArray[startIndex + (numElements - 1)] = value;\n-\t\t\n-\t\treturn discarded;\n-\t}\n-\n-\n-\t/**\n-\t * Notice the package scope on this method.   This method is simply here for the JUnit\n-\t * test, it allows us check if the expansion is working properly after a number of expansions.  This\n-\t * is not meant to be a part of the public interface of this class.\n-\t * \n-\t * @return the length of the internal storage array.\n-\t */\n-\tint getInternalLength() {\n-\t\treturn (internalArray.length);\n-\t}\n-\t\n-\t/**\n-\t * Clear the array, reset the size to the initialCapacity and the number of elements to zero\n-\t */\n-\tpublic synchronized void clear() {\n-\t\tnumElements = 0;\n-\t\tinternalArray = new double[initialCapacity];\n-\t}\n-\n-\t/**\n-\t * Discards values from the front of the list.  This function removes n elements from\n-\t * the front of the array.\n-\t * \n-\t * @param i number of elements to discard from the front of the array.\n-\t */\n-\tpublic synchronized void discardFrontElements(int i) {\n-\t\t\n-\t\tif( i > numElements ) {\n-\t\t\tthrow new IllegalArgumentException( \"Cannot discard more elements than are\" +\n-\t\t\t\t\"contained in this array.\");\n-\t\t} else if( i < 0 ) {\n-\t\t\tthrow new IllegalArgumentException( \"Cannot discard a negative number\" +\n-\t\t\t\t\" of elements.\");\n-\t\t} else {\n-\t\t\t// \"Subtract\" this number of discarded from numElements \n-\t\t\tnumElements -= i;\n-\t\t\tstartIndex += i;\n-\t\t}\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getElements()\n-\t */\n-\tpublic double[] getElements() {\n-\t\tdouble[] elementArray = new double[numElements];\n-\t\tSystem.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\n-\t\treturn elementArray;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getMax()\n-\t */\n-\tpublic double getMax() {\n-\t\tdouble max = internalArray[startIndex];\n-\t\t\n-\t\tfor( int i = startIndex + 1; i < (numElements + startIndex); i++) {\n-\t\t\tif( internalArray[i] > max ) {\n-\t\t\t\tmax = internalArray[i];\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn max;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getMin()\n-\t */\n-\tpublic double getMin() {\n-\t\tdouble min = internalArray[startIndex];\n-\t\t\n-\t\tfor( int i = startIndex + 1; i < (numElements + startIndex); i++) {\n-\t\t\tif( internalArray[i] < min ) {\n-\t\t\t\tmin = internalArray[i];\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn min;\n-\t}\n-\n+        for (int i = startIndex + 1; i < (numElements + startIndex); i++) {\n+            if (internalArray[i] > max) {\n+                max = internalArray[i];\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getMin()\n+     */\n+    public double getMin() {\n+        double min = internalArray[startIndex];\n+\n+        for (int i = startIndex + 1; i < (numElements + startIndex); i++) {\n+            if (internalArray[i] < min) {\n+                min = internalArray[i];\n+            }\n+        }\n+\n+        return min;\n+    }\n }\n--- a/src/java/org/apache/commons/math/FixedDoubleArray.java\n+++ b/src/java/org/apache/commons/math/FixedDoubleArray.java\n  */\n public class FixedDoubleArray implements DoubleArray {\n \n-\tdouble[] internalArray;\n-\t\n-\tint size = 0;\n-\tint nextAdd = 0;\n-\tint maxElements = 0;\n-\n-\tpublic FixedDoubleArray(int maxElements) {\n-\t\tthis.maxElements = maxElements;\n-\t\tinternalArray = new double[maxElements];\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getNumElements()\n-\t */\n-\tpublic int getNumElements() {\n-\t\treturn size;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getElement(int)\n-\t */\n-\tpublic double getElement(int index) throws NoSuchElementException {\n-\t\tif( index > (size-1) ) {\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Attempted to retrieve an element outside of\" +\n-\t\t\t\t\"the element array\");\n-\t\t} else {\n-\t\t\treturn internalArray[index];\n+    double[] internalArray;\n+\n+    int size = 0;\n+    int nextAdd = 0;\n+    int maxElements = 0;\n+\n+    public FixedDoubleArray(int maxElements) {\n+        this.maxElements = maxElements;\n+        internalArray = new double[maxElements];\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getNumElements()\n+     */\n+    public int getNumElements() {\n+        return size;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getElement(int)\n+     */\n+    public double getElement(int index) throws NoSuchElementException {\n+        if (index > (size-1)) {\n+            String msg = \"Attempted to retrieve an element outside of \" +\n+                \"the element array\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else {\n+            return internalArray[index];\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n+     */\n+    public void setElement(int index, double value) {\n+        if (index > (size-1)) {\n+            String msg = \"Attempted to set an element outside of\" +\n+\t\t\t\t\"the element array\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else {\n+            internalArray[index] = value;\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#addElement(double)\n+     */\n+    public void addElement(double value) {\n+        if (size < internalArray.length) {\n+            size++;\n+\n+            internalArray[nextAdd] = value;\n+\n+            nextAdd++;\n+            nextAdd = nextAdd % (maxElements);\n+\n+        } else {\n+            String msg = \"Attempted to add a value to an array of fixed \" +\n+                \"size, please use addElementRolling to avoid this exception\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n \t\t}\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n-\t */\n-\tpublic void setElement(int index, double value) {\n-\t\tif( index > (size-1) ) {\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Attempted to set an element outside of\" +\n-\t\t\t\t\"the element array\");\n-\t\t} else {\n-\t\t\tinternalArray[index] = value;\n-\t\t}\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#addElement(double)\n-\t */\n-\tpublic void addElement(double value) {\n-\t\tif( size < internalArray.length ) {\n-\t\t\tsize++;\n-\t\t\t\n-\t\t\tinternalArray[nextAdd] = value;\n-\t\t\t\n-\t\t\tnextAdd++;\n-\t\t\tnextAdd = nextAdd % (maxElements);\n-\n-\t\t} else {\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Attempted to add a value to an array of fixed size, please \" +\n-\t\t\t\t\"use addElementRolling to avoid this exception\");\n-\t\t}\n-\t\t\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#addElementRolling(double)\n-\t */\n-\tpublic double addElementRolling(double value) {\n-\t\tif( size < internalArray.length ) {\n-\t\t\tsize++;\n-\t\t} \n-\t\t\n-\t\tdouble discarded = internalArray[nextAdd];\n-\n-\t\tinternalArray[nextAdd] = value;\n-\n-\t\tnextAdd++;\n-\t\tnextAdd = nextAdd % maxElements;\t\n-\t\t\n-\t\t// but we return the value which was \"replaced\"\n-\t\treturn( discarded );\t\t\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getElements()\n-\t */\n-\tpublic double[] getElements() {\n-\t\tdouble[] copy = new double[internalArray.length];\n-\t\tSystem.arraycopy(internalArray, 0, copy, 0, internalArray.length);\n-\t\treturn copy;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#clear()\n-\t */\n-\tpublic void clear() {\n-\t\tsize = 0;\n-\t\tnextAdd = 0;\n-\t\tinternalArray = new double[maxElements];\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#discardFrontElements(int)\n-\t */\n-\tpublic void discardFrontElements(int i) {\n-\t\t// TODO: AH! implemented there is not concept of \"front\"\n-\t\t// in an array that discards values when rolling.....  anyone?\n-\t\tthrow new RuntimeException(\"Discarding front element not supported in FixedDoubleArray\");\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getMin()\n-\t */\n-\tpublic double getMin() {\n-\t\tdouble min = internalArray[0];\n-\t\tfor( int i = 1; i < size; i++) {\n-\t\t\tif( internalArray[i] < min ) {\n-\t\t\t\tmin = internalArray[i];\n-\t\t\t}\n-\t\t}\n-\t\treturn min;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.DoubleArray#getMax()\n-\t */\n-\tpublic double getMax() {\n-\t\tdouble max = internalArray[0];\n-\t\tfor( int i = 1; i < size; i++) {\n-\t\t\tif( internalArray[i] > max ) {\n-\t\t\t\tmax = internalArray[i];\n-\t\t\t}\n-\t\t}\n-\t\treturn max;\n-\t}\n-\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#addElementRolling(double)\n+     */\n+    public double addElementRolling(double value) {\n+        if (size < internalArray.length) {\n+            size++;\n+        } \n+\n+        double discarded = internalArray[nextAdd];\n+\n+        internalArray[nextAdd] = value;\n+\n+        nextAdd++;\n+        nextAdd = nextAdd % maxElements;\t\n+\n+        // but we return the value which was \"replaced\"\n+        return (discarded);\t\t\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getElements()\n+     */\n+    public double[] getElements() {\n+        double[] copy = new double[internalArray.length];\n+        System.arraycopy(internalArray, 0, copy, 0, internalArray.length);\n+        return copy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#clear()\n+     */\n+    public void clear() {\n+        size = 0;\n+        nextAdd = 0;\n+        internalArray = new double[maxElements];\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#discardFrontElements(int)\n+     */\n+    public void discardFrontElements(int i) {\n+        // TODO: AH! implemented there is not concept of \"front\"\n+        // in an array that discards values when rolling.....  anyone?\n+        String msg = \"Discarding front element not supported in \" +\n+            \"FixedDoubleArray\";\n+        throw new RuntimeException(msg);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getMin()\n+     */\n+    public double getMin() {\n+        double min = internalArray[0];\n+        for (int i = 1; i < size; i++) {\n+            if (internalArray[i] < min) {\n+                min = internalArray[i];\n+            }\n+        }\n+        return min;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getMax()\n+     */\n+    public double getMax() {\n+        double max = internalArray[0];\n+        for (int i = 1; i < size; i++) {\n+            if (internalArray[i] > max) {\n+                max = internalArray[i];\n+            }\n+        }\n+        return max;\n+    }\n }\n--- a/src/java/org/apache/commons/math/ListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/ListUnivariateImpl.java\n  */\n public class ListUnivariateImpl extends AbstractStoreUnivariate {\n \n-\t// Holds the value of the windowSize, initial windowSize is the constant\n-\t// Univariate.INFINITE_WINDOW\n-\tprivate int windowSize = Univariate.INIFINTE_WINDOW;\n+    // Holds the value of the windowSize, initial windowSize is the constant\n+    // Univariate.INFINITE_WINDOW\n+    private int windowSize = Univariate.INIFINTE_WINDOW;\n \n-\t// Holds a reference to a list - GENERICs are going to make\n-\t// out lives easier here as we could only accept List<Number>\n-\tList list;\n+    // Holds a reference to a list - GENERICs are going to make\n+    // out lives easier here as we could only accept List<Number>\n+    List list;\n \n-\tpublic ListUnivariateImpl( List list ) {\n-\t\tthis.list = list;\n-\t}\n+    public ListUnivariateImpl(List list) {\n+        this.list = list;\n+    }\n \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.StoreUnivariate#getValues()\n+     */\n+    public double[] getValues() {\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getValues()\n-\t */\n-\tpublic double[] getValues() {\n+        // If we've got a windowSize, we might not care about the entire list.\n+        List effectiveList = list;\n \n-\t\t// If we've got a windowSize, we might not care about the entire list.\n-\t\tList effectiveList = list;\n-\t\t\n-\t\t// If the window size is not INIFINITE_WINDOW AND\n-\t\t// the current list is larger that the window size, we need to\n-\t\t// take into account only the last n elements of the list\n-\t\t// as definied by windowSize\n-\t\tif( windowSize != Univariate.INIFINTE_WINDOW &&\n-\t\t\twindowSize < list.size() ) {\n-\t\t\teffectiveList = list.subList( (list.size() - 1) - windowSize, (list.size()-1));\n-\t\t}\n+        // If the window size is not INIFINITE_WINDOW AND\n+        // the current list is larger that the window size, we need to\n+        // take into account only the last n elements of the list\n+        // as definied by windowSize\n+        if (windowSize != Univariate.INIFINTE_WINDOW &&\n+            windowSize < list.size()) {\n+            effectiveList = list.subList((list.size() - 1) - windowSize, \n+                                          (list.size()-1));\n+        }\n \n-\t\t// Create an array to hold all values\n-\t\tdouble[] copiedArray = new double[effectiveList.size()];\n+        // Create an array to hold all values\n+        double[] copiedArray = new double[effectiveList.size()];\n \n-\t\tint i = 0;\n-\t\tIterator it = effectiveList.iterator();\n-\t\twhile( it.hasNext() ) {\n-\t\t\tNumber n = (Number) it.next();\n-\t\t\tcopiedArray[i] = n.doubleValue();\n-\t\t\ti++;\n-\t\t}\n+        int i = 0;\n+        Iterator it = effectiveList.iterator();\n+        while(it.hasNext()) {\n+            Number n = (Number) it.next();\n+            copiedArray[i] = n.doubleValue();\n+            i++;\n+        }\n \n-\t\treturn copiedArray;\n-\t}\n+        return copiedArray;\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n-\t */\n-\tpublic double getElement(int index) {\n-\t\t\n-\t\tdouble value = Double.NaN;\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n+     */\n+    public double getElement(int index) {\n \n-\t\tif( windowSize != Univariate.INIFINTE_WINDOW &&\n-\t\t\t windowSize < list.size() ) {\n-\t\t\tNumber n = (Number) list.get( ( (list.size() - 1) - windowSize ) + index ) ;\n-\t\t\tvalue = n.doubleValue();\n-\t\t} else {\n-\t\t\tNumber n = (Number) list.get(index);\n-\t\t\tvalue = n.doubleValue();\n-\t\t}\n-\t\t\n-\t\treturn value;\n-\t}\n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getN()\n-\t */\n-\tpublic double getN() {\n-\t\tdouble N = 0.0;\n-\t\t\n-\t\tif( windowSize != Univariate.INIFINTE_WINDOW ) {\n-\t\t\tif( list.size() > windowSize ) {\n-\t\t\t\tN = windowSize;\n-\t\t\t} else {\n-\t\t\t\tN = list.size();\n-\t\t\t}\n-\t\t} else {\n-\t\t\tN = list.size();\n-\t\t}\n-\t\t\n-\t\treturn N;\n-\t}\n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#addValue(double)\n-\t */\n-\tpublic void addValue(double v) {\n-\t\tlist.add( new Double(v));\n-\t}\n+        double value = Double.NaN;\n+        if (windowSize != Univariate.INIFINTE_WINDOW &&\n+            windowSize < list.size()) {\n+            Number n = (Number) list.get(((list.size() - 1) - windowSize) +\n+                                          index) ;\n+            value = n.doubleValue();\n+        } else {\n+            Number n = (Number) list.get(index);\n+            value = n.doubleValue();\n+        }\n+        return value;\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#clear()\n-\t */\n-\tpublic void clear() {\n-\t\tlist.clear();\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#getN()\n+     */\n+    public double getN() {\n+        double N = 0.0;\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getWindowSize()\n-\t */\n-\tpublic int getWindowSize() {\n-\t\treturn windowSize;\n-\t}\n+        if (windowSize != Univariate.INIFINTE_WINDOW) {\n+            if (list.size() > windowSize) {\n+                N = windowSize;\n+            } else {\n+                N = list.size();\n+            }\n+        } else {\n+            N = list.size();\n+        }\n+        return N;\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-\t */\n-\tpublic void setWindowSize(int windowSize) {\n-\t\tthis.windowSize = windowSize;\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#addValue(double)\n+     */\n+    public void addValue(double v) {\n+        list.add(new Double(v));\n+    }\n \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#clear()\n+     */\n+    public void clear() {\n+        list.clear();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#getWindowSize()\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     */\n+    public void setWindowSize(int windowSize) {\n+        this.windowSize = windowSize;\n+    }\n }\n--- a/src/java/org/apache/commons/math/StoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/StoreUnivariate.java\n  */\n public interface StoreUnivariate extends Univariate {\n \n-\t/**\n-\t * A LEPTOKURTIC set has a positive kurtosis (a high peak) \n-\t */\n-\tpublic static int LEPTOKURTIC = 1;\n-\t\n-\t/**\n-\t * A MESOKURTIC set has a kurtosis of 0 - it is a normal distribution\n-\t */\n-\tpublic static int MESOKURTIC = 0;\n-\t\n-\t/**\n-\t * A PLATYKURTIC set has a negative kurtosis (a flat \"peak\")\n-\t */\n-\tpublic static int PLATYKURTIC = -1;\n+    /**\n+     * A LEPTOKURTIC set has a positive kurtosis (a high peak) \n+     */\n+    public static int LEPTOKURTIC = 1;\n \n-\t/** \n-\t * Returns the mode of the values that have been added.  The mode is\n-\t * the element which occurs with the most frequency\n-\t * @return the mode\n-\t */\n-\tpublic abstract double getMode();\n+    /**\n+     * A MESOKURTIC set has a kurtosis of 0 - it is a normal distribution\n+     */\n+    public static int MESOKURTIC = 0;\n \n-\t/** \n-\t * Returns the skewness of a given distribution.  Skewness is a measure of the\n-\t * assymetry of a given distribution. \n-\t * \n-\t * @return The skewness of this distribution\n-\t */\n-\tpublic abstract double getSkewness();\n+    /**\n+     * A PLATYKURTIC set has a negative kurtosis (a flat \"peak\")\n+     */\n+    public static int PLATYKURTIC = -1;\n \n-\t/** \n-\t * Kurtosis is a measure of the \"peakedness\" of a distribution\n-\t * \n-\t * @return the mode\n-\t */\n-\tpublic abstract double getKurtosis();\n-\t\n-\t/**\n-\t * Returns the Kurtosis \"classification\" a distribution can be leptokurtic (high peak), platykurtic (flat peak), \n-\t * or mesokurtic (zero kurtosis).  \n-\t * \n-\t * @return A static constant defined in this interface, StoredDeviation.LEPTOKURITC, \n-\t * \t\t\t    StoredDeviation.PLATYKURTIC, or StoredDeviation.MESOKURTIC\n-\t */\n-\tpublic abstract int getKurtosisClass();\n-\t\n-\t/**\n-\t * Returns the current set of values in an array of double primitives.  The order of addition is preserved\n-\t * \n-\t * @return returns the current set of numbers in the order in which they were added to this set\n-\t */\n-\tpublic abstract double[] getValues();\n-\t\n-\t/**\n-\t * Returns the element at the specified index\n-\t * \n-\t * @return return the element at the specified index\n-\t */\n-\tpublic abstract double getElement(int index);\n+    /** \n+     * Returns the mode of the values that have been added.  The mode is\n+     * the element which occurs with the most frequency\n+     * @return the mode\n+     */\n+    public abstract double getMode();\n+\n+    /** \n+     * Returns the skewness of a given distribution.  Skewness is a \n+     * measure of the assymetry of a given distribution. \n+     * \n+     * @return The skewness of this distribution\n+     */\n+    public abstract double getSkewness();\n+\n+    /** \n+     * Kurtosis is a measure of the \"peakedness\" of a distribution\n+     * \n+     * @return the mode\n+     */\n+    public abstract double getKurtosis();\n+\n+    /**\n+     * Returns the Kurtosis \"classification\" a distribution can be \n+     * leptokurtic (high peak), platykurtic (flat peak), \n+     * or mesokurtic (zero kurtosis).  \n+     * \n+     * @return A static constant defined in this interface, \n+     *         StoredDeviation.LEPTOKURITC, StoredDeviation.PLATYKURTIC, or \n+     *         StoredDeviation.MESOKURTIC\n+     */\n+    public abstract int getKurtosisClass();\n+\n+    /**\n+     * Returns the current set of values in an array of double primitives.  \n+     * The order of addition is preserved\n+     * \n+     * @return returns the current set of numbers in the order in which they \n+     *         were added to this set\n+     */\n+    public abstract double[] getValues();\n+\n+    /**\n+     * Returns the element at the specified index\n+     * \n+     * @return return the element at the specified index\n+     */\n+    public abstract double getElement(int index);\n \n }\n--- a/src/java/org/apache/commons/math/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/StoreUnivariateImpl.java\n  */\n public class StoreUnivariateImpl extends AbstractStoreUnivariate {\n \n-\t// Use an internal double array\n-\tDoubleArray eDA;\n-\t\n-\t// Store the windowSize\n-\tprivate int windowSize = Univariate.INIFINTE_WINDOW;\n+    // Use an internal double array\n+    DoubleArray eDA;\n \n-\tpublic StoreUnivariateImpl() {\n-\t\t// A contractable double array is used.  memory is reclaimed when\n-\t\t// the storage of the array becomes too empty.\n-\t\teDA = new ContractableDoubleArray();\n-\t}\n+    // Store the windowSize\n+    private int windowSize = Univariate.INIFINTE_WINDOW;\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getValues()\n-\t */\n-\tpublic double[] getValues() {\n+    public StoreUnivariateImpl() {\n+        // A contractable double array is used.  memory is reclaimed when\n+        // the storage of the array becomes too empty.\n+        eDA = new ContractableDoubleArray();\n+    }\n \n-\t\tdouble[] copiedArray = new double[ eDA.getNumElements() ];\n-\t\tSystem.arraycopy( eDA.getElements(), 0, copiedArray, 0, eDA.getNumElements());\n-\t\treturn copiedArray;\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.StoreUnivariate#getValues()\n+     */\n+    public double[] getValues() {\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n-\t */\n-\tpublic double getElement(int index) {\n-\t\treturn eDA.getElement(index);\n-\t}\n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getN()\n-\t */\n-\tpublic double getN() {\n-\t\treturn eDA.getNumElements();\n-\t}\n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#addValue(double)\n-\t */\n-\tpublic synchronized void addValue(double v) {\n-\t\tif( windowSize != Univariate.INIFINTE_WINDOW ) {\n-\t\t\tif( getN() == windowSize ) {\n-\t\t\t\teDA.addElementRolling( v );\n-\t\t\t} else if( getN() < windowSize ) {\n-\t\t\t\teDA.addElement(v);\n-\t\t\t} else {\n-\t\t\t\tthrow new RuntimeException( \"A window Univariate had more element than \" +\n-\t\t\t\t\t\"the windowSize.  This is an inconsistent state.\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\teDA.addElement(v);\n-\t\t}\n-\t}\n+        double[] copiedArray = new double[ eDA.getNumElements() ];\n+        System.arraycopy( eDA.getElements(), 0, \n+                          copiedArray, 0, eDA.getNumElements());\n+        return copiedArray;\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#clear()\n-\t */\n-\tpublic synchronized void clear() {\n-\t\teDA.clear();\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n+     */\n+    public double getElement(int index) {\n+        return eDA.getElement(index);\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getWindowSize()\n-\t */\n-\tpublic int getWindowSize() {\n-\t\treturn windowSize;\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#getN()\n+     */\n+    public double getN() {\n+        return eDA.getNumElements();\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-\t */\n-\tpublic synchronized void setWindowSize(int windowSize) {\n-\t\tthis.windowSize = windowSize;\n-\t\t\n-\t\t// We need to check to see if we need to discard elements\n-\t\t// from the front of the array.  If the windowSize is less than \n-\t\t// the current number of elements.\n-\t\tif( windowSize < eDA.getNumElements() ) {\n-\t\t\teDA.discardFrontElements( eDA.getNumElements() - windowSize);\n-\t\t}\n-\t\t\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#addValue(double)\n+     */\n+    public synchronized void addValue(double v) {\n+        if( windowSize != Univariate.INIFINTE_WINDOW ) {\n+            if( getN() == windowSize ) {\n+                eDA.addElementRolling( v );\n+            } else if( getN() < windowSize ) {\n+                eDA.addElement(v);\n+            } else {\n+                String msg = \"A window Univariate had more element than \" +\n+\t\t\t\t\t\"the windowSize.  This is an inconsistent state.\";\n+                throw new RuntimeException( msg );\n+            }\n+        } else {\n+            eDA.addElement(v);\n+        }\n+    }\n \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#clear()\n+     */\n+    public synchronized void clear() {\n+        eDA.clear();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#getWindowSize()\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     */\n+    public synchronized void setWindowSize(int windowSize) {\n+        this.windowSize = windowSize;\n+\n+        // We need to check to see if we need to discard elements\n+        // from the front of the array.  If the windowSize is less than \n+        // the current number of elements.\n+        if( windowSize < eDA.getNumElements() ) {\n+            eDA.discardFrontElements( eDA.getNumElements() - windowSize);\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/math/Univariate.java\n+++ b/src/java/org/apache/commons/math/Univariate.java\n  *\n  * @author Phil Steitz\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @version $Revision: 1.3 $ $Date: 2003/05/16 05:23:29 $\n+ * @version $Revision: 1.4 $ $Date: 2003/05/20 18:15:29 $\n  * \n */\n public interface Univariate {\n-\t\n-\t/**\n-\t * Adds the value to the set of numbers\n-\t * @param v the value to be added \n-\t */\n-\tpublic abstract void addValue(double v);\n-\t\n-\t/** \n-\t * Returns the mean of the values that have been added\n-\t * @return mean value\n-\t */\n-\tpublic abstract double getMean();\n \n-\t/** \n-\t * Returns the variance of the values that have been added\n-\t * @return variance value\n-\t */\n-\tpublic abstract double getVariance();\n+    /**\n+     * Adds the value to the set of numbers\n+     * @param v the value to be added \n+     */\n+    public abstract void addValue(double v);\n \n-\t/** \n-\t * Returns the standard deviation of the values that have been added\n-\t * @return standard deviation value\n-\t */\n-\tpublic abstract double getStandardDeviation();\n+    /** \n+     * Returns the mean of the values that have been added\n+     * @return mean value\n+     */\n+    public abstract double getMean();\n \n-\t/** Getter for property max.\n-\t * @return Value of property max.\n-\t */\n-\tpublic abstract double getMax();\n+    /** \n+     * Returns the variance of the values that have been added\n+     * @return variance value\n+     */\n+    public abstract double getVariance();\n \n-\t/** Getter for property min.\n-\t * @return Value of property min.\n-\t */\n-\tpublic abstract double getMin();\n+    /** \n+     * Returns the standard deviation of the values that have been added\n+     * @return standard deviation value\n+     */\n+    public abstract double getStandardDeviation();\n \n-\t/** Getter for property n.\n-\t * @return Value of property n.\n-\t */\n-\tpublic abstract double getN();\n+    /** Getter for property max.\n+     * @return Value of property max.\n+     */\n+    public abstract double getMax();\n \n-\t/** Getter for property sum.\n-\t * @return Value of property sum.\n-\t */\n-\tpublic abstract double getSum();\n+    /** Getter for property min.\n+     * @return Value of property min.\n+     */\n+    public abstract double getMin();\n \n-\t/** Getter for property sumsq.\n-\t * @return Value of property sumsq.\n-\t */\n-\tpublic abstract double getSumsq();\n+    /** Getter for property n.\n+     * @return Value of property n.\n+     */\n+    public abstract double getN();\n \n-\t/** Resets all sums to 0, resets min and max */\n-\tpublic abstract void clear();\n-\t\n-\t/**\n-\t * This constant signals that a Univariate implementation\n-\t * takes into account the contributions of an infinite number of\n-\t * elements.  In other words, if getWindow returns this\n-\t * constant, there is, in effect, no \"window\".\n-\t */\n-\tpublic static final int INIFINTE_WINDOW = -1;\n+    /** Getter for property sum.\n+     * @return Value of property sum.\n+     */\n+    public abstract double getSum();\n \n-\t/**\n-\t * Univariate has the ability to return only measures for the\n-\t * last N elements added to the set of values.  This function returns\n-\t */\n-\tpublic abstract int getWindowSize();\n-\t\n-\t/**\n-\t * Sets the window.  windowSize controls the number of value\n-\t * which contribute to the values returned by Univariate.  \n-\t * For example, a window value of 10 means that getMean()\n-\t * will return the mean of the last 10 values added.\n-\t */\n-\tpublic abstract void setWindowSize(int windowSize);\n-}\n+    /** Getter for property sumsq.\n+     * @return Value of property sumsq.\n+     */\n+    public abstract double getSumsq();\n+\n+    /** Resets all sums to 0, resets min and max */\n+    public abstract void clear();\n+\n+    /**\n+     * This constant signals that a Univariate implementation\n+     * takes into account the contributions of an infinite number of\n+     * elements.  In other words, if getWindow returns this\n+     * constant, there is, in effect, no \"window\".\n+     */\n+    public static final int INIFINTE_WINDOW = -1;\n+\n+    /**\n+     * Univariate has the ability to return only measures for the\n+     * last N elements added to the set of values.  This function returns\n+     */\n+    public abstract int getWindowSize();\n+\n+    /**\n+     * Sets the window.  windowSize controls the number of value\n+     * which contribute to the values returned by Univariate.  \n+     * For example, a window value of 10 means that getMean()\n+     * will return the mean of the last 10 values added.\n+     */\n+    public abstract void setWindowSize(int windowSize);\n+}\n--- a/src/java/org/apache/commons/math/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/UnivariateImpl.java\n  * to doubles by addValue().  \n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.4 $ $Date: 2003/05/17 23:24:21 $\n+ * @version $Revision: 1.5 $ $Date: 2003/05/20 18:15:29 $\n  * \n */\n public class UnivariateImpl implements Univariate, Serializable {\n \n-\t/** hold the window size **/\n-\tprivate int windowSize = Univariate.INIFINTE_WINDOW;\n-\t\n-\t/** Just in case, the windowSize is not inifinite, we need to\n-\t *   keep an array to remember values 0 to N\n-\t */\n-\tprivate DoubleArray doubleArray;\n-\t\n+    /** hold the window size **/\n+    private int windowSize = Univariate.INIFINTE_WINDOW;\n+\n+    /** Just in case, the windowSize is not inifinite, we need to\n+     *   keep an array to remember values 0 to N\n+     */\n+    private DoubleArray doubleArray;\n+\n     /** running sum of values that have been added */\n     private double sum = 0.0;\n \n     \n     /** Create a new univariate with a fixed window **/\n     public UnivariateImpl(int window) {\n-    \twindowSize = window;\n-   \t\tdoubleArray = new FixedDoubleArray( window );\n-     }\n+        windowSize = window;\n+        doubleArray = new FixedDoubleArray( window );\n+    }\n \n     /**\n      * Adds the value, updating running sums.\n     /** \n      * Returns the variance of the values that have been added. \n      * @return The variance of a set of values.  Double.NaN is returned for\n-     * \t           an empty set of values and 0.0 is returned for a single value set.\n+     *         an empty set of values and 0.0 is returned for a single value set.\n      */\n     public double getVariance() {\n-    \tdouble variance = Double.NaN;\n-    \t\n-    \tif( n == 1 ) {\n-\t\t\tvariance = 0.0;\n-    \t} else if( n > 1 ) {\n-\t\t\tdouble xbar = getMean();\n-\t\t\tvariance =  (sumsq - xbar*xbar*n)/(n-1);\n-    \t}\n-    \t\n-    \treturn variance;\n+        double variance = Double.NaN;\n+\n+        if( n == 1 ) {\n+            variance = 0.0;\n+        } else if( n > 1 ) {\n+            double xbar = getMean();\n+            variance =  (sumsq - xbar*xbar*n)/(n-1);\n+        }\n+\n+        return variance;\n     }\n \n     /** \n      * Returns the standard deviation of the values that have been added\n-     * @return The standard deviation of a set of values.  Double.NaN is returned for\n-     * \t\t       an empty set of values and 0.0 is returned for a single value set.\n+     * @return The standard deviation of a set of values.  Double.NaN is \n+     *         returned for an empty set of values and 0.0 is returned for \n+     *         a single value set.\n      */\n     public double getStandardDeviation() {\n         return (new Double(Math.sqrt\n      * @param v the value to be added \n      */\n     private void insertValue(double v) {\n-    \t\n-    \tif( windowSize != Univariate.INIFINTE_WINDOW ) {\n-    \t\tif( windowSize == n ) {\n-\t\t\t\tdouble discarded = doubleArray.addElementRolling( v );        \t\n-\t\t\t\n-\t\t\t\t// Remove the influence of discarded value ONLY\n-\t\t\t\t// if the discard value has any meaning.  In other words\n-\t\t\t\t// don't discount until we \"roll\".\n-\t\t\t\tif( windowSize > doubleArray.getNumElements() ) {\n-\t\t\t\t\t// Remove the influence of the discarded\n-\t\t\t\t\tsum -= discarded;\n-\t\t\t\t\tsumsq -= discarded * discarded;\n-\t\t\t\t}\n-\t\t\t\n-\t\t\t\t// Include the influence of the new\n-\t\t\t\t// TODO: The next two lines seems rather expensive, but\n-\t\t\t\t// I don't see many alternatives.\t\t\t \n-\t\t\t\tmin = doubleArray.getMin();\n-\t\t\t\tmax = doubleArray.getMax();\n-\t\t\t\tsum += v;\n-\t\t\t\tsumsq += v*v;\n-    \t\t} else {\n-\t\t\t\tdoubleArray.addElement( v );        \t\n-\t        \tn += 1.0;\n-    \t    \tif (v < min) min = v;\n-       \t\t\tif (v > max) max = v;\n-        \t\tsum += v;\n-        \t\tsumsq += v*v;\n-    \t\t}\n-    \t} else {\n-\t\t\t// If the windowSize is inifinite please don't take the time to\n-\t\t\t// worry about storing any values.  We don't need to discard the\n-\t\t\t// influence of any single item.\n-\t\t\tn += 1.0;\n-\t\t\tif (v < min) min = v;\n-\t\t\tif (v > max) max = v;\n-\t\t\tsum += v;\n-\t\t\tsumsq += v*v;\n-    \t}\n+\n+        if( windowSize != Univariate.INIFINTE_WINDOW ) {\n+            if( windowSize == n ) {\n+                double discarded = doubleArray.addElementRolling( v );\n+\n+                // Remove the influence of discarded value ONLY\n+                // if the discard value has any meaning.  In other words\n+                // don't discount until we \"roll\".\n+                if( windowSize > doubleArray.getNumElements() ) {\n+                    // Remove the influence of the discarded\n+                    sum -= discarded;\n+                    sumsq -= discarded * discarded;\n+                }\n+\n+                // Include the influence of the new\n+                // TODO: The next two lines seems rather expensive, but\n+                // I don't see many alternatives.\t\t\t \n+                min = doubleArray.getMin();\n+                max = doubleArray.getMax();\n+                sum += v;\n+                sumsq += v*v;\n+            } else {\n+                doubleArray.addElement( v );        \t\n+                n += 1.0;\n+                if (v < min) min = v;\n+                if (v > max) max = v;\n+                sum += v;\n+                sumsq += v*v;\n+            }\n+        } else {\n+            // If the windowSize is inifinite please don't take the time to\n+            // worry about storing any values.  We don't need to discard the\n+            // influence of any single item.\n+            n += 1.0;\n+            if (v < min) min = v;\n+            if (v > max) max = v;\n+            sum += v;\n+            sumsq += v*v;\n+        }\n     }\n \n     /** Getter for property max.\n         this.max = Double.MIN_VALUE;\n     }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getWindowSize()\n-\t */\n-\tpublic int getWindowSize() {\n-\t\treturn windowSize;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-\t */\n-\tpublic void setWindowSize(int windowSize) {\n-\t\tthrow new RuntimeException( \"A fixed window size must be set via the UnivariateImpl constructor\");\n-\t}\n-\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#getWindowSize()\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     */\n+    public void setWindowSize(int windowSize) {\n+        String msg = \"A fixed window size must be set via the \" +\n+            \"UnivariateImpl constructor\";\n+        throw new RuntimeException( msg );\n+    }\n }", "timestamp": 1053454529, "metainfo": ""}