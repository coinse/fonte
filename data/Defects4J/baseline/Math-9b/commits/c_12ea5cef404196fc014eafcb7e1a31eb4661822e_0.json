{"sha": "12ea5cef404196fc014eafcb7e1a31eb4661822e", "log": "fixed various errors and warnings detected by checkstyle and findbugs  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static ArithmeticException createArithmeticException(final String pattern,\n                                                                 final Object[] arguments) {\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static ArrayIndexOutOfBoundsException createArrayIndexOutOfBoundsException(final String pattern,\n                                                                                       final Object[] arguments) {\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static EOFException createEOFException(final String pattern,\n                                                   final Object[] arguments) {\n      * with Java 6.</p>\n      * @param rootCause the exception or error that caused this exception\n      * to be thrown.\n+     * @return built exception\n      */\n     public static IOException createIOException(final Throwable rootCause) {\n         IOException ioe = new IOException(rootCause.getLocalizedMessage());\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static IllegalArgumentException createIllegalArgumentException(final String pattern,\n                                                                           final Object[] arguments) {\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static IllegalStateException createIllegalStateException(final String pattern,\n                                                                     final Object[] arguments) {\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static ConcurrentModificationException createConcurrentModificationException(final String pattern,\n                                                                                         final Object[] arguments) {\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @return built exception\n      */\n     public static NoSuchElementException createNoSuchElementException(final String pattern,\n                                                                       final Object[] arguments) {\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @param offset offset at which error occurred\n+     * @return built exception\n      */\n     public static ParseException createParseException(final String pattern,\n                                                       final Object[] arguments,\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n      * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n      * the case.</p>\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n--- a/src/java/org/apache/commons/math/analysis/MullerSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/MullerSolver.java\n      * <p>\n      * The formulas here do not use divided differences directly.</p>\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n     /**\n      * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value where the function is zero\n     /**\n      * Find a zero near the value <code>startValue</code>.\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval (ignored).\n      * @param max the upper bound for the interval (ignored).\n      * @param startValue the start value to use.\n--- a/src/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ZipfDistribution.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class ZipfDistributionImpl extends AbstractIntegerDistribution \n     implements ZipfDistribution, Serializable {\n+\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -140627372283420404L;\n \n+    /** Number of elements. */\n     private int numberOfElements;\n+\n+    /** Exponent parameter of the distribution. */\n     private double exponent;\n \n     /**\n      * exponent. Both values must be positive; otherwise an \n      * <code>IllegalArgumentException</code> is thrown.\n      * \n-     * @param n the number of elements\n-     * @param s the exponent\n+     * @param numberOfElements the number of elements\n+     * @param exponent the exponent\n      * @exception IllegalArgumentException if n &le; 0 or s &le; 0.0\n      */\n     public ZipfDistributionImpl(final int numberOfElements, final double exponent)\n--- a/src/java/org/apache/commons/math/genetics/Fitness.java\n+++ b/src/java/org/apache/commons/math/genetics/Fitness.java\n  */\n package org.apache.commons.math.genetics;\n \n-public interface Fitness extends Comparable {\n+/**\n+ * Interface used to compare chromosomes.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface Fitness extends Comparable<Fitness> {\n }\n--- a/src/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n     /**\n      * <p>Evolve the given population into the next generation.</p>\n      * <p><ol>\n-     *    <li>Get nextGeneration polulation to fill from <code>current</code>\n+     *    <li>Get nextGeneration population to fill from <code>current</code>\n      *        generation, using its nextGeneration method</li>\n      *    <li>Loop until new generation is filled:</li>\n      *    <ul><li>Apply configured SelectionPolicy to select a pair of parents\n--- a/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n     boolean isNonSingular();\n \n     /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n-     * @param decomposition decomposition of the matrix A\n      * @return inverse matrix\n      * @throws InvalidMatrixException if decomposed matrix is singular\n      */\n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n      * Calculates the eigen decomposition of the given tridiagonal symmetric matrix. \n      * <p>Calling this constructor is equivalent to first call the no-arguments\n      * constructor and then call {@link #decompose(double[], double[])}.</p>\n-     * @param main the main diagonal of the matrix\n-     * @param secondary the secondary diagonal of the matrix\n+     * @param main the main diagonal of the matrix (will be copied)\n+     * @param secondary the secondary diagonal of the matrix (will be copied)\n      * @param splitTolerance tolerance on the off-diagonal elements relative to the\n      * geometric mean to split the tridiagonal matrix (a suggested value is\n      * {@link MathUtils#SAFE_MIN})\n             final double splitTolerance)\n         throws InvalidMatrixException {\n \n-        this.main      = main;\n-        this.secondary = secondary;\n+        this.main      = main.clone();\n+        this.secondary = secondary.clone();\n         transformer    = null;\n \n         // pre-compute some elements\n         if (eigenvectors == null) {\n             findEigenVectors();\n         }\n-        return new Solver(realEigenvalues, eigenvectors);\n+        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n     }\n \n     /** Specialized solver. */\n         /** Serializable version identifier. */\n         private static final long serialVersionUID = -8965845906036558410L;\n \n-        /** Eigenvalues. */\n-        private final double[] eigenvalues;\n+        /** Real part of the realEigenvalues. */\n+        private double[] realEigenvalues;\n+\n+        /** Imaginary part of the realEigenvalues. */\n+        private double[] imagEigenvalues;\n \n         /** Eigenvectors. */\n         private final RealVectorImpl[] eigenvectors;\n \n         /**\n          * Build a solver from decomposed matrix.\n-         * @param realEigenvalues realEigenvalues\n+         * @param realEigenvalues real parts of the eigenvalues\n+         * @param imagEigenvalues imaginary parts of the eigenvalues\n          * @param eigenvectors eigenvectors\n          */\n-        private Solver(final double[] eigenvalues, final RealVectorImpl[] eigenvectors) {\n-            this.eigenvalues  = eigenvalues;\n-            this.eigenvectors = eigenvectors; \n+        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues,\n+                       final RealVectorImpl[] eigenvectors) {\n+            this.realEigenvalues = realEigenvalues;\n+            this.imagEigenvalues = imagEigenvalues;\n+            this.eigenvectors    = eigenvectors; \n         }\n \n         /** Solve the linear equation A &times; X = B for symmetric matrices A.\n                 throw new SingularMatrixException();\n             }\n \n-            final int m = eigenvalues.length;\n+            final int m = realEigenvalues.length;\n             if (b.length != m) {\n                 throw new IllegalArgumentException(\"constant vector has wrong length\");\n             }\n             for (int i = 0; i < m; ++i) {\n                 final RealVectorImpl v = eigenvectors[i];\n                 final double[] vData = v.getDataRef();\n-                final double s = v.dotProduct(b) / eigenvalues[i];\n+                final double s = v.dotProduct(b) / realEigenvalues[i];\n                 for (int j = 0; j < m; ++j) {\n                     bp[j] += s * vData[j];\n                 }\n                 throw new SingularMatrixException();\n             }\n \n-            final int m = eigenvalues.length;\n+            final int m = realEigenvalues.length;\n             if (b.getDimension() != m) {\n                 throw new IllegalArgumentException(\"constant vector has wrong length\");\n             }\n             for (int i = 0; i < m; ++i) {\n                 final RealVectorImpl v = eigenvectors[i];\n                 final double[] vData = v.getDataRef();\n-                final double s = v.dotProduct(b) / eigenvalues[i];\n+                final double s = v.dotProduct(b) / realEigenvalues[i];\n                 for (int j = 0; j < m; ++j) {\n                     bp[j] += s * vData[j];\n                 }\n                 throw new SingularMatrixException();\n             }\n \n-            final int m = eigenvalues.length;\n+            final int m = realEigenvalues.length;\n             if (b.getRowDimension() != m) {\n                 throw new IllegalArgumentException(\"Incorrect row dimension\");\n             }\n                     for (int j = 0; j < m; ++j) {\n                         s += v.getEntry(j) * b.getEntry(j, k);\n                     }\n-                    s /= eigenvalues[i];\n+                    s /= realEigenvalues[i];\n                     for (int j = 0; j < m; ++j) {\n                         bp[j][k] += s * vData[j];\n                     }\n          * @return true if the decomposed matrix is non-singular\n          */\n         public boolean isNonSingular() {\n-            for (double lambda : eigenvalues) {\n-                if (lambda == 0) {\n+            for (int i = 0; i < realEigenvalues.length; ++i) {\n+                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                     return false;\n                 }\n             }\n                 throw new SingularMatrixException();\n             }\n \n-            final int m = eigenvalues.length;\n+            final int m = realEigenvalues.length;\n             final double[][] invData = new double[m][m];\n \n             for (int i = 0; i < m; ++i) {\n                     double invIJ = 0;\n                     for (int k = 0; k < m; ++k) {\n                         final double[] vK = eigenvectors[k].getDataRef();\n-                        invIJ += vK[i] * vK[j] / eigenvalues[k];\n+                        invIJ += vK[i] * vK[j] / realEigenvalues[k];\n                     }\n                     invI[j] = invIJ;\n                 }\n         throws InvalidMatrixException {\n \n         // check decomposed matrix data range\n-        final int fourN1  = 4 * (n - 1);\n-        double sumDiag    = 0;\n         double sumOffDiag = 0;\n         for (int i = 0; i < n - 1; ++i) {\n             final int fourI = 4 * i;\n-            final double qi = work[fourI];\n             final double ei = work[fourI + 2];\n-            sumDiag    += qi;\n             sumOffDiag += ei;\n         }\n-        final double qi = work[fourN1];\n-        sumDiag += qi;\n \n         if (sumOffDiag == 0) {\n             // matrix is already diagonal\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n      * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n      */\n-    RealMatrix getR() throws IllegalStateException;\n+    RealMatrix getR();\n \n     /**\n      * Returns the matrix Q of the decomposition.\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n \n package org.apache.commons.math.linear;\n \n+import java.io.Serializable;\n+\n /**\n  * Interface defining a real-valued matrix with basic algebraic operations.\n  * <p>\n  * \n  * @version $Revision$ $Date$\n  */\n-public interface RealMatrix {\n+public interface RealMatrix extends Serializable {\n \n     /**\n      * Create a new RealMatrix of the same type as the instance with the supplied\n      *\n      * @param rowDimension  the number of rows in the new matrix\n      * @param columnDimension  the number of columns in the new matrix\n+     * @return a new matrix of the same type as the instance\n      * @throws IllegalArgumentException if row or column dimension is not positive\n      * @since 2.0\n      */\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n     private double[] secondaryBidiagonal;\n \n     /** Main diagonal of the tridiagonal matrix. */\n-    double[] mainTridiagonal;\n+    private double[] mainTridiagonal;\n \n     /** Secondary diagonal of the tridiagonal matrix. */\n-    double[] secondaryTridiagonal;\n+    private double[] secondaryTridiagonal;\n \n     /** Eigen decomposition of the tridiagonal matrix. */\n     private EigenDecomposition eigenDecomposition;\n--- a/src/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n  */\n \n package org.apache.commons.math.random;\n+import java.io.Serializable;\n import java.util.Collection;\n \n /**\n  * Random data generation utilities.\n  * @version $Revision$ $Date$\n  */\n-public interface RandomData {\n+public interface RandomData extends Serializable {\n     /**\n      * Generates a random string of hex characters of length\n      * <code>len</code>.\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n         return Double.NaN;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public Mean copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n         return max;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public Max copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n         return min;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public Min copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n         quantile = p;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public Percentile copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n         return product;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public Product copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n         return sum;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public Sum copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n         return sumLog;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public SumOfLogs copy() {\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n         return sumSq;\n     }\n     \n-    /*\n+    /**\n      * {@inheritDoc}\n      */\n     public SumOfSquares copy() {\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n  */\n public class FastFourierTransformer implements Serializable {\n \n-    /** serializable version identifier */\n+    /** Serializable version identifier. */\n     static final long serialVersionUID = 5138259215438106000L;\n \n     /** array of the roots of unity */\n     }\n     \n     /**\n-     * Performs a multi-dimensional Fourier transform on a given\n-     * array, using {@link #inversetransform2(Complex[])} and\n+     * Performs a multi-dimensional Fourier transform on a given array.\n+     * Use {@link #inversetransform2(Complex[])} and\n      * {@link #transform2(Complex[])} in a row-column implementation\n      * in any number of dimensions with O(N&times;log(N)) complexity with\n      * N=n<sub>1</sub>&times;n<sub>2</sub>&times;n<sub>3</sub>&times;...&times;n<sub>d</sub>,\n      * n<sub>x</sub>=number of elements in dimension x,\n      * and d=total number of dimensions.\n      *\n+     * @param mdca Multi-Dimensional Complex Array id est Complex[][][][]\n      * @param forward inverseTransform2 is preformed if this is false\n-     * @param mdca Multi-Dimensional Complex Array id est Complex[][][][]\n+     * @return transform of mdca as a Multi-Dimensional Complex Array id est Complex[][][][]\n      * @throws MathException if any dimension is not a power of two\n      */\n     public Object mdfft(Object mdca, boolean forward) throws MathException {\n         return mdcm.getArray();\n     }\n     \n+    /**\n+     * Performs one dimension of a multi-dimensional Fourier transform.\n+     *\n+     * @param mdcm input matrix\n+     * @param forward inverseTransform2 is preformed if this is false\n+     * @param d index of the dimension to process\n+     * @param subVector recursion subvector\n+     * @throws MathException if any dimension is not a power of two\n+     */\n     private void mdfft(MultiDimensionalComplexMatrix mdcm, boolean forward,\n                          int d, int[] subVector) throws MathException {\n         int[] dimensionSize = mdcm.getDimensionSizes();\n         return;\n     }\n \n-    /*\n-     * not designed for synchronized access\n+    /**\n+     * Complex matrix implementation.\n+     * Not designed for synchronized access\n      * may eventually be replaced by jsr-83 of the java community process\n      * http://jcp.org/en/jsr/detail?id=83\n      * may require additional exception throws for other basic requirements.\n      */\n     private class MultiDimensionalComplexMatrix implements Serializable,\n                                                            Cloneable {\n+\n+        /** Serializable version identifier. */\n         private static final long serialVersionUID =  0x564FCD47EBA8169BL;\n-        \n+\n+        /** Size in all dimensions. */\n         protected int[] dimensionSize = new int[1];\n+\n+        /** Storage array. */\n         protected Object multiDimensionalComplexArray;\n-        \n+\n+        /** Simple constructor.\n+         * @param multiDimensionalComplexArray array containing the matrix elements\n+         */\n         public MultiDimensionalComplexMatrix(Object\n                                              multiDimensionalComplexArray) {\n             this.multiDimensionalComplexArray = multiDimensionalComplexArray;\n                 dimensionSize = newDimensionSize;\n             }\n         }\n-        \n+\n+        /**\n+         * Get a matrix element.\n+         * @param vector indices of the element\n+         * @return matrix element\n+         */\n         public Complex get(int... vector) {\n             if ((vector == null && dimensionSize.length > 1) ||\n-                    vector.length != dimensionSize.length) {\n-                throw new IllegalArgumentException(\"Number of dimensions must \"\n-                                                   + \"match\");\n+                (vector != null && vector.length != dimensionSize.length)) {\n+                throw new IllegalArgumentException(\"Number of dimensions must match\");\n             }\n             \n             Object lastDimension = multiDimensionalComplexArray;\n             return (Complex) lastDimension;\n         }\n         \n+        /**\n+         * Set a matrix element.\n+         * @param magnitude magnitude of the element\n+         * @param vector indices of the element\n+         * @return the previous value\n+         */\n         public Complex set(Complex magnitude, int... vector) {\n             if ((vector == null && dimensionSize.length > 1) ||\n-                    vector.length != dimensionSize.length) {\n-                throw new IllegalArgumentException(\"Number of dimensions must \"\n-                                                   + \"match\");\n+                (vector != null && vector.length != dimensionSize.length)) {\n+                throw new IllegalArgumentException(\"Number of dimensions must match\");\n             }\n             \n             Object lastDimension = multiDimensionalComplexArray;\n                     magnitude;\n             return lastValue;\n         }\n-        \n+\n+        /**\n+         * Get the size in all dimensions.\n+         * @return size in all dimensions\n+         */\n         public int[] getDimensionSizes() {\n             return dimensionSize.clone();\n         }\n-        \n+\n+        /**\n+         * Get the underlying storage array\n+         * @return underlying storage array\n+         */\n         public Object getArray() {\n             return multiDimensionalComplexArray;\n         }\n-        \n+\n+        /** {@inheritDoc} */\n         @Override\n         public Object clone() {\n             MultiDimensionalComplexMatrix mdcm =\n             return mdcm;\n         }\n         \n-        /*\n+        /**\n          * Copy contents of current array into mdcm.\n+         * @param mdcm array where to copy data\n          */\n         private void clone(MultiDimensionalComplexMatrix mdcm) {\n             int[] vector = new int[dimensionSize.length];\n--- a/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n     public class Iterator {\n \n         /** Reference modification count. */\n-        final int referenceCount;\n+        private final int referenceCount;\n \n         /** Index of curent element. */\n         private int current;\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      * on original.  Original may not be null; otherwise a NullPointerException\n      * is thrown.\n      * \n-     * @param original\n+     * @param original array to copy\n      * @since 2.0\n      */\n     public ResizableDoubleArray(ResizableDoubleArray original) {\n        if (object instanceof ResizableDoubleArray == false) {\n             return false;\n         }\n-       boolean result = true;\n-       ResizableDoubleArray other = (ResizableDoubleArray) object;\n-       result = result && (other.initialCapacity == initialCapacity);\n-       result = result && (other.contractionCriteria == contractionCriteria);\n-       result = result && (other.expansionFactor == expansionFactor);\n-       result = result && (other.expansionMode == expansionMode);\n-       result = result && (other.numElements == numElements);\n-       result = result && (other.startIndex == startIndex);\n-       if (!result) { \n-           return false;\n-       } else {\n-           return Arrays.equals(internalArray, other.internalArray);\n+       synchronized(this) {\n+           synchronized(object) {\n+               boolean result = true;\n+               ResizableDoubleArray other = (ResizableDoubleArray) object;\n+               result = result && (other.initialCapacity == initialCapacity);\n+               result = result && (other.contractionCriteria == contractionCriteria);\n+               result = result && (other.expansionFactor == expansionFactor);\n+               result = result && (other.expansionMode == expansionMode);\n+               result = result && (other.numElements == numElements);\n+               result = result && (other.startIndex == startIndex);\n+               if (!result) { \n+                   return false;\n+               } else {\n+                   return Arrays.equals(internalArray, other.internalArray);\n+               }\n+           }\n        }\n     }\n     ", "timestamp": 1230115673, "metainfo": ""}