{"sha": "e89852254bd18ab27b334e54021887b8ccba588d", "log": "MATH-707 Renamed \"UnivariateRealIntegrator\" to \"UnivariateIntegrator\" and \"UnivariateRealIntegratorImpl\" to \"BaseAbstractUnivariateIntegrator\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/BaseAbstractUnivariateIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolverUtils;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Provide a default implementation for several generic functions.\n+ *\n+ * @version $Id$\n+ * @since 1.2\n+ */\n+public abstract class BaseAbstractUnivariateIntegrator implements UnivariateIntegrator {\n+\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;\n+\n+    /** Default relative accuracy. */\n+    public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;\n+\n+    /** Default minimal iteration count. */\n+    public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;\n+\n+    /** Default maximal iteration count. */\n+    public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;\n+\n+    /** Maximum absolute error. */\n+    protected double absoluteAccuracy;\n+\n+    /** Maximum relative error. */\n+    protected double relativeAccuracy;\n+\n+    /** minimum number of iterations */\n+    protected int minimalIterationCount;\n+\n+    /** The iteration count. */\n+    protected Incrementor iterations;\n+\n+    /** The functions evaluation count. */\n+    protected Incrementor evaluations;\n+\n+    /** Function to integrate. */\n+    protected UnivariateFunction function;\n+\n+    /** Lower bound for the interval. */\n+    protected double min;\n+\n+    /** Upper bound for the interval. */\n+    protected double max;\n+\n+    /**\n+     * Construct an integrator with given accuracies and iteration counts.\n+     * <p>\n+     * The meanings of the various parameters are:\n+     * <ul>\n+     *   <li>relative accuracy:\n+     *       this is used to stop iterations if the absolute accuracy can't be\n+     *       achieved due to large values or short mantissa length. If this\n+     *       should be the primary criterion for convergence rather then a\n+     *       safety measure, set the absolute accuracy to a ridiculously small value,\n+     *       like {@link org.apache.commons.math.util.Precision#SAFE_MIN Precision.SAFE_MIN}.</li>\n+     *   <li>absolute accuracy:\n+     *       The default is usually chosen so that results in the interval\n+     *       -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n+     *       expected absolute value of your results is of much smaller magnitude, set\n+     *       this to a smaller value.</li>\n+     *   <li>minimum number of iterations:\n+     *       minimal iteration is needed to avoid false early convergence, e.g.\n+     *       the sample points happen to be zeroes of the function. Users can\n+     *       use the default value or choose one that they see as appropriate.</li>\n+     *   <li>maximum number of iterations:\n+     *       usually a high iteration count indicates convergence problems. However,\n+     *       the \"reasonable value\" varies widely for different algorithms. Users are\n+     *       advised to use the default value supplied by the algorithm.</li>\n+     * </ul>\n+     * </p>\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     */\n+    protected BaseAbstractUnivariateIntegrator(final double relativeAccuracy,\n+                                           final double absoluteAccuracy,\n+                                           final int minimalIterationCount,\n+                                           final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+\n+        // accuracy settings\n+        this.relativeAccuracy      = relativeAccuracy;\n+        this.absoluteAccuracy      = absoluteAccuracy;\n+\n+        // iterations count settings\n+        if (minimalIterationCount <= 0) {\n+            throw new NotStrictlyPositiveException(minimalIterationCount);\n+        }\n+        if (maximalIterationCount <= minimalIterationCount) {\n+            throw new NumberIsTooSmallException(maximalIterationCount, minimalIterationCount, false);\n+        }\n+        this.minimalIterationCount = minimalIterationCount;\n+        this.iterations            = new Incrementor();\n+        iterations.setMaximalCount(maximalIterationCount);\n+\n+        // prepare evaluations counter, but do not set it yet\n+        evaluations = new Incrementor();\n+\n+    }\n+\n+    /**\n+     * Construct an integrator with given accuracies.\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     */\n+    protected BaseAbstractUnivariateIntegrator(final double relativeAccuracy,\n+                                           final double absoluteAccuracy) {\n+        this(relativeAccuracy, absoluteAccuracy,\n+             DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\n+    }\n+\n+    /**\n+     * Construct an integrator with given iteration counts.\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     */\n+    protected BaseAbstractUnivariateIntegrator(final int minimalIterationCount,\n+                                           final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+        this(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY,\n+             minimalIterationCount, maximalIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMinimalIterationCount() {\n+        return minimalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaximalIterationCount() {\n+        return iterations.getMaximalCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations.getCount();\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws TooManyEvaluationsException if the maximal number of function\n+     * evaluations is exceeded.\n+     */\n+    protected double computeObjectiveValue(final double point)\n+        throws TooManyEvaluationsException {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /**\n+     * Prepare for computation.\n+     * Subclasses must call this method if they override any of the\n+     * {@code solve} methods.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f the integrand function\n+     * @param lower the min bound for the interval\n+     * @param upper the upper bound for the interval\n+     * @throws NullArgumentException if {@code f} is {@code null}.\n+     * @throws MathIllegalArgumentException if {@code min >= max}.\n+     */\n+    protected void setup(final int maxEval,\n+                         final UnivariateFunction f,\n+                         final double lower, final double upper)\n+        throws NullArgumentException, MathIllegalArgumentException {\n+\n+        // Checks.\n+        MathUtils.checkNotNull(f);\n+        UnivariateSolverUtils.verifyInterval(lower, upper);\n+\n+        // Reset.\n+        this.min = lower;\n+        this.max = upper;\n+        function = f;\n+        evaluations.setMaximalCount(maxEval);\n+        evaluations.resetCount();\n+        iterations.resetCount();\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final int maxEval, final UnivariateFunction f,\n+                            final double lower, final double upper)\n+        throws TooManyEvaluationsException, MaxCountExceededException,\n+               MathIllegalArgumentException, NullArgumentException {\n+\n+        // Initialization.\n+        setup(maxEval, f, lower, upper);\n+\n+        // Perform computation.\n+        return doIntegrate();\n+\n+    }\n+\n+    /**\n+     * Method for implementing actual integration algorithms in derived\n+     * classes.\n+     *\n+     * @return the root.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     * @throws MaxCountExceededException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     */\n+    protected abstract double doIntegrate()\n+        throws TooManyEvaluationsException, MaxCountExceededException;\n+\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n  * @since 1.2\n  */\n \n-public class LegendreGaussIntegrator extends UnivariateRealIntegratorImpl {\n+public class LegendreGaussIntegrator extends BaseAbstractUnivariateIntegrator {\n \n     /** Abscissas for the 2 points method. */\n     private static final double[] ABSCISSAS_2 = {\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n  * @version $Id$\n  * @since 1.2\n  */\n-public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n+public class RombergIntegrator extends BaseAbstractUnivariateIntegrator {\n \n     /** Maximal number of iterations for Romberg. */\n     public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n  * @version $Id$\n  * @since 1.2\n  */\n-public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n+public class SimpsonIntegrator extends BaseAbstractUnivariateIntegrator {\n \n     /** Maximal number of iterations for Simpson. */\n     public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n  * @version $Id$\n  * @since 1.2\n  */\n-public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n+public class TrapezoidIntegrator extends BaseAbstractUnivariateIntegrator {\n \n     /** Maximum number of iterations for trapezoid. */\n     public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n      */\n-    double stage(final UnivariateRealIntegratorImpl baseIntegrator, final int n)\n+    double stage(final BaseAbstractUnivariateIntegrator baseIntegrator, final int n)\n         throws TooManyEvaluationsException {\n \n         if (n == 0) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+\n+/**\n+ * Interface for univariate real integration algorithms.\n+ *\n+ * @version $Id$\n+ * @since 1.2\n+ */\n+public interface UnivariateIntegrator {\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    double getRelativeAccuracy();\n+\n+    /**\n+     * Get the actual absolute accuracy.\n+     *\n+     * @return the accuracy\n+     */\n+    double getAbsoluteAccuracy();\n+\n+    /**\n+     * Get the min limit for the number of iterations.\n+     *\n+     * @return the actual min limit\n+     */\n+    int getMinimalIterationCount();\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     *\n+     * @return the actual upper limit\n+     */\n+    int getMaximalIterationCount();\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f the integrand function\n+     * @param min the min bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws TooManyEvaluationsException if the maximum number of function\n+     * evaluations is exceeded.\n+     * @throws MaxCountExceededException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws MathIllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the integrator\n+     * @throws NullArgumentException if {@code f} is {@code null}.\n+     */\n+    double integrate(int maxEval, UnivariateFunction f, double min,\n+                     double max)\n+        throws TooManyEvaluationsException, MaxCountExceededException,\n+               MathIllegalArgumentException, NullArgumentException;\n+\n+    /**\n+     * Get the number of function evaluations of the last run of the integrator.\n+     * @return number of function evaluations\n+     */\n+    int getEvaluations();\n+\n+    /**\n+     * Get the number of iterations of the last run of the integrator.\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);\n+        BaseAbstractUnivariateIntegrator integrator = new LegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = FastMath.PI; expected = 2;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator =\n+        UnivariateIntegrator integrator =\n                 new LegendreGaussIntegrator(3,\n-                                            UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,\n-                                            UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,\n-                                            UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,\n+                                            BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY,\n+                                            BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY,\n+                                            BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT,\n                                             64);\n         double min, max, expected, result;\n \n         for (int n = 2; n < 6; ++n) {\n             LegendreGaussIntegrator integrator =\n                 new LegendreGaussIntegrator(n,\n-                                            UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,\n-                                            UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,\n-                                            UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,\n+                                            BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY,\n+                                            BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY,\n+                                            BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT,\n                                             64);\n \n             // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly\n--- a/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new RombergIntegrator();\n+        UnivariateIntegrator integrator = new RombergIntegrator();\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = FastMath.PI; expected = 2;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new RombergIntegrator();\n+        UnivariateIntegrator integrator = new RombergIntegrator();\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = 1; expected = -1.0/48;\n--- a/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n+        UnivariateIntegrator integrator = new SimpsonIntegrator();\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = FastMath.PI; expected = 2;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n+        UnivariateIntegrator integrator = new SimpsonIntegrator();\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = 1; expected = -1.0/48;\n--- a/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n+        UnivariateIntegrator integrator = new TrapezoidIntegrator();\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = FastMath.PI; expected = 2;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n+        UnivariateIntegrator integrator = new TrapezoidIntegrator();\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = 1; expected = -1.0/48;\n--- a/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.integration.RombergIntegrator;\n-import org.apache.commons.math.analysis.integration.UnivariateRealIntegrator;\n+import org.apache.commons.math.analysis.integration.UnivariateIntegrator;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.junit.Assert;\n import org.junit.Test;\n                         return x * density(x);\n                     }\n                 };\n-                final UnivariateRealIntegrator integrator = new RombergIntegrator();\n+                final UnivariateIntegrator integrator = new RombergIntegrator();\n                 return integrator.integrate(Integer.MAX_VALUE, f, x0, x4);\n             }\n \n                         return x * x * density(x);\n                     }\n                 };\n-                final UnivariateRealIntegrator integrator = new RombergIntegrator();\n+                final UnivariateIntegrator integrator = new RombergIntegrator();\n                 final double meanX2 = integrator.integrate(Integer.MAX_VALUE,\n                         f, x0, x4);\n                 return meanX2 - meanX * meanX;", "timestamp": 1328137460, "metainfo": ""}