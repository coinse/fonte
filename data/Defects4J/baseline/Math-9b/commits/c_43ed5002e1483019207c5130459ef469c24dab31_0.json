{"sha": "43ed5002e1483019207c5130459ef469c24dab31", "log": "MATH-413 (points 1, 2 and 10) Reverted to the original version of the convergence checker (using only the previous and current best points). \"LevenberMarquardtOptimizer\": Removed setters (control parameters must be set at construction). Added a contructor.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n /**\n  * Base class for all convergence checker implementations.\n  *\n+ * <PAIR> Type of (point, value) pair.\n+ *\n  * @version $Revision$ $Date$\n  * @since 3.0\n  */\n-public abstract class AbstractConvergenceChecker<T>\n-    implements ConvergenceChecker<T> {\n+public abstract class AbstractConvergenceChecker<PAIR>\n+    implements ConvergenceChecker<PAIR> {\n     /**\n      * Default relative threshold.\n      */\n     }\n \n     /**\n-     * {@inheritDoc}\n+     * @return the relative threshold.\n      */\n     public double getRelativeThreshold() {\n         return relativeThreshold;\n     }\n \n     /**\n-     * {@inheritDoc}\n+     * @return the absolute threshold.\n      */\n     public double getAbsoluteThreshold() {\n         return absoluteThreshold;\n     /**\n      * {@inheritDoc}\n      */\n-    public abstract boolean converged(int iteration, T ... points);\n+    public abstract boolean converged(int iteration,\n+                                      PAIR previous,\n+                                      PAIR current);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n      * Check if the optimization algorithm has converged.\n      *\n      * @param iteration Current iteration.\n-     * @param points Data used for checking the convergence.\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n      * @return {@code true} if the algorithm is considered to have converged.\n      */\n-    boolean converged(int iteration, PAIR ... points);\n-\n-    /**\n-     * Get the relative tolerance.\n-     *\n-     * @return the relative threshold.\n-     */\n-    double getRelativeThreshold();\n-\n-    /**\n-     * Get the absolute tolerance.\n-     *\n-     * @return the absolute threshold.\n-     */\n-    double getAbsoluteThreshold();\n+    boolean converged(int iteration, PAIR previous, PAIR current);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n \n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n      * not only for the best or worst ones.\n      *\n      * @param iteration Index of current iteration\n-     * @param points Points used for checking convergence. The list must\n-     * contain two elements:\n-     * <ul>\n-     *  <li>the previous best point,</li>\n-     *  <li>the current best point.</li>\n-     * </ul>\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n      * @return {@code true} if the algorithm has converged.\n-     * @throws DimensionMismatchException if the length of the {@code points}\n-     * list is not equal to 2.\n      */\n     public boolean converged(final int iteration,\n-                             final RealPointValuePair ... points) {\n-        if (points.length != 2) {\n-            throw new DimensionMismatchException(points.length, 2);\n-        }\n-\n-        final double[] p = points[0].getPoint();\n-        final double[] c = points[1].getPoint();\n+                             final RealPointValuePair previous,\n+                             final RealPointValuePair current) {\n+        final double[] p = previous.getPoint();\n+        final double[] c = current.getPoint();\n         for (int i = 0; i < p.length; ++i) {\n             final double difference = FastMath.abs(p[i] - c[i]);\n             final double size = FastMath.max(FastMath.abs(p[i]), FastMath.abs(c[i]));\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n \n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n      * not only for the best or worst ones.\n      *\n      * @param iteration Index of current iteration\n-     * @param points Points used for checking convergence. The list must\n-     * contain two elements:\n-     * <ul>\n-     *  <li>the previous best point,</li>\n-     *  <li>the current best point.</li>\n-     * </ul>\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n      * @return {@code true} if the algorithm has converged.\n-     * @throws DimensionMismatchException if the length of the {@code points}\n-     * list is not equal to 2.\n      */\n     public boolean converged(final int iteration,\n-                             final RealPointValuePair ... points) {\n-        if (points.length != 2) {\n-            throw new DimensionMismatchException(points.length, 2);\n-        }\n-\n-        final double p = points[0].getValue();\n-        final double c = points[1].getValue();\n+                             final RealPointValuePair previous,\n+                             final RealPointValuePair current) {\n+        final double p = previous.getValue();\n+        final double c = current.getValue();\n         final double difference = FastMath.abs(p - c);\n         final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n         return (difference <= size * getRelativeThreshold() ||\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n      * not only for the best or worst ones.\n      *\n      * @param iteration Index of current iteration\n-     * @param points Points used for checking convergence. The list must\n-     * contain two elements:\n-     * <ul>\n-     *  <li>the previous best point,</li>\n-     *  <li>the current best point.</li>\n-     * </ul>\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n      * @return {@code true} if the algorithm has converged.\n-     * @throws DimensionMismatchException if the length of the {@code points}\n-     * list is not equal to 2.\n      */\n     public boolean converged(final int iteration,\n-                             final VectorialPointValuePair ... points) {\n-        if (points.length != 2) {\n-            throw new DimensionMismatchException(points.length, 2);\n-        }\n-\n-        final double[] p = points[0].getPointRef();\n-        final double[] c = points[1].getPointRef();\n+                             final VectorialPointValuePair previous,\n+                             final VectorialPointValuePair current) {\n+        final double[] p = previous.getPointRef();\n+        final double[] c = current.getPointRef();\n         for (int i = 0; i < p.length; ++i) {\n             final double pi = p[i];\n             final double ci = c[i];\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n      * not only for the best or worst ones.\n      *\n      * @param iteration Index of current iteration\n-     * @param points Points used for checking convergence. The list must\n-     * contain two elements:\n-     * <ul>\n-     *  <li>the previous best point,</li>\n-     *  <li>the current best point.</li>\n-     * </ul>\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n      * @return {@code true} if the algorithm has converged.\n-     * @throws DimensionMismatchException if the length of the {@code points}\n-     * list is not equal to 2.\n      */\n     public boolean converged(final int iteration,\n-                             final VectorialPointValuePair ... points) {\n-        if (points.length != 2) {\n-            throw new DimensionMismatchException(points.length, 2);\n-        }\n-\n-        final double[] p = points[0].getValueRef();\n-        final double[] c = points[1].getValueRef();\n+                             final VectorialPointValuePair previous,\n+                             final VectorialPointValuePair current) {\n+        final double[] p = previous.getValueRef();\n+        final double[] c = current.getValueRef();\n         for (int i = 0; i < p.length; ++i) {\n             final double pi         = p[i];\n             final double ci         = c[i];\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n  *\n  */\n public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n-\n     /** Number of solved point. */\n     private int solvedCols;\n-\n     /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n     private double[] diagR;\n-\n     /** Norms of the columns of the jacobian matrix. */\n     private double[] jacNorm;\n-\n     /** Coefficients of the Householder transforms vectors. */\n     private double[] beta;\n-\n     /** Columns permutation array. */\n     private int[] permutation;\n-\n     /** Rank of the jacobian matrix. */\n     private int rank;\n-\n     /** Levenberg-Marquardt parameter. */\n     private double lmPar;\n-\n     /** Parameters evolution direction associated with lmPar. */\n     private double[] lmDir;\n-\n     /** Positive input variable used in determining the initial step bound. */\n-    private double initialStepBoundFactor;\n-\n+    private final double initialStepBoundFactor;\n     /** Desired relative error in the sum of squares. */\n-    private double costRelativeTolerance;\n-\n+    private final double costRelativeTolerance;\n     /**  Desired relative error in the approximate solution parameters. */\n-    private double parRelativeTolerance;\n-\n+    private final double parRelativeTolerance;\n     /** Desired max cosine on the orthogonality between the function vector\n      * and the columns of the jacobian. */\n-    private double orthoTolerance;\n-\n+    private final double orthoTolerance;\n     /** Threshold for QR ranking. */\n-    private double qrRankingThreshold;\n+    private final double qrRankingThreshold;\n \n     /**\n-     * Build an optimizer for least squares problems.\n-     * <p>The default values for the algorithm settings are:\n-     *   <ul>\n-     *    <li>{@link #setConvergenceChecker(ConvergenceChecker) vectorial convergence checker}: null</li>\n-     *    <li>{@link #setInitialStepBoundFactor(double) initial step bound factor}: 100.0</li>\n-     *    <li>{@link #setCostRelativeTolerance(double) cost relative tolerance}: 1.0e-10</li>\n-     *    <li>{@link #setParRelativeTolerance(double) parameters relative tolerance}: 1.0e-10</li>\n-     *    <li>{@link #setOrthoTolerance(double) orthogonality tolerance}: 1.0e-10</li>\n-     *    <li>{@link #setQRRankingThreshold(double) QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n-     *   </ul>\n-     * </p>\n-     * <p>These default values may be overridden after construction. If the {@link\n-     * #setConvergenceChecker vectorial convergence checker} is set to a non-null value, it\n-     * will be used instead of the {@link #setCostRelativeTolerance cost relative tolerance}\n-     * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n+     * Build an optimizer for least squares problems with default values\n+     * for all the tuning parameters (see the {@link\n+     * #LevenbergMarquardtOptimizer(double,double,double,double,double)\n+     * other contructor}.\n+     * The default values for the algorithm settings are:\n+     * <ul>\n+     *  <li>Initial step bound factor}: 100</li>\n+     *  <li>Cost relative tolerance}: 1e-10</li>\n+     *  <li>Parameters relative tolerance}: 1e-10</li>\n+     *  <li>Orthogonality tolerance}: 1e-10</li>\n+     *  <li>QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n+     * </ul>\n      */\n     public LevenbergMarquardtOptimizer() {\n-        // default values for the tuning parameters\n-        setConvergenceChecker(null);\n-        setInitialStepBoundFactor(100.0);\n-        setCostRelativeTolerance(1.0e-10);\n-        setParRelativeTolerance(1.0e-10);\n-        setOrthoTolerance(1.0e-10);\n-        setQRRankingThreshold(MathUtils.SAFE_MIN);\n+        this(100, 1e-10, 1e-10, 1e-10, MathUtils.SAFE_MIN);\n     }\n \n     /**\n-     * Set the positive input variable used in determining the initial step bound.\n-     * This bound is set to the product of initialStepBoundFactor and the euclidean\n-     * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n-     * cases factor should lie in the interval (0.1, 100.0). 100.0 is a generally\n-     * recommended value.\n+     * Build an optimizer for least squares problems with default values\n+     * for some of the tuning parameters (see the {@link\n+     * #LevenbergMarquardtOptimizer(double,double,double,double,double)\n+     * other contructor}.\n+     * The default values for the algorithm settings are:\n+     * <ul>\n+     *  <li>Initial step bound factor}: 100</li>\n+     *  <li>QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n+     * </ul>\n      *\n-     * @param initialStepBoundFactor initial step bound factor\n+     * @param costRelativeTolerance Desired relative error in the sum of\n+     * squares.\n+     * @param parRelativeTolerance Desired relative error in the approximate\n+     * solution parameters.\n+     * @param orthoTolerance Desired max cosine on the orthogonality between\n+     * the function vector and the columns of the Jacobian.\n      */\n-    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n+    public LevenbergMarquardtOptimizer(double costRelativeTolerance,\n+                                       double parRelativeTolerance,\n+                                       double orthoTolerance) {\n+        this(100,\n+             costRelativeTolerance, parRelativeTolerance, orthoTolerance,\n+             MathUtils.SAFE_MIN);\n+    }\n+\n+    /**\n+     * The arguments control the behaviour of the default convergence checking\n+     * procedure.\n+     * Additional criteria can defined through the setting of a {@link\n+     * ConvergenceChecker}.\n+     *\n+     * @param initialStepBoundFactor Positive input variable used in\n+     * determining the initial step bound. This bound is set to the\n+     * product of initialStepBoundFactor and the euclidean norm of\n+     * {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\n+     * itself. In most cases factor should lie in the interval\n+     * {@code (0.1, 100.0)}. {@code 100} is a generally recommended value.\n+     * @param costRelativeTolerance Desired relative error in the sum of\n+     * squares.\n+     * @param parRelativeTolerance Desired relative error in the approximate\n+     * solution parameters.\n+     * @param orthoTolerance Desired max cosine on the orthogonality between\n+     * the function vector and the columns of the Jacobian.\n+     * @param threshold Desired threshold for QR ranking. If the squared norm\n+     * of a column vector is smaller or equal to this threshold during QR\n+     * decomposition, it is considered to be a zero vector and hence the rank\n+     * of the matrix is reduced.\n+     */\n+    public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\n+                                       double costRelativeTolerance,\n+                                       double parRelativeTolerance,\n+                                       double orthoTolerance,\n+                                       double threshold) {\n         this.initialStepBoundFactor = initialStepBoundFactor;\n-    }\n-\n-    /**\n-     * Set the desired relative error in the sum of squares.\n-     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n-     * convergence checker} is set to null.</p>\n-     * @param costRelativeTolerance desired relative error in the sum of squares\n-     */\n-    public void setCostRelativeTolerance(double costRelativeTolerance) {\n         this.costRelativeTolerance = costRelativeTolerance;\n-    }\n-\n-    /**\n-     * Set the desired relative error in the approximate solution parameters.\n-     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n-     * convergence checker} is set to null.</p>\n-     * @param parRelativeTolerance desired relative error\n-     * in the approximate solution parameters\n-     */\n-    public void setParRelativeTolerance(double parRelativeTolerance) {\n         this.parRelativeTolerance = parRelativeTolerance;\n-    }\n-\n-    /**\n-     * Set the desired max cosine on the orthogonality.\n-     * <p>This setting is always used, regardless of the {@link #setConvergenceChecker\n-     * vectorial convergence checker} being null or non-null.</p>\n-     * @param orthoTolerance desired max cosine on the orthogonality\n-     * between the function vector and the columns of the jacobian\n-     */\n-    public void setOrthoTolerance(double orthoTolerance) {\n         this.orthoTolerance = orthoTolerance;\n-    }\n-\n-    /**\n-     * Set the desired threshold for QR ranking.\n-     * <p>\n-     * If the squared norm of a column vector is smaller or equal to this threshold\n-     * during QR decomposition, it is considered to be a zero vector and hence the\n-     * rank of the matrix is reduced.\n-     * </p>\n-     * @param threshold threshold for QR ranking\n-     */\n-    public void setQRRankingThreshold(final double threshold) {\n         this.qrRankingThreshold = threshold;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException {\n-\n+    protected VectorialPointValuePair doOptimize()\n+        throws FunctionEvaluationException {\n         // arrays shared with the other private methods\n         solvedCols  = FastMath.min(rows, cols);\n         diagR       = new double[cols];\n                     objective = oldObj;\n                     oldObj    = tmpVec;\n                 }\n-                if (checker==null) {\n-                    if (((FastMath.abs(actRed) <= costRelativeTolerance) &&\n-                        (preRed <= costRelativeTolerance) &&\n-                        (ratio <= 2.0)) ||\n-                       (delta <= parRelativeTolerance * xNorm)) {\n-                       return current;\n-                   }\n-                }\n+\n+                // Default convergence criteria.\n+                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n+                     preRed <= costRelativeTolerance &&\n+                     ratio <= 2.0) ||\n+                    delta <= parRelativeTolerance * xNorm) {\n+                    return current;\n+                }\n+\n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n                 if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n import java.util.Arrays;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n  * algorithm (as implemented in module {@code optimize.py} v0.5 of\n  * <em>SciPy</em>).\n  * <br/>\n- * The user is responsible for calling {@link\n- * #setConvergenceChecker(ConvergenceChecker) ConvergenceChecker}\n+ * The default stopping criterion is based on the differences of the\n+ * function value between two successive iterations. It is however possible\n+ * to define custom convergence criteria by calling a {@link\n+ * #setConvergenceChecker(ConvergenceChecker) setConvergenceChecker}\n  * prior to using the optimizer.\n  *\n  * @version $Revision$ $Date$\n public class PowellOptimizer\n     extends AbstractScalarOptimizer {\n     /**\n+     * Minimum relative tolerance.\n+     */\n+    private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d);\n+    /**\n+     * Relative threshold.\n+     */\n+    private double relativeThreshold;\n+    /**\n+     * Absolute threshold.\n+     */\n+    private double absoluteThreshold;\n+    /**\n      * Line search.\n      */\n-    private LineSearch line = new LineSearch();\n-\n-    /**\n-     * Set the convergence checker.\n-     * It also indirectly sets the line search tolerances to the square-root\n-     * of the correponding tolerances in the checker.\n+    private LineSearch line;\n+\n+    /**\n+     * The arguments control the behaviour of the default convergence\n+     * checking procedure.\n      *\n-     * @param checker Convergence checker.\n-     */\n-    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> checker) {\n-        super.setConvergenceChecker(checker);\n+     * @param rel Relative threshold.\n+     * @param abs Absolute threshold.\n+     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n+     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n+     */\n+    public PowellOptimizer(double rel,\n+                           double abs) {\n+        if (rel < MIN_RELATIVE_TOLERANCE) {\n+            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n+        }\n+        if (abs <= 0) {\n+            throw new NotStrictlyPositiveException(abs);\n+        }\n+        relativeThreshold = rel;\n+        absoluteThreshold = abs;\n \n         // Line search tolerances can be much lower than the tolerances\n         // required for the optimizer itself.\n         final double minTol = 1e-4;\n-        final double rel = Math.min(Math.sqrt(checker.getRelativeThreshold()), minTol);\n-        final double abs = Math.min(Math.sqrt(checker.getAbsoluteThreshold()), minTol);\n-        line.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(rel, abs));\n+        final double lsRel = Math.min(FastMath.sqrt(relativeThreshold), minTol);\n+        final double lsAbs = Math.min(FastMath.sqrt(absoluteThreshold), minTol);\n+        line = new LineSearch(lsRel, lsAbs);\n     }\n \n     /** {@inheritDoc} */\n             direc[i][i] = 1;\n         }\n \n+        final ConvergenceChecker<RealPointValuePair> checker\n+            = getConvergenceChecker();\n+\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n                 }\n             }\n \n+            // Default convergence check.\n+            boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX)\n+                                                                    + FastMath.abs(fVal))\n+                                               + absoluteThreshold);\n+\n             final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n             final RealPointValuePair current = new RealPointValuePair(x, fVal);\n-            if (getConvergenceChecker().converged(iter, previous, current)) {\n+            if (!stop) { // User-defined stopping criteria.\n+                if (checker != null) {\n+                    stop = checker.converged(iter, previous, current);\n+                }\n+            }\n+            if (stop) {\n                 if (goal == GoalType.MINIMIZE) {\n                     return (fVal < fX) ? current : previous;\n                 } else {\n          * Value of the optimum.\n          */\n         private UnivariateRealPointValuePair optimum;\n+\n+        /**\n+         * @param rel Relative threshold.\n+         * @param rel Absolute threshold.\n+         */\n+        LineSearch(double rel,\n+                   double abs) {\n+            super(rel, abs);\n+        }\n \n         /**\n          * Find the minimum of the function {@code f(p + alpha * d)}.\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.MathUnsupportedOperationException;\n      * Golden section.\n      */\n     private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n-\n-    /**\n-     * Convergence checker that implements the original stopping criterion\n+    /**\n+     * Minimum relative tolerance.\n+     */\n+    private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d);\n+    /**\n+     * Relative threshold.\n+     */\n+    private final double relativeThreshold;\n+    /**\n+     * Absolute threshold.\n+     */\n+    private final double absoluteThreshold;\n+\n+    /**\n+     * The arguments are used implement the original stopping criterion\n      * of Brent's algorithm.\n      * {@code abs} and {@code rel} define a tolerance\n      * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n      * where <em>macheps</em> is the relative machine precision. {@code abs} must\n      * be positive.\n      *\n-     * @since 3.0\n-     */\n-    public static class BrentConvergenceChecker\n-        extends AbstractConvergenceChecker<UnivariateRealPointValuePair> {\n-        /**\n-         * Minimum relative tolerance.\n-         */\n-        private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d);\n-\n-        /**\n-         * Build an instance with specified thresholds.\n-         *\n-         * @param rel Relative tolerance threshold\n-         * @param abs Absolute tolerance threshold\n-         */\n-        public BrentConvergenceChecker(final double rel,\n-                                       final double abs) {\n-            super(rel, abs);\n-            \n-            if (rel < MIN_RELATIVE_TOLERANCE) {\n-                throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n-            }\n-            if (abs <= 0) {\n-                throw new NotStrictlyPositiveException(abs);\n-            }\n-        }\n-\n-        /**\n-         * Convergence criterion.\n-         *\n-         * @param iteration Current iteration.\n-         * @param points Points used for checking the stopping criterion. The list\n-         * must contain 3 points (in the following order):\n-         * <ul>\n-         *  <li>the lower end of the current interval</li>\n-         *  <li>the current best point</li>\n-         *  <li>the higher end of the current interval</li>\n-         * </ul>\n-         * @return {@code true} if the stopping criterion is satisfied.\n-         * @throws DimensionMismatchException if the length of the {@code points}\n-         * list is not equal to 3.\n-         */\n-        public boolean converged(final int iteration,\n-                                 final UnivariateRealPointValuePair ... points) {\n-            if (points.length != 3) {\n-                throw new DimensionMismatchException(points.length, 3);\n-            }\n-            \n-            final double a = points[0].getPoint();\n-            final double x = points[1].getPoint();\n-            final double b = points[2].getPoint();\n-            \n-            final double tol1 = getRelativeThreshold() * FastMath.abs(x) + getAbsoluteThreshold();\n-            final double tol2 = 2 * tol1;\n-            \n-            final double m = 0.5 * (a + b);\n-            return FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n-        }\n-    }\n-\n-    /**\n-     * Set the convergence checker.\n-     * Since this algorithm requires a specific checker, this method will throw\n-     * an {@code UnsupportedOperationexception} if the argument type is not\n-     * {@link BrentConvergenceChecker}.\n-     *\n-     * @throws MathUnsupportedOperationexception if the checker is not an\n-     * instance of {@link BrentConvergenceChecker}.\n-     */\n-    @Override\n-    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n-        if (checker instanceof BrentConvergenceChecker) {\n-            super.setConvergenceChecker(checker);\n-        } else {\n-            throw new MathUnsupportedOperationException();\n-        }\n+     * @param rel Relative threshold.\n+     * @param abs Absolute threshold.\n+     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n+     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n+     */\n+    public BrentOptimizer(double rel,\n+                          double abs) {\n+        if (rel < MIN_RELATIVE_TOLERANCE) {\n+            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n+        }\n+        if (abs <= 0) {\n+            throw new NotStrictlyPositiveException(abs);\n+        }\n+        relativeThreshold = rel;\n+        absoluteThreshold = abs;\n     }\n \n     /** {@inheritDoc} */\n         final double mid = getStartValue();\n         final double hi = getMax();\n \n+        // Optional additional convergence criteria.\n         final ConvergenceChecker<UnivariateRealPointValuePair> checker\n             = getConvergenceChecker();\n-        final double eps = checker.getRelativeThreshold();\n-        final double t = checker.getAbsoluteThreshold();\n \n         double a;\n         double b;\n         double fv = fx;\n         double fw = fx;\n \n+        UnivariateRealPointValuePair previous = null;\n+        UnivariateRealPointValuePair current\n+            = new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+\n         int iter = 0;\n         while (true) {\n-            double m = 0.5 * (a + b);\n-            final double tol1 = eps * FastMath.abs(x) + t;\n+            final double m = 0.5 * (a + b);\n+            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n             final double tol2 = 2 * tol1;\n \n-            // Check stopping criterion.\n-            // This test will work only if the \"checker\" is an instance of\n-            // \"BrentOptimizer.BrentConvergenceChecker\".\n-            if (!getConvergenceChecker().converged(iter,\n-                                                   new UnivariateRealPointValuePair(a, Double.NaN),\n-                                                   new UnivariateRealPointValuePair(x, Double.NaN),\n-                                                   new UnivariateRealPointValuePair(b, Double.NaN))) {\n+            // Default stopping criterion.\n+            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n+            if (!stop) {\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n                         fv = fu;\n                     }\n                 }\n-            } else { // Termination.\n-                return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+\n+                previous = current;\n+                current = new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+\n+                // User-defined convergence checker.\n+                if (checker != null) {\n+                    if (checker.converged(iter, previous, current)) {\n+                        return current;\n+                    }\n+                }\n+            } else { // Default termination (Brent's criterion).\n+                return current;\n             }\n             ++iter;\n         }\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n         assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n         assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n-\n     }\n \n     public void testNoDependency() throws FunctionEvaluationException {\n         assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n         assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n-\n     }\n \n     public void testTwoSets() throws FunctionEvaluationException {\n         assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n         assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n         assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n-\n     }\n \n     public void testNonInversible() throws FunctionEvaluationException {\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         }\n-\n     }\n \n     public void testIllConditioned() throws FunctionEvaluationException {\n         assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n         assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n         assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n-\n     }\n \n     public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException {\n         optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n                 new double[] { 7, 6, 5, 4 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-\n     }\n \n     public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException {\n         assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n         assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n         assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n-\n     }\n \n     public void testRedundantEquations() throws FunctionEvaluationException {\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n         assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n-\n     }\n \n     public void testInconsistentEquations() throws FunctionEvaluationException {\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n         assertTrue(optimizer.getRMS() > 0.1);\n-\n     }\n \n     public void testInconsistentSizes() throws FunctionEvaluationException {\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         }\n-\n     }\n \n     public void testControlParameters() {\n                                double costRelativeTolerance, double parRelativeTolerance,\n                                double orthoTolerance, boolean shouldFail) {\n         try {\n-            LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-            optimizer.setInitialStepBoundFactor(initialStepBoundFactor);\n+            LevenbergMarquardtOptimizer optimizer\n+                = new LevenbergMarquardtOptimizer(initialStepBoundFactor,\n+                                                  costRelativeTolerance,\n+                                                  parRelativeTolerance,\n+                                                  orthoTolerance,\n+                                                  MathUtils.SAFE_MIN);\n             optimizer.setMaxEvaluations(maxCostEval);\n-            optimizer.setCostRelativeTolerance(costRelativeTolerance);\n-            optimizer.setParRelativeTolerance(parRelativeTolerance);\n-            optimizer.setOrthoTolerance(orthoTolerance);\n             optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n             assertTrue(!shouldFail);\n         errors = optimizer.guessParametersErrors();\n         assertEquals(0.004, errors[0], 0.001);\n         assertEquals(0.004, errors[1], 0.001);\n-\n     }\n \n     public void testCircleFittingBadInit() throws FunctionEvaluationException {\n             problem.addPoint (2, -2.1488478161387325);\n             problem.addPoint (3, -1.9122489313410047);\n             problem.addPoint (4, 1.7785661310051026);\n-            LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-            optimizer.setQRRankingThreshold(0);\n+            LevenbergMarquardtOptimizer optimizer\n+                = new LevenbergMarquardtOptimizer(100, 1e-10, 1e-10, 1e-10, 0);\n             optimizer.optimize(problem,\n                                new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n-\n     }\n \n     private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n                 }\n             };\n         }\n-\n     }\n \n     private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {\n             }\n \n             return jacobian;\n-\n         }\n \n         public double[] value(double[] variables)\n             }\n \n             return residuals;\n-\n         }\n \n         public MultivariateMatrixFunction jacobian() {\n                 }\n             };\n         }\n-\n     }\n \n     private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n                 }\n             };\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n   }\n \n   private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n-      LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+      LevenbergMarquardtOptimizer optimizer\n+          = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16),\n+                                            FastMath.sqrt(2.22044604926e-16),\n+                                            2.22044604926e-16);\n       optimizer.setMaxEvaluations(400 * (function.getN() + 1));\n-      optimizer.setCostRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n-      optimizer.setParRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n-      optimizer.setOrthoTolerance(2.22044604926e-16);\n //      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n       try {\n           VectorialPointValuePair optimum =\n--- a/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n                         double fTol,\n                         double pointTol)\n         throws MathException {\n-        final MultivariateRealOptimizer optim = new PowellOptimizer();\n+        final MultivariateRealOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));\n         optim.setMaxEvaluations(1000);\n-        optim.setConvergenceChecker(new SimpleScalarValueChecker(fTol, Math.ulp(1d)));\n \n         final RealPointValuePair result = optim.optimize(func, goal, init);\n         final double[] found = result.getPoint();\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n     @Test\n     public void testSinMin() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n-        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-10, 1e-14));\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n         optimizer.setMaxEvaluations(200);\n         assertEquals(200, optimizer.getMaxEvaluations());\n-        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 4, 5).getPoint(),\n-                     100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n+        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n         assertTrue(optimizer.getEvaluations() <= 50);\n-        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 1, 5).getPoint(),\n-                     100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n+        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);\n         assertTrue(optimizer.getEvaluations() <= 100);\n         assertTrue(optimizer.getEvaluations() >= 15);\n         optimizer.setMaxEvaluations(10);\n     public void testQuinticMin() throws MathException {\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n-        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-10, 1e-14));\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n         optimizer.setMaxEvaluations(200);\n         assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n         assertEquals( 0.82221643, optimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n     public void testQuinticMinStatistics() throws MathException {\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n-        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-12, 1e-14));\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14);\n         optimizer.setMaxEvaluations(40);\n \n         final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];\n \n         final double meanOptValue = stat[0].getMean();\n         final double medianEval = stat[1].getPercentile(50);\n-        assertTrue(meanOptValue > -0.2719561281 && meanOptValue < -0.2719561280);\n-        assertEquals((int) medianEval, 27);\n+        assertTrue(meanOptValue > -0.2719561281);\n+        assertTrue(meanOptValue < -0.2719561280);\n+        assertEquals(23, (int) medianEval);\n     }\n \n     @Test(expected = TooManyEvaluationsException.class)\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has a local maximum at 0.27195613.\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n-        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-12, 1e-14));\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);\n         assertEquals(0.27195613, optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n         optimizer.setMaxEvaluations(5);\n         try {\n     @Test\n     public void testMinEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n-        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-8, 1e-14));\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14);\n         optimizer.setMaxEvaluations(50);\n \n         // endpoint is minimum\n         double result = optimizer.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();\n-        assertEquals(3 * Math.PI / 2, result, 100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n+        assertEquals(3 * Math.PI / 2, result, 1e-6);\n \n         result = optimizer.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();\n-        assertEquals(3 * Math.PI / 2, result, 100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n+        assertEquals(3 * Math.PI / 2, result, 1e-6);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n     @Test\n     public void testSinMin() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealOptimizer underlying = new BrentOptimizer();\n-        underlying.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-10, 1e-14));\n+        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);\n         underlying.setMaxEvaluations(300);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(44428400075l);\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer underlying = new BrentOptimizer();\n-        underlying.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-9, 1e-14));\n+        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n         underlying.setMaxEvaluations(300);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(4312000053L);", "timestamp": 1283763988, "metainfo": ""}