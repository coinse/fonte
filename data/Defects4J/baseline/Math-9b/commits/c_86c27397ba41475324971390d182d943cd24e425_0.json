{"sha": "86c27397ba41475324971390d182d943cd24e425", "log": "Replaced 2 calls to \"max(m,n)\" by the already known value (\"m\"), as requested by Greg Sterijevski on the \"dev\" ML. Added \"final\" keyword.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n     /** Computed singular values. */\n     private double[] singularValues;\n \n-    /** Row dimension. */\n-    private int m;\n-\n-    /** Column dimension. */\n-    private int n;\n+    /** max(row dimension, column dimension). */\n+    private final int m;\n+\n+    /** min(row dimension, column dimension). */\n+    private final int n;\n \n     /** Indicator for transposed matrix. */\n-    private boolean transposed;\n+    private final boolean transposed;\n \n     /** Cached value of U matrix. */\n-    private RealMatrix cachedU;\n+    private final RealMatrix cachedU;\n \n     /** Cached value of transposed U matrix. */\n     private RealMatrix cachedUt;\n     private RealMatrix cachedS;\n \n     /** Cached value of V matrix. */\n-    private RealMatrix cachedV;\n+    private final RealMatrix cachedV;\n \n     /** Cached value of transposed V matrix. */\n     private RealMatrix cachedVt;\n      * @param matrix Matrix to decompose.\n      */\n     public SingularValueDecompositionImpl(final RealMatrix matrix) {\n-\n-        // Derived from LINPACK code.\n-        // Initialize.\n-        double[][] A;\n-        m = matrix.getRowDimension();\n-        n = matrix.getColumnDimension();\n+        final double[][] A;\n+\n+         // \"m\" is always the largest dimension.\n         if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n             transposed = true;\n             A = matrix.transpose().getData();\n             m = matrix.getRowDimension();\n             n = matrix.getColumnDimension();\n         }\n-        int nu = FastMath.min(m, n);\n+ \n+        final int nu = FastMath.min(m, n);\n         singularValues = new double[FastMath.min(m + 1, n)];\n-        double[][] U = new double[m][nu];\n-        double[][] V = new double[n][n];\n-        double[] e = new double[n];\n-        double[] work = new double[m];\n+        final double[][] U = new double[m][nu];\n+        final double[][] V = new double[n][n];\n+        final double[] e = new double[n];\n+        final double[] work = new double[m];\n         boolean wantu = true;\n         boolean wantv = true;\n         // Reduce A to bidiagonal form, storing the diagonal elements\n         // in s and the super-diagonal elements in e.\n-        int nct = FastMath.min(m - 1, n);\n-        int nrt = FastMath.max(0, FastMath.min(n - 2, m));\n+        final int nct = FastMath.min(m - 1, n);\n+        final int nrt = FastMath.max(0, FastMath.min(n - 2, m));\n         for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n             if (k < nct) {\n                 // Compute the transformation for the k-th column and\n                         }\n                     }\n                     for (int j = k + 1; j < n; j++) {\n-                        double t = -e[j] / e[k + 1];\n+                        final double t = -e[j] / e[k + 1];\n                         for (int i = k + 1; i < m; i++) {\n                             A[i][j] += t * work[i];\n                         }\n             }\n         }\n         // Main iteration loop for the singular values.\n-        int pp = p - 1;\n+        final int pp = p - 1;\n         int iter = 0;\n         while (p > 0) {\n             int k;\n                 if (k == -1) {\n                     break;\n                 }\n-                final double threshold =\n-                        TINY + EPS * (FastMath.abs(singularValues[k]) + FastMath.abs(singularValues[k + 1]));\n+                final double threshold\n+                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n+                                    FastMath.abs(singularValues[k + 1]));\n                 if (FastMath.abs(e[k]) <= threshold) {\n                     e[k] = 0.0;\n                     break;\n                     if (ks == k) {\n                         break;\n                     }\n-                    double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +\n-                               (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);\n+                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +\n+                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);\n                     if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                         singularValues[ks] = 0.0;\n                         break;\n                     e[p - 2] = 0.0;\n                     for (int j = p - 2; j >= k; j--) {\n                         double t = FastMath.hypot(singularValues[j], f);\n-                        double cs = singularValues[j] / t;\n-                        double sn = f / t;\n+                        final double cs = singularValues[j] / t;\n+                        final double sn = f / t;\n                         singularValues[j] = t;\n                         if (j != k) {\n                             f = -sn * e[j - 1];\n                     e[k - 1] = 0.0;\n                     for (int j = k; j < p; j++) {\n                         double t = FastMath.hypot(singularValues[j], f);\n-                        double cs = singularValues[j] / t;\n-                        double sn = f / t;\n+                        final double cs = singularValues[j] / t;\n+                        final double sn = f / t;\n                         singularValues[j] = t;\n                         f = -sn * e[j];\n                         e[j] = cs * e[j];\n                 // Perform one qr step.\n                 case 3: {\n                     // Calculate the shift.\n-                    double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(\n+                    final double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(\n                             FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])), FastMath.abs(e[p - 2])),\n                             FastMath.abs(singularValues[k])), FastMath.abs(e[k]));\n-                    double sp = singularValues[p - 1] / scale;\n-                    double spm1 = singularValues[p - 2] / scale;\n-                    double epm1 = e[p - 2] / scale;\n-                    double sk = singularValues[k] / scale;\n-                    double ek = e[k] / scale;\n-                    double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n-                    double c = (sp * epm1) * (sp * epm1);\n+                    final double sp = singularValues[p - 1] / scale;\n+                    final double spm1 = singularValues[p - 2] / scale;\n+                    final double epm1 = e[p - 2] / scale;\n+                    final double sk = singularValues[k] / scale;\n+                    final double ek = e[k] / scale;\n+                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n+                    final double c = (sp * epm1) * (sp * epm1);\n                     double shift = 0.0;\n                     if ((b != 0.0) | (c != 0.0)) {\n                         shift = FastMath.sqrt(b * b + c);\n \n         if (dimension == 0) {\n             throw new NumberIsTooLargeException(LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,\n-                    minSingularValue, singularValues[0], true);\n+                                                minSingularValue, singularValues[0], true);\n         }\n \n         final double[][] data = new double[dimension][p];\n \n     /** {@inheritDoc} */\n     public int getRank() {\n-        double tol = FastMath.max(m, n) * singularValues[0] * EPS;\n+        final double tol = m * singularValues[0] * EPS;\n         int r = 0;\n         for (int i = 0; i < singularValues.length; i++) {\n             if (singularValues[i] > tol) {\n \n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n-        return new Solver(singularValues, getUT(), getV(), getRank() == Math.max(m, n));\n+        return new Solver(singularValues, getUT(), getV(), getRank() == m);\n     }\n \n     /** Specialized solver. */\n          * @param nonSingular Singularity indicator.\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT,\n-                final RealMatrix v, final boolean nonSingular) {\n-            double[][] suT = uT.getData();\n+                       final RealMatrix v, final boolean nonSingular) {\n+            final double[][] suT = uT.getData();\n             for (int i = 0; i < singularValues.length; ++i) {\n                 final double a;\n                 if (singularValues[i] > 0) {", "timestamp": 1313154058, "metainfo": ""}