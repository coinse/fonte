{"sha": "71ab26d48b1ffde0e5ad0e59bb3619a8b9c5aec2", "log": "use the reorganized Binary Space Partitioning framework for Euclidean spaces 1D, 2D and 3D.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Interval.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Interval.java\n \n /** This class represents a 1D interval.\n  * @see IntervalsSet\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n public class Interval {\n \n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n import java.util.Collection;\n import java.util.List;\n \n+import org.apache.commons.math.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n \n /** This class represents a 1D region: a set of intervals.\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class IntervalsSet extends Region {\n+public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> {\n \n     /** Build an intervals set representing the whole real line.\n      */\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n      * @param tree inside/outside BSP tree representing the intervals set\n      */\n-    public IntervalsSet(final BSPTree tree) {\n+    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n         super(tree);\n     }\n \n      * space.</p>\n      * @param boundary collection of boundary elements\n      */\n-    public IntervalsSet(final Collection<SubHyperplane> boundary) {\n+    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n         super(boundary);\n     }\n \n      * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n      * @return the built tree\n      */\n-    private static BSPTree buildTree(final double lower, final double upper) {\n+    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n         if (Double.isInfinite(lower) && (lower < 0)) {\n             if (Double.isInfinite(upper) && (upper > 0)) {\n                 // the tree must cover the whole real line\n-                return new BSPTree(Boolean.TRUE);\n+                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n             }\n             // the tree must be open on the negative infinity side\n-            final SubHyperplane upperCut =\n-                new SubHyperplane(new OrientedPoint(new Point1D(upper), true));\n-            return new BSPTree(upperCut,\n-                               new BSPTree(Boolean.FALSE),\n-                               new BSPTree(Boolean.TRUE),\n+            final SubHyperplane<Euclidean1D> upperCut =\n+                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n+            return new BSPTree<Euclidean1D>(upperCut,\n+                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                null);\n         }\n-        final SubHyperplane lowerCut =\n-            new SubHyperplane(new OrientedPoint(new Point1D(lower), false));\n+        final SubHyperplane<Euclidean1D> lowerCut =\n+            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n         if (Double.isInfinite(upper) && (upper > 0)) {\n             // the tree must be open on the positive infinity side\n-            return new BSPTree(lowerCut,\n-                               new BSPTree(Boolean.FALSE),\n-                               new BSPTree(Boolean.TRUE),\n+            return new BSPTree<Euclidean1D>(lowerCut,\n+                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                null);\n         }\n \n         // the tree must be bounded on the two sides\n-        final SubHyperplane upperCut =\n-            new SubHyperplane(new OrientedPoint(new Point1D(upper), true));\n-        return new BSPTree(lowerCut,\n-                           new BSPTree(Boolean.FALSE),\n-                           new BSPTree(upperCut,\n-                                       new BSPTree(Boolean.FALSE),\n-                                       new BSPTree(Boolean.TRUE),\n+        final SubHyperplane<Euclidean1D> upperCut =\n+            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n+        return new BSPTree<Euclidean1D>(lowerCut,\n+                           new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                           new BSPTree<Euclidean1D>(upperCut,\n+                                       new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                                       new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                        null),\n                                        null);\n \n     }\n \n     /** {@inheritDoc} */\n-    public Region buildNew(final BSPTree tree) {\n+    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n         return new IntervalsSet(tree);\n     }\n \n     /** {@inheritDoc} */\n     protected void computeGeometricalProperties() {\n         if (getTree(false).getCut() == null) {\n-            setBarycenter(Point1D.UNDEFINED);\n+            setBarycenter(Vector1D.NaN);\n             setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n         } else {\n             double size = 0.0;\n                 sum  += interval.getLength() * interval.getMidPoint();\n             }\n             setSize(size);\n-            setBarycenter(Double.isInfinite(size) ? Point1D.UNDEFINED : new Point1D(sum / size));\n+            setBarycenter(Double.isInfinite(size) ? Vector1D.NaN : new Vector1D(sum / size));\n         }\n     }\n \n      * instance is empty)\n      */\n     public double getInf() {\n-        BSPTree node = getTree(false);\n+        BSPTree<Euclidean1D> node = getTree(false);\n         double  inf  = Double.POSITIVE_INFINITY;\n         while (node.getCut() != null) {\n             final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n-            inf  = op.getLocation().getAbscissa();\n+            inf  = op.getLocation().getX();\n             node = op.isDirect() ? node.getMinus() : node.getPlus();\n         }\n         return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n      * instance is empty)\n      */\n     public double getSup() {\n-        BSPTree node = getTree(false);\n+        BSPTree<Euclidean1D> node = getTree(false);\n         double  sup  = Double.NEGATIVE_INFINITY;\n         while (node.getCut() != null) {\n             final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n-            sup  = op.getLocation().getAbscissa();\n+            sup  = op.getLocation().getX();\n             node = op.isDirect() ? node.getPlus() : node.getMinus();\n         }\n         return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n      * @param lower lower bound of the current convex cell\n      * @param upper upper bound of the current convex cell\n      */\n-    private void recurseList(final BSPTree node, final List<Interval> list,\n+    private void recurseList(final BSPTree<Euclidean1D> node,\n+                             final List<Interval> list,\n                              final double lower, final double upper) {\n \n         if (node.getCut() == null) {\n             }\n         } else {\n             final OrientedPoint op  = (OrientedPoint) node.getCut().getHyperplane();\n-            final Point1D       loc = op.getLocation();\n-            double        x   = loc.getAbscissa();\n+            final Vector1D       loc = op.getLocation();\n+            double              x   = loc.getX();\n \n             // make sure we explore the tree in increasing order\n-            final BSPTree low       = op.isDirect() ? node.getMinus() : node.getPlus();\n-            final BSPTree high      = op.isDirect() ? node.getPlus()  : node.getMinus();\n+            final BSPTree<Euclidean1D> low  =\n+                op.isDirect() ? node.getMinus() : node.getPlus();\n+            final BSPTree<Euclidean1D> high =\n+                op.isDirect() ? node.getPlus()  : node.getMinus();\n \n             recurseList(low, list, lower, x);\n             if ((checkPoint(low,  loc) == Location.INSIDE) &&\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/OrientedPoint.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/OrientedPoint.java\n  */\n package org.apache.commons.math.geometry.euclidean.oned;\n \n-import org.apache.commons.math.exception.MathUnsupportedOperationException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.Vector;\n import org.apache.commons.math.geometry.partitioning.Hyperplane;\n-import org.apache.commons.math.geometry.partitioning.Point;\n import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n-import org.apache.commons.math.geometry.partitioning.SubSpace;\n \n /** This class represents a 1D oriented hyperplane.\n  * <p>An hyperplane in 1D is a simple point, its orientation being a\n  * boolean.</p>\n  * <p>Instances of this class are guaranteed to be immutable.</p>\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class OrientedPoint implements Hyperplane {\n+public class OrientedPoint implements Hyperplane<Euclidean1D> {\n \n-    /** Dummy region returned by the {@link #wholeHyperplane} method. */\n-    private static final Region DUMMY_REGION = new DummyRegion();\n-\n-    /** Point location. */\n-    private Point1D location;\n+    /** Vector location. */\n+    private Vector1D location;\n \n     /** Orientation. */\n     private boolean direct;\n     /** Simple constructor.\n      * @param location location of the hyperplane\n      * @param direct if true, the plus side of the hyperplane is towards\n-     * abscissae greater than {@code location}\n+     * abscissas greater than {@code location}\n      */\n-    public OrientedPoint(final Point1D location, final boolean direct) {\n+    public OrientedPoint(final Vector1D location, final boolean direct) {\n         this.location = location;\n         this.direct   = direct;\n     }\n      * the instance.</p>\n      * @return the instance itself\n      */\n-    public Hyperplane copySelf() {\n+    public OrientedPoint copySelf() {\n         return this;\n     }\n \n-    /** Get the offset (oriented distance) of a point to the hyperplane.\n-     * @param point point to check\n-     * @return offset of the point\n-     */\n-    public double getOffset(final Point point) {\n-        final double delta = ((Point1D) point).getAbscissa() - location.getAbscissa();\n+    /** {@inheritDoc} */\n+    public double getOffset(final Vector<Euclidean1D> point) {\n+        final double delta = ((Vector1D) point).getX() - location.getX();\n         return direct ? delta : -delta;\n-    }\n-\n-    /** Transform a space point into a sub-space point.\n-     * <p>Since this class represent zero dimension spaces which does\n-     * not have lower dimension sub-spaces, this method cannot be\n-     * supported here. It always throws a {@code RuntimeException}\n-     * when called.</p>\n-     * @param point n-dimension point of the space\n-     * @return (n-1)-dimension point of the sub-space corresponding to\n-     * the specified space point\n-     * @see #toSpace\n-     */\n-    public Point toSubSpace(final Point point) {\n-        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n-    }\n-\n-    /** Transform a sub-space point into a space point.\n-     * <p>Since this class represent zero dimension spaces which does\n-     * not have lower dimension sub-spaces, this method cannot be\n-     * supported here. It always throws a {@code RuntimeException}\n-     * when called.</p>\n-     * @param point (n-1)-dimension point of the sub-space\n-     * @return n-dimension point of the space corresponding to the\n-     * specified sub-space point\n-     * @see #toSubSpace\n-     */\n-    public Point toSpace(final Point point) {\n-        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n-    }\n-\n-    /** Build the sub-space shared by the instance and another hyperplane.\n-     * <p>Since this class represent zero dimension spaces which does\n-     * not have lower dimension sub-spaces, this method cannot be\n-     * supported here. It always throws a {@code RuntimeException}\n-     * when called.</p>\n-     * @param other other sub-space (must have the same dimension as the\n-     * instance)\n-     * @return a sub-space at the intersection of the instance and the\n-     * other sub-space (it has a dimension one unit less than the\n-     * instance)\n-     */\n-    public SubSpace intersection(final Hyperplane other) {\n-        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n     }\n \n     /** Build a region covering the whole hyperplane.\n      * properly, it should <em>not</em> be used otherwise.</p>\n      * @return a dummy region\n      */\n-    public Region wholeHyperplane() {\n-        return DUMMY_REGION;\n+    public SubOrientedPoint wholeHyperplane() {\n+        return new SubOrientedPoint(this, null);\n     }\n \n     /** Build a region covering the whole space.\n      * @return a region containing the instance (really an {@link\n      * IntervalsSet IntervalsSet} instance)\n      */\n-    public Region wholeSpace() {\n+    public IntervalsSet wholeSpace() {\n         return new IntervalsSet();\n     }\n \n      * @return true if the instance and the other hyperplane have\n      * the same orientation\n      */\n-    public boolean sameOrientationAs(final Hyperplane other) {\n+    public boolean sameOrientationAs(final Hyperplane<Euclidean1D> other) {\n         return !(direct ^ ((OrientedPoint) other).direct);\n-    }\n-\n-    /** Compute the relative position of a sub-hyperplane with respect\n-     * to the instance.\n-     * @param sub sub-hyperplane to check\n-     * @return one of {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#PLUS PLUS},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#MINUS MINUS}\n-     * or {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n-     * (in dimension 1, this method <em>never</em> returns {@link\n-     * org.apache.commons.math.geometry.partitioning.Hyperplane.Side#BOTH BOTH})\n-     *\n-     */\n-    public Side side(final SubHyperplane sub) {\n-        final double global = getOffset(((OrientedPoint) sub.getHyperplane()).location);\n-        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n-    }\n-\n-    /** Split a sub-hyperplane in two parts by the instance.\n-     * @param sub sub-hyperplane to split\n-     * @return an object containing both the part of the sub-hyperplane\n-     * on the plus side of the instance and the part of the\n-     * sub-hyperplane on the minus side of the instance\n-     */\n-    public SplitSubHyperplane split(final SubHyperplane sub) {\n-        final double global = getOffset(((OrientedPoint) sub.getHyperplane()).location);\n-        return (global < -1.0e-10) ? new SplitSubHyperplane(null, sub) : new SplitSubHyperplane(sub, null);\n     }\n \n     /** Get the hyperplane location on the real line.\n      * @return the hyperplane location\n      */\n-    public Point1D getLocation() {\n+    public Vector1D getLocation() {\n         return location;\n     }\n \n         direct = !direct;\n     }\n \n-    /** Dummy region representing the whole set of reals. */\n-    private static class DummyRegion extends Region {\n-\n-        /** Simple constructor.\n-         */\n-        public DummyRegion() {\n-            super();\n-        }\n-\n-        /** {@inheritDoc} */\n-        public Region buildNew(final BSPTree tree) {\n-            return this;\n-        }\n-\n-        /** {@inheritDoc} */\n-        protected void computeGeometricalProperties() {\n-            setSize(0);\n-            setBarycenter(Point1D.ZERO);\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/SubOrientedPoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oned;\n+\n+import org.apache.commons.math.geometry.partitioning.AbstractSubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.Side;\n+\n+/** This class represents sub-hyperplane for {@link OrOrientedPoint}.\n+ * <p>An hyperplane in 1D is a simple point, its orientation being a\n+ * boolean.</p>\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class SubOrientedPoint extends AbstractSubHyperplane<Euclidean1D, Euclidean1D> {\n+\n+    /** Simple constructor.\n+     * @param hyperplane underlying hyperplane\n+     * @param remainingRegion remaining region of the hyperplane\n+     */\n+    public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\n+                            final Region<Euclidean1D> remainingRegion) {\n+        super(hyperplane, remainingRegion);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSize() {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected AbstractSubHyperplane<Euclidean1D, Euclidean1D> buildNew(final Hyperplane<Euclidean1D> hyperplane,\n+                                                                       final Region<Euclidean1D> remainingRegion) {\n+        return new SubOrientedPoint(hyperplane, remainingRegion);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Side side(final Hyperplane<Euclidean1D> hyperplane) {\n+        final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n+        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public SplitSubHyperplane<Euclidean1D> split(final Hyperplane<Euclidean1D> hyperplane) {\n+        final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n+        return (global < -1.0e-10) ?\n+                                    new SplitSubHyperplane<Euclidean1D>(null, this) :\n+                                        new SplitSubHyperplane<Euclidean1D>(this, null);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n-import org.apache.commons.math.geometry.partitioning.Point;\n-import org.apache.commons.math.geometry.partitioning.SubSpace;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.partitioning.Embedding;\n import org.apache.commons.math.util.FastMath;\n \n /** The class represent lines in a three dimensional space.\n  * which is closest to the origin. Abscissa increases in the line\n  * direction.</p>\n \n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class Line implements SubSpace {\n+public class Line implements Embedding<Euclidean3D, Euclidean1D> {\n \n     /** Line direction. */\n     private Vector3D direction;\n \n     /** Line point closest to the origin. */\n-    private Point3D zero;\n+    private Vector3D zero;\n \n     /** Build a line from a point and a direction.\n      * @param p point belonging to the line (this can be any point)\n             throw new IllegalArgumentException(\"null norm\");\n         }\n         this.direction = new Vector3D(1.0 / norm, dir);\n-        zero = new Point3D(1.0, p, -Vector3D.dotProduct(p, this.direction), this.direction);\n+        zero = new Vector3D(1.0, p, -Vector3D.dotProduct(p, this.direction), this.direction);\n     }\n \n-    /** Revert the line direction.\n+    /** Get a line with reversed direction.\n+     * @return a new instance, with reversed direction\n      */\n-    public void revertSelf() {\n-        direction = direction.negate();\n+    public Line revert() {\n+        return new Line(zero, direction.negate());\n     }\n \n     /** Get the normalized direction vector.\n      * @param point point to check (must be a {@link Vector3D Vector3D}\n      * instance)\n      * @return abscissa of the point (really a\n-     * {org.apache.commons.math.geometry.euclidean.oned.Point1D Point1D} instance)\n+     * {org.apache.commons.math.geometry.euclidean.oned.Vector1D Vector1D} instance)\n      */\n-    public Point toSubSpace(final Point point) {\n-        final double x = Vector3D.dotProduct(((Vector3D) point).subtract(zero), direction);\n-        return new Point1D(x);\n+    public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\n+        Vector3D p3 = (Vector3D) point;\n+        return new Vector1D(Vector3D.dotProduct(p3.subtract(zero), direction));\n     }\n \n     /** Get one point from the line.\n      * @param point desired abscissa for the point (must be a\n-     * {org.apache.commons.math.geometry.euclidean.oned.Point1D Point1D} instance)\n+     * {org.apache.commons.math.geometry.euclidean.oned.Vector1D Vector1D} instance)\n      * @return one point belonging to the line, at specified abscissa\n      * (really a {@link Vector3D Vector3D} instance)\n      */\n-    public Point toSpace(final Point point) {\n-        return new Point3D(1.0, zero, ((Point1D) point).getAbscissa(), direction);\n+    public Vector3D toSpace(final Vector<Euclidean1D> point) {\n+        Vector1D p1 = (Vector1D) point;\n+        return new Vector3D(1.0, zero, p1.getX(), direction);\n     }\n \n     /** Check if the instance is similar to another line.\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/OutlineExtractor.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/OutlineExtractor.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n-import org.apache.commons.math.geometry.euclidean.twod.Point2D;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n+import org.apache.commons.math.geometry.partitioning.AbstractSubHyperplane;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n-import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.BoundaryAttribute;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.util.FastMath;\n-\n-import java.util.ArrayList;\n \n /** Extractor for {@link PolygonsSet polyhedrons sets} outlines.\n  * <p>This class extracts the 2D outlines from {{@link PolygonsSet\n  * polyhedrons sets} in a specified projection plane.</p>\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n public class OutlineExtractor {\n \n      * @param polyhedronsSet polyhedrons set whose outline must be extracted\n      * @return an outline, as an array of loops.\n      */\n-    public Point2D[][] getOutline(final PolyhedronsSet polyhedronsSet) {\n+    public Vector2D[][] getOutline(final PolyhedronsSet polyhedronsSet) {\n \n         // project all boundary facets into one polygons set\n         final BoundaryProjector projector = new BoundaryProjector();\n         final PolygonsSet projected = projector.getProjected();\n \n         // Remove the spurious intermediate vertices from the outline\n-        final Point2D[][] outline = projected.getVertices();\n+        final Vector2D[][] outline = projected.getVertices();\n         for (int i = 0; i < outline.length; ++i) {\n-            final Point2D[] rawLoop = outline[i];\n+            final Vector2D[] rawLoop = outline[i];\n             int end = rawLoop.length;\n             int j = 0;\n             while (j < end) {\n             }\n             if (end != rawLoop.length) {\n                 // resize the array\n-                outline[i] = new Point2D[end];\n+                outline[i] = new Vector2D[end];\n                 System.arraycopy(rawLoop, 0, outline[i], 0, end);\n             }\n         }\n      * @param i index of the point to check (must be between 0 and n-1)\n      * @return true if the point is exactly between its neighbours\n      */\n-    private boolean pointIsBetween(final Point2D[] loop, final int n, final int i) {\n-        final Point2D previous = loop[(i + n - 1) % n];\n-        final Point2D current  = loop[i];\n-        final Point2D next     = loop[(i + 1) % n];\n-        final double dx1       = current.x - previous.x;\n-        final double dy1       = current.y - previous.y;\n-        final double dx2       = next.x    - current.x;\n-        final double dy2       = next.y    - current.y;\n+    private boolean pointIsBetween(final Vector2D[] loop, final int n, final int i) {\n+        final Vector2D previous = loop[(i + n - 1) % n];\n+        final Vector2D current  = loop[i];\n+        final Vector2D next     = loop[(i + 1) % n];\n+        final double dx1       = current.getX() - previous.getX();\n+        final double dy1       = current.getY() - previous.getY();\n+        final double dx2       = next.getX()    - current.getX();\n+        final double dy2       = next.getY()    - current.getY();\n         final double cross     = dx1 * dy2 - dx2 * dy1;\n         final double dot       = dx1 * dx2 + dy1 * dy2;\n         final double d1d2      = FastMath.sqrt((dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2));\n     }\n \n     /** Visitor projecting the boundary facets on a plane. */\n-    private class BoundaryProjector implements BSPTreeVisitor {\n+    private class BoundaryProjector implements BSPTreeVisitor<Euclidean3D> {\n \n         /** Projection of the polyhedrons set on the plane. */\n         private PolygonsSet projected;\n         /** Simple constructor.\n          */\n         public BoundaryProjector() {\n-            projected = new PolygonsSet(new BSPTree(Boolean.FALSE));\n+            projected = new PolygonsSet(new BSPTree<Euclidean2D>(Boolean.FALSE));\n         }\n \n         /** {@inheritDoc} */\n-        public Order visitOrder(final BSPTree node) {\n+        public Order visitOrder(final BSPTree<Euclidean3D> node) {\n             return Order.MINUS_SUB_PLUS;\n         }\n \n         /** {@inheritDoc} */\n-        public void visitInternalNode(final BSPTree node) {\n-            final Region.BoundaryAttribute attribute =\n-                (Region.BoundaryAttribute) node.getAttribute();\n+        public void visitInternalNode(final BSPTree<Euclidean3D> node) {\n+            @SuppressWarnings(\"unchecked\")\n+            final BoundaryAttribute<Euclidean3D> attribute =\n+                (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n             if (attribute.getPlusOutside() != null) {\n                 addContribution(attribute.getPlusOutside(), false);\n             }\n         }\n \n         /** {@inheritDoc} */\n-        public void visitLeafNode(final BSPTree node) {\n+        public void visitLeafNode(final BSPTree<Euclidean3D> node) {\n         }\n \n         /** Add he contribution of a boundary facet.\n          * @param facet boundary facet\n          * @param reversed if true, the facet has the inside on its plus side\n          */\n-        private void addContribution(final SubHyperplane facet, final boolean reversed) {\n+        private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) {\n \n             // extract the vertices of the facet\n+            @SuppressWarnings(\"unchecked\")\n+            final AbstractSubHyperplane<Euclidean3D, Euclidean2D> absFacet =\n+                (AbstractSubHyperplane<Euclidean3D, Euclidean2D>) facet;\n             final Plane plane    = (Plane) facet.getHyperplane();\n-            Point2D[][] vertices =\n-                ((PolygonsSet) facet.getRemainingRegion()).getVertices();\n+            Vector2D[][] vertices =\n+                ((PolygonsSet) absFacet.getRemainingRegion()).getVertices();\n \n             final double scal = Vector3D.dotProduct(plane.getNormal(), w);\n             if (FastMath.abs(scal) > 1.0e-3) {\n                 if ((scal < 0) ^ reversed) {\n                     // the facet is seen from the inside,\n                     // we need to invert its boundary orientation\n-                    final Point2D[][] newVertices = new Point2D[vertices.length][];\n+                    final Vector2D[][] newVertices = new Vector2D[vertices.length][];\n                     for (int i = 0; i < vertices.length; ++i) {\n-                        final Point2D[] loop = vertices[i];\n-                        final Point2D[] newLoop = new Point2D[loop.length];\n+                        final Vector2D[] loop = vertices[i];\n+                        final Vector2D[] newLoop = new Vector2D[loop.length];\n                         if (loop[0] == null) {\n                             newLoop[0] = null;\n                             for (int j = 1; j < loop.length; ++j) {\n                 }\n \n                 // compute the projection of the facet in the outline plane\n-                final ArrayList<SubHyperplane> edges = new ArrayList<SubHyperplane>();\n-                for (Point2D[] loop : vertices) {\n+                final ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<SubHyperplane<Euclidean2D>>();\n+                for (Vector2D[] loop : vertices) {\n                     final boolean closed = loop[0] != null;\n                     int previous         = closed ? (loop.length - 1) : 1;\n                     Vector3D previous3D  = (Vector3D) plane.toSpace(loop[previous]);\n                     int current          = (previous + 1) % loop.length;\n-                    Point2D pPoint       = new Point2D(Vector3D.dotProduct(previous3D, u),\n+                    Vector2D pPoint       = new Vector2D(Vector3D.dotProduct(previous3D, u),\n                                                        Vector3D.dotProduct(previous3D, v));\n                     while (current < loop.length) {\n \n                         final Vector3D current3D = (Vector3D) plane.toSpace(loop[current]);\n-                        final Point2D  cPoint    = new Point2D(Vector3D.dotProduct(current3D, u),\n+                        final Vector2D  cPoint    = new Vector2D(Vector3D.dotProduct(current3D, u),\n                                                                Vector3D.dotProduct(current3D, v));\n                         final org.apache.commons.math.geometry.euclidean.twod.Line line =\n                             new org.apache.commons.math.geometry.euclidean.twod.Line(pPoint, cPoint);\n-                        SubHyperplane edge = new SubHyperplane(line);\n+                        SubHyperplane<Euclidean2D> edge = line.wholeHyperplane();\n \n                         if (closed || (previous != 1)) {\n                             // the previous point is a real vertex\n                             final double angle = line.getAngle() + 0.5 * FastMath.PI;\n                             final org.apache.commons.math.geometry.euclidean.twod.Line l =\n                                 new org.apache.commons.math.geometry.euclidean.twod.Line(pPoint, angle);\n-                            edge = l.split(edge).getPlus();\n+                            edge = edge.split(l).getPlus();\n                         }\n \n                         if (closed || (current != (loop.length - 1))) {\n                             final double angle = line.getAngle() + 0.5 * FastMath.PI;\n                             final org.apache.commons.math.geometry.euclidean.twod.Line l =\n                                 new org.apache.commons.math.geometry.euclidean.twod.Line(cPoint, angle);\n-                            edge = l.split(edge).getMinus();\n+                            edge = edge.split(l).getMinus();\n                         }\n \n                         edges.add(edge);\n                 final PolygonsSet projectedFacet = new PolygonsSet(edges);\n \n                 // add the contribution of the facet to the global outline\n-                projected = (PolygonsSet) Region.union(projected, projectedFacet);\n+                projected = (PolygonsSet) new RegionFactory<Euclidean2D>().union(projected, projectedFacet);\n \n             }\n         }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n-import org.apache.commons.math.geometry.euclidean.twod.Point2D;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.euclidean.twod.Euclidean2D;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;\n-import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Embedding;\n import org.apache.commons.math.geometry.partitioning.Hyperplane;\n-import org.apache.commons.math.geometry.partitioning.Point;\n-import org.apache.commons.math.geometry.partitioning.Region;\n-import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n-import org.apache.commons.math.geometry.partitioning.SubSpace;\n import org.apache.commons.math.util.FastMath;\n \n /** The class represent planes in a three dimensional space.\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class Plane implements Hyperplane {\n+public class Plane implements Hyperplane<Euclidean3D>, Embedding<Euclidean3D, Euclidean2D> {\n \n     /** Offset of the origin with respect to the plane. */\n     private double originOffset;\n \n     /** Origin of the plane frame. */\n-    private Point3D origin;\n+    private Vector3D origin;\n \n     /** First vector of the plane frame (in plane). */\n     private Vector3D u;\n      * shared (except for immutable objects).</p>\n      * @return a new hyperplane, copy of the instance\n      */\n-    public Hyperplane copySelf() {\n+    public Plane copySelf() {\n         return new Plane(this);\n     }\n \n     /** Reset the plane frame.\n      */\n     private void setFrame() {\n-        origin = new Point3D(-originOffset, w);\n+        origin = new Vector3D(-originOffset, w);\n         u = w.orthogonal();\n         v = Vector3D.crossProduct(w, u);\n     }\n      * @return the origin point of the plane frame (point closest to the\n      * 3D-space origin)\n      */\n-    public Point3D getOrigin() {\n+    public Vector3D getOrigin() {\n         return origin;\n     }\n \n      * @param point point of the space (must be a {@link Vector3D\n      * Vector3D} instance)\n      * @return in-plane point (really a {@link\n-     * org.apache.commons.math.geometry.euclidean.twod.Point2D Point2D} instance)\n+     * org.apache.commons.math.geometry.euclidean.twod.Vector2D Vector2D} instance)\n      * @see #toSpace\n      */\n-    public Point toSubSpace(final Point point) {\n+    public Vector2D toSubSpace(final Vector<Euclidean3D> point) {\n         final Vector3D p3D = (Vector3D) point;\n-        return new Point2D(Vector3D.dotProduct(p3D, u),\n+        return new Vector2D(Vector3D.dotProduct(p3D, u),\n                            Vector3D.dotProduct(p3D, v));\n     }\n \n     /** Transform an in-plane point into a 3D space point.\n      * @param point in-plane point (must be a {@link\n-     * org.apache.commons.math.geometry.euclidean.twod.Point2D Point2D} instance)\n+     * org.apache.commons.math.geometry.euclidean.twod.Vector2D Vector2D} instance)\n      * @return 3D space point (really a {@link Vector3D Vector3D} instance)\n      * @see #toSubSpace\n      */\n-    public Point toSpace(final Point point) {\n-        final Point2D p2D = (Point2D) point;\n-        return new Point3D(p2D.x, u, p2D.y, v, -originOffset, w);\n+    public Vector3D toSpace(final Vector<Euclidean2D> point) {\n+        final Vector2D p2D = (Vector2D) point;\n+        return new Vector3D(p2D.getX(), u, p2D.getY(), v, -originOffset, w);\n     }\n \n     /** Get one point from the 3D-space.\n      * @return one point in the 3D-space, with given coordinates and offset\n      * relative to the plane\n      */\n-    public Vector3D getPointAt(final Point2D inPlane, final double offset) {\n-        return new Vector3D(inPlane.x, u, inPlane.y, v, offset - originOffset, w);\n+    public Vector3D getPointAt(final Vector2D inPlane, final double offset) {\n+        return new Vector3D(inPlane.getX(), u, inPlane.getY(), v, offset - originOffset, w);\n     }\n \n     /** Check if the instance is similar to another plane.\n      * @return intersection point between between the line and the\n      * instance (null if the line is parallel to the instance)\n      */\n-    public Point3D intersection(final Line line) {\n+    public Vector3D intersection(final Line line) {\n         final Vector3D direction = line.getDirection();\n         final double   dot       = Vector3D.dotProduct(w, direction);\n         if (FastMath.abs(dot) < 1.0e-10) {\n             return null;\n         }\n-        final Vector3D point = (Vector3D) line.toSpace(Point1D.ZERO);\n+        final Vector3D point = (Vector3D) line.toSpace(Vector1D.ZERO);\n         final double   k     = -(originOffset + Vector3D.dotProduct(w, point)) / dot;\n-        return new Point3D(1.0, point, k, direction);\n+        return new Vector3D(1.0, point, k, direction);\n     }\n \n     /** Build the line shared by the instance and another plane.\n      * @return line at the intersection of the instance and the\n      * other plane (really a {@link Line Line} instance)\n      */\n-    public SubSpace intersection(final Hyperplane other) {\n-        final Plane otherP = (Plane) other;\n-        final Vector3D direction = Vector3D.crossProduct(w, otherP.w);\n+    public Line intersection(final Plane other) {\n+        final Vector3D direction = Vector3D.crossProduct(w, other.w);\n         if (direction.getNorm() < 1.0e-10) {\n             return null;\n         }\n-        return new Line(intersection(this, otherP, new Plane(direction)),\n+        return new Line(intersection(this, other, new Plane(direction)),\n                         direction);\n     }\n \n     /** Build a region covering the whole hyperplane.\n      * @return a region covering the whole hyperplane\n      */\n-    public Region wholeHyperplane() {\n-        return new PolygonsSet();\n+    public SubPlane wholeHyperplane() {\n+        return new SubPlane(this, new PolygonsSet());\n     }\n \n     /** Build a region covering the whole space.\n      * @return a region containing the instance (really a {@link\n      * PolyhedronsSet PolyhedronsSet} instance)\n      */\n-    public Region wholeSpace() {\n+    public PolyhedronsSet wholeSpace() {\n         return new PolyhedronsSet();\n     }\n \n      * @param p point to check\n      * @return true if p belongs to the plane\n      */\n-    public boolean contains(final Point3D p) {\n+    public boolean contains(final Vector3D p) {\n         return FastMath.abs(getOffset(p)) < 1.0e-10;\n     }\n \n      * @param point point to check\n      * @return offset of the point\n      */\n-    public double getOffset(final Point point) {\n+    public double getOffset(final Vector<Euclidean3D> point) {\n         return Vector3D.dotProduct((Vector3D) point, w) + originOffset;\n     }\n \n      * @return true if the instance and the other hyperplane have\n      * the same orientation\n      */\n-    public boolean sameOrientationAs(final Hyperplane other) {\n+    public boolean sameOrientationAs(final Hyperplane<Euclidean3D> other) {\n         return Vector3D.dotProduct(((Plane) other).w, w) > 0.0;\n     }\n \n-    /** Compute the relative position of a sub-hyperplane with respect\n-     * to the instance.\n-     * @param sub sub-hyperplane to check\n-     * @return one of {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#PLUS PLUS},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#MINUS MINUS},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#BOTH BOTH},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n-     */\n-    public Side side(final SubHyperplane sub) {\n-\n-        final Plane otherPlane = (Plane) sub.getHyperplane();\n-        final Line  inter      = (Line) intersection(otherPlane);\n-\n-        if (inter == null) {\n-            // the hyperplanes are parallel,\n-            // any point can be used to check their relative position\n-            final double global = getOffset(otherPlane);\n-            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n-        }\n-\n-        // create a 2D line in the otherPlane canonical 2D frame such that:\n-        //   - the line is the crossing line of the two planes in 3D\n-        //   - the line splits the otherPlane in two half planes with an\n-        //     orientation consistent with the orientation of the instance\n-        //     (i.e. the 3D half space on the plus side (resp. minus side)\n-        //      of the instance contains the 2D half plane on the plus side\n-        //      (resp. minus side) of the 2D line\n-        Point2D p = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ZERO));\n-        Point2D q = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ONE));\n-        if (Vector3D.dotProduct(Vector3D.crossProduct(inter.getDirection(),\n-                                                      otherPlane.getNormal()),\n-                                                      w) < 0) {\n-            final Point2D tmp = p;\n-            p           = q;\n-            q           = tmp;\n-        }\n-        final Hyperplane line2D = new org.apache.commons.math.geometry.euclidean.twod.Line(p, q);\n-\n-        // check the side on the 2D plane\n-        return sub.getRemainingRegion().side(line2D);\n-\n-    }\n-\n-    /** Split a sub-hyperplane in two parts by the instance.\n-     * @param sub sub-hyperplane to split\n-     * @return an object containing both the part of the sub-hyperplane\n-     * on the plus side of the instance and the part of the\n-     * sub-hyperplane on the minus side of the instance\n-     */\n-    public SplitSubHyperplane split(final SubHyperplane sub) {\n-\n-        final Plane otherPlane = (Plane) sub.getHyperplane();\n-        final Line  inter      = (Line) intersection(otherPlane);\n-\n-        if (inter == null) {\n-            // the hyperplanes are parallel\n-            final double global = getOffset(otherPlane);\n-            return (global < -1.0e-10) ? new SplitSubHyperplane(null, sub) : new SplitSubHyperplane(sub, null);\n-        }\n-\n-        // the hyperplanes do intersect\n-        Point2D p = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ZERO));\n-        Point2D q = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ONE));\n-        if (Vector3D.dotProduct(Vector3D.crossProduct(inter.getDirection(),\n-                                                      otherPlane.getNormal()),\n-                                                      w) < 0) {\n-            final Point2D tmp = p;\n-            p           = q;\n-            q           = tmp;\n-        }\n-        final SubHyperplane l2DMinus =\n-            new SubHyperplane(new org.apache.commons.math.geometry.euclidean.twod.Line(p, q));\n-        final SubHyperplane l2DPlus =\n-            new SubHyperplane(new org.apache.commons.math.geometry.euclidean.twod.Line(q, p));\n-\n-        final BSPTree splitTree =\n-            sub.getRemainingRegion().getTree(false).split(l2DMinus);\n-        final BSPTree plusTree  = Region.isEmpty(splitTree.getPlus()) ?\n-                                  new BSPTree(Boolean.FALSE) :\n-                                  new BSPTree(l2DPlus, new BSPTree(Boolean.FALSE),\n-                                              splitTree.getPlus(), null);\n-\n-        final BSPTree minusTree = Region.isEmpty(splitTree.getMinus()) ?\n-                                  new BSPTree(Boolean.FALSE) :\n-                                  new BSPTree(l2DMinus, new BSPTree(Boolean.FALSE),\n-                                              splitTree.getMinus(), null);\n-\n-        return new SplitSubHyperplane(new SubHyperplane(otherPlane.copySelf(),\n-                                                        new PolygonsSet(plusTree)),\n-                                                        new SubHyperplane(otherPlane.copySelf(),\n-                                                                          new PolygonsSet(minusTree)));\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSet.java\n package org.apache.commons.math.geometry.euclidean.threed;\n \n import java.awt.geom.AffineTransform;\n-import java.util.Arrays;\n import java.util.Collection;\n \n-import org.apache.commons.math.geometry.euclidean.twod.Point2D;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.twod.Euclidean2D;\n+import org.apache.commons.math.geometry.euclidean.twod.SubLine;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n+import org.apache.commons.math.geometry.partitioning.BoundaryAttribute;\n import org.apache.commons.math.geometry.partitioning.Hyperplane;\n-import org.apache.commons.math.geometry.partitioning.Point;\n import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.geometry.partitioning.Transform;\n+import org.apache.commons.math.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math.util.FastMath;\n \n /** This class represents a 3D region: a set of polyhedrons.\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class PolyhedronsSet extends Region {\n+public class PolyhedronsSet extends AbstractRegion<Euclidean3D, Euclidean2D> {\n \n     /** Build a polyhedrons set representing the whole real line.\n      */\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n      * @param tree inside/outside BSP tree representing the region\n      */\n-    public PolyhedronsSet(final BSPTree tree) {\n+    public PolyhedronsSet(final BSPTree<Euclidean3D> tree) {\n         super(tree);\n     }\n \n      * its plus side.</p>\n      * <p>The boundary elements can be in any order, and can form\n      * several non-connected sets (like for example polyhedrons with holes\n-     * or a set of disjoints polyhedrons considered as a whole). In\n+     * or a set of disjoint polyhedrons considered as a whole). In\n      * fact, the elements do not even need to be connected together\n      * (their topological connections are not used here). However, if the\n      * boundary does not really separate an inside open from an outside\n      * open (open having here its topological meaning), then subsequent\n-     * calls to the {@link Region#checkPoint(Point) checkPoint} method will\n+     * calls to the {@link Region#checkPoint(Vector) checkPoint} method will\n      * not be meaningful anymore.</p>\n      * <p>If the boundary is empty, the region will represent the whole\n      * space.</p>\n      * @param boundary collection of boundary elements, as a\n      * collection of {@link SubHyperplane SubHyperplane} objects\n      */\n-    public PolyhedronsSet(final Collection<SubHyperplane> boundary) {\n+    public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary) {\n         super(boundary);\n     }\n \n      * @param zMin low bound along the z direction\n      * @param zMax high bound along the z direction\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public PolyhedronsSet(final double xMin, final double xMax,\n                           final double yMin, final double yMax,\n                           final double zMin, final double zMax) {\n-        this(buildConvex(Arrays.asList(new Hyperplane[] {\n+        this(new RegionFactory<Euclidean3D>().buildConvex(\n             new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I),\n             new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I),\n             new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J),\n             new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J),\n             new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K),\n-            new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K)\n-        })).getTree(false));\n+            new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K)).getTree(false));\n     }\n \n     /** {@inheritDoc} */\n-    public Region buildNew(final BSPTree tree) {\n+    public PolyhedronsSet buildNew(final BSPTree<Euclidean3D> tree) {\n         return new PolyhedronsSet(tree);\n     }\n \n             // the polyhedrons set as a finite outside\n             // surrounded by an infinite inside\n             setSize(Double.POSITIVE_INFINITY);\n-            setBarycenter(Point3D.UNDEFINED);\n+            setBarycenter(Vector3D.NaN);\n         } else {\n             // the polyhedrons set is finite, apply the remaining scaling factors\n             setSize(getSize() / 3.0);\n-            setBarycenter(new Point3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n+            setBarycenter(new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n         }\n \n     }\n \n     /** Visitor computing geometrical properties. */\n-    private class FacetsContributionVisitor implements BSPTreeVisitor {\n+    private class FacetsContributionVisitor implements BSPTreeVisitor<Euclidean3D> {\n \n         /** Simple constructor. */\n         public FacetsContributionVisitor() {\n             setSize(0);\n-            setBarycenter(new Point3D(0, 0, 0));\n-        }\n-\n-        /** {@inheritDoc} */\n-        public Order visitOrder(final BSPTree node) {\n+            setBarycenter(new Vector3D(0, 0, 0));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(final BSPTree<Euclidean3D> node) {\n             return Order.MINUS_SUB_PLUS;\n         }\n \n         /** {@inheritDoc} */\n-        public void visitInternalNode(final BSPTree node) {\n-            final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+        public void visitInternalNode(final BSPTree<Euclidean3D> node) {\n+            @SuppressWarnings(\"unchecked\")\n+            final BoundaryAttribute<Euclidean3D> attribute =\n+                (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n             if (attribute.getPlusOutside() != null) {\n                 addContribution(attribute.getPlusOutside(), false);\n             }\n         }\n \n         /** {@inheritDoc} */\n-        public void visitLeafNode(final BSPTree node) {\n+        public void visitLeafNode(final BSPTree<Euclidean3D> node) {\n         }\n \n         /** Add he contribution of a boundary facet.\n          * @param facet boundary facet\n          * @param reversed if true, the facet has the inside on its plus side\n          */\n-        private void addContribution(final SubHyperplane facet, final boolean reversed) {\n-\n-            final Region polygon = facet.getRemainingRegion();\n+        private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) {\n+\n+            final Region<Euclidean2D> polygon = ((SubPlane) facet).getRemainingRegion();\n             final double area    = polygon.getSize();\n \n             if (Double.isInfinite(area)) {\n                 setSize(Double.POSITIVE_INFINITY);\n-                setBarycenter(Point3D.UNDEFINED);\n+                setBarycenter(Vector3D.NaN);\n             } else {\n \n                 final Plane    plane  = (Plane) facet.getHyperplane();\n-                final Vector3D facetB = (Point3D) plane.toSpace(polygon.getBarycenter());\n+                final Vector3D facetB = plane.toSpace(polygon.getBarycenter());\n                 double   scaled = area * Vector3D.dotProduct(facetB, plane.getNormal());\n                 if (reversed) {\n                     scaled = -scaled;\n                 }\n \n                 setSize(getSize() + scaled);\n-                setBarycenter(new Point3D(1.0, (Point3D) getBarycenter(), scaled, facetB));\n+                setBarycenter(new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB));\n \n             }\n \n      * given point, or null if the line does not intersect any\n      * sub-hyperplaned\n      */\n-    public SubHyperplane firstIntersection(final Vector3D point, final Line line) {\n+    public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {\n         return recurseFirstIntersection(getTree(true), point, line);\n     }\n \n      * given point, or null if the line does not intersect any\n      * sub-hyperplaned\n      */\n-    private SubHyperplane recurseFirstIntersection(final BSPTree node,\n-                                                   final Vector3D point,\n-                                                   final Line line) {\n-\n-        final SubHyperplane cut = node.getCut();\n+    private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,\n+                                                                final Vector3D point,\n+                                                                final Line line) {\n+\n+        final SubHyperplane<Euclidean3D> cut = node.getCut();\n         if (cut == null) {\n             return null;\n         }\n-        final BSPTree minus = node.getMinus();\n-        final BSPTree plus  = node.getPlus();\n-        final Plane   plane = (Plane) cut.getHyperplane();\n+        final BSPTree<Euclidean3D> minus = node.getMinus();\n+        final BSPTree<Euclidean3D> plus  = node.getPlus();\n+        final Plane               plane = (Plane) cut.getHyperplane();\n \n         // establish search order\n-        final double offset = plane.getOffset((Point) point);\n+        final double offset = plane.getOffset(point);\n         final boolean in    = FastMath.abs(offset) < 1.0e-10;\n-        final BSPTree near;\n-        final BSPTree far;\n+        final BSPTree<Euclidean3D> near;\n+        final BSPTree<Euclidean3D> far;\n         if (offset < 0) {\n             near = minus;\n             far  = plus;\n \n         if (in) {\n             // search in the cut hyperplane\n-            final SubHyperplane facet = boundaryFacet(point, node);\n+            final SubHyperplane<Euclidean3D> facet = boundaryFacet(point, node);\n             if (facet != null) {\n                 return facet;\n             }\n         }\n \n         // search in the near branch\n-        final SubHyperplane crossed = recurseFirstIntersection(near, point, line);\n+        final SubHyperplane<Euclidean3D> crossed = recurseFirstIntersection(near, point, line);\n         if (crossed != null) {\n             return crossed;\n         }\n             // search in the cut hyperplane\n             final Vector3D hit3D = plane.intersection(line);\n             if (hit3D != null) {\n-                final SubHyperplane facet = boundaryFacet(hit3D, node);\n+                final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);\n                 if (facet != null) {\n                     return facet;\n                 }\n      * @return the boundary facet this points belongs to (or null if it\n      * does not belong to any boundary facet)\n      */\n-    private SubHyperplane boundaryFacet(final Vector3D point, final BSPTree node) {\n-        final Point point2D = node.getCut().getHyperplane().toSubSpace((Point) point);\n-        final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+    private SubHyperplane<Euclidean3D> boundaryFacet(final Vector3D point,\n+                                                     final BSPTree<Euclidean3D> node) {\n+        final Vector2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace(point);\n+        @SuppressWarnings(\"unchecked\")\n+        final BoundaryAttribute<Euclidean3D> attribute =\n+            (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n         if ((attribute.getPlusOutside() != null) &&\n-            (attribute.getPlusOutside().getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n+            (((SubPlane) attribute.getPlusOutside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n             return attribute.getPlusOutside();\n         }\n         if ((attribute.getPlusInside() != null) &&\n-            (attribute.getPlusInside().getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n+            (((SubPlane) attribute.getPlusInside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n             return attribute.getPlusInside();\n         }\n         return null;\n     }\n \n     /** 3D rotation as a Transform. */\n-    private static class RotationTransform implements Transform {\n+    private static class RotationTransform implements Transform<Euclidean3D, Euclidean2D> {\n \n         /** Center point of the rotation. */\n         private Vector3D   center;\n         private Rotation   rotation;\n \n         /** Cached original hyperplane. */\n-        private Hyperplane cachedOriginal;\n+        private Plane cachedOriginal;\n \n         /** Cached 2D transform valid inside the cached original hyperplane. */\n-        private Transform  cachedTransform;\n+        private Transform<Euclidean2D, Euclidean1D>  cachedTransform;\n \n         /** Build a rotation transform.\n          * @param center center point of the rotation\n         }\n \n         /** {@inheritDoc} */\n-        public Point apply(final Point point) {\n+        public Vector3D apply(final Vector<Euclidean3D> point) {\n             final Vector3D delta = ((Vector3D) point).subtract(center);\n-            return new Point3D(1.0, center, 1.0, rotation.applyTo(delta));\n-        }\n-\n-        /** {@inheritDoc} */\n-        public Hyperplane apply(final Hyperplane hyperplane) {\n+            return new Vector3D(1.0, center, 1.0, rotation.applyTo(delta));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Plane apply(final Hyperplane<Euclidean3D> hyperplane) {\n             return ((Plane) hyperplane).rotate(center, rotation);\n         }\n \n         /** {@inheritDoc} */\n-        public SubHyperplane apply(final SubHyperplane sub,\n-                                   final Hyperplane original, final Hyperplane transformed) {\n+        public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub,\n+                                                final Hyperplane<Euclidean3D> original,\n+                                                final Hyperplane<Euclidean3D> transformed) {\n             if (original != cachedOriginal) {\n                 // we have changed hyperplane, reset the in-hyperplane transform\n \n                 final Plane    oPlane = (Plane) original;\n                 final Plane    tPlane = (Plane) transformed;\n                 final Vector3D p00    = oPlane.getOrigin();\n-                final Vector3D p10    = (Vector3D) oPlane.toSpace(new Point2D(1.0, 0.0));\n-                final Vector3D p01    = (Vector3D) oPlane.toSpace(new Point2D(0.0, 1.0));\n-                final Point2D  tP00   = (Point2D) tPlane.toSubSpace(apply((Point) p00));\n-                final Point2D  tP10   = (Point2D) tPlane.toSubSpace(apply((Point) p10));\n-                final Point2D  tP01   = (Point2D) tPlane.toSubSpace(apply((Point) p01));\n+                final Vector3D p10    = (Vector3D) oPlane.toSpace(new Vector2D(1.0, 0.0));\n+                final Vector3D p01    = (Vector3D) oPlane.toSpace(new Vector2D(0.0, 1.0));\n+                final Vector2D  tP00   = (Vector2D) tPlane.toSubSpace(apply(p00));\n+                final Vector2D  tP10   = (Vector2D) tPlane.toSubSpace(apply(p10));\n+                final Vector2D  tP01   = (Vector2D) tPlane.toSubSpace(apply(p01));\n                 final AffineTransform at =\n                     new AffineTransform(tP10.getX() - tP00.getX(), tP10.getY() - tP00.getY(),\n                                         tP01.getX() - tP00.getX(), tP01.getY() - tP00.getY(),\n                                         tP00.getX(), tP00.getY());\n \n-                cachedOriginal  = original;\n+                cachedOriginal  = (Plane) original;\n                 cachedTransform = org.apache.commons.math.geometry.euclidean.twod.Line.getTransform(at);\n \n             }\n-            return sub.applyTransform(cachedTransform);\n+            return ((SubLine) sub).applyTransform(cachedTransform);\n         }\n \n     }\n     }\n \n     /** 3D translation as a transform. */\n-    private static class TranslationTransform implements Transform {\n+    private static class TranslationTransform implements Transform<Euclidean3D, Euclidean2D> {\n \n         /** Translation vector. */\n         private Vector3D   translation;\n \n         /** Cached original hyperplane. */\n-        private Hyperplane cachedOriginal;\n+        private Plane cachedOriginal;\n \n         /** Cached 2D transform valid inside the cached original hyperplane. */\n-        private Transform  cachedTransform;\n+        private Transform<Euclidean2D, Euclidean1D>  cachedTransform;\n \n         /** Build a translation transform.\n          * @param translation translation vector\n         }\n \n         /** {@inheritDoc} */\n-        public Point apply(final Point point) {\n-            return new Point3D(1.0, (Vector3D) point, 1.0, translation);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public Hyperplane apply(final Hyperplane hyperplane) {\n+        public Vector3D apply(final Vector<Euclidean3D> point) {\n+            return new Vector3D(1.0, (Vector3D) point, 1.0, translation);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Plane apply(final Hyperplane<Euclidean3D> hyperplane) {\n             return ((Plane) hyperplane).translate(translation);\n         }\n \n         /** {@inheritDoc} */\n-        public SubHyperplane apply(final SubHyperplane sub,\n-                                   final Hyperplane original, final Hyperplane transformed) {\n+        public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub,\n+                                                final Hyperplane<Euclidean3D> original,\n+                                                final Hyperplane<Euclidean3D> transformed) {\n             if (original != cachedOriginal) {\n                 // we have changed hyperplane, reset the in-hyperplane transform\n \n                 final Plane   oPlane = (Plane) original;\n                 final Plane   tPlane = (Plane) transformed;\n-                final Point2D shift  = (Point2D) tPlane.toSubSpace(apply((Point) oPlane.getOrigin()));\n+                final Vector2D shift  = (Vector2D) tPlane.toSubSpace(apply(oPlane.getOrigin()));\n                 final AffineTransform at =\n                     AffineTransform.getTranslateInstance(shift.getX(), shift.getY());\n \n-                cachedOriginal  = original;\n+                cachedOriginal  = (Plane) original;\n                 cachedTransform =\n                     org.apache.commons.math.geometry.euclidean.twod.Line.getTransform(at);\n \n             }\n \n-            return sub.applyTransform(cachedTransform);\n+            return ((SubLine) sub).applyTransform(cachedTransform);\n \n         }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threed;\n+\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.euclidean.twod.Euclidean2D;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n+import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;\n+import org.apache.commons.math.geometry.partitioning.AbstractSubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.Side;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+\n+/** This class represents a sub-hyperplane for {@link Plane}.\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class SubPlane extends AbstractSubHyperplane<Euclidean3D, Euclidean2D> {\n+\n+    /** Simple constructor.\n+     * @param hyperplane underlying hyperplane\n+     * @param remainingRegion remaining region of the hyperplane\n+     */\n+    public SubPlane(final Hyperplane<Euclidean3D> hyperplane,\n+                    final Region<Euclidean2D> remainingRegion) {\n+        super(hyperplane, remainingRegion);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected AbstractSubHyperplane<Euclidean3D, Euclidean2D> buildNew(final Hyperplane<Euclidean3D> hyperplane,\n+                                                                       final Region<Euclidean2D> remainingRegion) {\n+        return new SubPlane(hyperplane, remainingRegion);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Side side(Hyperplane<Euclidean3D> hyperplane) {\n+\n+        final Plane otherPlane = (Plane) hyperplane;\n+        final Plane thisPlane  = (Plane) getHyperplane();\n+        final Line  inter      = (Line) otherPlane.intersection(thisPlane);\n+\n+        if (inter == null) {\n+            // the hyperplanes are parallel,\n+            // any point can be used to check their relative position\n+            final double global = otherPlane.getOffset(thisPlane);\n+            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n+        }\n+\n+        // create a 2D line in the otherPlane canonical 2D frame such that:\n+        //   - the line is the crossing line of the two planes in 3D\n+        //   - the line splits the otherPlane in two half planes with an\n+        //     orientation consistent with the orientation of the instance\n+        //     (i.e. the 3D half space on the plus side (resp. minus side)\n+        //      of the instance contains the 2D half plane on the plus side\n+        //      (resp. minus side) of the 2D line\n+        Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n+        Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n+        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n+        if (Vector3D.dotProduct(crossP, otherPlane.getNormal()) < 0) {\n+            final Vector2D tmp = p;\n+            p           = q;\n+            q           = tmp;\n+        }\n+        final org.apache.commons.math.geometry.euclidean.twod.Line line2D =\n+            new org.apache.commons.math.geometry.euclidean.twod.Line(p, q);\n+\n+        // check the side on the 2D plane\n+        return getRemainingRegion().side(line2D);\n+\n+    }\n+\n+    /** Split the instance in two parts by an hyperplane.\n+     * @param hyperplane splitting hyperplane\n+     * @return an object containing both the part of the instance\n+     * on the plus side of the instance and the part of the\n+     * instance on the minus side of the instance\n+     */\n+    public SplitSubHyperplane<Euclidean3D> split(Hyperplane<Euclidean3D> hyperplane) {\n+\n+        final Plane otherPlane = (Plane) hyperplane;\n+        final Plane thisPlane  = (Plane) getHyperplane();\n+        final Line  inter      = (Line) otherPlane.intersection(thisPlane);\n+\n+        if (inter == null) {\n+            // the hyperplanes are parallel\n+            final double global = otherPlane.getOffset(thisPlane);\n+            return (global < -1.0e-10) ?\n+                   new SplitSubHyperplane<Euclidean3D>(null, this) :\n+                   new SplitSubHyperplane<Euclidean3D>(this, null);\n+        }\n+\n+        // the hyperplanes do intersect\n+        Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n+        Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n+        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n+        if (Vector3D.dotProduct(crossP, otherPlane.getNormal()) < 0) {\n+            final Vector2D tmp = p;\n+            p           = q;\n+            q           = tmp;\n+        }\n+        final SubHyperplane<Euclidean2D> l2DMinus =\n+            new org.apache.commons.math.geometry.euclidean.twod.Line(p, q).wholeHyperplane();\n+        final SubHyperplane<Euclidean2D> l2DPlus =\n+            new org.apache.commons.math.geometry.euclidean.twod.Line(q, p).wholeHyperplane();\n+\n+        final BSPTree<Euclidean2D> splitTree = getRemainingRegion().getTree(false).split(l2DMinus);\n+        final BSPTree<Euclidean2D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n+                                               new BSPTree<Euclidean2D>(Boolean.FALSE) :\n+                                               new BSPTree<Euclidean2D>(l2DPlus, new BSPTree<Euclidean2D>(Boolean.FALSE),\n+                                                                        splitTree.getPlus(), null);\n+\n+        final BSPTree<Euclidean2D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n+                                               new BSPTree<Euclidean2D>(Boolean.FALSE) :\n+                                                   new BSPTree<Euclidean2D>(l2DMinus, new BSPTree<Euclidean2D>(Boolean.FALSE),\n+                                                                            splitTree.getMinus(), null);\n+\n+        return new SplitSubHyperplane<Euclidean3D>(new SubPlane(thisPlane.copySelf(), new PolygonsSet(plusTree)),\n+                                                   new SubPlane(thisPlane.copySelf(), new PolygonsSet(minusTree)));\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Line.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Line.java\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n import org.apache.commons.math.geometry.euclidean.oned.OrientedPoint;\n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n-import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.partitioning.Embedding;\n import org.apache.commons.math.geometry.partitioning.Hyperplane;\n-import org.apache.commons.math.geometry.partitioning.Point;\n-import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n-import org.apache.commons.math.geometry.partitioning.SubSpace;\n import org.apache.commons.math.geometry.partitioning.Transform;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n  * left half plane is the set of points with negative offsets and the\n  * right half plane is the set of points with positive offsets.</p>\n \n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class Line implements Hyperplane {\n+public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euclidean1D> {\n \n     /** Angle with respect to the abscissa axis. */\n     private double angle;\n      * @param p1 first point\n      * @param p2 second point\n      */\n-    public Line(final Point2D p1, final Point2D p2) {\n+    public Line(final Vector2D p1, final Vector2D p2) {\n         reset(p1, p2);\n     }\n \n      * @param p point belonging to the line\n      * @param angle angle of the line with respect to abscissa axis\n      */\n-    public Line(final Point2D p, final double angle) {\n+    public Line(final Vector2D p, final double angle) {\n         reset(p, angle);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public Hyperplane copySelf() {\n+    public Line copySelf() {\n         return new Line(this);\n     }\n \n      * @param p1 first point\n      * @param p2 second point\n      */\n-    public void reset(final Point2D p1, final Point2D p2) {\n-        final double dx = p2.x - p1.x;\n-        final double dy = p2.y - p1.y;\n+    public void reset(final Vector2D p1, final Vector2D p2) {\n+        final double dx = p2.getX() - p1.getX();\n+        final double dy = p2.getY() - p1.getY();\n         final double d = FastMath.hypot(dx, dy);\n         if (d == 0.0) {\n             angle        = 0.0;\n             cos          = 1.0;\n             sin          = 0.0;\n-            originOffset = p1.y;\n+            originOffset = p1.getY();\n         } else {\n             angle        = FastMath.PI + FastMath.atan2(-dy, -dx);\n             cos          = FastMath.cos(angle);\n             sin          = FastMath.sin(angle);\n-            originOffset = (p2.x * p1.y - p1.x * p2.y) / d;\n+            originOffset = (p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d;\n         }\n     }\n \n      * @param p point belonging to the line\n      * @param alpha angle of the line with respect to abscissa axis\n      */\n-    public void reset(final Point2D p, final double alpha) {\n+    public void reset(final Vector2D p, final double alpha) {\n         this.angle   = MathUtils.normalizeAngle(alpha, FastMath.PI);\n         cos          = FastMath.cos(this.angle);\n         sin          = FastMath.sin(this.angle);\n-        originOffset = cos * p.y - sin * p.x;\n+        originOffset = cos * p.getY() - sin * p.getX();\n     }\n \n     /** Revert the instance.\n                         -cos, -sin, -originOffset);\n     }\n \n-    /** Transform a 2D space point into a line point.\n-     * @param point 2D point (must be a {@link Point2D Point2D}\n-     * instance)\n-     * @return line point corresponding to the 2D point (really a {@link\n-     * org.apache.commons.math.geometry.euclidean.oned.Point1D Point1D} instance)\n-     * @see #toSpace\n-     */\n-    public Point toSubSpace(final Point point) {\n-        final Point2D p2D = (Point2D) point;\n-        return new Point1D(cos * p2D.x + sin * p2D.y);\n-    }\n-\n-    /** Get one point from the line.\n-     * @param point desired abscissa for the point (must be a {@link\n-     * org.apache.commons.math.geometry.euclidean.oned.Point1D Point1D} instance)\n-     * @return line point at specified abscissa (really a {@link Point2D\n-     * Point2D} instance)\n-     */\n-    public Point toSpace(final Point point) {\n-        final double abscissa = ((Point1D) point).getAbscissa();\n-        return new Point2D(abscissa * cos - originOffset * sin,\n+    /** {@inheritDoc} */\n+    public Vector1D toSubSpace(final Vector<Euclidean2D> point) {\n+        Vector2D p2 = (Vector2D) point;\n+        return new Vector1D(cos * p2.getX() + sin * p2.getY());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D toSpace(final Vector<Euclidean1D> point) {\n+        final double abscissa = ((Vector1D) point).getX();\n+        return new Vector2D(abscissa * cos - originOffset * sin,\n                            abscissa * sin + originOffset * cos);\n     }\n \n     /** Get the intersection point of the instance and another line.\n      * @param other other line\n      * @return intersection point of the instance and the other line\n-     * (really a {@link Point2D Point2D} instance)\n-     */\n-    public SubSpace intersection(final Hyperplane other) {\n+     * (really a {@link Vector2D Vector2D} instance)\n+     */\n+    public Vector2D intersection(final Hyperplane<Euclidean2D> other) {\n         final Line otherL = (Line) other;\n         final double d = sin * otherL.cos - otherL.sin * cos;\n         if (FastMath.abs(d) < 1.0e-10) {\n             return null;\n         }\n-        return new Point2D((cos * otherL.originOffset - otherL.cos * originOffset) / d,\n+        return new Vector2D((cos * otherL.originOffset - otherL.cos * originOffset) / d,\n                            (sin * otherL.originOffset - otherL.sin * originOffset) / d);\n     }\n \n-    /** Build a region covering the whole hyperplane.\n-     * @return a region covering the whole hyperplane\n-     */\n-    public Region wholeHyperplane() {\n-        return new IntervalsSet();\n+    /** {@inheritDoc} */\n+    public SubLine wholeHyperplane() {\n+        return new SubLine(this, new IntervalsSet());\n     }\n \n     /** Build a region covering the whole space.\n      * @return a region containing the instance (really a {@link\n      * PolygonsSet PolygonsSet} instance)\n      */\n-    public Region wholeSpace() {\n+    public PolygonsSet wholeSpace() {\n         return new PolygonsSet();\n     }\n \n      * @param line line to check\n      * @return offset of the line\n      */\n-    public double getOffset(final Line line) {\n+    public double getOffset(final Hyperplane<Euclidean2D> hyperplane) {\n+        Line line = (Line) hyperplane;\n         return originOffset +\n                ((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset);\n     }\n      * positive if the point is on the right side of the line and\n      * negative if it is on the left side, according to its natural\n      * orientation.</p>\n-     * @param point point to check (must be a {@link Point2D Point2D} instance)\n+     * @param point point to check (must be a {@link Vector2D Vector2D} instance)\n      * @return offset of the point\n      */\n-    public double getOffset(final Point point) {\n-        final Point2D p2D = (Point2D) point;\n-        return sin * p2D.x - cos * p2D.y + originOffset;\n+    public double getOffset(final Vector<Euclidean2D> point) {\n+        Vector2D p2 = (Vector2D) point;\n+        return sin * p2.getX() - cos * p2.getY() + originOffset;\n     }\n \n     /** Check if the instance has the same orientation as another hyperplane.\n      * @return true if the instance and the other hyperplane have\n      * the same orientation\n      */\n-    public boolean sameOrientationAs(final Hyperplane other) {\n+    public boolean sameOrientationAs(final Hyperplane<Euclidean2D> other) {\n         final Line otherL = (Line) other;\n         return (sin * otherL.sin + cos * otherL.cos) >= 0.0;\n     }\n      * @return one point in the plane, with given abscissa and offset\n      * relative to the line\n      */\n-    public Point2D getPointAt(final Point1D abscissa, final double offset) {\n-        final double x       = abscissa.getAbscissa();\n+    public Vector2D getPointAt(final Vector1D abscissa, final double offset) {\n+        final double x       = abscissa.getX();\n         final double dOffset = offset - originOffset;\n-        return new Point2D(x * cos + dOffset * sin, x * sin - dOffset * cos);\n+        return new Vector2D(x * cos + dOffset * sin, x * sin - dOffset * cos);\n     }\n \n     /** Check if the line contains a point.\n      * @param p point to check\n      * @return true if p belongs to the line\n      */\n-    public boolean contains(final Point2D p) {\n+    public boolean contains(final Vector2D p) {\n         return FastMath.abs(getOffset(p)) < 1.0e-10;\n     }\n \n     /** Translate the line to force it passing by a point.\n      * @param p point by which the line should pass\n      */\n-    public void translateToPoint(final Point2D p) {\n-        originOffset = cos * p.y - sin * p.x;\n+    public void translateToPoint(final Vector2D p) {\n+        originOffset = cos * p.getY() - sin * p.getX();\n     }\n \n     /** Get the angle of the line.\n      */\n     public void setOriginOffset(final double offset) {\n         originOffset = offset;\n-    }\n-\n-    /** Compute the relative position of a sub-hyperplane with respect\n-     * to the instance.\n-     * @param sub sub-hyperplane to check\n-     * @return one of {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#PLUS PLUS},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#MINUS MINUS},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#BOTH BOTH},\n-     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n-     */\n-    public Side side(final SubHyperplane sub) {\n-\n-        final Hyperplane otherHyp = sub.getHyperplane();\n-        final Point2D    crossing = (Point2D) intersection(otherHyp);\n-\n-        if (crossing == null) {\n-            // the lines are parallel,\n-            final double global = getOffset((Line) otherHyp);\n-            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n-        }\n-\n-        // the lines do intersect\n-        final boolean direct = FastMath.sin(((Line) otherHyp).angle - angle) < 0;\n-        final Point1D x = (Point1D) otherHyp.toSubSpace(crossing);\n-        return sub.getRemainingRegion().side(new OrientedPoint(x, direct));\n-\n-    }\n-\n-    /** Split a sub-hyperplane in two parts by the instance.\n-     * @param sub sub-hyperplane to split\n-     * @return an object containing both the part of the sub-hyperplane\n-     * on the plus side of the instance and the part of the\n-     * sub-hyperplane on the minus side of the instance\n-     */\n-    public SplitSubHyperplane split(final SubHyperplane sub) {\n-\n-        final Line    otherLine = (Line) sub.getHyperplane();\n-        final Point2D crossing  = (Point2D) intersection(otherLine);\n-\n-        if (crossing == null) {\n-            // the lines are parallel\n-            final double global = getOffset(otherLine);\n-            return (global < -1.0e-10) ?\n-                   new SplitSubHyperplane(null, sub) :\n-                   new SplitSubHyperplane(sub, null);\n-        }\n-\n-        // the lines do intersect\n-        final boolean direct = FastMath.sin(otherLine.angle - angle) < 0;\n-        final Point1D x      = (Point1D) otherLine.toSubSpace(crossing);\n-        final SubHyperplane subPlus  = new SubHyperplane(new OrientedPoint(x, !direct));\n-        final SubHyperplane subMinus = new SubHyperplane(new OrientedPoint(x, direct));\n-\n-        final BSPTree splitTree =\n-            sub.getRemainingRegion().getTree(false).split(subMinus);\n-        final BSPTree plusTree  = Region.isEmpty(splitTree.getPlus()) ?\n-                                  new BSPTree(Boolean.FALSE) :\n-                                  new BSPTree(subPlus, new BSPTree(Boolean.FALSE),\n-                                              splitTree.getPlus(), null);\n-        final BSPTree minusTree = Region.isEmpty(splitTree.getMinus()) ?\n-                                  new BSPTree(Boolean.FALSE) :\n-                                  new BSPTree(subMinus, new BSPTree(Boolean.FALSE),\n-                                              splitTree.getMinus(), null);\n-\n-        return new SplitSubHyperplane(new SubHyperplane(otherLine.copySelf(),\n-                                                        new IntervalsSet(plusTree)),\n-                                                        new SubHyperplane(otherLine.copySelf(),\n-                                                                          new IntervalsSet(minusTree)));\n-\n     }\n \n     /** Get a {@link org.apache.commons.math.geometry.partitioning.Transform\n      * apply(Hyperplane)} method would work only for some lines, and\n      * fail for other ones)\n      * @return a new transform that can be applied to either {@link\n-     * Point2D Point2D}, {@link Line Line} or {@link\n+     * Vector2D Vector2D}, {@link Line Line} or {@link\n      * org.apache.commons.math.geometry.partitioning.SubHyperplane\n      * SubHyperplane} instances\n      * @exception MathIllegalArgumentException if the transform is non invertible\n      */\n-    public static Transform getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n+    public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform)\n+        throws MathIllegalArgumentException {\n         return new LineTransform(transform);\n     }\n \n      * applied to a large number of lines (for example to a large\n      * polygon)./<p>\n      */\n-    private static class LineTransform implements Transform {\n+    private static class LineTransform implements Transform<Euclidean2D, Euclidean1D> {\n \n         // CHECKSTYLE: stop JavadocVariable check\n         private double cXX;\n         }\n \n         /** {@inheritDoc} */\n-        public Point apply(final Point point) {\n-            final Point2D p2D = (Point2D) point;\n+        public Vector2D apply(final Vector<Euclidean2D> point) {\n+            final Vector2D p2D = (Vector2D) point;\n             final double  x   = p2D.getX();\n             final double  y   = p2D.getY();\n-            return new Point2D(cXX * x + cXY * y + cX1,\n+            return new Vector2D(cXX * x + cXY * y + cX1,\n                                cYX * x + cYY * y + cY1);\n         }\n \n         /** {@inheritDoc} */\n-        public Hyperplane apply(final Hyperplane hyperplane) {\n+        public Line apply(final Hyperplane<Euclidean2D> hyperplane) {\n             final Line   line    = (Line) hyperplane;\n             final double rOffset = c1X * line.cos + c1Y * line.sin + c11 * line.originOffset;\n             final double rCos    = cXX * line.cos + cXY * line.sin;\n         }\n \n         /** {@inheritDoc} */\n-        public SubHyperplane apply(final SubHyperplane sub,\n-                                   final Hyperplane original, final Hyperplane transformed) {\n-            final OrientedPoint op = (OrientedPoint) sub.getHyperplane();\n-            final Point1D newLoc =\n-                (Point1D) transformed.toSubSpace(apply(original.toSpace(op.getLocation())));\n-            return new SubHyperplane(new OrientedPoint(newLoc, op.isDirect()));\n+        public SubHyperplane<Euclidean1D> apply(final SubHyperplane<Euclidean1D> sub,\n+                                                final Hyperplane<Euclidean2D> original,\n+                                                final Hyperplane<Euclidean2D> transformed) {\n+            final OrientedPoint op     = (OrientedPoint) sub.getHyperplane();\n+            final Line originalLine    = (Line) original;\n+            final Line transformedLine = (Line) transformed;\n+            final Vector1D newLoc =\n+                transformedLine.toSubSpace(apply(originalLine.toSpace(op.getLocation())));\n+            return new OrientedPoint(newLoc, op.isDirect()).wholeHyperplane();\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/NestedLoops.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/NestedLoops.java\n package org.apache.commons.math.geometry.euclidean.twod;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Iterator;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.geometry.euclidean.oned.OrientedPoint;\n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n-import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n \n /** This class represent a tree of nested 2D boundary loops.\n \n- * <p>This class is used during Piece instances construction.\n- * Beams are built using the outline edges as\n- * representative of facets, the orientation of these facets are\n+ * <p>This class is used for piecewise polygons construction.\n+ * Polygons are built using the outline edges as\n+ * representative of boundaries, the orientation of these lines are\n  * meaningful. However, we want to allow the user to specify its\n  * outline loops without having to take care of this orientation. This\n  * class is devoted to correct mis-oriented loops.<p>\n \n- * <p>Orientation is computed assuming the piece is finite, i.e. the\n- * outermost loops have their exterior side facing points at infinity,\n- * and hence are oriented counter-clockwise. The orientation of\n+ * <p>Orientation is computed assuming the piecewise polygon is finite,\n+ * i.e. the outermost loops have their exterior side facing points at\n+ * infinity, and hence are oriented counter-clockwise. The orientation of\n  * internal loops is computed as the reverse of the orientation of\n  * their immediate surrounding loop.</p>\n \n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n class NestedLoops {\n \n     /** Boundary loop. */\n-    private Point2D[] loop;\n+    private Vector2D[] loop;\n \n     /** Surrounded loops. */\n     private ArrayList<NestedLoops> surrounded;\n \n     /** Polygon enclosing a finite region. */\n-    private Region polygon;\n+    private Region<Euclidean2D> polygon;\n \n     /** Indicator for original loop orientation. */\n     private boolean originalIsClockwise;\n      * @param loop boundary loop (will be reversed in place if needed)\n      * @exception MathIllegalArgumentException if an outline has an open boundary loop\n      */\n-    private NestedLoops(final Point2D[] loop) throws MathIllegalArgumentException {\n+    private NestedLoops(final Vector2D[] loop) throws MathIllegalArgumentException {\n \n         if (loop[0] == null) {\n             throw new MathIllegalArgumentException(LocalizedFormats.OUTLINE_BOUNDARY_LOOP_OPEN);\n         surrounded = new ArrayList<NestedLoops>();\n \n         // build the polygon defined by the loop\n-        final ArrayList<SubHyperplane> edges = new ArrayList<SubHyperplane>();\n-        Point2D current = loop[loop.length - 1];\n+        final ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<SubHyperplane<Euclidean2D>>();\n+        Vector2D current = loop[loop.length - 1];\n         for (int i = 0; i < loop.length; ++i) {\n-            final Point2D previous = current;\n+            final Vector2D previous = current;\n             current = loop[i];\n             final Line   line   = new Line(previous, current);\n-            final Region region =  Region.buildConvex(Arrays.asList(new Hyperplane[] {\n-                new OrientedPoint((Point1D) line.toSubSpace(previous), false),\n-                new OrientedPoint((Point1D) line.toSubSpace(current),  true)\n-            }));\n-            edges.add(new SubHyperplane(line, region));\n+            final IntervalsSet region = \n+                new IntervalsSet(line.toSubSpace(previous).getX(), line.toSubSpace(current).getX());\n+            edges.add(new SubLine(line, region));\n         }\n         polygon = new PolygonsSet(edges);\n \n         // ensure the polygon encloses a finite region of the plane\n         if (Double.isInfinite(polygon.getSize())) {\n-            polygon = polygon.getComplement();\n+            polygon = new RegionFactory<Euclidean2D>().getComplement(polygon);\n             originalIsClockwise = false;\n         } else {\n             originalIsClockwise = true;\n      * @exception MathIllegalArgumentException if an outline has crossing\n      * boundary loops or open boundary loops\n      */\n-    public void add(final Point2D[] bLoop) throws MathIllegalArgumentException {\n+    public void add(final Vector2D[] bLoop) throws MathIllegalArgumentException {\n         add(new NestedLoops(bLoop));\n     }\n \n         }\n \n         // we should be separate from the remaining children\n+        RegionFactory<Euclidean2D> factory = new RegionFactory<Euclidean2D>();\n         for (final NestedLoops child : surrounded) {\n-            if (!Region.intersection(node.polygon, child.polygon).isEmpty()) {\n+            if (!factory.intersection(node.polygon, child.polygon).isEmpty()) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.CROSSING_BOUNDARY_LOOPS);\n             }\n         }\n \n     /** Correct the orientation of the loops contained in the tree.\n      * <p>This is this method that really inverts the loops that where\n-     * provided through the {@link #add(Point2D[]) add} method if\n+     * provided through the {@link #add(Vector2D[]) add} method if\n      * they are mis-oriented</p>\n      */\n     public void correctOrientation() {\n             int min = -1;\n             int max = loop.length;\n             while (++min < --max) {\n-                final Point2D tmp = loop[min];\n+                final Vector2D tmp = loop[min];\n                 loop[min] = loop[max];\n                 loop[max] = tmp;\n             }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n package org.apache.commons.math.geometry.euclidean.twod;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n-import org.apache.commons.math.geometry.partitioning.Hyperplane;\n import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n import org.apache.commons.math.util.FastMath;\n \n /** This class represents a 2D region: a set of polygons.\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class PolygonsSet extends Region {\n+public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n     /** Vertices organized as boundary loops. */\n-    private Point2D[][] vertices;\n+    private Vector2D[][] vertices;\n \n     /** Build a polygons set representing the whole real line.\n      */\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n      * @param tree inside/outside BSP tree representing the region\n      */\n-    public PolygonsSet(final BSPTree tree) {\n+    public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n         super(tree);\n     }\n \n      * its plus side.</p>\n      * <p>The boundary elements can be in any order, and can form\n      * several non-connected sets (like for example polygons with holes\n-     * or a set of disjoints polyhedrons considered as a whole). In\n+     * or a set of disjoint polyhedrons considered as a whole). In\n      * fact, the elements do not even need to be connected together\n      * (their topological connections are not used here). However, if the\n      * boundary does not really separate an inside open from an outside\n      * @param boundary collection of boundary elements, as a\n      * collection of {@link SubHyperplane SubHyperplane} objects\n      */\n-    public PolygonsSet(final Collection<SubHyperplane> boundary) {\n+    public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n         super(boundary);\n     }\n \n      */\n     public PolygonsSet(final double xMin, final double xMax,\n                        final double yMin, final double yMax) {\n-        this(buildConvex(boxBoundary(xMin, xMax, yMin, yMax)).getTree(false));\n+        super(boxBoundary(xMin, xMax, yMin, yMax));\n     }\n \n     /** Create a list of hyperplanes representing the boundary of a box.\n      * @param yMax high bound along the y direction\n      * @return boundary of the box\n      */\n-    private static List<Hyperplane> boxBoundary(final double xMin, final double xMax,\n-                                                final double yMin, final double yMax) {\n-        final Point2D minMin = new Point2D(xMin, yMin);\n-        final Point2D minMax = new Point2D(xMin, yMax);\n-        final Point2D maxMin = new Point2D(xMax, yMin);\n-        final Point2D maxMax = new Point2D(xMax, yMax);\n-        return Arrays.asList(new Hyperplane[] {\n+    private static Line[] boxBoundary(final double xMin, final double xMax,\n+                                      final double yMin, final double yMax) {\n+        final Vector2D minMin = new Vector2D(xMin, yMin);\n+        final Vector2D minMax = new Vector2D(xMin, yMax);\n+        final Vector2D maxMin = new Vector2D(xMax, yMin);\n+        final Vector2D maxMax = new Vector2D(xMax, yMax);\n+        return new Line[] {\n             new Line(minMin, maxMin),\n             new Line(maxMin, maxMax),\n             new Line(maxMax, minMax),\n             new Line(minMax, minMin)\n-        });\n+        };\n     }\n \n     /** {@inheritDoc} */\n-    public Region buildNew(final BSPTree tree) {\n+    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n         return new PolygonsSet(tree);\n     }\n \n     /** {@inheritDoc} */\n     protected void computeGeometricalProperties() {\n \n-        final Point2D[][] v = getVertices();\n+        final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             if ((Boolean) getTree(false).getAttribute()) {\n                 setSize(Double.POSITIVE_INFINITY);\n-                setBarycenter(Point2D.UNDEFINED);\n+                setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n-                setBarycenter(new Point2D(0, 0));\n+                setBarycenter(new Vector2D(0, 0));\n             }\n         } else if (v[0][0] == null) {\n             // there is at least one open-loop: the polygon is infinite\n             setSize(Double.POSITIVE_INFINITY);\n-            setBarycenter(Point2D.UNDEFINED);\n+            setBarycenter(Vector2D.NaN);\n         } else {\n             // all loops are closed, we compute some integrals around the shape\n \n             double sumX = 0;\n             double sumY = 0;\n \n-            for (Point2D[] loop : v) {\n-                double x1 = loop[loop.length - 1].x;\n-                double y1 = loop[loop.length - 1].y;\n-                for (final Point2D point : loop) {\n+            for (Vector2D[] loop : v) {\n+                double x1 = loop[loop.length - 1].getX();\n+                double y1 = loop[loop.length - 1].getY();\n+                for (final Vector2D point : loop) {\n                     final double x0 = x1;\n                     final double y0 = y1;\n-                    x1 = point.x;\n-                    y1 = point.y;\n+                    x1 = point.getX();\n+                    y1 = point.getY();\n                     final double factor = x0 * y1 - y0 * x1;\n                     sum  += factor;\n                     sumX += factor * (x0 + x1);\n             if (sum < 0) {\n                 // the polygon as a finite outside surrounded by an infinite inside\n                 setSize(Double.POSITIVE_INFINITY);\n-                setBarycenter(Point2D.UNDEFINED);\n+                setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(sum / 2);\n-                setBarycenter(new Point2D(sumX / (3 * sum), sumY / (3 * sum)));\n+                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n             }\n \n         }\n      * loops with the open loops first (the returned value is guaranteed\n      * to be non-null)\n      */\n-    public Point2D[][] getVertices() {\n+    public Vector2D[][] getVertices() {\n         if (vertices == null) {\n             if (getTree(false).getCut() == null) {\n-                vertices = new Point2D[0][];\n+                vertices = new Vector2D[0][];\n             } else {\n \n-                // sort the segmfinal ents according to their start point\n+                // sort the segments according to their start point\n                 final SegmentsBuilder visitor = new SegmentsBuilder();\n                 getTree(true).visit(visitor);\n                 final AVLTree<Segment> sorted = visitor.getSorted();\n \n                 // identify the loops, starting from the open ones\n-                // (their start segments final are naturally at the sorted set beginning)\n+                // (their start segments are naturally at the sorted set beginning)\n                 final ArrayList<List<Segment>> loops = new ArrayList<List<Segment>>();\n                 while (!sorted.isEmpty()) {\n                     final AVLTree<Segment>.Node node = sorted.getSmallest();\n                 }\n \n                 // tranform the loops in an array of arrays of points\n-                vertices = new Point2D[loops.size()][];\n+                vertices = new Vector2D[loops.size()][];\n                 int i = 0;\n \n                 for (final List<Segment> loop : loops) {\n                     if (loop.size() < 2) {\n-                        // sifinal ngle infinite line\n-                        final Line line = ((Segment) loop.get(0)).getLine();\n-                        vertices[i++] = new Point2D[] {\n+                        // single infinite line\n+                        final Line line = loop.get(0).getLine();\n+                        vertices[i++] = new Vector2D[] {\n                             null,\n-                            (Point2D) line.toSpace(new Point1D(-Float.MAX_VALUE)),\n-                            (Point2D) line.toSpace(new Point1D(+Float.MAX_VALUE))\n+                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n+                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                         };\n-                    } else if (((Segment) loop.get(0)).getStart() == null) {\n-                        // open lofinal op with at least one real point\n-                        final Point2D[] array = new Point2D[loop.size() + 2];\n+                    } else if (loop.get(0).getStart() == null) {\n+                        // open loop with at least one real point\n+                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                         int j = 0;\n                         for (Segment segment : loop) {\n \n                             if (j == 0) {\n                                 // null point and first dummy point\n-                                double x =\n-                                    ((Point1D) segment.getLine().toSubSpace(segment.getEnd())).getAbscissa();\n+                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                 x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                 array[j++] = null;\n-                                array[j++] = (Point2D) segment.getLine().toSpace(new Point1D(x));\n+                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                             }\n \n                             if (j < (array.length - 1)) {\n \n                             if (j == (array.length - 1)) {\n                                 // last dummy point\n-                                double x =\n-                                    ((Point1D) segment.getLine().toSubSpace(segment.getStart())).getAbscissa();\n+                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                 x += FastMath.max(1.0, FastMath.abs(x / 2));\n-                                array[j++] = (Point2D) segment.getLine().toSpace(new Point1D(x));\n+                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                             }\n \n                         }\n                         vertices[i++] = array;\n                     } else {\n-                        final Point2D[] array = new Point2D[loop.size()];\n+                        final Vector2D[] array = new Vector2D[loop.size()];\n                         int j = 0;\n                         for (Segment segment : loop) {\n                             array[j++] = segment.getStart();\n                                      final AVLTree<Segment> sorted) {\n \n         final ArrayList<Segment> loop = new ArrayList<Segment>();\n-        Segment segment = (Segment) node.getElement();\n+        Segment segment = node.getElement();\n         loop.add(segment);\n-        final Point2D globalStart = segment.getStart();\n-        Point2D end = segment.getEnd();\n+        final Vector2D globalStart = segment.getStart();\n+        Vector2D end = segment.getEnd();\n         node.delete();\n \n         // is this an open or a closed loop ?\n         }\n \n         if ((end == null) && !open) {\n-            throw new RuntimeException(\"internal error\");\n+            throw new MathInternalError();\n         }\n \n         return loop;\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Segment.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Segment.java\n import org.apache.commons.math.geometry.partitioning.utilities.OrderedTuple;\n \n /** This class holds segments information before they are connected.\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n class Segment implements Comparable<Segment> {\n \n     /** Start point of the segment. */\n-    private final Point2D      start;\n+    private final Vector2D      start;\n \n     /** End point of the segments. */\n-    private final Point2D      end;\n+    private final Vector2D      end;\n \n     /** Line containing the segment. */\n     private final Line         line;\n      * @param end end point of the segment\n      * @param line line containing the segment\n      */\n-    public Segment(final Point2D start, final Point2D end, final Line line) {\n+    public Segment(final Vector2D start, final Vector2D end, final Line line) {\n         this.start  = start;\n         this.end    = end;\n         this.line   = line;\n         sortingKey = (start == null) ?\n                      new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n-                     new OrderedTuple(start.x, start.y);\n+                     new OrderedTuple(start.getX(), start.getY());\n     }\n \n     /** Build a dummy segment.\n      * @param dx abscissa offset from the start point\n      * @param dy ordinate offset from the start point\n      */\n-    public Segment(final Point2D start, final double dx, final double dy) {\n+    public Segment(final Vector2D start, final double dx, final double dy) {\n         this.start = null;\n         this.end   = null;\n         this.line  = null;\n-        sortingKey = new OrderedTuple(start.x + dx, start.y + dy);\n+        sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n     }\n \n     /** Get the start point of the segment.\n      * @return start point of the segment\n      */\n-    public Point2D getStart() {\n+    public Vector2D getStart() {\n         return start;\n     }\n \n     /** Get the end point of the segment.\n      * @return end point of the segment\n      */\n-    public Point2D getEnd() {\n+    public Vector2D getEnd() {\n         return end;\n     }\n \n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SegmentBuilder.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SegmentBuilder.java\n \n import java.util.List;\n \n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math.geometry.euclidean.oned.Interval;\n import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.partitioning.AbstractSubHyperplane;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n-import org.apache.commons.math.geometry.partitioning.Region.BoundaryAttribute;\n+import org.apache.commons.math.geometry.partitioning.BoundaryAttribute;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n \n /** Visitor building segments.\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-class SegmentsBuilder implements BSPTreeVisitor {\n+class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n \n     /** Sorted segments. */\n     private AVLTree<Segment> sorted;\n     }\n \n     /** {@inheritDoc} */\n-    public Order visitOrder(final BSPTree node) {\n+    public Order visitOrder(final BSPTree<Euclidean2D> node) {\n         return Order.MINUS_SUB_PLUS;\n     }\n \n     /** {@inheritDoc} */\n-    public void visitInternalNode(final BSPTree node) {\n-        final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+    public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n+        @SuppressWarnings(\"unchecked\")\n+        final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n         if (attribute.getPlusOutside() != null) {\n             addContribution(attribute.getPlusOutside(), false);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public void visitLeafNode(final BSPTree node) {\n+    public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n     }\n \n     /** Add he contribution of a boundary facet.\n      * @param sub boundary facet\n      * @param reversed if true, the facet has the inside on its plus side\n      */\n-    private void addContribution(final SubHyperplane sub, final boolean reversed) {\n+    private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n+        @SuppressWarnings(\"unchecked\")\n+        final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n+            (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n         final Line line      = (Line) sub.getHyperplane();\n-        final List<Interval> intervals = ((IntervalsSet) sub.getRemainingRegion()).asList();\n+        final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n         for (final Interval i : intervals) {\n-            final Point2D start = Double.isInfinite(i.getLower()) ?\n-                                  null : (Point2D) line.toSpace(new Point1D(i.getLower()));\n-            final Point2D end   = Double.isInfinite(i.getUpper()) ?\n-                                  null : (Point2D) line.toSpace(new Point1D(i.getUpper()));\n+            final Vector2D start = Double.isInfinite(i.getLower()) ?\n+                                  null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n+            final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n+                                  null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n             if (reversed) {\n                 sorted.insert(new Segment(end, start, line.getReverse()));\n             } else {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twod;\n+\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n+import org.apache.commons.math.geometry.euclidean.oned.OrientedPoint;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.partitioning.AbstractSubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.Side;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** This class represents a sub-hyperplane for {@link Line}.\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n+\n+    /** Simple constructor.\n+     * @param hyperplane underlying hyperplane\n+     * @param remainingRegion remaining region of the hyperplane\n+     */\n+    public SubLine(final Hyperplane<Euclidean2D> hyperplane,\n+                   final Region<Euclidean1D> remainingRegion) {\n+        super(hyperplane, remainingRegion);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane,\n+                                                                       final Region<Euclidean1D> remainingRegion) {\n+        return new SubLine(hyperplane, remainingRegion);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n+\n+        final Line    thisLine  = (Line) getHyperplane();\n+        final Line    otherLine = (Line) hyperplane;\n+        final Vector2D crossing  = thisLine.intersection(otherLine);\n+\n+        if (crossing == null) {\n+            // the lines are parallel,\n+            final double global = otherLine.getOffset(thisLine);\n+            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n+        }\n+\n+        // the lines do intersect\n+        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n+        final Vector1D x = (Vector1D) thisLine.toSubSpace(crossing);\n+        return getRemainingRegion().side(new OrientedPoint(x, direct));\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n+\n+        final Line    thisLine  = (Line) getHyperplane();\n+        final Line    otherLine = (Line) hyperplane;\n+        final Vector2D crossing  = thisLine.intersection(otherLine);\n+\n+        if (crossing == null) {\n+            // the lines are parallel\n+            final double global = otherLine.getOffset(thisLine);\n+            return (global < -1.0e-10) ?\n+                   new SplitSubHyperplane<Euclidean2D>(null, this) :\n+                   new SplitSubHyperplane<Euclidean2D>(this, null);\n+        }\n+\n+        // the lines do intersect\n+        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n+        final Vector1D x      = (Vector1D) thisLine.toSubSpace(crossing);\n+        final SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\n+        final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n+\n+        final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);\n+        final BSPTree<Euclidean1D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n+                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n+                                               new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                                                                        splitTree.getPlus(), null);\n+        final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n+                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n+                                               new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                                                                        splitTree.getMinus(), null);\n+\n+        return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\n+                                                   new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n+\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSetTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSetTest.java\n \n import org.apache.commons.math.geometry.euclidean.oned.Interval;\n import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     public void testInterval() {\n         IntervalsSet set = new IntervalsSet(2.3, 5.7);\n         Assert.assertEquals(3.4, set.getSize(), 1.0e-10);\n-        Assert.assertEquals(4.0, ((Point1D) set.getBarycenter()).getAbscissa(), 1.0e-10);\n-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(2.3)));\n-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(5.7)));\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(1.2)));\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(8.7)));\n-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(3.0)));\n+        Assert.assertEquals(4.0, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10);\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(2.3)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.7)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(1.2)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.7)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(3.0)));\n         Assert.assertEquals(2.3, set.getInf(), 1.0e-10);\n         Assert.assertEquals(5.7, set.getSup(), 1.0e-10);\n     }\n     @Test\n     public void testInfinite() {\n         IntervalsSet set = new IntervalsSet(9.0, Double.POSITIVE_INFINITY);\n-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(9.0)));\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(8.4)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(9.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.4)));\n         for (double e = 1.0; e <= 6.0; e += 1.0) {\n             Assert.assertEquals(Region.Location.INSIDE,\n-                                set.checkPoint(new Point1D(FastMath.pow(10.0, e))));\n+                                set.checkPoint(new Vector1D(FastMath.pow(10.0, e))));\n         }\n         Assert.assertTrue(Double.isInfinite(set.getSize()));\n         Assert.assertEquals(9.0, set.getInf(), 1.0e-10);\n         Assert.assertTrue(Double.isInfinite(set.getSup()));\n \n-        set = (IntervalsSet) set.getComplement();\n+        set = (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(set);\n         Assert.assertEquals(9.0, set.getSup(), 1.0e-10);\n         Assert.assertTrue(Double.isInfinite(set.getInf()));\n \n \n     @Test\n     public void testMultiple() {\n+        RegionFactory<Euclidean1D> factory = new RegionFactory<Euclidean1D>();\n         IntervalsSet set = (IntervalsSet)\n-        Region.intersection(Region.union(Region.difference(new IntervalsSet(1.0, 6.0),\n-                                                           new IntervalsSet(3.0, 5.0)),\n-                                                           new IntervalsSet(9.0, Double.POSITIVE_INFINITY)),\n-                                                           new IntervalsSet(Double.NEGATIVE_INFINITY, 11.0));\n+        factory.intersection(factory.union(factory.difference(new IntervalsSet(1.0, 6.0),\n+                                                              new IntervalsSet(3.0, 5.0)),\n+                                                              new IntervalsSet(9.0, Double.POSITIVE_INFINITY)),\n+                                                              new IntervalsSet(Double.NEGATIVE_INFINITY, 11.0));\n         Assert.assertEquals(5.0, set.getSize(), 1.0e-10);\n-        Assert.assertEquals(5.9, ((Point1D) set.getBarycenter()).getAbscissa(), 1.0e-10);\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(0.0)));\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(4.0)));\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(8.0)));\n-        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(12.0)));\n-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(1.2)));\n-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(5.9)));\n-        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(9.01)));\n-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(5.0)));\n-        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(11.0)));\n+        Assert.assertEquals(5.9, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10);\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(0.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(4.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(12.0)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(1.2)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(5.9)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(9.01)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.0)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(11.0)));\n         Assert.assertEquals( 1.0, set.getInf(), 1.0e-10);\n         Assert.assertEquals(11.0, set.getSup(), 1.0e-10);\n \n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/threed/PlaneTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/PlaneTest.java\n \n import org.apache.commons.math.geometry.euclidean.threed.Line;\n import org.apache.commons.math.geometry.euclidean.threed.Plane;\n-import org.apache.commons.math.geometry.euclidean.threed.Point3D;\n import org.apache.commons.math.geometry.euclidean.threed.Rotation;\n import org.apache.commons.math.geometry.euclidean.threed.Vector3D;\n import org.junit.Assert;\n     @Test\n     public void testContains() {\n         Plane p = new Plane(new Vector3D(0, 0, 1), new Vector3D(0, 0, 1));\n-        Assert.assertTrue(p.contains(new Point3D(0, 0, 1)));\n-        Assert.assertTrue(p.contains(new Point3D(17, -32, 1)));\n-        Assert.assertTrue(! p.contains(new Point3D(17, -32, 1.001)));\n+        Assert.assertTrue(p.contains(new Vector3D(0, 0, 1)));\n+        Assert.assertTrue(p.contains(new Vector3D(17, -32, 1)));\n+        Assert.assertTrue(! p.contains(new Vector3D(17, -32, 1.001)));\n     }\n \n     @Test\n     public void testOffset() {\n         Vector3D p1 = new Vector3D(1, 1, 1);\n         Plane p = new Plane(p1, new Vector3D(0.2, 0, 0));\n-        Assert.assertEquals(-5.0, p.getOffset(new Point3D(-4, 0, 0)), 1.0e-10);\n-        Assert.assertEquals(+5.0, p.getOffset(new Point3D(6, 10, -12)), 1.0e-10);\n+        Assert.assertEquals(-5.0, p.getOffset(new Vector3D(-4, 0, 0)), 1.0e-10);\n+        Assert.assertEquals(+5.0, p.getOffset(new Vector3D(6, 10, -12)), 1.0e-10);\n         Assert.assertEquals(0.3,\n-                            p.getOffset(new Point3D(1.0, p1, 0.3, p.getNormal())),\n+                            p.getOffset(new Vector3D(1.0, p1, 0.3, p.getNormal())),\n                             1.0e-10);\n         Assert.assertEquals(-0.3,\n-                            p.getOffset(new Point3D(1.0, p1, -0.3, p.getNormal())),\n+                            p.getOffset(new Vector3D(1.0, p1, -0.3, p.getNormal())),\n                             1.0e-10);\n     }\n \n \n     @Test\n     public void testThreePoints() {\n-        Point3D p1 = new Point3D(1.2, 3.4, -5.8);\n-        Point3D p2 = new Point3D(3.4, -5.8, 1.2);\n-        Point3D p3 = new Point3D(-2.0, 4.3, 0.7);\n+        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);\n+        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);\n+        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);\n         Plane    p  = new Plane(p1, p2, p3);\n         Assert.assertTrue(p.contains(p1));\n         Assert.assertTrue(p.contains(p2));\n \n     @Test\n     public void testRotate() {\n-        Point3D p1 = new Point3D(1.2, 3.4, -5.8);\n-        Point3D p2 = new Point3D(3.4, -5.8, 1.2);\n-        Point3D p3 = new Point3D(-2.0, 4.3, 0.7);\n+        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);\n+        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);\n+        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);\n         Plane    p  = new Plane(p1, p2, p3);\n         Vector3D oldNormal = p.getNormal();\n \n \n     @Test\n     public void testTranslate() {\n-        Point3D p1 = new Point3D(1.2, 3.4, -5.8);\n-        Point3D p2 = new Point3D(3.4, -5.8, 1.2);\n-        Point3D p3 = new Point3D(-2.0, 4.3, 0.7);\n+        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);\n+        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);\n+        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);\n         Plane    p  = new Plane(p1, p2, p3);\n \n         p = p.translate(new Vector3D(2.0, p.getU(), -1.5, p.getV()));\n     public void testIntersection() {\n         Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5));\n         Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1, 1, -1));\n-        Point3D point = p.intersection(l);\n+        Vector3D point = p.intersection(l);\n         Assert.assertTrue(p.contains(point));\n         Assert.assertTrue(l.contains(point));\n         Assert.assertNull(p.intersection(new Line(new Vector3D(10, 10, 10),\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSetTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSetTest.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n-import java.util.Arrays;\n-\n-import org.apache.commons.math.geometry.euclidean.threed.Plane;\n-import org.apache.commons.math.geometry.euclidean.threed.Point3D;\n-import org.apache.commons.math.geometry.euclidean.threed.PolyhedronsSet;\n-import org.apache.commons.math.geometry.euclidean.threed.Rotation;\n-import org.apache.commons.math.geometry.euclidean.threed.Vector3D;\n-import org.apache.commons.math.geometry.euclidean.twod.Point2D;\n import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n-import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.BoundaryAttribute;\n import org.apache.commons.math.geometry.partitioning.Region;\n-import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n                     boolean zOK = (z >= 0.0) && (z <= 1.0);\n                     Region.Location expected =\n                         (xOK && yOK && zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE;\n-                    Assert.assertEquals(expected, tree.checkPoint(new Point3D(x, y, z)));\n+                    Assert.assertEquals(expected, tree.checkPoint(new Vector3D(x, y, z)));\n                 }\n             }\n         }\n-        checkPoints(Region.Location.BOUNDARY, tree, new Point3D[] {\n-            new Point3D(0.0, 0.5, 0.5),\n-            new Point3D(1.0, 0.5, 0.5),\n-            new Point3D(0.5, 0.0, 0.5),\n-            new Point3D(0.5, 1.0, 0.5),\n-            new Point3D(0.5, 0.5, 0.0),\n-            new Point3D(0.5, 0.5, 1.0)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, tree, new Point3D[] {\n-            new Point3D(0.0, 1.2, 1.2),\n-            new Point3D(1.0, 1.2, 1.2),\n-            new Point3D(1.2, 0.0, 1.2),\n-            new Point3D(1.2, 1.0, 1.2),\n-            new Point3D(1.2, 1.2, 0.0),\n-            new Point3D(1.2, 1.2, 1.0)\n+        checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] {\n+            new Vector3D(0.0, 0.5, 0.5),\n+            new Vector3D(1.0, 0.5, 0.5),\n+            new Vector3D(0.5, 0.0, 0.5),\n+            new Vector3D(0.5, 1.0, 0.5),\n+            new Vector3D(0.5, 0.5, 0.0),\n+            new Vector3D(0.5, 0.5, 1.0)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] {\n+            new Vector3D(0.0, 1.2, 1.2),\n+            new Vector3D(1.0, 1.2, 1.2),\n+            new Vector3D(1.2, 0.0, 1.2),\n+            new Vector3D(1.2, 1.0, 1.2),\n+            new Vector3D(1.2, 1.2, 0.0),\n+            new Vector3D(1.2, 1.2, 1.0)\n         });\n     }\n \n     @Test\n     public void testTetrahedron() {\n-        Point3D vertex1 = new Point3D(1, 2, 3);\n-        Point3D vertex2 = new Point3D(2, 2, 4);\n-        Point3D vertex3 = new Point3D(2, 3, 3);\n-        Point3D vertex4 = new Point3D(1, 3, 4);\n+        Vector3D vertex1 = new Vector3D(1, 2, 3);\n+        Vector3D vertex2 = new Vector3D(2, 2, 4);\n+        Vector3D vertex3 = new Vector3D(2, 3, 3);\n+        Vector3D vertex4 = new Vector3D(1, 3, 4);\n+        @SuppressWarnings(\"unchecked\")\n         PolyhedronsSet tree =\n-            (PolyhedronsSet) Region.buildConvex(Arrays.asList(new Hyperplane[] {\n+            (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(\n                 new Plane(vertex3, vertex2, vertex1),\n                 new Plane(vertex2, vertex3, vertex4),\n                 new Plane(vertex4, vertex3, vertex1),\n-                new Plane(vertex1, vertex2, vertex4)\n-            }));\n+                new Plane(vertex1, vertex2, vertex4));\n         Assert.assertEquals(1.0 / 3.0, tree.getSize(), 1.0e-10);\n         Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), 1.0e-10);\n         Vector3D barycenter = (Vector3D) tree.getBarycenter();\n         Assert.assertEquals(2.5, barycenter.getY(), 1.0e-10);\n         Assert.assertEquals(3.5, barycenter.getZ(), 1.0e-10);\n         double third = 1.0 / 3.0;\n-        checkPoints(Region.Location.BOUNDARY, tree, new Point3D[] {\n+        checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] {\n             vertex1, vertex2, vertex3, vertex4,\n-            new Point3D(third, vertex1, third, vertex2, third, vertex3),\n-            new Point3D(third, vertex2, third, vertex3, third, vertex4),\n-            new Point3D(third, vertex3, third, vertex4, third, vertex1),\n-            new Point3D(third, vertex4, third, vertex1, third, vertex2)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, tree, new Point3D[] {\n-            new Point3D(1, 2, 4),\n-            new Point3D(2, 2, 3),\n-            new Point3D(2, 3, 4),\n-            new Point3D(1, 3, 3)\n+            new Vector3D(third, vertex1, third, vertex2, third, vertex3),\n+            new Vector3D(third, vertex2, third, vertex3, third, vertex4),\n+            new Vector3D(third, vertex3, third, vertex4, third, vertex1),\n+            new Vector3D(third, vertex4, third, vertex1, third, vertex2)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] {\n+            new Vector3D(1, 2, 4),\n+            new Vector3D(2, 2, 3),\n+            new Vector3D(2, 3, 4),\n+            new Vector3D(1, 3, 3)\n         });\n     }\n \n         Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2);\n         Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7);\n         Vector3D vertex4 = new Vector3D(1.0, 3.6, 4.5);\n+        @SuppressWarnings(\"unchecked\")\n         PolyhedronsSet tree =\n-            (PolyhedronsSet) Region.buildConvex(Arrays.asList(new Hyperplane[] {\n+            (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(\n                 new Plane(vertex3, vertex2, vertex1),\n                 new Plane(vertex2, vertex3, vertex4),\n                 new Plane(vertex4, vertex3, vertex1),\n-                new Plane(vertex1, vertex2, vertex4)\n-            }));\n+                new Plane(vertex1, vertex2, vertex4));\n         Vector3D barycenter = (Vector3D) tree.getBarycenter();\n         Vector3D s = new Vector3D(10.2, 4.3, -6.7);\n         Vector3D c = new Vector3D(-0.2, 2.1, -3.2);\n                                                                 1.0, c,\n                                                                 1.0, r.applyTo(vertex4.subtract(c)))\n         };\n-        tree.getTree(true).visit(new BSPTreeVisitor() {\n-\n-            public Order visitOrder(BSPTree node) {\n+        tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>() {\n+\n+            public Order visitOrder(BSPTree<Euclidean3D> node) {\n                 return Order.MINUS_SUB_PLUS;\n             }\n \n-            public void visitInternalNode(BSPTree node) {\n-                Region.BoundaryAttribute attribute =\n-                    (Region.BoundaryAttribute) node.getAttribute();\n+            public void visitInternalNode(BSPTree<Euclidean3D> node) {\n+                @SuppressWarnings(\"unchecked\")\n+                BoundaryAttribute<Euclidean3D> attribute =\n+                    (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n                 if (attribute.getPlusOutside() != null) {\n-                    checkFacet(attribute.getPlusOutside());\n+                    checkFacet((SubPlane) attribute.getPlusOutside());\n                 }\n                 if (attribute.getPlusInside() != null) {\n-                    checkFacet(attribute.getPlusInside());\n-                }\n-            }\n-\n-            public void visitLeafNode(BSPTree node) {\n-            }\n-\n-            private void checkFacet(SubHyperplane facet) {\n+                    checkFacet((SubPlane) attribute.getPlusInside());\n+                }\n+            }\n+\n+            public void visitLeafNode(BSPTree<Euclidean3D> node) {\n+            }\n+\n+            private void checkFacet(SubPlane facet) {\n                 Plane plane = (Plane) facet.getHyperplane();\n-                Point2D[][] vertices =\n+                Vector2D[][] vertices =\n                     ((PolygonsSet) facet.getRemainingRegion()).getVertices();\n                 Assert.assertEquals(1, vertices.length);\n                 for (int i = 0; i < vertices[0].length; ++i) {\n             new PolyhedronsSet(x - w, x + w, y - l, y + l, z - w, z + w);\n         PolyhedronsSet zBeam =\n             new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l);\n-        PolyhedronsSet tree =\n-            (PolyhedronsSet) Region.union(xBeam, Region.union(yBeam, zBeam));\n+        RegionFactory<Euclidean3D> factory = new RegionFactory<Euclidean3D>();\n+        PolyhedronsSet tree = (PolyhedronsSet) factory.union(xBeam, factory.union(yBeam, zBeam));\n         Vector3D barycenter = (Vector3D) tree.getBarycenter();\n \n         Assert.assertEquals(x, barycenter.getX(), 1.0e-10);\n \n     }\n \n-    private void checkPoints(Region.Location expected, PolyhedronsSet tree, Point3D[] points) {\n+    private void checkPoints(Region.Location expected, PolyhedronsSet tree, Vector3D[] points) {\n         for (int i = 0; i < points.length; ++i) {\n             Assert.assertEquals(expected, tree.checkPoint(points[i]));\n         }\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/twod/LineTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/twod/LineTest.java\n  */\n package org.apache.commons.math.geometry.euclidean.twod;\n \n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.euclidean.twod.Line;\n-import org.apache.commons.math.geometry.euclidean.twod.Point2D;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math.geometry.partitioning.Transform;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n \n     @Test\n     public void testContains() {\n-        Line l = new Line(new Point2D(0, 1), new Point2D(1, 2));\n-        Assert.assertTrue(l.contains(new Point2D(0, 1)));\n-        Assert.assertTrue(l.contains(new Point2D(1, 2)));\n-        Assert.assertTrue(l.contains(new Point2D(7, 8)));\n-        Assert.assertTrue(! l.contains(new Point2D(8, 7)));\n+        Line l = new Line(new Vector2D(0, 1), new Vector2D(1, 2));\n+        Assert.assertTrue(l.contains(new Vector2D(0, 1)));\n+        Assert.assertTrue(l.contains(new Vector2D(1, 2)));\n+        Assert.assertTrue(l.contains(new Vector2D(7, 8)));\n+        Assert.assertTrue(! l.contains(new Vector2D(8, 7)));\n     }\n \n     @Test\n     public void testAbscissa() {\n-        Line l = new Line(new Point2D(2, 1), new Point2D(-2, -2));\n+        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2));\n         Assert.assertEquals(0.0,\n-                            ((Point1D) l.toSubSpace(new Point2D(-3,  4))).getAbscissa(),\n+                            ((Vector1D) l.toSubSpace(new Vector2D(-3,  4))).getX(),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            ((Point1D) l.toSubSpace(new Point2D( 3, -4))).getAbscissa(),\n+                            ((Vector1D) l.toSubSpace(new Vector2D( 3, -4))).getX(),\n                             1.0e-10);\n         Assert.assertEquals(-5.0,\n-                            ((Point1D) l.toSubSpace(new Point2D( 7, -1))).getAbscissa(),\n+                            ((Vector1D) l.toSubSpace(new Vector2D( 7, -1))).getX(),\n                             1.0e-10);\n         Assert.assertEquals( 5.0,\n-                             ((Point1D) l.toSubSpace(new Point2D(-1, -7))).getAbscissa(),\n+                             ((Vector1D) l.toSubSpace(new Vector2D(-1, -7))).getX(),\n                              1.0e-10);\n     }\n \n     @Test\n     public void testOffset() {\n-        Line l = new Line(new Point2D(2, 1), new Point2D(-2, -2));\n-        Assert.assertEquals(-5.0, l.getOffset(new Point2D(5, -3)), 1.0e-10);\n-        Assert.assertEquals(+5.0, l.getOffset(new Point2D(-5, 2)), 1.0e-10);\n+        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2));\n+        Assert.assertEquals(-5.0, l.getOffset(new Vector2D(5, -3)), 1.0e-10);\n+        Assert.assertEquals(+5.0, l.getOffset(new Vector2D(-5, 2)), 1.0e-10);\n     }\n \n     @Test\n     public void testPointAt() {\n-        Line l = new Line(new Point2D(2, 1), new Point2D(-2, -2));\n+        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2));\n         for (double a = -2.0; a < 2.0; a += 0.2) {\n-            Point1D pA = new Point1D(a);\n-            Point2D point = (Point2D) l.toSpace(pA);\n-            Assert.assertEquals(a, ((Point1D) l.toSubSpace(point)).getAbscissa(), 1.0e-10);\n+            Vector1D pA = new Vector1D(a);\n+            Vector2D point = (Vector2D) l.toSpace(pA);\n+            Assert.assertEquals(a, ((Vector1D) l.toSubSpace(point)).getX(), 1.0e-10);\n             Assert.assertEquals(0.0, l.getOffset(point),   1.0e-10);\n             for (double o = -2.0; o < 2.0; o += 0.2) {\n                 point = l.getPointAt(pA, o);\n-                Assert.assertEquals(a, ((Point1D) l.toSubSpace(point)).getAbscissa(), 1.0e-10);\n+                Assert.assertEquals(a, ((Vector1D) l.toSubSpace(point)).getX(), 1.0e-10);\n                 Assert.assertEquals(o, l.getOffset(point),   1.0e-10);\n             }\n         }\n \n     @Test\n     public void testOriginOffset() {\n-        Line l1 = new Line(new Point2D(0, 1), new Point2D(1, 2));\n+        Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2));\n         Assert.assertEquals(FastMath.sqrt(0.5), l1.getOriginOffset(), 1.0e-10);\n-        Line l2 = new Line(new Point2D(1, 2), new Point2D(0, 1));\n+        Line l2 = new Line(new Vector2D(1, 2), new Vector2D(0, 1));\n         Assert.assertEquals(-FastMath.sqrt(0.5), l2.getOriginOffset(), 1.0e-10);\n     }\n \n     @Test\n     public void testParallel() {\n-        Line l1 = new Line(new Point2D(0, 1), new Point2D(1, 2));\n-        Line l2 = new Line(new Point2D(2, 2), new Point2D(3, 3));\n+        Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2));\n+        Line l2 = new Line(new Vector2D(2, 2), new Vector2D(3, 3));\n         Assert.assertTrue(l1.isParallelTo(l2));\n-        Line l3 = new Line(new Point2D(1, 0), new Point2D(0.5, -0.5));\n+        Line l3 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.5));\n         Assert.assertTrue(l1.isParallelTo(l3));\n-        Line l4 = new Line(new Point2D(1, 0), new Point2D(0.5, -0.51));\n+        Line l4 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.51));\n         Assert.assertTrue(! l1.isParallelTo(l4));\n     }\n \n     @Test\n     public void testTransform() {\n \n-        Line l1 = new Line(new Point2D(1.0 ,1.0), new Point2D(4.0 ,1.0));\n-        Transform t1 = Line.getTransform(new AffineTransform(0.0, 0.5,\n-                                                             -1.0, 0.0,\n-                                                             1.0, 1.5));\n+        Line l1 = new Line(new Vector2D(1.0 ,1.0), new Vector2D(4.0 ,1.0));\n+        Transform<Euclidean2D, Euclidean1D> t1 =\n+            Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5));\n         Assert.assertEquals(0.5 * FastMath.PI,\n                             ((Line) t1.apply(l1)).getAngle(),\n                             1.0e-10);\n \n-        Line l2 = new Line(new Point2D(0.0, 0.0), new Point2D(1.0, 1.0));\n-        Transform t2 = Line.getTransform(new AffineTransform(0.0, 0.5,\n-                                                             -1.0, 0.0,\n-                                                             1.0, 1.5));\n+        Line l2 = new Line(new Vector2D(0.0, 0.0), new Vector2D(1.0, 1.0));\n+        Transform<Euclidean2D, Euclidean1D> t2 =\n+            Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5));\n         Assert.assertEquals(FastMath.atan2(1.0, -2.0),\n                             ((Line) t2.apply(l2)).getAngle(),\n                             1.0e-10);\n \n     @Test\n     public void testIntersection() {\n-        Line    l1 = new Line(new Point2D( 0, 1), new Point2D(1, 2));\n-        Line    l2 = new Line(new Point2D(-1, 2), new Point2D(2, 1));\n-        Point2D p  = (Point2D) l1.intersection(l2);\n-        Assert.assertEquals(0.5, p.x, 1.0e-10);\n-        Assert.assertEquals(1.5, p.y, 1.0e-10);\n+        Line    l1 = new Line(new Vector2D( 0, 1), new Vector2D(1, 2));\n+        Line    l2 = new Line(new Vector2D(-1, 2), new Vector2D(2, 1));\n+        Vector2D p  = (Vector2D) l1.intersection(l2);\n+        Assert.assertEquals(0.5, p.getX(), 1.0e-10);\n+        Assert.assertEquals(1.5, p.getY(), 1.0e-10);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSetTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSetTest.java\n \n import org.apache.commons.math.geometry.euclidean.oned.Interval;\n import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n-import org.apache.commons.math.geometry.euclidean.oned.Point1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.euclidean.twod.Line;\n-import org.apache.commons.math.geometry.euclidean.twod.Point2D;\n+import org.apache.commons.math.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n \n     @Test\n     public void testSimplyConnected() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(36.0, 22.0),\n-                new Point2D(39.0, 32.0),\n-                new Point2D(19.0, 32.0),\n-                new Point2D( 6.0, 16.0),\n-                new Point2D(31.0, 10.0),\n-                new Point2D(42.0, 16.0),\n-                new Point2D(34.0, 20.0),\n-                new Point2D(29.0, 19.0),\n-                new Point2D(23.0, 22.0),\n-                new Point2D(33.0, 25.0)\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(36.0, 22.0),\n+                new Vector2D(39.0, 32.0),\n+                new Vector2D(19.0, 32.0),\n+                new Vector2D( 6.0, 16.0),\n+                new Vector2D(31.0, 10.0),\n+                new Vector2D(42.0, 16.0),\n+                new Vector2D(34.0, 20.0),\n+                new Vector2D(29.0, 19.0),\n+                new Vector2D(23.0, 22.0),\n+                new Vector2D(33.0, 25.0)\n             }\n         };\n         PolygonsSet set = buildSet(vertices);\n-        Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Point2D(50.0, 30.0)));\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(30.0, 15.0),\n-            new Point2D(15.0, 20.0),\n-            new Point2D(24.0, 25.0),\n-            new Point2D(35.0, 30.0),\n-            new Point2D(19.0, 17.0)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D(50.0, 30.0),\n-            new Point2D(30.0, 35.0),\n-            new Point2D(10.0, 25.0),\n-            new Point2D(10.0, 10.0),\n-            new Point2D(40.0, 10.0),\n-            new Point2D(50.0, 15.0),\n-            new Point2D(30.0, 22.0)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(30.0, 32.0),\n-            new Point2D(34.0, 20.0)\n+        Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector2D(50.0, 30.0)));\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(30.0, 15.0),\n+            new Vector2D(15.0, 20.0),\n+            new Vector2D(24.0, 25.0),\n+            new Vector2D(35.0, 30.0),\n+            new Vector2D(19.0, 17.0)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D(50.0, 30.0),\n+            new Vector2D(30.0, 35.0),\n+            new Vector2D(10.0, 25.0),\n+            new Vector2D(10.0, 10.0),\n+            new Vector2D(40.0, 10.0),\n+            new Vector2D(50.0, 15.0),\n+            new Vector2D(30.0, 22.0)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(30.0, 32.0),\n+            new Vector2D(34.0, 20.0)\n         });\n         checkVertices(set.getVertices(), vertices);\n     }\n \n     @Test\n     public void testStair() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0, 0.0),\n-                new Point2D( 0.0, 2.0),\n-                new Point2D(-0.1, 2.0),\n-                new Point2D(-0.1, 1.0),\n-                new Point2D(-0.3, 1.0),\n-                new Point2D(-0.3, 1.5),\n-                new Point2D(-1.3, 1.5),\n-                new Point2D(-1.3, 2.0),\n-                new Point2D(-1.8, 2.0),\n-                new Point2D(-1.8 - 1.0 / FastMath.sqrt(2.0),\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0, 0.0),\n+                new Vector2D( 0.0, 2.0),\n+                new Vector2D(-0.1, 2.0),\n+                new Vector2D(-0.1, 1.0),\n+                new Vector2D(-0.3, 1.0),\n+                new Vector2D(-0.3, 1.5),\n+                new Vector2D(-1.3, 1.5),\n+                new Vector2D(-1.3, 2.0),\n+                new Vector2D(-1.8, 2.0),\n+                new Vector2D(-1.8 - 1.0 / FastMath.sqrt(2.0),\n                             2.0 - 1.0 / FastMath.sqrt(2.0))\n             }\n         };\n \n     @Test\n     public void testHole() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(0.0, 0.0),\n-                new Point2D(3.0, 0.0),\n-                new Point2D(3.0, 3.0),\n-                new Point2D(0.0, 3.0)\n-            }, new Point2D[] {\n-                new Point2D(1.0, 2.0),\n-                new Point2D(2.0, 2.0),\n-                new Point2D(2.0, 1.0),\n-                new Point2D(1.0, 1.0)\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(0.0, 0.0),\n+                new Vector2D(3.0, 0.0),\n+                new Vector2D(3.0, 3.0),\n+                new Vector2D(0.0, 3.0)\n+            }, new Vector2D[] {\n+                new Vector2D(1.0, 2.0),\n+                new Vector2D(2.0, 2.0),\n+                new Vector2D(2.0, 1.0),\n+                new Vector2D(1.0, 1.0)\n             }\n         };\n         PolygonsSet set = buildSet(vertices);\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(0.5, 0.5),\n-            new Point2D(1.5, 0.5),\n-            new Point2D(2.5, 0.5),\n-            new Point2D(0.5, 1.5),\n-            new Point2D(2.5, 1.5),\n-            new Point2D(0.5, 2.5),\n-            new Point2D(1.5, 2.5),\n-            new Point2D(2.5, 2.5),\n-            new Point2D(0.5, 1.0)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D(1.5, 1.5),\n-            new Point2D(3.5, 1.0),\n-            new Point2D(4.0, 1.5),\n-            new Point2D(6.0, 6.0)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(1.0, 1.0),\n-            new Point2D(1.5, 0.0),\n-            new Point2D(1.5, 1.0),\n-            new Point2D(1.5, 2.0),\n-            new Point2D(1.5, 3.0),\n-            new Point2D(3.0, 3.0)\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(0.5, 0.5),\n+            new Vector2D(1.5, 0.5),\n+            new Vector2D(2.5, 0.5),\n+            new Vector2D(0.5, 1.5),\n+            new Vector2D(2.5, 1.5),\n+            new Vector2D(0.5, 2.5),\n+            new Vector2D(1.5, 2.5),\n+            new Vector2D(2.5, 2.5),\n+            new Vector2D(0.5, 1.0)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D(1.5, 1.5),\n+            new Vector2D(3.5, 1.0),\n+            new Vector2D(4.0, 1.5),\n+            new Vector2D(6.0, 6.0)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.0),\n+            new Vector2D(1.5, 0.0),\n+            new Vector2D(1.5, 1.0),\n+            new Vector2D(1.5, 2.0),\n+            new Vector2D(1.5, 3.0),\n+            new Vector2D(3.0, 3.0)\n         });\n         checkVertices(set.getVertices(), vertices);\n     }\n \n     @Test\n     public void testDisjointPolygons() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(0.0, 1.0),\n-                new Point2D(2.0, 1.0),\n-                new Point2D(1.0, 2.0)\n-            }, new Point2D[] {\n-                new Point2D(4.0, 0.0),\n-                new Point2D(5.0, 1.0),\n-                new Point2D(3.0, 1.0)\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(0.0, 1.0),\n+                new Vector2D(2.0, 1.0),\n+                new Vector2D(1.0, 2.0)\n+            }, new Vector2D[] {\n+                new Vector2D(4.0, 0.0),\n+                new Vector2D(5.0, 1.0),\n+                new Vector2D(3.0, 1.0)\n             }\n         };\n         PolygonsSet set = buildSet(vertices);\n-        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Point2D(1.0, 1.5)));\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(1.0, 1.5),\n-            new Point2D(4.5, 0.8)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D(1.0, 0.0),\n-            new Point2D(3.5, 1.2),\n-            new Point2D(2.5, 1.0),\n-            new Point2D(3.0, 4.0)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(1.0, 1.0),\n-            new Point2D(3.5, 0.5),\n-            new Point2D(0.0, 1.0)\n+        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector2D(1.0, 1.5)));\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.5),\n+            new Vector2D(4.5, 0.8)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D(1.0, 0.0),\n+            new Vector2D(3.5, 1.2),\n+            new Vector2D(2.5, 1.0),\n+            new Vector2D(3.0, 4.0)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.0),\n+            new Vector2D(3.5, 0.5),\n+            new Vector2D(0.0, 1.0)\n         });\n         checkVertices(set.getVertices(), vertices);\n     }\n \n     @Test\n     public void testOppositeHyperplanes() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(1.0, 0.0),\n-                new Point2D(2.0, 1.0),\n-                new Point2D(3.0, 1.0),\n-                new Point2D(2.0, 2.0),\n-                new Point2D(1.0, 1.0),\n-                new Point2D(0.0, 1.0)\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(1.0, 0.0),\n+                new Vector2D(2.0, 1.0),\n+                new Vector2D(3.0, 1.0),\n+                new Vector2D(2.0, 2.0),\n+                new Vector2D(1.0, 1.0),\n+                new Vector2D(0.0, 1.0)\n             }\n         };\n         PolygonsSet set = buildSet(vertices);\n \n     @Test\n     public void testSingularPoint() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 1.0,  0.0),\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 0.0,  1.0),\n-                new Point2D( 0.0,  0.0),\n-                new Point2D(-1.0,  0.0),\n-                new Point2D(-1.0, -1.0),\n-                new Point2D( 0.0, -1.0)\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 1.0,  0.0),\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 0.0,  1.0),\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D(-1.0,  0.0),\n+                new Vector2D(-1.0, -1.0),\n+                new Vector2D( 0.0, -1.0)\n             }\n         };\n         PolygonsSet set = buildSet(vertices);\n \n     @Test\n     public void testLineIntersection() {\n-        Point2D[][] vertices = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0),\n-                new Point2D( 1.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n+        Vector2D[][] vertices = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0),\n+                new Vector2D( 1.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n             }\n         };\n         PolygonsSet set = buildSet(vertices);\n \n-        Line l1 = new Line(new Point2D(-1.5, 0.0), FastMath.PI / 4);\n-        SubHyperplane s1 = set.intersection(new SubHyperplane(l1));\n+        Line l1 = new Line(new Vector2D(-1.5, 0.0), FastMath.PI / 4);\n+        SubLine s1 = (SubLine) set.intersection(l1.wholeHyperplane());\n         List<Interval> i1 = ((IntervalsSet) s1.getRemainingRegion()).asList();\n         Assert.assertEquals(2, i1.size());\n         Interval v10 = (Interval) i1.get(0);\n-        Point2D p10Lower = (Point2D) l1.toSpace(new Point1D(v10.getLower()));\n+        Vector2D p10Lower = (Vector2D) l1.toSpace(new Vector1D(v10.getLower()));\n         Assert.assertEquals(0.0, p10Lower.getX(), 1.0e-10);\n         Assert.assertEquals(1.5, p10Lower.getY(), 1.0e-10);\n-        Point2D p10Upper = (Point2D) l1.toSpace(new Point1D(v10.getUpper()));\n+        Vector2D p10Upper = (Vector2D) l1.toSpace(new Vector1D(v10.getUpper()));\n         Assert.assertEquals(0.5, p10Upper.getX(), 1.0e-10);\n         Assert.assertEquals(2.0, p10Upper.getY(), 1.0e-10);\n         Interval v11 = (Interval) i1.get(1);\n-        Point2D p11Lower = (Point2D) l1.toSpace(new Point1D(v11.getLower()));\n+        Vector2D p11Lower = (Vector2D) l1.toSpace(new Vector1D(v11.getLower()));\n         Assert.assertEquals(1.0, p11Lower.getX(), 1.0e-10);\n         Assert.assertEquals(2.5, p11Lower.getY(), 1.0e-10);\n-        Point2D p11Upper = (Point2D) l1.toSpace(new Point1D(v11.getUpper()));\n+        Vector2D p11Upper = (Vector2D) l1.toSpace(new Vector1D(v11.getUpper()));\n         Assert.assertEquals(1.5, p11Upper.getX(), 1.0e-10);\n         Assert.assertEquals(3.0, p11Upper.getY(), 1.0e-10);\n \n-        Line l2 = new Line(new Point2D(-1.0, 2.0), 0);\n-        SubHyperplane s2 = set.intersection(new SubHyperplane(l2));\n+        Line l2 = new Line(new Vector2D(-1.0, 2.0), 0);\n+        SubLine s2 = (SubLine) set.intersection(l2.wholeHyperplane());\n         List<Interval> i2 = ((IntervalsSet) s2.getRemainingRegion()).asList();\n         Assert.assertEquals(1, i2.size());\n         Interval v20 = (Interval) i2.get(0);\n-        Point2D p20Lower = (Point2D) l2.toSpace(new Point1D(v20.getLower()));\n+        Vector2D p20Lower = (Vector2D) l2.toSpace(new Vector1D(v20.getLower()));\n         Assert.assertEquals(1.0, p20Lower.getX(), 1.0e-10);\n         Assert.assertEquals(2.0, p20Lower.getY(), 1.0e-10);\n-        Point2D p20Upper = (Point2D) l2.toSpace(new Point1D(v20.getUpper()));\n+        Vector2D p20Upper = (Vector2D) l2.toSpace(new Vector1D(v20.getUpper()));\n         Assert.assertEquals(3.0, p20Upper.getX(), 1.0e-10);\n         Assert.assertEquals(2.0, p20Upper.getY(), 1.0e-10);\n \n \n     @Test\n     public void testUnlimitedSubHyperplane() {\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(0.0, 0.0),\n-                new Point2D(4.0, 0.0),\n-                new Point2D(1.4, 1.5),\n-                new Point2D(0.0, 3.5)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(0.0, 0.0),\n+                new Vector2D(4.0, 0.0),\n+                new Vector2D(1.4, 1.5),\n+                new Vector2D(0.0, 3.5)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(1.4,  0.2),\n-                new Point2D(2.8, -1.2),\n-                new Point2D(2.5,  0.6)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(1.4,  0.2),\n+                new Vector2D(2.8, -1.2),\n+                new Vector2D(2.5,  0.6)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n \n-        PolygonsSet set = (PolygonsSet) Region.union(set1.copySelf(),\n-                                                     set2.copySelf());\n+        PolygonsSet set =\n+            (PolygonsSet) new RegionFactory<Euclidean2D>().union(set1.copySelf(),\n+                                                                 set2.copySelf());\n         checkVertices(set1.getVertices(), vertices1);\n         checkVertices(set2.getVertices(), vertices2);\n-        checkVertices(set.getVertices(), new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(0.0,  0.0),\n-                new Point2D(1.6,  0.0),\n-                new Point2D(2.8, -1.2),\n-                new Point2D(2.6,  0.0),\n-                new Point2D(4.0,  0.0),\n-                new Point2D(1.4,  1.5),\n-                new Point2D(0.0,  3.5)\n+        checkVertices(set.getVertices(), new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(0.0,  0.0),\n+                new Vector2D(1.6,  0.0),\n+                new Vector2D(2.8, -1.2),\n+                new Vector2D(2.6,  0.0),\n+                new Vector2D(4.0,  0.0),\n+                new Vector2D(1.4,  1.5),\n+                new Vector2D(0.0,  3.5)\n             }\n         });\n \n \n     @Test\n     public void testUnion() {\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n-        PolygonsSet set  = (PolygonsSet) Region.union(set1.copySelf(),\n-                                                      set2.copySelf());\n+        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().union(set1.copySelf(),\n+                                                                                set2.copySelf());\n         checkVertices(set1.getVertices(), vertices1);\n         checkVertices(set2.getVertices(), vertices2);\n-        checkVertices(set.getVertices(), new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0),\n-                new Point2D( 1.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n-            }\n-        });\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(1.0, 1.0),\n-            new Point2D(0.5, 0.5),\n-            new Point2D(2.0, 2.0),\n-            new Point2D(2.5, 2.5),\n-            new Point2D(0.5, 1.5),\n-            new Point2D(1.5, 1.5),\n-            new Point2D(1.5, 0.5),\n-            new Point2D(1.5, 2.5),\n-            new Point2D(2.5, 1.5),\n-            new Point2D(2.5, 2.5)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D(-0.5, 0.5),\n-            new Point2D( 0.5, 2.5),\n-            new Point2D( 2.5, 0.5),\n-            new Point2D( 3.5, 2.5)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(0.0, 0.0),\n-            new Point2D(0.5, 2.0),\n-            new Point2D(2.0, 0.5),\n-            new Point2D(2.5, 1.0),\n-            new Point2D(3.0, 2.5)\n+        checkVertices(set.getVertices(), new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0),\n+                new Vector2D( 1.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.0),\n+            new Vector2D(0.5, 0.5),\n+            new Vector2D(2.0, 2.0),\n+            new Vector2D(2.5, 2.5),\n+            new Vector2D(0.5, 1.5),\n+            new Vector2D(1.5, 1.5),\n+            new Vector2D(1.5, 0.5),\n+            new Vector2D(1.5, 2.5),\n+            new Vector2D(2.5, 1.5),\n+            new Vector2D(2.5, 2.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D(-0.5, 0.5),\n+            new Vector2D( 0.5, 2.5),\n+            new Vector2D( 2.5, 0.5),\n+            new Vector2D( 3.5, 2.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(0.0, 0.0),\n+            new Vector2D(0.5, 2.0),\n+            new Vector2D(2.0, 0.5),\n+            new Vector2D(2.5, 1.0),\n+            new Vector2D(3.0, 2.5)\n         });\n \n     }\n \n     @Test\n     public void testIntersection() {\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n-        PolygonsSet set  = (PolygonsSet) Region.intersection(set1.copySelf(),\n-                                                             set2.copySelf());\n+        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().intersection(set1.copySelf(),\n+                                                                                       set2.copySelf());\n         checkVertices(set1.getVertices(), vertices1);\n         checkVertices(set2.getVertices(), vertices2);\n-        checkVertices(set.getVertices(), new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 2.0,  1.0),\n-                new Point2D( 2.0,  2.0),\n-                new Point2D( 1.0,  2.0)\n-            }\n-        });\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(1.5, 1.5)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D(0.5, 1.5),\n-            new Point2D(2.5, 1.5),\n-            new Point2D(1.5, 0.5),\n-            new Point2D(0.5, 0.5)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(1.0, 1.0),\n-            new Point2D(2.0, 2.0),\n-            new Point2D(1.0, 1.5),\n-            new Point2D(1.5, 2.0)\n+        checkVertices(set.getVertices(), new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 2.0,  1.0),\n+                new Vector2D( 2.0,  2.0),\n+                new Vector2D( 1.0,  2.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(1.5, 1.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D(0.5, 1.5),\n+            new Vector2D(2.5, 1.5),\n+            new Vector2D(1.5, 0.5),\n+            new Vector2D(0.5, 0.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.0),\n+            new Vector2D(2.0, 2.0),\n+            new Vector2D(1.0, 1.5),\n+            new Vector2D(1.5, 2.0)\n         });\n     }\n \n     @Test\n     public void testXor() {\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n-        PolygonsSet set  = (PolygonsSet) Region.xor(set1.copySelf(),\n-                                                    set2.copySelf());\n+        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().xor(set1.copySelf(),\n+                                                                              set2.copySelf());\n         checkVertices(set1.getVertices(), vertices1);\n         checkVertices(set2.getVertices(), vertices2);\n-        checkVertices(set.getVertices(), new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0),\n-                new Point2D( 1.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n+        checkVertices(set.getVertices(), new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0),\n+                new Vector2D( 1.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n             },\n-            new Point2D[] {\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 1.0,  2.0),\n-                new Point2D( 2.0,  2.0),\n-                new Point2D( 2.0,  1.0)\n-            }\n-        });\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(0.5, 0.5),\n-            new Point2D(2.5, 2.5),\n-            new Point2D(0.5, 1.5),\n-            new Point2D(1.5, 0.5),\n-            new Point2D(1.5, 2.5),\n-            new Point2D(2.5, 1.5),\n-            new Point2D(2.5, 2.5)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D(-0.5, 0.5),\n-            new Point2D( 0.5, 2.5),\n-            new Point2D( 2.5, 0.5),\n-            new Point2D( 1.5, 1.5),\n-            new Point2D( 3.5, 2.5)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(1.0, 1.0),\n-            new Point2D(2.0, 2.0),\n-            new Point2D(1.5, 1.0),\n-            new Point2D(2.0, 1.5),\n-            new Point2D(0.0, 0.0),\n-            new Point2D(0.5, 2.0),\n-            new Point2D(2.0, 0.5),\n-            new Point2D(2.5, 1.0),\n-            new Point2D(3.0, 2.5)\n+            new Vector2D[] {\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 1.0,  2.0),\n+                new Vector2D( 2.0,  2.0),\n+                new Vector2D( 2.0,  1.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(0.5, 0.5),\n+            new Vector2D(2.5, 2.5),\n+            new Vector2D(0.5, 1.5),\n+            new Vector2D(1.5, 0.5),\n+            new Vector2D(1.5, 2.5),\n+            new Vector2D(2.5, 1.5),\n+            new Vector2D(2.5, 2.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D(-0.5, 0.5),\n+            new Vector2D( 0.5, 2.5),\n+            new Vector2D( 2.5, 0.5),\n+            new Vector2D( 1.5, 1.5),\n+            new Vector2D( 3.5, 2.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.0),\n+            new Vector2D(2.0, 2.0),\n+            new Vector2D(1.5, 1.0),\n+            new Vector2D(2.0, 1.5),\n+            new Vector2D(0.0, 0.0),\n+            new Vector2D(0.5, 2.0),\n+            new Vector2D(2.0, 0.5),\n+            new Vector2D(2.5, 1.0),\n+            new Vector2D(3.0, 2.5)\n         });\n     }\n \n     @Test\n     public void testDifference() {\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 3.0,  1.0),\n-                new Point2D( 3.0,  3.0),\n-                new Point2D( 1.0,  3.0)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 3.0,  1.0),\n+                new Vector2D( 3.0,  3.0),\n+                new Vector2D( 1.0,  3.0)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n-        PolygonsSet set  = (PolygonsSet) Region.difference(set1.copySelf(),\n-                                                           set2.copySelf());\n+        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().difference(set1.copySelf(),\n+                                                                                     set2.copySelf());\n         checkVertices(set1.getVertices(), vertices1);\n         checkVertices(set2.getVertices(), vertices2);\n-        checkVertices(set.getVertices(), new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.0,  0.0),\n-                new Point2D( 2.0,  0.0),\n-                new Point2D( 2.0,  1.0),\n-                new Point2D( 1.0,  1.0),\n-                new Point2D( 1.0,  2.0),\n-                new Point2D( 0.0,  2.0)\n-            }\n-        });\n-        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n-            new Point2D(0.5, 0.5),\n-            new Point2D(0.5, 1.5),\n-            new Point2D(1.5, 0.5)\n-        });\n-        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n-            new Point2D( 2.5, 2.5),\n-            new Point2D(-0.5, 0.5),\n-            new Point2D( 0.5, 2.5),\n-            new Point2D( 2.5, 0.5),\n-            new Point2D( 1.5, 1.5),\n-            new Point2D( 3.5, 2.5),\n-            new Point2D( 1.5, 2.5),\n-            new Point2D( 2.5, 1.5),\n-            new Point2D( 2.0, 1.5),\n-            new Point2D( 2.0, 2.0),\n-            new Point2D( 2.5, 1.0),\n-            new Point2D( 2.5, 2.5),\n-            new Point2D( 3.0, 2.5)\n-        });\n-        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n-            new Point2D(1.0, 1.0),\n-            new Point2D(1.5, 1.0),\n-            new Point2D(0.0, 0.0),\n-            new Point2D(0.5, 2.0),\n-            new Point2D(2.0, 0.5)\n+        checkVertices(set.getVertices(), new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.0,  0.0),\n+                new Vector2D( 2.0,  0.0),\n+                new Vector2D( 2.0,  1.0),\n+                new Vector2D( 1.0,  1.0),\n+                new Vector2D( 1.0,  2.0),\n+                new Vector2D( 0.0,  2.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {\n+            new Vector2D(0.5, 0.5),\n+            new Vector2D(0.5, 1.5),\n+            new Vector2D(1.5, 0.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {\n+            new Vector2D( 2.5, 2.5),\n+            new Vector2D(-0.5, 0.5),\n+            new Vector2D( 0.5, 2.5),\n+            new Vector2D( 2.5, 0.5),\n+            new Vector2D( 1.5, 1.5),\n+            new Vector2D( 3.5, 2.5),\n+            new Vector2D( 1.5, 2.5),\n+            new Vector2D( 2.5, 1.5),\n+            new Vector2D( 2.0, 1.5),\n+            new Vector2D( 2.0, 2.0),\n+            new Vector2D( 2.5, 1.0),\n+            new Vector2D( 2.5, 2.5),\n+            new Vector2D( 3.0, 2.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {\n+            new Vector2D(1.0, 1.0),\n+            new Vector2D(1.5, 1.0),\n+            new Vector2D(0.0, 0.0),\n+            new Vector2D(0.5, 2.0),\n+            new Vector2D(2.0, 0.5)\n         });\n     }\n \n     @Test\n     public void testEmptyDifference() {\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.5, 3.5),\n-                new Point2D( 0.5, 4.5),\n-                new Point2D(-0.5, 4.5),\n-                new Point2D(-0.5, 3.5)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.5, 3.5),\n+                new Vector2D( 0.5, 4.5),\n+                new Vector2D(-0.5, 4.5),\n+                new Vector2D(-0.5, 3.5)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 1.0, 2.0),\n-                new Point2D( 1.0, 8.0),\n-                new Point2D(-1.0, 8.0),\n-                new Point2D(-1.0, 2.0)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 1.0, 2.0),\n+                new Vector2D( 1.0, 8.0),\n+                new Vector2D(-1.0, 8.0),\n+                new Vector2D(-1.0, 2.0)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n-        Assert.assertTrue(Region.difference(set1.copySelf(), set2.copySelf()).isEmpty());\n+        Assert.assertTrue(new RegionFactory<Euclidean2D>().difference(set1.copySelf(), set2.copySelf()).isEmpty());\n     }\n \n     @Test\n     public void testChoppedHexagon() {\n         double pi6   = FastMath.PI / 6.0;\n         double sqrt3 = FastMath.sqrt(3.0);\n-        SubHyperplane[] hyp = {\n-            new SubHyperplane(new Line(new Point2D(   0.0, 1.0),  5 * pi6)),\n-            new SubHyperplane(new Line(new Point2D(-sqrt3, 1.0),  7 * pi6)),\n-            new SubHyperplane(new Line(new Point2D(-sqrt3, 1.0),  9 * pi6)),\n-            new SubHyperplane(new Line(new Point2D(-sqrt3, 0.0), 11 * pi6)),\n-            new SubHyperplane(new Line(new Point2D(   0.0, 0.0), 13 * pi6)),\n-            new SubHyperplane(new Line(new Point2D(   0.0, 1.0),  3 * pi6)),\n-            new SubHyperplane(new Line(new Point2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6))\n-        };\n-        hyp[1] =                              hyp[0].getHyperplane().split(hyp[1]).getMinus();\n-        hyp[2] =                              hyp[1].getHyperplane().split(hyp[2]).getMinus();\n-        hyp[3] =                              hyp[2].getHyperplane().split(hyp[3]).getMinus();\n-        hyp[4] = hyp[0].getHyperplane().split(hyp[3].getHyperplane().split(hyp[4]).getMinus()).getMinus();\n-        hyp[5] = hyp[0].getHyperplane().split(hyp[4].getHyperplane().split(hyp[5]).getMinus()).getMinus();\n-        hyp[6] = hyp[1].getHyperplane().split(hyp[3].getHyperplane().split(hyp[6]).getMinus()).getMinus();\n-        BSPTree tree = new BSPTree(Boolean.TRUE);\n+        SubLine[] hyp = {\n+            new Line(new Vector2D(   0.0, 1.0),  5 * pi6).wholeHyperplane(),\n+            new Line(new Vector2D(-sqrt3, 1.0),  7 * pi6).wholeHyperplane(),\n+            new Line(new Vector2D(-sqrt3, 1.0),  9 * pi6).wholeHyperplane(),\n+            new Line(new Vector2D(-sqrt3, 0.0), 11 * pi6).wholeHyperplane(),\n+            new Line(new Vector2D(   0.0, 0.0), 13 * pi6).wholeHyperplane(),\n+            new Line(new Vector2D(   0.0, 1.0),  3 * pi6).wholeHyperplane(),\n+            new Line(new Vector2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6).wholeHyperplane()\n+        };\n+        hyp[1] = (SubLine) hyp[1].split(hyp[0].getHyperplane()).getMinus();\n+        hyp[2] = (SubLine) hyp[2].split(hyp[1].getHyperplane()).getMinus();\n+        hyp[3] = (SubLine) hyp[3].split(hyp[2].getHyperplane()).getMinus();\n+        hyp[4] = (SubLine) hyp[4].split(hyp[3].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();\n+        hyp[5] = (SubLine) hyp[5].split(hyp[4].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();\n+        hyp[6] = (SubLine) hyp[6].split(hyp[3].getHyperplane()).getMinus().split(hyp[1].getHyperplane()).getMinus();\n+        BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>(Boolean.TRUE);\n         for (int i = hyp.length - 1; i >= 0; --i) {\n-            tree = new BSPTree(hyp[i], new BSPTree(Boolean.FALSE), tree, null);\n+            tree = new BSPTree<Euclidean2D>(hyp[i], new BSPTree<Euclidean2D>(Boolean.FALSE), tree, null);\n         }\n         PolygonsSet set = new PolygonsSet(tree);\n-        SubHyperplane splitter =\n-            new SubHyperplane(new Line(new Point2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6));\n+        SubLine splitter =\n+            new Line(new Vector2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6).wholeHyperplane();\n         PolygonsSet slice =\n-            new PolygonsSet(new BSPTree(splitter,\n-                                        set.getTree(false).split(splitter).getPlus(),\n-                                        new BSPTree(Boolean.FALSE), null));\n+            new PolygonsSet(new BSPTree<Euclidean2D>(splitter,\n+                                                     set.getTree(false).split(splitter).getPlus(),\n+                                                     new BSPTree<Euclidean2D>(Boolean.FALSE), null));\n         Assert.assertEquals(Region.Location.OUTSIDE,\n-                            slice.checkPoint(new Point2D(0.1, 0.5)));\n+                            slice.checkPoint(new Vector2D(0.1, 0.5)));\n         Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), 1.0e-10);\n \n     }\n     @Test\n     public void testConcentric() {\n         double h = FastMath.sqrt(3.0) / 2.0;\n-        Point2D[][] vertices1 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.00, 0.1 * h),\n-                new Point2D( 0.05, 0.1 * h),\n-                new Point2D( 0.10, 0.2 * h),\n-                new Point2D( 0.05, 0.3 * h),\n-                new Point2D(-0.05, 0.3 * h),\n-                new Point2D(-0.10, 0.2 * h),\n-                new Point2D(-0.05, 0.1 * h)\n+        Vector2D[][] vertices1 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.00, 0.1 * h),\n+                new Vector2D( 0.05, 0.1 * h),\n+                new Vector2D( 0.10, 0.2 * h),\n+                new Vector2D( 0.05, 0.3 * h),\n+                new Vector2D(-0.05, 0.3 * h),\n+                new Vector2D(-0.10, 0.2 * h),\n+                new Vector2D(-0.05, 0.1 * h)\n             }\n         };\n         PolygonsSet set1 = buildSet(vertices1);\n-        Point2D[][] vertices2 = new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D( 0.00, 0.0 * h),\n-                new Point2D( 0.10, 0.0 * h),\n-                new Point2D( 0.20, 0.2 * h),\n-                new Point2D( 0.10, 0.4 * h),\n-                new Point2D(-0.10, 0.4 * h),\n-                new Point2D(-0.20, 0.2 * h),\n-                new Point2D(-0.10, 0.0 * h)\n+        Vector2D[][] vertices2 = new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D( 0.00, 0.0 * h),\n+                new Vector2D( 0.10, 0.0 * h),\n+                new Vector2D( 0.20, 0.2 * h),\n+                new Vector2D( 0.10, 0.4 * h),\n+                new Vector2D(-0.10, 0.4 * h),\n+                new Vector2D(-0.20, 0.2 * h),\n+                new Vector2D(-0.10, 0.0 * h)\n             }\n         };\n         PolygonsSet set2 = buildSet(vertices2);\n \n     @Test\n     public void testBug20040520() {\n-        BSPTree a0 = new BSPTree(buildSegment(new Point2D(0.85, -0.05),\n-                                              new Point2D(0.90, -0.10)),\n-                                              new BSPTree(Boolean.FALSE),\n-                                              new BSPTree(Boolean.TRUE),\n-                                              null);\n-        BSPTree a1 = new BSPTree(buildSegment(new Point2D(0.85, -0.10),\n-                                              new Point2D(0.90, -0.10)),\n-                                              new BSPTree(Boolean.FALSE), a0, null);\n-        BSPTree a2 = new BSPTree(buildSegment(new Point2D(0.90, -0.05),\n-                                              new Point2D(0.85, -0.05)),\n-                                              new BSPTree(Boolean.FALSE), a1, null);\n-        BSPTree a3 = new BSPTree(buildSegment(new Point2D(0.82, -0.05),\n-                                              new Point2D(0.82, -0.08)),\n-                                              new BSPTree(Boolean.FALSE),\n-                                              new BSPTree(Boolean.TRUE),\n-                                              null);\n-        BSPTree a4 = new BSPTree(buildHalfLine(new Point2D(0.85, -0.05),\n-                                               new Point2D(0.80, -0.05),\n-                                               false),\n-                                               new BSPTree(Boolean.FALSE), a3, null);\n-        BSPTree a5 = new BSPTree(buildSegment(new Point2D(0.82, -0.08),\n-                                              new Point2D(0.82, -0.18)),\n-                                              new BSPTree(Boolean.FALSE),\n-                                              new BSPTree(Boolean.TRUE),\n-                                              null);\n-        BSPTree a6 = new BSPTree(buildHalfLine(new Point2D(0.82, -0.18),\n-                                               new Point2D(0.85, -0.15),\n-                                               true),\n-                                               new BSPTree(Boolean.FALSE), a5, null);\n-        BSPTree a7 = new BSPTree(buildHalfLine(new Point2D(0.85, -0.05),\n-                                               new Point2D(0.82, -0.08),\n-                                               false),\n-                                               a4, a6, null);\n-        BSPTree a8 = new BSPTree(buildLine(new Point2D(0.85, -0.25),\n-                                           new Point2D(0.85,  0.05)),\n-                                           a2, a7, null);\n-        BSPTree a9 = new BSPTree(buildLine(new Point2D(0.90,  0.05),\n-                                           new Point2D(0.90, -0.50)),\n-                                           a8, new BSPTree(Boolean.FALSE), null);\n-\n-        BSPTree b0 = new BSPTree(buildSegment(new Point2D(0.92, -0.12),\n-                                              new Point2D(0.92, -0.08)),\n-                                              new BSPTree(Boolean.FALSE), new BSPTree(Boolean.TRUE),\n-                                              null);\n-        BSPTree b1 = new BSPTree(buildHalfLine(new Point2D(0.92, -0.08),\n-                                               new Point2D(0.90, -0.10),\n-                                               true),\n-                                               new BSPTree(Boolean.FALSE), b0, null);\n-        BSPTree b2 = new BSPTree(buildSegment(new Point2D(0.92, -0.18),\n-                                              new Point2D(0.92, -0.12)),\n-                                              new BSPTree(Boolean.FALSE), new BSPTree(Boolean.TRUE),\n-                                              null);\n-        BSPTree b3 = new BSPTree(buildSegment(new Point2D(0.85, -0.15),\n-                                              new Point2D(0.90, -0.20)),\n-                                              new BSPTree(Boolean.FALSE), b2, null);\n-        BSPTree b4 = new BSPTree(buildSegment(new Point2D(0.95, -0.15),\n-                                              new Point2D(0.85, -0.05)),\n-                                              b1, b3, null);\n-        BSPTree b5 = new BSPTree(buildHalfLine(new Point2D(0.85, -0.05),\n-                                               new Point2D(0.85, -0.25),\n-                                               true),\n-                                               new BSPTree(Boolean.FALSE), b4, null);\n-        BSPTree b6 = new BSPTree(buildLine(new Point2D(0.0, -1.10),\n-                                           new Point2D(1.0, -0.10)),\n-                                           new BSPTree(Boolean.FALSE), b5, null);\n-\n-        PolygonsSet c = (PolygonsSet) Region.union(new PolygonsSet(a9),\n-                                                   new PolygonsSet(b6));\n-\n-        checkPoints(Region.Location.INSIDE, c, new Point2D[] {\n-            new Point2D(0.83, -0.06),\n-            new Point2D(0.83, -0.15),\n-            new Point2D(0.88, -0.15),\n-            new Point2D(0.88, -0.09),\n-            new Point2D(0.88, -0.07),\n-            new Point2D(0.91, -0.18),\n-            new Point2D(0.91, -0.10)\n-        });\n-\n-        checkPoints(Region.Location.OUTSIDE, c, new Point2D[] {\n-            new Point2D(0.80, -0.10),\n-            new Point2D(0.83, -0.50),\n-            new Point2D(0.83, -0.20),\n-            new Point2D(0.83, -0.02),\n-            new Point2D(0.87, -0.50),\n-            new Point2D(0.87, -0.20),\n-            new Point2D(0.87, -0.02),\n-            new Point2D(0.91, -0.20),\n-            new Point2D(0.91, -0.08),\n-            new Point2D(0.93, -0.15)\n+        BSPTree<Euclidean2D> a0 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.05),\n+                                                  new Vector2D(0.90, -0.10)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE),\n+                                                  new BSPTree<Euclidean2D>(Boolean.TRUE),\n+                                                  null);\n+        BSPTree<Euclidean2D> a1 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.10),\n+                                                  new Vector2D(0.90, -0.10)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), a0, null);\n+        BSPTree<Euclidean2D> a2 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.90, -0.05),\n+                                                  new Vector2D(0.85, -0.05)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), a1, null);\n+        BSPTree<Euclidean2D> a3 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82, -0.05),\n+                                                  new Vector2D(0.82, -0.08)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE),\n+                                                  new BSPTree<Euclidean2D>(Boolean.TRUE),\n+                                                  null);\n+        BSPTree<Euclidean2D> a4 =\n+            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05),\n+                                                   new Vector2D(0.80, -0.05),\n+                                                   false),\n+                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), a3, null);\n+        BSPTree<Euclidean2D> a5 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82, -0.08),\n+                                                  new Vector2D(0.82, -0.18)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE),\n+                                                  new BSPTree<Euclidean2D>(Boolean.TRUE),\n+                                                  null);\n+        BSPTree<Euclidean2D> a6 =\n+            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.82, -0.18),\n+                                                   new Vector2D(0.85, -0.15),\n+                                                   true),\n+                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), a5, null);\n+        BSPTree<Euclidean2D> a7 =\n+            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05),\n+                                                   new Vector2D(0.82, -0.08),\n+                                                   false),\n+                                                   a4, a6, null);\n+        BSPTree<Euclidean2D> a8 =\n+            new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.85, -0.25),\n+                                               new Vector2D(0.85,  0.05)),\n+                                               a2, a7, null);\n+        BSPTree<Euclidean2D> a9 =\n+            new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.90,  0.05),\n+                                               new Vector2D(0.90, -0.50)),\n+                                               a8, new BSPTree<Euclidean2D>(Boolean.FALSE), null);\n+\n+        BSPTree<Euclidean2D> b0 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92, -0.12),\n+                                                  new Vector2D(0.92, -0.08)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE),\n+                                                  null);\n+        BSPTree<Euclidean2D> b1 =\n+            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.92, -0.08),\n+                                                   new Vector2D(0.90, -0.10),\n+                                                   true),\n+                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), b0, null);\n+        BSPTree<Euclidean2D> b2 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92, -0.18),\n+                                                  new Vector2D(0.92, -0.12)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE),\n+                                                  null);\n+        BSPTree<Euclidean2D> b3 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.15),\n+                                                  new Vector2D(0.90, -0.20)),\n+                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), b2, null);\n+        BSPTree<Euclidean2D> b4 =\n+            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.95, -0.15),\n+                                                  new Vector2D(0.85, -0.05)),\n+                                                  b1, b3, null);\n+        BSPTree<Euclidean2D> b5 =\n+            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05),\n+                                                   new Vector2D(0.85, -0.25),\n+                                                   true),\n+                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), b4, null);\n+        BSPTree<Euclidean2D> b6 =\n+            new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.0, -1.10),\n+                                               new Vector2D(1.0, -0.10)),\n+                                               new BSPTree<Euclidean2D>(Boolean.FALSE), b5, null);\n+\n+        PolygonsSet c =\n+            (PolygonsSet) new RegionFactory<Euclidean2D>().union(new PolygonsSet(a9),\n+                                                                 new PolygonsSet(b6));\n+\n+        checkPoints(Region.Location.INSIDE, c, new Vector2D[] {\n+            new Vector2D(0.83, -0.06),\n+            new Vector2D(0.83, -0.15),\n+            new Vector2D(0.88, -0.15),\n+            new Vector2D(0.88, -0.09),\n+            new Vector2D(0.88, -0.07),\n+            new Vector2D(0.91, -0.18),\n+            new Vector2D(0.91, -0.10)\n+        });\n+\n+        checkPoints(Region.Location.OUTSIDE, c, new Vector2D[] {\n+            new Vector2D(0.80, -0.10),\n+            new Vector2D(0.83, -0.50),\n+            new Vector2D(0.83, -0.20),\n+            new Vector2D(0.83, -0.02),\n+            new Vector2D(0.87, -0.50),\n+            new Vector2D(0.87, -0.20),\n+            new Vector2D(0.87, -0.02),\n+            new Vector2D(0.91, -0.20),\n+            new Vector2D(0.91, -0.08),\n+            new Vector2D(0.93, -0.15)\n         });\n \n         checkVertices(c.getVertices(),\n-                      new Point2D[][] {\n-            new Point2D[] {\n-                new Point2D(0.85, -0.15),\n-                new Point2D(0.90, -0.20),\n-                new Point2D(0.92, -0.18),\n-                new Point2D(0.92, -0.08),\n-                new Point2D(0.90, -0.10),\n-                new Point2D(0.90, -0.05),\n-                new Point2D(0.82, -0.05),\n-                new Point2D(0.82, -0.18),\n+                      new Vector2D[][] {\n+            new Vector2D[] {\n+                new Vector2D(0.85, -0.15),\n+                new Vector2D(0.90, -0.20),\n+                new Vector2D(0.92, -0.18),\n+                new Vector2D(0.92, -0.08),\n+                new Vector2D(0.90, -0.10),\n+                new Vector2D(0.90, -0.05),\n+                new Vector2D(0.82, -0.05),\n+                new Vector2D(0.82, -0.18),\n             }\n         });\n \n     public void testBug20041003() {\n \n         Line[] l = {\n-            new Line(new Point2D(0.0, 0.625000007541172),\n-                     new Point2D(1.0, 0.625000007541172)),\n-                     new Line(new Point2D(-0.19204433621902645, 0.0),\n-                              new Point2D(-0.19204433621902645, 1.0)),\n-                              new Line(new Point2D(-0.40303524786887,  0.4248364535319128),\n-                                       new Point2D(-1.12851149797877, -0.2634107480798909)),\n-                                       new Line(new Point2D(0.0, 2.0),\n-                                                new Point2D(1.0, 2.0))\n-        };\n-\n-        BSPTree node1 =\n-            new BSPTree(new SubHyperplane(l[0],\n+            new Line(new Vector2D(0.0, 0.625000007541172),\n+                     new Vector2D(1.0, 0.625000007541172)),\n+                     new Line(new Vector2D(-0.19204433621902645, 0.0),\n+                              new Vector2D(-0.19204433621902645, 1.0)),\n+                              new Line(new Vector2D(-0.40303524786887,  0.4248364535319128),\n+                                       new Vector2D(-1.12851149797877, -0.2634107480798909)),\n+                                       new Line(new Vector2D(0.0, 2.0),\n+                                                new Vector2D(1.0, 2.0))\n+        };\n+\n+        BSPTree<Euclidean2D> node1 =\n+            new BSPTree<Euclidean2D>(new SubLine(l[0],\n                                           new IntervalsSet(intersectionAbscissa(l[0], l[1]),\n                                                            intersectionAbscissa(l[0], l[2]))),\n-                                                           new BSPTree(Boolean.TRUE), new BSPTree(Boolean.FALSE),\n+                                                           new BSPTree<Euclidean2D>(Boolean.TRUE), new BSPTree<Euclidean2D>(Boolean.FALSE),\n                                                            null);\n-        BSPTree node2 =\n-            new BSPTree(new SubHyperplane(l[1],\n+        BSPTree<Euclidean2D> node2 =\n+            new BSPTree<Euclidean2D>(new SubLine(l[1],\n                                           new IntervalsSet(intersectionAbscissa(l[1], l[2]),\n                                                            intersectionAbscissa(l[1], l[3]))),\n-                                                           node1, new BSPTree(Boolean.FALSE), null);\n-        BSPTree node3 =\n-            new BSPTree(new SubHyperplane(l[2],\n+                                                           node1, new BSPTree<Euclidean2D>(Boolean.FALSE), null);\n+        BSPTree<Euclidean2D> node3 =\n+            new BSPTree<Euclidean2D>(new SubLine(l[2],\n                                           new IntervalsSet(intersectionAbscissa(l[2], l[3]),\n                                                            Double.POSITIVE_INFINITY)),\n-                                                           node2, new BSPTree(Boolean.FALSE), null);\n-        BSPTree node4 =\n-            new BSPTree(new SubHyperplane(l[3]),\n-                        node3, new BSPTree(Boolean.FALSE), null);\n+                                                           node2, new BSPTree<Euclidean2D>(Boolean.FALSE), null);\n+        BSPTree<Euclidean2D> node4 =\n+            new BSPTree<Euclidean2D>(l[3].wholeHyperplane(), node3, new BSPTree<Euclidean2D>(Boolean.FALSE), null);\n \n         PolygonsSet set = new PolygonsSet(node4);\n         Assert.assertEquals(0, set.getVertices().length);\n \n     }\n \n-    private PolygonsSet buildSet(Point2D[][] vertices) {\n-        ArrayList<SubHyperplane> edges = new ArrayList<SubHyperplane>();\n+    private PolygonsSet buildSet(Vector2D[][] vertices) {\n+        ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<SubHyperplane<Euclidean2D>>();\n         for (int i = 0; i < vertices.length; ++i) {\n             int l = vertices[i].length;\n             for (int j = 0; j < l; ++j) {\n         return new PolygonsSet(edges);\n     }\n \n-    private SubHyperplane buildLine(Point2D start, Point2D end) {\n-        return new SubHyperplane(new Line(start, end));\n+    private SubHyperplane<Euclidean2D> buildLine(Vector2D start, Vector2D end) {\n+        return new Line(start, end).wholeHyperplane();\n     }\n \n     private double intersectionAbscissa(Line l0, Line l1) {\n-        Point2D p = (Point2D) l0.intersection(l1);\n-        return ((Point1D) l0.toSubSpace(p)).getAbscissa();\n-    }\n-\n-    private SubHyperplane buildHalfLine(Point2D start, Point2D end,\n-                                        boolean startIsVirtual) {\n+        Vector2D p = (Vector2D) l0.intersection(l1);\n+        return ((Vector1D) l0.toSubSpace(p)).getX();\n+    }\n+\n+    private SubHyperplane<Euclidean2D> buildHalfLine(Vector2D start, Vector2D end,\n+                                                     boolean startIsVirtual) {\n         Line   line  = new Line(start, end);\n         double lower = startIsVirtual\n         ? Double.NEGATIVE_INFINITY\n-        : ((Point1D) line.toSubSpace(start)).getAbscissa();\n+        : ((Vector1D) line.toSubSpace(start)).getX();\n         double upper = startIsVirtual\n-        ? ((Point1D) line.toSubSpace(end)).getAbscissa()\n+        ? ((Vector1D) line.toSubSpace(end)).getX()\n         : Double.POSITIVE_INFINITY;\n-        return new SubHyperplane(line, new IntervalsSet(lower, upper));\n-    }\n-\n-    private SubHyperplane buildSegment(Point2D start, Point2D end) {\n+        return new SubLine(line, new IntervalsSet(lower, upper));\n+    }\n+\n+    private SubHyperplane<Euclidean2D> buildSegment(Vector2D start, Vector2D end) {\n         Line   line  = new Line(start, end);\n-        double lower = ((Point1D) line.toSubSpace(start)).getAbscissa();\n-        double upper = ((Point1D) line.toSubSpace(end)).getAbscissa();\n-        return new SubHyperplane(line, new IntervalsSet(lower, upper));\n+        double lower = ((Vector1D) line.toSubSpace(start)).getX();\n+        double upper = ((Vector1D) line.toSubSpace(end)).getX();\n+        return new SubLine(line, new IntervalsSet(lower, upper));\n     }\n \n     private void checkPoints(Region.Location expected, PolygonsSet set,\n-                             Point2D[] points) {\n+                             Vector2D[] points) {\n         for (int i = 0; i < points.length; ++i) {\n             Assert.assertEquals(expected, set.checkPoint(points[i]));\n         }\n     }\n \n-    private boolean checkInSegment(Point2D p,\n-                                   Point2D p1, Point2D p2,\n+    private boolean checkInSegment(Vector2D p,\n+                                   Vector2D p1, Vector2D p2,\n                                    double tolerance) {\n         Line line = new Line(p1, p2);\n         if (line.getOffset(p) < tolerance) {\n-            double x  = ((Point1D) line.toSubSpace(p)).getAbscissa();\n-            double x1 = ((Point1D) line.toSubSpace(p1)).getAbscissa();\n-            double x2 = ((Point1D) line.toSubSpace(p2)).getAbscissa();\n+            double x  = ((Vector1D) line.toSubSpace(p)).getX();\n+            double x1 = ((Vector1D) line.toSubSpace(p1)).getX();\n+            double x2 = ((Vector1D) line.toSubSpace(p2)).getX();\n             return (((x - x1) * (x - x2) <= 0.0)\n                     || (p1.distance(p) < tolerance)\n                     || (p2.distance(p) < tolerance));\n         }\n     }\n \n-    private void checkVertices(Point2D[][] rebuiltVertices,\n-                               Point2D[][] vertices) {\n+    private void checkVertices(Vector2D[][] rebuiltVertices,\n+                               Vector2D[][] vertices) {\n \n         // each rebuilt vertex should be in a segment joining two original vertices\n         for (int i = 0; i < rebuiltVertices.length; ++i) {\n             for (int j = 0; j < rebuiltVertices[i].length; ++j) {\n                 boolean inSegment = false;\n-                Point2D p = rebuiltVertices[i][j];\n+                Vector2D p = rebuiltVertices[i][j];\n                 for (int k = 0; k < vertices.length; ++k) {\n-                    Point2D[] loop = vertices[k];\n+                    Vector2D[] loop = vertices[k];\n                     int length = loop.length;\n                     for (int l = 0; (! inSegment) && (l < length); ++l) {\n                         inSegment = checkInSegment(p, loop[l], loop[(l + 1) % length], 1.0e-10);", "timestamp": 1307124492, "metainfo": ""}