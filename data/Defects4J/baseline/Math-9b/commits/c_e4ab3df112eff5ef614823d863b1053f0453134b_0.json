{"sha": "e4ab3df112eff5ef614823d863b1053f0453134b", "log": "Refactored integration API for consistency with solvers API. Now the main convergence parameters are set in the constructor and remain fixed.  JIRA: MATH-501   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n \n             // check convergence\n             if ((iterations.getCount() + 1 >= minimalIterationCount) && (delta <= limit)) {\n-                setResult(t);\n-                return result;\n+                return t;\n             }\n \n             // prepare next iteration\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n                 final double delta  = FastMath.abs(s - olds);\n                 final double rLimit = relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n-                    setResult(s);\n-                    return result;\n+                    return s;\n                 }\n             }\n             olds = s;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n \n         TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n         if (minimalIterationCount == 1) {\n-            final double s = (4 * qtrap.stage(this, 1) - qtrap.stage(this, 0)) / 3.0;\n-            setResult(s);\n-            return result;\n+            return (4 * qtrap.stage(this, 1) - qtrap.stage(this, 0)) / 3.0;\n         }\n+\n         // Simpson's rule requires at least two trapezoid stages.\n         double olds = 0;\n         double oldt = qtrap.stage(this, 0);\n                 final double rLimit =\n                     relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n-                    setResult(s);\n-                    return result;\n+                    return s;\n                 }\n             }\n             olds = s;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n                 final double rLimit =\n                     relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n-                    setResult(t);\n-                    return result;\n+                    return t;\n                 }\n             }\n             oldt = t;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n                MathIllegalArgumentException, NullArgumentException;\n \n     /**\n-     * Get the result of the last run of the integrator.\n-     *\n-     * @return the last result\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed\n-     */\n-    double getResult() throws IllegalStateException;\n-\n-    /**\n      * Get the number of function evaluations of the last run of the integrator.\n      * @return number of function evaluations\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed\n      */\n-    int getEvaluations() throws IllegalStateException;\n+    int getEvaluations();\n \n     /**\n      * Get the number of iterations of the last run of the integrator.\n      * @return number of iterations\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed\n      */\n-    int getIterations() throws IllegalStateException;\n+    int getIterations();\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.util.MathUtils;\n \n \n     /** Upper bound for the interval. */\n     protected double max;\n-\n-    /** indicates whether an integral has been computed */\n-    protected boolean resultComputed = false;\n-\n-    /** the last computed integral */\n-    protected double result;\n \n     /**\n      * Construct an integrator with given accuracies and iteration counts.\n     }\n \n     /** {@inheritDoc} */\n-    public double getResult() throws IllegalStateException {\n-        if (resultComputed) {\n-            return result;\n-        } else {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() throws IllegalStateException {\n-        if (resultComputed) {\n-            return evaluations.getCount();\n-        } else {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() throws IllegalStateException {\n-        if (resultComputed) {\n-            return iterations.getCount();\n-        } else {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n-        }\n-    }\n-\n-    /**\n-     * Convenience function for implementations.\n-     *\n-     * @param newResult the result to set\n-     * @param newCount the iteration count to set\n-     */\n-    protected final void setResult(final double newResult) {\n-        result         = newResult;\n-        resultComputed = true;\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations.getCount();\n     }\n \n     /**\n         evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n         iterations.resetCount();\n-        resultComputed = false;\n \n     }\n ", "timestamp": 1314201796, "metainfo": ""}