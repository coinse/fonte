{"sha": "ee555fecaf3a86dc55468b27c28cc28c2983e87b", "log": "fixed numerous checkstyle warnings (javadoc, trailing spaces, tabs, parenthesis, declaration order ...)  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n      * @return the value.\n      * @throws FunctionEvaluationException if the function evaluation fails.\n      */\n-    public double value(double x, double y)\n+    double value(double x, double y)\n         throws FunctionEvaluationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n      * @return the value.\n      * @throws FunctionEvaluationException if the function evaluation fails.\n      */\n-    public double value(double x, double y, double z)\n+    double value(double x, double y, double z)\n         throws FunctionEvaluationException;\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.exception.NonMonotonousSequenceException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.util.MathUtils;\n \n      * every grid point.\n      * @throws DimensionMismatchException if the various arrays do not contain\n      * the expected number of elements.\n-     * @throws NonMonotonousSequenceException if {@code x} or {@code y} are not strictly\n-     * increasing.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} or {@code y} are not strictly increasing.\n      * @throws NoDataException if any of the arrays has zero length.\n      */\n     public BicubicSplineInterpolatingFunction(double[] x,\n  */\n class BicubicSplineFunction\n     implements BivariateRealFunction {\n+\n+    /** Number of points. */\n     private static final short N = 4;\n+\n     /** Coefficients */\n-    private final double[][] a = new double[N][N];\n-    /** Partial derivatives */\n-    BivariateRealFunction partialDerivativeX = null;\n-    BivariateRealFunction partialDerivativeY = null;\n-    BivariateRealFunction partialDerivativeXX = null;\n-    BivariateRealFunction partialDerivativeYY = null;\n-    BivariateRealFunction partialDerivativeXY = null;\n-\n-    /**\n+    private final double[][] a;\n+\n+    /** First partial derivative along x. */\n+    private BivariateRealFunction partialDerivativeX;\n+\n+    /** First partial derivative along y. */\n+    private BivariateRealFunction partialDerivativeY;\n+\n+    /** Second partial derivative along x. */\n+    private BivariateRealFunction partialDerivativeXX;\n+\n+    /** Second partial derivative along y. */\n+    private BivariateRealFunction partialDerivativeYY;\n+\n+    /** Second crossed partial derivative. */\n+    private BivariateRealFunction partialDerivativeXY;\n+\n+    /**\n+     * Simple constructor.\n      * @param a Spline coefficients\n      */\n-    public BicubicSplineFunction(double[] aV) {\n+    public BicubicSplineFunction(double[] a) {\n+        this.a = new double[N][N];\n         for (int i = 0; i < N; i++) {\n             for (int j = 0; j < N; j++) {\n-                a[i][j] = aV[i + N * j];\n+                this.a[i][j] = a[i + N * j];\n             }\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n \n /**\n  * Implements a linear function for interpolation of real univariate functions.\n+ * @version $Revision$ $Date$\n  */\n public class LinearInterpolator implements UnivariateRealInterpolator {\n     /**\n      * @return a function which interpolates the data set\n      * @throws DimensionMismatchException if {@code x} and {@code y}\n      * have different sizes.\n-     * @throws NonMonotonousSequenceException if {@code x} is not sorted in\n-     * strict increasing order.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strict increasing order.\n      * @throws NumberIsTooSmallException if the size of {@code x} is smaller\n      * than 2.\n      */\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathUtils.Order;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n \n             throw new DimensionMismatchException(xval.length, zval.length);\n         }\n \n-        MathUtils.checkOrder(xval, 1, true);\n-        MathUtils.checkOrder(yval, 1, true);\n+        MathUtils.checkOrder(xval, Order.Direction.INCREASING, true);\n+        MathUtils.checkOrder(yval, Order.Direction.INCREASING, true);\n \n         final int xLen = xval.length;\n         final int yLen = yval.length;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n  */\n public class SmoothingPolynomialBicubicSplineInterpolator\n     extends BicubicSplineInterpolator {\n+\n+    /** Fitter for x. */\n     private final PolynomialFitter xFitter;\n+\n+    /** Fitter for y. */\n     private final PolynomialFitter yFitter;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n      * @return a function which interpolates the data set\n      * @throws DimensionMismatchException if {@code x} and {@code y}\n      * have different sizes.\n-     * @throws NonMonotonousSequenceException if {@code x} is not sorted in\n-     * strict increasing order.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strict increasing order.\n      * @throws NumberIsTooSmallException if the size of {@code x} is smaller\n      * than 3.\n      */\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n      * to x on every grid point.\n      * @param dFdY Values of the partial derivative of function with respect\n      * to y on every grid point.\n+     * @param dFdZ Values of the partial derivative of function with respect\n+     * to z on every grid point.\n      * @param d2FdXdY Values of the cross partial derivative of function on\n      * every grid point.\n      * @param d2FdXdZ Values of the cross partial derivative of function on\n         final int yLen = y.length;\n         final int zLen = z.length;\n \n-        if (xLen == 0 || yLen == 0 || z.length == 0\n-            || f.length == 0 || f[0].length == 0) {\n+        if (xLen == 0 || yLen == 0 || z.length == 0 || f.length == 0 || f[0].length == 0) {\n             throw new NoDataException();\n         }\n         if (xLen != f.length) {\n  */\n class TricubicSplineFunction\n     implements TrivariateRealFunction {\n+    /** Number of points. */\n     private static final short N = 4;\n-    private static final short N2 = N * N;\n     /** Coefficients */\n     private final double[][][] a = new double[N][N][N];\n \n         for (int i = 0; i < N; i++) {\n             for (int j = 0; j < N; j++) {\n                 for (int k = 0; k < N; k++) {\n-                    a[i][j][k] = aV[i + N * j + N2 * k];\n+                    a[i][j][k] = aV[i + N * (j + N * k)];\n                 }\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n      * @param fval the values of the interpolation points on all the grid knots:\n      * {@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}.\n      * @return a function that interpolates the data set.\n-     * @throws NoDataException if any of the arrays has zero length.\n-     * @throws DimensionMismatchException if the array lengths are inconsistent.\n+     * @throws org.apache.commons.math.exception.NoDataException if any of the arrays has zero length.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException if the array lengths are inconsistent.\n      * @throws MathException if arguments violate assumptions made by the\n      *         interpolation algorithm.\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n-    \n+\n     /**\n      * RandomData instance used to generate samples from the distribution\n      * @since 2.2\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n      * Arguments used to build the message.\n      */\n     private final Object[] arguments;\n-    \n+\n     /**\n      * @param specific Message pattern providing the specific context of\n      * the error.\n \n         return sb.toString();\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n      *\n      * @param specific Localizable pattern.\n      * @param general Localizable pattern.\n-     * @param arguments Arguments. The first element must be the requested\n-     * value that raised the exception.\n+     * @param wrong wrong number\n+     * @param arguments Arguments.\n      */\n     protected MathIllegalNumberException(Localizable specific,\n                                          Localizable general,\n      * Construct an exception.\n      *\n      * @param general Localizable pattern.\n-     * @param arguments Arguments. The first element must be the requested\n-     * value that raised the exception.\n+     * @param wrong wrong number\n+     * @param arguments Arguments.\n      */\n     protected MathIllegalNumberException(Localizable general,\n                                          Number wrong,\n--- a/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n      *\n      * @param wrong Value that is larger than the maximum.\n      * @param max maximum.\n+     * @param boundIsAllowed if true the maximum is included in the allowed range.\n      */\n     public NumberIsTooLargeException(Number wrong,\n                                      Number max,\n      * @param specific Specific contexte pattern .\n      * @param wrong Value that is larger than the maximum.\n      * @param max maximum.\n+     * @param boundIsAllowed if true the maximum is included in the allowed range.\n      */\n     public NumberIsTooLargeException(Localizable specific,\n                                      Number wrong,\n                                      Number max,\n                                      boolean boundIsAllowed) {\n         super(specific,\n-              (boundIsAllowed ?\n-               LocalizedFormats.NUMBER_TOO_LARGE :\n-               LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED),\n+              boundIsAllowed ?\n+              LocalizedFormats.NUMBER_TOO_LARGE :\n+              LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED,\n               wrong, max);\n \n         this.max = max;\n--- a/src/main/java/org/apache/commons/math/exception/NumberIsTooSmallException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooSmallException.java\n                                      Number min,\n                                      boolean boundIsAllowed) {\n         super(specific,\n-              (boundIsAllowed ?\n-               LocalizedFormats.NUMBER_TOO_SMALL :\n-               LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED),\n+              boundIsAllowed ?\n+              LocalizedFormats.NUMBER_TOO_SMALL :\n+              LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED,\n               wrong, min);\n \n         this.min = min;\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n             dim = getDimension();\n             current = new EntryImpl();\n             next = new EntryImpl();\n-            if(next.getValue() == 0){\n-            \tadvance(next);\n+            if (next.getValue() == 0) {\n+                advance(next);\n             }\n         }\n \n \n         /** {@inheritDoc} */\n         public Entry next() {\n-        \tint index = next.getIndex();\n-        \tif(index < 0){\n-        \t\tthrow new NoSuchElementException();\n-        \t}\n-        \tcurrent.setIndex(index);\n-        \tadvance(next);\n-        \treturn current;\n+            int index = next.getIndex();\n+            if (index < 0) {\n+                throw new NoSuchElementException();\n+            }\n+            current.setIndex(index);\n+            advance(next);\n+            return current;\n         }\n \n         /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/ode/ExtendedFirstOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/ExtendedFirstOrderDifferentialEquations.java\n      */\n     int getMainSetDimension();\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.events.EventException;\n \n     /** Get the current value of the step start time t<sub>i</sub>.\n      * <p>This method can be called during integration (typically by\n-     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * the object implementing the {@link org.apache.commons.math.ode.FirstOrderDifferentialEquations\n      * differential equations} problem) if the value of the current step that\n      * is attempted is needed.</p>\n      * <p>The result is undefined if the method is called outside of\n \n     /** Get the current signed value of the integration stepsize.\n      * <p>This method can be called during integration (typically by\n-     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * the object implementing the {@link org.apache.commons.math.ode.FirstOrderDifferentialEquations\n      * differential equations} problem) if the signed value of the current stepsize\n      * that is tried is needed.</p>\n      * <p>The result is undefined if the method is called outside of\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n     /** Allowed relative vectorial error. */\n     protected final double[] vecRelativeTolerance;\n \n+    /** Main set dimension. */\n+    protected int mainSetDimension;\n+\n     /** User supplied initial step. */\n     private double initialStep;\n \n \n     /** Maximal step. */\n     private final double maxStep;\n-\n-    /** Main set dimension. */\n-    protected int mainSetDimension;\n \n   /** Build an integrator with the given stepsize bounds.\n    * The default step handler does nothing.\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n  * Commons-Math. Users of the API are advised to base their code on\n  * {@link MultivariateRealOptimizer} or on\n  * {@link DifferentiableMultivariateRealOptimizer}.\n+ * @param <T> the type of the objective function to be optimized\n  *\n  * @see MultivariateRealOptimizer\n  * @see DifferentiableMultivariateRealOptimizer\n \n     /**\n      * Optimize an objective function.\n-     *     \n+     *\n      * @param f Objective function.\n      * @param goalType Type of optimization goal: either {@link GoalType#MAXIMIZE}\n      * or {@link GoalType#MINIMIZE}.\n--- a/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n      * @param value value of an objective function at the point\n      */\n     public RealPointValuePair(final double[] point, final double value) {\n-        this.point = (point == null ? null : point.clone());\n+        this.point = (point == null) ? null : point.clone();\n         this.value  = value;\n     }\n \n      */\n     public RealPointValuePair(final double[] point, final double value,\n                               final boolean copyArray) {\n-        this.point = (copyArray ?\n-                      (point == null ? null : point.clone()) :\n-                      point);\n+        this.point = copyArray ?\n+                     ((point == null) ? null : point.clone()) :\n+                     point;\n         this.value  = value;\n     }\n \n      * @return a copy of the stored point\n      */\n     public double[] getPoint() {\n-        return (point == null ? null : point.clone());\n+        return (point == null) ? null : point.clone();\n     }\n \n     /** Get a reference to the point.\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n      * @param value value of an objective function at the point\n      */\n     public VectorialPointValuePair(final double[] point, final double[] value) {\n-        this.point = (point == null ? null : point.clone());\n-        this.value = (value == null ? null : value.clone());\n+        this.point = (point == null) ? null : point.clone();\n+        this.value = (value == null) ? null : value.clone();\n     }\n \n     /** Build a point/objective function value pair.\n      */\n     public VectorialPointValuePair(final double[] point, final double[] value,\n                                    final boolean copyArray) {\n-        this.point = (copyArray ?\n-                      (point == null ? null : point.clone()) :\n-                      point);\n-        this.value = (copyArray ?\n-                      (value == null ? null : value.clone()) :\n-                      value);\n+        this.point = copyArray ?\n+                      ((point == null) ? null : point.clone()) :\n+                      point;\n+        this.value = copyArray ?\n+                      ((value == null) ? null : value.clone()) :\n+                      value;\n     }\n \n     /** Get the point.\n      * @return a copy of the stored point\n      */\n     public double[] getPoint() {\n-        return (point == null ? null : point.clone());\n+        return (point == null) ? null : point.clone();\n     }\n \n     /** Get a reference to the point.\n      * @return a copy of the stored value of the objective function\n      */\n     public double[] getValue() {\n-        return (value == null ? null : value.clone());\n+        return (value == null) ? null : value.clone();\n     }\n \n     /** Get a reference to the value of the objective function.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n         throws FunctionEvaluationException, OptimizationException,\n         IllegalArgumentException {\n \n-        if (startConfiguration == null\n-            || startConfiguration.length != startPoint.length) {\n+        if ((startConfiguration == null) ||\n+            (startConfiguration.length != startPoint.length)) {\n             // no initial configuration has been set up for simplex\n             // build a default one from a unit hypercube\n             final double[] unit = new double[startPoint.length];\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar\n public abstract class AbstractScalarDifferentiableOptimizer\n     extends BaseAbstractScalarOptimizer<DifferentiableMultivariateRealFunction>\n     implements DifferentiableMultivariateRealOptimizer {\n-    /** Number of gradient evaluations. */\n-    private int gradientEvaluations;\n-    /** Objective function gradient. */\n-    private MultivariateVectorialFunction gradient;\n \n     /** Convergence checker.\n      * @deprecated in 2.2 (to be removed in 3.0). Please use the accessor\n      */\n     protected double[] point;\n \n+    /** Number of gradient evaluations. */\n+    private int gradientEvaluations;\n+\n+    /** Objective function gradient. */\n+    private MultivariateVectorialFunction gradient;\n+\n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleScalarValueChecker},\n+     * The convergence check is set to a {@link org.apache.commons.math.optimization.SimpleScalarValueChecker},\n      * the allowed number of iterations and evaluations are set to their\n      * default values.\n      */\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarOptimizer.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n import org.apache.commons.math.optimization.RealConvergenceChecker;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n /**\n  * Base class for implementing optimizers for multivariate (not necessarily\n     implements MultivariateRealOptimizer {\n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleScalarValueChecker},\n+     * The convergence check is set to a {@link org.apache.commons.math.optimization.SimpleScalarValueChecker},\n      * the allowed number of iterations and evaluations are set to their\n      * default values.\n      */\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n      * during QR decomposition, it is considered to be a zero vector and hence the\n      * rank of the matrix is reduced.\n      * </p>\n-     * @param qrRankingThreshold threshold for QR ranking\n-     */\n-    public void setQRRankingThreshold(final double qrRankingThreshold) {\n-        this.qrRankingThreshold = qrRankingThreshold;\n+     * @param threshold threshold for QR ranking\n+     */\n+    public void setQRRankingThreshold(final double threshold) {\n+        this.qrRankingThreshold = threshold;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n     public PowellOptimizer(double lineSearchTolerance) {\n         line = new LineSearch(lineSearchTolerance);\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     protected RealPointValuePair doOptimize()\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n-        \n+\n         final double[][] direc = new double[n][n];\n         for (int i = 0; i < n; i++) {\n             direc[i][i] = 1;\n         }\n-        \n+\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n         while (true) {\n             incrementIterationsCounter();\n-            \n+\n             double fX = fVal;\n             double fX2 = 0;\n             double delta = 0;\n             int bigInd = 0;\n             double alphaMin = 0;\n-            \n+\n             double[] direc1 = new double[n];\n             for (int i = 0; i < n; i++) {\n                 direc1 = direc[i];\n-            \n+\n                 fX2 = fVal;\n-            \n+\n                 line.search(x, direc1);\n                 fVal = line.getValueAtOptimum();\n                 alphaMin = line.getOptimum();\n                 setNewPointAndDirection(x, direc1, alphaMin);\n-       \n+\n                 if ((fX2 - fVal) > delta) {\n                     delta = fX2 - fVal;\n                     bigInd = i;\n             final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n             final RealPointValuePair current = new RealPointValuePair(x, fVal);\n             if (getConvergenceChecker().converged(getIterations(), previous, current)) {\n-                switch (goal) {\n-                case MINIMIZE:\n-                    return (fVal < fX ? current : previous);\n-                case MAXIMIZE:\n-                    return (fVal > fX ? current : previous);\n+                if (goal == GoalType.MINIMIZE) {\n+                    return (fVal < fX) ? current : previous;\n+                } else {\n+                    return (fVal > fX) ? current : previous;\n                 }\n             }\n-            \n+\n             double[] x2 = new double[n];\n             for (int i = 0; i < n; i++) {\n                 direc1[i] = x[i] - x1[i];\n                     fVal = line.getValueAtOptimum();\n                     alphaMin = line.getOptimum();\n                     setNewPointAndDirection(x, direc1, alphaMin);\n-                    \n+\n                     final int lastInd = n - 1;\n                     direc[bigInd] = direc[lastInd];\n                     direc[lastInd] = direc1;\n          *\n          * @param p Starting point.\n          * @param d Search direction.\n+         * @throws OptimizationException if function cannot be evaluated at some test point\n+         * or algorithm fails to converge\n          */\n         public void search(final double[] p,\n                            final double[] d)\n                                          bracket.getHi(),\n                                          bracket.getMid());\n                 valueAtOptimum = f.value(optimum);\n-            } catch (Exception e) {\n+            } catch (FunctionEvaluationException e) {\n+                throw new OptimizationException(e);\n+            } catch (MaxIterationsExceededException e) {\n                 throw new OptimizationException(e);\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n      * classes.\n      *\n      * @return the optimum.\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded.\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function.\n      */\n     protected abstract double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException;\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n  * Provide an interval that brackets a local optimum of a function.\n  * This code is based on a Python implementation (from <em>SciPy</em>,\n  * module {@code optimize.py} v0.5).\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n  */\n public class BracketFinder {\n+    /** Tolerance to avoid division by zero. */\n     private static final double EPS_MIN = 1e-21;\n     /**\n      * Golden section.\n      * @param goal {@link GoalType Goal type}.\n      * @param xA Initial point.\n      * @param xB Initial point.\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded.\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function.\n      */\n     public void search(UnivariateRealFunction func,\n                        GoalType goal,\n         throws MaxIterationsExceededException,\n                FunctionEvaluationException {\n         reset();\n-        final boolean isMinim = (goal == GoalType.MINIMIZE);\n+        final boolean isMinim = goal == GoalType.MINIMIZE;\n \n         double fA = eval(func, xA);\n         double fB = eval(func, xB);\n             if (++iterations > maxIterations) {\n                 throw new MaxIterationsExceededException(maxIterations);\n             }\n-            \n+\n             double tmp1 = (xB - xA) * (fB - fC);\n             double tmp2 = (xB - xC) * (fB - fA);\n \n     }\n \n     /**\n-     * @param func Function.\n+     * @param f Function.\n      * @param x Argument.\n      * @return {@code f(x)}\n+     * @throws FunctionEvaluationException if function cannot be evaluated at x\n      */\n     private double eval(UnivariateRealFunction f,\n                         double x)\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n         setRelativeAccuracy(1e-9);\n     }\n \n-    /**\n-     * Perform the optimization.\n-     *\n-     * @return the optimum.\n-     */\n+    /** {@inheritDoc} */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n         if (t <= 0) {\n             throw new NotStrictlyPositiveException(t);\n         }\n-        double a, b;\n+        double a;\n+        double b;\n         if (lo < hi) {\n             a = lo;\n             b = hi;\n                     r = e;\n                     e = d;\n \n-                    if (p > q * (a - x)\n-                        && p < q * (b - x)\n-                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n+                    if (p > q * (a - x) &&\n+                        p < q * (b - x) &&\n+                        Math.abs(p) < Math.abs(0.5 * q * r)) {\n                         // Parabolic interpolation step.\n                         d = p / q;\n                         u = x + d;\n \n                         // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2\n-                            || b - u < tol2) {\n+                        if (u - a < tol2 || b - u < tol2) {\n                             if (x <= m) {\n                                 d = tol1;\n                             } else {\n                     } else {\n                         b = u;\n                     }\n-                    if (fu <= fw\n-                        || w == x) {\n+                    if (fu <= fw || w == x) {\n                         v = w;\n                         fv = fw;\n                         w = u;\n                         fw = fu;\n-                    } else if (fu <= fv\n-                               || v == x\n-                               || v == w) {\n+                    } else if (fu <= fv || v == x || v == w) {\n                         v = u;\n                         fv = fu;\n                     }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n      * @param k\n      *            size of the permutation (must satisfy 0 < k <= n).\n      * @return the random permutation as an int array\n-     * @throws NumberIsTooLargException if {@code k > n}.\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n      * @throws NotStrictlyPositiveException if {@code k <= 0}.\n      */\n     public int[] nextPermutation(int n, int k) {\n--- a/src/main/java/org/apache/commons/math/util/DummyLocalizable.java\n+++ b/src/main/java/org/apache/commons/math/util/DummyLocalizable.java\n     /** Source string. */\n     private final String source;\n \n-    /** Simple constructor. */\n+    /** Simple constructor.\n+     * @param source source text\n+     */\n     public DummyLocalizable(final String source) {\n         this.source = source;\n     }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n             yInt = SGN_MASK - yInt;\n         }\n \n-        final boolean isEqual = (Math.abs(xInt - yInt) <= maxUlps);\n+        final boolean isEqual = Math.abs(xInt - yInt) <= maxUlps;\n \n         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n     }\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n  *  <li>...</li>\n  *  <li>(1, 3, 2) corresponds to 23</li>\n  * </ul>\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n  */\n public class MultidimensionalCounter implements Iterable<Integer> {\n     /**\n         private int count = -1;\n \n         /**\n-         * Create an iterator (see {@link MultidimensionalCounter#iterator()}.\n+         * Create an iterator\n+         * @see #iterator()\n          */\n         Iterator() {\n             counter[last] = -1;\n                     break;\n                 }\n             }\n-            \n+\n             return ++count;\n         }\n \n          * of the iterator.\n          * @throws IndexOutOfBoundsException if {@code index} is not in the\n          * correct interval (as defined by the length of the argument in the\n-         * {@link MultidimensionalCounter#MultidimensionalCounter(int[])\n+         * {@link #MultidimensionalCounter(int[])\n          * constructor of the enclosing class}).\n          */\n         public int getCount(int dim) {\n             || index >= totalSize) {\n             throw new OutOfRangeException(index, 0, totalSize);\n         }\n-        \n+\n         final int[] indices = new int[dimension];\n-        \n+\n         int count = 0;\n         for (int i = 0; i < last; i++) {\n             int idx = 0;\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n \n         for (int i = 0; i < N; i++) {\n             for (int j = 0; j < N; j++) {\n-                final int index = i + N * j;\n                 coeff[i + N * j] = (i + 1) * (j + 2);\n             }\n         }", "timestamp": 1280527384, "metainfo": ""}