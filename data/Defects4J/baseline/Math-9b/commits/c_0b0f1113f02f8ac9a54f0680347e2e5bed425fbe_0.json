{"sha": "0b0f1113f02f8ac9a54f0680347e2e5bed425fbe", "log": "[MATH-831] Add a RealMatrixFormat class to (de-)serialize a RealMatrix from its string representation.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.math3.exception.MathParseException;\n+import org.apache.commons.math3.util.CompositeFormat;\n+\n+/**\n+ * Formats a {@code nxm} matrix in components list format\n+ * \"[a<sub>0</sub><sub>0</sub>, a<sub>0</sub><sub>1</sub>, ...,\n+ * a<sub>0</sub><sub>m-1</sub>; a<sub>1</sub><sub>0</sub>,\n+ * a<sub>1</sub><sub>1</sub>, ..., a<sub>1</sub><sub>m-1</sub>; ...;\n+ * a<sub>n-1</sub><sub>0</sub>, a<sub>n-1</sub><sub>1</sub>, ...,\n+ * a<sub>n-1</sub><sub>m-1</sub>}\".\n+ * <p>The prefix and suffix \"[\" and \"]\", the row separator \"; \" and the column\n+ * separator \", \" can be replaced by any user-defined strings. The number format\n+ * for components can be configured.</p>\n+ *\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"[1,1,1]\" and\n+ * \" [ 1 , 1 , 1 ] \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * <p><b>Note:</b> the grouping functionality of the used {@link NumberFormat} is\n+ * disabled to prevent problems when parsing (e.g. 1,345.34 would be a valid number\n+ * but conflicts with the default column separator).</p>\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class RealMatrixFormat {\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"[\";\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"]\";\n+    /** The default row separator: \";\". */\n+    private static final String DEFAULT_ROW_SEPARATOR = \"; \";\n+    /** The default column separator: \", \". */\n+    private static final String DEFAULT_COLUMN_SEPARATOR = \", \";\n+    /** Prefix. */\n+    private final String prefix;\n+    /** Suffix. */\n+    private final String suffix;\n+    /** Row separator. */\n+    private final String rowSeparator;\n+    /** Column separator. */\n+    private final String columnSeparator;\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+    /** Trimmed row separator. */\n+    private final String trimmedRowSeparator;\n+    /** Trimmed column separator. */\n+    private final String trimmedColumnSeparator;\n+    /** The format used for components. */\n+    private final NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and row/column separator:\n+     * \"[\", \"]\", \";\" and \", \" and the default number format for components.</p>\n+     */\n+    public RealMatrixFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR,\n+             CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public RealMatrixFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param rowSeparator tow separator to use instead of the default \";\"\n+     * @param columnSeparator column separator to use instead of the default \", \"\n+     */\n+    public RealMatrixFormat(final String prefix, final String suffix,\n+                            final String rowSeparator, final String columnSeparator) {\n+        this(prefix, suffix, rowSeparator, columnSeparator, CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param rowSeparator tow separator to use instead of the default \";\"\n+     * @param columnSeparator column separator to use instead of the default \", \"\n+     * @param format the custom format for components.\n+     */\n+    public RealMatrixFormat(final String prefix, final String suffix,\n+                            final String rowSeparator, final String columnSeparator,\n+                            final NumberFormat format) {\n+        this.prefix            = prefix;\n+        this.suffix            = suffix;\n+        this.rowSeparator      = rowSeparator;\n+        this.columnSeparator   = columnSeparator;\n+        trimmedPrefix          = prefix.trim();\n+        trimmedSuffix          = suffix.trim();\n+        trimmedRowSeparator    = rowSeparator.trim();\n+        trimmedColumnSeparator = columnSeparator.trim();\n+        this.format            = format;\n+        // disable grouping to prevent parsing problems\n+        this.format.setGroupingUsed(false);\n+    }\n+\n+    /**\n+     * Get the set of locales for which real vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available real vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between rows of the matrix.\n+     * @return format separator for rows.\n+     */\n+    public String getRowSeparator() {\n+        return rowSeparator;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator between components.\n+     */\n+    public String getColumnSeparator() {\n+        return columnSeparator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the current locale.\n+     * @return the default real vector format.\n+     */\n+    public static RealMatrixFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the real vector format specific to the given locale.\n+     */\n+    public static RealMatrixFormat getInstance(final Locale locale) {\n+        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This method calls {@link #format(RealMatrix,StringBuffer,FieldPosition)}.\n+     *\n+     * @param m RealMatrix object to format.\n+     * @return a formatted matrix.\n+     */\n+    public String format(RealMatrix m) {\n+        return format(m, new StringBuffer(), new FieldPosition(0)).toString();\n+    }\n+\n+    /**\n+     * Formats a {@link RealMatrix} object to produce a string.\n+     * @param matrix the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(RealMatrix matrix, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format rows\n+        final int rows = matrix.getRowDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < matrix.getColumnDimension(); ++j) {\n+                if (j > 0) {\n+                    toAppendTo.append(columnSeparator);\n+                }\n+                CompositeFormat.formatDouble(matrix.getEntry(i, j), format, toAppendTo, pos);\n+            }\n+            if (i < rows - 1) {\n+                toAppendTo.append(rowSeparator);\n+            }\n+        }\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Parse a string to produce a {@link RealMatrix} object.\n+     *\n+     * @param source String to parse.\n+     * @return the parsed {@link RealMatrix} object.\n+     * @throws MathParseException if the beginning of the specified string\n+     * cannot be parsed.\n+     */\n+    public RealMatrix parse(String source) {\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final RealMatrix result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new MathParseException(source,\n+                                         parsePosition.getErrorIndex(),\n+                                         Array2DRowRealMatrix.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parse a string to produce a {@link RealMatrix} object.\n+     *\n+     * @param source String to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link RealMatrix} object.\n+     */\n+    public RealMatrix parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse components\n+        List<List<Number>> matrix = new ArrayList<List<Number>>();\n+        List<Number> rowComponents = new ArrayList<Number>();\n+        for (boolean loop = true; loop;){\n+\n+            if (!rowComponents.isEmpty()) {\n+                CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+                if (!CompositeFormat.parseFixedstring(source, trimmedColumnSeparator, pos)) {\n+                    if (CompositeFormat.parseFixedstring(source, trimmedRowSeparator, pos)) {\n+                        matrix.add(rowComponents);\n+                        rowComponents = new ArrayList<Number>();\n+                    } else {\n+                        loop = false;\n+                    }\n+                }\n+            }\n+\n+            if (loop) {\n+                CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+                Number component = CompositeFormat.parseNumber(source, format, pos);\n+                if (component != null) {\n+                    rowComponents.add(component);\n+                } else {\n+                    if (rowComponents.isEmpty()) {\n+                        loop = false;\n+                    } else {\n+                        // invalid component\n+                        // set index back to initial, error index should already be set\n+                        pos.setIndex(initialIndex);\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+        }\n+\n+        if (!rowComponents.isEmpty()) {\n+            matrix.add(rowComponents);\n+        }\n+\n+        // parse suffix\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        // do not allow an empty matrix\n+        if (matrix.isEmpty()) {\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // build vector\n+        double[][] data = new double[matrix.size()][];\n+        int row = 0;\n+        for (List<Number> rowList : matrix) {\n+            data[row] = new double[rowList.size()];\n+            for (int i = 0; i < rowList.size(); i++) {\n+                data[row][i] = rowList.get(i).doubleValue();\n+            }\n+            row++;\n+        }\n+        return MatrixUtils.createRealMatrix(data);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/RealMatrixFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+import org.apache.commons.math3.exception.MathParseException;\n+\n+public abstract class RealMatrixFormatAbstractTest {\n+\n+    RealMatrixFormat realMatrixFormat = null;\n+    RealMatrixFormat realMatrixFormatOther = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+\n+    public RealMatrixFormatAbstractTest() {\n+        realMatrixFormat = RealMatrixFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        realMatrixFormatOther = new RealMatrixFormat(\"{\", \"}\", \", \", \" : \", nf);\n+    }\n+\n+    @Test\n+    public void testSimpleNoDecimals() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});\n+        String expected = \"[1, 1, 1; 1, 1, 1]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testSimpleWithDecimals() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.23, 1.43, 1.63}, {2.46, 2.46, 2.66}});\n+        String expected =\n+            \"[1\"    + getDecimalCharacter() +\n+            \"23, 1\" + getDecimalCharacter() +\n+            \"43, 1\" + getDecimalCharacter() +\n+            \"63; 2\" + getDecimalCharacter() +\n+            \"46, 2\" + getDecimalCharacter() +\n+            \"46, 2\" + getDecimalCharacter() +\n+            \"66]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testSimpleWithDecimalsTrunc() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.2323, 1.4343, 1.6333},\n+                                                                    {2.4666, 2.4666, 2.6666}});\n+        String expected =\n+                \"[1\"    + getDecimalCharacter() +\n+                \"23, 1\" + getDecimalCharacter() +\n+                \"43, 1\" + getDecimalCharacter() +\n+                \"63; 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"67]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegativeX() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{-1.2323, 1.4343, 1.6333},\n+                                                                    {2.4666, 2.4666, 2.6666}});\n+        String expected =\n+                \"[-1\"    + getDecimalCharacter() +\n+                \"23, 1\" + getDecimalCharacter() +\n+                \"43, 1\" + getDecimalCharacter() +\n+                \"63; 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"67]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegativeY() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.2323, -1.4343, 1.6333},\n+                                                                    {2.4666, 2.4666, 2.6666}});\n+        String expected =\n+                \"[1\"    + getDecimalCharacter() +\n+                \"23, -1\" + getDecimalCharacter() +\n+                \"43, 1\" + getDecimalCharacter() +\n+                \"63; 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"67]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegativeSecondRow() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1.2323, 1.4343, 1.6333},\n+                                                                    {-2.4666, 2.4666, 2.6666}});\n+        String expected =\n+                \"[1\"    + getDecimalCharacter() +\n+                \"23, 1\" + getDecimalCharacter() +\n+                \"43, 1\" + getDecimalCharacter() +\n+                \"63; -2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"47, 2\" + getDecimalCharacter() +\n+                \"67]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNonDefaultSetting() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});\n+        String expected = \"{1 : 1 : 1, 1 : 1 : 1}\";\n+        String actual = realMatrixFormatOther.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testDefaultFormatRealVectorImpl() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{232.222, -342.33, 432.444}});\n+        String expected =\n+            \"[232\"    + getDecimalCharacter() +\n+            \"22, -342\" + getDecimalCharacter() +\n+            \"33, 432\" + getDecimalCharacter() +\n+            \"44]\";\n+        String actual = (new RealMatrixFormat()).format(m);\n+        Assert.assertEquals(expected, actual);\n+\n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    @Test\n+    public void testNan() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {{Double.NaN, Double.NaN, Double.NaN}});\n+        String expected = \"[(NaN), (NaN), (NaN)]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testPositiveInfinity() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(\n+                new double[][] {{Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY}});\n+        String expected = \"[(Infinity), (Infinity), (Infinity)]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void tesNegativeInfinity() {\n+        RealMatrix m = MatrixUtils.createRealMatrix(\n+                new double[][] {{Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}});\n+        String expected = \"[(-Infinity), (-Infinity), (-Infinity)]\";\n+        String actual = realMatrixFormat.format(m);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"[1, 1, 1; 1, 1, 1]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseSimpleWithClosingRowSeparator() {\n+        String source = \"[1, 1, 1; 1, 1, 1 ;]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseIgnoredWhitespace() {\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1, 1, 1}, {1, 1, 1}});\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"[1,1,1;1,1,1]\";\n+        Assert.assertEquals(expected, realMatrixFormat.parse(source1, pos1));\n+        Assert.assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" [ 1 , 1 , 1 ; 1 , 1 , 1 ] \";\n+        Assert.assertEquals(expected, realMatrixFormat.parse(source2, pos2));\n+        Assert.assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    @Test\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"23, 1\" + getDecimalCharacter() +\n+            \"43, 1\" + getDecimalCharacter() +\n+            \"63]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1.23, 1.43, 1.63}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323, 1\" + getDecimalCharacter() +\n+            \"4343, 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1.2323, 1.4343, 1.6333}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeComponent() {\n+        String source =\n+            \"[-1\" + getDecimalCharacter() +\n+            \"2323, 1\" + getDecimalCharacter() +\n+            \"4343, 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{-1.2323, 1.4343, 1.6333}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"[-1\" + getDecimalCharacter() +\n+            \"2323, -1\" + getDecimalCharacter() +\n+            \"4343, -1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{-1.2323, -1.4343, -1.6333}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseZeroComponent() {\n+        String source =\n+            \"[0\" + getDecimalCharacter() +\n+            \"0, -1\" + getDecimalCharacter() +\n+            \"4343, 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{0.0, -1.4343, 1.6333}});\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{1.2323, 1.4343, 1.6333}});\n+        RealMatrix actual = realMatrixFormatOther.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNan() {\n+        String source = \"[(NaN), (NaN), (NaN)]\";\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        RealMatrix expected = MatrixUtils.createRealMatrix(new double[][] {{Double.NaN, Double.NaN, Double.NaN}});\n+        for (int i = 0; i < expected.getRowDimension(); i++) {\n+            for (int j = 0; j < expected.getColumnDimension(); j++) {\n+                Assert.assertTrue(Double.isNaN(actual.getEntry(i, j)));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testParsePositiveInfinity() {\n+        String source = \"[(Infinity), (Infinity), (Infinity)]\";\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        RealMatrix expected = MatrixUtils.createRealMatrix(\n+                new double[][] {{Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY}});\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeInfinity() {\n+        String source = \"[(-Infinity), (-Infinity), (-Infinity)]\";\n+        RealMatrix actual = realMatrixFormat.parse(source);\n+        RealMatrix expected = MatrixUtils.createRealMatrix(\n+                new double[][] {{Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}});\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNoComponents() {\n+        try {\n+            realMatrixFormat.parse(\"[ ]\");\n+            Assert.fail(\"Expecting MathParseException\");\n+        } catch (MathParseException pe) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testParseManyComponents() {\n+        RealMatrix parsed = realMatrixFormat.parse(\"[0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0]\");\n+        Assert.assertEquals(24, parsed.getRowDimension());\n+    }\n+\n+    @Test\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        RealMatrixFormat mf = new RealMatrixFormat(nf);\n+        Assert.assertNotNull(mf);\n+        Assert.assertEquals(nf, mf.getFormat());\n+    }\n+\n+    @Test\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        final String source = \"1; 1; 1]\";\n+        Assert.assertNull(\"Should not parse <\"+source+\">\", new RealMatrixFormat().parse(source, pos));\n+        Assert.assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    @Test\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        final String source = \"[1; 1 1]\";\n+        Assert.assertNull(\"Should not parse <\"+source+\">\", new RealMatrixFormat().parse(source, pos));\n+        Assert.assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    @Test\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        final String source = \"[1; 1; 1 \";\n+        Assert.assertNull(\"Should not parse <\"+source+\">\", new RealMatrixFormat().parse(source, pos));\n+        Assert.assertEquals(8, pos.getErrorIndex());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/RealMatrixFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class RealMatrixFormatTest extends RealMatrixFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}", "timestamp": 1342985916, "metainfo": ""}