{"sha": "9744c652bf8be7ecf69159aada16da121db9d1be", "log": "Minor checkstyle fixes in optimization.[direct|linear].  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionMappingAdapter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionMappingAdapter.java\n import org.apache.commons.math.analysis.function.Logit;\n import org.apache.commons.math.analysis.function.Sigmoid;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n      * @param upper upper bounds for each element of the input parameters array\n      * (some elements may be set to {@code Double.POSITIVE_INFINITY} for\n      * unbounded values)\n-     * @exception MathIllegalArgumentException if lower and upper bounds are not\n+     * @exception DimensionMismatchException if lower and upper bounds are not\n      * consistent, either according to dimension or to values\n      */\n     public MultivariateFunctionMappingAdapter(final MultivariateFunction bounded,\n \n     }\n \n-    /** \n-     * Map an array from bounded to unbounded.\n+    /** Map an array from bounded to unbounded.\n      * @param point bounded value\n      * @return unbounded value\n      */\n      * set up at construction and calls the underlying function using\n      * the bounded point.\n      * </p>\n+     * @param point unbounded value\n+     * @return underlying function value\n      * @see #unboundedToBounded(double[])\n      */\n     public double value(double[] point) {\n     }\n \n     /** Mapping interface. */\n-    private static interface Mapper {\n+    private interface Mapper {\n \n         /** Map a value from unbounded to bounded.\n          * @param y unbounded value\n          * @return bounded value\n          */\n-        public double unboundedToBounded(double y);\n+        double unboundedToBounded(double y);\n \n         /** Map a value from bounded to unbounded.\n          * @param x bounded value\n          * @return unbounded value\n          */\n-        public double boundedToUnbounded(double x);\n+        double boundedToUnbounded(double x);\n \n     }\n \n         public double unboundedToBounded(final double y) {\n             return upper - FastMath.exp(-y);\n         }\n-        \n+\n         /** {@inheritDoc} */\n         public double boundedToUnbounded(final double x) {\n             return -FastMath.log(upper - x);\n         }\n-        \n+\n     }\n \n     /** Local class for lower and bounds mapping. */\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java\n \n import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n      * unbounded values)\n      * @param offset base offset of the penalty function\n      * @param scale scale of the penalty function\n-     * @exception MathIllegalArgumentException if lower bounds, upper bounds and\n+     * @exception DimensionMismatchException if lower bounds, upper bounds and\n      * scales are not consistent, either according to dimension or to bounadary\n      * values\n      */\n      * a replacement value using the offset and scale if bounds are\n      * violated, without calling the function at all.\n      * </p>\n+     * @param point unbounded point\n      * @return either underlying function value or penalty function value\n      */\n     public double value(double[] point) {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n           Integer basicRow = getBasicRow(colIndex);\n           if (basicRow != null && basicRow == 0) {\n               // if the basic row is found to be the objective function row\n-              // set the coefficient to 0 -> this case handles unconstrained \n+              // set the coefficient to 0 -> this case handles unconstrained\n               // variables that are still part of the objective function\n               coefficients[i] = 0;\n           } else if (basicRows.contains(basicRow)) {", "timestamp": 1328213994, "metainfo": ""}