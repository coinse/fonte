{"sha": "1347c824bbaedf56d28863e92c0c38f41253d823", "log": "[MATH-235] add support for non-symmetric matrices in EigenvalueDecomposition.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n \n package org.apache.commons.math3.linear;\n \n+import org.apache.commons.math3.complex.Complex;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n- * Calculates the eigen decomposition of a real <strong>symmetric</strong>\n- * matrix.\n+ * Calculates the eigen decomposition of a real matrix.\n  * <p>The eigen decomposition of matrix A is a set of two matrices:\n  * V and D such that A = V &times; D &times; V<sup>T</sup>.\n  * A, V and D are all m &times; m matrices.</p>\n  *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n  * </ul>\n  * <p>\n- * As of 2.0, this class supports only <strong>symmetric</strong> matrices, and\n- * hence computes only real realEigenvalues. This implies the D matrix returned\n- * by {@link #getD()} is always diagonal and the imaginary values returned\n- * {@link #getImagEigenvalue(int)} and {@link #getImagEigenvalues()} are always\n- * null.\n+ * As of 3.1, this class supports general real matrices (both symmetric and non-symmetric):\n  * </p>\n  * <p>\n- * When called with a {@link RealMatrix} argument, this implementation only uses\n- * the upper part of the matrix, the part below the diagonal is not accessed at\n- * all.\n+ * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector\n+ * matrix V is orthogonal, i.e. A = V.multiply(D.multiply(V.transpose())) and\n+ * V.multiply(V.transpose()) equals the identity matrix.\n+ * </p>\n+ * <p>\n+ * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues\n+ * in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks:\n+ * <pre>\n+ *    [lambda, mu    ]\n+ *    [   -mu, lambda]\n+ * </pre>\n+ * The columns of V represent the eigenvectors in the sense that A*V = V*D,\n+ * i.e. A.multiply(V) equals V.multiply(D).\n+ * The matrix V may be badly conditioned, or even singular, so the validity of the equation\n+ * A = V*D*inverse(V) depends upon the condition of V.\n  * </p>\n  * <p>\n  * This implementation is based on the paper by A. Drubrulle, R.S. Martin and\n  * @version $Id$\n  * @since 2.0 (changed to concrete class in 3.0)\n  */\n-public class EigenDecomposition{\n+public class EigenDecomposition {\n     /** Maximum number of iterations accepted in the implicit QL transformation */\n     private byte maxIter = 30;\n     /** Main diagonal of the tridiagonal matrix. */\n     /** Cached value of Vt. */\n     private RealMatrix cachedVt;\n \n-    /**\n-     * Calculates the eigen decomposition of the given symmetric matrix.\n-     *\n-     * @param matrix Matrix to decompose. It <em>must</em> be symmetric.\n+    /** Internally used epsilon criteria. */\n+    private final double epsilon = 1e-16;\n+\n+    /**\n+     * Calculates the eigen decomposition of the given real matrix.\n+     *\n+     * @param matrix Matrix to decompose.\n      * @param splitTolerance Dummy parameter (present for backward\n      * compatibility only).\n-     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n      */\n     public EigenDecomposition(final RealMatrix matrix,\n-                                  final double splitTolerance)  {\n-        if (isSymmetric(matrix, true)) {\n+                              final double splitTolerance)  {\n+        if (isSymmetric(matrix, false)) {\n             transformToTridiagonal(matrix);\n             findEigenVectors(transformer.getQ().getData());\n+        } else {\n+            final SchurTransformer t = transformToSchur(matrix);\n+            findEigenVectorsFromSchur(t);\n         }\n     }\n \n      * compatibility only).\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n      */\n-    public EigenDecomposition(final double[] main,final double[] secondary,\n-                                  final double splitTolerance) {\n+    public EigenDecomposition(final double[] main, final double[] secondary,\n+                              final double splitTolerance) {\n         this.main      = main.clone();\n         this.secondary = secondary.clone();\n         transformer    = null;\n-        final int size=main.length;\n-        double[][] z = new double[size][size];\n-        for (int i=0;i<size;i++) {\n-            z[i][i]=1.0;\n+        final int size = main.length;\n+        final double[][] z = new double[size][size];\n+        for (int i = 0; i < size; i++) {\n+            z[i][i] = 1.0;\n         }\n         findEigenVectors(z);\n     }\n         if (cachedD == null) {\n             // cache the matrix for subsequent calls\n             cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n+\n+            for (int i = 0; i < imagEigenvalues.length; i++) {\n+                if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) > 0) {\n+                    cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n+                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) < 0) {\n+                    cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n+                }\n+            }\n         }\n         return cachedD;\n     }\n             for (int k = 0; k < m; ++k) {\n                 cachedVt.setRowVector(k, eigenvectors[k]);\n             }\n-\n         }\n \n         // return the cached matrix\n      * @param householderMatrix Householder matrix of the transformation\n      * to tridiagonal form.\n      */\n-    private void findEigenVectors(double[][] householderMatrix) {\n+    private void findEigenVectors(final double[][] householderMatrix) {\n         final double[][]z = householderMatrix.clone();\n         final int n = main.length;\n         realEigenvalues = new double[n];\n             }\n         }\n         // Make null any eigen value too small to be significant\n-        if (maxAbsoluteValue!=0.0) {\n+        if (maxAbsoluteValue != 0.0) {\n             for (int i=0; i < n; i++) {\n                 if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n                     realEigenvalues[i] = 0;\n             eigenvectors[i] = new ArrayRealVector(tmp);\n         }\n     }\n+\n+    /**\n+     * Transforms the matrix to Schur form and calculates the eigenvalues.\n+     *\n+     * @param matrix Matrix to transform.\n+     * @return the {@link SchurTransform} for this matrix\n+     */\n+    private SchurTransformer transformToSchur(final RealMatrix matrix) {\n+        final SchurTransformer schurTransform = new SchurTransformer(matrix);\n+        final double[][] matT = schurTransform.getT().getData();\n+\n+        realEigenvalues = new double[matT.length];\n+        imagEigenvalues = new double[matT.length];\n+\n+        for (int i = 0; i < realEigenvalues.length; i++) {\n+            if (i == (realEigenvalues.length - 1) ||\n+                Precision.equals(matT[i + 1][i], 0.0, epsilon)) {\n+                realEigenvalues[i] = matT[i][i];\n+            } else {\n+                final double x = matT[i + 1][i + 1];\n+                final double p = 0.5 * (matT[i][i] - x);\n+                final double z = FastMath.sqrt(FastMath.abs(p * p + matT[i + 1][i] * matT[i][i + 1]));\n+                realEigenvalues[i] = x + p;\n+                imagEigenvalues[i] = z;\n+                realEigenvalues[i + 1] = x + p;\n+                imagEigenvalues[i + 1] = -z;\n+                i++;\n+            }\n+        }\n+        return schurTransform;\n+    }\n+\n+    /**\n+     * Performs a division of two complex numbers.\n+     *\n+     * @param xr real part of the first number\n+     * @param xi imaginary part of the first number\n+     * @param yr real part of the second number\n+     * @param yi imaginary part of the second number\n+     * @return result of the complex division\n+     */\n+    private Complex cdiv(final double xr, final double xi,\n+                         final double yr, final double yi) {\n+        return new Complex(xr, xi).divide(new Complex(yr, yi));\n+    }\n+\n+    /**\n+     * Find eigenvectors from a matrix transformed to Schur form.\n+     *\n+     * @param schur the schur transformation of the matrix\n+     */\n+    private void findEigenVectorsFromSchur(final SchurTransformer schur) {\n+        final double[][] matrixT = schur.getT().getData();\n+        final double[][] matrixP = schur.getP().getData();\n+\n+        final int n = matrixT.length;\n+\n+        // compute matrix norm\n+        double norm = 0.0;\n+        for (int i = 0; i < n; i++) {\n+           for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n+              norm = norm + FastMath.abs(matrixT[i][j]);\n+           }\n+        }\n+\n+        if (Precision.equals(norm, 0.0)) {\n+            // TODO: we can not handle a zero matrix, what exception to throw?\n+           return;\n+        }\n+\n+        // Backsubstitute to find vectors of upper triangular form\n+\n+        double r = 0.0;\n+        double s = 0.0;\n+        double z = 0.0;\n+\n+        for (int idx = n - 1; idx >= 0; idx--) {\n+            double p = realEigenvalues[idx];\n+            double q = imagEigenvalues[idx];\n+\n+            if (Precision.equals(q, 0.0)) {\n+                // Real vector\n+                int l = idx;\n+                matrixT[idx][idx] = 1.0;\n+                for (int i = idx - 1; i >= 0; i--) {\n+                    double w = matrixT[i][i] - p;\n+                    r = 0.0;\n+                    for (int j = l; j <= idx; j++) {\n+                        r = r + matrixT[i][j] * matrixT[j][idx];\n+                    }\n+                    if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) < 0.0) {\n+                        z = w;\n+                        s = r;\n+                    } else {\n+                        l = i;\n+                        if (Precision.equals(imagEigenvalues[i], 0.0)) {\n+                            if (w != 0.0) {\n+                                matrixT[i][idx] = -r / w;\n+                            } else {\n+                                matrixT[i][idx] = -r / (Precision.EPSILON * norm);\n+                            }\n+                        } else {\n+                            // Solve real equations\n+                            double x = matrixT[i][i + 1];\n+                            double y = matrixT[i + 1][i];\n+                            q = (realEigenvalues[i] - p) * (realEigenvalues[i] - p) +\n+                                imagEigenvalues[i] * imagEigenvalues[i];\n+                            double t = (x * s - z * r) / q;\n+                            matrixT[i][idx] = t;\n+                            if (FastMath.abs(x) > FastMath.abs(z)) {\n+                                matrixT[i + 1][idx] = (-r - w * t) / x;\n+                            } else {\n+                                matrixT[i + 1][idx] = (-s - y * t) / z;\n+                            }\n+                        }\n+\n+                        // Overflow control\n+                        double t = FastMath.abs(matrixT[i][idx]);\n+                        if ((Precision.EPSILON * t) * t > 1) {\n+                            for (int j = i; j <= idx; j++) {\n+                                matrixT[j][idx] = matrixT[j][idx] / t;\n+                            }\n+                        }\n+                    }\n+                }\n+            } else if (q < 0.0) {\n+                // Complex vector\n+                int l = idx - 1;\n+\n+                // Last vector component imaginary so matrix is triangular\n+                if (FastMath.abs(matrixT[idx][idx - 1]) > FastMath.abs(matrixT[idx - 1][idx])) {\n+                    matrixT[idx - 1][idx - 1] = q / matrixT[idx][idx - 1];\n+                    matrixT[idx - 1][idx]     = -(matrixT[idx][idx] - p) / matrixT[idx][idx - 1];\n+                } else {\n+                    final Complex result = cdiv(0.0, -matrixT[idx - 1][idx],\n+                                                matrixT[idx - 1][idx - 1] - p, q);\n+                    matrixT[idx - 1][idx - 1] = result.getReal();\n+                    matrixT[idx - 1][idx]     = result.getImaginary();\n+                }\n+\n+                matrixT[idx][idx - 1] = 0.0;\n+                matrixT[idx][idx]     = 1.0;\n+\n+                for (int i = idx - 2; i >= 0; i--) {\n+                    double ra = 0.0;\n+                    double sa = 0.0;\n+                    for (int j = l; j <= idx; j++) {\n+                        ra = ra + matrixT[i][j] * matrixT[j][idx - 1];\n+                        sa = sa + matrixT[i][j] * matrixT[j][idx];\n+                    }\n+                    double w = matrixT[i][i] - p;\n+\n+                    if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) < 0.0) {\n+                        z = w;\n+                        r = ra;\n+                        s = sa;\n+                    } else {\n+                        l = i;\n+                        if (Precision.equals(imagEigenvalues[i], 0.0)) {\n+                            final Complex c = cdiv(-ra, -sa, w, q);\n+                            matrixT[i][idx - 1] = c.getReal();\n+                            matrixT[i][idx] = c.getImaginary();\n+                        } else {\n+                            // Solve complex equations\n+                            double x = matrixT[i][i + 1];\n+                            double y = matrixT[i + 1][i];\n+                            double vr = (realEigenvalues[i] - p) * (realEigenvalues[i] - p) +\n+                                        imagEigenvalues[i] * imagEigenvalues[i] - q * q;\n+                            final double vi = (realEigenvalues[i] - p) * 2.0 * q;\n+                            if (Precision.equals(vr, 0.0) && Precision.equals(vi, 0.0)) {\n+                                vr = Precision.EPSILON * norm *\n+                                     (FastMath.abs(w) + FastMath.abs(q) + FastMath.abs(x) +\n+                                      FastMath.abs(y) + FastMath.abs(z));\n+                            }\n+                            final Complex c     = cdiv(x * r - z * ra + q * sa,\n+                                                       x * s - z * sa - q * ra, vr, vi);\n+                            matrixT[i][idx - 1] = c.getReal();\n+                            matrixT[i][idx]     = c.getImaginary();\n+\n+                            if (FastMath.abs(x) > (FastMath.abs(z) + FastMath.abs(q))) {\n+                                matrixT[i + 1][idx - 1] = (-ra - w * matrixT[i][idx - 1] +\n+                                                           q * matrixT[i][idx]) / x;\n+                                matrixT[i + 1][idx]     = (-sa - w * matrixT[i][idx] -\n+                                                           q * matrixT[i][idx - 1]) / x;\n+                            } else {\n+                                final Complex c2        = cdiv(-r - y * matrixT[i][idx - 1],\n+                                                               -s - y * matrixT[i][idx], z, q);\n+                                matrixT[i + 1][idx - 1] = c2.getReal();\n+                                matrixT[i + 1][idx]     = c2.getImaginary();\n+                            }\n+                        }\n+\n+                        // Overflow control\n+                        double t = FastMath.max(FastMath.abs(matrixT[i][idx - 1]),\n+                                                FastMath.abs(matrixT[i][idx]));\n+                        if ((Precision.EPSILON * t) * t > 1) {\n+                            for (int j = i; j <= idx; j++) {\n+                                matrixT[j][idx - 1] = matrixT[j][idx - 1] / t;\n+                                matrixT[j][idx]     = matrixT[j][idx] / t;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Vectors of isolated roots\n+        for (int i = 0; i < n; i++) {\n+            if (i < 0 | i > n - 1) {\n+                for (int j = i; j < n; j++) {\n+                    matrixP[i][j] = matrixT[i][j];\n+                }\n+            }\n+        }\n+\n+        // Back transformation to get eigenvectors of original matrix\n+        for (int j = n - 1; j >= 0; j--) {\n+            for (int i = 0; i <= n - 1; i++) {\n+                z = 0.0;\n+                for (int k = 0; k <= FastMath.min(j, n - 1); k++) {\n+                    z = z + matrixP[i][k] * matrixT[k][j];\n+                }\n+                matrixP[i][j] = z;\n+            }\n+        }\n+\n+        eigenvectors = new ArrayRealVector[n];\n+        final double[] tmp = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                tmp[j] = matrixP[j][i];\n+            }\n+            eigenvectors[i] = new ArrayRealVector(tmp);\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.java\n         for (int i = 0; i < bigValues.length; ++i) {\n             Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n         }\n+    }\n+\n+    @Test\n+    public void testSymmetric() {\n+        RealMatrix symmetric = MatrixUtils.createRealMatrix(new double[][] {\n+                {4, 1, 1},\n+                {1, 2, 3},\n+                {1, 3, 6}\n+        });\n+\n+        EigenDecomposition ed;\n+        ed = new EigenDecomposition(symmetric, Precision.SAFE_MIN);\n+        \n+        RealMatrix d = ed.getD();\n+        RealMatrix v = ed.getV();\n+        RealMatrix vT = ed.getVT();\n+\n+        double norm = v.multiply(d).multiply(vT).subtract(symmetric).getNorm();\n+        Assert.assertEquals(0, norm, 6.0e-13);\n+\n+//           check(A.times(V),V.times(D));\n+    }\n+\n+    @Test\n+    public void testUnsymmetric() {\n+        // Vandermonde matrix V(x;i,j) = x_i^{n - j} with x = (-1,-2,3,4)\n+        double[][] vData = { { -1.0, 1.0, -1.0, 1.0 },\n+                             { -8.0, 4.0, -2.0, 1.0 },\n+                             { 27.0, 9.0,  3.0, 1.0 },\n+                             { 64.0, 16.0, 4.0, 1.0 } };\n+        checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(vData));\n+      \n+        RealMatrix randMatrix = MatrixUtils.createRealMatrix(new double[][] {\n+                {0,  1,     0,     0},\n+                {1,  0,     2.e-7, 0},\n+                {0, -2.e-7, 0,     1},\n+                {0,  0,     1,     0}\n+        });\n+        checkUnsymmetricMatrix(randMatrix);\n+\n+        // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html\n+        double[][] randData2 = {\n+                {  0.680, -0.3300, -0.2700, -0.717, -0.687,  0.0259 },\n+                { -0.211,  0.5360,  0.0268,  0.214, -0.198,  0.6780 },\n+                {  0.566, -0.4440,  0.9040, -0.967, -0.740,  0.2250 },\n+                {  0.597,  0.1080,  0.8320, -0.514, -0.782, -0.4080 },\n+                {  0.823, -0.0452,  0.2710, -0.726,  0.998,  0.2750 },\n+                { -0.605,  0.2580,  0.4350,  0.608, -0.563,  0.0486 }\n+        };\n+        checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(randData2));\n+    }\n+    \n+    private void checkUnsymmetricMatrix(final RealMatrix m) {\n+        EigenDecomposition ed = new EigenDecomposition(m, Precision.SAFE_MIN);\n+        \n+        RealMatrix d = ed.getD();\n+        RealMatrix v = ed.getV();\n+        //RealMatrix vT = ed.getVT();\n+\n+        RealMatrix x = m.multiply(v);\n+        RealMatrix y = v.multiply(d);\n+        \n+        Assert.assertTrue(\"The norm of (X-Y) is too large\",\n+                x.subtract(y).getNorm() < 1000 * Precision.EPSILON * FastMath.max(x.getNorm(), y.getNorm()));\n+        \n+        RealMatrix invV = new LUDecomposition(v).getSolver().getInverse();\n+        double norm = v.multiply(d).multiply(invV).subtract(m).getNorm();\n+        Assert.assertEquals(0.0, norm, 6.0e-13);\n     }\n \n     /** test eigenvectors */", "timestamp": 1336333257, "metainfo": ""}