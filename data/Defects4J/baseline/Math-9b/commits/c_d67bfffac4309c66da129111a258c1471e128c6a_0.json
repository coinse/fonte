{"sha": "d67bfffac4309c66da129111a258c1471e128c6a", "log": "Added an int/double hash map (OpenIntToDoubleHashMap) with much smaller memory overhead than standard java.util.Map (open addressing and no boxing)  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n import java.io.PrintWriter;\n import java.text.MessageFormat;\n import java.text.ParseException;\n+import java.util.ConcurrentModificationException;\n import java.util.Locale;\n import java.util.MissingResourceException;\n+import java.util.NoSuchElementException;\n import java.util.ResourceBundle;\n \n /**\n public class MathRuntimeException extends RuntimeException {\n     \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 8560172512507661982L;\n+    private static final long serialVersionUID = -143052521750625264L;\n \n     /** Cache for resources bundle. */\n     private static ResourceBundle cachedResources = null;\n     }\n \n     /**\n+     * Constructs a new <code>ConcurrentModificationException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static ConcurrentModificationException createConcurrentModificationException(final String pattern,\n+                                                                                        final Object[] arguments) {\n+        return new ConcurrentModificationException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 6134247282754009421L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>NoSuchElementException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static NoSuchElementException createNoSuchElementException(final String pattern,\n+                                                                      final Object[] arguments) {\n+        return new NoSuchElementException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 7304273322489425799L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n      * Constructs a new <code>ParseException</code> with specified\n      * formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n       \"une matrice doit comporter au moins une colonne\" },\n     { \"some rows have length {0} while others have length {1}\",\n       \"certaines ligne ont une longueur de {0} alors que d''autres ont une longueur de {1}\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour l'addition matricielle\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la soustraction matricielle\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle\" },\n \n     // org.apache.commons.math.linear.BigMatrixImpl\n     // org.apache.commons.math.linear.RealMatrixImpl\n       \"tableau des indices de lignes s\\u00e9lectionn\\u00e9es vide\" },\n     { \"empty selected column index array\",\n       \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" },\n-    { \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n-      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle\" },\n-    { \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n-      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour l'addition matricielle\" },\n-    { \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n-      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la soustraction matricielle\" },\n \n    // org.apache.commons.math.random.EmpiricalDistributionImpl\n    // org.apache.commons.math.random.ValueServer\n    { \"invalid number of elements {0} (must be positive)\",\n      \"nombre d''\\u00e9l\\u00e9ments {0} invalide (doit \\u00eatre positif)\" },\n    { \"invalid exponent {0} (must be positive)\",\n-     \"exposant {0} invalide (doit \\u00eatre positif)\" }\n+     \"exposant {0} invalide (doit \\u00eatre positif)\" },\n+\n+   // org.apache.commons.math.util.OpenIntToDoubleHashMap\n+   { \"map has been modified while iterating\",\n+     \"la table d''adressage a \\u00e9t\\u00e9 modifi\\u00e9e pendant l''it\\u00e9ration\" },\n+   { \"iterator exhausted\",\n+     \"it\\u00e9ration achev\\u00e9e\" }\n \n   };\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+import java.util.ConcurrentModificationException;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Open addressed map from int to double.\n+ * <p>This class provides a dedicated map from integers to doubles with a\n+ * much smaller memory overhead than standard <code>java.util.Map</code>.</p>\n+ * <p>This class is not synchronized. The specialized iterators returned by\n+ * {@link #iterator()} are fail-fast: they throw a\n+ * <code>ConcurrentModificationException</code> when they detect the map has been\n+ * modified during iteration.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OpenIntToDoubleHashMap implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3646337053166149105L;\n+\n+    /** Load factor for the map. */\n+    private static final float LOAD_FACTOR = 0.5f;\n+\n+    /** Default starting size.\n+     * <p>This must be a power of two for bit mask to work properly. </p>\n+     */\n+    private static final int DEFAULT_EXPECTED_SIZE = 16;\n+\n+    /** Multiplier for size growth when map fills up.\n+     * <p>This must be a power of two for bit mask to work properly. </p>\n+     */\n+    private static final int RESIZE_MULTIPLIER = 2;\n+\n+    /** Number of bits to perturb the index when probing for collision resolution. */\n+    private static final int PERTURB_SHIFT = 5;\n+\n+    /** Status indicator for free table entries. */\n+    protected static final byte FREE    = 0;\n+\n+    /** Status indicator for full table entries. */\n+    protected static final byte FULL    = 1;\n+\n+    /** Status indicator for removed table entries. */\n+    protected static final byte REMOVED = 2;\n+\n+    /** Keys table. */\n+    private int[] keys;\n+\n+    /** Values table. */\n+    private double[] values;\n+\n+    /** States table. */\n+    private byte[] states;\n+\n+    /** Current size of the map. */\n+    private int size;\n+\n+    /** Bit mask for hash values. */\n+    private int mask;\n+\n+    /** Modifications count. */\n+    private transient int count;\n+\n+    /**\n+     * Build an empty map with default size.\n+     */\n+    public OpenIntToDoubleHashMap() {\n+        this(DEFAULT_EXPECTED_SIZE);\n+    }\n+\n+    /**\n+     * Build an empty map with specified size.\n+     * @param expectedSize expected number of elements in the map\n+     */\n+    public OpenIntToDoubleHashMap(final int expectedSize) {\n+        final int capacity = computeCapacity(expectedSize);\n+        keys   = new int[capacity];\n+        values = new double[capacity];\n+        states = new byte[capacity];\n+        mask   = capacity - 1;\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param source map to copy\n+     */\n+    public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) {\n+        final int length = source.keys.length;\n+        keys = new int[length];\n+        System.arraycopy(source.keys, 0, keys, 0, length);\n+        values = new double[length];\n+        System.arraycopy(source.values, 0, values, 0, length);\n+        states = new byte[length];\n+        System.arraycopy(source.states, 0, states, 0, length);\n+        size  = source.size;\n+        mask  = source.mask;\n+        count = source.count;\n+    }\n+\n+    /**\n+     * Compute the capacity needed for a given size.\n+     * @param expectedSize expected size of the map\n+     * @return capacity to use for the specified size\n+     */\n+    private static int computeCapacity(final int expectedSize) {\n+        if (expectedSize == 0) {\n+            return 1;\n+        }\n+        final int capacity   = (int) Math.ceil(expectedSize / LOAD_FACTOR);\n+        final int powerOfTwo = Integer.highestOneBit(capacity);\n+        if (powerOfTwo == capacity) {\n+            return capacity;\n+        }\n+        return nextPowerOfTwo(capacity);\n+    }\n+\n+    /**\n+     * Find the smallest power of two greater than the input value\n+     * @param i input value\n+     * @return smallest power of two greater than the input value\n+     */\n+    private static int nextPowerOfTwo(final int i) {\n+        return Integer.highestOneBit(i) << 1;\n+    }\n+\n+    /**\n+     * Get the stored value associated with the given key\n+     * @param key key associated with the data\n+     * @return data associated with the key\n+     */\n+    public double get(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return values[index];\n+        }\n+\n+        if (states[index] == FREE) {\n+            return 0.0;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return values[index];\n+            }\n+        }\n+\n+        return 0.0;\n+\n+    }\n+\n+    /**\n+     * Check if a value is associated with a key.\n+     * @param key key to check\n+     * @return true if a value is associated with key\n+     */\n+    public boolean containsKey(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return true;\n+        }\n+\n+        if (states[index] == FREE) {\n+            return false;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+\n+    /**\n+     * Get an iterator over map elements.\n+     * <p>The specialized iterators returned are fail-fast: they throw a\n+     * <code>ConcurrentModificationException</code> when they detect the map\n+     * has been modified during iteration.</p>\n+     * @return iterator over the map elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator();\n+    }\n+\n+    /**\n+     * Perturb the hash for starting probing.\n+     * @param hash initial hash\n+     * @return perturbed hash\n+     */\n+    private static int perturb(final int hash) {\n+        return hash & 0x7fffffff;\n+    }\n+\n+    /**\n+     * Find the index at which a key should be inserted\n+     * @param key key to lookup\n+     * @return index at which key should be inserted\n+     */\n+    private int findInsertionIndex(final int key) {\n+        return findInsertionIndex(keys, states, key, mask);\n+    }\n+\n+    /**\n+     * Find the index at which a key should be inserted\n+     * @param keys keys table\n+     * @param states states table\n+     * @param key key to lookup\n+     * @param mask bit mask for hash values\n+     * @return index at which key should be inserted\n+     */\n+    private static int findInsertionIndex(final int[] keys, final byte[] states,\n+                                          final int key, final int mask) {\n+        final int hash = hashOf(key);\n+        int index = hash & mask;\n+        if (states[index] == FREE) {\n+            return index;\n+        } else if (states[index] == FULL && keys[index] == key) {\n+            return changeIndexSign(index);\n+        }\n+\n+        int perturb = perturb(hash);\n+        int j = index;\n+        if (states[index] == FULL) {\n+            while (true) {\n+                j = probe(perturb, j);\n+                index = j & mask;\n+                perturb >>= PERTURB_SHIFT;\n+                \n+                if (states[index] != FULL || keys[index] == key) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (states[index] == FREE) {\n+            return index;\n+        } else if (states[index] == FULL) {\n+            // due to the loop exit condition,\n+            // if (states[index] == FULL) then keys[index] == key\n+            return changeIndexSign(index);\n+        }\n+\n+        final int firstRemoved = index;\n+        while (true) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+\n+            if (states[index] == FREE) {\n+                return firstRemoved;\n+            } else if (states[index] == FULL && keys[index] == key) {\n+                return changeIndexSign(index);\n+            }\n+\n+            perturb >>= PERTURB_SHIFT;\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute next probe for collision resolution\n+     * @param perturb perturbed hash\n+     * @param j previous probe\n+     * @return next probe\n+     */\n+    private static int probe(final int perturb, final int j) {\n+        return (j << 2) + j + perturb + 1;\n+    }\n+\n+    /**\n+     * Change the index sign\n+     * @param index initial index\n+     * @return changed index\n+     */\n+    private static int changeIndexSign(final int index) {\n+        return -index - 1;\n+    }\n+\n+    /**\n+     * Get the number of elements stored in the map.\n+     * @return number of elements stored in the map\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Remove the value associated with a key.\n+     * @param key key to which the value is associated\n+     * @return removed value\n+     */\n+    public double remove(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return doRemove(index);\n+        }\n+\n+        if (states[index] == FREE) {\n+            return 0.0;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return doRemove(index);\n+            }\n+        }\n+\n+        return 0.0;\n+\n+    }\n+\n+    /**\n+     * Check if the tables contain an element associated with specified key\n+     * at specified index.\n+     * @param key key to check\n+     * @param index index to check\n+     * @return true if an element is associated with key at index\n+     */\n+    private boolean containsKey(final int key, final int index) {\n+        return (key != 0 || states[index] == FULL) && keys[index] == key;\n+    }\n+\n+    /**\n+     * Remove an element at specified index.\n+     * @param index index of the element to remove\n+     * @return removed value\n+     */\n+    private double doRemove(int index) {\n+        keys[index]   = 0;\n+        states[index] = REMOVED;\n+        final double previous = values[index];\n+        values[index] = 0;\n+        --size;\n+        ++count;\n+        return previous;\n+    }\n+\n+    /**\n+     * Put a value associated with a key in the map.\n+     * @param key key to which value is associated\n+     * @param value value to put in the map\n+     * @return previous value associated with the key\n+     */\n+    public double put(final int key, final double value) {\n+        int index = findInsertionIndex(key);\n+        double previous = 0.0;\n+        boolean newMapping = true;\n+        if (index < 0) {\n+            index = changeIndexSign(index);\n+            previous = values[index];\n+            newMapping = false;\n+        }\n+        keys[index]   = key;\n+        states[index] = FULL;\n+        values[index] = value;\n+        if (newMapping) {\n+            ++size;\n+            if (shouldGrowTable()) {\n+                growTable();\n+            }\n+        }\n+\n+        ++count;\n+        return previous;\n+\n+    }\n+\n+    /**\n+     * Grow the tables.\n+     */\n+    private void growTable() {\n+\n+        final int oldLength      = states.length;\n+        final int[] oldKeys      = keys;\n+        final double[] oldValues = values;\n+        final byte[] oldStates   = states;\n+\n+        final int newLength = RESIZE_MULTIPLIER * oldLength;\n+        final int[] newKeys = new int[newLength];\n+        final double[] newValues = new double[newLength];\n+        final byte[] newStates = new byte[newLength];\n+        final int newMask = newLength - 1;\n+        for (int i = 0; i < oldLength; ++i) {\n+            if (oldStates[i] == FULL) {\n+                final int key = oldKeys[i];\n+                final int index = findInsertionIndex(newKeys, newStates, key, newMask);\n+                newKeys[index]   = key;\n+                newValues[index] = oldValues[i];\n+                newStates[index] = FULL;\n+            }\n+        }\n+\n+        mask   = newMask;\n+        keys   = newKeys;\n+        values = newValues;\n+        states = newStates;\n+\n+    }\n+\n+    /**\n+     * Check if tables should grow due to increased size.\n+     * @return true if  tables should grow\n+     */\n+    private boolean shouldGrowTable() {\n+        return size > (mask + 1) * LOAD_FACTOR;\n+    }\n+\n+    /**\n+     * Compute the hash value of a key\n+     * @param key key to hash\n+     * @return hash value of the key\n+     */\n+    private static int hashOf(final int key) {\n+        final int h = key ^ ((key >>> 20) ^ (key >>> 12));\n+        return h ^ (h >>> 7) ^ (h >>> 4);\n+    }\n+\n+    /** Iterator class for the map. */\n+    public class Iterator {\n+\n+        /** Reference modification count. */\n+        final int referenceCount;\n+\n+        /** Index of next element. */\n+        private int index;\n+\n+        /**\n+         * Simple constructor.\n+         */\n+        private Iterator() {\n+            referenceCount = count;\n+            index = -1;\n+            goToNext();\n+        }\n+\n+        /**\n+         * Check if there is a next element in the map.\n+         * @return true if there is a next element\n+         */\n+        public boolean hasNext() {\n+            return index >= 0;\n+        }\n+\n+        /**\n+         * Get the next entry.\n+         * @return next entry\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public Entry next()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n+                                                                                 null);\n+            }\n+            if (index < 0) {\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n+            }\n+            final Entry entry = new Entry(keys[index], values[index]);\n+            goToNext();\n+            return entry;\n+        }\n+\n+        /**\n+         * Find next index.\n+         */\n+        private void goToNext() {\n+            try {\n+                while (states[++index] != FULL) {\n+                    // nothing to do\n+                }\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                index = -1;\n+            }\n+        }\n+\n+    }\n+\n+    /** Entry class for the map.\n+     * <p>Entry elements are built on the fly only during iteration,\n+     * copying values. So changes in the map are <strong>not</strong>\n+     * reflected on already built entries.</p>\n+     */\n+    public static class Entry {\n+\n+        /** Key. */\n+        private final int key;\n+\n+        /** Value. */\n+        private final double value;\n+\n+        /**\n+         * Simple constructor.\n+         * @param key entry key\n+         * @param value entry value\n+         */\n+        private Entry(final int key, final double value) {\n+            this.key   = key;\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Get the key.\n+         * @return entry key\n+         */\n+        public int key() {\n+            return key;\n+        }\n+\n+        /**\n+         * Get the value.\n+         * @return entry value\n+         */\n+        public double value() {\n+            return value;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link OpenIntToDoubleHashMap}.\n+ */\n+public class OpenIntToDoubleHashMapTest extends TestCase {\n+\n+    private Map<Integer, Double> javaMap = new HashMap<Integer, Double>();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        javaMap.put(50, 100.0);\n+        javaMap.put(75, 75.0);\n+        javaMap.put(25, 500.0);\n+        javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE);\n+        javaMap.put(0, -1.0);\n+        javaMap.put(1, 0.0);\n+        javaMap.put(33, -0.1);\n+        javaMap.put(23234234, -242343.0);\n+        javaMap.put(23321, Double.MIN_VALUE);\n+        javaMap.put(-4444, 332.0);\n+        javaMap.put(-1, -2323.0);\n+        javaMap.put(Integer.MIN_VALUE, 44.0);\n+\n+        /* Add a few more to cause the table to rehash */\n+        javaMap.putAll(generate());\n+\n+    }\n+\n+    private Map<Integer, Double> generate() {\n+        Map<Integer, Double> map = new HashMap<Integer, Double>();\n+        Random r = new Random();\n+        for (int i = 0; i < 2000; ++i)\n+            map.put(r.nextInt(), r.nextDouble());\n+        return map;\n+    }\n+\n+    private OpenIntToDoubleHashMap createFromJavaMap() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+        }\n+        return map;\n+    }\n+    \n+    public void testPutAndGetWith0ExpectedSize() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);\n+        assertPutAndGet(map);\n+    }\n+    \n+    public void testPutAndGetWithExpectedSize() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);\n+        assertPutAndGet(map);\n+    }\n+\n+    public void testPutAndGet() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        assertPutAndGet(map);\n+    }\n+\n+    private void assertPutAndGet(OpenIntToDoubleHashMap map) {\n+        assertPutAndGet(map, 0, new HashSet<Integer>());\n+    }\n+\n+    private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,\n+            Set<Integer> keysInMap) {\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            if (!keysInMap.contains(mapEntry.getKey()))\n+                ++mapSize;\n+            assertEquals(mapSize, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutAbsentOnExisting() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int size = javaMap.size();\n+        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(++size, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutOnExisting() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(javaMap.size(), map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testGetAbsent() {\n+        Map<Integer, Double> generated = generateAbsent();\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        \n+        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())\n+            assertEquals(0.0, map.get(mapEntry.getKey()));\n+    }\n+\n+    public void testGetFromEmpty() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        assertEquals(0.0, map.get(5));\n+        assertEquals(0.0, map.get(0));\n+        assertEquals(0.0, map.get(50));\n+    }\n+\n+    public void testRemove() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int mapSize = javaMap.size();\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertEquals(0.0, map.get(mapEntry.getKey()));\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map);\n+    }\n+\n+    /* This time only remove some entries */\n+    public void testRemove2() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int mapSize = javaMap.size();\n+        int count = 0;\n+        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            keysInMap.remove(mapEntry.getKey());\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertEquals(0.0, map.get(mapEntry.getKey()));\n+            if (count++ > 5)\n+                break;\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map, mapSize, keysInMap);\n+    }\n+\n+    public void testRemoveFromEmpty() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        assertEquals(0.0, map.remove(50));\n+    }\n+\n+    public void testRemoveAbsent() {\n+        Map<Integer, Double> generated = generateAbsent();\n+\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        int mapSize = map.size();\n+        \n+        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(mapSize, map.size());\n+            assertEquals(0.0, map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    /**\n+     * Returns a map with at least 100 elements where each element is absent from javaMap.\n+     */\n+    private Map<Integer, Double> generateAbsent() {\n+        Map<Integer, Double> generated = new HashMap<Integer, Double>();\n+        do {\n+            generated.putAll(generate());\n+            for (Integer key : javaMap.keySet())\n+                generated.remove(key);\n+        } while (generated.size() < 100);\n+        return generated;\n+    }\n+\n+    public void testCopy() {\n+        OpenIntToDoubleHashMap copy =\n+            new OpenIntToDoubleHashMap(createFromJavaMap());\n+        assertEquals(javaMap.size(), copy.size());\n+\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())\n+            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n+    }\n+\n+    public void testContainsKey() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            assertTrue(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n+            assertFalse(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n+            int key = mapEntry.getKey();\n+            assertTrue(map.containsKey(key));\n+            map.remove(key);\n+            assertFalse(map.containsKey(key));\n+        }\n+    }\n+\n+    public void testIterator() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n+        for (int i = 0; i < map.size(); ++i) {\n+            assertTrue(iterator.hasNext());\n+            OpenIntToDoubleHashMap.Entry entry = iterator.next();\n+            int key = entry.key();\n+            assertTrue(map.containsKey(key));\n+            assertEquals(javaMap.get(key), map.get(key), 0);\n+            assertTrue(javaMap.containsKey(key));\n+        }\n+        assertFalse(iterator.hasNext());\n+        try {\n+            iterator.next();\n+        } catch (NoSuchElementException nsee) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConcurrentModification() {\n+        OpenIntToDoubleHashMap map = createFromJavaMap();\n+        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n+        map.put(3, 3);\n+        try {\n+            iterator.next();\n+        } catch (ConcurrentModificationException cme) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Regression test for a bug in findInsertionIndex where the hashing in the second probing\n+     * loop was inconsistent with the first causing duplicate keys after the right sequence\n+     * of puts and removes.\n+     */\n+    public void testPutKeysWithCollisions() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        int key1 = -1996012590;\n+        double value1 = 1.0;\n+        map.put(key1, value1);\n+        int key2 = 835099822;\n+        map.put(key2, value1);\n+        int key3 = 1008859686;\n+        map.put(key3, value1);\n+        assertEquals(value1, map.get(key3));\n+        assertEquals(3, map.size());\n+        \n+        map.remove(key2);\n+        double value2 = 2.0;\n+        map.put(key3, value2);\n+        assertEquals(value2, map.get(key3));\n+        assertEquals(2, map.size());\n+    }\n+    \n+    /**\n+     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n+     * different manner.\n+     */\n+    public void testPutKeysWithCollision2() {\n+        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n+        int key1 = 837989881;\n+        double value1 = 1.0;\n+        map.put(key1, value1);\n+        int key2 = 476463321;\n+        map.put(key2, value1);\n+        assertEquals(2, map.size());\n+        assertEquals(value1, map.get(key2));\n+        \n+        map.remove(key1);\n+        double value2 = 2.0;\n+        map.put(key2, value2);\n+        assertEquals(1, map.size());\n+        assertEquals(value2, map.get(key2));\n+    }\n+\n+}", "timestamp": 1229266610, "metainfo": ""}