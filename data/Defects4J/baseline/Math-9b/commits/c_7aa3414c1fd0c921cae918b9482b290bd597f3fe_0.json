{"sha": "7aa3414c1fd0c921cae918b9482b290bd597f3fe", "log": "improved tests coverage  ", "commit": "\n--- a/src/test/org/apache/commons/math/ode/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/ClassicalRungeKuttaIntegratorTest.java\n           * Math.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n-        TestProblemHandler handler = new TestProblemHandler(pb);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        double error = handler.getMaximalError();\n+        double error = handler.getMaximalValueError();\n         if (i > 4) {\n           assertTrue(error < Math.abs(previousError));\n         }\n         previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       }\n \n     }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() < 2.0e-13);\n-    assertTrue(handler.getMaximalError() < 4.0e-12);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(\"classical Runge-Kutta\", integ.getName());\n   }\n \n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() > 0.0004);\n-    assertTrue(handler.getMaximalError() > 0.005);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n \n--- a/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n       FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                  vecAbsoluteTolerance,\n                                                                  vecRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       RungeKuttaFehlbergIntegrator integ =\n           new DormandPrince54Integrator(minStep, maxStep,\n                                         scalAbsoluteTolerance, scalRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setSafety(0.8);\n       integ.setMaxGrowth(5.0);\n       integ.setMinReduction(0.3);\n       // the 0.7 factor is only valid for this test\n       // and has been obtained from trial and error\n       // there is no general relation between local and global errors\n-      assertTrue(handler.getMaximalError() < (0.7 * scalAbsoluteTolerance));\n+      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n       assertTrue(calls <= previousCalls);\n     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalError() < 5.0e-6);\n+    assertTrue(handler.getMaximalValueError() < 5.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n \n   }\n--- a/src/test/org/apache/commons/math/ode/DormandPrince853IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince853IntegratorTest.java\n       FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                   vecAbsoluteTolerance,\n                                                                   vecRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                   scalAbsoluteTolerance,\n                                                                   scalRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       // the 1.3 factor is only valid for this test\n       // and has been obtained from trial and error\n       // there is no general relation between local and global errors\n-      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n       assertTrue(calls <= previousCalls);\n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                 scalAbsoluteTolerance,\n                                                                 scalRelativeTolerance);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalError() < 5.0e-8);\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n \n   }\n--- a/src/test/org/apache/commons/math/ode/EulerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/EulerIntegratorTest.java\n           * Math.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new EulerIntegrator(step);\n-        TestProblemHandler handler = new TestProblemHandler(pb);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n                         pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        double error = handler.getMaximalError();\n+        double error = handler.getMaximalValueError();\n         if (i > 4) {\n           assertTrue(error < Math.abs(previousError));\n         }\n         previousError = error;\n-      \n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n       }\n \n     }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n     FirstOrderIntegrator integ = new EulerIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n    assertTrue(handler.getLastError() < 2.0e-4);\n-   assertTrue(handler.getMaximalError() < 1.0e-3);\n+   assertTrue(handler.getMaximalValueError() < 1.0e-3);\n+   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n    assertEquals(\"Euler\", integ.getName());\n \n   }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n     FirstOrderIntegrator integ = new EulerIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() > 0.01);\n-    assertTrue(handler.getMaximalError() > 0.2);\n+    assertTrue(handler.getMaximalValueError() > 0.2);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n   \n--- a/src/test/org/apache/commons/math/ode/GillIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/GillIntegratorTest.java\n           * Math.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new GillIntegrator(step);\n-        TestProblemHandler handler = new TestProblemHandler(pb);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        double error = handler.getMaximalError();\n+        double error = handler.getMaximalValueError();\n         if (i > 5) {\n           assertTrue(error < Math.abs(previousError));\n         }\n         previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n       }\n \n     }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n     FirstOrderIntegrator integ = new GillIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() < 2.0e-13);\n-    assertTrue(handler.getMaximalError() < 4.0e-12);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(\"Gill\", integ.getName());\n \n   }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n     FirstOrderIntegrator integ = new GillIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() > 0.0004);\n-    assertTrue(handler.getMaximalError() > 0.005);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n \n--- a/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n       FirstOrderIntegrator integ =\n         new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                          vecAbsoluteTolerance, vecRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       FirstOrderIntegrator integ =\n         new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                          absTolerance, relTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       // the coefficients are only valid for this test\n       // and have been obtained from trial and error\n       // there is no general relation between local and global errors\n-      double ratio =  handler.getMaximalError() / absTolerance;\n+      double ratio =  handler.getMaximalValueError() / absTolerance;\n       assertTrue(ratio < 2.4);\n       assertTrue(ratio > 0.02);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n       assertTrue(calls <= previousCalls);\n \n   private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n     throws DerivativeException, IntegratorException {\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n       integrator.setStepHandler(handler);\n       integrator.integrate(pb,\n                            pb.getInitialTime(), pb.getInitialState(),\n                            pb.getFinalTime(), new double[pb.getDimension()]);\n-      return handler.getMaximalError();\n+      return handler.getMaximalValueError();\n   }\n \n   public void testSwitchingFunctions()\n     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                                                   scalAbsoluteTolerance,\n                                                                   scalRelativeTolerance);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalError() < 5.0e-8);\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n \n   }\n--- a/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n       FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                               vecAbsoluteTolerance,\n                                                               vecRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                               scalAbsoluteTolerance,\n                                                               scalRelativeTolerance);\n-      TestProblemHandler handler = new TestProblemHandler(pb);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n       integ.setStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n       // the 1.3 factor is only valid for this test\n       // and has been obtained from trial and error\n       // there is no general relation between local and global errors\n-      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n       assertTrue(calls <= previousCalls);\n     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                             scalAbsoluteTolerance,\n                                                             scalRelativeTolerance);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalError() < 1.0e-7);\n+    assertTrue(handler.getMaximalValueError() < 1.0e-7);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n \n   }\n--- a/src/test/org/apache/commons/math/ode/MidpointIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/MidpointIntegratorTest.java\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n           * Math.pow(2.0, -i);\n         FirstOrderIntegrator integ = new MidpointIntegrator(step);\n-        TestProblemHandler handler = new TestProblemHandler(pb);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n                         pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        double error = handler.getMaximalError();\n+        double error = handler.getMaximalValueError();\n         if (i > 4) {\n           assertTrue(error < Math.abs(previousError));\n         }\n         previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n       }\n \n     }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n     FirstOrderIntegrator integ = new MidpointIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() < 2.0e-7);\n-    assertTrue(handler.getMaximalError() < 1.0e-6);\n+    assertTrue(handler.getMaximalValueError() < 1.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(\"midpoint\", integ.getName());\n \n   }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n     FirstOrderIntegrator integ = new MidpointIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() > 0.01);\n-    assertTrue(handler.getMaximalError() > 0.05);\n+    assertTrue(handler.getMaximalValueError() > 0.05);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n \n--- a/src/test/org/apache/commons/math/ode/TestProblemHandler.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblemHandler.java\n   /** Associated problem. */\n   private TestProblemAbstract problem;\n \n-  /** Maximal error encountered during the integration. */\n-  private double maxError;\n+  /** Maximal errors encountered during the integration. */\n+  private double maxValueError;\n+  private double maxTimeError;\n \n   /** Error at the end of the integration. */\n   private double lastError;\n   /** Time at the end of integration. */\n   private double lastTime;\n \n+  /** ODE solver used. */\n+  private FirstOrderIntegrator integrator;\n+\n+  /** Expected start for step. */\n+  private double expectedStepStart;\n+\n   /**\n    * Simple constructor.\n    * @param problem problem for which steps should be handled\n+   * @param integrator ODE solver used\n    */\n-  public TestProblemHandler(TestProblemAbstract problem) {\n+  public TestProblemHandler(TestProblemAbstract problem, FirstOrderIntegrator integrator) {\n     this.problem = problem;\n+    this.integrator = integrator;\n     reset();\n   }\n \n   }\n \n   public void reset() {\n-    maxError  = 0;\n-    lastError = 0;\n+    maxValueError = 0;\n+    maxTimeError  = 0;\n+    lastError     = 0;\n+    expectedStepStart = problem.getInitialTime();\n   }\n \n   public void handleStep(StepInterpolator interpolator,\n                          boolean isLast)\n     throws DerivativeException {\n+\n+    double start = integrator.getCurrentStepStart();\n+    maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));\n+    expectedStepStart = start + integrator.getCurrentSignedStepsize();\n \n     double pT = interpolator.getPreviousTime();\n     double cT = interpolator.getCurrentTime();\n       // update the errors\n       for (int i = 0; i < interpolatedY.length; ++i) {\n         double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n-        if (error > maxError) {\n-          maxError = error;\n+        if (error > maxValueError) {\n+          maxValueError = error;\n         }\n       }\n \n   }\n \n   /**\n-   * Get the maximal error encountered during integration.\n-   * @return maximal error\n+   * Get the maximal value error encountered during integration.\n+   * @return maximal value error\n    */\n-  public double getMaximalError() {\n-    return maxError;\n+  public double getMaximalValueError() {\n+    return maxValueError;\n+  }\n+\n+  /**\n+   * Get the maximal time error encountered during integration.\n+   * @return maximal time error\n+   */\n+  public double getMaximalTimeError() {\n+    return maxTimeError;\n   }\n \n   /**\n--- a/src/test/org/apache/commons/math/ode/ThreeEighthesIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/ThreeEighthesIntegratorTest.java\n           * Math.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n-        TestProblemHandler handler = new TestProblemHandler(pb);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        double error = handler.getMaximalError();\n+        double error = handler.getMaximalValueError();\n         if (i > 4) {\n           assertTrue(error < Math.abs(previousError));\n         }\n         previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n       }\n \n     }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() < 2.0e-13);\n-    assertTrue(handler.getMaximalError() < 4.0e-12);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(\"3/8\", integ.getName());\n \n   }\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n \n     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n-    TestProblemHandler handler = new TestProblemHandler(pb);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.setStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getLastError() > 0.0004);\n-    assertTrue(handler.getMaximalError() > 0.005);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n ", "timestamp": 1194115637, "metainfo": ""}