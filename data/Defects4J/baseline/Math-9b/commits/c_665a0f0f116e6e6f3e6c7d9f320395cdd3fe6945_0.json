{"sha": "665a0f0f116e6e6f3e6c7d9f320395cdd3fe6945", "log": "MATH-783 Made the internal \"line\" search use a stopping criterion based on function values instead of domain values (as is the default in \"BrentOptimizer\").   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.PointValuePair;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n+import org.apache.commons.math3.optimization.AbstractConvergenceChecker;\n import org.apache.commons.math3.optimization.MultivariateOptimizer;\n import org.apache.commons.math3.optimization.univariate.BracketFinder;\n import org.apache.commons.math3.optimization.univariate.BrentOptimizer;\n import org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair;\n+import org.apache.commons.math3.optimization.univariate.SimpleUnivariateValueChecker;\n \n /**\n  * Powell algorithm.\n         relativeThreshold = rel;\n         absoluteThreshold = abs;\n \n-        // Line search tolerances can be much lower than the tolerances\n-        // required for the optimizer itself.\n-        final double minTol = 1e-4;\n-        final double lsRel = Math.min(FastMath.sqrt(relativeThreshold), minTol);\n-        final double lsAbs = Math.min(FastMath.sqrt(absoluteThreshold), minTol);\n-        line = new LineSearch(lsRel, lsAbs);\n+        // Line search tolerances can be much less stringent than the tolerances\n+        // required for the optimizer itself. XXX Is it still true with the new checker?\n+        line = new LineSearch(rel, abs);\n     }\n \n     /**\n      */\n     private class LineSearch extends BrentOptimizer {\n         /**\n+         * Value that will pass the precondition check for {@link BrentOptimizer}\n+         * but will not pass the convergence check, so that the custom checker\n+         * will always decide when to stop the line search.\n+         */\n+        private static final double REL_TOL_UNUSED = 1e-15;\n+        /**\n+         * Value that will pass the precondition check for {@link BrentOptimizer}\n+         * but will not pass the convergence check, so that the custom checker\n+         * will always decide when to stop the line search.\n+         */\n+        private static final double ABS_TOL_UNUSED = Double.MIN_VALUE;\n+        /**\n          * Automatic bracketing.\n          */\n         private final BracketFinder bracket = new BracketFinder();\n \n         /**\n+         * The \"BrentOptimizer\" default stopping criterion uses the tolerances\n+         * to check the domain (point) values, not the function values.\n+         * We thus create a custom checker to use function values.\n+         *\n          * @param rel Relative threshold.\n          * @param abs Absolute threshold.\n          */\n         LineSearch(double rel,\n                    double abs) {\n-            super(rel, abs);\n+            super(REL_TOL_UNUSED,\n+                  ABS_TOL_UNUSED,\n+                  new SimpleUnivariateValueChecker(rel, abs));\n         }\n \n         /**\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/PowellOptimizerTest.java\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.MultivariateOptimizer;\n import org.apache.commons.math3.optimization.PointValuePair;\n+import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n             init[i] = maxPoint[i] - 20;\n         }\n         doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);\n+    }\n+\n+    /**\n+     * Ensure that we do not increase the number of function evaluations when\n+     * the function values are scaled up.\n+     * Note that the tolerances parameters passed to the constructor must\n+     * still hold sensible values because they are used to set the line search\n+     * tolerances.\n+     */\n+    @Test\n+    public void testRelativeToleranceOnScaledValues() {\n+        final MultivariateFunction func = new MultivariateFunction() {\n+                public double value(double[] x) {\n+                    final double a = x[0] - 1;\n+                    final double b = x[1] - 1;\n+                    return a * a * FastMath.sqrt(FastMath.abs(a)) + b * b + 1;\n+                }\n+            };\n+\n+        int dim = 2;\n+        final double[] minPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            minPoint[i] = 1;\n+        }\n+\n+        double[] init = new double[dim];\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i] - 20;\n+        }\n+\n+        final double relTol = 1e-10;\n+\n+        final int maxEval = 1000;\n+        // Very small absolute tolerance to rely solely on the relative\n+        // tolerance as a stopping criterion\n+        final MultivariateOptimizer optim = new PowellOptimizer(relTol, 1e-100);\n+\n+        final PointValuePair funcResult = optim.optimize(maxEval, func, GoalType.MINIMIZE, init);\n+        final double funcValue = func.value(funcResult.getPoint());\n+        final int funcEvaluations = optim.getEvaluations();\n+\n+        final double scale = 1e10;\n+        final MultivariateFunction funcScaled = new MultivariateFunction() {\n+                public double value(double[] x) {\n+                    return scale * func.value(x);\n+                }\n+            };\n+\n+        final PointValuePair funcScaledResult = optim.optimize(maxEval, funcScaled, GoalType.MINIMIZE, init);\n+        final double funcScaledValue = funcScaled.value(funcScaledResult.getPoint());\n+        final int funcScaledEvaluations = optim.getEvaluations();\n+\n+        // Check that both minima provide the same objective funciton values,\n+        // within the relative function tolerance.\n+        Assert.assertEquals(1, funcScaledValue / (scale * funcValue), relTol);\n+\n+        // Check that the numbers of evaluations are the same.\n+        Assert.assertEquals(funcEvaluations, funcScaledEvaluations);\n     }\n \n     /**\n         final MultivariateOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));\n \n         final PointValuePair result = optim.optimize(1000, func, goal, init);\n-        final double[] found = result.getPoint();\n+        final double[] point = result.getPoint();\n \n         for (int i = 0, dim = optimum.length; i < dim; i++) {\n-            Assert.assertEquals(optimum[i], found[i], pointTol);\n+            Assert.assertEquals(\"found[\" + i + \"]=\" + point[i] + \" value=\" + result.getValue(),\n+                                optimum[i], point[i], pointTol);\n         }\n     }\n }", "timestamp": 1335434568, "metainfo": ""}