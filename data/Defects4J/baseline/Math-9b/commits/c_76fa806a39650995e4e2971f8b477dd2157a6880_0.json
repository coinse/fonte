{"sha": "76fa806a39650995e4e2971f8b477dd2157a6880", "log": "MATH-621 Removed function \"rescue\" and \"case 190\" in function \"bobyqb\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n             // useful safeguard, but is not invoked in most applications of BOBYQA.\n \n         }\n-        case 190: {\n-            nfsav = getEvaluations();\n-            kbase = trustRegionCenterInterpolationPointIndex;\n-\n-            rescue(xbase, xpt,\n-                    fval, xopt, gopt, hq, pq, bmat,\n-                    zmat, sl, su, delta,\n-                   vlag);\n-\n-            // XOPT is updated now in case the branch below to label 720 is taken.\n-            // Any updating of GOPT occurs after the branch below to label 20, which\n-            // leads to a trust region iteration as does the branch to label 60.\n-\n-            xoptsq = ZERO;\n-            if (trustRegionCenterInterpolationPointIndex != kbase) {\n-                for (int i = 0; i < n; i++) {\n-                    xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n-                    // Computing 2nd power\n-                    final double d1 = xopt.getEntry(i);\n-                    xoptsq += d1 * d1;\n-                }\n-            }\n-            nresc = getEvaluations();\n-            if (nfsav < getEvaluations()) {\n-                nfsav = getEvaluations();\n-                state = 20; break;\n-            }\n-            if (ntrits > 0) {\n-                state = 60; break;\n-            }\n-        }\n         case 210: {\n             // Pick two alternative vectors of variables, relative to XBASE, that\n             // are suitable as new positions of the KNEW-th interpolation point.\n \n             if (ntrits == 0) {\n                 // Computing 2nd power\n-                d__1 = vlag.getEntry(knew); // XXX Same statement as a few lines below?\n-                denom = d__1 * d__1 + alpha * beta;\n+                final double d1 = vlag.getEntry(knew);\n+                denom = d1 * d1 + alpha * beta;\n                 if (denom < cauchy && cauchy > ZERO) {\n                     for (int i = 0; i < n; i++) {\n                         xnew.setEntry(i, xalt.getEntry(i));\n                     cauchy = ZERO; // XXX Useful statement?\n                     state = 230; break;\n                 }\n-                // Computing 2nd power\n-                d__1 = vlag.getEntry(knew); // XXX Same statement as a few lines above?\n-                if (denom <= HALF * (d__1 * d__1)) {\n-                    if (getEvaluations() > nresc) {\n-                        state = 190; break;\n-                    }\n-                    throw new MathIllegalStateException(LocalizedFormats.TOO_MUCH_CANCELLATION, vquad);\n-                }\n-\n                 // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                 // the next interpolation point to be deleted to make room for a trust\n-                // region step. Again RESCUE may be called if rounding errors have damaged\n+                // region step. Again RESCUE may be called if rounding errors have damaged_\n                 // the chosen denominator, which is the reason for attempting to select\n                 // KNEW before calculating the next value of the objective function.\n \n                     d__1 = biglsq;\n                     d__2 = temp * (d__3 * d__3);\n                     biglsq = Math.max(d__1, d__2);\n-                }\n-                if (scaden <= HALF * biglsq) {\n-                    if (getEvaluations() > nresc) {\n-                        state = 190; break;\n-                    }\n-                    throw new MathIllegalStateException(LocalizedFormats.TOO_MUCH_CANCELLATION, vquad);\n                 }\n             }\n \n                 f = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n             }\n             return f;\n+        }\n+        default: {\n+            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n         }}\n     } // bobyqb\n \n             }\n         } while (getEvaluations() < npt);\n     } // prelim\n-\n-    // ----------------------------------------------------------------------------------------\n-\n-    /**\n-     *     The first NDIM+NPT elements of the array W are used for working space.\n-     *     The final elements of BMAT and ZMAT are set in a well-conditioned way\n-     *       to the values that are appropriate for the new interpolation points.\n-     *     The elements of GOPT, HQ and PQ are also revised to the values that are\n-     *       appropriate to the final quadratic model.\n-     *\n-     *     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT,\n-     *       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as\n-     *       the corresponding arguments of BOBYQB on the entry to RESCUE.\n-     *     NF is maintained as the number of calls of CALFUN so far, except that\n-     *       NF is set to -1 if the value of MAXFUN prevents further progress.\n-     *     KOPT is maintained so that FVAL(KOPT) is the least calculated function\n-     *       value. Its correct value must be given on entry. It is updated if a\n-     *       new least function value is found, but the corresponding changes to\n-     *       XOPT and GOPT have to be made later by the calling program.\n-     *     DELTA is the current trust region radius.\n-     *     VLAG is a working space vector that will be used for the values of the\n-     *       provisional Lagrange functions at each of the interpolation points.\n-     *       They are part of a product that requires VLAG to be of length NDIM.\n-     *     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and\n-     *       PTSAUX(2,J) specify the two positions of provisional interpolation\n-     *       points when a nonzero step is taken along e_J (the J-th coordinate\n-     *       direction) through XBASE+XOPT, as specified below. Usually these\n-     *       steps have length DELTA, but other lengths are chosen if necessary\n-     *       in order to satisfy the given bounds on the variables.\n-     *     PTSID is also a working space array. It has NPT components that denote\n-     *       provisional new positions of the original interpolation points, in\n-     *       case changes are needed to restore the linear independence of the\n-     *       interpolation conditions. The K-th point is a candidate for change\n-     *       if and only if PTSID(K) is nonzero. In this case let p and q be the\n-     *       int parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p\n-     *       and q are both positive, the step from XBASE+XOPT to the new K-th\n-     *       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise\n-     *       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or\n-     *       p=0, respectively.\n-     * @param xbase\n-     * @param xpt\n-     * @param fval\n-     * @param xopt\n-     * @param gopt\n-     * @param hq\n-     * @param pq\n-     * @param bmat\n-     * @param zmat\n-     * @param sl\n-     * @param su\n-     * @param delta\n-     * @param vlag\n-     */\n-    private void rescue(\n-            ArrayRealVector xbase,\n-            Array2DRowRealMatrix xpt,\n-            ArrayRealVector fval,\n-            ArrayRealVector xopt,\n-            ArrayRealVector gopt,\n-            ArrayRealVector hq,\n-            ArrayRealVector pq,\n-            Array2DRowRealMatrix bmat,\n-            Array2DRowRealMatrix zmat,\n-            ArrayRealVector sl,\n-            ArrayRealVector su,\n-            double delta,\n-            ArrayRealVector vlag\n-    ) {\n-        // System.out.println(\"rescue\"); // XXX\n-\n-        final int n = currentBest.getDimension();\n-        final int npt = numberOfInterpolationPoints;\n-        final int ndim = bmat.getRowDimension();\n-\n-        final Array2DRowRealMatrix ptsaux = new Array2DRowRealMatrix(n, 2);\n-        final ArrayRealVector ptsid = new ArrayRealVector(npt);\n-\n-        final ArrayRealVector work1 = new ArrayRealVector(npt); // Originally: w(1 .. npt).\n-        final ArrayRealVector work2 = new ArrayRealVector(n); // Originally: w(npt+1 .. npt+n).\n-        final ArrayRealVector work3 = new ArrayRealVector(npt); // Originally: w(npt+n+1 .. npt+n+npt).\n-\n-        final int np = n + 1;\n-        final double sfrac = HALF / (double) np;\n-        final int nptm = npt - np;\n-\n-        // System generated locals\n-        double d__1, d__2, d__3, d__4;\n-\n-\n-        // Local variables\n-        double f;\n-        int ih, jp, ip, iq;\n-        double xp = 0, xq = 0, den = 0;\n-        int ihp = 0;\n-        int jpn, kpt;\n-        double sum = 0, diff = 0, beta = 0;\n-        int kold;\n-        double winc;\n-        int nrem, knew;\n-        double temp, bsum;\n-        double hdiag = 0, fbase = 0, denom = 0, vquad = 0, sumpq = 0;\n-        double dsqmin, distsq, vlmxsq;\n-\n-        // Set some constants.\n-\n-        // Function Body\n-\n-        // Shift the interpolation points so that XOPT becomes the origin, and set\n-        // the elements of ZMAT to zero. The value of SUMPQ is required in the\n-        // updating of HQ below. The squares of the distances from XOPT to the\n-        // other interpolation points are set at the end of W. Increments of WINC\n-        // may be added later to these squares to balance the consideration of\n-        // the choice of point that is going to become current.\n-\n-        sumpq = ZERO;\n-        winc = ZERO;\n-        for (int k = 0; k < npt; k++) {\n-            distsq = ZERO;\n-            for (int j = 0; j < n; j++) {\n-                xpt.setEntry(k, j, xpt.getEntry(k, j) - xopt.getEntry(j));\n-                // Computing 2nd power\n-                final double d1 = xpt.getEntry(k, j);\n-                distsq += d1 * d1;\n-            }\n-            sumpq += pq.getEntry(k);\n-            work3.setEntry(k, distsq);\n-            winc = Math.max(winc, distsq);\n-            for (int j = 0; j < nptm; j++) {\n-                zmat.setEntry(k, j, ZERO);\n-            }\n-        }\n-\n-        // Update HQ so that HQ and PQ define the second derivatives of the model\n-        // after XBASE has been shifted to the trust region centre.\n-\n-        ih = 0;\n-        for (int j = 0; j < n; j++) {\n-            work2.setEntry(j, HALF * sumpq * xopt.getEntry(j));\n-            for (int k = 0; k < npt; k++) {\n-                work2.setEntry(j, work2.getEntry(j) + pq.getEntry(k) * xpt.getEntry(k, j));\n-            }\n-            for (int i = 0; i <= j; i++) {\n-                hq.setEntry(ih, hq.getEntry(ih) + work2.getEntry(i) * xopt.getEntry(j) + work2.getEntry(j) * xopt.getEntry(i));\n-                ih++;\n-            }\n-        }\n-\n-        // Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and\n-        // also set the elements of PTSAUX.\n-\n-        for (int j = 0; j < n; j++) {\n-            xbase.setEntry(j, xbase.getEntry(j) + xopt.getEntry(j));\n-            sl.setEntry(j, sl.getEntry(j) - xopt.getEntry(j));\n-            su.setEntry(j, su.getEntry(j) - xopt.getEntry(j));\n-            xopt.setEntry(j, ZERO);\n-            // Computing MIN\n-            d__1 = delta;\n-            d__2 = su.getEntry(j);\n-            ptsaux.setEntry(j, 0, Math.min(d__1, d__2));\n-            // Computing MAX\n-            d__1 = -delta;\n-            d__2 = sl.getEntry(j);\n-            ptsaux.setEntry(j, 1, Math.max(d__1, d__2));\n-            if (ptsaux.getEntry(j, 0) + ptsaux.getEntry(j, 1) < ZERO) {\n-                temp = ptsaux.getEntry(j, 0);\n-                ptsaux.setEntry(j, 0, ptsaux.getEntry(j, 1));\n-                ptsaux.setEntry(j, 1, temp);\n-            }\n-            d__2 = ptsaux.getEntry(j, 1);\n-            d__1 = ptsaux.getEntry(j, 0);\n-            if (Math.abs(d__2) < HALF * Math.abs(d__1)) {\n-                ptsaux.setEntry(j, 1, HALF * ptsaux.getEntry(j, 0));\n-            }\n-            for (int i = 0; i < ndim; i++) {\n-                bmat.setEntry(i, j, ZERO);\n-            }\n-        }\n-        fbase = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n-\n-        // Set the identifiers of the artificial interpolation points that are\n-        // along a coordinate direction from XOPT, and set the corresponding\n-        // nonzero elements of BMAT and ZMAT.\n-\n-        ptsid.setEntry(0, sfrac);\n-        for (int j = 0; j < n; j++) {\n-            jp = j + 1;\n-            jpn = jp + n;\n-            ptsid.setEntry(jp, 1.0 + j + sfrac);\n-            if (jpn <= npt) {\n-                ptsid.setEntry(jpn, (1.0+j) / (double) np + sfrac);\n-                temp = ONE / (ptsaux.getEntry(j, 0) - ptsaux.getEntry(j, 1));\n-                bmat.setEntry(jp, j, -temp + ONE / ptsaux.getEntry(j, 0));\n-                bmat.setEntry(jpn, j, temp + ONE / ptsaux.getEntry(j, 1));\n-                bmat.setEntry(0, j, -bmat.getEntry(jp, j) - bmat.getEntry(jpn, j));\n-                final double d1 = ptsaux.getEntry(j, 0) * ptsaux.getEntry(j, 1);\n-                zmat.setEntry(0, j,  Math.sqrt(TWO) / Math.abs(d1));\n-                zmat.setEntry(jp, j, zmat.getEntry(0, j) *\n-                        ptsaux.getEntry(j, 1) * temp);\n-                zmat.setEntry(jpn, j, -zmat.getEntry(0, j) *\n-                        ptsaux.getEntry(j, 0) * temp);\n-            } else {\n-                bmat.setEntry(0, j, -ONE / ptsaux.getEntry(j, 0));\n-                bmat.setEntry(jp, j, ONE / ptsaux.getEntry(j, 0));\n-                // Computing 2nd power\n-                final double d1 = ptsaux.getEntry(j, 0);\n-                bmat.setEntry(j + npt, j, -HALF * (d1 * d1));\n-            }\n-        }\n-\n-        // Set any remaining identifiers with their nonzero elements of ZMAT.\n-\n-        if (npt >= n + np) {\n-           for (int k = np << 1; k <= npt; k++) {\n-                int iw = (int) (((double) (k - np) - HALF) / (double) n);\n-                ip = k - np - iw * n;\n-                iq = ip + iw;\n-                if (iq > n) {\n-                    iq -= n;\n-                }\n-                ptsid.setEntry(k, (double) ip + (double) iq / (double) np +\n-                        sfrac);\n-                temp = ONE / (ptsaux.getEntry(ip, 0) * ptsaux.getEntry(iq, 0));\n-                zmat.setEntry(0, (k - np), temp);\n-                zmat.setEntry(ip + 1, k - np, -temp);\n-                zmat.setEntry(iq + 1, k - np, -temp);\n-                zmat.setEntry(k, k - np, temp);\n-            }\n-        }\n-        nrem = npt;\n-        kold = 1;\n-        knew = trustRegionCenterInterpolationPointIndex;\n-\n-        // Reorder the provisional points in the way that exchanges PTSID(KOLD)\n-        // with PTSID(KNEW).\n-\n-        int state = 80;\n-        for(;;) switch (state) {\n-        case 80: {\n-            for (int j = 0; j < n; j++) {\n-                temp = bmat.getEntry(kold, j);\n-                bmat.setEntry(kold, j, bmat.getEntry(knew, j));\n-                bmat.setEntry(knew, j, temp);\n-            }\n-            for (int j = 0; j < nptm; j++) {\n-                temp = zmat.getEntry(kold, j);\n-                zmat.setEntry(kold, j, zmat.getEntry(knew, j));\n-                zmat.setEntry(knew, j, temp);\n-            }\n-            ptsid.setEntry(kold, ptsid.getEntry(knew));\n-            ptsid.setEntry(knew, ZERO);\n-            work3.setEntry(knew, ZERO);\n-            --nrem;\n-            if (knew != trustRegionCenterInterpolationPointIndex) {\n-                temp = vlag.getEntry(kold);\n-                vlag.setEntry(kold, vlag.getEntry(knew));\n-                vlag.setEntry(knew, temp);\n-\n-                // Update the BMAT and ZMAT matrices so that the status of the KNEW-th\n-                // interpolation point can be changed from provisional to original. The\n-                // branch to label 350 occurs if all the original points are reinstated.\n-                // The nonnegative values of W(NDIM+K) are required in the search below.\n-\n-                update(bmat, zmat, vlag,\n-                        beta, denom, knew);\n-\n-                if (nrem == 0) {\n-                    return;\n-                }\n-                for (int k = 0; k < npt; k++) {\n-                    work3.setEntry(k, Math.abs(work3.getEntry(k)));\n-                }\n-            }\n-\n-            // Pick the index KNEW of an original interpolation point that has not\n-            // yet replaced one of the provisional interpolation points, giving\n-            // attention to the closeness to XOPT and to previous tries with KNEW.\n-        }\n-        case 120: {\n-            dsqmin = ZERO;\n-            for (int k = 0; k < npt; k++) {\n-                final double v1 = work3.getEntry(k);\n-                if (v1 > ZERO) {\n-                    if (dsqmin == ZERO ||\n-                        v1 < dsqmin) {\n-                        knew = k;\n-                        dsqmin = v1;\n-                    }\n-                }\n-            }\n-            if (dsqmin == ZERO) {\n-                state = 260; break;\n-            }\n-\n-            // Form the W-vector of the chosen original interpolation point.\n-\n-            for (int j = 0; j < n; j++) {\n-                work2.setEntry(j, xpt.getEntry(knew, j));\n-            }\n-            for (int k = 0; k < npt; k++) {\n-                sum = ZERO;\n-                if (k == trustRegionCenterInterpolationPointIndex) {\n-                } else if (ptsid.getEntry(k) == ZERO) {\n-                    for (int j = 0; j < n; j++) {\n-                        sum += work2.getEntry(j) * xpt.getEntry(k, j);\n-                    }\n-                } else {\n-                    ip = (int) ptsid.getEntry(k);\n-                    if (ip > 0) {\n-                        sum = work2.getEntry(ip - 1) * ptsaux.getEntry(ip - 1, 0);\n-                    }\n-                    iq = (int) ((double) np * ptsid.getEntry(k) - (double) (ip * np));\n-                    if (iq > 0) {\n-                        int iw = 0;\n-                        if (ip == 0) {\n-                            iw = 1;\n-                        }\n-                        sum += work2.getEntry(iq - 1) * ptsaux.getEntry(iq - 1, iw);\n-                    }\n-                }\n-                work1.setEntry(k, HALF * sum * sum);\n-            }\n-\n-            // Calculate VLAG and BETA for the required updating of the H matrix if\n-            // XPT(KNEW,.) is reinstated in the set of interpolation points.\n-\n-            for (int k = 0; k < npt; k++) {\n-                sum = ZERO;\n-                for (int j = 0; j < n; j++) {\n-                    sum += bmat.getEntry(k, j) * work2.getEntry(j);\n-                }\n-                vlag.setEntry(k, sum);\n-            }\n-            beta = ZERO;\n-            for (int j = 0; j < nptm; j++) {\n-                sum = ZERO;\n-                for (int k = 0; k < npt; k++) {\n-                    sum += zmat.getEntry(k, j) * work1.getEntry(k);\n-                }\n-                beta -= sum * sum;\n-                for (int k = 0; k < npt; k++) {\n-                    vlag.setEntry(k, vlag.getEntry(k) + sum * zmat.getEntry(k, j));\n-                }\n-            }\n-            bsum = ZERO;\n-            distsq = ZERO;\n-            for (int j = 0; j < n; j++) {\n-                sum = ZERO;\n-                for (int k = 0; k < npt; k++) {\n-                    sum += bmat.getEntry(k, j) * work1.getEntry(k);\n-                }\n-                jp = j + npt;\n-                bsum += sum * work2.getEntry(j);\n-                for (int k = 0; k < n; k++) {\n-                    sum += bmat.getEntry(npt + k, j) * work2.getEntry(k);\n-                }\n-                bsum += sum * work2.getEntry(j);\n-                vlag.setEntry(jp, sum);\n-                // Computing 2nd power\n-                final double d1 = xpt.getEntry(knew, j);\n-                distsq += d1 * d1;\n-            }\n-            beta = HALF * distsq * distsq + beta - bsum;\n-            vlag.setEntry(trustRegionCenterInterpolationPointIndex, vlag.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n-\n-            // KOLD is set to the index of the provisional interpolation point that is\n-            // going to be deleted to make way for the KNEW-th original interpolation\n-            // point. The choice of KOLD is governed by the avoidance of a small value\n-            // of the denominator in the updating calculation of UPDATE.\n-\n-            denom = ZERO;\n-            vlmxsq = ZERO;\n-            for (int k = 0; k < npt; k++) {\n-                if (ptsid.getEntry(k) != ZERO) {\n-                    hdiag = ZERO;\n-                    for (int j = 0; j < nptm; j++) {\n-                        // Computing 2nd power\n-                        final double d1 = zmat.getEntry(k, j);\n-                        hdiag += d1 * d1;\n-                    }\n-                    // Computing 2nd power\n-                    final double d1 = vlag.getEntry(k);\n-                    den = beta * hdiag + d1 * d1;\n-                    if (den > denom) {\n-                        kold = k;\n-                        denom = den;\n-                    }\n-                }\n-                // Computing MAX\n-                // Computing 2nd power\n-                final double d3 = vlag.getEntry(k);\n-                vlmxsq = Math.max(vlmxsq , d3 * d3);\n-            }\n-            if (denom <= vlmxsq * .01) {\n-                work3.setEntry(knew, -work3.getEntry(knew) - winc);\n-                state = 120; break;\n-            }\n-            state = 80; break;\n-\n-            // When label 260 is reached, all the final positions of the interpolation\n-            // points have been chosen although any changes have not been included yet\n-            // in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart\n-            // from the shift of XBASE, the updating of the quadratic model remains to\n-            // be done. The following cycle through the new interpolation points begins\n-            // by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero,\n-            // except that a RETURN occurs if MAXFUN prohibits another value of F.\n-\n-        }\n-        case 260: {\n-            for (kpt = 0; kpt < npt; kpt++) {\n-                if (ptsid.getEntry(kpt) == ZERO) {\n-                    continue;\n-                }\n-                ih = 0;\n-                for (int j = 0; j < n; j++) {\n-                    work2.setEntry(j, xpt.getEntry(kpt, j));\n-                    xpt.setEntry(kpt, j, ZERO);\n-                    temp = pq.getEntry(kpt) * work2.getEntry(j);\n-                    for (int i = 0; i <= j; i++) {\n-                        hq.setEntry(ih, hq.getEntry(ih) + temp * work2.getEntry(i));\n-                        ih++;\n-                    }\n-                }\n-                pq.setEntry(kpt, ZERO);\n-                ip = (int) ptsid.getEntry(kpt);\n-                iq = (int) ((double) np * ptsid.getEntry(kpt) - (double) (ip * np));\n-                if (ip > 0) {\n-                    xp = ptsaux.getEntry(ip - 1, 0);\n-                    xpt.setEntry(kpt, ip - 1, xp);\n-                }\n-                if (iq > 0) {\n-                    xq = ptsaux.getEntry(iq - 1, 0);\n-                    if (ip == 0) {\n-                        xq = ptsaux.getEntry(iq - 1, 1);\n-                    }\n-                    xpt.setEntry(kpt, iq - 1, xq);\n-                }\n-\n-                // Set VQUAD to the value of the current model at the new point.\n-\n-                vquad = fbase;\n-                if (ip > 0) {\n-                    ihp = (ip + ip * ip) / 2;\n-                    vquad += xp * (gopt.getEntry(ip - 1) + HALF * xp * hq.getEntry(ihp - 1));\n-                }\n-                if (iq > 0) {\n-                    int ihq = (iq + iq * iq) / 2;\n-                    vquad += xq * (gopt.getEntry(iq - 1) + HALF * xq * hq.getEntry(ihq - 1));\n-                    if (ip > 0) {\n-                        int iiw = Math.max(ihp, ihq) - Math.abs(ip - iq);\n-                        vquad += xp * xq * hq.getEntry(iiw - 1);\n-                    }\n-                }\n-                for (int k = 0; k < npt; k++) {\n-                    temp = ZERO;\n-                    if (ip > 0) {\n-                        temp += xp * xpt.getEntry(k, ip - 1);\n-                    }\n-                    if (iq > 0) {\n-                        temp += xq * xpt.getEntry(k, iq - 1);\n-                    }\n-                    vquad += HALF * pq.getEntry(k) * temp * temp;\n-                }\n-\n-                // Calculate F at the new interpolation point, and set DIFF to the factor\n-                // that is going to multiply the KPT-th Lagrange function when the model\n-                // is updated to provide interpolation to the new function value.\n-\n-                for (int i = 0; i < n; i++) {\n-                    // Computing MIN\n-                    // Computing MAX\n-                    d__3 = lowerBound[i];\n-                    d__4 = xbase.getEntry(i) + xpt.getEntry(kpt, i);\n-                    d__1 = Math.max(d__3, d__4);\n-                    d__2 = upperBound[i];\n-                    work2.setEntry(i, Math.min(d__1, d__2));\n-                    if (xpt.getEntry(kpt, i) == sl.getEntry(i)) {\n-                        work2.setEntry(i, lowerBound[i]);\n-                    }\n-                    if (xpt.getEntry(kpt, i) == su.getEntry(i)) {\n-                        work2.setEntry(i, upperBound[i]);\n-                    }\n-                }\n-\n-                f = computeObjectiveValue(work2.getData());\n-\n-                if (!isMinimize)\n-                    f = -f;\n-                fval.setEntry(kpt, f);\n-                if (f < fval.getEntry(trustRegionCenterInterpolationPointIndex)) {\n-                    trustRegionCenterInterpolationPointIndex = kpt;\n-                }\n-                diff = f - vquad;\n-\n-                // Update the quadratic model. The RETURN from the subroutine occurs when\n-                // all the new interpolation points are included in the model.\n-\n-                for (int i = 0; i < n; i++) {\n-                    gopt.setEntry(i, gopt.getEntry(i) + diff * bmat.getEntry(kpt, i));\n-                }\n-                for (int k = 0; k < npt; k++) {\n-                    sum = ZERO;\n-                    for (int j = 0; j < nptm; j++) {\n-                        sum += zmat.getEntry(k, j) * zmat.getEntry(kpt, j);\n-                    }\n-                    temp = diff * sum;\n-                    if (ptsid.getEntry(k) == ZERO) {\n-                        pq.setEntry(k, pq.getEntry(k) + temp);\n-                    } else {\n-                        ip = (int) ptsid.getEntry(k);\n-                        iq = (int) ((double) np * ptsid.getEntry(k) - (double) (ip * np));\n-                        int ihq = (iq * iq + iq) / 2;\n-                        if (ip == 0) {\n-                            // Computing 2nd power\n-                            final double d1 = ptsaux.getEntry(iq - 1, 1);\n-                            hq.setEntry(ihq - 1, hq.getEntry(ihq - 1) + temp * (d1 * d1));\n-                        } else {\n-                            ihp = (ip * ip + ip) / 2;\n-                            // Computing 2nd power\n-                            final double d1 = ptsaux.getEntry(ip - 1, 0);\n-                            hq.setEntry(ihp - 1, hq.getEntry(ihp - 1) + temp * (d1 * d1));\n-                            if (iq > 0) {\n-                                // Computing 2nd power\n-                                final double d2 = ptsaux.getEntry(iq - 1, 0);\n-                                hq.setEntry(ihq - 1, hq.getEntry(ihq - 1) + temp * (d2 * d2));\n-                                int iw = Math.max(ihp,ihq) - Math.abs(iq - ip);\n-                                hq.setEntry(iw - 1, hq.getEntry(iw - 1)\n-                                            + temp * ptsaux.getEntry(ip - 1, 0) * ptsaux.getEntry(iq - 1, 0));\n-                            }\n-                        }\n-                    }\n-                }\n-                ptsid.setEntry(kpt, ZERO);\n-            }\n-            return;\n-        }}\n-    } // rescue\n-\n \n \n     // ----------------------------------------------------------------------------------------\n                 hred.setEntry(i, hs.getEntry(i));\n             }\n             state = 120; break;\n+        }\n+        default: {\n+            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n         }}\n     } // trsbox\n \n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n                GoalType.MINIMIZE, \n                1e-13, 1e-6, lowMaxEval, null);\n      }\n-\n-    @Test(expected=TooManyEvaluationsException.class)\n-    public void testRescue() {\n-        double[] startPoint = point(DIM, 1);\n-        double[][] boundaries = null;\n-        RealPointValuePair expected =  new RealPointValuePair(point(DIM, 0), 0);\n-        doTest(new MinusElli(), startPoint, boundaries,\n-               GoalType.MINIMIZE, \n-               1e-13, 1e-6, 1000, expected);\n-    }\n \n     @Test\n     public void testRosen() {", "timestamp": 1313529356, "metainfo": ""}