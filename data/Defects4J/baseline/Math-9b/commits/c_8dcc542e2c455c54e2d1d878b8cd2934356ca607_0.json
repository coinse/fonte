{"sha": "8dcc542e2c455c54e2d1d878b8cd2934356ca607", "log": "Combined Expandable, ContractableDoubleArrays into ResizableDoubleArray and dropped FixedDoubleArray.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/DescriptiveStatisticsImpl.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/DescriptiveStatisticsImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.util.ContractableDoubleArray;\n+import org.apache.commons.math.util.ResizableDoubleArray;\n \n /**\n  * Default implementation of\n  * {@link org.apache.commons.math.stat.univariate.DescriptiveStatistics}.\n  * \n- * @version $Revision: 1.6 $ $Date: 2004/06/01 21:34:35 $\n+ * @version $Revision: 1.7 $ $Date: 2004/06/14 21:41:33 $\n  */\n public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {\n \n     /** \n      *  Stored data values\n      */\n-    protected ContractableDoubleArray eDA;\n+    protected ResizableDoubleArray eDA;\n \n     /**\n      * Construct a DescriptiveStatisticsImpl with infinite window\n      */\n     public DescriptiveStatisticsImpl(int window) {\n     \tsuper();\n-    \teDA = new ContractableDoubleArray();\n+    \teDA = new ResizableDoubleArray();\n         setWindowSize(window);\n     }\n \n--- a/src/java/org/apache/commons/math/util/DoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/DoubleArray.java\n \n \n /**\n- * Provides a single interface for dealing with various flavors\n- * of double arrays.  This arrays framework follows the model of the\n- * Collections API by allowing a user to select from a number of \n- * array implementations with support for various storage mechanisms\n+ * Provides a standard interface for double arrays.  Allows different\n+ * array implementations to support various storage mechanisms\n  * such as automatic expansion, contraction, and array \"rolling\".\n  * \n- * @version $Revision: 1.11 $ $Date: 2004/06/08 14:19:40 $\n+ * @version $Revision: 1.12 $ $Date: 2004/06/14 21:41:33 $\n  */\n public interface DoubleArray {\n \n     /**\n      * Returns the number of elements currently in the array.  Please note\n-     * that this is different from the length of the internal storage array.  \n+     * that this may be different from the length of the internal storage array.  \n+     * \n      * @return number of elements\n      */\n     int getNumElements();\n     double getElement(int index);\n \n     /**\n-     * Sets the element at the specified index.  This method may expand the \n-     * internal storage array to accomodate the insertion of a value at an \n-     * index beyond the current capacity.\n+     * Sets the element at the specified index.  If the specified index is greater than\n+     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n+     * is increased to <code>index +1</code> and additional storage is allocated \n+     * (if necessary) for the new element and all  (uninitialized) elements \n+     * between the new element and the previous end of the array).\n      * \n      * @param index index to store a value in\n      * @param value value to store at the specified index\n     void addElement(double value);\n \n     /**\n-     * Adds an element and moves the window of elements up one.  This\n-     * has the effect of a FIFO.  when you \"roll\" the array an element may be \n-     * removed from the array.  In this case, the return value of this function is the \n-     * discarded double.  In some implementations, removal will only occur when\n-     * the array has reached a capacity threshold.  \n      * <p>\n-     * When removal does occur, the effect is to add an element to the end of the\n-     * array and to discard the element at the beginning of the array.\n+     * Adds an element to the end of the array and removes the first\n+     * element in the array.  Returns the discarded first element.\n+     * The effect is similar to a push operation in a FIFO queue.\n+     * </p>\n+     * <p>\n+     * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n+     * and addElementRolling(5) is invoked, the result is an array containing\n+     * the entries 2, 3, 4, 5 and the value returned is 1.\n+     * </p>\n      * \n      * @param value the value to be added to the array\n      * @return the value which has been discarded or \"pushed\" out of the array\n-     *         by this rolling insert or null if no value has been discarded\n+     *         by this rolling insert\n      */\n     double addElementRolling(double value);\n \n     /**\n-     * Returns a double[] of elements\n+     * Returns a double[] array containing the elements of this \n+     * <code>DoubleArray</code>.  If the underlying implementation is \n+     * array-based, this method should always return a copy, rather than a \n+     * reference to the underlying array so that changes made to the returned\n+     *  array have no effect on the <code>DoubleArray.</code>\n      *\n      * @return all elements added to the array\n      */\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>\n+ * A variable length {@link DoubleArray} implementation that automatically \n+ * handles expanding and contracting its internal storage array as elements \n+ * are added and removed.\n+ * </p>\n+ * <p>\n+ *  The internal storage array starts with capacity determined by the\n+ * <code>initialCapacity</code> property, which can be set by the constructor.\n+ * The default initial capacity is 16.  Adding elements using \n+ * {@link #addElement(double)} appends elements to the end of the array.  When \n+ * there are no open entries at the end of the internal storage array, the \n+ * array is expanded.  The size of the expanded array depends on the \n+ * <code>expansionMode</code> and <code>expansionFactor</code> properties.  \n+ * The <code>expansionMode</code> determines whether the size of the array is \n+ * multiplied by the <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n+ * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n+ * storage locations added).  The default <code>expansionMode</code> is \n+ * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n+ * is 2.0.\n+ * </p>\n+ * <p>\n+ * The {@link #addElementRolling(double)} method adds a new element to the end\n+ * of the internal storage array and adjusts the \"usable window\" of the \n+ * internal array forward by one position (effectively making what was the \n+ * second element the first, and so on).  Repeated activations of this method\n+ * (or activation of {@link #discardFrontElements(int)}) will effectively orphan\n+ * the storage locations at the beginning of the internal storage array.  To\n+ * reclaim this storage, each time one of these methods is activated, the size\n+ * of the internal storage array is compared to the number of addressable \n+ * elements (the <code>numElements</code> property) and if the difference\n+ * is too large, the internal array is contracted to size \n+ * <code>numElements + 1.</code>  The determination of when the internal\n+ * storage array is \"too large\" depends on the <code>expansionMode</code> and\n+ * <code>contractionFactor</code> properties.  If  the <code>expansionMode</code>\n+ * is <code>MULTIPLICATIVE_MODE</code>, contraction is triggered when the\n+ * ratio between storage array length and <code>numElements</code> exceeds\n+ * <code>contractionFactor.</code>  If the <code>expansionMode</code>\n+ * is <code>ADDITIVE_MODE,</code> the number of excess storage locations\n+ * is compared to <code>contractionFactor.</code>  \n+ * </p>\n+ * <p>\n+ * To avoid cycles of expansions and contractions, the \n+ * <code>expansionFactor</code> must not exceed the \n+ * <code>contractionFactor.</code> Constructors and mutators for both of these\n+ * properties enforce this requirement, throwing IllegalArgumentException if it\n+ * is violated.\n+ * </p>\n+ * <p>\n+ * @version $Revision: 1.1 $ $Date: 2004/06/14 21:41:33 $\n+ */\n+public class ResizableDoubleArray implements DoubleArray, Serializable {\n+    \n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -3485529955529426875L; \n+    \n+    /** additive expansion mode */\n+    public static final int ADDITIVE_MODE = 1;\n+    \n+    /** multiplicative expansion mode */\n+    public static final int MULTIPLICATIVE_MODE = 0;\n+   \n+    /** \n+     * The contraction criteria determines when the internal array will be \n+     * contracted to fit the number of elements contained in the element\n+     *  array + 1.\n+     */\n+    protected float contractionCriteria = 2.5f;\n+\n+    /** \n+     * The expansion factor of the array.  When the array needs to be expanded, \n+     * the new array size will be \n+     * <code>internalArray.length * expansionFactor</code>\n+     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE, or\n+     * <code>internalArray.length + expansionFactor</code> if \n+     * <code>expansionMode</code> is set to ADDITIVE_MODE.\n+     */\n+    protected float expansionFactor = 2.0f;\n+    \n+    /**\n+     * Determines whether array expansion by <code>expansionFactor</code>\n+     * is additive or multiplicative.\n+     */\n+    protected int expansionMode = MULTIPLICATIVE_MODE;\n+\n+    /**\n+     * The initial capacity of the array.  Initial capacity is not exposed as a\n+     * property as it is only meaningful when passed to a constructor.\n+     */\n+    protected int initialCapacity = 16;\n+    \n+    /** \n+     * The internal storage array.\n+     */\n+    protected double[] internalArray;\n+\n+    /** \n+     * The number of addressable elements in the array.  Note that this\n+     * has nothing to do with the length of the internal storage array.\n+     */\n+    protected int numElements = 0;\n+\n+    /** \n+     * The position of the first addressable element in the internal storage\n+     * array.  The addressable elements in the array are <code>\n+     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n+     * </code>\n+     */\n+    protected int startIndex = 0;\n+\n+    /**\n+     * Create a ResizableArray with default properties.\n+     * <ul>\n+     * <li><code>initialCapacity = 16</code></li>\n+     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n+     * <li><code>expansionFactor = 2.5</code></li>\n+     * <li><code>contractionFactor = 2.0</code></li>\n+     * </ul>\n+     */\n+    public ResizableDoubleArray() {\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Create a ResizableArray with the specified initial capacity.  Other\n+     * properties take default values:\n+      * <ul>\n+     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n+     * <li><code>expansionFactor = 2.5</code></li>\n+     * <li><code>contractionFactor = 2.0</code></li>\n+     * </ul>\n+     * @param initialCapacity The initial size of the internal storage array\n+     * @throws IllegalArgumentException if initialCapacity is not > 0\n+     */\n+    public ResizableDoubleArray(int initialCapacity) {\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[this.initialCapacity];\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a ResizableArray with the specified initial capacity \n+     * and expansion factor.  The remaining properties take default\n+     * values:\n+     * <ul>\n+     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n+     * <li><code>contractionFactor = 0.5 + expansionFactor</code></li>\n+     * </ul></p>\n+     * <p>\n+     * Throws IllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     * <li><code>initialCapacity > 0</code></li>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * </ul></p>\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     * @throws IllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor) {\n+        this.expansionFactor = expansionFactor;\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+        setContractionCriteria(expansionFactor +0.5f);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a ResizableArray with the specified initialCapacity, \n+     * expansionFactor, and contractionCriteria. The <code>expansionMode</code>\n+     * will default to <code>MULTIPLICATIVE_MODE.</code></p>\n+     * <p>\n+     * Throws IllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     * <li><code>initialCapacity > 0</code></li>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * <li><code>contractionFactor >= expansionFactor</code></li>\n+     * </ul></p>\n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     * @param contractionCriteria The contraction Criteria.\n+     * @throws IllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n+        float contractionCriteria) {\n+        this.expansionFactor = expansionFactor;\n+        setContractionCriteria(contractionCriteria);\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+    }\n+    \n+    /**\n+     * <p>\n+     * Create a ResizableArray with the specified properties.</p>\n+    * <p>\n+     * Throws IllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     * <li><code>initialCapacity > 0</code></li>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * <li><code>contractionFactor >= expansionFactor</code></li>\n+     * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>\n+     * </li>\n+     * </ul></p>\n+     * \n+     * @param initialCapacity the initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     * @param contractionCriteria the contraction Criteria\n+     * @param expansionMode  the expansion mode\n+     * @throws IllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n+            float contractionCriteria, int expansionMode) {\n+        this.expansionFactor = expansionFactor;\n+        setContractionCriteria(contractionCriteria);\n+        setInitialCapacity(initialCapacity);\n+        setExpansionMode(expansionMode);\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array.\n+     * \n+     * @param value to be added to end of array\n+     */\n+    public synchronized void addElement(double value) {\n+        numElements++;\n+        if ((startIndex + numElements) > internalArray.length) {\n+            expand();\n+        }\n+        internalArray[startIndex + (numElements - 1)] = value;\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds an element to the end of the array and removes the first\n+     * element in the array.  Returns the discarded first element.\n+     * The effect is similar to a push operation in a FIFO queue.\n+     * </p>\n+     * <p>\n+     * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n+     * and addElementRolling(5) is invoked, the result is an array containing\n+     * the entries 2, 3, 4, 5 and the value returned is 1.\n+     * </p>\n+     * \n+     * @param value the value to be added to the array\n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     *         by this rolling insert\n+     */\n+    public synchronized double addElementRolling(double value) {\n+        double discarded = internalArray[startIndex];\n+\n+        if ((startIndex + (numElements + 1)) > internalArray.length) {\n+            expand();\n+        }\n+        // Increment the start index\n+        startIndex += 1;\n+\n+        // Add the new value\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        // Check the contraction criteria\n+        if (shouldContract()) {\n+            contract();\n+        }\n+        return discarded;\n+    }\n+\n+    /**\n+     * Checks the expansion factor and the contraction criteria and throws an \n+     * IllegalArgumentException if the contractionCriteria is less than the \n+     * expansionCriteria\n+     * \n+     * @param expansionFactor factor to be checked\n+     * @param contractionCritera critera to be checked\n+     * @throws IllegalArgumentException if the contractionCriteria is less than\n+     *         the expansionCriteria.\n+     */\n+    protected void checkContractExpand(\n+        float contractionCritera,\n+        float expansionFactor) {\n+\n+        if (contractionCritera < expansionFactor) {\n+            String msg =\n+                \"Contraction criteria can never be smaller than \" +\n+                \"the expansion factor.  This would lead to a never \" +\n+                \"ending loop of expansion and contraction as a newly \" +\n+                \"expanded internal storage array would immediately \" +\n+                \"satisfy the criteria for contraction\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        if (contractionCriteria <= 1.0) {\n+            String msg =\n+                \"The contraction criteria must be a number larger \" +\n+                \"than one.  If the contractionCriteria is less than or \" +\n+                \"equal to one an endless loop of contraction and \" +\n+                \"expansion would ensue as an internalArray.length \" +\n+                \"== numElements would satisfy the contraction criteria\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        if (expansionFactor <= 1.0) {\n+            String msg =\n+                \"The expansion factor must be a number greater than 1.0\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+    \n+    /**\n+     * Clear the array, reset the size to the initialCapacity and the number \n+     * of elements to zero.\n+     */\n+    public synchronized void clear() {\n+        numElements = 0;\n+        internalArray = new double[initialCapacity];\n+    }\n+    \n+    /**\n+     * Contracts the storage array to the (size of the element set) + 1 - to \n+     * avoid a zero length array. This function also resets the startIndex to \n+     * zero. \n+     */\n+    public synchronized void contract() {\n+        double[] tempArray = new double[numElements + 1];\n+\n+        // Copy and swap - copy only the element array from the src array.\n+        System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n+        internalArray = tempArray;\n+\n+        // Reset the start index to zero\n+        startIndex = 0;\n+    }\n+\n+    /**\n+     * Discards the <code>i<code> initial elements of the array.  For example,\n+     * if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardFrontElements(2)</code> will cause the first two elements \n+     * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n+     * if i exceeds numElements.\n+     * \n+     * @param i  the number of elements to discard from the front of the array\n+     * @throws IllegalArgumentException if i is greater than numElements.\n+     */\n+    public synchronized void discardFrontElements(int i) {\n+        if (i > numElements) {\n+            String msg = \"Cannot discard more elements than are\" +\n+            \"contained in this array.\";\n+            throw new IllegalArgumentException(msg);\n+        } else if (i < 0) {\n+            String msg = \"Cannot discard a negative number of elements.\";\n+            throw new IllegalArgumentException(msg);\n+        } else {\n+            // \"Subtract\" this number of discarded from numElements \n+            numElements -= i;\n+            startIndex += i;\n+        }\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * Expands the internal storage array using the expansion factor.\n+     * <p>\n+     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n+     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n+     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n+     * after expansion will be <code>internalArray.length + expansionFactor</code>\n+     */\n+    protected synchronized void expand() {\n+\n+        // notice the use of Math.ceil(), this gaurantees that we will always \n+        // have an array of at least currentSize + 1.   Assume that the \n+        // current initial capacity is 1 and the expansion factor\n+        // is 1.000000000000000001.  The newly calculated size will be \n+        // rounded up to 2 after the multiplication is performed.\n+        int newSize = 0;\n+        if (expansionMode == MULTIPLICATIVE_MODE) {\n+            newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n+        } else {\n+            newSize = internalArray.length + Math.round(expansionFactor);\n+        }\n+        double[] tempArray = new double[newSize];\n+\n+        // Copy and swap\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+        internalArray = tempArray;\n+    }\n+    \n+    /**\n+     * Expands the internal storage array to the specified size.\n+     * \n+     * @param size Size of the new internal storage array\n+     */\n+    private synchronized void expandTo(int size) {\n+        double[] tempArray = new double[size];\n+        // Copy and swap\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+        internalArray = tempArray;\n+    }\n+\n+    /**\n+     * The contraction criteria defines when the internal array will contract \n+     * to store only the number of elements in the element array.   \n+     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n+     * contraction is triggered when the ratio between storage array length \n+     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n+     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n+     * number of excess storage locations is compared to \n+     * <code>contractionFactor.</code>   \n+     * \n+     * @return the contraction criteria used to reclaim memory.\n+     */\n+    public float getContractionCriteria() {\n+        return contractionCriteria;\n+    }\n+    \n+    /**\n+     * Returns the element at the specified index\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n+     *         zero or is greater than <code>getNumElements() - 1</code>.\n+     */\n+    public double getElement(int index) {\n+        double value = Double.NaN;\n+        if (index >= numElements) {\n+            String msg =\n+                \"The index specified: \" + index +\n+                \" is larger than the current number of elements\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else if (index >= 0) {\n+            value = internalArray[startIndex + index];\n+        } else {\n+            String msg =\n+                \"Elements cannot be retrieved from a negative array index\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        }\n+        return value;\n+    }\n+    \n+     /**\n+     * Returns a double[] array containing the elements of this \n+     * <code>ResizableArray</code>.  This method returns a copy, not a\n+     * reference to the underlying array, so that changes made to the returned\n+     *  array have no effect on this <code>ResizableArray.</code>\n+     */\n+    public double[] getElements() {\n+        double[] elementArray = new double[numElements];\n+        System.arraycopy( internalArray, startIndex, elementArray, 0,\n+                numElements);\n+        return elementArray;\n+    }\n+    \n+    /**\n+     * The expansion factor controls the size of a new aray when an array \n+     * needs to be expanded.  The <code>expansionMode</code>\n+     * determines whether the size of the array is multiplied by the \n+     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n+     * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n+     * storage locations added).  The default <code>expansionMode</code> is \n+     * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n+     * is 2.0.\n+     * \n+     * @return the expansion factor of this expandable double array\n+     */\n+    public float getExpansionFactor() {\n+        return expansionFactor;\n+    }\n+    \n+    /**\n+     * The <code>expansionMode</code> determines whether the internal storage \n+     * array grows additively (ADDITIVE_MODE) or multiplicatively \n+     * (MULTIPLICATIVE_MODE) when it is expanded.\n+     * \n+     * @return Returns the expansionMode.\n+     */\n+    public int getExpansionMode() {\n+        return expansionMode;\n+    }\n+    \n+    /**\n+     * Notice the package scope on this method.   This method is simply here \n+     * for the JUnit test, it allows us check if the expansion is working \n+     * properly after a number of expansions.  This is not meant to be a part \n+     * of the public interface of this class.\n+     * \n+     * @return the length of the internal storage array.\n+     */\n+    int getInternalLength() {\n+        return (internalArray.length);\n+    }\n+\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this is different from the length of the internal storage array.  \n+     *\n+     * @return number of elements\n+     */\n+    public int getNumElements() {\n+        return (numElements);\n+    }\n+    \n+    /**\n+     * Returns the internal storage array.  Note that this method returns\n+     * a reference to the internal storage array, not a copy, and to correctly\n+     * address elements of the array, the <code>startIndex</code> is\n+     * required (available via the {@link #start} method).  This method should\n+     * only be used in cases where copying the internal array is not practical.\n+     * The {@link #getElements} method should be used in all other cases.\n+     *\n+     * \n+     * @return the internal storage array used by this object\n+     */\n+    public double[] getValues() {\n+        return (internalArray);\n+    }\n+\n+    /**\n+     * Sets the contraction criteria for this ExpandContractDoubleArray. \n+     * \n+     * @param contractionCriteria contraction criteria\n+     */\n+    public void setContractionCriteria(float contractionCriteria) {\n+        checkContractExpand(contractionCriteria, getExpansionFactor());\n+        this.contractionCriteria = contractionCriteria;\n+    }\n+    \n+\n+    /**\n+     * Sets the element at the specified index.  If the specified index is greater than\n+     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n+     * is increased to <code>index +1</code> and additional storage is allocated \n+     * (if necessary) for the new element and all  (uninitialized) elements \n+     * between the new element and the previous end of the array).\n+     * \n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n+     *         zero.\n+     */\n+    public synchronized void setElement(int index, double value) {\n+        if (index < 0) {\n+            String msg = \"Cannot set an element at a negative index\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        }\n+        if (index + 1 > numElements) {\n+            numElements = index + 1;\n+        }       \n+        if ((startIndex + index) >= internalArray.length) {\n+            expandTo(startIndex + (index + 1));\n+        }    \n+        internalArray[startIndex + index] = value;\n+    }\n+\n+    /**\n+     * Sets the expansionFactor.  Throws IllegalArgumentException if the \n+     * the following conditions are not met:\n+     * <ul>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * <li><code>contractionFactor >= expansionFactor</code></li>\n+     * </ul>\n+     *\n+     * @throws IllegalArgumentException if expansionFactor is <= 1 or greater\n+     * than contractionFactor\n+     */\n+    public void setExpansionFactor(float expansionFactor) {\n+        checkContractExpand(getContractionCriteria(), expansionFactor);\n+        // The check above verifies that the expansion factor is > 1.0;\n+        this.expansionFactor = expansionFactor;\n+    }\n+\n+    /**\n+     * Sets the <code>expansionMode</code>. The specified value must be one of\n+     * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n+     * \n+     * @param expansionMode The expansionMode to set.\n+     * @throws IllegalArgumentException if the specified mode value is not valid\n+     */\n+    public void setExpansionMode(int expansionMode) {\n+        if (expansionMode != MULTIPLICATIVE_MODE && \n+                expansionMode != ADDITIVE_MODE) {\n+            throw new IllegalArgumentException(\"Illegal expansionMode setting.\");  \n+        }\n+        this.expansionMode = expansionMode;\n+    }\n+    \n+    /**\n+     * Sets the initial capacity.  Should only be invoked by constructors.\n+     * \n+     * @param initialCapacity of the array\n+     * @throws IllegalArgumentException if <code>initialCapacity</code> is not\n+     *         positive.\n+     */\n+    protected void setInitialCapacity(int initialCapacity) {\n+        if (initialCapacity > 0) {\n+            this.initialCapacity = initialCapacity;\n+        } else {\n+            String msg =\n+                \"The initial capacity supplied: \" + initialCapacity +\n+                \"must be a positive integer\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+    \n+    /**\n+     * This function allows you to control the number of elements contained \n+     * in this array, and can be used to \"throw out\" the last n values in an \n+     * array. This function will also expand the internal array as needed.\n+     * \n+     * @param i a new number of elements\n+     * @throws IllegalArgumentException if <code>i</code> is negative.\n+     */\n+    public synchronized void setNumElements(int i) {\n+\n+        // If index is negative thrown an error\n+        if (i < 0) {\n+            String msg =\n+                \"Number of elements must be zero or a positive \" + \"integer\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        // Test the new num elements, check to see if the array needs to be \n+        // expanded to accomodate this new number of elements\n+        if ((startIndex + i) > internalArray.length) {\n+            expandTo(startIndex + i);\n+        }\n+\n+        // Set the new number of elements to new value\n+        numElements = i;\n+    }\n+\n+    /**\n+     * Returns true if the internal storage array has too many unused \n+     * storage positions.  \n+     * \n+     * @return true if array satisfies the contraction criteria\n+     */\n+    private synchronized boolean shouldContract() {\n+        if (expansionMode == MULTIPLICATIVE_MODE) { \n+            return (internalArray.length / numElements) > contractionCriteria;\n+        } else {\n+            return (internalArray.length - numElements) > contractionCriteria;\n+        }\n+    }\n+\n+    /**\n+     * Returns the starting index of the internal array.  The starting index is\n+     * the position of the first addressable element in the internal storage\n+     * array.  The addressable elements in the array are <code>\n+     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n+     * </code>\n+     *\n+     * @return starting index\n+     */\n+    public int start() {\n+        return startIndex;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.random.RandomData;\n+\n+\n+/**\n+ * This class contains test cases for the ResizableDoubleArray.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/06/14 21:41:33 $\n+ */\n+public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {\n+    \n+    public ResizableDoubleArrayTest(String name) {\n+        super( name );\n+    }\n+      \n+    protected void tearDown() throws Exception {\n+        da = null;\n+        ra = null;\n+    }\n+       \n+    protected void setUp() throws Exception {\n+        da = new ResizableDoubleArray();\n+        ra = new ResizableDoubleArray();\n+    }\n+    \n+    public void testConstructors() {\n+        float defaultExpansionFactor = 2.0f;\n+        float defaultContractionCriteria = 2.5f;\n+        int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;\n+        \n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n+        assertEquals(defaultMode, testDa.getExpansionMode());\n+        try {\n+            da = new ResizableDoubleArray(-1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        testDa = new ResizableDoubleArray(2, 2.0f);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n+        assertEquals(defaultMode, testDa.getExpansionMode());\n+        \n+        try {\n+            da = new ResizableDoubleArray(2, 0.5f);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        testDa = new ResizableDoubleArray(2, 3.0f);\n+        assertEquals(3.0f, testDa.getExpansionFactor(), 0);\n+        assertEquals(3.5f, testDa.getContractionCriteria(), 0);\n+        \n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n+        assertEquals(defaultMode, testDa.getExpansionMode());\n+        \n+        try {\n+            da = new ResizableDoubleArray(2, 2.0f, 1.5f);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(0, testDa.getNumElements());\n+        assertEquals(2, testDa.getInternalLength());\n+        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n+        assertEquals(ResizableDoubleArray.ADDITIVE_MODE, \n+                testDa.getExpansionMode());\n+        \n+        try {\n+            da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+    }\n+    \n+    \n+    public void testSetElementArbitraryExpansion() {\n+        \n+        // MULTIPLICATIVE_MODE \n+        da.addElement(2.0);\n+        da.addElement(4.0);\n+        da.addElement(6.0);\n+        da.setElement(1, 3.0);\n+        \n+        // Expand the array arbitrarily to 1000 items\n+        da.setElement(1000, 3.4);\n+        \n+        assertEquals( \"The number of elements should now be 1001, it isn't\", \n+                da.getNumElements(), 1001);\n+        \n+        assertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n+                da.getElement( 760 ), Double.MIN_VALUE );\n+        \n+        assertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), \n+                Double.MIN_VALUE );\n+        assertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), \n+                Double.MIN_VALUE); \n+        \n+        // Make sure numElements and expansion work correctly for expansion boundary cases\n+        da.clear();\n+        da.addElement(2.0);\n+        da.addElement(4.0);\n+        da.addElement(6.0);\n+        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(3, da.getNumElements());\n+        da.setElement(3, 7.0);\n+        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(4, da.getNumElements());\n+        da.setElement(10, 10.0);\n+        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(11, da.getNumElements());\n+        da.setElement(9, 10.0);\n+        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n+        assertEquals(11, da.getNumElements());\n+        \n+        try {\n+            da.setElement(-2, 3);\n+            fail(\"Expecting ArrayIndexOutOfBoundsException for negative index\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        \n+        // ADDITIVE_MODE\n+        \n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(2, testDa.getInternalLength());\n+        testDa.addElement(1d);\n+        testDa.addElement(1d);\n+        assertEquals(2, testDa.getInternalLength());\n+        testDa.addElement(1d);\n+        assertEquals(4, testDa.getInternalLength());         \n+    }\n+    \n+    public void testAdd1000() {\n+        super.testAdd1000();\n+        assertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+                \"16 and an expansion factor of 2.0\",\n+                1024, ((ResizableDoubleArray) da).getInternalLength());\n+    }\n+    \n+    public void testAddElementRolling() {\n+        super.testAddElementRolling();\n+        \n+        // MULTIPLICATIVE_MODE\n+        da.clear();\n+        da.addElement(1);\n+        da.addElement(2);\n+        da.addElementRolling(3);\n+        assertEquals(3, da.getElement(1), 0);\n+        da.addElementRolling(4);\n+        assertEquals(3, da.getElement(0), 0);\n+        assertEquals(4, da.getElement(1), 0);\n+        da.addElement(5);\n+        assertEquals(5, da.getElement(2), 0);\n+        da.addElementRolling(6);\n+        assertEquals(4, da.getElement(0), 0);\n+        assertEquals(5, da.getElement(1), 0);\n+        assertEquals(6, da.getElement(2), 0);   \n+        \n+        // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)\n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(2, testDa.getInternalLength());\n+        testDa.addElement(1d); // x,0\n+        testDa.addElement(2d); // x,x\n+        testDa.addElement(3d); // x,x,x,0 -- expanded\n+        assertEquals(1d, testDa.getElement(0), 0);\n+        assertEquals(2d, testDa.getElement(1), 0);\n+        assertEquals(3d, testDa.getElement(2), 0);   \n+        assertEquals(4, testDa.getInternalLength());  // x,x,x,0 \n+        assertEquals(3, testDa.getNumElements());\n+        testDa.addElementRolling(4d);\n+        assertEquals(2d, testDa.getElement(0), 0);\n+        assertEquals(3d, testDa.getElement(1), 0);\n+        assertEquals(4d, testDa.getElement(2), 0);   \n+        assertEquals(4, testDa.getInternalLength());  // 0,x,x,x\n+        assertEquals(3, testDa.getNumElements());\n+        testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract\n+        assertEquals(3d, testDa.getElement(0), 0);\n+        assertEquals(4d, testDa.getElement(1), 0);\n+        assertEquals(5d, testDa.getElement(2), 0);   \n+        assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0     \n+        assertEquals(3, testDa.getNumElements());\n+        try {\n+            testDa.getElement(4);\n+            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected\n+        }  \n+        try {\n+            testDa.getElement(-1);\n+            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetNumberOfElements() {\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        da.addElement( 1.0 );\n+        assertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n+        \n+        ((ResizableDoubleArray) da).setNumElements( 3 );\n+        assertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n+        \n+        try {\n+            ((ResizableDoubleArray) da).setNumElements( -3 );\n+            fail( \"Setting number of elements to negative should've thrown an exception\");\n+        } catch( IllegalArgumentException iae ) {\n+        }\n+        \n+        ((ResizableDoubleArray) da).setNumElements(1024);\n+        assertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n+        assertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+        \n+    }\n+    \n+    public void testWithInitialCapacity() {\n+        \n+        ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);\n+        assertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n+        \n+        RandomData randomData = new RandomDataImpl();\n+        int iterations = randomData.nextInt(100, 1000);\n+        \n+        for( int i = 0; i < iterations; i++) {\n+            eDA2.addElement( i );\n+        }\n+        \n+        assertEquals(\"Number of elements should be equal to \" + iterations, iterations, eDA2.getNumElements());\n+        \n+        eDA2.addElement( 2.0 );\n+        \n+        assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n+                iterations + 1 , eDA2.getNumElements() );\n+    }\n+    \n+    public void testWithInitialCapacityAndExpansionFactor() {\n+        \n+        ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);\n+        assertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n+        \n+        RandomData randomData = new RandomDataImpl();\n+        int iterations = randomData.nextInt(100, 3000);\n+        \n+        for( int i = 0; i < iterations; i++) {\n+            eDA3.addElement( i );\n+        }\n+        \n+        assertEquals(\"Number of elements should be equal to \" + iterations, iterations,eDA3.getNumElements());\n+        \n+        eDA3.addElement( 2.0 );\n+        \n+        assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n+                iterations +1, eDA3.getNumElements() );\n+        \n+        assertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n+    }\n+    \n+    public void testDiscard() {\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        \n+        ((ResizableDoubleArray)da).discardFrontElements(5);\n+        assertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n+        \n+        try {\n+            ((ResizableDoubleArray)da).discardFrontElements(-1);\n+            fail( \"Trying to discard a negative number of element is not allowed\");\n+        } catch( Exception e ){\n+        }\n+        \n+        try {\n+            ((ResizableDoubleArray)da).discardFrontElements( 10000 );\n+            fail( \"You can't discard more elements than the array contains\");\n+        } catch( Exception e ){\n+        }\n+    }\n+    \n+    public void testMutators() {\n+        ((ResizableDoubleArray)da).setContractionCriteria(10f);\n+        assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);\n+        ((ResizableDoubleArray)da).setExpansionFactor(8f);  \n+        assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);\n+        try {\n+            ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        ((ResizableDoubleArray)da).setExpansionMode(\n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        assertEquals(ResizableDoubleArray.ADDITIVE_MODE, \n+                ((ResizableDoubleArray)da).getExpansionMode());\n+        try {\n+            ((ResizableDoubleArray)da).setExpansionMode(-1);\n+            fail (\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1087249293, "metainfo": ""}