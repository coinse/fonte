{"sha": "fe6f1d8531f872598bf0f5d39824c1302043ac05", "log": "removed MathUserException from analysis package  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * An interface representing a bivariate real function.\n  *\n      * @param x Abscissa for which the function value should be computed.\n      * @param y Ordinate for which the function value should be computed.\n      * @return the value.\n-     * @throws MathUserException if the function evaluation fails.\n      */\n-    double value(double x, double y)\n-        throws MathUserException;\n+    double value(double x, double y);\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n-\n /**\n  * An interface representing a multivariate matrix function.\n  * @version $Id$\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n-     * @exception MathUserException if the function evaluation fails\n      * @exception IllegalArgumentException if points dimension is wrong\n      */\n     double[][] value(double[] point)\n-        throws MathUserException, IllegalArgumentException;\n+        throws IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n      *\n      * @param point Point at which the function must be evaluated.\n      * @return the function value for the given point.\n-     * @throws org.apache.commons.math.exception.MathUserException if\n-     * the function evaluation fails.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the parameter's dimension is wrong for the function being evaluated.\n      * @throws  org.apache.commons.math.exception.MathIllegalArgumentException\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * An interface representing a multivariate vectorial function.\n  * @version $Id$\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n-     * @exception MathUserException if the function evaluation fails\n      * @exception IllegalArgumentException if points dimension is wrong\n      */\n     double[] value(double[] point)\n-        throws MathUserException, IllegalArgumentException;\n+        throws IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * An interface representing a trivariate real function.\n  *\n      * @param y y-coordinate for which the function value should be computed.\n      * @param z z-coordinate for which the function value should be computed.\n      * @return the value.\n-     * @throws MathUserException if the function evaluation fails.\n      */\n-    double value(double x, double y, double z)\n-        throws MathUserException;\n+    double value(double x, double y, double z);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * An interface representing a univariate matrix function.\n  *\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n-     * @throws MathUserException if the function evaluation fails\n      */\n-    double[][] value(double x) throws MathUserException;\n+    double[][] value(double x);\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * An interface representing a univariate real function.\n  *\n     /**\n      * Compute the value of the function.\n      *\n+     * <p>\n+     * For user-defined functions, when the method encounters an error\n+     * during evaluation, users must use their <em>own</em> unchecked exceptions.\n+     * The following example shows the recommended way to do that, using root\n+     * solving as the example (the same construct should be used for ODE\n+     * integrators or for optimizations).\n+     * </p>\n+     * <pre>\n+     * private static class LocalException extends RuntimeException {\n+     *\n+     *   // the x value that caused the problem\n+     *   private final double x;\n+     *\n+     *   public LocalException(double x) {\n+     *     this.x = x;\n+     *   }\n+     *\n+     *   public double getX() {\n+     *     return x;\n+     *   }\n+     *\n+     * }\n+     *\n+     * private static class MyFunction implements UnivariateRealFunction {\n+     *   public double value(double x) {\n+     *     double y = hugeFormula(x);\n+     *     if (somethingBadHappens) {\n+     *       throw new LocalException(x);\n+     *     }\n+     *     return y;\n+     *   }\n+     * }\n+     *\n+     * public void compute() {\n+     *   try {\n+     *     solver.solve(maxEval, new MyFunction(a, b, c), min, max);\n+     *   } catch (LocalException le) {\n+     *     // retrieve the x value\n+     *   }\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * As shown in this example the exception is really something local to user code\n+     * and there is a guarantee Apache Commons Math will not mess with it. The user is safe.\n+     * </p>\n      * @param x Point at which the function value should be computed.\n      * @return the value.\n      * @throws IllegalArgumentException when the activated method itself can\n      * majority of cases where Commons-Math throws IllegalArgumentException,\n      * it is the result of argument checking of actual parameters immediately\n      * passed to a method.\n-     * @throws MathUserException when the method may encounter errors during evaluation.\n-     * This should be thrown only in circumstances where, at the level of the\n-     * activated function, IllegalArgumentException is not appropriate and it\n-     * should indicate that while formal preconditions of the method have not\n-     * been violated, an irrecoverable error has occurred evaluating a\n-     * function at some (usually lower) level of the call stack.\n-     * Convergence failures, runtime exceptions (even IllegalArgumentException)\n-     * in user code or lower level methods can cause (and should be wrapped in)\n-     * a MathUserException.\n      */\n-    double value(double x) throws MathUserException;\n+    double value(double x);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * An interface representing a univariate vectorial function.\n  *\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n-     * @throws MathUserException if the function evaluation fails\n      */\n-    double[] value(double x) throws MathUserException;\n+    double[] value(double x);\n \n }\n--- a/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Wrapper class for counting functions calls.\n         return callsCount;\n     }\n \n-    public double value(double x) throws MathUserException {\n+    public double value(double x) {\n         ++callsCount;\n         return f.value(x);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Auxiliary class for testing optimizers.\n      * @param point Argument.\n      * @return the value of this function at point {@code x}.\n      */\n-    public double value(double[] point) throws MathUserException {\n+    public double value(double[] point) {\n         double sum = 0;\n         for (int i = 0, max = point.length; i < max; i++) {\n             final double x = point[i];\n      */\n     public MultivariateRealFunction partialDerivative(final int k) {\n         return new MultivariateRealFunction() {\n-            public double value(double[] point) throws MathUserException {\n+            public double value(double[] point) {\n                 return sincDeriv.value(point[k]);\n             }\n         };\n      */\n     public MultivariateVectorialFunction gradient() {\n         return new MultivariateVectorialFunction() {\n-            public double[] value(double[] point)\n-                throws MathUserException {\n+            public double[] value(double[] point) {\n                 final int n = point.length;\n                 final double[] r = new double[n];\n                 for (int i = 0; i < n; i++) {\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n \n     @Test\n     public void testExactIntegration()\n-        throws ConvergenceException, MathUserException {\n+        throws ConvergenceException {\n         Random random = new Random(86343623467878363l);\n         for (int n = 2; n < 6; ++n) {\n             LegendreGaussIntegrator integrator =", "timestamp": 1315339237, "metainfo": ""}