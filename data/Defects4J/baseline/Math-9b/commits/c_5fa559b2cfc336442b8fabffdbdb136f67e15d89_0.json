{"sha": "5fa559b2cfc336442b8fabffdbdb136f67e15d89", "log": "Refactored distribution package so that more general distributions can be represented and added Poisson distribution. 1) Added Distribution, AbstractDistribution 2) Added IntegerDistribution, AbstractIntegerDistribution 3) Added PoissonDistribution contributed by Fredrik Norin (PR #31688)   ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.analysis.UnivariateRealSolverUtils;\n \n /**\n- * Base class for various continuous distributions.  It provides default\n- * implementations for some of the methods that do not vary from distribution\n- * to distribution.\n+ * Base class for continuous distributions.  Default implementations are\n+ * provided for some of the methods that do not vary from distribution to\n+ * distribution.\n  *  \n- * @version $Revision: 1.25 $ $Date: 2004/07/17 21:19:39 $\n+ * @version $Revision: 1.26 $ $Date: 2004/11/07 03:32:48 $\n  */\n public abstract class AbstractContinuousDistribution\n+    extends AbstractDistribution\n     implements ContinuousDistribution, Serializable {\n \n     /** Serializable version identifier */\n      */\n     protected AbstractContinuousDistribution() {\n         super();\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(x0 &lt; X &lt; x1).  This\n-     * is accomplished by using the equality P(x0 &lt; X &lt; x1) =\n-     * P(X &lt; x1) - P(X &lt; x0).\n-     * \n-     * @param x0 the lower bound\n-     * @param x1 the upper bound\n-     * @return the cumulative probability. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if x0 > x1\n-     */\n-    public double cumulativeProbability(double x0, double x1)\n-        throws MathException {\n-        if (x0 > x1) {\n-            throw new IllegalArgumentException\n-            (\"lower endpoint must be less than or equal to upper endpoint\");\n-        }\n-        return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Base class for probability distributions.   \n+ *  \n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:48 $\n+ */\n+public abstract class AbstractDistribution\n+    implements Distribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -38038050983108802L;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractDistribution() {\n+        super();\n+    }\n+\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * <p>\n+     * The default implementation uses the identity\n+     * <p>\n+     * P(x0 &le; X &le; x1) = P(X &le; x1) - P(X &le; x0)\n+     * \n+     * @param x0 the (inclusive) lower bound\n+     * @param x1 the (inclusive) upper bound\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between <code>x0</code> and <code>x1</code>,\n+     * including the endpoints.\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     */\n+    public double cumulativeProbability(double x0, double x1)\n+        throws MathException {\n+        if (x0 > x1) {\n+            throw new IllegalArgumentException\n+            (\"lower endpoint must be less than or equal to upper endpoint\");\n+        }\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n+\n+/**\n+ * Base class for integer-valued discrete distributions.  Default\n+ * implementations are provided for some of the methods that do not vary\n+ * from distribution to distribution.\n+ *  \n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:48 $\n+ */\n+public abstract class AbstractIntegerDistribution extends AbstractDistribution\n+    implements IntegerDistribution, Serializable {\n+        \n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -1146319659338487221L;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractIntegerDistribution() {\n+        super();\n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the  (cumulative) distribution function, or\n+     * CDF, for this distribution.\n+     * <p>\n+     * If <code>x</code> does not represent an integer value, the CDF is \n+     * evaluated at the greatest integer less than x.\n+     * \n+     * @param x the value at which the distribution function is evaluated.\n+     * @return cumulative probability that a random variable with this\n+     * distribution takes a value less than or equal to <code>x</code>\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n+        return cumulativeProbability((int) Math.floor(x));  \n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the probability distribution function, or PDF,\n+     * for this distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return PDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    abstract public double cumulativeProbability(int x) throws MathException;\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X = x). In other words, this\n+     * method represents the probability mass function,  or PMF, for the distribution.\n+     * <p>\n+     * If <code>x</code> does not represent an integer value, 0 is returned.\n+     * \n+     * @param x the value at which the probability density function is evaluated\n+     * @return the value of the probability density function at x\n+     */\n+    public double probability(double x) {\n+        double fl = Math.floor(x);\n+        if (fl == x) {\n+            return this.probability((int) x);\n+        } else {\n+            return 0;\n+        }\n+    }\n+    \n+    /**\n+    * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * \n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @return the cumulative probability. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if x0 > x1\n+     */\n+    public double cumulativeProbability(int x0, int x1) throws MathException {\n+        if (x0 > x1) {\n+            throw new IllegalArgumentException\n+            \t(\"lower endpoint must be less than or equal to upper endpoint\");\n+        }\n+        return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns the largest x, such\n+     * that P(X &le; x) &le; <code>p</code>.\n+     *\n+     * @param p the desired probability\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1\n+     */\n+    public int inverseCumulativeProbability(final double p) throws MathException{\n+        if (p < 0.0 || p > 1.0) {\n+            throw new IllegalArgumentException(\n+                \"p must be between 0 and 1.0 (inclusive)\");\n+        }\n+        \n+        // by default, do simple bisection.\n+        // subclasses can override if there is a better method.\n+        int x0 = getDomainLowerBound(p);\n+        int x1 = getDomainUpperBound(p);\n+        double pm;\n+        while (x0 < x1) {\n+            int xm = x0 + (x1 - x0) / 2;\n+            pm = cumulativeProbability(xm);\n+            if (pm > p) {\n+                // update x1\n+                if (xm == x1) {\n+                    // this can happen with integer division\n+                    // simply decrement x1\n+                    --x1;\n+                } else {\n+                    // update x1 normally\n+                    x1 = xm;\n+                }\n+            } else {\n+                // update x0\n+                if (xm == x0) {\n+                    // this can happen with integer division\n+                    // simply increment x0\n+                    ++x0;\n+                } else {\n+                    // update x0 normally\n+                    x0 = xm;\n+                }\n+            }\n+        }\n+        \n+        // insure x0 is the correct critical point\n+        pm = cumulativeProbability(x0);\n+        while (pm > p) {\n+            --x0;\n+            pm = cumulativeProbability(x0);\n+        }\n+    \n+        return x0;        \n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected abstract int getDomainLowerBound(double p);\n+    \n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected abstract int getDomainUpperBound(double p);\n+}\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistribution.java\n  * </ul>\n  * </p>\n  *\n- * @version $Revision: 1.11 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.12 $ $Date: 2004/11/07 03:32:48 $\n  */\n-public interface BinomialDistribution extends DiscreteDistribution {\n+public interface BinomialDistribution extends IntegerDistribution {\n     /**\n      * Access the number of trials for this distribution.\n      * @return the number of trials.\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n /**\n  * The default implementation of {@link BinomialDistribution}.\n  *\n- * @version $Revision: 1.18 $ $Date: 2004/07/25 16:29:24 $\n+ * @version $Revision: 1.19 $ $Date: 2004/11/07 03:32:48 $\n  */\n public class BinomialDistributionImpl\n-    extends AbstractDiscreteDistribution\n+    extends AbstractIntegerDistribution\n     implements BinomialDistribution, Serializable {\n \n     /** Serializable version identifier */\n     }\n \n     /**\n-     * For this disbution, X, this method returns P(X &le; x).\n+     * For this distribution, X, this method returns P(X &le; x).\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      * @throws MathException if the cumulative probability can not be\n \n     /**\n      * For this disbution, X, this method returns P(X = x).\n+     * \n      * @param x the value at which the PMF is evaluated.\n      * @return PMF for this distribution. \n      */\n--- a/src/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n import org.apache.commons.math.MathException;\n \n /**\n- * Base interface for various continuous distributions.\n+ * Base interface for continuous distributions.\n  *\n- * @version $Revision: 1.15 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.16 $ $Date: 2004/11/07 03:32:48 $\n  */\n-public interface ContinuousDistribution {\n-    /**\n-     * For this disbution, X, this method returns P(X &lt; x).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     */\n-    double cumulativeProbability(double x) throws MathException;\n-\n-    /**\n-     * For this disbution, X, this method returns P(x0 &lt; X &lt; x1).\n-     * @param x0 the lower bound\n-     * @param x1 the upper bound\n-     * @return the cumulative probability. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     */\n-    double cumulativeProbability(double x0, double x1) throws MathException;\n+public interface ContinuousDistribution extends Distribution {\n     \n     /**\n      * For this disbution, X, this method returns x such that P(X &lt; x) = p.\n--- a/src/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n \n /**\n- * Base interface for various discrete distributions.\n+ * Base interface for discrete distributions.\n  *\n- * @version $Revision: 1.16 $ $Date: 2004/07/25 16:29:24 $\n+ * @version $Revision: 1.17 $ $Date: 2004/11/07 03:32:48 $\n  */\n-public interface DiscreteDistribution {\n+public interface DiscreteDistribution extends Distribution {\n     /**\n-     * For this distribution, X, this method returns P(X = x).\n-     * @param x the value at which the PMF is evaluated.\n-     * @return PMF for this distribution. \n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X = x). In other words, this\n+     * method represents the probability mass function, or PMF for the distribution.\n+     * \n+     * @param x the value at which the probability mass function is evaluated.\n+     * @return the value of the probability mass function at x\n      */\n-    double probability(int x);\n-    \n-    /**\n-     * For this distribution, X, this method returns P(X &le; x).\n-     * @param x the value at which the PDF is evaluated.\n-     * @return PDF for this distribution. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     */\n-    double cumulativeProbability(int x) throws MathException;\n-\n-    /**\n-     * For this distribution, X, this method returns P(x0 &le; X &le; x1).\n-     * @param x0 the inclusive, lower bound\n-     * @param x1 the inclusive, upper bound\n-     * @return the cumulative probability. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if x0 > x1\n-     */\n-    double cumulativeProbability(int x0, int x1) throws MathException;\n-    \n-    /**\n-     * For this distribution, X, this method returns the largest x such that\n-     * P(X &le; x) <= p.\n-     * <p>\n-     * Note that this definition implies: <ul>\n-     * <li> If there is a minimum value, <code>m</code>, with postive\n-     * probablility under (the density of) X, then <code>m - 1</code> is\n-     * returned by <code>inverseCumulativeProbability(0).</code>  If there is\n-     * no such value <code>m,  Integer.MIN_VALUE</code> is \n-     * returned.</li>\n-     * <li> If there is a maximum value, <code>M</code>, such that\n-     * P(X &le; M) =1, then <code>M</code> is returned by \n-     * <code>inverseCumulativeProbability(1).</code>\n-     * If there is no such value, <code>M, Integer.MAX_VALUE</code> is \n-     * returned.</li></ul>\n-     * \n-     * @param p the cumulative probability.\n-     * @return the largest x such that P(X &le; x) <= p\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if p is not between 0 and 1 (inclusive)\n-     */\n-    int inverseCumulativeProbability(double p) throws MathException;\n+    double probability(double x);\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/Distribution.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Base interface for probability distributions.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:48 $\n+ */\n+public interface Distribution {\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the  (cumulative) distribution function, or\n+     * CDF, for this distribution.\n+     * \n+     * @param x the value at which the distribution function is evaluated.\n+     * @return the probability that a random variable with this\n+     * distribution takes a value less than or equal to <code>x</code>\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     */\n+    double cumulativeProbability(double x) throws MathException;\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * \n+     * @param x0 the (inclusive) lower bound\n+     * @param x1 the (inclusive) upper bound\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between <code>x0</code> and <code>x1</code>, \n+     * including the endpoints\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     */\n+    double cumulativeProbability(double x0, double x1) throws MathException;\n+}\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n  * <li>F</li>\n  * <li>Gamma</li>\n  * <li>HyperGeometric</li>\n+ * <li>Poisson</li>\n  * <li>Normal</li>\n  * <li>Student's t</li>\n  * </ul>\n  * ChiSquaredDistribution chi = factory.createChiSquareDistribution(5.0);\n  * </pre>\n  *\n- * @version $Revision: 1.21 $ $Date: 2004/07/10 15:59:14 $\n+ * @version $Revision: 1.22 $ $Date: 2004/11/07 03:32:48 $\n  */\n public abstract class DistributionFactory {\n     /**\n     /**\n      * Create a binomial distribution with the given number of trials and\n      * probability of success.\n+     * \n      * @param numberOfTrials the number of trials.\n-     * @param probabilityOfSuccess the probability of success.\n-     * @return a new binomial distribution.\n+     * @param probabilityOfSuccess the probability of success\n+     * @return a new binomial distribution\n      */\n     public abstract BinomialDistribution createBinomialDistribution(\n         int numberOfTrials, double probabilityOfSuccess);\n         \n     /**\n      * Create a new chi-square distribution with the given degrees of freedom.\n-     * @param degreesOfFreedom degrees of freedom.\n-     * @return a new chi-square distribution.  \n+     * \n+     * @param degreesOfFreedom degrees of freedom\n+     * @return a new chi-square distribution  \n      */\n     public abstract ChiSquaredDistribution createChiSquareDistribution(\n         double degreesOfFreedom);\n     \n     /**\n      * Create a new exponential distribution with the given degrees of freedom.\n-     * @param mean mean.\n-     * @return a new exponential distribution.  \n+     * \n+     * @param mean mean\n+     * @return a new exponential distribution  \n      */\n     public abstract ExponentialDistribution createExponentialDistribution(\n         double mean);\n     \n     /**\n      * Create a new F-distribution with the given degrees of freedom.\n-     * @param numeratorDegreesOfFreedom numerator degrees of freedom.\n-     * @param denominatorDegreesOfFreedom denominator degrees of freedom.\n-     * @return a new F-distribution.  \n+     * \n+     * @param numeratorDegreesOfFreedom numerator degrees of freedom\n+     * @param denominatorDegreesOfFreedom denominator degrees of freedom\n+     * @return a new F-distribution \n      */\n     public abstract FDistribution createFDistribution(\n         double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);\n     \n     /**\n-     * Create a new gamma distribution with the given alpha and beta values.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     * @return a new gamma distribution.  \n+     * Create a new gamma distribution with the given shape and scale\n+     * parameters.\n+     * \n+     * @param alpha the shape parameter\n+     * @param beta the scale parameter\n+     * \n+     * @return a new gamma distribution  \n      */\n     public abstract GammaDistribution createGammaDistribution(\n         double alpha, double beta);\n \n     /**\n      * Create a new t distribution with the given degrees of freedom.\n-     * @param degreesOfFreedom degrees of freedom.\n-     * @return a new t distribution.  \n+     * \n+     * @param degreesOfFreedom degrees of freedom\n+     * @return a new t distribution  \n      */\n     public abstract TDistribution createTDistribution(double degreesOfFreedom);\n     \n     /**\n      * Create a new hypergeometric distribution with the given the population\n      * size, the number of successes in the population, and the sample size.\n-     * @param populationSize the population size.\n-     * @param numberOfSuccesses number of successes in the population.\n-     * @param sampleSize the sample size.\n-     * @return a new hypergeometric desitribution.\n+     * \n+     * @param populationSize the population size\n+     * @param numberOfSuccesses number of successes in the population\n+     * @param sampleSize the sample size\n+     * @return a new hypergeometric desitribution\n      */\n     public abstract HypergeometricDistribution\n         createHypergeometricDistribution(int populationSize,\n  \n \t/**\n \t * Create a new normal distribution with the given mean and standard\n-\t * deviation values.\n-\t * @param mean arithmetic mean.\n-\t * @param sd standard deviation.\n-\t * @return a new normal distribution.  \n+\t * deviation.\n+     * \n+\t * @param mean the mean of the distribution\n+\t * @param sd standard deviation\n+\t * @return a new normal distribution  \n \t */           \n     public abstract NormalDistribution \n     \tcreateNormalDistribution(double mean, double sd);\n     \t\n \t/**\n-\t * Create a new normal distribution with the mean equal to zero and standard\n-\t * deviation equal to one.\n+\t * Create a new normal distribution with mean zero and standard\n+\t * deviation one.\n+     * \n \t * @return a new normal distribution.  \n \t */               \n \tpublic abstract NormalDistribution createNormalDistribution();\n+    \n+    /**\n+     * Create a new Poisson distribution with poisson parameter lambda.\n+     * \n+     * @param lambda poisson parameter\n+     * @return a new normal distribution.  \n+     */               \n+    public abstract PoissonDistribution \n+        createPoissonDistribution(double lambda);\n }\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n  * A concrete distribution factory.  This is the default factory used by\n  * Commons-Math.\n  *  \n- * @version $Revision: 1.20 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.21 $ $Date: 2004/11/07 03:32:48 $\n  */\n public class DistributionFactoryImpl extends DistributionFactory {\n \n     \n     /**\n      * Create a new chi-square distribution with the given degrees of freedom.\n-     * @param degreesOfFreedom degrees of freedom.\n-     * @return a new chi-square distribution.  \n+     * \n+     * @param degreesOfFreedom degrees of freedom\n+     * @return a new chi-square distribution  \n      */\n     public ChiSquaredDistribution createChiSquareDistribution(\n         final double degreesOfFreedom) {\n     }\n     \n     /**\n-     * Create a new gamma distribution the given alpha and beta values.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     * @return a new gamma distribution.  \n+     * Create a new gamma distribution the given shape and scale parameters.\n+     * \n+     * @param alpha the shape parameter\n+     * @param beta the scale parameter\n+     * @return a new gamma distribution  \n      */\n     public GammaDistribution createGammaDistribution(\n         double alpha, double beta) {\n \n     /**\n      * Create a new t distribution with the given degrees of freedom.\n-     * @param degreesOfFreedom degrees of freedom.\n+     * \n+     * @param degreesOfFreedom degrees of freedom\n      * @return a new t distribution.  \n      */\n     public TDistribution createTDistribution(double degreesOfFreedom) {\n \n     /**\n      * Create a new F-distribution with the given degrees of freedom.\n-     * @param numeratorDegreesOfFreedom numerator degrees of freedom.\n-     * @param denominatorDegreesOfFreedom denominator degrees of freedom.\n-     * @return a new F-distribution.  \n+     * \n+     * @param numeratorDegreesOfFreedom numerator degrees of freedom\n+     * @param denominatorDegreesOfFreedom denominator degrees of freedom\n+     * @return a new F-distribution \n      */\n     public FDistribution createFDistribution(\n         double numeratorDegreesOfFreedom,\n \n     /**\n      * Create a new exponential distribution with the given degrees of freedom.\n-     * @param mean mean.\n-     * @return a new exponential distribution.  \n+     * \n+     * @param mean mean\n+     * @return a new exponential distribution  \n      */\n     public ExponentialDistribution createExponentialDistribution(double mean) {\n         return new ExponentialDistributionImpl(mean);\n     /**\n      * Create a binomial distribution with the given number of trials and\n      * probability of success.\n-     * @param numberOfTrials the number of trials.\n-     * @param probabilityOfSuccess the probability of success.\n-     * @return a new binomial distribution.\n+     * \n+     * @param numberOfTrials the number of trials\n+     * @param probabilityOfSuccess the probability of success\n+     * @return a new binomial distribution\n      */\n     public BinomialDistribution createBinomialDistribution(\n         int numberOfTrials, double probabilityOfSuccess) {\n     /**\n      * Create a new hypergeometric distribution with the given the population\n      * size, the number of successes in the population, and the sample size.\n-     * @param populationSize the population size.\n-     * @param numberOfSuccesses number of successes in the population.\n-     * @param sampleSize the sample size.\n-     * @return a new hypergeometric desitribution.\n+     * \n+     * @param populationSize the population size\n+     * @param numberOfSuccesses number of successes in the population\n+     * @param sampleSize the sample size\n+     * @return a new hypergeometric desitribution\n      */\n     public HypergeometricDistribution createHypergeometricDistribution(\n-        int populationSize,\n-        int numberOfSuccesses,\n-        int sampleSize)\n-    {\n+        int populationSize, int numberOfSuccesses, int sampleSize) {\n         return new HypergeometricDistributionImpl(populationSize,\n             numberOfSuccesses, sampleSize);\n     }\n \n \t/**\n \t * Create a new normal distribution with the given mean and standard\n-\t * deviation values.\n-\t * @param mean arithmetic mean.\n-\t * @param sd standard deviation.\n-\t * @return a new normal distribution.  \n+\t * deviation.\n+     *  \n+\t * @param mean the mean of the distribution\n+\t * @param sd standard deviation\n+\t * @return a new normal distribution \n \t */   \n \tpublic NormalDistribution createNormalDistribution(double mean, double sd) {\n \t\treturn new NormalDistributionImpl(mean, sd);\n \t}\n \n \t/**\n-\t * Create a new normal distribution with the mean equal to zero and standard\n-\t * deviation equal to one.\n-\t * @return a new normal distribution.  \n+\t * Create a new normal distribution with the mean zero and standard\n+\t * deviation one.\n+     * \n+\t * @return a new normal distribution  \n \t */ \n \tpublic NormalDistribution createNormalDistribution() {\n \t\treturn new NormalDistributionImpl();\n \t}\n+    \n+    /**\n+     * Create a new Poisson distribution with poisson parameter lambda.\n+     * <p>\n+     * lambda must be postive; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param lambda poisson parameter\n+     * @return a new Poisson distribution  \n+     * @throws IllegalArgumentException if lambda &le; 0\n+     */               \n+    public PoissonDistribution  createPoissonDistribution(double lambda) {\n+        return new PoissonDistributionImpl(lambda);\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n  * </ul>\n  * </p>\n  *\n- * @version $Revision: 1.10 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.11 $ $Date: 2004/11/07 03:32:48 $\n  */\n-public interface HypergeometricDistribution extends DiscreteDistribution {\n+public interface HypergeometricDistribution extends IntegerDistribution {\n     /**\n      * Access the number of successes.\n      * @return the number of successes.\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n /**\n  * The default implementation of {@link HypergeometricDistribution}.\n  *\n- * @version $Revision: 1.15 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.16 $ $Date: 2004/11/07 03:32:48 $\n  */\n-public class HypergeometricDistributionImpl extends AbstractDiscreteDistribution\n+public class HypergeometricDistributionImpl extends AbstractIntegerDistribution\n     implements HypergeometricDistribution, Serializable \n {\n \n \n     /**\n      * For this disbution, X, this method returns P(X = x).\n+     * \n      * @param x the value at which the PMF is evaluated.\n      * @return PMF for this distribution. \n      */\n     /**\n      * For the disbution, X, defined by the given hypergeometric distribution\n      * parameters, this method returns P(X = x).\n+     * \n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface for discrete distributions of integer-valued random variables.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:48 $\n+ */\n+public interface IntegerDistribution extends DiscreteDistribution {\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X = x). In other words, this\n+     * method represents the probability mass function for the distribution.\n+     * \n+     * @param x the value at which the probability density function is evaluated.\n+     * @return the value of the probability density function at x\n+     */\n+    double probability(int x);\n+\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the probability distribution function, or PDF\n+     * for the distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return PDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    double cumulativeProbability(int x) throws MathException;\n+    \n+    /**\n+     * For this distribution, X, this method returns P(x0 &le; X &le; x1).\n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @return the cumulative probability. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if x0 > x1\n+     */\n+    double cumulativeProbability(int x0, int x1) throws MathException;\n+    \n+    /**\n+     * For this distribution, X, this method returns the largest x such that\n+     * P(X &le; x) <= p.\n+     * <p>\n+     * Note that this definition implies: <ul>\n+     * <li> If there is a minimum value, <code>m</code>, with postive\n+     * probablility under (the density of) X, then <code>m - 1</code> is\n+     * returned by <code>inverseCumulativeProbability(0).</code>  If there is\n+     * no such value <code>m,  Integer.MIN_VALUE</code> is \n+     * returned.</li>\n+     * <li> If there is a maximum value, <code>M</code>, such that\n+     * P(X &le; M) =1, then <code>M</code> is returned by \n+     * <code>inverseCumulativeProbability(1).</code>\n+     * If there is no such value, <code>M, Integer.MAX_VALUE</code> is \n+     * returned.</li></ul>\n+     * \n+     * @param p the cumulative probability.\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p is not between 0 and 1 (inclusive)\n+     */\n+    int inverseCumulativeProbability(double p) throws MathException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface representing the Poisson Distribution.\n+ * \n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/PoissonDistribution.html\">\n+ * Poisson distribution</a></li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:48 $\n+ */\n+public interface PoissonDistribution extends IntegerDistribution {\n+\n+    /**\n+     * Get the mean for the distribution.\n+     * \n+     * @return the mean for the distribution.\n+     */\n+    public double getMean();\n+\n+    /**\n+     * Set the mean for the distribution.\n+     * The parameter value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the mean\n+     * @throws IllegalArgumentException if p &le; 0\n+     */\n+    public void setMean(double p);\n+\n+    /**\n+     * Calculates the Poisson distribution function using a normal approximation.\n+     * \n+     * @param x the upper bound, inclusive\n+     * @return the distribution function value calculated using a normal approximation\n+     * @throws MathException if an error occurs computing the normal approximation\n+     */\n+    public double normalApproximateProbability(int x) throws MathException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implementation for the @link{PoissonDistribution}\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:48 $\n+ */\n+public class PoissonDistributionImpl extends AbstractIntegerDistribution\n+        implements PoissonDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -3349935121172596109L;\n+    \n+    /**\n+     * Holds the Poisson mean for the distribution.\n+     */\n+    private double mean;\n+\n+    /**\n+     * Create a new Poisson distribution with the given the mean.\n+     * The mean value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the Poisson mean\n+     * @throws IllegalArgumentException if p &le; 0\n+     */\n+    public PoissonDistributionImpl(double p) {\n+        super();\n+        setMean(p);\n+    }\n+\n+    /**\n+     * Get the Poisson mean for the distribution.\n+     * \n+     * @return the Poisson mean for the distribution.\n+     */\n+    public double getMean() {\n+        return this.mean;\n+    }\n+\n+    /**\n+     * Set the Poisson mean for the distribution.\n+     * The mean value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the Poisson mean value\n+     * @throws IllegalArgumentException if p &le; 0\n+     */\n+    public void setMean(double p) {\n+        if (p <= 0) {\n+            throw new IllegalArgumentException(\n+                    \"The Poisson mean must be positive\");\n+        }\n+        this.mean = p;\n+    }\n+\n+    /**\n+     * The probability mass function P(X = x) for a Poisson distribution.\n+     * \n+     * @param x the value at which the probability density function is evaluated.\n+     * @return the value of the probability mass function at x\n+     */\n+    public double probability(int x) {\n+        if (x < 0 || x == Integer.MAX_VALUE) {\n+            return 0;\n+        }\n+        return Math.pow(getMean(), x) / \n+            MathUtils.factorialDouble(x) * Math.exp(-mean);\n+    }\n+    \n+    /**\n+     * The probability distribution function P(X <= x) for a Poisson distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return Poisson distribution function evaluated at x\n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(int x) throws MathException {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        if (x == Integer.MAX_VALUE) {\n+            return 1;\n+        }\n+        return Gamma.regularizedGammaQ((double)x + 1, mean, \n+                1E-12, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Calculates the Poisson distribution function using a normal\n+     * approximation.  The <code>N(mean, sqrt(mean))</code>\n+     * distribution is used to approximate the Poisson distribution.\n+     * <p>\n+     * The computation uses \"half-correction\" -- evaluating the normal\n+     * distribution function at <code>x + 0.5</code>\n+     * \n+     * @param x the upper bound, inclusive\n+     * @return the distribution function value calculated using a normal approximation\n+     * @throws MathException if an error occurs computing the normal approximation\n+     */\n+    public double normalApproximateProbability(int x) throws MathException {\n+        NormalDistribution normal = DistributionFactory.newInstance()\n+                .createNormalDistribution(getMean(),\n+                        Math.sqrt(getMean()));\n+\n+        // calculate the probability using half-correction\n+        return normal.cumulativeProbability(x + 0.5);\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain lower bound\n+     */\n+    protected int getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain upper bound\n+     */\n+    protected int getDomainUpperBound(double p) {\n+        return Integer.MAX_VALUE;\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n \n /**\n  * Test cases for BinomialDistribution.\n- * Extends DiscreteDistributionAbstractTest.  See class javadoc for\n- * DiscreteDistributionAbstractTest for details.\n+ * Extends IntegerDistributionAbstractTest.  See class javadoc for\n+ * IntegerDistributionAbstractTest for details.\n  * \n- * @version $Revision: 1.15 $ $Date: 2004/07/25 16:29:25 $\n+ * @version $Revision: 1.16 $ $Date: 2004/11/07 03:32:49 $\n  */\n-public class BinomialDistributionTest extends DiscreteDistributionAbstractTest {\n+public class BinomialDistributionTest extends IntegerDistributionAbstractTest {\n     \n     /**\n      * Constructor for BinomialDistributionTest.\n     //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default discrete distribution instance to use in tests. */\n-    public DiscreteDistribution makeDistribution() {\n+    public IntegerDistribution makeDistribution() {\n         return DistributionFactory.newInstance().createBinomialDistribution(10,0.70);\n     }\n     \n     }\n     \n     /** Test degenerate case p = 1   */\n-    public void tstDegenerate1() throws Exception {\n+    public void testDegenerate1() throws Exception {\n         setDistribution(DistributionFactory.newInstance().createBinomialDistribution(5,1.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});\n--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n \n /**\n  * Test cases for HyperGeometriclDistribution.\n- * Extends DiscreteDistributionAbstractTest.  See class javadoc for\n- * DiscreteDistributionAbstractTest for details.\n+ * Extends IntegerDistributionAbstractTest.  See class javadoc for\n+ * IntegerDistributionAbstractTest for details.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/07/25 16:29:25 $\n+ * @version $Revision: 1.13 $ $Date: 2004/11/07 03:32:49 $\n  */\n-public class HypergeometricDistributionTest extends DiscreteDistributionAbstractTest {\n+public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {\n \n     /**\n      * Constructor for ChiSquareDistributionTest.\n //-------------- Implementations for abstract methods -----------------------\n     \n     /** Creates the default discrete distribution instance to use in tests. */\n-    public DiscreteDistribution makeDistribution() {\n+    public IntegerDistribution makeDistribution() {\n         return DistributionFactory.newInstance().createHypergeometricDistribution(10,5, 5);\n     }\n     \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract base class for {@link IntegerDistribution} tests.\n+ * <p>\n+ * To create a concrete test class for an integer distribution implementation,\n+ *  implement makeDistribution() to return a distribution instance to use in \n+ *  tests and each of the test data generation methods below.  In each case, the\n+ *  test points and test values arrays returned represent parallel arrays of \n+ *  inputs and expected values for the distribution returned by makeDistribution().\n+ *  <p>\n+ *  makeDensityTestPoints() -- arguments used to test probability density calculation\n+ *  makeDensityTestValues() -- expected probability densities\n+ *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities\n+ *  makeCumulativeTestValues() -- expected cumulative probabilites\n+ *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation\n+ *  makeInverseCumulativeTestValues() -- expected inverse cdf values\n+ * <p>\n+ *  To implement additional test cases with different distribution instances and test data,\n+ *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods\n+ *  to verify results. \n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:49 $\n+ */\n+public abstract class IntegerDistributionAbstractTest extends TestCase {\n+    \n+//-------------------- Private test instance data -------------------------\n+    /** Discrete distribution instance used to perform tests */\n+    private IntegerDistribution distribution;\n+    \n+    /** Tolerance used in comparing expected and returned values */\n+    private double tolerance = 1E-4;\n+    \n+    /** Arguments used to test probability density calculations */\n+    private int[] densityTestPoints;\n+    \n+    /** Values used to test probability density calculations */\n+    private double[] densityTestValues;\n+    \n+    /** Arguments used to test cumulative probability density calculations */\n+    private int[] cumulativeTestPoints;\n+    \n+    /** Values used to test cumulative probability density calculations */\n+    private double[] cumulativeTestValues;\n+    \n+    /** Arguments used to test inverse cumulative probability density calculations */\n+    private double[] inverseCumulativeTestPoints;\n+    \n+    /** Values used to test inverse cumulative probability density calculations */\n+    private int[] inverseCumulativeTestValues;\n+    \n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * Constructor for IntegerDistributionAbstractTest.\n+     * @param name\n+     */\n+    public IntegerDistributionAbstractTest(String name) {\n+        super(name);\n+    }\n+    \n+    //-------------------- Abstract methods -----------------------------------\n+    \n+    /** Creates the default discrete distribution instance to use in tests. */\n+    public abstract IntegerDistribution makeDistribution();\n+    \n+    /** Creates the default probability density test input values */\n+    public abstract int[] makeDensityTestPoints();\n+    \n+    /** Creates the default probability density test expected values */\n+    public abstract double[] makeDensityTestValues();\n+    \n+    /** Creates the default cumulative probability density test input values */\n+    public abstract int[] makeCumulativeTestPoints();\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    public abstract double[] makeCumulativeTestValues();\n+    \n+    /** Creates the default inverse cumulative probability test input values */\n+    public abstract double[] makeInverseCumulativeTestPoints();\n+    \n+    /** Creates the default inverse cumulative probability density test expected values */\n+    public abstract int[] makeInverseCumulativeTestValues();\n+    \n+    //-------------------- Setup / tear down ----------------------------------\n+     \n+    /**\n+     * Setup sets all test instance data to default values \n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        distribution = makeDistribution();\n+        densityTestPoints = makeDensityTestPoints();\n+        densityTestValues = makeDensityTestValues();\n+        cumulativeTestPoints = makeCumulativeTestPoints();\n+        cumulativeTestValues = makeCumulativeTestValues();\n+        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n+        inverseCumulativeTestValues = makeInverseCumulativeTestValues();   \n+    }\n+    \n+    /**\n+     * Cleans up test instance data\n+     */\n+    protected void tearDown() throws Exception {      \n+        super.tearDown();\n+        distribution = null;\n+        densityTestPoints = null;\n+        densityTestValues = null;\n+        cumulativeTestPoints = null;\n+        cumulativeTestValues = null;\n+        inverseCumulativeTestPoints = null;\n+        inverseCumulativeTestValues = null;   \n+    }\n+    \n+    //-------------------- Verification methods -------------------------------\n+    \n+    /**\n+     * Verifies that probability density calculations match exptected values\n+     * using current test instance data\n+     */\n+    protected void verifyDensities() throws Exception {\n+        for (int i = 0; i < densityTestPoints.length; i++) {\n+            assertEquals(\"Incorrect density value returned for \" + densityTestPoints[i],\n+                    densityTestValues[i], \n+                    distribution.probability(densityTestPoints[i]), tolerance);\n+        }     \n+    }\n+    \n+    /**\n+     * Verifies that cumulative probability density calculations match exptected values\n+     * using current test instance data\n+     */   \n+    protected void verifyCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            assertEquals(\"Incorrect cumulative probability value returned for \" + cumulativeTestPoints[i],\n+                    cumulativeTestValues[i], \n+                    distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);\n+        }           \n+    }\n+    \n+    /**\n+     * Verifies that inverse cumulative probability density calculations match exptected values\n+     * using current test instance data\n+     */\n+    protected void verifyInverseCumulativeProbabilities() throws Exception {\n+        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n+            assertEquals(\"Incorrect inverse cumulative probability value returned for \" \n+                    + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], \n+                    distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));\n+        }           \n+    }\n+    \n+    //------------------------ Default test cases -----------------------------\n+\n+    /**\n+     * Verifies that probability density calculations match exptected values\n+     * using default test instance data\n+     */\n+    public void testDensities() throws Exception {\n+        verifyDensities();     \n+    }\n+    \n+    /**\n+     * Verifies that cumulative probability density calculations match exptected values\n+     * using default test instance data\n+     */\n+    public void testCumulativeProbabilities() throws Exception {\n+        verifyCumulativeProbabilities();      \n+    }\n+    \n+    /**\n+     * Verifies that inverse cumulative probability density calculations match exptected values\n+     * using default test instance data\n+     */\n+    public void testInverseCumulativeProbabilities() throws Exception {\n+        verifyInverseCumulativeProbabilities();       \n+    }\n+    \n+    /**\n+     * Verifies that illegal arguments are correctly handled\n+     */\n+    public void testIllegalArguments() throws Exception {\n+        try {\n+            distribution.cumulativeProbability(1, 0);\n+            fail(\"Expecting IllegalArgumentException for bad cumulativeProbability interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(-1);\n+            fail(\"Expecting IllegalArgumentException for p = -1\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            distribution.inverseCumulativeProbability(2);\n+            fail(\"Expecting IllegalArgumentException for p = 2\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }       \n+    }\n+    \n+    //------------------ Getters / Setters for test instance data -----------\n+    /**\n+     * @return Returns the cumulativeTestPoints.\n+     */\n+    protected int[] getCumulativeTestPoints() {\n+        return cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param cumulativeTestPoints The cumulativeTestPoints to set.\n+     */\n+    protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {\n+        this.cumulativeTestPoints = cumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the cumulativeTestValues.\n+     */\n+    protected double[] getCumulativeTestValues() {\n+        return cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param cumulativeTestValues The cumulativeTestValues to set.\n+     */\n+    protected void setCumulativeTestValues(double[] cumulativeTestValues) {\n+        this.cumulativeTestValues = cumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the densityTestPoints.\n+     */\n+    protected int[] getDensityTestPoints() {\n+        return densityTestPoints;\n+    }\n+\n+    /**\n+     * @param densityTestPoints The densityTestPoints to set.\n+     */\n+    protected void setDensityTestPoints(int[] densityTestPoints) {\n+        this.densityTestPoints = densityTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the densityTestValues.\n+     */\n+    protected double[] getDensityTestValues() {\n+        return densityTestValues;\n+    }\n+\n+    /**\n+     * @param densityTestValues The densityTestValues to set.\n+     */\n+    protected void setDensityTestValues(double[] densityTestValues) {\n+        this.densityTestValues = densityTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the distribution.\n+     */\n+    protected IntegerDistribution getDistribution() {\n+        return distribution;\n+    }\n+\n+    /**\n+     * @param distribution The distribution to set.\n+     */\n+    protected void setDistribution(IntegerDistribution distribution) {\n+        this.distribution = distribution;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestPoints.\n+     */\n+    protected double[] getInverseCumulativeTestPoints() {\n+        return inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.\n+     */\n+    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {\n+        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;\n+    }\n+\n+    /**\n+     * @return Returns the inverseCumulativeTestValues.\n+     */\n+    protected int[] getInverseCumulativeTestValues() {\n+        return inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.\n+     */\n+    protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {\n+        this.inverseCumulativeTestValues = inverseCumulativeTestValues;\n+    }\n+\n+    /**\n+     * @return Returns the tolerance.\n+     */\n+    protected double getTolerance() {\n+        return tolerance;\n+    }\n+\n+    /**\n+     * @param tolerance The tolerance to set.\n+     */\n+    protected void setTolerance(double tolerance) {\n+        this.tolerance = tolerance;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * <code>PoissonDistributionTest</code>\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/11/07 03:32:49 $\n+ */\n+public class PoissonDistributionTest extends IntegerDistributionAbstractTest {\n+\n+    /**\n+     * Poisson parameter value for the test distribution.\n+     */\n+    private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;\n+\n+    /**\n+     * Constructor.\n+     * @param name\n+     */\n+    public PoissonDistributionTest(String name) {\n+        super(name);\n+        setTolerance(1e-12);\n+    }\n+\n+    /** \n+     * Creates the default discrete distribution instance to use in tests. \n+     */\n+    public IntegerDistribution makeDistribution() {\n+        return DistributionFactory.newInstance().createPoissonDistribution\n+            (DEFAULT_TEST_POISSON_PARAMETER);  \n+    }\n+\n+    /** \n+     * Creates the default probability density test input values.\n+     */\n+    public int[] makeDensityTestPoints() {\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n+    }\n+\n+    /**\n+     * Creates the default probability density test expected values.\n+     * These and all other test values are generated by R, version 1.8.1\n+     */\n+    public double[] makeDensityTestValues() {\n+        return new double[] { 0d, 0.0183156388887d,  0.073262555555d,\n+                0.14652511111d, 0.195366814813d, 0.195366814813, \n+                0.156293451851d, 0.00529247667642d, 8.27746364655e-09};\n+    }\n+\n+    /**\n+     * Creates the default cumulative probability density test input values.\n+     */\n+    public int[] makeCumulativeTestPoints() {\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };\n+    }\n+\n+    /**\n+     * Creates the default cumulative probability density test expected values.\n+     */\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d, \n+                0.238103305554d, 0.433470120367d, 0.62883693518,\n+                0.78513038703d,  0.99716023388d, 0.999999998077 };\n+    }\n+\n+    /** \n+     * Creates the default inverse cumulative probability test input values.\n+     * Increased 3rd and 7th values slightly as computed cumulative\n+     * probabilities for corresponding values exceeds the target value (still \n+     * within tolerance).\n+     */\n+    public double[] makeInverseCumulativeTestPoints() {\n+        return new double[] { 0d,  0.018315638889d, 0.0915781944437d, \n+                0.238103305554d, 0.433470120367d, 0.62883693518,\n+                0.78513038704d,  0.99716023388d, 0.999999998077 };\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability density test expected values.\n+     */\n+    public int[] makeInverseCumulativeTestValues() {\n+        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n+    }\n+\n+    /**\n+     * Test the normal approximation of the Poisson distribution by\n+     * calculating P(90 &le; X &le; 110) for X = Po(100) and\n+     * P(9900 &le; X &le; 10200) for X  = Po(10000)\n+     */\n+    public void testNormalApproximateProbability() throws Exception {\n+        PoissonDistribution dist = new PoissonDistributionImpl(100);\n+        double result = dist.normalApproximateProbability(110)\n+                - dist.normalApproximateProbability(89);\n+        assertEquals(0.706281887248, result, 1E-10);\n+        dist.setMean(10000);\n+        result = dist.normalApproximateProbability(10200)\n+        - dist.normalApproximateProbability(9899);\n+        assertEquals(0.820070051552, result, 1E-10);\n+    }\n+\n+    /**\n+     * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.\n+     * @throws Exception\n+     */\n+    public void testDegenerateInverseCumulativeProbability() throws Exception {\n+          PoissonDistribution dist = new PoissonDistributionImpl(\n+                    DEFAULT_TEST_POISSON_PARAMETER);\n+            assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n+            assertEquals(-1, dist.inverseCumulativeProbability(0d));\n+    }\n+}", "timestamp": 1099798369, "metainfo": ""}