{"sha": "9fb5d27fd15d856b136fbadd3d7bb7dfbd0ddf50", "log": "added proper and improper formats for BigFraction (both parsing and display)  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n       \"les valeurs NaN ne peuvent \\u00eatre converties\" },\n     { \"cannot convert infinite value\",\n       \"les valeurs infinies ne peuvent \\u00eatre converties\" },\n+\n+    // org.apache.commons.math.fraction.AbstractFormat\n+    { \"denominator format can not be null\",\n+      \"le format du d\\u00e9nominateur ne doit pas \\u00eatre nul\" },\n+    { \"numerator format can not be null\",\n+      \"le format du num\\u00e9rateur ne doit pas \\u00eatre nul\" },\n+\n+    // org.apache.commons.math.fraction.FractionFormat\n+    { \"cannot convert given object to a fraction number: {0}\",\n+      \"impossible de convertir l''objet sous forme d''un nombre rationnel : {0}\" },\n+\n+    // org.apache.commons.math.fraction.FractionFormat\n+    // org.apache.commons.math.fraction.BigFractionFormat\n+    { \"unparseable fraction number: \\\"{0}\\\"\",\n+      \"\\u00e9chec d''analyse du nombre rationnel \\\"{0}\\\"\" },\n+    { \"cannot format given object as a fraction number\",\n+      \"impossible de formater l''objet sous forme d''un nombre rationnel\" },\n+\n+    // org.apache.commons.math.fraction.ProperFractionFormat\n+    // org.apache.commons.math.fraction.ProperBigFractionFormat\n+    { \"whole format can not be null\",\n+      \"le format complet ne doit pas \\u00eatre nul\" },\n \n     // org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils\n     { \"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4},\" +\n    // org.apache.commons.math.complex.ComplexFormat\n    { \"unparseable complex number: \\\"{0}\\\"\",\n      \"\\u00e9chec d''analyse du nombre complexe \\\"{0}\\\"\" },\n-\n-   // org.apache.commons.math.fraction.FractionFormat\n-   { \"unparseable fraction number: \\\"{0}\\\"\",\n-     \"\\u00e9chec d''analyse du nombre rationnel \\\"{0}\\\"\" },\n \n    // org.apache.commons.math.geometry.Vector3DFormat\n    { \"unparseable 3D vector: \\\"{0}\\\"\",\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/AbstractFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+public abstract class AbstractFormat extends NumberFormat implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -6981118387974191891L;\n+\n+    /** The format used for the denominator. */\n+    protected NumberFormat denominatorFormat;\n+\n+    /** The format used for the numerator. */\n+    protected NumberFormat numeratorFormat;\n+\n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    protected AbstractFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    protected AbstractFormat(final NumberFormat format) {\n+        this(format, (NumberFormat) format.clone());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    protected AbstractFormat(final NumberFormat numeratorFormat,\n+                             final NumberFormat denominatorFormat) {\n+        this.numeratorFormat   = numeratorFormat;\n+        this.denominatorFormat = denominatorFormat;\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of BigFraction digits, which is set to 0.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of BigFraction digits, which is set to 0.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n+        final NumberFormat nf = NumberFormat.getNumberInstance(locale);\n+        nf.setMaximumFractionDigits(0);\n+        nf.setParseIntegerOnly(true);\n+        return nf;\n+    }\n+\n+    /**\n+     * Access the denominator format.\n+     * @return the denominator format.\n+     */\n+    public NumberFormat getDenominatorFormat() {\n+        return denominatorFormat;\n+    }\n+\n+    /**\n+     * Access the numerator format.\n+     * @return the numerator format.\n+     */\n+    public NumberFormat getNumeratorFormat() {\n+        return numeratorFormat;\n+    }\n+\n+    /**\n+     * Modify the denominator format.\n+     * @param format the new denominator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setDenominatorFormat(final NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"denominator format can not be null\");\n+        }\n+        this.denominatorFormat = format;\n+    }\n+\n+    /**\n+     * Modify the numerator format.\n+     * @param format the new numerator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setNumeratorFormat(final NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"numerator format can not be null\");\n+        }\n+        this.numeratorFormat = format;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected static void parseAndIgnoreWhitespace(final String source,\n+                                                   final ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected static char parseNextCharacter(final String source,\n+                                             final ParsePosition pos) {\n+         int index = pos.getIndex();\n+         final int n = source.length();\n+         char ret = 0;\n+\n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+\n+    /**\n+     * Formats a double value as a fraction and appends the result to a StringBuffer. \n+     *\n+     * @param value the double value to format\n+     * @param buffer StringBuffer to append to\n+     * @param position On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return a reference to the appended buffer\n+     * @see {@link #format(Object, StringBuffer, FieldPosition)}\n+     */\n+    public StringBuffer format(final double value,\n+                               final StringBuffer buffer, final FieldPosition position) {\n+        return format(Double.valueOf(value), buffer, position);\n+    }\n+\n+    \n+    /**\n+     * Formats a long value as a fraction and appends the result to a StringBuffer. \n+     *\n+     * @param value the long value to format\n+     * @param buffer StringBuffer to append to\n+     * @param position On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return a reference to the appended buffer\n+     * @see {@link #format(Object, StringBuffer, FieldPosition)}\n+     */\n+    public StringBuffer format(final long value,\n+                               final StringBuffer buffer, final FieldPosition position) {\n+        return format(Long.valueOf(value), buffer, position);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/BigFractionFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Formats a BigFraction number in proper format or improper format.\n+ * <p>\n+ * The number format for each of the whole number, numerator and,\n+ * denominator can be configured.\n+ * </p>\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class BigFractionFormat extends AbstractFormat implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2932167925527338976L;\n+\n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    public BigFractionFormat() {\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    public BigFractionFormat(final NumberFormat format) {\n+        super(format);\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public BigFractionFormat(final NumberFormat numeratorFormat,\n+                             final NumberFormat denominatorFormat) {\n+        super(numeratorFormat, denominatorFormat);\n+    }\n+\n+    /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * This static method calls formatBigFraction() on a default instance of\n+     * BigFractionFormat.\n+     *\n+     * @param f BigFraction object to format\n+     * @return A formatted BigFraction in proper form.\n+     */\n+    public static String formatBigFraction(final BigFraction f) {\n+        return getImproperInstance().format(f);\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static BigFractionFormat getImproperInstance() {\n+        return getImproperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static BigFractionFormat getImproperInstance(final Locale locale) {\n+        return new BigFractionFormat(getDefaultNumberFormat(locale));\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static BigFractionFormat getProperInstance() {\n+        return getProperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static BigFractionFormat getProperInstance(final Locale locale) {\n+        return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n+    }\n+    \n+    /**\n+     * Formats a {@link BigFraction} object to produce a string.  The BigFraction is\n+     * output in improper format.\n+     *\n+     * @param BigFraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(final BigFraction BigFraction,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        getNumeratorFormat().format(BigFraction.getNumerator(), toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(BigFraction.getDenominator(), toAppendTo, pos);\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats an object and appends the result to a StringBuffer.\n+     * <code>obj</code> must be either a  {@link BigFraction} object or a\n+     * {@link BigInteger} object or a {@link Number} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(final Object obj,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+\n+        final StringBuffer ret;\n+        if (obj instanceof BigFraction) {\n+            ret = format((BigFraction) obj, toAppendTo, pos);\n+        } else if (obj instanceof BigInteger) {\n+            ret = format(new BigFraction((BigInteger) obj), toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            ret = format(new BigFraction(((Number) obj).doubleValue()),\n+                         toAppendTo, pos);\n+        } else { \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot format given object as a fraction number\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link BigFraction} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link BigFraction} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public BigFraction parse(final String source) throws ParseException {\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final BigFraction result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable fraction number: \\\"{0}\\\"\", source);\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link BigFraction} object.\n+     * This method expects the string to be formatted as an improper BigFraction.  \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link BigFraction} object.\n+     */\n+    public BigFraction parse(final String source, final ParsePosition pos) {\n+        final int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse numerator\n+        final BigInteger num = parseNextBigInteger(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        final int startIndex = pos.getIndex();\n+        final char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a BigFraction\n+            return new BigFraction(num);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        final BigInteger den = parseNextBigInteger(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        return new BigFraction(num, den);\n+    }\n+\n+    /**\n+     * Parses a string to produce a <code>BigInteger</code>.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return a parsed <code>BigInteger</code> or null if string does not\n+     * contain a BigInteger at the specified position\n+     */\n+    protected BigInteger parseNextBigInteger(final String source,\n+                                             final ParsePosition pos) {\n+\n+        final int start = pos.getIndex();\n+         int end = (source.charAt(start) == '-') ? (start + 1) : start;\n+         while((end < source.length()) &&\n+               Character.isDigit(source.charAt(end))) {\n+             ++end;\n+         }\n+\n+         try {\n+             BigInteger n = new BigInteger(source.substring(start, end));\n+             pos.setIndex(end);\n+             return n;\n+         } catch (NumberFormatException nfe) {\n+             pos.setErrorIndex(start);\n+             return null;\n+         }\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n \n package org.apache.commons.math.fraction;\n \n-import java.io.Serializable;\n import java.text.FieldPosition;\n import java.text.NumberFormat;\n import java.text.ParseException;\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n-public class FractionFormat extends NumberFormat implements Serializable {\n+public class FractionFormat extends AbstractFormat {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -6337346779577272306L;\n-\n-    /** The format used for the denominator. */\n-    private NumberFormat denominatorFormat;\n-\n-    /** The format used for the numerator. */\n-    private NumberFormat numeratorFormat;\n-    \n+    private static final long serialVersionUID = 3008655719530972611L;\n+\n     /**\n      * Create an improper formatting instance with the default number format\n      * for the numerator and denominator.  \n      */\n     public FractionFormat() {\n-        this(getDefaultNumberFormat());\n     }\n \n     /**\n      * both the numerator and denominator.\n      * @param format the custom format for both the numerator and denominator.\n      */\n-    public FractionFormat(NumberFormat format) {\n-        this(format, (NumberFormat)format.clone());\n+    public FractionFormat(final NumberFormat format) {\n+        super(format);\n     }\n \n     /**\n      * @param numeratorFormat the custom format for the numerator.\n      * @param denominatorFormat the custom format for the denominator.\n      */\n-    public FractionFormat(NumberFormat numeratorFormat,\n-            NumberFormat denominatorFormat)\n-    {\n-        super();\n-        this.numeratorFormat = numeratorFormat;\n-        this.denominatorFormat = denominatorFormat;\n+    public FractionFormat(final NumberFormat numeratorFormat,\n+                          final NumberFormat denominatorFormat) {\n+        super(numeratorFormat, denominatorFormat);\n+    }\n+\n+    /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n     }\n \n     /**\n     }\n     \n     /**\n-     * Get the set of locales for which complex formats are available.  This\n-     * is the same set as the {@link NumberFormat} set. \n-     * @return available complex format locales.\n-     */\n-    public static Locale[] getAvailableLocales() {\n-        return NumberFormat.getAvailableLocales();\n-    }\n-    \n-    /**\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n      */\n      * @param locale the specific locale used by the format.\n      * @return the complex format specific to the given locale.\n      */\n-    public static FractionFormat getImproperInstance(Locale locale) {\n-        NumberFormat f = getDefaultNumberFormat(locale);\n-        return new FractionFormat(f);\n+    public static FractionFormat getImproperInstance(final Locale locale) {\n+        return new FractionFormat(getDefaultNumberFormat(locale));\n     }\n     \n     /**\n      * @param locale the specific locale used by the format.\n      * @return the complex format specific to the given locale.\n      */\n-    public static FractionFormat getProperInstance(Locale locale) {\n-        NumberFormat f = getDefaultNumberFormat(locale);\n-        return new ProperFractionFormat(f);\n+    public static FractionFormat getProperInstance(final Locale locale) {\n+        return new ProperFractionFormat(getDefaultNumberFormat(locale));\n     }\n     \n     /**\n      */\n     protected static NumberFormat getDefaultNumberFormat() {\n         return getDefaultNumberFormat(Locale.getDefault());\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of fraction digits, which is set to 0.  \n-     * @param locale the specific locale used by the format.\n-     * @return the default number format specific to the given locale.\n-     */\n-    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n-        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n-        nf.setMaximumFractionDigits(0);\n-        nf.setParseIntegerOnly(true);\n-        return nf;\n     }\n     \n     /**\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      */\n-    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n-            FieldPosition pos) {\n+    public StringBuffer format(final Fraction fraction,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n         \n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-            FieldPosition pos)\n-    {\n+    public StringBuffer format(final Object obj,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n         StringBuffer ret = null;\n         \n         if (obj instanceof Fraction) {\n-            ret = format( (Fraction)obj, toAppendTo, pos);\n+            ret = format((Fraction) obj, toAppendTo, pos);\n         } else if (obj instanceof Number) {\n             try {\n-                ret = format( new Fraction(((Number)obj).doubleValue()),\n-                    toAppendTo, pos);\n+                ret = format(new Fraction(((Number) obj).doubleValue()),\n+                             toAppendTo, pos);\n             } catch (ConvergenceException ex) {\n-                throw new IllegalArgumentException(\n-                    \"Cannot convert given object to a fraction.\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                    \"cannot convert given object to a fraction number: {0}\",\n+                    ex.getLocalizedMessage());\n             }\n         } else { \n-            throw new IllegalArgumentException(\n-                \"Cannot format given object as a fraction\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot format given object as a fraction number\");\n         }\n         \n         return ret;\n-    }\n-\n-    /**\n-     * Access the denominator format.\n-     * @return the denominator format.\n-     */\n-    public NumberFormat getDenominatorFormat() {\n-        return denominatorFormat;\n-    }\n-    \n-    /**\n-     * Access the numerator format.\n-     * @return the numerator format.\n-     */\n-    public NumberFormat getNumeratorFormat() {\n-        return numeratorFormat;\n     }\n \n     /**\n      * @exception ParseException if the beginning of the specified string\n      *            cannot be parsed.\n      */\n-    public Fraction parse(String source) throws ParseException {\n-        ParsePosition parsePosition = new ParsePosition(0);\n-        Fraction result = parse(source, parsePosition);\n+    public Fraction parse(final String source) throws ParseException {\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final Fraction result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n             throw MathRuntimeException.createParseException(\n                     parsePosition.getErrorIndex(),\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n      */\n-    public Fraction parse(String source, ParsePosition pos) {\n-        int initialIndex = pos.getIndex();\n+    public Fraction parse(final String source, final ParsePosition pos) {\n+        final int initialIndex = pos.getIndex();\n \n         // parse whitespace\n         parseAndIgnoreWhitespace(source, pos);\n \n         // parse numerator\n-        Number num = getNumeratorFormat().parse(source, pos);\n+        final Number num = getNumeratorFormat().parse(source, pos);\n         if (num == null) {\n             // invalid integer number\n             // set index back to initial, error index should already be set\n         }\n \n         // parse '/'\n-        int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n+        final int startIndex = pos.getIndex();\n+        final char c = parseNextCharacter(source, pos);\n         switch (c) {\n         case 0 :\n             // no '/'\n         parseAndIgnoreWhitespace(source, pos);\n \n         // parse denominator\n-        Number den = getDenominatorFormat().parse(source, pos);\n+        final Number den = getDenominatorFormat().parse(source, pos);\n         if (den == null) {\n             // invalid integer number\n             // set index back to initial, error index should already be set\n         return new Fraction(num.intValue(), den.intValue());\n     }\n     \n-    /**\n-     * Modify the denominator format.\n-     * @param format the new denominator format value.\n-     * @throws IllegalArgumentException if <code>format</code> is\n-     *         <code>null</code>.\n-     */\n-    public void setDenominatorFormat(NumberFormat format) {\n-        if (format == null) {\n-            throw new IllegalArgumentException(\n-                \"denominator format can not be null.\");\n-        }\n-        this.denominatorFormat = format;\n-    }\n-    \n-    /**\n-     * Modify the numerator format.\n-     * @param format the new numerator format value.\n-     * @throws IllegalArgumentException if <code>format</code> is\n-     *         <code>null</code>.\n-     */\n-    public void setNumeratorFormat(NumberFormat format) {\n-        if (format == null) {\n-            throw new IllegalArgumentException(\n-                \"numerator format can not be null.\");\n-        }\n-        this.numeratorFormat = format;\n-    }\n-     \n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n-     *        holds the index of the next non-whitespace character.\n-     */\n-    protected static void parseAndIgnoreWhitespace(\n-        String source, ParsePosition pos)\n-    {\n-        parseNextCharacter(source, pos);\n-        pos.setIndex(pos.getIndex() - 1);\n-    }\n-\n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the first non-whitespace character.\n-     */\n-    protected static char parseNextCharacter(String source, ParsePosition pos) {\n-         int index = pos.getIndex();\n-         int n = source.length();\n-         char ret = 0;\n-\n-         if (index < n) {\n-             char c;\n-             do {\n-                 c = source.charAt(index++);\n-             } while (Character.isWhitespace(c) && index < n);\n-             pos.setIndex(index);\n-         \n-             if (index < n) {\n-                 ret = c;\n-             }\n-         }\n-         \n-         return ret;\n-    }\n-\n-    /**\n-     * Formats a double value as a fraction and appends the result to a StringBuffer. \n-     *\n-     * @param value the double value to format\n-     * @param buffer StringBuffer to append to\n-     * @param position On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return a reference to the appended buffer\n-     * @see {@link #format(Object, StringBuffer, FieldPosition)}\n-     */\n-    public StringBuffer format(double value, StringBuffer buffer,\n-            FieldPosition position) {\n-        return format(Double.valueOf(value), buffer, position);\n-    }\n-\n-    \n-    /**\n-     * Formats a long value as a fraction and appends the result to a StringBuffer. \n-     *\n-     * @param value the long value to format\n-     * @param buffer StringBuffer to append to\n-     * @param position On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return a reference to the appended buffer\n-     * @see {@link #format(Object, StringBuffer, FieldPosition)}\n-     */\n-    public StringBuffer format(long value, StringBuffer buffer, FieldPosition position) {\n-        return format(Long.valueOf(value), buffer, position);\n-    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigInteger;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Formats a BigFraction number in proper format.  The number format for each of\n+ * the whole number, numerator and, denominator can be configured.\n+ * <p>\n+ * Minus signs are only allowed in the whole number part - i.e.,\n+ * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+ * will result in a <code>ParseException</code>.</p>\n+ * \n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class ProperBigFractionFormat extends BigFractionFormat {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6337346779577272307L;\n+    \n+    /** The format used for the whole number. */\n+    private NumberFormat wholeFormat;\n+\n+    /**\n+     * Create a proper formatting instance with the default number format for\n+     * the whole, numerator, and denominator.  \n+     */\n+    public ProperBigFractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for the\n+     * whole, numerator, and denominator.\n+     * @param format the custom format for the whole, numerator, and\n+     *        denominator.\n+     */\n+    public ProperBigFractionFormat(final NumberFormat format) {\n+        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for each\n+     * of the whole, numerator, and denominator.\n+     * @param wholeFormat the custom format for the whole.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public ProperBigFractionFormat(final NumberFormat wholeFormat,\n+                                   final NumberFormat numeratorFormat,\n+                                   final NumberFormat denominatorFormat) {\n+        super(numeratorFormat, denominatorFormat);\n+        setWholeFormat(wholeFormat);\n+    }\n+    \n+    /**\n+     * Formats a {@link BigFraction} object to produce a string.  The BigFraction\n+     * is output in proper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(final BigFraction fraction,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        BigInteger num = fraction.getNumerator();\n+        BigInteger den = fraction.getDenominator();\n+        BigInteger whole = num.divide(den);\n+        num = num.remainder(den);\n+        \n+        if (!BigInteger.ZERO.equals(whole)) {\n+            getWholeFormat().format(whole, toAppendTo, pos);\n+            toAppendTo.append(' ');\n+            if (num.compareTo(BigInteger.ZERO) < 0) {\n+                num = num.negate();\n+            }\n+        }\n+        getNumeratorFormat().format(num, toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(den, toAppendTo, pos);\n+        \n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Access the whole format.\n+     * @return the whole format.\n+     */\n+    public NumberFormat getWholeFormat() {\n+        return wholeFormat;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link BigFraction} object.  This method\n+     * expects the string to be formatted as a proper BigFraction.\n+     * <p>\n+     * Minus signs are only allowed in the whole number part - i.e.,\n+     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+     * will result in a <code>ParseException</code>.</p>\n+     * \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link BigFraction} object.\n+     */\n+    public BigFraction parse(final String source, final ParsePosition pos) {\n+        // try to parse improper BigFraction\n+        BigFraction ret = super.parse(source, pos);\n+        if (ret != null) {\n+            return ret;\n+        }\n+        \n+        final int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse whole\n+        BigInteger whole = parseNextBigInteger(source, pos);\n+        if (whole == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+        \n+        // parse numerator\n+        BigInteger num = parseNextBigInteger(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (num.compareTo(BigInteger.ZERO) < 0) {\n+            // minus signs should be leading, invalid expression\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        final int startIndex = pos.getIndex();\n+        final char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a BigFraction\n+            return new BigFraction(num);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        final BigInteger den = parseNextBigInteger(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (den.compareTo(BigInteger.ZERO) < 0) {\n+            // minus signs must be leading, invalid\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        boolean wholeIsNeg = whole.compareTo(BigInteger.ZERO) < 0;\n+        if (wholeIsNeg) {\n+            whole = whole.negate();\n+        }\n+        num = whole.multiply(den).add(num);\n+        if (wholeIsNeg) {\n+            num = num.negate();\n+        }\n+\n+        return new BigFraction(num, den);\n+\n+    }\n+    \n+    /**\n+     * Modify the whole format.\n+     * @param format The new whole format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setWholeFormat(final NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"whole format can not be null\");\n+        }\n+        this.wholeFormat = format;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n import java.text.NumberFormat;\n import java.text.ParsePosition;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n public class ProperFractionFormat extends FractionFormat {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -6337346779577272307L;\n-    \n+    private static final long serialVersionUID = 760934726031766749L;\n+\n     /** The format used for the whole number. */\n     private NumberFormat wholeFormat;\n \n      */\n     public void setWholeFormat(NumberFormat format) {\n         if (format == null) {\n-            throw new IllegalArgumentException(\n-                \"whole format can not be null.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"whole format can not be null\");\n         }\n         this.wholeFormat = format;\n     }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigInteger;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+public class BigFractionFormatTest extends TestCase {\n+ \n+    BigFractionFormat properFormat = null;\n+    BigFractionFormat improperFormat = null;\n+\n+    protected Locale getLocale() {\n+        return Locale.getDefault();\n+    }\n+\n+    protected void setUp() throws Exception {\n+        properFormat = BigFractionFormat.getProperInstance(getLocale());\n+        improperFormat = BigFractionFormat.getImproperInstance(getLocale());\n+    }\n+   \n+    public void testFormat() {\n+        BigFraction c = new BigFraction(1, 2);\n+        String expected = \"1 / 2\";\n+        \n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatNegative() {\n+        BigFraction c = new BigFraction(-1, 2);\n+        String expected = \"-1 / 2\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatZero() {\n+        BigFraction c = new BigFraction(0, 1);\n+        String expected = \"0 / 1\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testFormatImproper() {\n+        BigFraction c = new BigFraction(5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"5 / 3\", actual);\n+    }\n+    \n+    public void testFormatImproperNegative() {\n+        BigFraction c = new BigFraction(-5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"-5 / 3\", actual);\n+    }\n+    \n+    public void testParse() {\n+        String source = \"1 / 2\";\n+\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.ONE, c.getNumerator());\n+            assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.ONE, c.getNumerator());\n+            assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInteger() {\n+        String source = \"10\";\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.TEN, c.getNumerator());\n+            assertEquals(BigInteger.ONE, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        try {\n+            BigFraction c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(BigInteger.TEN, c.getNumerator());\n+            assertEquals(BigInteger.ONE, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInvalid() {\n+        String source = \"a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseInvalidDenominator() {\n+        String source = \"10 / a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseNegative() {\n+\n+        try {\n+            String source = \"-1 / 2\";\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+\n+            source = \"1 / -2\";\n+            c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumeratorAsInt());\n+            assertEquals(2, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseProper() {\n+        String source = \"1 2 / 3\";\n+\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(5, c.getNumeratorAsInt());\n+            assertEquals(3, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperNegative() {\n+        String source = \"-1 2 / 3\";\n+        try {\n+            BigFraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-5, c.getNumeratorAsInt());\n+            assertEquals(3, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperInvalidMinus() {\n+        String source = \"2 -2 / 3\";\n+        try {\n+            properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+        source = \"2 2 / -3\";\n+        try {\n+            properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testNumeratorFormat() {\n+        NumberFormat old = properFormat.getNumeratorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, properFormat.getNumeratorFormat());\n+        properFormat.setNumeratorFormat(old);\n+\n+        old = improperFormat.getNumeratorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, improperFormat.getNumeratorFormat());\n+        improperFormat.setNumeratorFormat(old);\n+    }\n+    \n+    public void testDenominatorFormat() {\n+        NumberFormat old = properFormat.getDenominatorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, properFormat.getDenominatorFormat());\n+        properFormat.setDenominatorFormat(old);\n+\n+        old = improperFormat.getDenominatorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, improperFormat.getDenominatorFormat());\n+        improperFormat.setDenominatorFormat(old);\n+    }\n+    \n+    public void testWholeFormat() {\n+        ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;\n+        \n+        NumberFormat old = format.getWholeFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        format.setWholeFormat(nf);\n+        assertEquals(nf, format.getWholeFormat());\n+        format.setWholeFormat(old);\n+    }\n+    \n+    public void testLongFormat() {\n+        assertEquals(\"10 / 1\", improperFormat.format(10l));\n+    }\n+    \n+    public void testDoubleFormat() {\n+        assertEquals(\"1 / 16\", improperFormat.format(0.0625));\n+    }\n+}", "timestamp": 1238344433, "metainfo": ""}