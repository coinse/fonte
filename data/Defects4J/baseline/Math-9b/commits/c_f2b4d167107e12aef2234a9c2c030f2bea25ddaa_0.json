{"sha": "f2b4d167107e12aef2234a9c2c030f2bea25ddaa", "log": "Merged KolmogorovSmirnovDistribution and KolmogorovSmirnovDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.fraction.BigFractionField;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n /**\n- * Treats the distribution of the two-sided\n- * {@code P(D}<sub>{@code n}</sub>{@code < d)}\n- * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the\n- * theoretical cdf G and the emperical cdf Gn.\n+ * Implementation of the Kolmogorov-Smirnov distribution.\n  *\n+ * <p>\n+ * Treats the distribution of the two-sided {@code P(D_n < d)} where\n+ * {@code D_n = sup_x |G(x) - G_n (x)|} for the theoretical cdf {@code G} and\n+ * the empirical cdf {@code G_n}.\n+ * </p>\n+ * <p>\n+ * This implementation is based on [1] with certain quick decisions for extreme\n+ * values given in [2].\n+ * </p>\n+ * <p>\n+ * In short, when wanting to evaluate {@code P(D_n < d)}, the method in [1] is\n+ * to write {@code d = (k - h) / n} for positive integer {@code k} and\n+ * {@code 0 <= h < 1}. Then {@code P(D_n < d) = (n! / n^n) * t_kk}, where\n+ * {@code t_kk} is the {@code (k, k)}'th entry in the special matrix\n+ * {@code H^n}, i.e. {@code H} to the {@code n}'th power.\n+ * </p>\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li>[1] <a href=\"http://www.jstatsoft.org/v08/i18/\">\n+ * Evaluating Kolmogorov's Distribution</a> by George Marsaglia, Wai\n+ * Wan Tsang, and Jingbo Wang</li>\n+ * <li>[2] <a href=\"http://www.jstatsoft.org/v39/i11/\">\n+ * Computing the Two-Sided Kolmogorov-Smirnov Distribution</a> by Richard Simard\n+ * and Pierre L'Ecuyer</li>\n+ * </ul>\n+ * Note that [1] contains an error in computing h, refer to\n+ * <a href=\"https://issues.apache.org/jira/browse/MATH-437\">MATH-437</a> for details.\n+ * </p>\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test\">\n+ * Kolmogorov-Smirnov test (Wikipedia)</a>\n  * @version $Id$\n  */\n-public interface KolmogorovSmirnovDistribution {\n-\n-    /**\n-     * Calculates {@code P(D}<sub>n</sub> {@code < d)}.\n-     *\n-     * @param d statistic\n-     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n-     */\n-    double cdf(double d);\n-\n+public class KolmogorovSmirnovDistribution implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4670676796862967187L;\n+\n+    /** Number of observations. */\n+    private int n;\n+\n+    /**\n+     * @param n Number of observations\n+     * @throws NotStrictlyPositiveException if {@code n <= 0}\n+     */\n+    public KolmogorovSmirnovDistribution(int n)\n+        throws NotStrictlyPositiveException {\n+        if (n <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, n);\n+        }\n+\n+        this.n = n;\n+    }\n+\n+    /**\n+     * Calculates {@code P(D_n < d)} using method described in [1] with quick\n+     * decisions for extreme values given in [2] (see above). The result is not\n+     * exact as with\n+     * {@link KolmogorovSmirnovDistribution#cdfExact(double)} because\n+     * calculations are based on {@code double} rather than\n+     * {@link org.apache.commons.math.fraction.BigFraction}.\n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D_n < d)}\n+     * @throws MathArithmeticException if algorithm fails to convert {@code h}\n+     * to a {@link org.apache.commons.math.fraction.BigFraction} in expressing\n+     * {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n+     * {@code 0 <= h < 1}.\n+     */\n+    public double cdf(double d) throws MathArithmeticException {\n+        return this.cdf(d, false);\n+    }\n+\n+    /**\n+     * Calculates {@code P(D_n < d)} using method described in [1] with quick\n+     * decisions for extreme values given in [2] (see above). The result is\n+     * exact in the sense that BigFraction/BigReal is used everywhere at the\n+     * expense of very slow execution time. Almost never choose this in real\n+     * applications unless you are very sure; this is almost solely for\n+     * verification purposes. Normally, you would choose\n+     * {@link KolmogorovSmirnovDistribution#cdf(double)}\n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D_n < d)}\n+     * @throws MathArithmeticException if algorithm fails to convert {@code h}\n+     * to a {@link org.apache.commons.math.fraction.BigFraction} in expressing\n+     * {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n+     * {@code 0 <= h < 1}.\n+     */\n+    public double cdfExact(double d) throws MathArithmeticException {\n+        return this.cdf(d, true);\n+    }\n+\n+    /**\n+     * Calculates {@code P(D_n < d)} using method described in [1] with quick\n+     * decisions for extreme values given in [2] (see above).\n+     *\n+     * @param d statistic\n+     * @param exact whether the probability should be calculated exact using\n+     * {@link org.apache.commons.math.fraction.BigFraction} everywhere at the\n+     * expense of very slow execution time, or if {@code double} should be used\n+     * convenient places to gain speed. Almost never choose {@code true} in real\n+     * applications unless you are very sure; {@code true} is almost solely for\n+     * verification purposes.\n+     * @return the two-sided probability of {@code P(D_n < d)}\n+     * @throws MathArithmeticException if algorithm fails to convert {@code h}\n+     * to a {@link org.apache.commons.math.fraction.BigFraction} in expressing\n+     * {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n+     * {@code 0 <= h < 1}.\n+     */\n+    public double cdf(double d, boolean exact) throws MathArithmeticException {\n+\n+        final double ninv = 1 / ((double) n);\n+        final double ninvhalf = 0.5 * ninv;\n+\n+        if (d <= ninvhalf) {\n+\n+            return 0;\n+\n+        } else if (ninvhalf < d && d <= ninv) {\n+\n+            double res = 1;\n+            double f = 2 * d - ninv;\n+\n+            // n! f^n = n*f * (n-1)*f * ... * 1*x\n+            for (int i = 1; i <= n; ++i) {\n+                res *= i * f;\n+            }\n+\n+            return res;\n+\n+        } else if (1 - ninv <= d && d < 1) {\n+\n+            return 1 - 2 * Math.pow(1 - d, n);\n+\n+        } else if (1 <= d) {\n+\n+            return 1;\n+        }\n+\n+        return exact ? exactK(d) : roundedK(d);\n+    }\n+\n+    /**\n+     * Calculates the exact value of {@code P(D_n < d)} using method described\n+     * in [1] and {@link org.apache.commons.math.fraction.BigFraction} (see\n+     * above).\n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D_n < d)}\n+     * @throws MathArithmeticException if algorithm fails to convert {@code h}\n+     * to a {@link org.apache.commons.math.fraction.BigFraction} in expressing\n+     * {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n+     * {@code 0 <= h < 1}.\n+     */\n+    private double exactK(double d) throws MathArithmeticException {\n+\n+        final int k = (int) Math.ceil(n * d);\n+\n+        final FieldMatrix<BigFraction> H = this.createH(d);\n+        final FieldMatrix<BigFraction> Hpower = H.power(n);\n+\n+        BigFraction pFrac = Hpower.getEntry(k - 1, k - 1);\n+\n+        for (int i = 1; i <= n; ++i) {\n+            pFrac = pFrac.multiply(i).divide(n);\n+        }\n+\n+        /*\n+         * BigFraction.doubleValue converts numerator to double and the\n+         * denominator to double and divides afterwards. That gives NaN quite\n+         * easy. This does not (scale is the number of digits):\n+         */\n+        return pFrac.bigDecimalValue(20, BigDecimal.ROUND_HALF_UP).doubleValue();\n+    }\n+\n+    /**\n+     * Calculates {@code P(D_n < d)} using method described in [1] and doubles\n+     * (see above).\n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D_n < d)}\n+     * @throws MathArithmeticException if algorithm fails to convert {@code h}\n+     * to a {@link org.apache.commons.math.fraction.BigFraction} in expressing\n+     * {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n+     * {@code 0 <= h < 1}.\n+     */\n+    private double roundedK(double d) throws MathArithmeticException {\n+\n+        final int k = (int) Math.ceil(n * d);\n+        final FieldMatrix<BigFraction> HBigFraction = this.createH(d);\n+        final int m = HBigFraction.getRowDimension();\n+\n+        /*\n+         * Here the rounding part comes into play: use\n+         * RealMatrix instead of FieldMatrix<BigFraction>\n+         */\n+        final RealMatrix H = new Array2DRowRealMatrix(m, m);\n+\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = 0; j < m; ++j) {\n+                H.setEntry(i, j, HBigFraction.getEntry(i, j).doubleValue());\n+            }\n+        }\n+\n+        final RealMatrix Hpower = H.power(n);\n+\n+        double pFrac = Hpower.getEntry(k - 1, k - 1);\n+\n+        for (int i = 1; i <= n; ++i) {\n+            pFrac *= (double)i / (double)n;\n+        }\n+\n+        return pFrac;\n+    }\n+\n+    /***\n+     * Creates {@code H} of size {@code m x m} as described in [1] (see above).\n+     *\n+     * @param d statistic\n+     * @return H matrix\n+     * @throws NumberIsTooLargeException if fractional part is greater than 1\n+     * @throws FractionConversionException if algorithm fails to convert\n+     * {@code h} to a {@link org.apache.commons.math.fraction.BigFraction} in\n+     * expressing {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n+     * {@code 0 <= h < 1}.\n+     */\n+    private FieldMatrix<BigFraction> createH(double d)\n+            throws NumberIsTooLargeException, FractionConversionException {\n+\n+        int k = (int) Math.ceil(n * d);\n+\n+        int m = 2 * k - 1;\n+        double hDouble = k - n * d;\n+\n+        if (hDouble >= 1) {\n+            throw new NumberIsTooLargeException(hDouble, 1.0, false);\n+        }\n+\n+        BigFraction h = null;\n+\n+        try {\n+            h = new BigFraction(hDouble, 1.0e-20, 10000);\n+        } catch (FractionConversionException e1) {\n+            try {\n+                h = new BigFraction(hDouble, 1.0e-10, 10000);\n+            } catch (FractionConversionException e2) {\n+                h = new BigFraction(hDouble, 1.0e-5, 10000);\n+            }\n+        }\n+\n+        final BigFraction[][] Hdata = new BigFraction[m][m];\n+\n+        /*\n+         * Start by filling everything with either 0 or 1.\n+         */\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = 0; j < m; ++j) {\n+                if (i - j + 1 < 0) {\n+                    Hdata[i][j] = BigFraction.ZERO;\n+                } else {\n+                    Hdata[i][j] = BigFraction.ONE;\n+                }\n+            }\n+        }\n+\n+        /*\n+         * Setting up power-array to avoid calculating the same value twice:\n+         * hPowers[0] = h^1 ... hPowers[m-1] = h^m\n+         */\n+        final BigFraction[] hPowers = new BigFraction[m];\n+        hPowers[0] = h;\n+        for (int i = 1; i < m; ++i) {\n+            hPowers[i] = h.multiply(hPowers[i - 1]);\n+        }\n+\n+        /*\n+         * First column and last row has special values (each other reversed).\n+         */\n+        for (int i = 0; i < m; ++i) {\n+            Hdata[i][0] = Hdata[i][0].subtract(hPowers[i]);\n+            Hdata[m - 1][i] = Hdata[m - 1][i].subtract(hPowers[m - i - 1]);\n+        }\n+\n+        /*\n+         * [1] states: \"For 1/2 < h < 1 the bottom left element of the matrix\n+         * should be (1 - 2*h^m + (2h - 1)^m )/m!\" Since 0 <= h < 1, then if h >\n+         * 1/2 is sufficient to check:\n+         */\n+        if (h.compareTo(BigFraction.ONE_HALF) == 1) {\n+            Hdata[m - 1][0] = Hdata[m - 1][0].add(h.multiply(2).subtract(1).pow(m));\n+        }\n+\n+        /*\n+         * Aside from the first column and last row, the (i, j)-th element is\n+         * 1/(i - j + 1)! if i - j + 1 >= 0, else 0. 1's and 0's are already\n+         * put, so only division with (i - j + 1)! is needed in the elements\n+         * that have 1's. There is no need to calculate (i - j + 1)! and then\n+         * divide - small steps avoid overflows.\n+         *\n+         * Note that i - j + 1 > 0 <=> i + 1 > j instead of j'ing all the way to\n+         * m. Also note that it is started at g = 2 because dividing by 1 isn't\n+         * really necessary.\n+         */\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = 0; j < i + 1; ++j) {\n+                if (i - j + 1 > 0) {\n+                    for (int g = 2; g <= i - j + 1; ++g) {\n+                        Hdata[i][j] = Hdata[i][j].divide(g);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<BigFraction>(BigFractionField.getInstance(), Hdata);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionTest.java\n import org.junit.Test;\n \n /**\n- * Test cases for {@link KolmogorovSmirnovDistributionImpl}.\n+ * Test cases for {@link KolmogorovSmirnovDistribution}.\n  *\n  * @version $Id$\n  */\n     @Test\n     public void testCumulativeDensityFunction() throws Exception {\n         \n-        KolmogorovSmirnovDistributionImpl dist;\n+        KolmogorovSmirnovDistribution dist;\n         \n         /* The code below is generated using the R-script located in\n          * /src/test/R/KolmogorovSmirnovDistributionTestCases.R\n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.005), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n          * 4.907829957616471622388047046469198862537e-86\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        dist = new KolmogorovSmirnovDistribution(200);\n         Assert.assertEquals(4.907829957616471622388047046469198862537e-86, dist.cdf(0.005, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.02), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n          * 5.151982014280041957199687829849210629618e-06\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        dist = new KolmogorovSmirnovDistribution(200);\n         Assert.assertEquals(5.151982014280041957199687829849210629618e-06, dist.cdf(0.02, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.031111), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n          * 0.01291614648162886340443389343590752105229\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        dist = new KolmogorovSmirnovDistribution(200);\n         Assert.assertEquals(0.01291614648162886340443389343590752105229, dist.cdf(0.031111, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.04), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n          * 0.1067137011362679355208626930107129737735\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        dist = new KolmogorovSmirnovDistribution(200);\n         Assert.assertEquals(0.1067137011362679355208626930107129737735, dist.cdf(0.04, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.005), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n          * 1.914734701559404553985102395145063418825e-53\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        dist = new KolmogorovSmirnovDistribution(341);\n         Assert.assertEquals(1.914734701559404553985102395145063418825e-53, dist.cdf(0.005, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.02), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n          * 0.001171328985781981343872182321774744195864\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        dist = new KolmogorovSmirnovDistribution(341);\n         Assert.assertEquals(0.001171328985781981343872182321774744195864, dist.cdf(0.02, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.031111), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n          * 0.1142955196267499418105728636874118819833\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        dist = new KolmogorovSmirnovDistribution(341);\n         Assert.assertEquals(0.1142955196267499418105728636874118819833, dist.cdf(0.031111, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.04), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n          * 0.3685529520496805266915885113121476024389\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        dist = new KolmogorovSmirnovDistribution(341);\n         Assert.assertEquals(0.3685529520496805266915885113121476024389, dist.cdf(0.04, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.005), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n          * 1.810657144595055888918455512707637574637e-47\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        dist = new KolmogorovSmirnovDistribution(389);\n         Assert.assertEquals(1.810657144595055888918455512707637574637e-47, dist.cdf(0.005, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.02), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n          * 0.003068542559702356568168690742481885536108\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        dist = new KolmogorovSmirnovDistribution(389);\n         Assert.assertEquals(0.003068542559702356568168690742481885536108, dist.cdf(0.02, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.031111), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n          * 0.1658291700122746237244797384846606291831\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        dist = new KolmogorovSmirnovDistribution(389);\n         Assert.assertEquals(0.1658291700122746237244797384846606291831, dist.cdf(0.031111, false), TOLERANCE);\n \n         /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.04), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n          * 0.4513143712128902529379104180407011881471\n          */\n-        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        dist = new KolmogorovSmirnovDistribution(389);\n         Assert.assertEquals(0.4513143712128902529379104180407011881471, dist.cdf(0.04, false), TOLERANCE);\n \n     }", "timestamp": 1322304806, "metainfo": ""}