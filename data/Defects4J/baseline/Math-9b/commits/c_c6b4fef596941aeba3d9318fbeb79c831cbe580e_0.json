{"sha": "c6b4fef596941aeba3d9318fbeb79c831cbe580e", "log": "- Merged ExponentialDistribution and ExponentialDistributionImpl (MATH-711). - Merged FDistribution and FDistributionImpl (MATH-711). - Merged GammaDistribution and GammaDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n-\n-\n-/**\n- * Implementation of the chi-squared distribution.\n- *\n- * @see <a href=\"http://en.wikipedia.org/wiki/Chi-squared_distribution\">Chi-squared distribution (Wikipedia)</a>\n- * @see <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">Chi-squared Distribution (MathWorld)</a>\n- * @version $Id$\n- */\n-public class ChiSquaredDistribution\n-    extends AbstractContinuousDistribution\n-    implements Serializable {\n-    /**\n-     * Default inverse cumulative probability accuracy\n-     * @since 2.1\n-     */\n-    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -8352658048349159782L;\n-    /** Internal Gamma distribution. */\n-    private final GammaDistribution gamma;\n-    /** Inverse cumulative probability accuracy */\n-    private final double solverAbsoluteAccuracy;\n-\n-    /**\n-     * Create a Chi-Squared distribution with the given degrees of freedom.\n-     *\n-     * @param degreesOfFreedom Degrees of freedom.\n-     */\n-    public ChiSquaredDistribution(double degreesOfFreedom) {\n-        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n-     * Create a Chi-Squared distribution with the given degrees of freedom and\n-     * inverse cumulative probability accuracy.\n-     *\n-     * @param degreesOfFreedom Degrees of freedom.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse\n-     * cumulative probability estimates (defaults to\n-     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n-     * @since 2.1\n-     */\n-    public ChiSquaredDistribution(double degreesOfFreedom,\n-                                      double inverseCumAccuracy) {\n-        gamma = new GammaDistributionImpl(degreesOfFreedom / 2, 2);\n-        solverAbsoluteAccuracy = inverseCumAccuracy;\n-    }\n-\n-    /**\n-     * Access the number of degrees of freedom.\n-     *\n-     * @return the degrees of freedom.\n-     */\n-    public double getDegreesOfFreedom() {\n-        return gamma.getAlpha() * 2.0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double density(double x) {\n-        return gamma.density(x);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double cumulativeProbability(double x)  {\n-        return gamma.cumulativeProbability(x);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * Returns {@code 0} when {@code p == 0} and\n-     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n-     */\n-    @Override\n-    public double inverseCumulativeProbability(final double p) {\n-        if (p == 0) {\n-            return 0d;\n-        }\n-        if (p == 1) {\n-            return Double.POSITIVE_INFINITY;\n-        }\n-        return super.inverseCumulativeProbability(p);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainLowerBound(double p) {\n-        return Double.MIN_VALUE * gamma.getBeta();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n-\n-        double ret;\n-\n-        if (p < .5) {\n-            // use mean\n-            ret = getDegreesOfFreedom();\n-        } else {\n-            // use max\n-            ret = Double.MAX_VALUE;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > 0.5\n-\n-        double ret;\n-\n-        if (p < 0.5) {\n-            // use 1/2 mean\n-            ret = getDegreesOfFreedom() * 0.5;\n-        } else {\n-            // use mean\n-            ret = getDegreesOfFreedom();\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getSolverAbsoluteAccuracy() {\n-        return solverAbsoluteAccuracy;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The lower bound of the support is always 0 no matter the\n-     * degrees of freedom.\n-     *\n-     * @return lower bound of the support (always 0)\n-     */\n-    @Override\n-    public double getSupportLowerBound() {\n-        return 0;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The upper bound of the support is always positive infinity no matter the\n-     * degrees of freedom.\n-     *\n-     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n-     */\n-    @Override\n-    public double getSupportUpperBound() {\n-        return Double.POSITIVE_INFINITY;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For {@code k} degrees of freedom, the mean is {@code k}.\n-     */\n-    @Override\n-    protected double calculateNumericalMean() {\n-        return getDegreesOfFreedom();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * For {@code k} degrees of freedom, the variance is {@code 2 * k}.\n-     *\n-     * @return {@inheritDoc}\n-     */\n-    @Override\n-    protected double calculateNumericalVariance() {\n-        return 2*getDegreesOfFreedom();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public boolean isSupportLowerBoundInclusive() {\n-        return true;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public boolean isSupportUpperBoundInclusive() {\n-        return false;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * Implementation of the chi-squared distribution.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Chi-squared_distribution\">Chi-squared distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">Chi-squared Distribution (MathWorld)</a>\n+ * @version $Id: ChiSquaredDistribution.java 1206060 2011-11-25 05:16:56Z celestin $\n+ */\n+public class ChiSquaredDistribution\n+    extends AbstractContinuousDistribution\n+    implements Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8352658048349159782L;\n+    /** Internal Gamma distribution. */\n+    private final GammaDistribution gamma;\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     */\n+    public ChiSquaredDistribution(double degreesOfFreedom) {\n+        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom and\n+     * inverse cumulative probability accuracy.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @since 2.1\n+     */\n+    public ChiSquaredDistribution(double degreesOfFreedom,\n+                                      double inverseCumAccuracy) {\n+        gamma = new GammaDistribution(degreesOfFreedom / 2, 2);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Access the number of degrees of freedom.\n+     *\n+     * @return the degrees of freedom.\n+     */\n+    public double getDegreesOfFreedom() {\n+        return gamma.getAlpha() * 2.0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        return gamma.density(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x)  {\n+        return gamma.cumulativeProbability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p == 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return Double.MIN_VALUE * gamma.getBeta();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < .5) {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        } else {\n+            // use max\n+            ret = Double.MAX_VALUE;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > 0.5\n+\n+        double ret;\n+\n+        if (p < 0.5) {\n+            // use 1/2 mean\n+            ret = getDegreesOfFreedom() * 0.5;\n+        } else {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the\n+     * degrees of freedom.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * degrees of freedom.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code k} degrees of freedom, the mean is {@code k}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getDegreesOfFreedom();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code k} degrees of freedom, the variance is {@code 2 * k}.\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return 2*getDegreesOfFreedom();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * The Exponential Distribution.\n+ * Implementation of the exponential distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n- * Exponential Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Exponential_distribution\">Exponential distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">Exponential distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface ExponentialDistribution extends ContinuousDistribution {\n+public class ExponentialDistribution extends AbstractContinuousDistribution\n+    implements Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 2401296428283614780L;\n+    /** The mean of this distribution. */\n+    private final double mean;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a exponential distribution with the given mean.\n+     * @param mean mean of this distribution.\n+     */\n+    public ExponentialDistribution(double mean) {\n+        this(mean, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a exponential distribution with the given mean.\n+     *\n+     * @param mean Mean of this distribution.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n+     * @since 2.1\n+     */\n+    public ExponentialDistribution(double mean, double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException{\n+        if (mean <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n+        }\n+        this.mean = mean;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n     /**\n      * Access the mean.\n      *\n      * @return the mean.\n      */\n-    double getMean();\n+    public double getMean() {\n+        return mean;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return FastMath.exp(-x / mean) / mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n+     * Exponential Distribution</a>, equation (1).</li>\n+     * </ul>\n+     */\n+    public double cumulativeProbability(double x)  {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = 1.0 - FastMath.exp(-x / mean);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p= = 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) throws OutOfRangeException {\n+        double ret;\n+\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0.0, 1.0);\n+        } else if (p == 1.0) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = -mean * FastMath.log(1.0 - p);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p><strong>Algorithm Description</strong>: this implementation uses the\n+     * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\">\n+     * Inversion Method</a> to generate exponentially distributed random values\n+     * from uniform deviates.</p>\n+     *\n+     * @return a random value.\n+     * @since 2.2\n+     */\n+    @Override\n+    public double sample() {\n+        return randomData.nextExponential(mean);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: exponential is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        if (p < 0.5) {\n+            // use mean\n+            return mean;\n+        } else {\n+            // use max\n+            return Double.MAX_VALUE;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // TODO: try to improve on this estimate\n+        // TODO: what should really happen here is not derive from\n+        // AbstractContinuousDistribution\n+        // TODO: because the inverse cumulative distribution is simple.\n+        // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n+        if (p < 0.5) {\n+            // use 1/2 mean\n+            return mean * 0.5;\n+        } else {\n+            // use mean\n+            return mean;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the mean parameter.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the mean parameter.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code k}, the mean is {@code k}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code k}, the variance is {@code k^2}.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double m = getMean();\n+        return m * m;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * F-Distribution.\n+ * Implementation of the F-distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n- * F-Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/F-distribution\">F-distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">F-distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface FDistribution extends ContinuousDistribution {\n+public class FDistribution\n+    extends AbstractContinuousDistribution\n+    implements Serializable  {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -8516354193418641566L;\n+    /** The numerator degrees of freedom. */\n+    private final double numeratorDegreesOfFreedom;\n+    /** The numerator degrees of freedom. */\n+    private final double denominatorDegreesOfFreedom;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a F distribution using the given degrees of freedom.\n+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n+     * @throws NotStrictlyPositiveException if\n+     * {@code numeratorDegreesOfFreedom <= 0} or\n+     * {@code denominatorDegreesOfFreedom <= 0}.\n+     */\n+    public FDistribution(double numeratorDegreesOfFreedom,\n+                             double denominatorDegreesOfFreedom)\n+        throws NotStrictlyPositiveException {\n+        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n+             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create an F distribution using the given degrees of freedom\n+     * and inverse cumulative probability accuracy.\n+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates.\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     * @throws NotStrictlyPositiveException if\n+     * {@code numeratorDegreesOfFreedom <= 0} or\n+     * {@code denominatorDegreesOfFreedom <= 0}.\n+     * @since 2.1\n+     */\n+    public FDistribution(double numeratorDegreesOfFreedom,\n+                             double denominatorDegreesOfFreedom,\n+                             double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        if (numeratorDegreesOfFreedom <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n+                                                   numeratorDegreesOfFreedom);\n+        }\n+        if (denominatorDegreesOfFreedom <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n+                                                   denominatorDegreesOfFreedom);\n+        }\n+        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\n+        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @since 2.1\n+     */\n+    public double density(double x) {\n+        final double nhalf = numeratorDegreesOfFreedom / 2;\n+        final double mhalf = denominatorDegreesOfFreedom / 2;\n+        final double logx = FastMath.log(x);\n+        final double logn = FastMath.log(numeratorDegreesOfFreedom);\n+        final double logm = FastMath.log(denominatorDegreesOfFreedom);\n+        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +\n+                                           denominatorDegreesOfFreedom);\n+        return FastMath.exp(nhalf * logn + nhalf * logx - logx +\n+                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -\n+                            Beta.logBeta(nhalf, mhalf));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The implementation of this method is based on\n+     * <ul>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+     *   F-Distribution</a>, equation (4).\n+     *  </li>\n+     * </ul>\n+     */\n+    public double cumulativeProbability(double x)  {\n+        double ret;\n+        if (x <= 0) {\n+            ret = 0;\n+        } else {\n+            double n = numeratorDegreesOfFreedom;\n+            double m = denominatorDegreesOfFreedom;\n+\n+            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n+                0.5 * n,\n+                0.5 * m);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p == 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p == 0) {\n+            return 0;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        double ret = 1;\n+        double d = denominatorDegreesOfFreedom;\n+        if (d > 2) {\n+            // use mean\n+            ret = d / (d - 2);\n+        }\n+        return ret;\n+    }\n+\n     /**\n      * Access the numerator degrees of freedom.\n      *\n      * @return the numerator degrees of freedom.\n      */\n-    double getNumeratorDegreesOfFreedom();\n+    public double getNumeratorDegreesOfFreedom() {\n+        return numeratorDegreesOfFreedom;\n+    }\n \n     /**\n      * Access the denominator degrees of freedom.\n      *\n      * @return the denominator degrees of freedom.\n      */\n-    double getDenominatorDegreesOfFreedom();\n+    public double getDenominatorDegreesOfFreedom() {\n+        return denominatorDegreesOfFreedom;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For denominator degrees of freedom parameter {@code b}, the mean is\n+     * <ul>\n+     *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>\n+     *  <li>else undefined ({@code Double.NaN}).\n+     * </ul>\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double denominatorDF = getDenominatorDegreesOfFreedom();\n+\n+        if (denominatorDF > 2) {\n+            return denominatorDF / (denominatorDF - 2);\n+        }\n+\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For numerator degrees of freedom parameter {@code a} and denominator\n+     * degrees of freedom parameter {@code b}, the variance is\n+     * <ul>\n+     *  <li>\n+     *    if {@code b > 4} then\n+     *    {@code [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)]},\n+     *  </li>\n+     *  <li>else undefined ({@code Double.NaN}).\n+     * </ul>\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double denominatorDF = getDenominatorDegreesOfFreedom();\n+\n+        if (denominatorDF > 4) {\n+            final double numeratorDF = getNumeratorDegreesOfFreedom();\n+            final double denomDFMinusTwo = denominatorDF - 2;\n+\n+            return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /\n+                   ( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n+        }\n+\n+        return Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * The Gamma Distribution.\n+ * Implementation of the Gamma distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/GammaDistribution.html\">\n- * Gamma Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Gamma_distribution\">Gamma distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/GammaDistribution.html\">Gamma distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface GammaDistribution extends ContinuousDistribution {\n-    /**\n-     * Access the alpha shape parameter.\n-     *\n-     * @return alpha.\n-     */\n-    double getAlpha();\n-\n-    /**\n-     * Access the beta scale parameter.\n-     *\n-     * @return beta.\n-     */\n-    double getBeta();\n+public class GammaDistribution extends AbstractContinuousDistribution\n+    implements Serializable  {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3239549463135430361L;\n+    /** The shape parameter. */\n+    private final double alpha;\n+    /** The scale parameter. */\n+    private final double beta;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a new gamma distribution with the given {@code alpha} and\n+     * {@code beta} values.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     */\n+    public GammaDistribution(double alpha, double beta) {\n+        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a new gamma distribution with the given {@code alpha} and\n+     * {@code beta} values.\n+     *\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n+     * {@code beta <= 0}.\n+     * @since 2.1\n+     */\n+    public GammaDistribution(double alpha, double beta, double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        if (alpha <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.ALPHA, alpha);\n+        }\n+        if (beta <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.BETA, beta);\n+        }\n+\n+        this.alpha = alpha;\n+        this.beta = beta;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The implementation of this method is based on:\n+     * <ul>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n+     *    Chi-Squared Distribution</a>, equation (9).\n+     *  </li>\n+     *  <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.\n+     *    Belmont, CA: Duxbury Press.\n+     *  </li>\n+     * </ul>\n+     */\n+    public double cumulativeProbability(double x) {\n+        double ret;\n+\n+        if (x <= 0) {\n+            ret = 0;\n+        } else {\n+            ret = Gamma.regularizedGammaP(alpha, x / beta);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p == 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n+        if (p == 0) {\n+            return 0;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /**\n+     * Access the {@code alpha} shape parameter.\n+     *\n+     * @return {@code alpha}.\n+     */\n+    public double getAlpha() {\n+        return alpha;\n+    }\n+\n+    /**\n+     * Access the {@code beta} scale parameter.\n+     *\n+     * @return {@code beta}.\n+     */\n+    public double getBeta() {\n+        return beta;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return FastMath.pow(x / beta, alpha - 1) / beta *\n+               FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        // TODO: try to improve on this estimate\n+        return Double.MIN_VALUE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // TODO: try to improve on this estimate\n+        // NOTE: gamma is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < 0.5) {\n+            // use mean\n+            ret = alpha * beta;\n+        } else {\n+            // use max value\n+            ret = Double.MAX_VALUE;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // TODO: try to improve on this estimate\n+        // Gamma is skewed to the left, therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < 0.5) {\n+            // use 1/2 mean\n+            ret = alpha * beta * 0.5;\n+        } else {\n+            // use mean\n+            ret = alpha * beta;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For shape parameter {@code alpha} and scale parameter {@code beta}, the\n+     * mean is {@code alpha * beta}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getAlpha() * getBeta();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For shape parameter {@code alpha} and scale parameter {@code beta}, the\n+     * variance is {@code alpha * beta^2}.\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double b = getBeta();\n+        return getAlpha() * b * b;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.CauchyDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ContinuousDistribution;\n-import org.apache.commons.math.distribution.FDistributionImpl;\n+import org.apache.commons.math.distribution.FDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n import org.apache.commons.math.distribution.IntegerDistribution;\n import org.apache.commons.math.distribution.PascalDistributionImpl;\n     }\n \n     /**\n-     * Generates a random value from the {@link FDistributionImpl F Distribution}.\n+     * Generates a random value from the {@link FDistribution F Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public double nextF(double numeratorDf, double denominatorDf) {\n-        return nextInversionDeviate(new FDistributionImpl(numeratorDf, denominatorDf));\n+        return nextInversionDeviate(new FDistribution(numeratorDf, denominatorDf));\n     }\n \n     /**\n      * <p>Generates a random value from the\n-     * {@link org.apache.commons.math.distribution.GammaDistributionImpl Gamma Distribution}.</p>\n+     * {@link org.apache.commons.math.distribution.GammaDistribution Gamma Distribution}.</p>\n      *\n      * <p>This implementation uses the following algorithms: </p>\n      *\n--- a/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.distribution.FDistribution;\n-import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n     public double anovaPValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n         AnovaStats a = anovaStats(categoryData);\n-        FDistribution fdist = new FDistributionImpl(a.dfbg, a.dfwg);\n+        FDistribution fdist = new FDistribution(a.dfbg, a.dfwg);\n         return 1.0 - fdist.cumulativeProbability(a.F);\n     }\n \n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ExponentialDistribution makeDistribution() {\n-        return new ExponentialDistributionImpl(5.0);\n+        return new ExponentialDistribution(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n \n     @Test\n     public void testDensity() {\n-        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);\n+        ExponentialDistribution d1 = new ExponentialDistribution(1);\n         Assert.assertTrue(Precision.equals(0.0, d1.density(-1e-9), 1));\n         Assert.assertTrue(Precision.equals(1.0, d1.density(0.0), 1));\n         Assert.assertTrue(Precision.equals(0.0, d1.density(1000.0), 1));\n         Assert.assertTrue(Precision.equals(FastMath.exp(-1), d1.density(1.0), 1));\n         Assert.assertTrue(Precision.equals(FastMath.exp(-2), d1.density(2.0), 1));\n \n-        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n+        ExponentialDistribution d2 = new ExponentialDistribution(3);\n         Assert.assertTrue(Precision.equals(1/3.0, d2.density(0.0), 1));\n         // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5\n         Assert.assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n \n     @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions() {\n-        new ExponentialDistributionImpl(0);\n+        new ExponentialDistribution(0);\n     }\n \n     @Test\n     public void testMoments() {\n         final double tol = 1e-9;\n         ExponentialDistribution dist;\n-        \n-        dist = new ExponentialDistributionImpl(11d);\n+\n+        dist = new ExponentialDistribution(11d);\n         Assert.assertEquals(dist.getNumericalMean(), 11d, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 11d * 11d, tol);\n-        \n-        dist = new ExponentialDistributionImpl(10.5d);\n+\n+        dist = new ExponentialDistribution(10.5d);\n         Assert.assertEquals(dist.getNumericalMean(), 10.5d, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public FDistribution makeDistribution() {\n-        return new FDistributionImpl(5.0, 6.0);\n+        return new FDistribution(5.0, 6.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Test\n     public void testPreconditions() {\n         try {\n-            new FDistributionImpl(0, 1);\n+            new FDistribution(0, 1);\n             Assert.fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n-            new FDistributionImpl(1, 0);\n+            new FDistribution(1, 0);\n             Assert.fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n \n     @Test\n     public void testLargeDegreesOfFreedom() throws Exception {\n-        FDistributionImpl fd = new FDistributionImpl(100000, 100000);\n+        FDistribution fd = new FDistribution(100000, 100000);\n         double p = fd.cumulativeProbability(.999);\n         double x = fd.inverseCumulativeProbability(p);\n         Assert.assertEquals(.999, x, 1.0e-5);\n \n     @Test\n     public void testSmallDegreesOfFreedom() throws Exception {\n-        FDistributionImpl fd = new FDistributionImpl(1, 1);\n+        FDistribution fd = new FDistribution(1, 1);\n         double p = fd.cumulativeProbability(0.975);\n         double x = fd.inverseCumulativeProbability(p);\n         Assert.assertEquals(0.975, x, 1.0e-5);\n \n-        fd = new FDistributionImpl(1, 2);\n+        fd = new FDistribution(1, 2);\n         p = fd.cumulativeProbability(0.975);\n         x = fd.inverseCumulativeProbability(p);\n         Assert.assertEquals(0.975, x, 1.0e-5);\n     public void testMoments() {\n         final double tol = 1e-9;\n         FDistribution dist;\n-        \n-        dist = new FDistributionImpl(1, 2);\n+\n+        dist = new FDistribution(1, 2);\n         Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n         Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n-        \n-        dist = new FDistributionImpl(1, 3);\n+\n+        dist = new FDistribution(1, 3);\n         Assert.assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol);\n         Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n-        \n-        dist = new FDistributionImpl(1, 5);\n+\n+        dist = new FDistribution(1, 5);\n         Assert.assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);        \n+        Assert.assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public GammaDistribution makeDistribution() {\n-        return new GammaDistributionImpl(4d, 2d);\n+        return new GammaDistribution(4d, 2d);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Test\n     public void testPreconditions() {\n         try {\n-            new GammaDistributionImpl(0, 1);\n+            new GammaDistribution(0, 1);\n             Assert.fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n-            new GammaDistributionImpl(1, 0);\n+            new GammaDistribution(1, 0);\n             Assert.fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n     }\n \n     private void testProbability(double x, double a, double b, double expected) throws Exception {\n-        GammaDistribution distribution = new GammaDistributionImpl( a, b );\n+        GammaDistribution distribution = new GammaDistribution( a, b );\n         double actual = distribution.cumulativeProbability(x);\n         Assert.assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n     }\n \n     private void testValue(double expected, double a, double b, double p) throws Exception {\n-        GammaDistribution distribution = new GammaDistributionImpl( a, b );\n+        GammaDistribution distribution = new GammaDistribution( a, b );\n         double actual = distribution.inverseCumulativeProbability(p);\n         Assert.assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n     }\n     }\n \n     private void checkDensity(double alpha, double rate, double[] x, double[] expected) {\n-        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);\n+        GammaDistribution d = new GammaDistribution(alpha, 1 / rate);\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);\n         }\n     public void testMoments() {\n         final double tol = 1e-9;\n         GammaDistribution dist;\n-        \n-        dist = new GammaDistributionImpl(1, 2);\n+\n+        dist = new GammaDistribution(1, 2);\n         Assert.assertEquals(dist.getNumericalMean(), 2, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 4, tol); \n-        \n-        dist = new GammaDistributionImpl(1.1, 4.2);\n+        Assert.assertEquals(dist.getNumericalVariance(), 4, tol);\n+\n+        dist = new GammaDistribution(1.1, 4.2);\n         Assert.assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.BinomialDistributionTest;\n import org.apache.commons.math.distribution.CauchyDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n-import org.apache.commons.math.distribution.ExponentialDistributionImpl;\n-import org.apache.commons.math.distribution.FDistributionImpl;\n-import org.apache.commons.math.distribution.GammaDistributionImpl;\n+import org.apache.commons.math.distribution.ExponentialDistribution;\n+import org.apache.commons.math.distribution.FDistribution;\n+import org.apache.commons.math.distribution.GammaDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n import org.apache.commons.math.distribution.HypergeometricDistributionTest;\n import org.apache.commons.math.distribution.PascalDistributionImpl;\n         long[] counts;\n \n         // Mean 1\n-        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistributionImpl(1));\n+        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistribution(1));\n         counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n \n         // Mean 5\n-        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistributionImpl(5));\n+        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistribution(5));\n         counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n \n     @Test\n     public void testNextF() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new FDistributionImpl(12, 5));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new FDistribution(12, 5));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n         long[] counts;\n         \n         // Tests shape > 1, one case in the rejection sampling\n-        quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n+        quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(4, 2));\n         counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n         \n         // Tests shape <= 1, another case in the rejection sampling        \n-        quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(0.3, 3));\n+        quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(0.3, 3));\n         counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {", "timestamp": 1322288269, "metainfo": ""}