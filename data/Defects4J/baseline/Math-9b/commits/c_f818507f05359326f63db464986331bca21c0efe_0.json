{"sha": "f818507f05359326f63db464986331bca21c0efe", "log": "Added fix for MATH-585: Implemented faster generation of random gamma variates using Ahrens and Dieter (1974) and Marsaglia and Tsang (2001). Test case was improved, too.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n import org.apache.commons.math.distribution.ContinuousDistribution;\n import org.apache.commons.math.distribution.FDistributionImpl;\n-import org.apache.commons.math.distribution.GammaDistributionImpl;\n import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n import org.apache.commons.math.distribution.IntegerDistribution;\n import org.apache.commons.math.distribution.PascalDistributionImpl;\n \n     /**\n      * Generates a random value from the {@link GammaDistributionImpl Gamma Distribution}.\n-     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n-     * to generate random values.\n+     *\n+     * This implementation uses the following algorithms:\n+     *\n+     * For 0 < shape < 1:\n+     * [1]: Ahrens, J. H. and Dieter, U. (1974). Computer methods for\n+     * sampling from gamma, beta, Poisson and binomial distributions.\n+     * Computing, 12, 223-246.\n+     *\n+     * For shape >= 1:\n+     * [2]: Marsaglia and Tsang (2001). A Simple Method for Generating\n+     * Gamma Variables. ACM Transactions on Mathematical Software, 26,\n      *\n      * @param shape the median of the Gamma distribution\n      * @param scale the scale parameter of the Gamma distribution\n      * @since 2.2\n      */\n     public double nextGamma(double shape, double scale) throws MathException {\n-        return nextInversionDeviate(new GammaDistributionImpl(shape, scale));\n+        if (shape < 1) {\n+            /*\n+            final double gamma = this.nextOldGamma(1 + shape, scale);\n+            final double u = this.nextUniform(0, 1);\n+            return gamma * FastMath.pow(u, 1/shape);\n+            */\n+\n+            // [1]: p. 228, Algorithm GS\n+\n+            while (true) {\n+                // Step 1:\n+                final double u = this.nextUniform(0, 1);\n+                final double bGS = 1 + shape/FastMath.E;\n+                final double p = bGS*u;\n+\n+                if (p <= 1) {\n+                    // Step 2:\n+\n+                    final double x = FastMath.pow(p, 1/shape);\n+                    final double u2 = this.nextUniform(0.0, 1);\n+\n+                    if (u2 > FastMath.exp(-x)) {\n+                        // Reject\n+                        continue;\n+                    } else {\n+                        return scale*x;\n+                    }\n+                } else {\n+                    // Step 3:\n+\n+                    final double x = -1 * FastMath.log((bGS-p)/shape);\n+                    final double u2 = this.nextUniform(0, 1);\n+\n+                    if (u2 > FastMath.pow(x, shape - 1)) {\n+                        // Reject\n+                        continue;\n+                    } else {\n+                        return scale*x;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Now shape >= 1\n+\n+        final RandomGenerator generator = this.getRan();\n+        final double d = shape - 0.333333333333333333;\n+        final double c = 1.0 / (3*FastMath.sqrt(d));\n+\n+        while (true) {\n+            final double x = generator.nextGaussian();\n+            final double v = (1+c*x)*(1+c*x)*(1+c*x);\n+\n+            if (v <= 0) {\n+                continue;\n+            }\n+\n+            final double xx = x*x;\n+            final double u = this.nextUniform(0, 1);\n+\n+            // Squeeze\n+            if (u < 1 - 0.0331*xx*xx) {\n+                return scale*d*v;\n+            }\n+\n+            if (FastMath.log(u) < 0.5*xx + d*(1 - v + FastMath.log(v))) {\n+                return scale*d*v;\n+            }\n+        }\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n \n     @Test\n     public void testNextGamma() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n-        long[] counts = new long[4];\n+        double[] quartiles;\n+        long[] counts;\n+        \n+        // Tests shape > 1, one case in the rejection sampling\n+        quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n+        counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextGamma(4, 2);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+        \n+        // Tests shape <= 1, another case in the rejection sampling        \n+        quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(0.3, 3));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextGamma(0.3, 3);\n             TestUtils.updateCounts(value, counts, quartiles);\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);", "timestamp": 1311280655, "metainfo": ""}