{"sha": "6d0cca3e56cd82d68ede4919d6ca35068ce6fc89", "log": "fixed checkstyle and findbugs warnings  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n import java.util.SortedSet;\n import java.util.TreeSet;\n     private Collection<EventState> eventsStates;\n \n     /** Initialization indicator of events states. */\n-    protected boolean statesInitialized;\n+    private boolean statesInitialized;\n \n     /** Name of the method. */\n     private final String name;\n         equations.computeDerivatives(t, y, yDot);\n     }\n \n+    /** Set the stateInitialized flag.\n+     * <p>This method must be called by integrators with the value\n+     * {@code false} before they start integration, so a proper lazy\n+     * initialization is done automatically on the first step.</p>\n+     * @param stateInitialized new value for the flag\n+     */\n+    protected void setStateInitialized(final boolean stateInitialized) {\n+        this.statesInitialized = stateInitialized;\n+    }\n+\n     /** Accept a step, triggering events and step handlers.\n      * @param interpolator step interpolator\n      * @param y state vector at step end time, must be reset if an event\n                 statesInitialized = true;\n             }\n \n+            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n+\n+                /** {@inheritDoc} */\n+                public int compare(EventState es0, EventState es1) {\n+                    return Double.compare(es0.getEventTime(), es1.getEventTime());\n+                }\n+\n+            });\n+\n             // find all events that occur during the step\n-            SortedSet<EventState> occuringEvents = new TreeSet<EventState>();\n             for (final EventState state : eventsStates) {\n                 if (state.evaluateStep(interpolator)) {\n                     // the event occurs during the current step\n \n                 // restrict the interpolator to the first part of the step, up to the event\n                 final double eventT = state.getEventTime();\n-                interpolator.setSoftBounds(previousT, eventT);\n+                interpolator.setSoftPreviousTime(previousT);\n+                interpolator.setSoftCurrentTime(eventT);\n \n                 // trigger the event\n                 interpolator.setInterpolatedTime(eventT);\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n-                interpolator.setSoftBounds(eventT, currentT);\n+                interpolator.setSoftPreviousTime(eventT);\n+                interpolator.setSoftCurrentTime(currentT);\n \n             }\n \n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public class EventState implements Comparable<EventState> {\n+public class EventState {\n \n     /** Event handler. */\n     private final EventHandler handler;\n \n     }\n \n-    /** Get the occurrence time of the event triggered in the current\n-     * step.\n+    /** Get the occurrence time of the event triggered in the current step.\n      * @return occurrence time of the event triggered in the current\n-     * step.\n+     * step or positive infinity if no events are triggered\n      */\n     public double getEventTime() {\n-        return pendingEventTime;\n+        return pendingEvent ? pendingEventTime : Double.POSITIVE_INFINITY;\n     }\n \n     /** Acknowledge the fact the step has been accepted by the integrator.\n \n     }\n \n-    /** Compare the instance with another event state.\n-     * <p>\n-     * Event state ordering is based on occurrence time within the last\n-     * evaluated step. If no event occurs during the step, a time arbitrarily\n-     * set to positive infinity is used.\n-     * </p>\n-     * @param state other event state to compare the instance to\n-     * @return a negative integer, zero, or a positive integer as the event\n-     * occurs before, simultaneous, or after the specified event of the\n-     * specified state.\n-     */\n-    public int compareTo(final EventState state) {\n-        final double instanceTime = pendingEvent ? pendingEventTime : Double.POSITIVE_INFINITY;\n-        final double otherTime = state.pendingEvent ? state.pendingEventTime : Double.POSITIVE_INFINITY;\n-        return Double.compare(instanceTime, otherTime);\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n         for (StepHandler handler : stepHandlers) {\n             handler.reset();\n         }\n-        statesInitialized = false;\n+        setStateInitialized(false);\n \n         // compute the initial Nordsieck vector using the configured starter integrator\n         start(t0, y, t);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n         for (StepHandler handler : stepHandlers) {\n             handler.reset();\n         }\n-        statesInitialized = false;\n+        setStateInitialized(false);\n \n         // compute the initial Nordsieck vector using the configured starter integrator\n         start(t0, y, t);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n-    statesInitialized = false;\n+    setStateInitialized(false);\n \n     // main integration loop\n     isLastStep = false;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n-    statesInitialized = false;\n+    setStateInitialized(false);\n     costPerTimeUnit[0] = 0;\n     isLastStep = false;\n     do {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n-    statesInitialized = false;\n+    setStateInitialized(false);\n \n     // main integration loop\n     isLastStep = false;\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n public abstract class AbstractStepInterpolator\n   implements StepInterpolator {\n \n+  /** current time step */\n+  protected double h;\n+\n+  /** current state */\n+  protected double[] currentState;\n+\n+  /** interpolated time */\n+  protected double interpolatedTime;\n+\n+  /** interpolated state */\n+  protected double[] interpolatedState;\n+\n+  /** interpolated derivatives */\n+  protected double[] interpolatedDerivatives;\n+\n   /** global previous time */\n   private double globalPreviousTime;\n \n \n   /** soft current time */\n   private double softCurrentTime;\n-\n-  /** current time step */\n-  protected double h;\n-\n-  /** current state */\n-  protected double[] currentState;\n-\n-  /** interpolated time */\n-  protected double interpolatedTime;\n-\n-  /** interpolated state */\n-  protected double[] interpolatedState;\n-\n-  /** interpolated derivatives */\n-  protected double[] interpolatedDerivatives;\n \n   /** indicate if the step has been finalized or not. */\n   private boolean finalized;\n    * <p>\n    * This method can be used to restrict a step and make it appear\n    * as if the original step was smaller. Calling this method\n-   * <em>only</em> changes the value returned by {@link #getPreviousTime()}\n-   * and {@link #getCurrentTime()}, it does not change any\n+   * <em>only</em> changes the value returned by {@link #getPreviousTime()},\n+   * it does not change any other property\n    * </p>\n    * @param softPreviousTime start of the restricted step\n+   * @since 2.2\n+   */\n+  public void setSoftPreviousTime(final double softPreviousTime) {\n+      this.softPreviousTime = softPreviousTime;\n+  }\n+\n+  /** Restrict step range to a limited part of the global step.\n+   * <p>\n+   * This method can be used to restrict a step and make it appear\n+   * as if the original step was smaller. Calling this method\n+   * <em>only</em> changes the value returned by {@link #getCurrentTime()},\n+   * it does not change any other property\n+   * </p>\n    * @param softCurrentTime end of the restricted step\n-   */\n-  public void setSoftBounds(final double softPreviousTime, final double softCurrentTime) {\n-      this.softPreviousTime = softPreviousTime;\n+   * @since 2.2\n+   */\n+  public void setSoftCurrentTime(final double softCurrentTime) {\n       this.softCurrentTime  = softCurrentTime;\n   }\n \n   /**\n    * Get the previous soft grid point time.\n    * @return previous soft grid point time\n-   * @see #setSoftBounds(double, double)\n+   * @see #setSoftPreviousTime(double)\n    */\n   public double getPreviousTime() {\n     return softPreviousTime;\n   /**\n    * Get the current soft grid point time.\n    * @return current soft grid point time\n-   * @see #setSoftBounds(double, double)\n+   * @see #setSoftCurrentTime(double)\n    */\n   public double getCurrentTime() {\n     return softCurrentTime;\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n             double xb = ab;\n \n             /* Need a more accurate epsilon, so adjust the division. */\n-            double numer = (bits & 0x3ffffffffffL);\n+            double numer = bits & 0x3ffffffffffL;\n             double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n             aa = numer - xa*denom - xb * denom;\n             xb += aa / denom;", "timestamp": 1297372073, "metainfo": ""}