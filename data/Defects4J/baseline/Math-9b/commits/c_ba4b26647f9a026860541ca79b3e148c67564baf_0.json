{"sha": "ba4b26647f9a026860541ca79b3e148c67564baf", "log": "MATH-621 Function \"update\": All local variables defined at initialization.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n         // upper bound on the indices of the conjugate gradient iterations.\n \n         int state = 20;\n-        for(;;) switch (state) {\n-\n+        for(;;) {\n+            // System.out.println(\"loop in trsbox: state=\" + state); // XXX\n+            switch (state) {\n         case 20: {\n             beta = ZERO;\n         }\n         default: {\n             throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n         }}\n+        }\n     } // trsbox\n \n     // ----------------------------------------------------------------------------------------\n         // XXX Should probably be split into two arrays.\n         final ArrayRealVector work = new ArrayRealVector(npt + n);\n \n-\n-        // System generated locals\n-        double d__1, d__2, d__3;\n-\n-        // Local variables\n-        int jp;\n-        double tau, temp;\n-        double alpha, tempa, tempb, ztest;\n-\n-        // Function Body\n-\n-        ztest = ZERO;\n+        double ztest = ZERO;\n         for (int k = 0; k < npt; k++) {\n             for (int j = 0; j < nptm; j++) {\n                 // Computing MAX\n         // Apply the rotations that put zeros in the KNEW-th row of ZMAT.\n \n         for (int j = 1; j < nptm; j++) {\n-            d__1 = zmat.getEntry(knew, j);\n-            if (Math.abs(d__1) > ztest) {\n+            final double d1 = zmat.getEntry(knew, j);\n+            if (Math.abs(d1) > ztest) {\n                 // Computing 2nd power\n-                d__1 = zmat.getEntry(knew, 0);\n+                final double d2 = zmat.getEntry(knew, 0);\n                 // Computing 2nd power\n-                d__2 = zmat.getEntry(knew, j);\n-                temp = Math.sqrt(d__1 * d__1 + d__2 * d__2);\n-                tempa = zmat.getEntry(knew, 0) / temp;\n-                tempb = zmat.getEntry(knew, j) / temp;\n+                final double d3 = zmat.getEntry(knew, j);\n+                final double d4 = Math.sqrt(d2 * d2 + d3 * d3);\n+                final double d5 = zmat.getEntry(knew, 0) / d4;\n+                final double d6 = zmat.getEntry(knew, j) / d4;\n                 for (int i = 0; i < npt; i++) {\n-                    temp = tempa * zmat.getEntry(i, 0) + tempb * zmat.getEntry(i, j);\n-                    zmat.setEntry(i, j, tempa * zmat.getEntry(i, j) -\n-                                  tempb * zmat.getEntry(i, 0));\n-                    zmat.setEntry(i, 0, temp);\n+                    final double d7 = d5 * zmat.getEntry(i, 0) + d6 * zmat.getEntry(i, j);\n+                    zmat.setEntry(i, j, d5 * zmat.getEntry(i, j) - d6 * zmat.getEntry(i, 0));\n+                    zmat.setEntry(i, 0, d7);\n                 }\n             }\n             zmat.setEntry(knew, j, ZERO);\n         for (int i = 0; i < npt; i++) {\n             work.setEntry(i, zmat.getEntry(knew, 0) * zmat.getEntry(i, 0));\n         }\n-        alpha = work.getEntry(knew);\n-        tau = vlag.getEntry(knew);\n+        final double alpha = work.getEntry(knew);\n+        final double tau = vlag.getEntry(knew);\n         vlag.setEntry(knew, vlag.getEntry(knew) - ONE);\n \n         // Complete the updating of ZMAT.\n \n-        temp = Math.sqrt(denom);\n-        tempb = zmat.getEntry(knew, 0) / temp;\n-        tempa = tau / temp;\n+        final double sqrtDenom = Math.sqrt(denom);\n+        final double d1 = tau / sqrtDenom;\n+        final double d2 = zmat.getEntry(knew, 0) / sqrtDenom;\n         for (int i = 0; i < npt; i++) {\n             zmat.setEntry(i, 0,\n-                          tempa * zmat.getEntry(i, 0) - tempb * vlag.getEntry(i));\n+                          d1 * zmat.getEntry(i, 0) - d2 * vlag.getEntry(i));\n         }\n \n         // Finally, update the matrix BMAT.\n \n         for (int j = 0; j < n; j++) {\n-            jp = npt + j;\n+            final int jp = npt + j;\n             work.setEntry(jp, bmat.getEntry(knew, j));\n-            tempa = (alpha * vlag.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n-            tempb = (-beta * work.getEntry(jp) - tau * vlag.getEntry(jp)) / denom;\n+            final double d3 = (alpha * vlag.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n+            final double d4 = (-beta * work.getEntry(jp) - tau * vlag.getEntry(jp)) / denom;\n             for (int i = 0; i <= jp; i++) {\n-                bmat.setEntry(i, j, bmat.getEntry(i, j) + tempa *\n-                        vlag.getEntry(i) + tempb * work.getEntry(i));\n+                bmat.setEntry(i, j,\n+                              bmat.getEntry(i, j) + d3 * vlag.getEntry(i) + d4 * work.getEntry(i));\n                 if (i >= npt) {\n                     bmat.setEntry(jp, (i - npt), bmat.getEntry(i, j));\n                 }", "timestamp": 1313531749, "metainfo": ""}