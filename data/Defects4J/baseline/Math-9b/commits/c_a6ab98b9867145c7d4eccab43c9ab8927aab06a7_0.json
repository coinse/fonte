{"sha": "a6ab98b9867145c7d4eccab43c9ab8927aab06a7", "log": "Added a nextAfter method in MathUtils to return the next machine-representable number in a specified direction from a given floating point number.  Used this to ensure that MathUtils.round does not return incorrect results for numbers with bad IEEE754  representations. JIRA: MATH-151 Reported by Buza Zolt\u00e1n Patch submitted by Luc Maisonobe   ", "commit": "\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     /**\n+     * Get the closest machine representable number\n+     * from a number in some direction.\n+\n+     * @param d base number\n+     * @param direction (the only important thing is whether\n+     * direction is greater or smaller than d)\n+     * @return\n+     */\n+    public static double nextAfter(double d, double direction) {\n+\n+        // handling of some important special cases\n+        if (Double.isNaN(d) || Double.isInfinite(d)) {\n+                return d;\n+        } else if (d == 0) {\n+                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n+        }\n+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n+        // are handled just as normal numbers\n+\n+        // split the double in raw components\n+        long bits     = Double.doubleToLongBits(d);\n+        long sign     = bits & 0x8000000000000000L;\n+        long exponent = bits & 0x7ff0000000000000L;\n+        long mantissa = bits & 0x000fffffffffffffL;\n+\n+        if (d * (direction - d) >= 0) {\n+                // we should increase the mantissa\n+                if (mantissa == 0x000fffffffffffffL) {\n+                        return Double.longBitsToDouble(sign |\n+                                        (exponent + 0x0010000000000000L));\n+                } else {\n+                        return Double.longBitsToDouble(sign |\n+                                        exponent | (mantissa + 1));\n+                }\n+        } else {\n+                // we should decrease the mantissa\n+                if (mantissa == 0L) {\n+                        return Double.longBitsToDouble(sign |\n+                                        (exponent - 0x0010000000000000L) |\n+                                        0x000fffffffffffffL);\n+                } else {\n+                        return Double.longBitsToDouble(sign |\n+                                        exponent | (mantissa - 1));\n+                }\n+        }\n+\n+    }\n+\n+    /**\n      * Round the given value to the specified number of decimal places. The\n      * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n      * \n      * @since 1.1\n      */\n     public static double round(double x, int scale, int roundingMethod) {\n-        double sign = indicator(x);\n-        double factor = Math.pow(10.0, scale) * sign;\n-        return roundUnscaled(x * factor, sign, roundingMethod) / factor;\n+        try {\n+            return (new BigDecimal\n+                   (new Double(x).toString())\n+                   .setScale(scale, roundingMethod))\n+                   .doubleValue();\n+        } catch (NumberFormatException ex) {\n+            if (Double.isInfinite(x)) {\n+                return x;          \n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n     }\n \n     /**\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = Math.floor(unscaled);\n+                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = Math.ceil(unscaled);\n+                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = Math.floor(unscaled);\n+            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = Math.ceil(unscaled);\n+                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = Math.floor(unscaled);\n+                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n-            double fraction = Math.abs(unscaled - Math.floor(unscaled));\n+            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            double fraction = unscaled - Math.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = Math.ceil(unscaled);\n             } else {\n             break;\n         }\n         case BigDecimal.ROUND_HALF_EVEN : {\n-            double fraction = Math.abs(unscaled - Math.floor(unscaled));\n+            double fraction = unscaled - Math.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = Math.ceil(unscaled);\n             } else if (fraction < 0.5) {\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n-            double fraction = Math.abs(unscaled - Math.floor(unscaled));\n+            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            double fraction = unscaled - Math.floor(unscaled);\n             if (fraction >= 0.5) {\n                 unscaled = Math.ceil(unscaled);\n             } else {\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = Math.ceil(unscaled);\n+            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw new IllegalArgumentException(\"Invalid rounding method.\");\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n         assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n     }\n     \n+    public void testNextAfterSpecialCases() {\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));\n+        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter( Double.MAX_VALUE, Double.POSITIVE_INFINITY)));\n+        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));\n+        assertEquals( Double.MIN_VALUE, MathUtils.nextAfter(0,  1), 0);\n+        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);\n+        assertEquals(0, MathUtils.nextAfter( Double.MIN_VALUE, -1), 0);\n+        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE,  1), 0);\n+    }\n+    \n+    public void testNextAfter() {\n+        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000\n+        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n+\n+        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe\n+        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n+\n+        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe\n+        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n+\n+        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe\n+        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n+\n+        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001\n+        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);\n+\n+        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff\n+        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);\n+\n+        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff\n+        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);\n+\n+        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff\n+        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224\n+        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224\n+        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222\n+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224\n+        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224\n+        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222\n+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+\n+    }\n+\n     public void testRoundDouble() {\n         double x = 1.234567890;\n         assertEquals(1.23, MathUtils.round(x, 2), 0.0);\n         assertEquals(1.235, MathUtils.round(x, 3), 0.0);\n         assertEquals(1.2346, MathUtils.round(x, 4), 0.0);\n         \n+        // JIRA MATH-151\n+        assertEquals(39.25,MathUtils.round(39.245, 2), 0.0);\n+        assertEquals(39.24,MathUtils.round(39.245, 2, \n+                BigDecimal.ROUND_DOWN), 0.0);\n+        double xx = 39.0;\n+        xx = xx + 245d/1000d;\n+        assertEquals(39.25,MathUtils.round(xx, 2), 0.0);\n+        \n         // BZ 35904\n         assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);\n         assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);\n+        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);\n+        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);\n         assertEquals(50.09d,  MathUtils.round(50.085d, 2), 0.0d);\n         assertEquals(50.19d,  MathUtils.round(50.185d, 2), 0.0d);\n         assertEquals(50.01d,  MathUtils.round(50.005d, 2), 0.0d);\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n+        // MATH-151\n+        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+     \n         // special values\n         TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);\n         assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);", "timestamp": 1152000565, "metainfo": ""}