{"sha": "6d732dba587f9d92d1dbfe3f1dee6acaf806f104", "log": "removed direct references to RealMatrixImpl and use factory  ", "commit": "\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.LUSolver;\n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n \n /**\n  * Base class for implementing estimators.\n         try {\n             // compute the covariances matrix\n             RealMatrix inverse =\n-                new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(jTj, false))).getInverse();\n-            return ((RealMatrixImpl) inverse).getDataRef();\n+                new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj))).getInverse();\n+            return inverse.getData();\n         } catch (InvalidMatrixException ime) {\n             throw new EstimationException(\"unable to compute covariances: singular problem\",\n                                           null);\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.LUSolver;\n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.RealVectorImpl;\n \n         double[] grad             = new double[parameters.length];\n         RealVectorImpl bDecrement = new RealVectorImpl(parameters.length);\n         double[] bDecrementData   = bDecrement.getDataRef();\n-        RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);\n-        double[][] wggData        = wGradGradT.getDataRef();\n+        RealMatrix wGradGradT     = MatrixUtils.createRealMatrix(parameters.length, parameters.length);\n \n         // iterate until convergence is reached\n         double previous = Double.POSITIVE_INFINITY;\n             // build the linear problem\n             incrementJacobianEvaluationsCounter();\n             RealVector b = new RealVectorImpl(parameters.length);\n-            RealMatrix a = new RealMatrixImpl(parameters.length, parameters.length);\n+            RealMatrix a = MatrixUtils.createRealMatrix(parameters.length, parameters.length);\n             for (int i = 0; i < measurements.length; ++i) {\n                 if (! measurements [i].isIgnored()) {\n \n \n                     // build the contribution matrix for measurement i\n                     for (int k = 0; k < parameters.length; ++k) {\n-                        double[] wggRow = wggData[k];\n                         double gk = grad[k];\n                         for (int l = 0; l < parameters.length; ++l) {\n-                            wggRow[l] =  weight * gk * grad[l];\n+                            wGradGradT.setEntry(k, l, weight * gk * grad[l]);\n                         }\n                     }\n \n--- a/src/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+++ b/src/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n             final int p = main.length;\n             final int diagOffset    = (m >= n) ? 0 : 1;\n             final double[] diagonal = (m >= n) ? main : secondary;\n-            final double[][] uData  = new double[m][m];\n+            cachedU = MatrixUtils.createRealMatrix(m, m);\n \n             // fill up the part of the matrix not affected by Householder transforms\n             for (int k = m - 1; k >= p; --k) {\n-                uData[k][k] = 1;\n+                cachedU.setEntry(k, k, 1);\n             }\n \n             // build up first part of the matrix by applying Householder transforms\n             for (int k = p - 1; k >= diagOffset; --k) {\n                 final double[] hK = householderVectors[k];\n-                uData[k][k] = 1;\n+                cachedU.setEntry(k, k, 1);\n                 if (hK[k - diagOffset] != 0.0) {\n                     for (int j = k; j < m; ++j) {\n                         double alpha = 0;\n                         for (int i = k; i < m; ++i) {\n-                            alpha -= uData[i][j] * householderVectors[i][k - diagOffset];\n+                            alpha -= cachedU.getEntry(i, j) * householderVectors[i][k - diagOffset];\n                         }\n                         alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];\n \n                         for (int i = k; i < m; ++i) {\n-                            uData[i][j] -= alpha * householderVectors[i][k - diagOffset];\n+                            cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);\n                         }\n                     }\n                 }\n             }\n             if (diagOffset > 0) {\n-                uData[0][0] = 1;\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedU = new RealMatrixImpl(uData, false);\n+                cachedU.setEntry(0, 0, 1);\n+            }\n \n         }\n \n \n             final int m = householderVectors.length;\n             final int n = householderVectors[0].length;\n-            double[][] bData = new double[m][n];\n+            cachedB = MatrixUtils.createRealMatrix(m, n);\n             for (int i = 0; i < main.length; ++i) {\n-                double[] bDataI = bData[i];\n-                bDataI[i] = main[i];\n+                cachedB.setEntry(i, i, main[i]);\n                 if (m < n) {\n                     if (i > 0) {\n-                        bDataI[i - 1] = secondary[i - 1];\n+                        cachedB.setEntry(i, i - 1, secondary[i - 1]);\n                     }\n                 } else {\n                     if (i < main.length - 1) {\n-                        bDataI[i + 1] = secondary[i];\n-                    }\n-                }\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedB = new RealMatrixImpl(bData, false);\n+                        cachedB.setEntry(i, i + 1, secondary[i]);\n+                    }\n+                }\n+            }\n \n         }\n \n             final int p = main.length;\n             final int diagOffset    = (m >= n) ? 1 : 0;\n             final double[] diagonal = (m >= n) ? secondary : main;\n-            final double[][] vData  = new double[n][n];\n+            cachedV = MatrixUtils.createRealMatrix(n, n);\n \n             // fill up the part of the matrix not affected by Householder transforms\n             for (int k = n - 1; k >= p; --k) {\n-                vData[k][k] = 1;\n+                cachedV.setEntry(k, k, 1);\n             }\n \n             // build up first part of the matrix by applying Householder transforms\n             for (int k = p - 1; k >= diagOffset; --k) {\n                 final double[] hK = householderVectors[k - diagOffset];\n-                vData[k][k] = 1;\n+                cachedV.setEntry(k, k, 1);\n                 if (hK[k] != 0.0) {\n                     for (int j = k; j < n; ++j) {\n                         double beta = 0;\n                         for (int i = k; i < n; ++i) {\n-                            beta -= vData[i][j] * hK[i];\n+                            beta -= cachedV.getEntry(i, j) * hK[i];\n                         }\n                         beta /= diagonal[k - diagOffset] * hK[k];\n \n                         for (int i = k; i < n; ++i) {\n-                            vData[i][j] -= beta * hK[i];\n+                            cachedV.addToEntry(i, j, -beta * hK[i]);\n                         }\n                     }\n                 }\n             }\n             if (diagOffset > 0) {\n-                vData[0][0] = 1;\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedV = new RealMatrixImpl(vData, false);\n+                cachedV.setEntry(0, 0, 1);\n+            }\n \n         }\n \n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n         throws InvalidMatrixException {\n \n         if (cachedV == null) {\n-            cachedV = getVT().transpose();\n+\n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n+\n+            final int m = eigenvectors.length;\n+            cachedV = MatrixUtils.createRealMatrix(m, m);\n+            for (int k = 0; k < m; ++k) {\n+                cachedV.setColumnVector(k, eigenvectors[k]);\n+            }\n+\n         }\n \n         // return the cached matrix\n     /** {@inheritDoc} */\n     public RealMatrix getD()\n         throws InvalidMatrixException {\n-\n         if (cachedD == null) {\n-\n-            final int m = eigenvalues.length;\n-            final double[][] sData = new double[m][m];\n-            for (int i = 0; i < m; ++i) {\n-                sData[i][i] = eigenvalues[i];\n-            }\n-\n             // cache the matrix for subsequent calls\n-            cachedD = new RealMatrixImpl(sData, false);\n-\n+            cachedD = MatrixUtils.createRealDiagonalMatrix(eigenvalues);\n         }\n         return cachedD;\n     }\n                 findEigenVectors();\n             }\n \n-            final double[][] vtData = new double[eigenvectors.length][];\n-            for (int k = 0; k < eigenvectors.length; ++k) {\n-                vtData[k] = eigenvectors[k].getData();\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedVt = new RealMatrixImpl(vtData, false);\n+            final int m = eigenvectors.length;\n+            cachedVt = MatrixUtils.createRealMatrix(m, m);\n+            for (int k = 0; k < m; ++k) {\n+                cachedVt.setRowVector(k, eigenvectors[k]);\n+            }\n \n         }\n \n--- a/src/java/org/apache/commons/math/linear/EigenSolver.java\n+++ b/src/java/org/apache/commons/math/linear/EigenSolver.java\n             }\n         }\n \n-        return new RealMatrixImpl(bp, false);\n+        return MatrixUtils.createRealMatrix(bp);\n \n     }\n \n                 invI[j] = invIJ;\n             }\n         }\n-        return new RealMatrixImpl(invData, false);\n+        return MatrixUtils.createRealMatrix(invData);\n \n     }\n \n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n         throws IllegalStateException {\n         if ((cachedL == null) && !singular) {\n             final int m = pivot.length;\n-            final double[][] lData = new double[m][m];\n+            cachedL = MatrixUtils.createRealMatrix(m, m);\n             for (int i = 0; i < m; ++i) {\n-                System.arraycopy(lu[i], 0, lData[i], 0, i);\n-                lData[i][i] = 1.0;\n-            }\n-            cachedL = new RealMatrixImpl(lData, false);\n+                final double[] luI = lu[i];\n+                for (int j = 0; j < i; ++j) {\n+                    cachedL.setEntry(i, j, luI[j]);\n+                }\n+                cachedL.setEntry(i, i, 1.0);\n+            }\n         }\n         return cachedL;\n     }\n         throws IllegalStateException {\n         if ((cachedU == null) && !singular) {\n             final int m = pivot.length;\n-            final double[][] uData = new double[m][m];\n+            cachedU = MatrixUtils.createRealMatrix(m, m);\n             for (int i = 0; i < m; ++i) {\n-                System.arraycopy(lu[i], i, uData[i], i, m - i);\n-            }\n-            cachedU = new RealMatrixImpl(uData, false);\n+                final double[] luI = lu[i];\n+                for (int j = i; j < m; ++j) {\n+                    cachedU.setEntry(i, j, luI[j]);\n+                }\n+            }\n         }\n         return cachedU;\n     }\n         throws IllegalStateException {\n         if ((cachedP == null) && !singular) {\n             final int m = pivot.length;\n-            final double[][] pData = new double[m][m];\n+            cachedP = MatrixUtils.createRealMatrix(m, m);\n             for (int i = 0; i < m; ++i) {\n-                pData[i][pivot[i]] = 1.0;\n-            }\n-            cachedP = new RealMatrixImpl(pData, false);\n+                cachedP.setEntry(i, pivot[i], 1.0);\n+            }\n         }\n         return cachedP;\n     }\n--- a/src/java/org/apache/commons/math/linear/LUSolver.java\n+++ b/src/java/org/apache/commons/math/linear/LUSolver.java\n             }\n         }\n \n-        return new RealMatrixImpl(bp, false);\n+        return MatrixUtils.createRealMatrix(bp);\n \n     }\n \n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n             // R is supposed to be m x n\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            double[][] r = new double[m][n];\n+            cachedR = MatrixUtils.createRealMatrix(m, n);\n \n             // copy the diagonal from rDiag and the upper triangle of qr\n             for (int row = Math.min(m, n) - 1; row >= 0; row--) {\n-                double[] rRow = r[row];\n-                rRow[row] = rDiag[row];\n+                cachedR.setEntry(row, row, rDiag[row]);\n                 for (int col = row + 1; col < n; col++) {\n-                    rRow[col] = qrt[col][row];\n-                }\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedR = new RealMatrixImpl(r, false);\n+                    cachedR.setEntry(row, col, qrt[col][row]);\n+                }\n+            }\n \n         }\n \n             // QT is supposed to be m x m\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            double[][] qT = new double[m][m];\n+            cachedQT = MatrixUtils.createRealMatrix(m, m);\n \n             /* \n              * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n              * succession to the result \n              */ \n             for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n-                qT[minor][minor]=1;\n-            }\n-\n-            for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n+                cachedQT.setEntry(minor, minor, 1.0);\n+            }\n+\n+            for (int minor = Math.min(m, n)-1; minor >= 0; minor--){\n                 final double[] qrtMinor = qrt[minor];\n-                qT[minor][minor] = 1;\n+                cachedQT.setEntry(minor, minor, 1.0);\n                 if (qrtMinor[minor] != 0.0) {\n                     for (int col = minor; col < m; col++) {\n-                        final double[] qTCol = qT[col];\n                         double alpha = 0;\n                         for (int row = minor; row < m; row++) {\n-                            alpha -= qTCol[row] * qrtMinor[row];\n+                            alpha -= cachedQT.getEntry(col, row) * qrtMinor[row];\n                         }\n                         alpha /= rDiag[minor] * qrtMinor[minor];\n \n                         for (int row = minor; row < m; row++) {\n-                            qTCol[row] -= alpha * qrtMinor[row];\n+                            cachedQT.addToEntry(col, row, -alpha * qrtMinor[row]);\n                         }\n                     }\n                 }\n             }\n \n-            // cache the matrix for subsequent calls\n-            cachedQT = new RealMatrixImpl(qT, false);\n-\n         }\n \n         // return the cached matrix\n \n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            double[][] hData = new double[m][n];\n+            cachedH = MatrixUtils.createRealMatrix(m, n);\n             for (int i = 0; i < m; ++i) {\n-                final double[] hDataI = hData[i];\n                 for (int j = 0; j < Math.min(i + 1, n); ++j) {\n-                    hDataI[j] = qrt[j][i] / -rDiag[j];\n-                }\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedH = new RealMatrixImpl(hData, false);\n+                    cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);\n+                }\n+            }\n \n         }\n \n--- a/src/java/org/apache/commons/math/linear/QRSolver.java\n+++ b/src/java/org/apache/commons/math/linear/QRSolver.java\n             }\n         }\n \n-        return new RealMatrixImpl(xData, false);\n+        return MatrixUtils.createRealMatrix(xData);\n \n     }\n \n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n             return outerProduct((RealVectorImpl) v);\n         } catch (ClassCastException cce) {\n             checkVectorDimensions(v);\n-            double[][] out = new double[data.length][data.length];\n+            final int m = data.length;\n+            final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n             for (int i = 0; i < data.length; i++) {\n                 for (int j = 0; j < data.length; j++) {\n-                    out[i][j] = data[i] * v.getEntry(j);\n+                    out.setEntry(i, j, data[i] * v.getEntry(j));\n                 }\n             }\n-            return new RealMatrixImpl(out);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix outerProduct(double[] v)\n-        throws IllegalArgumentException {\n-        checkVectorDimensions(v.length);\n-        double[][] out = new double[data.length][data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            for (int j = 0; j < data.length; j++) {\n-                out[i][j] = data[i] * v[j];\n-            }\n-        }\n-        return new RealMatrixImpl(out);\n+            return out;\n+        }\n     }\n \n     /**\n      * @return the square matrix outer product between instance and v\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n-    public RealMatrixImpl outerProduct(RealVectorImpl v)\n-        throws IllegalArgumentException {\n-        return (RealMatrixImpl) outerProduct(v.data);\n+    public RealMatrix outerProduct(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        final int m = data.length;\n+        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out.setEntry(i, j, data[i] * v[j]);\n+            }\n+        }\n+        return out;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n                     iData[i] = new double[n];\n                 }\n                 cachedU =\n-                    transformer.getU().multiply(new RealMatrixImpl(iData, false));\n+                    transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n \n         if (cachedS == null) {\n \n-            final int p = singularValues.length;\n-            final double[][] sData = new double[p][p];\n-            for (int i = 0; i < p; ++i) {\n-                sData[i][i] = singularValues[i];\n-            }\n-\n             // cache the matrix for subsequent calls\n-            cachedS = new RealMatrixImpl(sData, false);\n+            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n \n         }\n         return cachedS;\n                     iData[i] = new double[m];\n                 }\n                 cachedV =\n-                    transformer.getV().multiply(new RealMatrixImpl(iData, false));\n+                    transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n             }\n \n         }\n--- a/src/java/org/apache/commons/math/linear/SingularValueSolver.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueSolver.java\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n \n-        final RealMatrixImpl w = (RealMatrixImpl) decomposition.getUT().multiply(b);\n-        final double[][] wData = w.getDataRef();\n+        final RealMatrix w = decomposition.getUT().multiply(b);\n         for (int i = 0; i < singularValues.length; ++i) {\n             final double si  = singularValues[i];\n             if (si == 0) {\n                 throw new SingularMatrixException();\n             }\n             final double inv = 1.0 / si;\n-            final double[] wi = wData[i];\n             for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                wi[j] *= inv;\n+                w.multiplyEntry(i, j, inv);\n             }\n         }\n         return decomposition.getV().multiply(w);\n--- a/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(int row, int column, double increment)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        final int key = computeKey(row, column);\n+        final double value = entries.get(key) + increment;\n+        if (value == 0.0) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(int row, int column, double factor)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        final int key = computeKey(row, column);\n+        final double value = entries.get(key) * factor;\n+        if (value == 0.0) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+    }\n+\n     /**\n      * Compute the key to access a matrix element\n      * @param row row index of the matrix element\n--- a/src/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+++ b/src/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n         if (cachedQt == null) {\n \n             final int m = householderVectors.length;\n-            final double[][] qtData  = new double[m][m];\n+            cachedQt = MatrixUtils.createRealMatrix(m, m);\n \n             // build up first part of the matrix by applying Householder transforms\n             for (int k = m - 1; k >= 1; --k) {\n                 final double[] hK = householderVectors[k - 1];\n                 final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n-                qtData[k][k] = 1;\n+                cachedQt.setEntry(k, k, 1);\n                 if (hK[k] != 0.0) {\n-                    final double[] qtK = qtData[k];\n                     double beta = 1.0 / secondary[k - 1];\n-                    qtK[k] = 1 + beta * hK[k];\n+                    cachedQt.setEntry(k, k, 1 + beta * hK[k]);\n                     for (int i = k + 1; i < m; ++i) {\n-                        qtK[i] = beta * hK[i];\n+                        cachedQt.setEntry(k, i, beta * hK[i]);\n                     }\n                     for (int j = k + 1; j < m; ++j) {\n-                        final double[] qtJ = qtData[j];\n                         beta = 0;\n                         for (int i = k + 1; i < m; ++i) {\n-                            beta += qtJ[i] * hK[i];\n+                            beta += cachedQt.getEntry(j, i) * hK[i];\n                         }\n                         beta *= inv;\n-                        qtJ[k] = beta * hK[k];\n+                        cachedQt.setEntry(j, k, beta * hK[k]);\n                         for (int i = k + 1; i < m; ++i) {\n-                            qtJ[i] += beta * hK[i];\n+                            cachedQt.addToEntry(j, i, beta * hK[i]);\n                         }\n                     }\n                 }\n             }\n-            qtData[0][0] = 1;\n-\n-            // cache the matrix for subsequent calls\n-            cachedQt = new RealMatrixImpl(qtData, false);\n+            cachedQt.setEntry(0, 0, 1);\n \n         }\n \n         if (cachedT == null) {\n \n             final int m = main.length;\n-            double[][] tData = new double[m][m];\n+            cachedT = MatrixUtils.createRealMatrix(m, m);\n             for (int i = 0; i < m; ++i) {\n-                double[] tDataI = tData[i];\n-                tDataI[i] = main[i];\n+                cachedT.setEntry(i, i, main[i]);\n                 if (i > 0) {\n-                    tDataI[i - 1] = secondary[i - 1];\n+                    cachedT.setEntry(i, i - 1, secondary[i - 1]);\n                 }\n                 if (i < main.length - 1) {\n-                    tDataI[i + 1] = secondary[i];\n-                }\n-            }\n-\n-            // cache the matrix for subsequent calls\n-            cachedT = new RealMatrixImpl(tData, false);\n+                    cachedT.setEntry(i, i + 1, secondary[i]);\n+                }\n+            }\n \n         }\n \n--- a/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n \n /** \n  * A {@link RandomVectorGenerator} that generates vectors with with \n         }\n \n         // build the root matrix\n-        root = new RealMatrixImpl(order, rank);\n+        root = MatrixUtils.createRealMatrix(order, rank);\n         for (int i = 0; i < order; ++i) {\n-            System.arraycopy(b[i], 0, root.getDataRef()[index[i]], 0, rank);\n+            for (int j = 0; j < rank; ++j) {\n+                root.setEntry(index[i], j, b[i][j]);\n+            }\n         }\n \n     }\n     private double[] mean;\n \n     /** Permutated Cholesky root of the covariance matrix. */\n-    private RealMatrixImpl root;\n+    private RealMatrix root;\n \n     /** Rank of the covariance matrix. */\n     private int rank;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n import java.util.Arrays;\n \n import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n \n /**\n  * Returns the covariance matrix of the available vectors.\n     public RealMatrix getResult() {\n \n         int dimension = sums.length;\n-        RealMatrixImpl result = new RealMatrixImpl(dimension, dimension);\n+        RealMatrix result = MatrixUtils.createRealMatrix(dimension, dimension);\n \n         if (n > 1) {\n-            double[][] resultData = result.getDataRef();\n             double c = 1.0 / (n * (isBiasCorrected ? (n - 1) : n));\n             int k = 0;\n             for (int i = 0; i < dimension; ++i) {\n                 for (int j = 0; j <= i; ++j) {\n                     double e = c * (n * productsSums[k++] - sums[i] * sums[j]);\n-                    resultData[i][j] = e;\n-                    resultData[j][i] = e;\n+                    result.setEntry(i, j, e);\n+                    result.setEntry(j, i, e);\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n \n /**\n  * Abstract base class for implementations of MultipleLinearRegression.\n     protected RealMatrix X;\n \n     /** Y sample data. */\n-    protected RealMatrix Y;\n+    protected RealVector Y;\n \n     /**\n      * Loads model x and y sample data from a flat array of data, overriding any previous sample.\n                 x[i][j] = data[pointer++];\n             }\n         }\n-        this.X = new RealMatrixImpl(x);\n-        this.Y = new RealMatrixImpl(y);\n+        this.X = MatrixUtils.createRealMatrix(x);\n+        this.Y = new RealVectorImpl(y);\n     }\n     \n     /**\n      * @param y the [n,1] array representing the y sample\n      */\n     protected void newYSampleData(double[] y) {\n-        this.Y = new RealMatrixImpl(y);\n+        this.Y = new RealVectorImpl(y);\n     }\n \n     /**\n      * @param x the [n,k] array representing the x sample\n      */\n     protected void newXSampleData(double[][] x) {\n-        this.X = new RealMatrixImpl(x);\n+        this.X = MatrixUtils.createRealMatrix(x);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public double[] estimateRegressionParameters() {\n-        RealMatrix b = calculateBeta();\n-        return b.getColumn(0);\n+        return calculateBeta().getData();\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public double[] estimateResiduals() {\n-        RealMatrix b = calculateBeta();\n-        RealMatrix e = Y.subtract(X.multiply(b));\n-        return e.getColumn(0);\n+        return Y.subtract(X.operate(calculateBeta())).getData();\n     }\n \n     /**\n      * \n      * @return beta\n      */\n-    protected abstract RealMatrix calculateBeta();\n+    protected abstract RealVector calculateBeta();\n \n     /**\n      * Calculates the beta variance of multiple linear regression in matrix\n      * \n      * @return The residuals [n,1] matrix\n      */\n-    protected RealMatrix calculateResiduals() {\n-        RealMatrix b = calculateBeta();\n-        return Y.subtract(X.multiply(b));\n+    protected RealVector calculateResiduals() {\n+        return Y.subtract(X.operate(calculateBeta()));\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n \n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.LUSolver;\n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealVector;\n \n \n /**\n      * @param omega the [n,n] array representing the covariance\n      */\n     protected void newCovarianceData(double[][] omega){\n-        this.Omega = new RealMatrixImpl(omega);\n+        this.Omega = MatrixUtils.createRealMatrix(omega);\n         this.OmegaInverse = null;\n     }\n \n      * </pre>\n      * @return beta\n      */\n-    protected RealMatrix calculateBeta() {\n+    protected RealVector calculateBeta() {\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XT = X.transpose();\n         RealMatrix XTOIX = XT.multiply(OI).multiply(X);\n         RealMatrix inverse = new LUSolver(new LUDecompositionImpl(XTOIX)).getInverse();\n-        return inverse.multiply(XT).multiply(OI).multiply(Y);\n+        return inverse.multiply(XT).multiply(OI).operate(Y);\n     }\n \n     /**\n      * @return The Y variance\n      */\n     protected double calculateYVariance() {\n-        RealMatrix u = calculateResiduals();\n-        RealMatrix sse =  u.transpose().multiply(getOmegaInverse()).multiply(u);\n-        return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());\n+        final RealVector u = calculateResiduals();\n+        final double sse =  u.dotProduct(getOmegaInverse().operate(u));\n+        return sse / (X.getRowDimension() - X.getColumnDimension());\n     }\n     \n }\n--- a/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n+import org.apache.commons.math.linear.DenseRealMatrix;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.LUSolver;\n import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n \n /**\n  * <p>Implements ordinary least squares (OLS) to estimate the parameters of a \n      * @param x the [n,k] array representing the x sample\n      */\n     protected void newXSampleData(double[][] x) {\n-        this.X = new RealMatrixImpl(x);\n+        this.X = new DenseRealMatrix(x);\n         qr = new QRDecompositionImpl(X);\n     }\n     \n      * \n      * @return beta\n      */\n-    protected RealMatrix calculateBeta() {\n-        return solveUpperTriangular((RealMatrixImpl) qr.getR(),\n-                (RealMatrixImpl) qr.getQ().transpose().multiply(Y));\n+    protected RealVector calculateBeta() {\n+        return solveUpperTriangular(qr.getR(), qr.getQ().transpose().operate(Y));\n     }\n \n     /**\n      * @return The Y variance\n      */\n     protected double calculateYVariance() {\n-        RealMatrix u = calculateResiduals();\n-        RealMatrix sse = u.transpose().multiply(u);\n-        return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());\n+        final RealVector u = calculateResiduals();\n+        final double sse = u.dotProduct(u);\n+        return sse / (X.getRowDimension() - X.getColumnDimension());\n     }\n     \n     /** TODO:  Find a home for the following methods in the linear package */   \n      * \n      * @param coefficients upper-triangular coefficients matrix\n      * @param constants column RHS constants matrix\n-     * @return solution matrix as a column matrix\n+     * @return solution matrix as a vector\n      * \n      */\n-    private static RealMatrix solveUpperTriangular(RealMatrixImpl coefficients,\n-            RealMatrixImpl constants) {\n+    private static RealVector solveUpperTriangular(RealMatrix coefficients, RealVector constants) {\n         if (!isUpperTriangular(coefficients, 1E-12)) {\n             throw new IllegalArgumentException(\n                    \"Coefficients is not upper-triangular\");\n         }\n-        if (constants.getColumnDimension() != 1) {\n-            throw new IllegalArgumentException(\n-                    \"Constants not a column matrix.\");\n-        }\n         int length = coefficients.getColumnDimension();\n-        double[][] cons = constants.getDataRef();\n-        double[][] coef = coefficients.getDataRef();\n         double x[] = new double[length];\n         for (int i = 0; i < length; i++) {\n             int index = length - 1 - i;\n             double sum = 0;\n             for (int j = index + 1; j < length; j++) {\n-                sum += coef[index][j] * x[j];\n+                sum += coefficients.getEntry(index, j) * x[j];\n             }\n-            x[index] = (cons[index][0] - sum) / coef[index][index];\n+            x[index] = (constants.getEntry(index) - sum) / coefficients.getEntry(index, index);\n         } \n-        return new RealMatrixImpl(x);\n+        return new RealVectorImpl(x);\n     }\n     \n     /**\n      * @return true if m is upper-triangular; false otherwise\n      * @throws NullPointerException if m is null\n      */\n-    private static boolean isUpperTriangular(RealMatrixImpl m, double epsilon) {\n-        double[][] data = m.getDataRef();\n+    private static boolean isUpperTriangular(RealMatrix m, double epsilon) {\n         int nCols = m.getColumnDimension();\n         int nRows = m.getRowDimension();\n         for (int r = 0; r < nRows; r++) {\n             int bound = Math.min(r, nCols);\n             for (int c = 0; c < bound; c++) {\n-                if (Math.abs(data[r][c]) > epsilon) {\n+                if (Math.abs(m.getEntry(r, c)) > epsilon) {\n                     return false;\n                 }\n             }\n--- a/src/test/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n+++ b/src/test/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n     }\n \n     public void testDimensions() {\n-        checkdimensions(new RealMatrixImpl(testSquare, false));\n-        checkdimensions(new RealMatrixImpl(testNonSquare, false));\n-        checkdimensions(new RealMatrixImpl(testNonSquare, false).transpose());\n+        checkdimensions(MatrixUtils.createRealMatrix(testSquare));\n+        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n     }\n \n     private void checkdimensions(RealMatrix matrix) {\n     }\n \n     public void testAEqualUSVt() {\n-        checkAEqualUSVt(new RealMatrixImpl(testSquare, false));\n-        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false));\n-        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose());\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n     }\n \n     private void checkAEqualUSVt(RealMatrix matrix) {\n     }\n \n     public void testUOrthogonal() {\n-        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getU());\n-        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getU());\n-        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());\n     }\n \n     public void testVOrthogonal() {\n-        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getV());\n-        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getV());\n-        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());\n     }\n \n     private void checkOrthogonal(RealMatrix m) {\n     }\n \n     public void testBBiDiagonal() {\n-        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getB());\n-        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getB());\n-        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());\n     }\n \n     private void checkBiDiagonal(RealMatrix m) {\n \n     public void testMatricesValues() {\n        BiDiagonalTransformer transformer =\n-            new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false));\n+            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));\n        final double s17 = Math.sqrt(17.0);\n-        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n                 {  -8 / (5 * s17), 19 / (5 * s17) },\n                 { -19 / (5 * s17), -8 / (5 * s17) }\n         });\n-        RealMatrix bRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { -3 * s17 / 5, 32 * s17 / 85 },\n                 {      0.0,     -5 * s17 / 17 }\n         });\n-        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1.0,  0.0 },\n                 { 0.0, -1.0 }\n         });\n     }\n \n     public void testUpperOrLower() {\n-        assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).isUpperBiDiagonal());\n-        assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).isUpperBiDiagonal());\n-        assertFalse(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).isUpperBiDiagonal());\n+        assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());\n+        assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());\n+        assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n \n     public void testDimension1() {\n         RealMatrix matrix =\n-            new RealMatrixImpl(new double[][] {\n-                                   { 1.5 }\n-                               }, false);\n+            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15);\n     }\n \n     public void testDimension2() {\n         RealMatrix matrix =\n-            new RealMatrixImpl(new double[][] {\n-                                   {       59.0, 12.0 },\n-                                   { Double.NaN, 66.0 }\n-                               }, false);\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                    {       59.0, 12.0 },\n+                    { Double.NaN, 66.0 }\n+            });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15);\n \n     public void testDimension3() {\n         RealMatrix matrix =\n-            new RealMatrixImpl(new double[][] {\n+            MatrixUtils.createRealMatrix(new double[][] {\n                                    {    39632.0,    -4824.0, -16560.0 },\n                                    { Double.NaN,     8693.0,   7920.0 },\n                                    { Double.NaN, Double.NaN,  17300.0 }\n-                               }, false);\n+                               });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11);\n         assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11);\n \n     public void testDimension4WithSplit() {\n         RealMatrix matrix =\n-            new RealMatrixImpl(new double[][] {\n+            MatrixUtils.createRealMatrix(new double[][] {\n                                    {      0.784,     -0.288,       0.000,  0.000 },\n                                    { Double.NaN,      0.616,       0.000,  0.000 },\n                                    { Double.NaN, Double.NaN,       0.164, -0.048 },\n                                    { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n-                               }, false);\n+                               });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n \n     public void testDimension4WithoutSplit() {\n         RealMatrix matrix =\n-            new RealMatrixImpl(new double[][] {\n+            MatrixUtils.createRealMatrix(new double[][] {\n                                    {  0.5608, -0.2016,  0.1152, -0.2976 },\n                                    { -0.2016,  0.4432, -0.2304,  0.1152 },\n                                    {  0.1152, -0.2304,  0.3088, -0.1344 },\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n-                               }, false);\n+                               });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n      * Matrix with eigenvalues {8, -1, -1}\n      */\n     public void testRepeatedEigenvalue() {\n-        RealMatrix repeated = new RealMatrixImpl(new double[][] {\n+        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {\n                 {3,  2,  4},\n                 {2,  0,  2},\n                 {4,  2,  3}\n      * Matrix with eigenvalues {2, 0, 12}\n      */\n     public void testDistinctEigenvalues() {\n-        RealMatrix distinct = new RealMatrixImpl(new double[][] {\n+        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {\n                 {3, 1, -4},  \n                 {1, 3, -4}, \n                 {-4, -4, 8}\n             } while (norm2 * size < 0.01);\n         }\n \n-        return new RealMatrixImpl(data, false);\n+        return MatrixUtils.createRealMatrix(data);\n \n     }\n \n         for (int i = 0; i < Math.min(rows, columns); ++i) {\n             dData[i][i] = diagonal[i];\n         }\n-        return new RealMatrixImpl(dData, false);\n+        return MatrixUtils.createRealMatrix(dData);\n     }\n \n }\n--- a/src/test/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenSolverTest.java\n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n         EigenSolver es = new EigenSolver(new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             es.solve(b);\n             fail(\"an exception should have been thrown\");\n \n     /** test solve */\n     public void testSolve() {\n-        RealMatrix m = new RealMatrixImpl(new double[][] {\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {\n                 { 91,  5, 29, 32, 40, 14 },\n                 {  5, 34, -1,  0,  2, -1 },\n                 { 29, -1, 12,  9, 21,  8 },\n         });\n         EigenSolver  es = new EigenSolver(new EigenDecompositionImpl(m, MathUtils.SAFE_MIN));\n         assertEquals(184041, es.getDeterminant(), 2.0e-8);\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1561, 269, 188 },\n                 {   69, -21,  70 },\n                 {  739, 108,  63 },\n                 { 1624, 194, 107 },\n                 {  796,  69,  36 }\n         });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1,   2, 1 },\n                 { 2,  -1, 2 },\n                 { 4,   2, 3 },\n--- a/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n \n     /** test dimensions */\n     public void testDimensions() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         LUDecomposition LU = new LUDecompositionImpl(matrix);\n         assertEquals(testData.length, LU.getL().getRowDimension());\n         assertEquals(testData.length, LU.getL().getColumnDimension());\n     /** test non-square matrix */\n     public void testNonSquare() {\n         try {\n-            new LUDecompositionImpl(new RealMatrixImpl(new double[3][2], false));\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n         } catch (Exception e) {\n \n     /** test PA = LU */\n     public void testPAEqualLU() {\n-        RealMatrix matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         LUDecomposition lu = new LUDecompositionImpl(matrix);\n         RealMatrix l = lu.getL();\n         RealMatrix u = lu.getU();\n         double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n         assertEquals(0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testDataMinus, false);\n+        matrix = MatrixUtils.createRealMatrix(testDataMinus);\n         lu = new LUDecompositionImpl(matrix);\n         l = lu.getL();\n         u = lu.getU();\n         norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n         assertEquals(0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(singular, false);\n+        matrix = MatrixUtils.createRealMatrix(singular);\n         lu = new LUDecompositionImpl(matrix);\n         assertTrue(lu.isSingular());\n         assertNull(lu.getL());\n         assertNull(lu.getU());\n         assertNull(lu.getP());\n \n-        matrix = new RealMatrixImpl(bigSingular, false);\n+        matrix = MatrixUtils.createRealMatrix(bigSingular);\n         lu = new LUDecompositionImpl(matrix);\n         assertTrue(lu.isSingular());\n         assertNull(lu.getL());\n \n     /** test that L is lower triangular with unit diagonal */\n     public void testLLowerTriangular() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         RealMatrix l = new LUDecompositionImpl(matrix).getL();\n         for (int i = 0; i < l.getRowDimension(); i++) {\n             assertEquals(l.getEntry(i, i), 1, entryTolerance);\n \n     /** test that U is upper triangular */\n     public void testUUpperTriangular() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         RealMatrix u = new LUDecompositionImpl(matrix).getU();\n         for (int i = 0; i < u.getRowDimension(); i++) {\n             for (int j = 0; j < i; j++) {\n \n     /** test that P is a permutation matrix */\n     public void testPPermutation() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n         RealMatrix p   = new LUDecompositionImpl(matrix).getP();\n \n         RealMatrix ppT = p.multiply(p.transpose());\n     /** test singular */\n     public void testSingular() {\n         LUDecomposition lu =\n-            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n         assertFalse(lu.isSingular());\n-        lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n-        assertTrue(lu.isSingular());\n-        lu = new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false));\n+        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular));\n+        assertTrue(lu.isSingular());\n+        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular));\n         assertTrue(lu.isSingular());\n     }\n \n     /** test matrices values */\n     public void testMatricesValues1() {\n        LUDecomposition lu =\n-            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n-        RealMatrix lRef = new RealMatrixImpl(new double[][] {\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1.0, 0.0, 0.0 },\n                 { 0.5, 1.0, 0.0 },\n                 { 0.5, 0.2, 1.0 }\n         });\n-        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 2.0,  5.0, 3.0 },\n                 { 0.0, -2.5, 6.5 },\n                 { 0.0,  0.0, 0.2 }\n         });\n-        RealMatrix pRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 0.0, 1.0, 0.0 },\n                 { 0.0, 0.0, 1.0 },\n                 { 1.0, 0.0, 0.0 }\n     /** test matrices values */\n     public void testMatricesValues2() {\n        LUDecomposition lu =\n-            new LUDecompositionImpl(new RealMatrixImpl(luData, false));\n-        RealMatrix lRef = new RealMatrixImpl(new double[][] {\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(luData));\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n                 {    1.0,    0.0, 0.0 },\n                 {    0.0,    1.0, 0.0 },\n                 { 1.0 / 3.0, 0.0, 1.0 }\n         });\n-        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 6.0, 9.0,    8.0    },\n                 { 0.0, 5.0,    7.0    },\n                 { 0.0, 0.0, 1.0 / 3.0 }\n         });\n-        RealMatrix pRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 0.0, 0.0, 1.0 },\n                 { 0.0, 1.0, 0.0 },\n                 { 1.0, 0.0, 0.0 }\n--- a/src/test/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/LUSolverTest.java\n \n     /** test threshold impact */\n     public void testThreshold() {\n-        final RealMatrix matrix = new RealMatrixImpl(new double[][] {\n+        final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {\n                                                        { 1.0, 2.0, 3.0},\n                                                        { 2.0, 5.0, 3.0},\n                                                        { 4.000001, 9.0, 9.0}\n-                                                     }, false);\n+                                                     });\n         assertFalse(new LUSolver(new LUDecompositionImpl(matrix, 1.0e-5)).isNonSingular());\n         assertTrue(new LUSolver(new LUDecompositionImpl(matrix, 1.0e-10)).isNonSingular());\n     }\n     /** test singular */\n     public void testSingular() {\n         LUSolver lu =\n-            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(testData, false)));\n+            new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)));\n         assertTrue(lu.isNonSingular());\n-        lu = new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(singular, false)));\n+        lu = new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)));\n         assertFalse(lu.isNonSingular());\n-        lu = new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)));\n+        lu = new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)));\n         assertFalse(lu.isNonSingular());\n     }\n \n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n         LUSolver solver =\n-            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(testData, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+            new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n     /** test solve singularity errors */\n     public void testSolveSingularityErrors() {\n         LUSolver solver =\n-            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(singular, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+            new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n     /** test solve */\n     public void testSolve() {\n         LUSolver solver =\n-            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(testData, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n+            new LUSolver(new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1, 0 }, { 2, -5 }, { 3, 1 }\n         });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 19, -71 }, { -6, 22 }, { -2, 9 }\n         });\n \n \n     /** test determinant */\n     public void testDeterminant() {\n-        assertEquals( -1, getDeterminant(new RealMatrixImpl(testData, false)), 1.0e-15);\n-        assertEquals(-10, getDeterminant(new RealMatrixImpl(luData, false)), 1.0e-14);\n-        assertEquals(  0, getDeterminant(new RealMatrixImpl(singular, false)), 1.0e-17);\n-        assertEquals(  0, getDeterminant(new RealMatrixImpl(bigSingular, false)), 1.0e-10);\n+        assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n+        assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);\n+        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);\n+        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);\n     }\n \n     private double getDeterminant(RealMatrix m) {\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n     /** test dimensions */\n     public void testDimensions() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         QRDecomposition qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"3x3 Q size\", qr.getQ().getRowDimension(), 3);\n         assertEquals(\"3x3 Q size\", qr.getQ().getColumnDimension(), 3);\n         assertEquals(\"3x3 R size\", qr.getR().getRowDimension(), 3);\n         assertEquals(\"3x3 R size\", qr.getR().getColumnDimension(), 3);\n \n-        matrix = new RealMatrixImpl(testData4x3, false);\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n         qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"4x3 Q size\", qr.getQ().getRowDimension(), 4);\n         assertEquals(\"4x3 Q size\", qr.getQ().getColumnDimension(), 4);\n         assertEquals(\"4x3 R size\", qr.getR().getRowDimension(), 4);\n         assertEquals(\"4x3 R size\", qr.getR().getColumnDimension(), 3);\n \n-        matrix = new RealMatrixImpl(testData3x4, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n         qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"3x4 Q size\", qr.getQ().getRowDimension(), 3);\n         assertEquals(\"3x4 Q size\", qr.getQ().getColumnDimension(), 3);\n \n     /** test A = QR */\n     public void testAEqualQR() {\n-        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix A = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         QRDecomposition qr = new QRDecompositionImpl(A);\n         RealMatrix Q = qr.getQ();\n         RealMatrix R = qr.getR();\n         double norm = Q.multiply(R).subtract(A).getNorm();\n         assertEquals(\"3x3 nonsingular A = QR\", 0, norm, normTolerance);\n \n-        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"3x3 singular A = QR\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"3x4 A = QR\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3, false);\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"4x3 A = QR\", 0, norm, normTolerance);\n \n     /** test the orthogonality of Q */\n     public void testQOrthogonal() {\n-        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         RealMatrix q  = new QRDecompositionImpl(matrix).getQ();\n         RealMatrix qT = new QRDecompositionImpl(matrix).getQT();\n         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);\n         double norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x3 nonsingular Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n         q  = new QRDecompositionImpl(matrix).getQ();\n         qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n         norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x3 singular Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n         q  = new QRDecompositionImpl(matrix).getQ();\n         qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n         norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x4 Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3, false);\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n         q  = new QRDecompositionImpl(matrix).getQ();\n         qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(4);\n \n     /** test that R is upper triangular */\n     public void testRUpperTriangular() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         RealMatrix R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3, false);\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n \n     /** test that H is trapezoidal */\n     public void testHTrapezoidal() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         RealMatrix H = new QRDecompositionImpl(matrix).getH();\n         for (int i = 0; i < H.getRowDimension(); i++)\n             for (int j = i + 1; j < H.getColumnDimension(); j++)\n                 assertEquals(H.getEntry(i, j), 0, entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n         H = new QRDecompositionImpl(matrix).getH();\n         for (int i = 0; i < H.getRowDimension(); i++)\n             for (int j = i + 1; j < H.getColumnDimension(); j++)\n                 assertEquals(H.getEntry(i, j), 0, entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4, false);\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n         H = new QRDecompositionImpl(matrix).getH();\n         for (int i = 0; i < H.getRowDimension(); i++)\n             for (int j = i + 1; j < H.getColumnDimension(); j++)\n                 assertEquals(H.getEntry(i, j), 0, entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3, false);\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n         H = new QRDecompositionImpl(matrix).getH();\n         for (int i = 0; i < H.getRowDimension(); i++)\n             for (int j = i + 1; j < H.getColumnDimension(); j++)\n     /** test matrices values */\n     public void testMatricesValues() {\n         QRDecomposition qr =\n-            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n-        RealMatrix qRef = new RealMatrixImpl(new double[][] {\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n                 {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n                 {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }\n         });\n-        RealMatrix rRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { -14.0,  -21.0, 14.0 },\n                 {   0.0, -175.0, 70.0 },\n                 {   0.0,    0.0, 35.0 }\n         });\n-        RealMatrix hRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 26.0 / 14.0, 0.0, 0.0 },\n                 {  6.0 / 14.0, 648.0 / 325.0, 0.0 },\n                 { -4.0 / 14.0,  36.0 / 325.0, 2.0 }\n--- a/src/test/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRSolverTest.java\n     /** test rank */\n     public void testRank() {\n         QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)));\n+            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)));\n         assertTrue(solver.isNonSingular());\n \n-        solver = new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false)));\n+        solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)));\n         assertFalse(solver.isNonSingular());\n \n-        solver = new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false)));\n+        solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)));\n         assertTrue(solver.isNonSingular());\n \n-        solver = new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false)));\n+        solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)));\n         assertTrue(solver.isNonSingular());\n \n     }\n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n         QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n     /** test solve rank errors */\n     public void testSolveRankErrors() {\n         QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n     /** test solve */\n     public void testSolve() {\n         QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n+            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n         });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1, 2515 }, { 2, 422 }, { -3, 898 }\n         });\n \n--- a/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n         double dot_2 =  v1.dotProduct(v2_t);\n         assertEquals(\"compare val \",32d, dot_2);\n \n-        RealMatrixImpl m_outerProduct = v1.outerProduct(v2);\n+        RealMatrix m_outerProduct = v1.outerProduct(v2);\n         assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n \n         RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n--- a/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n \n     /** test dimensions */\n     public void testDimensions() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testSquare, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);\n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n         SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n \n     /** test A = USVt */\n     public void testAEqualUSVt() {\n-        checkAEqualUSVt(new RealMatrixImpl(testSquare, false));\n-        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false));\n-        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose());\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n     }\n \n     public void checkAEqualUSVt(final RealMatrix matrix) {\n \n     /** test that U is orthogonal */\n     public void testUOrthogonal() {\n-        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)).getU());\n-        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false)).getU());\n-        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false).transpose()).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());\n     }\n \n     /** test that V is orthogonal */\n     public void testVOrthogonal() {\n-        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)).getV());\n-        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false)).getV());\n-        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false).transpose()).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());\n     }\n \n     public void checkOrthogonal(final RealMatrix m) {\n     /** test matrices values */\n     public void testMatricesValues1() {\n        SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n-        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 3.0 / 5.0, -4.0 / 5.0 },\n                 { 4.0 / 5.0,  3.0 / 5.0 }\n         });\n-        RealMatrix sRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 3.0, 0.0 },\n                 { 0.0, 1.0 }\n         });\n-        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { 4.0 / 5.0,  3.0 / 5.0 },\n                 { 3.0 / 5.0, -4.0 / 5.0 }\n         });\n     /** test matrices values */\n     public void testMatricesValues2() {\n \n-        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n             {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },\n             { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },\n             {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },\n             { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }\n         });\n-        RealMatrix sRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {\n             { 4.0, 0.0, 0.0 },\n             { 0.0, 3.0, 0.0 },\n             { 0.0, 0.0, 2.0 }\n         });\n-        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n             {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },\n             {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },\n             { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }\n \n         // check values against known references\n         SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false));\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare));\n         RealMatrix u = svd.getU();\n         assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n         RealMatrix s = svd.getS();\n     /** test condition number */\n     public void testConditionNumber() {\n         SingularValueDecompositionImpl svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n         assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n     }\n \n--- a/src/test/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/SingularValueSolverTest.java\n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n         SingularValueSolver solver =\n-            new SingularValueSolver(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+            new SingularValueSolver(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n     /** test solve singularity errors */\n     public void testSolveSingularityErrors() {\n         RealMatrix m =\n-            new RealMatrixImpl(new double[][] {\n+            MatrixUtils.createRealMatrix(new double[][] {\n                                    { 1.0, 0.0 },\n                                    { 0.0, 0.0 }\n-                               }, false);\n+                               });\n         SingularValueSolver solver = new SingularValueSolver(new SingularValueDecompositionImpl(m));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n     /** test solve */\n     public void testSolve() {\n         SingularValueSolver solver =\n-            new SingularValueSolver(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)));\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n+            new SingularValueSolver(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)));\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1, 2, 3 }, { 0, -5, 1 }\n         });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n                 { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },\n                 { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }\n         });\n     /** test condition number */\n     public void testConditionNumber() {\n         SingularValueDecompositionImpl svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n         assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n     }\n \n--- a/src/test/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+++ b/src/test/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n \n     public void testNonSquare() {\n         try {\n-            new TriDiagonalTransformer(new RealMatrixImpl(new double[3][2], false));\n+            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n     }\n \n     public void testAEqualQTQt() {\n-        checkAEqualQTQt(new RealMatrixImpl(testSquare5, false));\n-        checkAEqualQTQt(new RealMatrixImpl(testSquare3, false));\n+        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));\n+        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));\n     }\n \n     private void checkAEqualQTQt(RealMatrix matrix) {\n             modifiedData[i] = data[i].clone();\n             Arrays.fill(modifiedData[i], 0, i, Double.NaN);\n         }\n-        RealMatrix matrix = new RealMatrixImpl(modifiedData, false);\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData);\n         TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n         RealMatrix q  = transformer.getQ();\n         RealMatrix qT = transformer.getQT();\n         RealMatrix t  = transformer.getT();\n-        double norm = q.multiply(t).multiply(qT).subtract(new RealMatrixImpl(data, false)).getNorm();\n+        double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();\n         assertEquals(0, norm, 4.0e-15);\n     }\n \n     public void testQOrthogonal() {\n-        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQ());\n-        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQ());\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());\n     }\n \n     public void testQTOrthogonal() {\n-        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQT());\n-        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQT());\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());\n+        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());\n     }\n \n     private void checkOrthogonal(RealMatrix m) {\n     }\n \n     public void testTTriDiagonal() {\n-        checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getT());\n-        checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getT());\n+        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());\n+        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());\n     }\n \n     private void checkTriDiagonal(RealMatrix m) {\n                                      double[] mainDiagnonal,\n                                      double[] secondaryDiagonal) {\n         TriDiagonalTransformer transformer =\n-            new TriDiagonalTransformer(new RealMatrixImpl(matrix, false));\n+            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix));\n \n         // check values against known references\n         RealMatrix q = transformer.getQ();\n-        assertEquals(0, q.subtract(new RealMatrixImpl(qRef, false)).getNorm(), 1.0e-14);\n+        assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);\n \n         RealMatrix t = transformer.getT();\n         double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];\n                 tData[i][i + 1] = secondaryDiagonal[i];\n             }\n         }\n-        assertEquals(0, t.subtract(new RealMatrixImpl(tData, false)).getNorm(), 1.0e-14);\n+        assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);\n \n         // check the same cached instance is returned the second time\n         assertTrue(q == transformer.getQ());\n--- a/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n     } catch (ConvergenceException ce) {\n         // expected behavior\n     } catch (Exception e) {\n+        e.printStackTrace(System.err);\n         fail(\"wrong exception caught: \" + e.getMessage());\n     }\n \n--- a/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n \n package org.apache.commons.math.random;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n-\n-import junit.framework.*;\n \n public class CorrelatedRandomVectorGeneratorTest\n extends TestCase {\n                 { 2, 16, 38, -1 },\n                 { 6, 2, -1, 197 }\n         };\n-        RealMatrix covRM = new RealMatrixImpl(cov, false);\n+        RealMatrix covRM = MatrixUtils.createRealMatrix(cov);\n         JDKRandomGenerator jg = new JDKRandomGenerator();\n         jg.setSeed(5322145245211l);\n         NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);\n         try {\n             mean = new double[] { 0.0, 1.0, -3.0, 2.3};\n \n-            RealMatrixImpl b = new RealMatrixImpl(4, 3);\n-            double[][] bData = b.getDataRef();\n+            RealMatrix b = MatrixUtils.createRealMatrix(4, 3);\n             int counter = 0;\n-            for (int i = 0; i < bData.length; ++i) {\n-                double[] bi = bData[i];\n+            for (int i = 0; i < b.getRowDimension(); ++i) {\n                 for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                    bi[j] = 1.0 + 0.1 * ++counter;\n+                    b.setEntry(i, j, 1.0 + 0.1 * ++counter);\n                 }\n             }\n             RealMatrix bbt = b.multiply(b.transpose());\n-            covariance = new RealMatrixImpl(mean.length, mean.length);\n-            double[][] covData = covariance.getDataRef();\n+            covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);\n             for (int i = 0; i < covariance.getRowDimension(); ++i) {\n-                covData[i][i] = bbt.getEntry(i, i);\n+                covariance.setEntry(i, i, bbt.getEntry(i, i));\n                 for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n                     double s = bbt.getEntry(i, j);\n-                    covData[i][j] = s;\n-                    covData[j][i] = s;\n+                    covariance.setEntry(i, j, s);\n+                    covariance.setEntry(j, i, s);\n                 }\n             }\n \n     }\n \n     private double[] mean;\n-    private RealMatrixImpl covariance;\n+    private RealMatrix covariance;\n     private CorrelatedRandomVectorGenerator generator;\n \n }\n--- a/src/test/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n         createRegression().newSampleData(y, x, null);\n     }\n     \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=ArrayIndexOutOfBoundsException.class)\n     public void cannotAddNullCovarianceData() {\n         createRegression().newSampleData(new double[]{}, new double[][]{}, null);\n     }", "timestamp": 1229731393, "metainfo": ""}