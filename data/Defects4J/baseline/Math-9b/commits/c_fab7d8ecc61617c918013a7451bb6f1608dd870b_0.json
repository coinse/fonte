{"sha": "fab7d8ecc61617c918013a7451bb6f1608dd870b", "log": "Populate throws declarations for geometry package.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/Space.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/Space.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+\n /** This interface represents a generic space, with affine and vectorial counterparts.\n  * @version $Id$\n  * @see Vector\n     /** Get the n-1 dimension subspace of this space.\n      * @return n-1 dimension sub-space of this space\n      * @see #getDimension()\n+     * @exception MathUnsupportedOperationException for dimension-1 spaces\n+     * which do not have sub-spaces\n      */\n-    Space getSubSpace();\n+    Space getSubSpace() throws MathUnsupportedOperationException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/geometry/Vector.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/Vector.java\n \n import java.io.Serializable;\n import java.text.NumberFormat;\n+\n+import org.apache.commons.math3.exception.MathArithmeticException;\n \n /** This interface represents a generic vector in a vectorial space or a point in an affine space.\n  * @param <S> Type of the space.\n \n     /** Get a normalized vector aligned with the instance.\n      * @return a new normalized vector\n-     * @exception ArithmeticException if the norm is zero\n+     * @exception MathArithmeticException if the norm is zero\n      */\n-    Vector<S> normalize();\n+    Vector<S> normalize() throws MathArithmeticException;\n \n     /** Multiply the instance by a scalar.\n      * @param a scalar\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java\n     }\n \n     /** {@inheritDoc} */\n-    public Vector1D normalize() {\n+    public Vector1D normalize() throws MathArithmeticException {\n         double s = getNorm();\n         if (s == 0) {\n             throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1DFormat.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1DFormat.java\n \n     /** {@inheritDoc} */\n     @Override\n-    public Vector1D parse(final String source) {\n+    public Vector1D parse(final String source) throws MathParseException {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector1D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n  */\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.geometry.Vector;\n import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\n      * @param p2 second point belonging to the line (this can be any point, different from p1)\n      * @exception MathIllegalArgumentException if the points are equal\n      */\n-    public Line(final Vector3D p1, final Vector3D p2) {\n+    public Line(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n         reset(p1, p2);\n     }\n \n      * @param p2 second point belonging to the line (this can be any point, different from p1)\n      * @exception MathIllegalArgumentException if the points are equal\n      */\n-    public void reset(final Vector3D p1, final Vector3D p2) {\n+    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n         final Vector3D delta = p2.subtract(p1);\n         final double norm2 = delta.getNormSq();\n         if (norm2 == 0.0) {\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        return new Line(zero, zero.subtract(direction));\n+        try {\n+            return new Line(zero, zero.subtract(direction));\n+        } catch (MathIllegalArgumentException miae) {\n+            // this should never happen has the instance was already built without error\n+            throw new MathInternalError(miae);\n+        }\n     }\n \n     /** Get the normalized direction vector.\n      * @return true if the lines are similar\n      */\n     public boolean isSimilarTo(final Line line) {\n-        final double angle = Vector3D.angle(direction, line.direction);\n-        return ((angle < 1.0e-10) || (angle > (FastMath.PI - 1.0e-10))) && contains(line.zero);\n+        try {\n+            final double angle = Vector3D.angle(direction, line.direction);\n+            return ((angle < 1.0e-10) || (angle > (FastMath.PI - 1.0e-10))) && contains(line.zero);\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as directions are non-zero vectors\n+            throw new MathInternalError(mae);\n+        }\n     }\n \n     /** Check if the instance contains a point.\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.geometry.Vector;\n import org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n+import org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n-import org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet;\n import org.apache.commons.math3.geometry.partitioning.Embedding;\n import org.apache.commons.math3.geometry.partitioning.Hyperplane;\n import org.apache.commons.math3.util.FastMath;\n      * @param normal normal direction to the plane\n      * @exception MathArithmeticException if the normal norm is too small\n      */\n-    public Plane(final Vector3D normal) {\n+    public Plane(final Vector3D normal) throws MathArithmeticException {\n         setNormal(normal);\n         originOffset = 0;\n         setFrame();\n      * @param normal normal direction to the plane\n      * @exception MathArithmeticException if the normal norm is too small\n      */\n-    public Plane(final Vector3D p, final Vector3D normal) {\n+    public Plane(final Vector3D p, final Vector3D normal) throws MathArithmeticException {\n         setNormal(normal);\n         originOffset = -p.dotProduct(w);\n         setFrame();\n      * @param p3 third point belonging to the plane\n      * @exception MathArithmeticException if the points do not constitute a plane\n      */\n-    public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3) {\n+    public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3)\n+        throws MathArithmeticException {\n         this(p1, p2.subtract(p1).crossProduct(p3.subtract(p1)));\n     }\n \n     /** Reset the instance as if built from a point and a normal.\n      * @param p point belonging to the plane\n      * @param normal normal direction to the plane\n-     */\n-    public void reset(final Vector3D p, final Vector3D normal) {\n+     * @exception MathArithmeticException if the normal norm is too small\n+     */\n+    public void reset(final Vector3D p, final Vector3D normal) throws MathArithmeticException {\n         setNormal(normal);\n         originOffset = -p.dotProduct(w);\n         setFrame();\n      * @param normal normal direction to the plane (will be copied)\n      * @exception MathArithmeticException if the normal norm is too small\n      */\n-    private void setNormal(final Vector3D normal) {\n+    private void setNormal(final Vector3D normal) throws MathArithmeticException {\n         final double norm = normal.getNorm();\n         if (norm < 1.0e-10) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n     /** Reset the plane frame.\n      */\n     private void setFrame() {\n-        origin = new Vector3D(-originOffset, w);\n-        u = w.orthogonal();\n-        v = Vector3D.crossProduct(w, u);\n+        try {\n+            origin = new Vector3D(-originOffset, w);\n+            u = w.orthogonal();\n+            v = Vector3D.crossProduct(w, u);\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as w is built to be non-zero\n+            throw new MathInternalError(mae);\n+        }\n     }\n \n     /** Get the origin point of the plane frame.\n      * @return true if the planes are similar\n      */\n     public boolean isSimilarTo(final Plane plane) {\n-        final double angle = Vector3D.angle(w, plane.w);\n-        return ((angle < 1.0e-10) && (FastMath.abs(originOffset - plane.originOffset) < 1.0e-10)) ||\n-               ((angle > (FastMath.PI - 1.0e-10)) && (FastMath.abs(originOffset + plane.originOffset) < 1.0e-10));\n+        try {\n+            final double angle = Vector3D.angle(w, plane.w);\n+            return ((angle < 1.0e-10) && (FastMath.abs(originOffset - plane.originOffset) < 1.0e-10)) ||\n+                    ((angle > (FastMath.PI - 1.0e-10)) && (FastMath.abs(originOffset + plane.originOffset) < 1.0e-10));\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as w vectors are built to be non-zero\n+            throw new MathInternalError(mae);\n+        }\n     }\n \n     /** Rotate the plane around the specified point.\n      */\n     public Plane rotate(final Vector3D center, final Rotation rotation) {\n \n-        final Vector3D delta = origin.subtract(center);\n-        final Plane plane = new Plane(center.add(rotation.applyTo(delta)),\n-                                rotation.applyTo(w));\n-\n-        // make sure the frame is transformed as desired\n-        plane.u = rotation.applyTo(u);\n-        plane.v = rotation.applyTo(v);\n-\n-        return plane;\n+        try {\n+            final Vector3D delta = origin.subtract(center);\n+            final Plane plane = new Plane(center.add(rotation.applyTo(delta)),\n+                                          rotation.applyTo(w));\n+\n+            // make sure the frame is transformed as desired\n+            plane.u = rotation.applyTo(u);\n+            plane.v = rotation.applyTo(v);\n+\n+            return plane;\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as w vector is built to be non-zero\n+            throw new MathInternalError(mae);\n+        }\n \n     }\n \n      */\n     public Plane translate(final Vector3D translation) {\n \n-        final Plane plane = new Plane(origin.add(translation), w);\n-\n-        // make sure the frame is transformed as desired\n-        plane.u = u;\n-        plane.v = v;\n-\n-        return plane;\n+        try {\n+            final Plane plane = new Plane(origin.add(translation), w);\n+\n+            // make sure the frame is transformed as desired\n+            plane.u = u;\n+            plane.v = v;\n+\n+            return plane;\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as w vector is built to be non-zero\n+            throw new MathInternalError(mae);\n+        }\n \n     }\n \n      * other plane (really a {@link Line Line} instance)\n      */\n     public Line intersection(final Plane other) {\n-        final Vector3D direction = Vector3D.crossProduct(w, other.w);\n-        if (direction.getNorm() < 1.0e-10) {\n-            return null;\n-        }\n-        final Vector3D point = intersection(this, other, new Plane(direction));\n-        return new Line(point, point.add(direction));\n+        try {\n+            final Vector3D direction = Vector3D.crossProduct(w, other.w);\n+            if (direction.getNorm() < 1.0e-10) {\n+                return null;\n+            }\n+            final Vector3D point = intersection(this, other, new Plane(direction));\n+            return new Line(point, point.add(direction));\n+        } catch (MathIllegalArgumentException miae) {\n+            // this should never happen as direction has been checked to have non-zero norm\n+            throw new MathInternalError(miae);\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as direction has been checked to have non-zero norm\n+            throw new MathInternalError(mae);\n+        }\n     }\n \n     /** Get the intersection point of three planes.\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n import java.awt.geom.AffineTransform;\n import java.util.Collection;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.geometry.Vector;\n import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n      * @param zMin low bound along the z direction\n      * @param zMax high bound along the z direction\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public PolyhedronsSet(final double xMin, final double xMax,\n                           final double yMin, final double yMax,\n                           final double zMin, final double zMax) {\n-        this(new RegionFactory<Euclidean3D>().buildConvex(\n-            new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I),\n-            new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I),\n-            new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J),\n-            new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J),\n-            new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K),\n-            new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K)).getTree(false));\n+        super(buildBoundary(xMin, xMax, yMin, yMax, zMin, zMax));\n+    }\n+\n+    /** Build a parallellepipedic box boundary.\n+     * @param xMin low bound along the x direction\n+     * @param xMax high bound along the x direction\n+     * @param yMin low bound along the y direction\n+     * @param yMax high bound along the y direction\n+     * @param zMin low bound along the z direction\n+     * @param zMax high bound along the z direction\n+     * @return boundary tree\n+     */\n+    private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax,\n+                                                      final double yMin, final double yMax,\n+                                                      final double zMin, final double zMax) {\n+        try {\n+            final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I);\n+            final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I);\n+            final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J);\n+            final Plane pyMax = new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J);\n+            final Plane pzMin = new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K);\n+            final Plane pzMax = new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K);\n+            @SuppressWarnings(\"unchecked\")\n+            final Region<Euclidean3D> boundary =\n+                    new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\n+            return boundary.getTree(false);\n+        } catch (MathArithmeticException mae) {\n+            // this should never happen as provided normals are all non-zero\n+            throw new MathInternalError(mae);\n+        }\n     }\n \n     /** {@inheritDoc} */\n                 final Vector3D p00    = oPlane.getOrigin();\n                 final Vector3D p10    = oPlane.toSpace(new Vector2D(1.0, 0.0));\n                 final Vector3D p01    = oPlane.toSpace(new Vector2D(0.0, 1.0));\n-                final Vector2D  tP00   = tPlane.toSubSpace(apply(p00));\n-                final Vector2D  tP10   = tPlane.toSubSpace(apply(p10));\n-                final Vector2D  tP01   = tPlane.toSubSpace(apply(p01));\n+                final Vector2D tP00   = tPlane.toSubSpace(apply(p00));\n+                final Vector2D tP10   = tPlane.toSubSpace(apply(p10));\n+                final Vector2D tP01   = tPlane.toSubSpace(apply(p01));\n                 final AffineTransform at =\n                     new AffineTransform(tP10.getX() - tP00.getX(), tP10.getY() - tP00.getY(),\n                                         tP01.getX() - tP00.getX(), tP01.getY() - tP00.getY(),\n                                         tP00.getX(), tP00.getY());\n \n                 cachedOriginal  = (Plane) original;\n-                cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n+                try {\n+                    cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n+                } catch (MathIllegalArgumentException miae) {\n+                    // this should never happen as the transform built on p00, p10, p01 is invertible\n+                    throw new MathInternalError(miae);\n+                }\n \n             }\n             return ((SubLine) sub).applyTransform(cachedTransform);\n                     AffineTransform.getTranslateInstance(shift.getX(), shift.getY());\n \n                 cachedOriginal  = (Plane) original;\n-                cachedTransform =\n-                    org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n+                try {\n+                    cachedTransform =\n+                            org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);\n+                } catch (MathIllegalArgumentException miae) {\n+                    // this should never happen as a translation is always invertible\n+                    throw new MathInternalError(miae);\n+                }\n \n             }\n \n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n    * @param angle rotation angle.\n    * @exception MathIllegalArgumentException if the axis norm is zero\n    */\n-  public Rotation(Vector3D axis, double angle) {\n+  public Rotation(Vector3D axis, double angle) throws MathIllegalArgumentException {\n \n     double norm = axis.getNorm();\n     if (norm == 0) {\n    * @param u2 second vector of the origin pair\n    * @param v1 desired image of u1 by the rotation\n    * @param v2 desired image of u2 by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero,\n+   * @exception MathArithmeticException if the norm of one of the vectors is zero,\n    * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n    */\n   public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n-      throws MathIllegalArgumentException {\n+      throws MathArithmeticException {\n \n       // build orthonormalized base from u1, u2\n       // this fails when vectors are null or colinear, which is forbidden to define a rotation\n \n    * @param u origin vector\n    * @param v desired image of u by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero\n-   */\n-  public Rotation(Vector3D u, Vector3D v) {\n+   * @exception MathArithmeticException if the norm of one of the vectors is zero\n+   */\n+  public Rotation(Vector3D u, Vector3D v) throws MathArithmeticException {\n \n     double normProduct = u.getNorm() * v.getNorm();\n     if (normProduct == 0) {\n-        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n+        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n     }\n \n     double dot = u.dotProduct(v);\n    */\n   public Rotation(RotationOrder order,\n                   double alpha1, double alpha2, double alpha3) {\n-    Rotation r1 = new Rotation(order.getA1(), alpha1);\n-    Rotation r2 = new Rotation(order.getA2(), alpha2);\n-    Rotation r3 = new Rotation(order.getA3(), alpha3);\n-    Rotation composed = r1.applyTo(r2.applyTo(r3));\n-    q0 = composed.q0;\n-    q1 = composed.q1;\n-    q2 = composed.q2;\n-    q3 = composed.q3;\n+      try {\n+          Rotation r1 = new Rotation(order.getA1(), alpha1);\n+          Rotation r2 = new Rotation(order.getA2(), alpha2);\n+          Rotation r3 = new Rotation(order.getA3(), alpha3);\n+          Rotation composed = r1.applyTo(r2.applyTo(r3));\n+          q0 = composed.q0;\n+          q1 = composed.q1;\n+          q2 = composed.q2;\n+          q3 = composed.q3;\n+      } catch (MathIllegalArgumentException miae) {\n+          // this should never happen as RotationOrder axes are all normalized,\n+          // and hence never null\n+          throw new MathInternalError(miae);\n+      }\n   }\n \n   /** Convert an orthogonal rotation matrix to a quaternion.\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.geometry.euclidean.oned.Interval;\n import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\n import org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\n     /** Create a sub-line from two endpoints.\n      * @param start start point\n      * @param end end point\n+     * @exception MathIllegalArgumentException if the points are equal\n      */\n-    public SubLine(final Vector3D start, final Vector3D end) {\n+    public SubLine(final Vector3D start, final Vector3D end)\n+        throws MathIllegalArgumentException {\n         this(new Line(start, end), buildIntervalSet(start, end));\n     }\n \n     /** Create a sub-line from a segment.\n      * @param segment single segment forming the sub-line\n+     * @exception MathIllegalArgumentException if the segment endpoints are equal\n      */\n-    public SubLine(final Segment segment) {\n+    public SubLine(final Segment segment) throws MathIllegalArgumentException {\n         this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n     }\n \n      * @param start start point\n      * @param end end point\n      * @return an interval set\n+     * @exception MathIllegalArgumentException if the points are equal\n      */\n-    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) {\n+    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end)\n+        throws MathIllegalArgumentException {\n         final Line line = new Line(start, end);\n         return new IntervalsSet(line.toSubSpace(start).getX(),\n                                 line.toSubSpace(end).getX());\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java\n     }\n \n     /** {@inheritDoc} */\n-    public Vector3D normalize() {\n+    public Vector3D normalize() throws MathArithmeticException {\n         double s = getNorm();\n         if (s == 0) {\n             throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n      * @return a new normalized vector orthogonal to the instance\n      * @exception MathArithmeticException if the norm of the instance is null\n      */\n-    public Vector3D orthogonal() {\n+    public Vector3D orthogonal() throws MathArithmeticException {\n \n         double threshold = 0.6 * getNorm();\n         if (threshold == 0) {\n      * @return angular separation between v1 and v2\n      * @exception MathArithmeticException if either vector has a null norm\n      */\n-    public static double angle(Vector3D v1, Vector3D v2) {\n+    public static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n \n         double normProduct = v1.getNorm() * v2.getNorm();\n         if (normProduct == 0) {\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormat.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormat.java\n      * cannot be parsed.\n      */\n     @Override\n-    public Vector3D parse(final String source) {\n+    public Vector3D parse(final String source) throws MathParseException {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector3D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java\n     }\n \n     /** {@inheritDoc} */\n-    public Vector2D normalize() {\n+    public Vector2D normalize() throws MathArithmeticException {\n         double s = getNorm();\n         if (s == 0) {\n             throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2DFormat.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2DFormat.java\n \n     /** {@inheritDoc} */\n     @Override\n-    public Vector2D parse(final String source) {\n+    public Vector2D parse(final String source) throws MathParseException {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector2D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/LineTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/LineTest.java\n  */\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.geometry.euclidean.threed.Line;\n import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n import org.apache.commons.math3.util.FastMath;\n public class LineTest {\n \n     @Test\n-    public void testContains() {\n+    public void testContains() throws MathIllegalArgumentException, MathArithmeticException {\n         Vector3D p1 = new Vector3D(0, 0, 1);\n         Line l = new Line(p1, new Vector3D(0, 0, 2));\n         Assert.assertTrue(l.contains(p1));\n     }\n \n     @Test\n-    public void testSimilar() {\n+    public void testSimilar() throws MathIllegalArgumentException, MathArithmeticException {\n         Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n         Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n         Line     lA  = new Line(p1, p2);\n     }\n \n     @Test\n-    public void testPointDistance() {\n+    public void testPointDistance() throws MathIllegalArgumentException {\n         Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10);\n         Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10);\n     }\n \n     @Test\n-    public void testLineDistance() {\n+    public void testLineDistance() throws MathIllegalArgumentException {\n         Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertEquals(1.0,\n                             l.distance(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))),\n     }\n \n     @Test\n-    public void testClosest() {\n+    public void testClosest() throws MathIllegalArgumentException {\n         Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertEquals(0.0,\n                             l.closestPoint(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))).distance(new Vector3D(0, 0, 0)),\n     }\n \n     @Test\n-    public void testIntersection() {\n+    public void testIntersection() throws MathIllegalArgumentException {\n         Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertNull(l.intersection(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))));\n         Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))));\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PlaneTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PlaneTest.java\n  */\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.geometry.euclidean.threed.Line;\n import org.apache.commons.math3.geometry.euclidean.threed.Plane;\n import org.apache.commons.math3.geometry.euclidean.threed.Rotation;\n public class PlaneTest {\n \n     @Test\n-    public void testContains() {\n+    public void testContains() throws MathArithmeticException {\n         Plane p = new Plane(new Vector3D(0, 0, 1), new Vector3D(0, 0, 1));\n         Assert.assertTrue(p.contains(new Vector3D(0, 0, 1)));\n         Assert.assertTrue(p.contains(new Vector3D(17, -32, 1)));\n     }\n \n     @Test\n-    public void testOffset() {\n+    public void testOffset() throws MathArithmeticException {\n         Vector3D p1 = new Vector3D(1, 1, 1);\n         Plane p = new Plane(p1, new Vector3D(0.2, 0, 0));\n         Assert.assertEquals(-5.0, p.getOffset(new Vector3D(-4, 0, 0)), 1.0e-10);\n     }\n \n     @Test\n-    public void testPoint() {\n+    public void testPoint() throws MathArithmeticException {\n         Plane p = new Plane(new Vector3D(2, -3, 1), new Vector3D(1, 4, 9));\n         Assert.assertTrue(p.contains(p.getOrigin()));\n     }\n \n     @Test\n-    public void testThreePoints() {\n+    public void testThreePoints() throws MathArithmeticException {\n         Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);\n         Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);\n         Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);\n     }\n \n     @Test\n-    public void testRotate() {\n+    public void testRotate() throws MathArithmeticException, MathIllegalArgumentException {\n         Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);\n         Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);\n         Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);\n     }\n \n     @Test\n-    public void testTranslate() {\n+    public void testTranslate() throws MathArithmeticException {\n         Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);\n         Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);\n         Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);\n     }\n \n     @Test\n-    public void testIntersection() {\n+    public void testIntersection() throws MathArithmeticException, MathIllegalArgumentException {\n         Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5));\n         Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1.2, -2.5, -0.3));\n         Vector3D point = p.intersection(l);\n     }\n \n     @Test\n-    public void testIntersection2() {\n+    public void testIntersection2() throws MathArithmeticException {\n         Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n         Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n         Plane    pA  = new Plane(p1, p2, new Vector3D (-2.0, 4.3, 0.7));\n     }\n \n     @Test\n-    public void testIntersection3() {\n+    public void testIntersection3() throws MathArithmeticException {\n         Vector3D reference = new Vector3D (1.2, 3.4, -5.8);\n         Plane p1 = new Plane(reference, new Vector3D(1, 3, 3));\n         Plane p2 = new Plane(reference, new Vector3D(-2, 4, 0));\n     }\n \n     @Test\n-    public void testSimilar() {\n+    public void testSimilar() throws MathArithmeticException {\n         Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n         Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n         Vector3D p3  = new Vector3D (-2.0, 4.3, 0.7);\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSetTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSetTest.java\n \n import java.util.ArrayList;\n \n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet;\n import org.apache.commons.math3.geometry.euclidean.twod.SubLine;\n     }\n \n     @Test\n-    public void testTetrahedron() {\n+    public void testTetrahedron() throws MathArithmeticException {\n         Vector3D vertex1 = new Vector3D(1, 2, 3);\n         Vector3D vertex2 = new Vector3D(2, 2, 4);\n         Vector3D vertex3 = new Vector3D(2, 3, 3);\n     }\n \n     @Test\n-    public void testIsometry() {\n+    public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException {\n         Vector3D vertex1 = new Vector3D(1.1, 2.2, 3.3);\n         Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2);\n         Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7);\n     }\n \n     @Test\n-    public void testIssue780() {\n+    public void testIssue780() throws MathArithmeticException {\n         float[] coords = {\n             1.000000f, -1.000000f, -1.000000f, \n             1.000000f, -1.000000f, 1.000000f, \n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationTest.java\n   }\n \n   @Test\n-  public void testAxisAngle() {\n+  public void testAxisAngle() throws MathIllegalArgumentException {\n \n     Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);\n     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);\n   }\n \n   @Test\n-  public void testVectorOnePair() {\n+  public void testVectorOnePair() throws MathArithmeticException {\n \n     Vector3D u = new Vector3D(3, 2, 1);\n     Vector3D v = new Vector3D(-4, 2, 2);\n     try {\n         new Rotation(u, Vector3D.ZERO);\n         Assert.fail(\"an exception should have been thrown\");\n-    } catch (IllegalArgumentException e) {\n+    } catch (MathArithmeticException e) {\n         // expected behavior\n     }\n \n   }\n \n   @Test\n-  public void testVectorTwoPairs() {\n+  public void testVectorTwoPairs() throws MathArithmeticException {\n \n     Vector3D u1 = new Vector3D(3, 0, 0);\n     Vector3D u2 = new Vector3D(0, 5, 0);\n   }\n \n   @Test\n-  public void testQuaternion() {\n+  public void testQuaternion() throws MathIllegalArgumentException {\n \n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n     double n = 23.5;\n   }\n \n   @Test\n-  public void testCompose() {\n+  public void testCompose() throws MathIllegalArgumentException {\n \n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n     Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n   }\n \n   @Test\n-  public void testComposeInverse() {\n+  public void testComposeInverse() throws MathIllegalArgumentException {\n \n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n     Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n   }\n \n   @Test\n-  public void testArray() {\n+  public void testArray() throws MathIllegalArgumentException {\n \n       Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n \n   }\n \n   @Test\n-  public void testApplyInverseTo() {\n+  public void testApplyInverseTo() throws MathIllegalArgumentException {\n \n     Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n   }\n \n   @Test\n-  public void testIssue639(){\n+  public void testIssue639() throws MathArithmeticException{\n       Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n                                  -5774608829631843.0 /  268435456.0,\n                                  -3822921525525679.0 / 4294967296.0);\n   }\n \n   @Test\n-  public void testIssue801() {\n+  public void testIssue801() throws MathArithmeticException {\n       Vector3D u1 = new Vector3D(0.9999988431610581, -0.0015210774290851095, 0.0);\n       Vector3D u2 = new Vector3D(0.0, 0.0, 1.0);\n \n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/SubLineTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/SubLineTest.java\n \n import java.util.List;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n public class SubLineTest {\n \n     @Test\n-    public void testEndPoints() {\n+    public void testEndPoints() throws MathIllegalArgumentException {\n         Vector3D p1 = new Vector3D(-1, -7, 2);\n         Vector3D p2 = new Vector3D(7, -1, 0);\n         Segment segment = new Segment(p1, p2, new Line(p1, p2));\n     }\n \n     @Test\n-    public void testNoEndPoints() {\n+    public void testNoEndPoints() throws MathIllegalArgumentException {\n         SubLine wholeLine = new Line(new Vector3D(-1, 7, 2), new Vector3D(7, 1, 0)).wholeLine();\n         List<Segment> segments = wholeLine.getSegments();\n         Assert.assertEquals(1, segments.size());\n     }\n \n     @Test\n-    public void testNoSegments() {\n+    public void testNoSegments() throws MathIllegalArgumentException {\n         SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)),\n                                     (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));\n         List<Segment> segments = empty.getSegments();\n     }\n \n     @Test\n-    public void testSeveralSegments() {\n+    public void testSeveralSegments() throws MathIllegalArgumentException {\n         SubLine twoSubs = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)),\n                                       (IntervalsSet) new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2),\n                                                                                             new IntervalsSet(3, 4)));\n     }\n \n     @Test\n-    public void testHalfInfiniteNeg() {\n+    public void testHalfInfiniteNeg() throws MathIllegalArgumentException {\n         SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)),\n                                     new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0));\n         List<Segment> segments = empty.getSegments();\n     }\n \n     @Test\n-    public void testHalfInfinitePos() {\n+    public void testHalfInfinitePos() throws MathIllegalArgumentException {\n         SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)),\n                                     new IntervalsSet(0.0, Double.POSITIVE_INFINITY));\n         List<Segment> segments = empty.getSegments();\n     }\n \n     @Test\n-    public void testIntersectionInsideInside() {\n+    public void testIntersectionInsideInside() throws MathIllegalArgumentException {\n         SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));\n         SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 2, 2));\n         Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n     }\n \n     @Test\n-    public void testIntersectionInsideBoundary() {\n+    public void testIntersectionInsideBoundary() throws MathIllegalArgumentException {\n         SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));\n         SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1));\n         Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n     }\n \n     @Test\n-    public void testIntersectionInsideOutside() {\n+    public void testIntersectionInsideOutside() throws MathIllegalArgumentException {\n         SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));\n         SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));\n         Assert.assertNull(sub1.intersection(sub2, true));\n     }\n \n     @Test\n-    public void testIntersectionBoundaryBoundary() {\n+    public void testIntersectionBoundaryBoundary() throws MathIllegalArgumentException {\n         SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1));\n         SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1));\n         Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n     }\n \n     @Test\n-    public void testIntersectionBoundaryOutside() {\n+    public void testIntersectionBoundaryOutside() throws MathIllegalArgumentException {\n         SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1));\n         SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));\n         Assert.assertNull(sub1.intersection(sub2, true));\n     }\n \n     @Test\n-    public void testIntersectionOutsideOutside() {\n+    public void testIntersectionOutsideOutside() throws MathIllegalArgumentException {\n         SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\n         SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));\n         Assert.assertNull(sub1.intersection(sub2, true));\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormatAbstractTest.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math3.exception.MathParseException;\n import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n import org.apache.commons.math3.geometry.euclidean.threed.Vector3DFormat;\n import org.junit.Test;\n     }\n \n     @Test\n-    public void testParseSimpleNoDecimals() {\n+    public void testParseSimpleNoDecimals() throws MathParseException {\n         String source = \"{1; 1; 1}\";\n         Vector3D expected = new Vector3D(1, 1, 1);\n         Vector3D actual = vector3DFormat.parse(source);\n     }\n \n     @Test\n-    public void testParseSimpleWithDecimals() {\n+    public void testParseSimpleWithDecimals() throws MathParseException {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"23; 1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseSimpleWithDecimalsTrunc() {\n+    public void testParseSimpleWithDecimalsTrunc() throws MathParseException {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"2323; 1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseNegativeX() {\n+    public void testParseNegativeX() throws MathParseException {\n         String source =\n             \"{-1\" + getDecimalCharacter() +\n             \"2323; 1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseNegativeY() {\n+    public void testParseNegativeY() throws MathParseException {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"2323; -1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseNegativeZ() {\n+    public void testParseNegativeZ() throws MathParseException {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"2323; 1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseNegativeAll() {\n+    public void testParseNegativeAll() throws MathParseException {\n         String source =\n             \"{-1\" + getDecimalCharacter() +\n             \"2323; -1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseZeroX() {\n+    public void testParseZeroX() throws MathParseException {\n         String source =\n             \"{0\" + getDecimalCharacter() +\n             \"0; -1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseNonDefaultSetting() {\n+    public void testParseNonDefaultSetting() throws MathParseException {\n         String source =\n             \"[1\" + getDecimalCharacter() +\n             \"2323 : 1\" + getDecimalCharacter() +\n     }\n \n     @Test\n-    public void testParseNan() {\n+    public void testParseNan() throws MathParseException {\n         String source = \"{(NaN); (NaN); (NaN)}\";\n         Vector3D actual = vector3DFormat.parse(source);\n         Assert.assertEquals(Vector3D.NaN, actual);\n     }\n \n     @Test\n-    public void testParsePositiveInfinity() {\n+    public void testParsePositiveInfinity() throws MathParseException {\n         String source = \"{(Infinity); (Infinity); (Infinity)}\";\n         Vector3D actual = vector3DFormat.parse(source);\n         Assert.assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n     }\n \n     @Test\n-    public void testParseNegativeInfinity() {\n+    public void testParseNegativeInfinity() throws MathParseException {\n         String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n         Vector3D actual = vector3DFormat.parse(source);\n         Assert.assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DTest.java\n \n public class Vector3DTest {\n     @Test\n-    public void testConstructors() {\n+    public void testConstructors() throws DimensionMismatchException {\n         double r = FastMath.sqrt(2) /2;\n         checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)),\n                     r, r * FastMath.sqrt(3), -2 * r);\n     }\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void testWrongDimension() {\n+    public void testWrongDimension() throws DimensionMismatchException {\n         new Vector3D(new double[] { 2,  5 });\n     }\n \n     }\n \n     @Test\n-    public void testAngularSeparation() {\n+    public void testAngularSeparation() throws MathArithmeticException {\n         Vector3D v1 = new Vector3D(2, -1, 4);\n \n         Vector3D  k = v1.normalize();\n   }\n \n     @Test\n-    public void testNormalize() {\n+    public void testNormalize() throws MathArithmeticException {\n         Assert.assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);\n         try {\n             Vector3D.ZERO.normalize();\n     }\n \n     @Test\n-    public void testOrthogonal() {\n+    public void testOrthogonal() throws MathArithmeticException {\n         Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);\n         Assert.assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);\n         Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);\n     }\n \n     @Test\n-    public void testAngle() {\n+    public void testAngle() throws MathArithmeticException {\n         Assert.assertEquals(0.22572612855273393616,\n                             Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),\n                             1.0e-12);\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/LineTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/LineTest.java\n  */\n package org.apache.commons.math3.geometry.euclidean.twod;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math3.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math3.geometry.euclidean.twod.Line;\n     }\n \n     @Test\n-    public void testTransform() {\n+    public void testTransform() throws MathIllegalArgumentException {\n \n         Line l1 = new Line(new Vector2D(1.0 ,1.0), new Vector2D(4.0 ,1.0));\n         Transform<Euclidean2D, Euclidean1D> t1 =", "timestamp": 1346595772, "metainfo": ""}