{"sha": "703a07553a6c401cb83297d047896cd3920408af", "log": "Started work on JAMA-like interfaces. This first step is an enhancement of the existing QR-decomposition interface and associated implementation in JAMA-style, i.e with added getH() method and most importantly various solve methods for least-squares solution of the A * X = B equation. JIRA: MATH-220  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A base interface to decomposition algorithms that can solve A &times; X = B.\n+ * <p>This interface is the common base of decomposition algorithms like\n+ * {@link QRDecomposition} or {@link LUDecomposition}. All these algorithms\n+ * decompose an A matrix has a product of several specific matrices from\n+ * which they can solve A &times; X = B.</p>\n+ * <p>Depending on the solver, the solution is either an exact linear solution\n+ * or a least squares solution. When an exact linear solution exist, both the\n+ * linear and the least squares solution are equal. When no exact linear solution\n+ * exist, a least square solution gives an X which such that A &times; X is the\n+ * closest possible to B.</p>\n+ *   \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DecompositionSolver extends Serializable {\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    double[] solve(double[] b)\n+      throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealVector solve(RealVector b)\n+      throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealMatrix solve(RealMatrix b)\n+      throws IllegalArgumentException, InvalidMatrixException;\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n /**\n  * An interface to classes that implement a algorithm to calculate the \n  * QR-decomposition of a real matrix.\n+ * <p>This interface is similar to the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n  *   \n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public interface QRDecomposition {\n+public interface QRDecomposition extends DecompositionSolver {\n \n     /**\n      * Returns the matrix R of the decomposition. \n-     * \n+     * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n      */\n-    public abstract RealMatrix getR();\n+    RealMatrix getR();\n \n     /**\n      * Returns the matrix Q of the decomposition.\n-     * \n+     * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n      */\n-    public abstract RealMatrix getQ();\n+    RealMatrix getQ();\n+\n+    /**\n+     * Returns the Householder reflector vectors.\n+     * <p>H is a lower trapezoidal matrix whose columns represent\n+     * each successive Householder reflector vector. This matrix is used\n+     * to compute Q.</p>\n+     * @return a matrix containing the Householder reflector vectors\n+     */\n+    RealMatrix getH();\n+\n+    /**\n+     * Check if the decomposed matrix is full rank.\n+     * @return true if the decomposed matrix is full rank\n+     */\n+    boolean isFullRank();\n+\n }\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n  */\n public class QRDecompositionImpl implements QRDecomposition {\n \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3965943878043764074L;\n+\n     /**\n      * A packed representation of the QR decomposition. The elements above the \n      * diagonal are the elements of R, and the columns of the lower triangle \n      * are the Householder reflector vectors of which an explicit form of Q can\n      * be calculated. \n      */\n-    private double[][] qr;\n+    private final double[][] qr;\n \n     /**\n      * The diagonal elements of R.\n      */\n-    private double[] rDiag;\n+    private final double[] rDiag;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of R. */\n+    private RealMatrix cachedR;\n+\n+    /** Cached value of H. */\n+    private RealMatrix cachedH;\n \n     /**\n      * The row dimension of the given matrix. The size of Q will be m x m, the \n      * size of R will be m x n. \n      */\n-    private int m;\n+    private final int m;\n \n     /**\n      * The column dimension of the given matrix. The size of R will be m x n. \n      */\n-    private int n;\n+    private final int n;\n \n     /**\n      * Calculates the QR decomposition of the given matrix. \n         n = matrix.getColumnDimension();\n         qr = matrix.getData();\n         rDiag = new double[n];\n+        cachedQ = null;\n+        cachedR = null;\n+        cachedH = null;\n \n         /*\n          * The QR decomposition of a matrix A is calculated using Householder\n              */\n             double xNormSqr = 0;\n             for (int row = minor; row < m; row++) {\n-                xNormSqr += qr[row][minor]*qr[row][minor];\n-            }\n-            double a = Math.sqrt(xNormSqr);\n-            if (qr[minor][minor] > 0) a = -a;\n+                final double c = qr[row][minor];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (qr[minor][minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n             rDiag[minor] = a;\n \n             if (a != 0.0) {\n                  * |v|^2 = -2a*(qr[minor][minor]), so\n                  * alpha = -<x,v>/(a*qr[minor][minor])\n                  */\n-                for (int col = minor+1; col < n; col++) {\n+                for (int col = minor + 1; col < n; col++) {\n                     double alpha = 0;\n                     for (int row = minor; row < m; row++) {\n-                        alpha -= qr[row][col]*qr[row][minor];\n+                        final double[] qrRow = qr[row];\n+                        alpha -= qrRow[col] * qrRow[minor];\n                     }\n-                    alpha /= a*qr[minor][minor];\n+                    alpha /= a * qr[minor][minor];\n \n                     // Subtract the column vector alpha*v from x.\n                     for (int row = minor; row < m; row++) {\n-                        qr[row][col] -= alpha*qr[row][minor];\n+                        final double[] qrRow = qr[row];\n+                        qrRow[col] -= alpha * qrRow[minor];\n                     }\n                 }\n             }\n         }\n     }\n \n-    /**\n-     * Returns the matrix R of the QR-decomposition. \n-     * \n-     * @return the R matrix\n-     */\n-    public RealMatrix getR()\n-    {\n-        // R is supposed to be m x n\n-        RealMatrixImpl ret = new RealMatrixImpl(m,n);\n-        double[][] r = ret.getDataRef();\n-\n-        // copy the diagonal from rDiag and the upper triangle of qr\n-        for (int row = Math.min(m,n)-1; row >= 0; row--) {\n-            r[row][row] = rDiag[row];\n-            for (int col = row+1; col < n; col++) {\n-                r[row][col] = qr[row][col];\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    /**\n-     * Returns the matrix Q of the QR-decomposition.\n-     * \n-     * @return the Q matrix\n-     */\n-    public RealMatrix getQ()\n-    {\n-        // Q is supposed to be m x m\n-        RealMatrixImpl ret = new RealMatrixImpl(m,m);\n-        double[][] Q = ret.getDataRef();\n-\n-        /* \n-         * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n-         * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n-         * succession to the result \n-         */ \n-        for (int minor = m-1; minor >= Math.min(m,n); minor--) {\n-            Q[minor][minor]=1;\n-        }\n-\n-        for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n-            Q[minor][minor] = 1;\n-            if (qr[minor][minor] != 0.0) {\n-                for (int col = minor; col < m; col++) {\n-                    double alpha = 0;\n-                    for (int row = minor; row < m; row++) {\n-                        alpha -= Q[row][col] * qr[row][minor];\n+    /** {@inheritDoc} */\n+    public RealMatrix getR() {\n+\n+        if (cachedR == null) {\n+\n+            // R is supposed to be m x n\n+            double[][] r = new double[m][n];\n+\n+            // copy the diagonal from rDiag and the upper triangle of qr\n+            for (int row = Math.min(m,n)-1; row >= 0; row--) {\n+                final double[] rRow = r[row];\n+                rRow[row] = rDiag[row];\n+                System.arraycopy(qr[row], row + 1, rRow, row + 1, n - row - 1);\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedR = new RealMatrixImpl(r, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedR;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getQ() {\n+\n+        if (cachedQ == null) {\n+\n+            // Q is supposed to be m x m\n+            double[][] Q = new double[m][m];\n+\n+            /* \n+             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n+             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n+             * succession to the result \n+             */ \n+            for (int minor = m-1; minor >= Math.min(m,n); minor--) {\n+                Q[minor][minor]=1;\n+            }\n+\n+            for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n+                Q[minor][minor] = 1;\n+                if (qr[minor][minor] != 0.0) {\n+                    for (int col = minor; col < m; col++) {\n+                        double alpha = 0;\n+                        for (int row = minor; row < m; row++) {\n+                            alpha -= Q[row][col] * qr[row][minor];\n+                        }\n+                        alpha /= rDiag[minor]*qr[minor][minor];\n+\n+                        for (int row = minor; row < m; row++) {\n+                            Q[row][col] -= alpha*qr[row][minor];\n+                        }\n                     }\n-                    alpha /= rDiag[minor]*qr[minor][minor];\n-\n-                    for (int row = minor; row < m; row++) {\n-                        Q[row][col] -= alpha*qr[row][minor];\n-                    }\n-                }\n-            }\n-        }\n-\n-        return ret;\n-    }\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedQ = new RealMatrixImpl(Q, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedQ;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getH() {\n+        if (cachedH == null) {\n+\n+            double[][] hData = new double[m][n];\n+            for (int i = 0; i < m; ++i) {\n+                for (int j = 0; j < Math.min(i + 1, n); ++j) {\n+                    hData[i][j] = qr[i][j] / -rDiag[j];\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedH = new RealMatrixImpl(hData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedH;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isFullRank() {\n+        for (double diag : rDiag) {\n+            if (diag == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+ \n+            if (b.length != m) {\n+                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+            }\n+            if (!isFullRank()) {\n+                throw new InvalidMatrixException(\"Matrix is rank-deficient\");\n+            }\n+\n+            final double[] x = new double[n];\n+            final double[] y = b.clone();\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qr[row][minor];\n+                }\n+                dotProduct /= rDiag[minor] * qr[minor][minor];\n+\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qr[row][minor];\n+                }\n+\n+            }\n+\n+            // solve triangular system R.x = y\n+            for (int row = n - 1; row >= 0; --row) {\n+                y[row] /= rDiag[row];\n+                final double yRow = y[row];\n+                x[row] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                    y[i] -= yRow * qr[i][row];\n+                }\n+            }\n+\n+            return x;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+            return new RealVectorImpl(solve(b.getData()), false);\n+        }\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (!isFullRank()) {\n+            throw new InvalidMatrixException(\"Matrix is rank-deficient\");\n+        }\n+\n+        final int cols = b.getColumnDimension();\n+        final double[][] xData = new double[n][cols];\n+        final double[] y = new double[b.getRowDimension()];\n+\n+        for (int k = 0; k < cols; ++k) {\n+\n+            // get the right hand side vector\n+            for (int j = 0; j < y.length; ++j) {\n+                y[j] = b.getEntry(j, k);\n+            }\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qr[row][minor];\n+                }\n+                dotProduct /= rDiag[minor] * qr[minor][minor];\n+\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qr[row][minor];\n+                }\n+\n+            }\n+\n+            // solve triangular system R.x = y\n+            for (int row = n - 1; row >= 0; --row) {\n+                y[row] /= rDiag[row];\n+                final double yRow = y[row];\n+                xData[row][k] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                   y[i] -= yRow * qr[i][row];\n+                }\n+             }\n+\n+        }\n+\n+        return new RealMatrixImpl(xData, false);\n+\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4, false);\n+        matrix = new RealMatrixImpl(testData3x3Singular, false);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3, false);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n-    }\n+\n+        matrix = new RealMatrixImpl(testData4x3, false);\n+        R = new QRDecompositionImpl(matrix).getR();\n+        for (int i = 0; i < R.getRowDimension(); i++)\n+            for (int j = 0; j < i; j++)\n+                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n+                        entryTolerance);\n+    }\n+\n+    /** test that H is trapezoidal */\n+    public void testHTrapezoidal() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x4, false);\n+        H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData4x3, false);\n+        H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+    }\n+\n+    /** test rank */\n+    public void testRank() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        assertTrue(qr.isFullRank());\n+\n+        qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));\n+        assertFalse(qr.isFullRank());\n+\n+        qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false));\n+        assertFalse(qr.isFullRank());\n+\n+        qr = new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false));\n+        assertTrue(qr.isFullRank());\n+\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            qr.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve rank errors */\n+    public void testSolveRankErrors() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+        try {\n+            qr.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, qr.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(qr.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         qr.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         qr.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        RealMatrix qRef = new RealMatrixImpl(new double[][] {\n+                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n+                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n+                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }\n+        });\n+        RealMatrix rRef = new RealMatrixImpl(new double[][] {\n+                { -14.0,  -21.0, 14.0 },\n+                {   0.0, -175.0, 70.0 },\n+                {   0.0,    0.0, 35.0 }\n+        });\n+        RealMatrix hRef = new RealMatrixImpl(new double[][] {\n+                { 26.0 / 14.0, 0.0, 0.0 },\n+                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },\n+                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix q = qr.getQ();\n+        assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        RealMatrix r = qr.getR();\n+        assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n+        RealMatrix h = qr.getH();\n+        assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(q == qr.getQ());\n+        assertTrue(r == qr.getR());\n+        assertTrue(h == qr.getH());\n+        \n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n \n     // Testclass to test the RealVector interface \n     // only with enough content to support the test\n-    public class RealVectorTestImpl implements RealVector, Serializable {\n+    public static class RealVectorTestImpl implements RealVector, Serializable {\n \n         /** Serializable version identifier. */\n         private static final long serialVersionUID = 8731816072271374422L;\n         }\n \n         public double[] getData() {\n-            throw unsupported();\n+            return data.clone();\n         }\n \n         public double dotProduct(RealVector v) throws IllegalArgumentException {", "timestamp": 1219182077, "metainfo": ""}