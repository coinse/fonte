{"sha": "ce95573d61e6de535371b537e474f50f389dc6a8", "log": "Changed integration API for consistency with solvers API. Now the main convergence parameters are set in the constructor and remain fixed, but a maximal number of function evaluation must be provided at each call to the integration method.  JIRA: MATH-464  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n     /** Weights for the current method. */\n     private final double[] weights;\n \n-    /** Build a Legendre-Gauss integrator.\n+    /**\n+     * Build a Legendre-Gauss integrator with given accuracies and iterations counts.\n      * @param n number of points desired (must be between 2 and 5 inclusive)\n-     * @param defaultMaximalIterationCount maximum number of iterations\n-     * @exception IllegalArgumentException if the number of points is not\n-     * in the supported range\n-     */\n-    public LegendreGaussIntegrator(final int n, final int defaultMaximalIterationCount)\n-        throws IllegalArgumentException {\n-        super(defaultMaximalIterationCount);\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     */\n+    public LegendreGaussIntegrator(final int n,\n+                                   final double relativeAccuracy,\n+                                   final double absoluteAccuracy,\n+                                   final int minimalIterationCount,\n+                                   final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+        super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n         switch(n) {\n         case 2 :\n             abscissas = ABSCISSAS_2;\n \n     }\n \n+    /**\n+     * Build a Legendre-Gauss integrator with given accuracies.\n+     * @param n number of points desired (must be between 2 and 5 inclusive)\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     */\n+    public LegendreGaussIntegrator(final int n,\n+                                   final double relativeAccuracy,\n+                                   final double absoluteAccuracy) {\n+        this(n, relativeAccuracy, absoluteAccuracy,\n+             DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\n+    }\n+\n+    /**\n+     * Build a Legendre-Gauss integrator with given iteration counts.\n+     * @param n number of points desired (must be between 2 and 5 inclusive)\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     */\n+    public LegendreGaussIntegrator(final int n,\n+                                   final int minimalIterationCount,\n+                                   final int maximalIterationCount) {\n+        this(n, DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY,\n+             minimalIterationCount, maximalIterationCount);\n+    }\n+\n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n-        throws ConvergenceException,  MathUserException, IllegalArgumentException {\n-\n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n+    protected double doIntegrate()\n+        throws TooManyEvaluationsException, ConvergenceException {\n \n         // compute first estimate with a single step\n-        double oldt = stage(f, min, max, 1);\n+        double oldt = stage(1);\n \n         int n = 2;\n-        for (int i = 0; i < maximalIterationCount; ++i) {\n+        while (true) {\n \n             // improve integral with a larger number of steps\n-            final double t = stage(f, min, max, n);\n+            final double t = stage(n);\n \n             // estimate error\n             final double delta = FastMath.abs(t - oldt);\n                          relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n \n             // check convergence\n-            if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {\n-                setResult(t, i);\n+            if ((iterations.getCount() + 1 >= minimalIterationCount) && (delta <= limit)) {\n+                setResult(t);\n                 return result;\n             }\n \n             double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n             n = FastMath.max((int) (ratio * n), n + 1);\n             oldt = t;\n+            iterations.incrementCount();\n \n         }\n \n-        throw new MaxCountExceededException(maximalIterationCount);\n-\n     }\n \n     /**\n      * Compute the n-th stage integral.\n-     * @param f the integrand function\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n      * @param n number of steps\n      * @return the value of n-th stage integral\n-     * @throws MathUserException if an error occurs evaluating the\n-     * function\n-     */\n-    private double stage(final UnivariateRealFunction f,\n-                         final double min, final double max, final int n)\n-        throws MathUserException {\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    private double stage(final int n)\n+        throws TooManyEvaluationsException {\n \n         // set up the step for the current stage\n         final double step     = (max - min) / n;\n         double sum = 0.0;\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < abscissas.length; ++j) {\n-                sum += weights[j] * f.value(midPoint + halfStep * abscissas[j]);\n+                sum += weights[j] * computeObjectiveValue(midPoint + halfStep * abscissas[j]);\n             }\n             midPoint += step;\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  */\n public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n \n+    /** Maximal number of iterations for Romberg. */\n+    public static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;\n+\n     /**\n-     * Construct an integrator.\n+     * Build a Romberg integrator with given accuracies and iterations counts.\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #ROMBERG_MAX_ITERATIONS_COUNT})\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #ROMBERG_MAX_ITERATIONS_COUNT}\n+     */\n+    public RombergIntegrator(final double relativeAccuracy,\n+                             final double absoluteAccuracy,\n+                             final int minimalIterationCount,\n+                             final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > ROMBERG_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                ROMBERG_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Build a Romberg integrator with given iteration counts.\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #ROMBERG_MAX_ITERATIONS_COUNT})\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #ROMBERG_MAX_ITERATIONS_COUNT}\n+     */\n+    public RombergIntegrator(final int minimalIterationCount,\n+                             final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > ROMBERG_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                ROMBERG_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Construct a Romberg integrator with default settings\n+     * (max iteration count set to {@link #ROMBERG_MAX_ITERATIONS_COUNT})\n      */\n     public RombergIntegrator() {\n-        super(32);\n+        super(DEFAULT_MIN_ITERATIONS_COUNT, ROMBERG_MAX_ITERATIONS_COUNT);\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n-        throws MaxCountExceededException, MathUserException, IllegalArgumentException {\n+    protected double doIntegrate()\n+        throws TooManyEvaluationsException, ConvergenceException {\n \n-        final int m = maximalIterationCount + 1;\n+        final int m = iterations.getMaximalCount() + 1;\n         double previousRow[] = new double[m];\n         double currentRow[]  = new double[m];\n \n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n+        currentRow[0] = qtrap.stage(this, 0);\n+        iterations.incrementCount();\n+        double olds = currentRow[0];\n+        while (true) {\n \n-        TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n-        currentRow[0] = qtrap.stage(f, min, max, 0);\n-        double olds = currentRow[0];\n-        for (int i = 1; i <= maximalIterationCount; ++i) {\n+            final int i = iterations.getCount();\n \n             // switch rows\n             final double[] tmpRow = previousRow;\n             previousRow = currentRow;\n             currentRow = tmpRow;\n \n-            currentRow[0] = qtrap.stage(f, min, max, i);\n+            currentRow[0] = qtrap.stage(this, i);\n+            iterations.incrementCount();\n             for (int j = 1; j <= i; j++) {\n                 // Richardson extrapolation coefficient\n                 final double r = (1L << (2 * j)) - 1;\n                 final double delta  = FastMath.abs(s - olds);\n                 final double rLimit = relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n-                    setResult(s, i);\n+                    setResult(s);\n                     return result;\n                 }\n             }\n             olds = s;\n         }\n-        throw new MaxCountExceededException(maximalIterationCount);\n+\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        super.verifyIterationCount();\n-        // at most 32 bisection refinements due to higher order divider\n-        if (maximalIterationCount > 32) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n-                    0, 32);\n-        }\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  */\n public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n \n+    /** Maximal number of iterations for Simpson. */\n+    public static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;\n+\n     /**\n-     * Construct an integrator.\n+     * Build a Simpson integrator with given accuracies and iterations counts.\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #SIMPSON_MAX_ITERATIONS_COUNT})\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #SIMPSON_MAX_ITERATIONS_COUNT}\n+     */\n+    public SimpsonIntegrator(final double relativeAccuracy,\n+                             final double absoluteAccuracy,\n+                             final int minimalIterationCount,\n+                             final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > SIMPSON_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                SIMPSON_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Build a Simpson integrator with given iteration counts.\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #SIMPSON_MAX_ITERATIONS_COUNT})\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #SIMPSON_MAX_ITERATIONS_COUNT}\n+     */\n+    public SimpsonIntegrator(final int minimalIterationCount,\n+                             final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > SIMPSON_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                SIMPSON_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Construct an integrator with default settings.\n+     * (max iteration count set to {@link #SIMPSON_MAX_ITERATIONS_COUNT})\n      */\n     public SimpsonIntegrator() {\n-        super(64);\n+        super(DEFAULT_MIN_ITERATIONS_COUNT, SIMPSON_MAX_ITERATIONS_COUNT);\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n-        throws MaxCountExceededException, MathUserException, IllegalArgumentException {\n-\n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n+    protected double doIntegrate()\n+        throws TooManyEvaluationsException, ConvergenceException {\n \n         TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n         if (minimalIterationCount == 1) {\n-            final double s = (4 * qtrap.stage(f, min, max, 1) - qtrap.stage(f, min, max, 0)) / 3.0;\n-            setResult(s, 1);\n+            final double s = (4 * qtrap.stage(this, 1) - qtrap.stage(this, 0)) / 3.0;\n+            setResult(s);\n             return result;\n         }\n         // Simpson's rule requires at least two trapezoid stages.\n         double olds = 0;\n-        double oldt = qtrap.stage(f, min, max, 0);\n-        for (int i = 1; i <= maximalIterationCount; ++i) {\n-            final double t = qtrap.stage(f, min, max, i);\n+        double oldt = qtrap.stage(this, 0);\n+        while (true) {\n+            final double t = qtrap.stage(this, iterations.getCount());\n+            iterations.incrementCount();\n             final double s = (4 * t - oldt) / 3.0;\n-            if (i >= minimalIterationCount) {\n+            if (iterations.getCount() >= minimalIterationCount) {\n                 final double delta = FastMath.abs(s - olds);\n                 final double rLimit =\n                     relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n-                    setResult(s, i);\n+                    setResult(s);\n                     return result;\n                 }\n             }\n             olds = s;\n             oldt = t;\n         }\n-        throw new MaxCountExceededException(maximalIterationCount);\n+\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        super.verifyIterationCount();\n-        // at most 64 bisection refinements\n-        if (maximalIterationCount > 64) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n-                    0, 64);\n-        }\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  */\n public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n \n+    /** Maximal number of iterations for trapezoid. */\n+    public static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;\n+\n     /** Intermediate result. */\n     private double s;\n \n     /**\n-     * Construct an integrator.\n+     * Build a trapezoid integrator with given accuracies and iterations counts.\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #TRAPEZOID_MAX_ITERATIONS_COUNT)\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}\n+     */\n+    public TrapezoidIntegrator(final double relativeAccuracy,\n+                               final double absoluteAccuracy,\n+                               final int minimalIterationCount,\n+                               final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > TRAPEZOID_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                TRAPEZOID_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Build a trapezoid integrator with given iteration counts.\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #TRAPEZOID_MAX_ITERATIONS_COUNT)\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}\n+     */\n+    public TrapezoidIntegrator(final int minimalIterationCount,\n+                               final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > TRAPEZOID_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                TRAPEZOID_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Construct a trapezoid integrator with default settings.\n+     * (max iteration count set to {@link #TRAPEZOID_MAX_ITERATIONS_COUNT})\n      */\n     public TrapezoidIntegrator() {\n-        super(64);\n+        super(DEFAULT_MIN_ITERATIONS_COUNT, TRAPEZOID_MAX_ITERATIONS_COUNT);\n     }\n \n     /**\n      * arbitrary m sections because this configuration can best utilize the\n      * alrealy computed values.</p>\n      *\n-     * @param f the integrand function\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param baseIntegrator integrator holdingintegration parameters\n      * @param n the stage of 1/2 refinement, n = 0 is no refinement\n      * @return the value of n-th stage integral\n-     * @throws MathUserException if an error occurs evaluating the function\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n      */\n-    double stage(final UnivariateRealFunction f,\n-                 final double min, final double max, final int n)\n-        throws MathUserException {\n+    double stage(final UnivariateRealIntegratorImpl baseIntegrator, final int n)\n+        throws TooManyEvaluationsException {\n \n         if (n == 0) {\n-            s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n+            s = 0.5 * (baseIntegrator.max - baseIntegrator.min) *\n+                      (baseIntegrator.computeObjectiveValue(baseIntegrator.min) +\n+                       baseIntegrator.computeObjectiveValue(baseIntegrator.max));\n             return s;\n         } else {\n             final long np = 1L << (n-1);           // number of new points in this stage\n             double sum = 0;\n-            final double spacing = (max - min) / np; // spacing between adjacent new points\n-            double x = min + 0.5 * spacing;    // the first new point\n+            // spacing between adjacent new points\n+            final double spacing = (baseIntegrator.max - baseIntegrator.min) / np;\n+            double x = baseIntegrator.min + 0.5 * spacing;    // the first new point\n             for (long i = 0; i < np; i++) {\n-                sum += f.value(x);\n+                sum += baseIntegrator.computeObjectiveValue(x);\n                 x += spacing;\n             }\n             // add the new sum to previously calculated result\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n-        throws MaxCountExceededException, MathUserException, IllegalArgumentException {\n+    protected double doIntegrate()\n+        throws TooManyEvaluationsException, ConvergenceException {\n \n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n-\n-        double oldt = stage(f, min, max, 0);\n-        for (int i = 1; i <= maximalIterationCount; ++i) {\n-            final double t = stage(f, min, max, i);\n+        double oldt = stage(this, 0);\n+        iterations.incrementCount();\n+        while (true) {\n+            final int i = iterations.getCount();\n+            final double t = stage(this, i);\n             if (i >= minimalIterationCount) {\n                 final double delta = FastMath.abs(t - oldt);\n                 final double rLimit =\n                     relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n-                    setResult(t, i);\n+                    setResult(t);\n                     return result;\n                 }\n             }\n             oldt = t;\n+            iterations.incrementCount();\n         }\n-        throw new MaxCountExceededException(maximalIterationCount);\n+\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        super.verifyIterationCount();\n-        // at most 64 bisection refinements\n-        if (maximalIterationCount > 64) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n-                    0, 64);\n-        }\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n \n /**\n  * Interface for univariate real integration algorithms.\n public interface UnivariateRealIntegrator {\n \n     /**\n-     * Set the upper limit for the number of iterations.\n-     * <p>\n-     * Usually a high iteration count indicates convergence problems. However,\n-     * the \"reasonable value\" varies widely for different algorithms. Users are\n-     * advised to use the default value supplied by the algorithm.</p>\n-     * <p>\n-     * A {@link ConvergenceException} will be thrown if this number\n-     * is exceeded.</p>\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    double getRelativeAccuracy();\n+\n+    /**\n+     * Get the actual absolute accuracy.\n      *\n-     * @param count maximum number of iterations\n+     * @return the accuracy\n      */\n-    void setMaximalIterationCount(int count);\n+    double getAbsoluteAccuracy();\n+\n+    /**\n+     * Get the min limit for the number of iterations.\n+     *\n+     * @return the actual min limit\n+     */\n+    int getMinimalIterationCount();\n \n     /**\n      * Get the upper limit for the number of iterations.\n     int getMaximalIterationCount();\n \n     /**\n-     * Set the absolute accuracy.\n-     * <p>\n-     * The default is usually chosen so that results in the interval\n-     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n-     * expected absolute value of your results is of much smaller magnitude, set\n-     * this to a smaller value.</p>\n-     * <p>\n-     * Algorithms are advised to do a plausibility check with the relative\n-     * accuracy, but clients should not rely on this.</p>\n-     *\n-     * @param accuracy the accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the solver or is otherwise deemed unreasonable.\n-     */\n-    void setAbsoluteAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual absolute accuracy.\n-     *\n-     * @return the accuracy\n-     */\n-    double getAbsoluteAccuracy();\n-\n-    /**\n-     * Set the relative accuracy.\n-     * <p>\n-     * This is used to stop iterations if the absolute accuracy can't be\n-     * achieved due to large values or short mantissa length.</p>\n-     * <p>\n-     * If this should be the primary criterion for convergence rather then a\n-     * safety measure, set the absolute accuracy to a ridiculously small value,\n-     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n-     *\n-     * @param accuracy the relative accuracy.\n-     */\n-    void setRelativeAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     * @return the accuracy\n-     */\n-    double getRelativeAccuracy();\n-\n-    /**\n-     * Set the lower limit for the number of iterations.\n-     * <p>\n-     * Minimal iteration is needed to avoid false early convergence, e.g.\n-     * the sample points happen to be zeroes of the function. Users can\n-     * use the default value or choose one that they see as appropriate.</p>\n-     * <p>\n-     * A <code>ConvergenceException</code> will be thrown if this number\n-     * is not met.</p>\n-     *\n-     * @param count minimum number of iterations\n-     */\n-    void setMinimalIterationCount(int count);\n-\n-    /**\n-     * Get the lower limit for the number of iterations.\n-     *\n-     * @return the actual lower limit\n-     */\n-    int getMinimalIterationCount();\n-\n-    /**\n-     * Reset the lower limit for the number of iterations to the default.\n-     * <p>\n-     * The default value is supplied by the implementation.</p>\n-     *\n-     * @see #setMinimalIterationCount(int)\n-     */\n-    void resetMinimalIterationCount();\n-\n-    /**\n      * Integrate the function in the given interval.\n      *\n+     * @param maxEval Maximum number of evaluations.\n      * @param f the integrand function\n-     * @param min the lower bound for the interval\n+     * @param min the min bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value of integral\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the integrator detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * @throws MathIllegalArgumentException if min > max or the endpoints do not\n      * satisfy the requirements specified by the integrator\n+     * @throws NullArgumentException if {@code f} is {@code null}.\n      */\n-    double integrate(UnivariateRealFunction f, double min, double max)\n-        throws ConvergenceException, MathUserException, IllegalArgumentException;\n+    double integrate(int maxEval, UnivariateRealFunction f, double min, double max)\n+        throws TooManyEvaluationsException, ConvergenceException,\n+               MathIllegalArgumentException, NullArgumentException;\n \n     /**\n      * Get the result of the last run of the integrator.\n      * because no result was yet computed or the last attempt failed\n      */\n     double getResult() throws IllegalStateException;\n+\n+    /**\n+     * Get the number of function evaluations of the last run of the integrator.\n+     * @return number of function evaluations\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    int getEvaluations() throws IllegalStateException;\n+\n+    /**\n+     * Get the number of iterations of the last run of the integrator.\n+     * @return number of iterations\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    int getIterations() throws IllegalStateException;\n+\n }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Provide a default implementation for several generic functions.\n  */\n public abstract class UnivariateRealIntegratorImpl implements UnivariateRealIntegrator {\n \n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;\n+\n+    /** Default relative accuracy. */\n+    public static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;\n+\n+    /** Default minimal iteration count. */\n+    public static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;\n+\n+    /** Default maximal iteration count. */\n+    public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;\n+\n     /** Maximum absolute error. */\n     protected double absoluteAccuracy;\n \n     /** Maximum relative error. */\n     protected double relativeAccuracy;\n \n-    /** Maximum number of iterations. */\n-    protected int maximalIterationCount;\n-\n     /** minimum number of iterations */\n     protected int minimalIterationCount;\n \n-    /** default minimum number of iterations */\n-    protected int defaultMinimalIterationCount;\n-\n-    /** The last iteration count. */\n-    protected int iterationCount;\n+    /** The iteration count. */\n+    protected Incrementor iterations;\n+\n+    /** The functions evaluation count. */\n+    protected Incrementor evaluations;\n+\n+    /** Function to integrate. */\n+    protected UnivariateRealFunction function;\n+\n+    /** Lower bound for the interval. */\n+    protected double min;\n+\n+    /** Upper bound for the interval. */\n+    protected double max;\n \n     /** indicates whether an integral has been computed */\n     protected boolean resultComputed = false;\n     protected double result;\n \n     /**\n-     * Construct an integrator with given iteration count and accuracy.\n-     *\n+     * Construct an integrator with given accuracies and iteration counts.\n+     * <p>\n+     * The meanings of the various parameters are:\n+     * <ul>\n+     *   <li>relative accuracy:\n+     *       this is used to stop iterations if the absolute accuracy can't be\n+     *       achieved due to large values or short mantissa length. If this\n+     *       should be the primary criterion for convergence rather then a\n+     *       safety measure, set the absolute accuracy to a ridiculously small value,\n+     *       like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</li>\n+     *   <li>absolute accuracy:\n+     *       The default is usually chosen so that results in the interval\n+     *       -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n+     *       expected absolute value of your results is of much smaller magnitude, set\n+     *       this to a smaller value.</li>\n+     *   <li>minimum number of iterations:\n+     *       minimal iteration is needed to avoid false early convergence, e.g.\n+     *       the sample points happen to be zeroes of the function. Users can\n+     *       use the default value or choose one that they see as appropriate.</li>\n+     *   <li>maximum number of iterations:\n+     *       usually a high iteration count indicates convergence problems. However,\n+     *       the \"reasonable value\" varies widely for different algorithms. Users are\n+     *       advised to use the default value supplied by the algorithm.</li>\n+     * </ul>\n+     * </p>\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n      * @param maximalIterationCount maximum number of iterations\n-     */\n-    protected UnivariateRealIntegratorImpl(final int maximalIterationCount) {\n-\n-        setMaximalIterationCount(maximalIterationCount);\n-        setAbsoluteAccuracy(1.0e-15);\n-        setRelativeAccuracy(1.0e-6);\n-        setMinimalIterationCount(3);\n-\n-        verifyIterationCount();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaximalIterationCount(final int count) {\n-        maximalIterationCount = count;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaximalIterationCount() {\n-        return maximalIterationCount;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setAbsoluteAccuracy(double accuracy) {\n-        absoluteAccuracy = accuracy;\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     */\n+    protected UnivariateRealIntegratorImpl(final double relativeAccuracy,\n+                                           final double absoluteAccuracy,\n+                                           final int minimalIterationCount,\n+                                           final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+\n+        // accuracy settings\n+        this.relativeAccuracy      = relativeAccuracy;\n+        this.absoluteAccuracy      = absoluteAccuracy;\n+\n+        // iterations count settings\n+        if (minimalIterationCount <= 0) {\n+            throw new NotStrictlyPositiveException(minimalIterationCount);\n+        }\n+        if (maximalIterationCount <= minimalIterationCount) {\n+            throw new NumberIsTooSmallException(maximalIterationCount, minimalIterationCount, false);\n+        }\n+        this.minimalIterationCount = minimalIterationCount;\n+        this.iterations            = new Incrementor();\n+        iterations.setMaximalCount(maximalIterationCount);\n+\n+        // prepare evaluations counter, but do not set it yet\n+        evaluations = new Incrementor();\n+\n+    }\n+\n+    /**\n+     * Construct an integrator with given accuracies.\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     */\n+    protected UnivariateRealIntegratorImpl(final double relativeAccuracy,\n+                                           final double absoluteAccuracy) {\n+        this(relativeAccuracy, absoluteAccuracy,\n+             DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\n+    }\n+\n+    /**\n+     * Construct an integrator with given iteration counts.\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     */\n+    protected UnivariateRealIntegratorImpl(final int minimalIterationCount,\n+                                           final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+        this(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY,\n+             minimalIterationCount, maximalIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public void setRelativeAccuracy(final double accuracy) {\n-        relativeAccuracy = accuracy;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getRelativeAccuracy() {\n-        return relativeAccuracy;\n+    public int getMinimalIterationCount() {\n+        return minimalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaximalIterationCount() {\n+        return iterations.getMaximalCount();\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public int getEvaluations() throws IllegalStateException {\n+        if (resultComputed) {\n+            return evaluations.getCount();\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() throws IllegalStateException {\n+        if (resultComputed) {\n+            return iterations.getCount();\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n+        }\n+    }\n+\n     /**\n      * Convenience function for implementations.\n      *\n      * @param newResult the result to set\n      * @param newCount the iteration count to set\n      */\n-    protected final void setResult(final double newResult, final int newCount) {\n-        this.result         = newResult;\n-        this.iterationCount = newCount;\n-        this.resultComputed = true;\n-    }\n-\n-    /**\n-     * Convenience function for implementations.\n-     */\n-    protected final void clearResult() {\n-        this.iterationCount = 0;\n-        this.resultComputed = false;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMinimalIterationCount(final int count) {\n-        minimalIterationCount = count;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMinimalIterationCount() {\n-        return minimalIterationCount;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void resetMinimalIterationCount() {\n-        minimalIterationCount = defaultMinimalIterationCount;\n-    }\n-\n-    /**\n-     * Verifies that the endpoints specify an interval.\n+    protected final void setResult(final double newResult) {\n+        result         = newResult;\n+        resultComputed = true;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n      *\n-     * @param lower lower endpoint\n-     * @param upper upper endpoint\n-     * @throws IllegalArgumentException if not interval\n-     */\n-    protected void verifyInterval(final double lower, final double upper)\n-        throws IllegalArgumentException {\n-        if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n-                    lower, upper);\n-        }\n-    }\n-\n-    /**\n-     * Verifies that the upper and lower limits of iterations are valid.\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected double computeObjectiveValue(final double point)\n+        throws TooManyEvaluationsException {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /**\n+     * Prepare for computation.\n+     * Subclasses must call this method if they override any of the\n+     * {@code solve} methods.\n      *\n-     * @throws IllegalArgumentException if not valid\n-     */\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        if ((minimalIterationCount <= 0) || (maximalIterationCount <= minimalIterationCount)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n-                    minimalIterationCount, maximalIterationCount);\n-        }\n-    }\n-\n-    /**\n-     * Reset the iterations counter to 0.\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f the integrand function\n+     * @param min the min bound for the interval\n+     * @param upper the upper bound for the interval\n+     * @throws NullArgumentException if {@code f} is {@code null}.\n+     * @throws MathIllegalArgumentException if {@code min >= max}.\n+     */\n+    protected void setup(final int maxEval,\n+                         final UnivariateRealFunction f,\n+                         final double min, final double max)\n+        throws NullArgumentException, MathIllegalArgumentException {\n+\n+        // Checks.\n+        MathUtils.checkNotNull(f);\n+        UnivariateRealSolverUtils.verifyInterval(min, max);\n+\n+        // Reset.\n+        this.min = min;\n+        this.max = max;\n+        function = f;\n+        evaluations.setMaximalCount(maxEval);\n+        evaluations.resetCount();\n+        iterations.resetCount();\n+        resultComputed = false;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final int maxEval, final UnivariateRealFunction f,\n+                            final double min, final double max)\n+        throws TooManyEvaluationsException, ConvergenceException,\n+               MathIllegalArgumentException, NullArgumentException {\n+\n+        // Initialization.\n+        setup(maxEval, f, min, max);\n+\n+        // Perform computation.\n+        return doIntegrate();\n+\n+    }\n+\n+    /**\n+     * Method for implementing actual integration algorithms in derived\n+     * classes.\n      *\n-     * @since 2.2\n-     */\n-    protected void resetIterationsCounter() {\n-        iterationCount = 0;\n-    }\n-\n-    /**\n-     * Increment the iterations counter by 1.\n-     *\n-     * @throws MaxCountExceededException if the maximal number\n-     * of iterations is exceeded.\n-     * @since 2.2\n-     */\n-    protected void incrementIterationsCounter() {\n-        if (++iterationCount > maximalIterationCount) {\n-            throw new MaxCountExceededException(maximalIterationCount);\n-        }\n-    }\n+     * @return the root.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     */\n+    protected abstract double doIntegrate()\n+        throws TooManyEvaluationsException, ConvergenceException;\n \n }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     @Test\n     public void testSinFunction() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator(5, 64);\n-        integrator.setAbsoluteAccuracy(1.0e-10);\n-        integrator.setRelativeAccuracy(1.0e-14);\n-        integrator.setMinimalIterationCount(2);\n-        integrator.setMaximalIterationCount(15);\n+        UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n                              FastMath.abs(expected * integrator.getRelativeAccuracy()));\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n                 FastMath.abs(expected * integrator.getRelativeAccuracy()));\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n     @Test\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);\n+        UnivariateRealIntegrator integrator =\n+                new LegendreGaussIntegrator(3,\n+                                            UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,\n+                                            UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,\n+                                            UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,\n+                                            64);\n         double min, max, expected, result;\n \n         min = 0; max = 1; expected = -1.0/48;\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n         Assert.assertEquals(expected, result, 1.0e-16);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n         Assert.assertEquals(expected, result, 1.0e-16);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n         Assert.assertEquals(expected, result, 1.0e-16);\n     }\n \n         Random random = new Random(86343623467878363l);\n         for (int n = 2; n < 6; ++n) {\n             LegendreGaussIntegrator integrator =\n-                new LegendreGaussIntegrator(n, 64);\n+                new LegendreGaussIntegrator(n,\n+                                            UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,\n+                                            UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,\n+                                            UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,\n+                                            64);\n \n             // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly\n             for (int degree = 0; degree <= 2 * n - 1; ++degree) {\n                         coeff[k] = 2 * random.nextDouble() - 1;\n                     }\n                     PolynomialFunction p = new PolynomialFunction(coeff);\n-                    double result    = integrator.integrate(p, -5.0, 15.0);\n+                    double result    = integrator.integrate(10000, p, -5.0, 15.0);\n                     double reference = exactIntegration(p, -5.0, 15.0);\n                     Assert.assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));\n                 }\n             }\n \n         }\n+    }\n+\n+    @Test\n+    public void testIssue464() throws ConvergenceException {\n+        final double value = 0.2;\n+        UnivariateRealFunction f = new UnivariateRealFunction() {\n+            public double value(double x) {\n+                return (x >= 0 && x <= 5) ? value : 0.0;\n+            }\n+        };\n+        LegendreGaussIntegrator gauss = new LegendreGaussIntegrator(5, 3, 100);\n+\n+        // due to the discontinuity, integration implies *many* calls\n+        double maxX = 0.32462367623786328;\n+        Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7);\n+        Assert.assertTrue(gauss.getEvaluations() > 37000000);\n+        Assert.assertTrue(gauss.getIterations() < 30);\n+\n+        // setting up limits prevents such large number of calls\n+        try {\n+            gauss.integrate(1000, f, -10, maxX);\n+            Assert.fail(\"expected TooManyEvaluationsException\");\n+        } catch (TooManyEvaluationsException tmee) {\n+            // expected\n+            Assert.assertEquals(1000, tmee.getMax());\n+        }\n+\n+        // integrating on the two sides should be simpler\n+        double sum1 = gauss.integrate(1000, f, -10, 0);\n+        int eval1   = gauss.getEvaluations();\n+        double sum2 = gauss.integrate(1000, f, 0, maxX);\n+        int eval2   = gauss.getEvaluations();\n+        Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7);\n+        Assert.assertTrue(eval1 + eval2 < 200);\n+\n     }\n \n     private double exactIntegration(PolynomialFunction p, double a, double b) {\n--- a/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(100, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 50);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(100, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 50);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         min = 0; max = 1; expected = -1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(100, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 10);\n+        Assert.assertTrue(integrator.getIterations()  < 5);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(100, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 10);\n+        Assert.assertTrue(integrator.getIterations()  < 5);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(100, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 10);\n+        Assert.assertTrue(integrator.getIterations()  < 5);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n     @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new RombergIntegrator();\n \n         try {\n             // bad interval\n-            integrator.integrate(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            new RombergIntegrator().integrate(1000, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // bad iteration limits\n-            integrator.setMinimalIterationCount(5);\n-            integrator.setMaximalIterationCount(4);\n-            integrator.integrate(f, -1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n+            new RombergIntegrator(5, 4);\n+            Assert.fail(\"Expecting NumberIsTooSmallException - bad iteration limits\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             // bad iteration limits\n-            integrator.setMinimalIterationCount(10);\n-            integrator.setMaximalIterationCount(50);\n-            integrator.integrate(f, -1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n+            new RombergIntegrator(10, 50);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad iteration limits\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(1000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 100);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(1000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 50);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         min = 0; max = 1; expected = -1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(1000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 150);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(1000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 100);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(1000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 150);\n+        Assert.assertTrue(integrator.getIterations()  < 10);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n     @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n-\n         try {\n             // bad interval\n-            integrator.integrate(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            new SimpsonIntegrator().integrate(1000, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // bad iteration limits\n-            integrator.setMinimalIterationCount(5);\n-            integrator.setMaximalIterationCount(4);\n-            integrator.integrate(f, -1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n+            new SimpsonIntegrator(5, 4);\n+            Assert.fail(\"Expecting NumberIsTooSmallException - bad iteration limits\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             // bad iteration limits\n-            integrator.setMinimalIterationCount(10);\n-            integrator.setMaximalIterationCount(99);\n-            integrator.integrate(f, -1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n+            new SimpsonIntegrator(10, 99);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad iteration limits\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 2500);\n+        Assert.assertTrue(integrator.getIterations()  < 15);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 2500);\n+        Assert.assertTrue(integrator.getIterations()  < 15);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         min = 0; max = 1; expected = -1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 5000);\n+        Assert.assertTrue(integrator.getIterations()  < 15);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 2500);\n+        Assert.assertTrue(integrator.getIterations()  < 15);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(f, min, max);\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < 5000);\n+        Assert.assertTrue(integrator.getIterations()  < 15);\n         Assert.assertEquals(expected, result, tolerance);\n+\n     }\n \n     /**\n     @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n \n         try {\n             // bad interval\n-            integrator.integrate(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            new TrapezoidIntegrator().integrate(1000, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // bad iteration limits\n-            integrator.setMinimalIterationCount(5);\n-            integrator.setMaximalIterationCount(4);\n-            integrator.integrate(f, -1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n+            new TrapezoidIntegrator(5, 4);\n+            Assert.fail(\"Expecting NumberIsTooSmallException - bad iteration limits\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             // bad iteration limits\n-            integrator.setMinimalIterationCount(10);\n-            integrator.setMaximalIterationCount(99);\n-            integrator.integrate(f, -1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n+            new TrapezoidIntegrator(10,99);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad iteration limits\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n     }", "timestamp": 1314138906, "metainfo": ""}