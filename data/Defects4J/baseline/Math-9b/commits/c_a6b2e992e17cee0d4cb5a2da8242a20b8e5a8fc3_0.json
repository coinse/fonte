{"sha": "a6b2e992e17cee0d4cb5a2da8242a20b8e5a8fc3", "log": "MATH-924 Using a diagonal matrix to avoid exhausting memory.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n \n import org.apache.commons.math3.optim.OptimizationData;\n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.NonSquareMatrixException;\n \n /**\n      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n-        weightMatrix = MatrixUtils.createRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+        weightMatrix = new DiagonalMatrix(weight);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n-        final EigenDecomposition dec = new EigenDecomposition(m);\n-        return dec.getSquareRoot();\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n+            final EigenDecomposition dec = new EigenDecomposition(m);\n+            return dec.getSquareRoot();\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java\n         checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false);\n     }\n \n+    @Test\n+    public void testLargeSample() {\n+        Random randomizer = new Random(0x5551480dca5b369bl);\n+        double maxError = 0;\n+        for (int degree = 0; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n+            for (int i = 0; i < 40000; ++i) {\n+                double x = -1.0 + i / 20000.0;\n+                fitter.addObservedPoint(1.0, x,\n+                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n+            }\n+\n+            final double[] init = new double[degree + 1];\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n+\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n+                              (1.0 + FastMath.abs(p.value(x)));\n+                maxError = FastMath.max(maxError, error);\n+                Assert.assertTrue(FastMath.abs(error) < 0.01);\n+            }\n+        }\n+        Assert.assertTrue(maxError > 0.001);\n+    }\n+\n     private void checkUnsolvableProblem(MultivariateVectorOptimizer optimizer,\n                                         boolean solvable) {\n         Random randomizer = new Random(1248788532l);", "timestamp": 1356786977, "metainfo": ""}