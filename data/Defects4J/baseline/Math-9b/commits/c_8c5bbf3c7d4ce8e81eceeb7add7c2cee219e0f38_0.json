{"sha": "8c5bbf3c7d4ce8e81eceeb7add7c2cee219e0f38", "log": "removed overhead of Entry object allocation during OpenIntToDoubleHashMap iteration  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n \n         final RealMatrix out = new SparseRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n-            final OpenIntToDoubleHashMap.Entry entry = iterator.next();\n-            final int row = entry.key() / columnDimension;\n-            final int col = entry.key() - row * columnDimension;\n-            out.setEntry(row, col, getEntry(row, col) + entry.value());\n+            iterator.advance();\n+            final int row = iterator.key() / columnDimension;\n+            final int col = iterator.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) + iterator.value());\n         }\n \n         return out;\n \n         final RealMatrix out = new SparseRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n-            final OpenIntToDoubleHashMap.Entry entry = iterator.next();\n-            final int row = entry.key() / columnDimension;\n-            final int col = entry.key() - row * columnDimension;\n-            out.setEntry(row, col, getEntry(row, col) - entry.value());\n+            iterator.advance();\n+            final int row = iterator.key() / columnDimension;\n+            final int col = iterator.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) - iterator.value());\n         }\n \n         return out;\n--- a/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n         /** Reference modification count. */\n         final int referenceCount;\n \n+        /** Index of curent element. */\n+        private int current;\n+\n         /** Index of next element. */\n-        private int index;\n+        private int next;\n \n         /**\n          * Simple constructor.\n          */\n         private Iterator() {\n+\n+            // preserve the modification count of the map to detect concurrent modifications later\n             referenceCount = count;\n-            index = -1;\n-            goToNext();\n+\n+            // initialize current index\n+            next = -1;\n+            try {\n+                advance();\n+            } catch (NoSuchElementException nsee) {\n+                // ignored\n+            }\n+\n         }\n \n         /**\n          * @return true if there is a next element\n          */\n         public boolean hasNext() {\n-            return index >= 0;\n+            return next >= 0;\n         }\n \n         /**\n-         * Get the next entry.\n-         * @return next entry\n+         * Get the key of current entry.\n+         * @return key of current entry\n          * @exception ConcurrentModificationException if the map is modified during iteration\n          * @exception NoSuchElementException if there is no element left in the map\n          */\n-        public Entry next()\n+        public int key()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n                 throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n                                                                                  null);\n             }\n-            if (index < 0) {\n+            if (current < 0) {\n                 throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n             }\n-            final Entry entry = new Entry(keys[index], values[index]);\n-            goToNext();\n-            return entry;\n+            return keys[current];\n         }\n \n         /**\n-         * Find next index.\n+         * Get the value of current entry.\n+         * @return value of current entry\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n          */\n-        private void goToNext() {\n+        public double value()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n+                                                                                 null);\n+            }\n+            if (current < 0) {\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n+            }\n+            return values[current];\n+        }\n+\n+        /**\n+         * Advance iterator one step further.\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public void advance()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n+                                                                                 null);\n+            }\n+\n+            // advance on step\n+            current = next;\n+\n+            // prepare next step\n             try {\n-                while (states[++index] != FULL) {\n+                while (states[++next] != FULL) {\n                     // nothing to do\n                 }\n             } catch (ArrayIndexOutOfBoundsException e) {\n-                index = -1;\n-            }\n-        }\n-\n-    }\n-\n-    /** Entry class for the map.\n-     * <p>Entry elements are built on the fly only during iteration,\n-     * copying values. So changes in the map are <strong>not</strong>\n-     * reflected on already built entries.</p>\n-     */\n-    public static class Entry {\n-\n-        /** Key. */\n-        private final int key;\n-\n-        /** Value. */\n-        private final double value;\n-\n-        /**\n-         * Simple constructor.\n-         * @param key entry key\n-         * @param value entry value\n-         */\n-        private Entry(final int key, final double value) {\n-            this.key   = key;\n-            this.value = value;\n-        }\n-\n-        /**\n-         * Get the key.\n-         * @return entry key\n-         */\n-        public int key() {\n-            return key;\n-        }\n-\n-        /**\n-         * Get the value.\n-         * @return entry value\n-         */\n-        public double value() {\n-            return value;\n+                next = -2;\n+                if (current < 0) {\n+                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n+                }\n+            }\n+\n         }\n \n     }\n--- a/src/test/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n+++ b/src/test/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n         OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n         for (int i = 0; i < map.size(); ++i) {\n             assertTrue(iterator.hasNext());\n-            OpenIntToDoubleHashMap.Entry entry = iterator.next();\n-            int key = entry.key();\n+            iterator.advance();\n+            int key = iterator.key();\n             assertTrue(map.containsKey(key));\n             assertEquals(javaMap.get(key), map.get(key), 0);\n+            assertEquals(javaMap.get(key), iterator.value(), 0);\n             assertTrue(javaMap.containsKey(key));\n         }\n         assertFalse(iterator.hasNext());\n         try {\n-            iterator.next();\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n         } catch (NoSuchElementException nsee) {\n             // expected\n         }\n         OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n         map.put(3, 3);\n         try {\n-            iterator.next();\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n         } catch (ConcurrentModificationException cme) {\n             // expected\n         }", "timestamp": 1229272318, "metainfo": ""}