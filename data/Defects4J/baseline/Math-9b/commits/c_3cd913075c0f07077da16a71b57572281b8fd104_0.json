{"sha": "3cd913075c0f07077da16a71b57572281b8fd104", "log": "removed the current point from count in multistep integrators updated documentation since now Adams-Bashforth and Adams-Moulton are adaptive stepsize integrators  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n     // org.apache.commons.math.ode.MultistepIntegrator\n-    { \"{0} is supported only for 2 points or more\",\n-      \"la m\\u00e9thode {0} n''est disponible que pour 2 points ou plus\" },\n+    { \"{0} method needs at least one previous point\",\n+      \"la m\\u00e9thode {0} n\\u00e9cessite au moins un point pr\\u00e9c\\u00e9dent\" },\n \n     // org.apache.commons.math.ode.stiff.BDFIntegrator\n     { \"unsupported order {0} for BDF methods, must be between {1} and {2}\",\n--- a/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n     /** Starter integrator. */\n     private FirstOrderIntegrator starter;\n \n-    /** Number of steps of the multistep method (including the one being computed). */\n+    /** Number of steps of the multistep method (excluding the one being computed). */\n     private final int nSteps;\n \n     /** First scaled derivative (h y'). */\n      * some defaults settings.</p>\n      * @param name name of the method\n      * @param nSteps number of steps of the multistep method\n-     * (including the one being computed)\n+     * (excluding the one being computed)\n      * @param order order of the method\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n \n         super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n \n-        if (nSteps <= 1) {\n+        if (nSteps <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} is supported only for 2 points or more\",\n+                  \"{0} method needs at least one previous point\",\n                   name);\n         }\n \n                                                  scalAbsoluteTolerance,\n                                                  scalRelativeTolerance);\n         this.nSteps = nSteps;\n-        transformer = NordsieckTransformer.getInstance(nSteps);\n+        transformer = NordsieckTransformer.getInstance(nSteps + 1);\n \n         exp = -1.0 / order;\n \n      * some defaults settings.</p>\n      * @param name name of the method\n      * @param nSteps number of steps of the multistep method\n-     * (including the one being computed)\n+     * (excluding the one being computed)\n      * @param order order of the method\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n                                                  vecAbsoluteTolerance,\n                                                  vecRelativeTolerance);\n         this.nSteps = nSteps;\n-        transformer = NordsieckTransformer.getInstance(nSteps);\n+        transformer = NordsieckTransformer.getInstance(nSteps + 1);\n \n         exp = -1.0 / order;\n \n             final Class<MultistepIntegrator> cl = MultistepIntegrator.class;\n             final Field f = cl.getDeclaredField(\"transformer\");\n             f.setAccessible(true);\n-            f.set(this, NordsieckTransformer.getInstance(nSteps));\n+            f.set(this, NordsieckTransformer.getInstance(nSteps + 1));\n \n         } catch (NoSuchFieldException nsfe) {\n             IOException ioe = new IOException();\n             final double prev = interpolator.getPreviousTime();\n             final double curr = interpolator.getCurrentTime();\n             stepStart = prev;\n-            stepSize  = (curr - prev) / nSteps;\n+            stepSize  = (curr - prev) / (nSteps + 1);\n \n             // compute the first scaled derivative\n             interpolator.setInterpolatedTime(prev);\n             }\n \n             // compute the high order scaled derivatives\n-            final double[][] multistep = new double[nSteps - 1][];\n-            for (int i = 1; i < nSteps; ++i) {\n+            final double[][] multistep = new double[nSteps][];\n+            for (int i = 1; i <= nSteps; ++i) {\n                 interpolator.setInterpolatedTime(prev + stepSize * i);\n                 final double[] msI = interpolator.getInterpolatedDerivatives().clone();\n                 for (int j = 0; j < n; ++j) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n  * Differential Equations.\n  *\n  * <p>Adams-Bashforth methods (in fact due to Adams alone) are explicit\n- * multistep ODE solvers with fixed stepsize. The value of state vector\n+ * multistep ODE solvers. This implementation is a variation of the classical\n+ * one: it uses adaptive stepsize to implement error control, whereas\n+ * classical implementations are fixed step size. The value of state vector\n  * at step n+1 is a simple combination of the value at step n and of the\n  * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\n  * steps one wants to use for computing the next value, different formulas\n  *   <li>...</li>\n  * </ul>\n  *\n- * <p>A k-steps Adams-Bashforth method is of order k. There is no theoretical limit to the\n- * value of k, but due to an implementation limitation k must be greater than 1.</p>\n+ * <p>A k-steps Adams-Bashforth method is of order k.</p>\n  *\n  * <h3>Implementation details</h3>\n  *\n  *   Taylor series formulas,</li>\n  *   <li>it simplifies step changes that occur when discrete events that truncate\n  *   the step are triggered,</li>\n- *   <li>it allows to extend the methods in order to support adaptive stepsize (not implemented yet).</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\n  * </ul></p>\n  * \n  * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:\n \n     /**\n      * Build an Adams-Bashforth with the given order and step size.\n-     * @param order order of the method (must be greater than 1: due to\n-     * an implementation limitation the order 1 method is not supported)\n+     * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n      * @param maxStep maximal step (must be positive even for backward\n      * @param scalRelativeTolerance allowed relative error\n      * @exception IllegalArgumentException if order is 1 or less\n      */\n-    public AdamsBashforthIntegrator(final int order,\n+    public AdamsBashforthIntegrator(final int nSteps,\n                                     final double minStep, final double maxStep,\n                                     final double scalAbsoluteTolerance,\n                                     final double scalRelativeTolerance)\n         throws IllegalArgumentException {\n-        super(\"Adams-Bashforth\", order, order, minStep, maxStep,\n+        super(\"Adams-Bashforth\", nSteps, nSteps + 1, minStep, maxStep,\n               scalAbsoluteTolerance, scalRelativeTolerance);\n     }\n \n     /**\n      * Build an Adams-Bashforth with the given order and step size.\n-     * @param order order of the method (must be greater than 1: due to\n-     * an implementation limitation the order 1 method is not supported)\n+     * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n      * @param maxStep maximal step (must be positive even for backward\n      * @param vecRelativeTolerance allowed relative error\n      * @exception IllegalArgumentException if order is 1 or less\n      */\n-    public AdamsBashforthIntegrator(final int order,\n+    public AdamsBashforthIntegrator(final int nSteps,\n                                     final double minStep, final double maxStep,\n                                     final double[] vecAbsoluteTolerance,\n                                     final double[] vecRelativeTolerance)\n         throws IllegalArgumentException {\n-        super(\"Adams-Bashforth\", order, order, minStep, maxStep,\n+        super(\"Adams-Bashforth\", nSteps, nSteps + 1, minStep, maxStep,\n               vecAbsoluteTolerance, vecRelativeTolerance);\n     }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n  * Differential Equations.\n  *\n  * <p>Adams-Moulton methods (in fact due to Adams alone) are implicit\n- * multistep ODE solvers with fixed stepsize. The value of state vector\n+ * multistep ODE solvers. This implementation is a variation of the classical\n+ * one: it uses adaptive stepsize to implement error control, whereas\n+ * classical implementations are fixed step size. The value of state vector\n  * at step n+1 is a simple combination of the value at step n and of the\n  * derivatives at steps n+1, n, n-1 ... Since y'<sub>n+1</sub> is needed to\n- * compute y<sub>n+1</sub>, another method must be used to compute a first\n+ * compute y<sub>n+1</sub>,another method must be used to compute a first\n  * estimate of y<sub>n+1</sub>, then compute y'<sub>n+1</sub>, then compute\n  * a final estimate of y<sub>n+1</sub> using the following formulas. Depending\n  * on the number k of previous steps one wants to use for computing the next\n  *   <li>...</li>\n  * </ul>\n  *\n- * <p>A k-steps Adams-Moulton method is of order k+1. There is no theoretical limit to the\n- * value of k, but due to an implementation limitation k must be greater than 1.</p>\n+ * <p>A k-steps Adams-Moulton method is of order k+1.</p>\n  *\n  * <h3>Implementation details</h3>\n  *\n  *   Taylor series formulas,</li>\n  *   <li>it simplifies step changes that occur when discrete events that truncate\n  *   the step are triggered,</li>\n- *   <li>it allows to extend the methods in order to support adaptive stepsize (not implemented yet).</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\n  * </ul></p>\n  * \n  * <p>The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step\n public class AdamsMoultonIntegrator extends MultistepIntegrator {\n \n     /**\n-     * Build an Adams-Moulton integrator with the given order and step size.\n-     * @param order order of the method (must be greater than 1: due to\n-     * an implementation limitation the order 1 method is not supported)\n+     * Build an Adams-Moulton integrator with the given order and error control parameters.\n+     * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n      * @param maxStep maximal step (must be positive even for backward\n      * @param scalRelativeTolerance allowed relative error\n      * @exception IllegalArgumentException if order is 1 or less\n      */\n-    public AdamsMoultonIntegrator(final int order,\n+    public AdamsMoultonIntegrator(final int nSteps,\n                                   final double minStep, final double maxStep,\n                                   final double scalAbsoluteTolerance,\n                                   final double scalRelativeTolerance)\n         throws IllegalArgumentException {\n-        super(\"Adams-Moulton\", order, order, minStep, maxStep,\n+        super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n               scalAbsoluteTolerance, scalRelativeTolerance);\n     }\n \n     /**\n      * Build an Adams-Moulton integrator with the given order and step size.\n-     * @param order order of the method (must be greater than 1: due to\n-     * an implementation limitation the order 1 method is not supported)\n+     * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n      * @param maxStep maximal step (must be positive even for backward\n      * @param vecRelativeTolerance allowed relative error\n      * @exception IllegalArgumentException if order is 1 or less\n      */\n-    public AdamsMoultonIntegrator(final int order,\n+    public AdamsMoultonIntegrator(final int nSteps,\n                                   final double minStep, final double maxStep,\n                                   final double[] vecAbsoluteTolerance,\n                                   final double[] vecRelativeTolerance)\n         throws IllegalArgumentException {\n-        super(\"Adams-Moulton\", order, order, minStep, maxStep,\n+        super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n               vecAbsoluteTolerance, vecRelativeTolerance);\n     }\n       \n--- a/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n     public void dimensionCheck() throws DerivativeException, IntegratorException {\n         TestProblem1 pb = new TestProblem1();\n         FirstOrderIntegrator integ =\n-            new AdamsBashforthIntegrator(3, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+            new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n         integ.integrate(pb,\n                         0.0, new double[pb.getDimension()+10],\n                         1.0, new double[pb.getDimension()+10]);\n           double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n           double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n \n-          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, minStep, maxStep,\n+          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,\n                                                                     vecAbsoluteTolerance,\n                                                                     vecRelativeTolerance);\n           TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             double scalAbsoluteTolerance = Math.pow(10.0, i);\n             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n-            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, minStep, maxStep,\n+            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,\n                                                                       scalAbsoluteTolerance,\n                                                                       scalRelativeTolerance);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n \n-        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, 0, range, 1.0e-12, 1.0e-12);\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(2, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n         integ.setMaxEvaluations(650);\n         TestProblem5 pb = new TestProblem5();\n         double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, 0, range, 1.0e-12, 1.0e-12);\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n         TestProblem6 pb = new TestProblem6();\n         double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        for (int order = 2; order < 9; ++order) {\n+        for (int nSteps = 1; nSteps < 8; ++nSteps) {\n             AdamsBashforthIntegrator integ =\n-                new AdamsBashforthIntegrator(order, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);\n+                new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n-            if (order < 5) {\n+            if (nSteps < 4) {\n                 assertTrue(integ.getEvaluations() > 160);\n             } else {\n                 assertTrue(integ.getEvaluations() < 70);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n     public void dimensionCheck() throws DerivativeException, IntegratorException {\n         TestProblem1 pb = new TestProblem1();\n         FirstOrderIntegrator integ =\n-            new AdamsMoultonIntegrator(3, 0.0, 1.0, 1.0e-10, 1.0e-10);\n+            new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n         integ.integrate(pb,\n                         0.0, new double[pb.getDimension()+10],\n                         1.0, new double[pb.getDimension()+10]);\n           double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n           double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n \n-          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, minStep, maxStep,\n-                                                                    vecAbsoluteTolerance,\n-                                                                    vecRelativeTolerance);\n+          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,\n+                                                                  vecAbsoluteTolerance,\n+                                                                  vecRelativeTolerance);\n           TestProblemHandler handler = new TestProblemHandler(pb, integ);\n           integ.addStepHandler(handler);\n           integ.integrate(pb,\n             double scalAbsoluteTolerance = Math.pow(10.0, i);\n             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n-            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, minStep, maxStep,\n-                                                                      scalAbsoluteTolerance,\n-                                                                      scalRelativeTolerance);\n+            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb,\n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n \n-        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(3, 0, range, 1.0e-12, 1.0e-12);\n+        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n         integ.setMaxEvaluations(650);\n         TestProblem5 pb = new TestProblem5();\n         double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, 0, range, 1.0e-12, 1.0e-12);\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n         TestProblem6 pb = new TestProblem6();\n         double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        for (int order = 2; order < 8; ++order) {\n+        for (int nSteps = 1; nSteps < 7; ++nSteps) {\n             AdamsMoultonIntegrator integ =\n-                new AdamsMoultonIntegrator(order, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n+                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n-            if (order < 5) {\n+            if (nSteps < 4) {\n                 assertTrue(integ.getEvaluations() > 150);\n             } else {\n                 assertTrue(integ.getEvaluations() < 90);", "timestamp": 1245603663, "metainfo": ""}