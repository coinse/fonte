{"sha": "be09075a6d2a252b68c40e5c308449a8df08bc57", "log": "Code cleanup: moved all computations to the constructor, allowing to make the class immutable.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n      * number of measurements.</p>\n      */\n     public static class ParameterGuesser {\n-        /** Sampled observations. */\n-        private final WeightedObservedPoint[] observations;\n         /** Amplitude. */\n-        private double a;\n+        private final double a;\n         /** Angular frequency. */\n-        private double omega;\n+        private final double omega;\n         /** Phase. */\n-        private double phi;\n+        private final double phi;\n \n         /**\n          * Simple constructor.\n-         * @param observations sampled observations\n-         * @throws NumberIsTooSmallException if the sample is too short or if\n-         * the first guess cannot be computed.\n+         *\n+         * @param observations Sampled observations.\n+         * @throws NumberIsTooSmallException if the sample is too short.\n+         * @throws ZeroException if the abscissa range is zero.\n+         * @throws MathIllegalStateException when the guessing procedure cannot\n+         * produce sensible results.\n          */\n         public ParameterGuesser(WeightedObservedPoint[] observations) {\n             if (observations.length < 4) {\n                                                     observations.length, 4, true);\n             }\n \n-            this.observations = observations.clone();\n+            final WeightedObservedPoint[] sorted = sortObservations(observations);\n+\n+            final double aOmega[] = guessAOmega(sorted);\n+            a = aOmega[0];\n+            omega = aOmega[1];\n+\n+            phi = guessPhi(sorted);\n         }\n \n         /**\n          * </ul>\n          */\n         public double[] guess() {\n-            sortObservations();\n-            guessAOmega();\n-            guessPhi();\n             return new double[] { a, omega, phi };\n         }\n \n         /**\n          * Sort the observations with respect to the abscissa.\n-         */\n-        private void sortObservations() {\n+         *\n+         * @param unsorted Input observations.\n+         * @return the input observations, sorted.\n+         */\n+        private WeightedObservedPoint[] sortObservations(WeightedObservedPoint[] unsorted) {\n+            final WeightedObservedPoint[] observations = unsorted.clone();\n+\n             // Since the samples are almost always already sorted, this\n             // method is implemented as an insertion sort that reorders the\n             // elements in place. Insertion sort is very efficient in this case.\n                     curr = observations[j];\n                 }\n             }\n+\n+            return observations;\n         }\n \n         /**\n          * This method assumes that the {@link #sortObservations()} method\n          * has been called previously.\n          *\n+         * @param observations Observations, sorted w.r.t. abscissa.\n          * @throws ZeroException if the abscissa range is zero.\n          * @throws MathIllegalStateException when the guessing procedure cannot\n          * produce sensible results.\n-         */\n-        private void guessAOmega() {\n+         * @return the guessed amplitude (at index 0) and circular frequency\n+         * (at index 1).\n+         */\n+        private double[] guessAOmega(WeightedObservedPoint[] observations) {\n+            final double[] aOmega = new double[2];\n+\n             // initialize the sums for the linear model between the two integrals\n             double sx2 = 0;\n             double sy2 = 0;\n                 if (xRange == 0) {\n                     throw new ZeroException();\n                 }\n-                omega = 2 * Math.PI / xRange;\n+                aOmega[1] = 2 * Math.PI / xRange;\n \n                 double yMin = Double.POSITIVE_INFINITY;\n                 double yMax = Double.NEGATIVE_INFINITY;\n                         yMax = y;\n                     }\n                 }\n-                a = 0.5 * (yMax - yMin);\n+                aOmega[0] = 0.5 * (yMax - yMin);\n             } else {\n                 if (c2 == 0) {\n                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n                     throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n                 }\n \n-                a = FastMath.sqrt(c1 / c2);\n-                omega = FastMath.sqrt(c2 / c3);\n-            }\n+                aOmega[0] = FastMath.sqrt(c1 / c2);\n+                aOmega[1] = FastMath.sqrt(c2 / c3);\n+            }\n+\n+            return aOmega;\n         }\n \n         /**\n          * Estimate a first guess of the phase.\n-         */\n-        private void guessPhi() {\n+         *\n+         * @param observations Observations, sorted w.r.t. abscissa.\n+         * @return the guessed phase.\n+         */\n+        private double guessPhi(WeightedObservedPoint[] observations) {\n             // initialize the means\n             double fcMean = 0;\n             double fsMean = 0;\n                 fsMean += omega * currentY * sine + currentYPrime * cosine;\n             }\n \n-            phi = FastMath.atan2(-fsMean, fcMean);\n+            return FastMath.atan2(-fsMean, fcMean);\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/optimization/fitting/HarmonicFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/HarmonicFitterTest.java\n             points[i] = new WeightedObservedPoint(1, i, y[i]);\n         }\n \n-        final HarmonicFitter.ParameterGuesser guesser\n-            = new HarmonicFitter.ParameterGuesser(points);\n-\n         // The guesser fails because the function is far from an harmonic\n         // function: It is a triangular periodic function with amplitude 3\n         // and period 12, and all sample points are taken at integer abscissae\n         // so function values all belong to the integer subset {-3, -2, -1, 0,\n         // 1, 2, 3}.\n-        guesser.guess();\n+        final HarmonicFitter.ParameterGuesser guesser\n+            = new HarmonicFitter.ParameterGuesser(points);\n     }\n }", "timestamp": 1345216199, "metainfo": ""}