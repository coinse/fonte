{"sha": "c657a840cc1ce8f80ecbdb761851c356a82cf41b", "log": "Fix checkstyle warnings, added missing javadoc.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n     /** Indirection arrays for function composition. */\n     private final int[][][] compIndirection;\n \n-    /** Get the compiler for number of free parameters and order.\n-     * @param parameters number of free parameters\n-     * @param order derivation order\n-     * @return cached rules set\n-     */\n-    public static DSCompiler getCompiler(int parameters, int order) {\n-\n-        // get the cached compilers\n-        final DSCompiler[][] cache = compilers.get();\n-        if (cache != null && cache.length > parameters && cache[parameters].length > order) {\n-            if (cache[parameters][order] != null) {\n-                // the compiler has already been created\n-                return cache[parameters][order];\n-            }\n-        }\n-\n-        // we need to create more compilers\n-        final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n-        final int maxOrder      = FastMath.max(order,     cache == null ? 0 : cache[0].length);\n-        final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n-\n-        if (cache != null) {\n-            // preserve the already created compilers\n-            for (int i = 0; i < cache.length; ++i) {\n-                System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n-            }\n-        }\n-\n-        // create the array in increasing diagonal order\n-        for (int diag = 0; diag <= parameters + order; ++diag) {\n-            for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n-                final int p = diag - o;\n-                if (newCache[p][o] == null) {\n-                    final DSCompiler valueCompiler      = (p == 0) ? null : newCache[p - 1][o];\n-                    final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n-                    newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n-                }\n-            }\n-        }\n-\n-        // atomically reset the cached compilers array\n-        compilers.compareAndSet(cache, newCache);\n-\n-        return newCache[parameters][order];\n-\n-    }\n-\n     /** Private constructor, reserved for the factory method {@link #getCompiler(int, int)}.\n      * @param parameters number of free parameters\n      * @param order derivation order\n                                               valueCompiler, derivativeCompiler,\n                                               sizes, derivativesIndirection, lowerIndirection);\n \n+    }\n+\n+    /** Get the compiler for number of free parameters and order.\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @return cached rules set\n+     */\n+    public static DSCompiler getCompiler(int parameters, int order) {\n+\n+        // get the cached compilers\n+        final DSCompiler[][] cache = compilers.get();\n+        if (cache != null && cache.length > parameters && cache[parameters].length > order) {\n+            if (cache[parameters][order] != null) {\n+                // the compiler has already been created\n+                return cache[parameters][order];\n+            }\n+        }\n+\n+        // we need to create more compilers\n+        final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n+        final int maxOrder      = FastMath.max(order,     cache == null ? 0 : cache[0].length);\n+        final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n+\n+        if (cache != null) {\n+            // preserve the already created compilers\n+            for (int i = 0; i < cache.length; ++i) {\n+                System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n+            }\n+        }\n+\n+        // create the array in increasing diagonal order\n+        for (int diag = 0; diag <= parameters + order; ++diag) {\n+            for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n+                final int p = diag - o;\n+                if (newCache[p][o] == null) {\n+                    final DSCompiler valueCompiler      = (p == 0) ? null : newCache[p - 1][o];\n+                    final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n+                    newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n+                }\n+            }\n+        }\n+\n+        // atomically reset the cached compilers array\n+        compilers.compareAndSet(cache, newCache);\n+\n+        return newCache[parameters][order];\n \n     }\n \n      *   <li>if there is only 1 {@link #getFreeParameters() free parameter}, then the\n      *   derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp\n      *   at index 1, d<sup>2</sup>f/dp<sup>2</sup> at index 2 ...\n-     *   d<sup>k</sup>f/dp<sup>k</sup> at index k),</li> \n+     *   d<sup>k</sup>f/dp<sup>k</sup> at index k),</li>\n      *   <li>if the {@link #getOrder() derivation order} is 1, then the derivatives\n      *   are sorted in incresing free parameter order (i.e. f at index 0, df/dx<sub>1</sub>\n      *   at index 1, df/dx<sub>2</sub> at index 2 ... df/dx<sub>k</sub> at index k),</li>\n      * @param operand array holding the operand\n      * @param operandOffset offset of the operand in its array\n      * @param result array where result must be stored (for\n-     * shifted logarithm the result array <em>cannot</em> be the input\n-     * array)\n+     * shifted logarithm the result array <em>cannot</em> be the input array)\n+     * @param resultOffset offset of the result in its array\n      */\n     public void log1p(final double[] operand, final int operandOffset,\n                       final double[] result, final int resultOffset) {\n      * @param operand array holding the operand\n      * @param operandOffset offset of the operand in its array\n      * @param result array where result must be stored (for\n-     * base 10 logarithm the result array <em>cannot</em> be the input\n-     * array)\n+     * base 10 logarithm the result array <em>cannot</em> be the input array)\n+     * @param resultOffset offset of the result in its array\n      */\n     public void log10(final double[] operand, final int operandOffset,\n                       final double[] result, final int resultOffset) {\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.java\n             public double value(final double x) throws MathIllegalArgumentException {\n                 return function.value(x);\n             }\n-            \n+\n             /** {@inheritDoc} */\n             public DerivativeStructure value(final DerivativeStructure t)\n                 throws MathIllegalArgumentException {\n             public double[]value(final double x) throws MathIllegalArgumentException {\n                 return function.value(x);\n             }\n-            \n+\n             /** {@inheritDoc} */\n             public DerivativeStructure[] value(final DerivativeStructure t)\n                 throws MathIllegalArgumentException {\n             public double[][]  value(final double x) throws MathIllegalArgumentException {\n                 return function.value(x);\n             }\n-            \n+\n             /** {@inheritDoc} */\n             public DerivativeStructure[][]  value(final DerivativeStructure t)\n                 throws MathIllegalArgumentException {", "timestamp": 1350837150, "metainfo": ""}