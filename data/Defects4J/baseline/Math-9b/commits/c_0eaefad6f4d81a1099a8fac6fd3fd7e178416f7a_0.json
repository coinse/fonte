{"sha": "0eaefad6f4d81a1099a8fac6fd3fd7e178416f7a", "log": "Added RealDistribution methods to EmpiricalDistribution.  JIRA: MATH-672.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/random/EmpiricalDistribution.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n-import java.io.Serializable;\n import java.net.URL;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math3.distribution.AbstractRealDistribution;\n+import org.apache.commons.math3.distribution.NormalDistribution;\n+import org.apache.commons.math3.distribution.RealDistribution;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math3.util.MathUtils;\n \n /**\n- * Represents an <a href=\"http://http://en.wikipedia.org/wiki/Empirical_distribution_function\">\n+ * <p>Represents an <a href=\"http://http://en.wikipedia.org/wiki/Empirical_distribution_function\">\n  * empirical probability distribution</a> -- a probability distribution derived\n  * from observed data without making any assumptions about the functional form\n- * of the population distribution that the data come from.<p>\n- * An <code>EmpiricalDistribution</code> maintains data structures, called\n+ * of the population distribution that the data come from.</p>\n+ *\n+ * <p>An <code>EmpiricalDistribution</code> maintains data structures, called\n  * <i>distribution digests</i>, that describe empirical distributions and\n  * support the following operations: <ul>\n  * <li>loading the distribution from a file of observed data values</li>\n  * frequency histograms representing the input data or to generate random values\n  * \"like\" those in the input file -- i.e., the values generated will follow the\n  * distribution of the values in the file.</p>\n+ *\n  * <p>The implementation uses what amounts to the\n  * <a href=\"http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html\">\n  * Variable Kernel Method</a> with Gaussian smoothing:<p>\n  * <li>Generate a uniformly distributed value in (0,1) </li>\n  * <li>Select the subinterval to which the value belongs.\n  * <li>Generate a random Gaussian value with mean = mean of the associated\n- *     bin and std dev = std dev of associated bin.</li></ol></p><p>\n+ *     bin and std dev = std dev of associated bin.</li></ol></p>\n+ *\n+ * <p>EmpiricalDistribution implements the {@link RealDistribution} interface\n+ * as follows.  Given x within the range of values in the dataset, let B\n+ * be the bin containing x and let K be the within-bin kernel for B.  Let P(B-)\n+ * be the sum of the probabilities of the bins below B and let K(B) be the\n+ * mass of B under K (i.e., the integral of the kernel density over B).  Then\n+ * set P(X < x) = P(B-) + K(x) / K(B) where K(x) is the kernel distribution\n+ * evaluated at x. This results in a cdf that matches the grouped frequency\n+ * distribution at the bin endpoints and interpolates within bins using\n+ * within-bin kernels.</p>\n+ *\n  *<strong>USAGE NOTES:</strong><ul>\n  *<li>The <code>binCount</code> is set by default to 1000.  A good rule of thumb\n  *    is to set the bin count to approximately the length of the input file divided\n  *\n  * @version $Id$\n  */\n-public class EmpiricalDistribution implements Serializable {\n+public class EmpiricalDistribution extends AbstractRealDistribution {\n \n     /** Default bin count */\n     public static final int DEFAULT_BIN_COUNT = 1000;\n      *\n      * @param in the input data array\n      * @exception NullArgumentException if in is null\n-     * @throws MathIllegalStateException if an IOException occurs\n-     */\n-    public void load(double[] in) throws NullArgumentException, MathIllegalStateException {\n+     */\n+    public void load(double[] in) throws NullArgumentException {\n         DataAdapter da = new ArrayDataAdapter(in);\n         try {\n             da.computeStats();\n             // new adapter for the second pass\n             fillBinStats(new ArrayDataAdapter(in));\n-        } catch (IOException e) {\n-            throw new MathIllegalStateException(e, LocalizedFormats.SIMPLE_MESSAGE, e.getLocalizedMessage());\n+        } catch (IOException ex) {\n+            // Can't happen\n+            throw new MathInternalError();\n         }\n         loaded = true;\n \n      * <p>The input file <i>must</i> be an ASCII text file containing one\n      * valid numeric entry per line.</p>\n      *\n-     * @param url  url of the input file\n+     * @param url url of the input file\n      *\n      * @throws IOException if an IO error occurs\n      * @throws NullArgumentException if url is null\n      */\n     private int findBin(double value) {\n         return FastMath.min(\n-                FastMath.max((int) FastMath.ceil((value- min) / delta) - 1, 0),\n+                FastMath.max((int) FastMath.ceil((value - min) / delta) - 1, 0),\n                 binCount - 1);\n-        }\n+    }\n \n     /**\n      * Generates a random value from this distribution.\n      */\n     public double[] getUpperBounds() {\n         double[] binUpperBounds = new double[binCount];\n-        binUpperBounds[0] = min + delta;\n-        for (int i = 1; i < binCount - 1; i++) {\n-            binUpperBounds[i] = binUpperBounds[i-1] + delta;\n+        for (int i = 0; i < binCount - 1; i++) {\n+            binUpperBounds[i] = min + delta * (i + 1);\n         }\n         binUpperBounds[binCount - 1] = max;\n         return binUpperBounds;\n     public void reSeed(long seed) {\n         randomData.reSeed(seed);\n     }\n+\n+    // Distribution methods ---------------------------\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public double probability(double x) {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Returns the kernel density normalized so that its integral over each bin\n+     * equals the bin mass.</p>\n+     *\n+     * <p>Algorithm description: <ol>\n+     * <li>Find the bin B that x belongs to.</li>\n+     * <li>Compute K(B) = the mass of B with respect to the within-bin kernel (i.e., the\n+     * integral of the kernel density over B).</li>\n+     * <li>Return k(x) * P(B) / K(B), where k is the within-bin kernel density\n+     * and P(B) is the mass of B.</li></ol></p>\n+     * @since 3.1\n+     */\n+    public double density(double x) {\n+        if (x < min || x > max) {\n+            return 0d;\n+        }\n+        final int binIndex = findBin(x);\n+        final RealDistribution kernel = getKernel(binStats.get(binIndex));\n+        return kernel.density(x) * pB(binIndex) / kB(binIndex);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Algorithm description:<ol>\n+     * <li>Find the bin B that x belongs to.</li>\n+     * <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.</li>\n+     * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\n+     * and K(B-) = the kernel distribution evaluated at the lower endpoint of B</li>\n+     * <li>Return P(B-) + P(B) * [K(x) - K(B-)] / K(B) where\n+     * K(x) is the within-bin kernel distribution function evaluated at x.</li></ol></p>\n+     *\n+     * @since 3.1\n+     */\n+    public double cumulativeProbability(double x) {\n+        if (x < min) {\n+            return 0d;\n+        } else if (x >= max) {\n+            return 1d;\n+        }\n+        final int binIndex = findBin(x);\n+        final double pBminus = pBminus(binIndex);\n+        final double pB = pB(binIndex);\n+        final double[] binBounds = getUpperBounds();\n+        final double kB = kB(binIndex);\n+        final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\n+        final RealDistribution kernel = k(x);\n+        final double withinBinCum =\n+            (kernel.cumulativeProbability(x) -  kernel.cumulativeProbability(lower)) / kB;\n+        return pBminus + pB * withinBinCum;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Algorithm description:<ol>\n+     * <li>Find the smallest i such that the sum of the masses of the bins\n+     *  through i is at least p.</li>\n+     * <li>\n+     *   Let K be the within-bin kernel distribution for bin i.</br>\n+     *   Let K(B) be the mass of B under K. <br/>\n+     *   Let K(B-) be K evaluated at the lower endpoint of B (the combined\n+     *   mass of the bins below B under K).<br/>\n+     *   Let P(B) be the probability of bin i.<br/>\n+     *   Let P(B-) be the sum of the bin masses below bin i. <br/>\n+     *   Let pCrit = p - P(B-)<br/>\n+     * <li>Return the inverse of K evaluated at <br/>\n+     *    K(B-) + pCrit * K(B) / P(B) </li>\n+     *  </ol></p>\n+     *\n+     * @since 3.1\n+     */\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        if (p == 0.0) {\n+            return getSupportLowerBound();\n+        }\n+\n+        if (p == 1.0) {\n+            return getSupportUpperBound();\n+        }\n+\n+        int i = 0;\n+        while (cumBinP(i) < p) {\n+            i++;\n+        }\n+\n+        final RealDistribution kernel = getKernel(binStats.get(i));\n+        final double kB = kB(i);\n+        final double[] binBounds = getUpperBounds();\n+        final double lower = i == 0 ? min : binBounds[i - 1];\n+        final double kBminus = kernel.cumulativeProbability(lower);\n+        final double pB = pB(i);\n+        final double pBminus = pBminus(i);\n+        final double pCrit = p - pBminus;\n+        if (pCrit <= 0) {\n+            return lower;\n+        }\n+        return kernel.inverseCumulativeProbability(kBminus + pCrit * kB / pB);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public double getNumericalMean() {\n+       return sampleStats.getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public double getNumericalVariance() {\n+        return sampleStats.getVariance();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public double getSupportLowerBound() {\n+       return min;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public double getSupportUpperBound() {\n+        return max;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    @Override\n+    public double sample() {\n+        return getNextValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n+    @Override\n+    public void reseedRandomGenerator(long seed) {\n+        randomData.reSeed(seed);\n+    }\n+\n+    /**\n+     * The probability of bin i.\n+     *\n+     * @param i the index of the bin\n+     * @return the probability that selection begins in bin i\n+     */\n+    private double pB(int i) {\n+        return i == 0 ? upperBounds[0] :\n+            upperBounds[i] - upperBounds[i - 1];\n+    }\n+\n+    /**\n+     * The combined probability of the bins up to but not including bin i.\n+     *\n+     * @param i the index of the bin\n+     * @return the probability that selection begins in a bin below bin i.\n+     */\n+    private double pBminus(int i) {\n+        return i == 0 ? 0 : upperBounds[i - 1];\n+    }\n+\n+    /**\n+     * Mass of bin i under the within-bin kernel of the bin.\n+     *\n+     * @param i index of the bin\n+     * @return the difference in the within-bin kernel cdf between the\n+     * upper and lower endpoints of bin i\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    private double kB(int i) {\n+        final double[] binBounds = getUpperBounds();\n+        final RealDistribution kernel = getKernel(binStats.get(i));\n+        return i == 0 ? kernel.cumulativeProbability(min, binBounds[0]) :\n+            kernel.cumulativeProbability(binBounds[i - 1], binBounds[i]);\n+    }\n+\n+    /**\n+     * The within-bin kernel of the bin that x belongs to.\n+     *\n+     * @param x the value to locate within a bin\n+     * @return the within-bin kernel of the bin containing x\n+     */\n+    private RealDistribution k(double x) {\n+        final int binIndex = findBin(x);\n+        return getKernel(binStats.get(binIndex));\n+    }\n+\n+    /**\n+     * The combined probability of the bins up to and including binIndex.\n+     *\n+     * @param binIndex maximum bin index\n+     * @return sum of the probabilities of bins through binIndex\n+     */\n+    private double cumBinP(int binIndex) {\n+        return upperBounds[binIndex];\n+    }\n+\n+    /**\n+     * The within-bin smoothing kernel.\n+     *\n+     * @param bStats summary statistics for the bin\n+     * @return within-bin kernel parameterized by bStats\n+     */\n+    private RealDistribution getKernel(SummaryStatistics bStats) {\n+        // For now, hard-code Gaussian (only kernel supported)\n+        return new NormalDistribution(\n+                bStats.getMean(), bStats.getStandardDeviation());\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.java\n import java.util.ArrayList;\n \n import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator;\n+import org.apache.commons.math3.analysis.integration.IterativeLegendreGaussIntegrator;\n+import org.apache.commons.math3.distribution.NormalDistribution;\n+import org.apache.commons.math3.distribution.RealDistribution;\n+import org.apache.commons.math3.distribution.RealDistributionAbstractTest;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.junit.Assert;\n  * @version $Id$\n  */\n \n-public final class EmpiricalDistributionTest {\n+public final class EmpiricalDistributionTest extends RealDistributionAbstractTest {\n \n     protected EmpiricalDistribution empiricalDistribution = null;\n     protected EmpiricalDistribution empiricalDistribution2 = null;\n     protected File file = null;\n     protected URL url = null;\n     protected double[] dataArray = null;\n+    protected final int n = 10000;\n \n     @Before\n-    public void setUp() throws IOException {\n+    public void setUp() {\n+        super.setUp();\n         empiricalDistribution = new EmpiricalDistribution(100);\n         url = getClass().getResource(\"testData.txt\");\n-\n-        empiricalDistribution2 = new EmpiricalDistribution(100);\n-        BufferedReader in =\n+        final ArrayList<Double> list = new ArrayList<Double>();\n+        try {\n+            empiricalDistribution2 = new EmpiricalDistribution(100);\n+            BufferedReader in =\n                 new BufferedReader(new InputStreamReader(\n                         url.openStream()));\n-        String str = null;\n-        ArrayList<Double> list = new ArrayList<Double>();\n-        while ((str = in.readLine()) != null) {\n-            list.add(Double.valueOf(str));\n-        }\n-        in.close();\n-        in = null;\n+            String str = null;\n+            while ((str = in.readLine()) != null) {\n+                list.add(Double.valueOf(str));\n+            }\n+            in.close();\n+            in = null;\n+        } catch (IOException ex) {\n+            Assert.fail(\"IOException \" + ex);\n+        }\n \n         dataArray = new double[list.size()];\n         int i = 0;\n         Assert.assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n         Assert.assertEquals(\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), tolerance);\n     }\n+   \n+    //  Setup for distribution tests\n+    \n+    @Override\n+    public RealDistribution makeDistribution() {\n+        // Create a uniform distribution on [0, 10,000]\n+        final double[] sourceData = new double[n + 1];\n+        for (int i = 0; i < n + 1; i++) {\n+            sourceData[i] = i;\n+        }\n+        EmpiricalDistribution dist = new EmpiricalDistribution();\n+        dist.load(sourceData);\n+        return dist;\n+    }\n+    \n+    /** Uniform bin mass = 10/10001 == mass of all but the first bin */\n+    private final double binMass = 10d / (double) (n + 1);\n+    \n+    /** Mass of first bin = 11/10001 */\n+    private final double firstBinMass = 11d / (double) (n + 1);\n+\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+       final double[] testPoints = new double[] {9, 10, 15, 1000, 5004, 9999};\n+       return testPoints;\n+    }\n+    \n+\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        /* \n+         * Bins should be [0, 10], (10, 20], ..., (9990, 10000]\n+         * Kernels should be N(4.5, 3.02765), N(14.5, 3.02765)...\n+         * Each bin should have mass 10/10000 = .001\n+         */\n+        final double[] testPoints = getCumulativeTestPoints();\n+        final double[] cumValues = new double[testPoints.length];\n+        final EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution) makeDistribution();\n+        final double[] binBounds = empiricalDistribution.getUpperBounds();\n+        for (int i = 0; i < testPoints.length; i++) {\n+            final int bin = findBin(testPoints[i]);\n+            final double lower = bin == 0 ? empiricalDistribution.getSupportLowerBound() :\n+                binBounds[bin - 1];\n+            final double upper = binBounds[bin];\n+            // Compute bMinus = sum or mass of bins below the bin containing the point\n+            // First bin has mass 11 / 10000, the rest have mass 10 / 10000.\n+            final double bMinus = bin == 0 ? 0 : (bin - 1) * binMass + firstBinMass;\n+            final RealDistribution kernel = findKernel(lower, upper);\n+            final double withinBinKernelMass = kernel.cumulativeProbability(lower, upper);\n+            final double kernelCum = kernel.cumulativeProbability(lower, testPoints[i]);\n+            cumValues[i] = bMinus + (bin == 0 ? firstBinMass : binMass) * kernelCum/withinBinKernelMass;\n+        }\n+        return cumValues;\n+    }\n+\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        final double[] testPoints = getCumulativeTestPoints();\n+        final double[] densityValues = new double[testPoints.length];\n+        final EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution) makeDistribution();\n+        final double[] binBounds = empiricalDistribution.getUpperBounds();\n+        for (int i = 0; i < testPoints.length; i++) {\n+            final int bin = findBin(testPoints[i]);\n+            final double lower = bin == 0 ? empiricalDistribution.getSupportLowerBound() :\n+                binBounds[bin - 1];\n+            final double upper = binBounds[bin];\n+            final RealDistribution kernel = findKernel(lower, upper);\n+            final double withinBinKernelMass = kernel.cumulativeProbability(lower, upper);\n+            final double density = kernel.density(testPoints[i]);\n+            densityValues[i] = density * (bin == 0 ? firstBinMass : binMass) / withinBinKernelMass;   \n+        }\n+        return densityValues;\n+    }\n+    \n+    /** \n+     * Modify test integration bounds from the default. Because the distribution\n+     * has discontinuities at bin boundaries, integrals spanning multiple bins\n+     * will face convergence problems.  Only test within-bin integrals and spans\n+     * across no more than 3 bin boundaries.\n+     */\n+    @Override\n+    @Test\n+    public void testDensityIntegrals() {\n+        final RealDistribution distribution = makeDistribution();\n+        final double tol = 1.0e-9;\n+        final BaseAbstractUnivariateIntegrator integrator =\n+            new IterativeLegendreGaussIntegrator(5, 1.0e-12, 1.0e-10);\n+        final UnivariateFunction d = new UnivariateFunction() {\n+            public double value(double x) {\n+                return distribution.density(x);\n+            }\n+        };\n+        final double[] lower = {0, 5, 1000, 5001, 9995};\n+        final double[] upper = {5, 12, 1030, 5010, 10000};\n+        for (int i = 1; i < 5; i++) {\n+            Assert.assertEquals(\n+                    distribution.cumulativeProbability( \n+                            lower[i], upper[i]),\n+                            integrator.integrate(\n+                                    1000000, // Triangle integrals are very slow to converge\n+                                    d, lower[i], upper[i]), tol);\n+        }\n+    }\n+    \n+    /**\n+     * Find the bin that x belongs (relative to {@link #makeDistribution()}).\n+     */\n+    private int findBin(double x) {\n+        // Number of bins below x should be trunc(x/10)\n+        final double nMinus = Math.floor(x / 10);\n+        final int bin =  (int) Math.round(nMinus);\n+        // If x falls on a bin boundary, it is in the lower bin\n+        return Math.floor(x / 10) == x / 10 ? bin - 1 : bin;\n+    }\n+    \n+    /**\n+     * Find the within-bin kernel for the bin with lower bound lower\n+     * and upper bound upper. All bins other than the first contain 10 points\n+     * exclusive of the lower bound and are centered at (lower + upper + 1) / 2.\n+     * The first bin includes its lower bound, 0, so has different mean and\n+     * standard deviation.\n+     */\n+    private RealDistribution findKernel(double lower, double upper) {\n+        if (lower < 1) {\n+            return new NormalDistribution(5d, 3.3166247903554);\n+        } else {\n+            return new NormalDistribution((upper + lower + 1) / 2d, 3.0276503540974917); \n+        }\n+    }\n }", "timestamp": 1355204166, "metainfo": ""}