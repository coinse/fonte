{"sha": "7c4c349f26e4ddd2d5af00486cf1f445b5523c20", "log": "* Added density functions to remaining continuous distributions (F, T, Weibull, Cauchy). * Deprecated HasDensity interface. * Added density tests. * Made Brent Solver (inverse cum) absolute accuracy configurable for all continuous distributions.  JIRA: MATH-332 JIRA: MATH-282 Thanks to Mikkel Meyer Andersen  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n    // org.apache.commons.math.distribution.AbstractContinuousDistribution\n    { \"Cumulative probability function returned NaN for argument {0} p = {1}\",\n      \"Fonction de probabilit\\u00e9 cumulative retourn\\u00e9 NaN \\u00e0 l''argument de {0} p = {1}\" },\n+   { \"This distribution does not have a density function implemented\",\n+     \"La fonction de densit\\u00e9 pour cette distribution n'a pas \\u00e9t\\u00e9 mis en oeuvre\" },\n \n    // org.apache.commons.math.distribution.AbstractIntegerDistribution\n    { \"Discrete cumulative probability function returned NaN for argument {0}\",\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n     }\n \n     /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     * @throws MathRuntimeException if the specialized class hasn't implemented this function\n+     */\n+    public double density(double x) throws MathRuntimeException {\n+        throw new MathRuntimeException(new UnsupportedOperationException(),\n+                \"This distribution does not have a density function implemented\");\n+    }\n+\n+    /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      *\n              * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n              * case if density has bounded support and p is 0 or 1).\n              */\n-            if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n+            if (Math.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n                 return lowerBound;\n             }\n-            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n+            if (Math.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n                 return upperBound;\n             }\n             // Failed bracket convergence was not because of corner solution\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.special.Beta;\n \n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public double density(Double x) throws MathException {\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     * @deprecated\n+     */\n+    public double density(Double x) {\n+        return density(x.doubleValue());\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(double x) {\n         recomputeZ();\n         if (x < 0 || x > 1) {\n             return 0;\n         } else if (x == 0) {\n             if (alpha < 1) {\n-                throw new MathException(\"Cannot compute beta density at 0 when alpha = {0,number}\", alpha);\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"Cannot compute beta density at 0 when alpha = {0,number}\", alpha);\n             }\n             return 0;\n         } else if (x == 1) {\n             if (beta < 1) {\n-                throw new MathException(\"Cannot compute beta density at 1 when beta = %.3g\", beta);\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"Cannot compute beta density at 1 when beta = %.3g\", beta);\n             }\n             return 0;\n         } else {\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n     }\n \n     /**\n+     * Returns the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    @Override\n+    public double density(double x) {\n+        final double dev = x - median;\n+        return (1 / Math.PI) * (scale / (dev * dev + scale * scale));\n+    }\n+\n+    /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n     }\n     /**\n      * Modify the median.\n-     * @param median for this distribution\n-     */\n-    private void setMedianInternal(double median) {\n-        this.median = median;\n+     * @param newMedian for this distribution\n+     */\n+    private void setMedianInternal(double newMedian) {\n+        this.median = newMedian;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     extends AbstractContinuousDistribution\n     implements ChiSquaredDistribution, Serializable  {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8352658048349159782L;\n \n     /** Internal Gamma distribution. */\n     private GammaDistribution gamma;\n+\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a Chi-Squared distribution with the given degrees of freedom.\n         super();\n         setGammaInternal(g);\n         setDegreesOfFreedomInternal(df);\n+        solverAbsoluteAccuracy = DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n+    }\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom and\n+     * inverse cumulative probability accuracy.\n+     * @param df degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     */\n+    public ChiSquaredDistributionImpl(double df, double inverseCumAccuracy) {\n+        super();\n+        gamma = new GammaDistributionImpl(df / 2.0, 2.0);\n+        setDegreesOfFreedomInternal(df);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n      *\n      * @param x The point at which the density should be computed.\n      * @return The pdf at point x.\n+     * @deprecated\n      */\n     public double density(Double x) {\n+        return density(x.doubleValue());\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    @Override\n+    public double density(double x) {\n         return gamma.density(x);\n     }\n \n \n     }\n \n-    /**\n-     * Access the Gamma distribution.\n-     * @return the internal Gamma distribution.\n-     */\n-    private GammaDistribution getGamma() {\n-        return gamma;\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n import org.apache.commons.math.MathException;\n \n /**\n- * Base interface for continuous distributions.\n+ * <p>Base interface for continuous distributions.</p>\n+ *\n+ * <p>Note: this interface will be extended in version 3.0 to include\n+ * <br/><code>public double density(double x)</code><br/>\n+ * that is, from version 3.0 forward, continuous distributions <strong>must</strong>\n+ * include implementations of probability density functions. As of version\n+ * 2.1, all continuous distribution implementations included in commons-math\n+ * provide implementations of this method.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n     }\n     /**\n      * Modify the mean.\n-     * @param mean the new mean.\n-     * @throws IllegalArgumentException if <code>mean</code> is not positive.\n-     */\n-    private void setMeanInternal(double mean) {\n-        if (mean <= 0.0) {\n+     * @param newMean the new mean.\n+     * @throws IllegalArgumentException if <code>newMean</code> is not positive.\n+     */\n+    private void setMeanInternal(double newMean) {\n+        if (newMean <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"mean must be positive ({0})\", mean);\n-        }\n-        this.mean = mean;\n+                  \"mean must be positive ({0})\", newMean);\n+        }\n+        this.mean = newMean;\n     }\n \n     /**\n      *\n      * @param x The point at which the density should be computed.\n      * @return The pdf at point x.\n+     * @deprecated - use density(double)\n      */\n     public double density(Double x) {\n+        return density(x.doubleValue());\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    @Override\n+    public double density(double x) {\n         if (x < 0) {\n             return 0;\n         }\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n     extends AbstractContinuousDistribution\n     implements FDistribution, Serializable  {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Message for non positive degrees of freddom. */\n     private static final String NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE =\n         \"degrees of freedom must be positive ({0})\";\n     /** The numerator degrees of freedom*/\n     private double denominatorDegreesOfFreedom;\n \n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n     /**\n      * Create a F distribution using the given degrees of freedom.\n      * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n      */\n     public FDistributionImpl(double numeratorDegreesOfFreedom,\n                              double denominatorDegreesOfFreedom) {\n+        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a F distribution using the given degrees of freedom and inverse cumulative probability accuracy.\n+     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     */\n+    public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom,\n+            double inverseCumAccuracy) {\n         super();\n         setNumeratorDegreesOfFreedomInternal(numeratorDegreesOfFreedom);\n         setDenominatorDegreesOfFreedomInternal(denominatorDegreesOfFreedom);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Returns the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    @Override\n+    public double density(double x) {\n+        final double nhalf = numeratorDegreesOfFreedom / 2;\n+        final double mhalf = denominatorDegreesOfFreedom / 2;\n+        final double logx = Math.log(x);\n+        final double logn = Math.log(numeratorDegreesOfFreedom);\n+        final double logm = Math.log(denominatorDegreesOfFreedom);\n+        final double lognxm = Math.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);\n+        return Math.exp(nhalf*logn + nhalf*logx - logx + mhalf*logm - nhalf*lognxm -\n+               mhalf*lognxm - Beta.logBeta(nhalf, mhalf));\n     }\n \n     /**\n     public double getDenominatorDegreesOfFreedom() {\n         return denominatorDegreesOfFreedom;\n     }\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n public class GammaDistributionImpl extends AbstractContinuousDistribution\n     implements GammaDistribution, Serializable  {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3239549463135430361L;\n \n \n     /** The scale parameter. */\n     private double beta;\n+\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a new gamma distribution with the given alpha and beta values.\n      * @param beta the scale parameter.\n      */\n     public GammaDistributionImpl(double alpha, double beta) {\n+        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a new gamma distribution with the given alpha and beta values.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     */\n+    public GammaDistributionImpl(double alpha, double beta, double inverseCumAccuracy) {\n         super();\n         setAlphaInternal(alpha);\n         setBetaInternal(beta);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n \n     /**\n      * Modify the shape parameter, alpha.\n-     * @param alpha the new shape parameter.\n-     * @throws IllegalArgumentException if <code>alpha</code> is not positive.\n-     */\n-    private void setAlphaInternal(double alpha) {\n-        if (alpha <= 0.0) {\n+     * @param newAlpha the new shape parameter.\n+     * @throws IllegalArgumentException if <code>newAlpha</code> is not positive.\n+     */\n+    private void setAlphaInternal(double newAlpha) {\n+        if (newAlpha <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"alpha must be positive ({0})\",\n-                  alpha);\n-        }\n-        this.alpha = alpha;\n+                  newAlpha);\n+        }\n+        this.alpha = newAlpha;\n     }\n \n     /**\n \n     /**\n      * Modify the scale parameter, beta.\n-     * @param beta the new scale parameter.\n-     * @throws IllegalArgumentException if <code>beta</code> is not positive.\n+     * @param newBeta the new scale parameter.\n+     * @throws IllegalArgumentException if <code>newBeta</code> is not positive.\n      * @deprecated as of 2.1 (class will become immutable in 3.0)\n      */\n     @Deprecated\n-    public void setBeta(double beta) {\n-        setBetaInternal(beta);\n+    public void setBeta(double newBeta) {\n+        setBetaInternal(newBeta);\n     }\n \n     /**\n      * Modify the scale parameter, beta.\n-     * @param beta the new scale parameter.\n-     * @throws IllegalArgumentException if <code>beta</code> is not positive.\n-     */\n-    private void setBetaInternal(double beta) {\n-        if (beta <= 0.0) {\n+     * @param newBeta the new scale parameter.\n+     * @throws IllegalArgumentException if <code>newBeta</code> is not positive.\n+     */\n+    private void setBetaInternal(double newBeta) {\n+        if (newBeta <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"beta must be positive ({0})\",\n-                  beta);\n-        }\n-        this.beta = beta;\n+                  newBeta);\n+        }\n+        this.beta = newBeta;\n     }\n \n     /**\n     }\n \n     /**\n-     * Return the probability density for a particular point.\n+     * Returns the probability density for a particular point.\n      *\n      * @param x The point at which the density should be computed.\n      * @return The pdf at point x.\n      */\n-    public double density(Double x) {\n+    @Override\n+    public double density(double x) {\n         if (x < 0) return 0;\n         return Math.pow(x / beta, alpha - 1) / beta * Math.exp(-x / beta) / Math.exp(Gamma.logGamma(alpha));\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     * @deprecated\n+     */\n+    public double density(Double x) {\n+        return density(x.doubleValue());\n     }\n \n     /**\n \n         return ret;\n     }\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/HasDensity.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HasDensity.java\n import org.apache.commons.math.MathException;\n \n /**\n- * Interface that signals that a distribution can compute the probability density function\n+ * <p>Interface that signals that a distribution can compute the probability density function\n  * for a particular point.\n  * @param <P> the type of the point at which density is to be computed, this\n- * may be for example <code>Double</code>\n+ * may be for example <code>Double.</code></p>\n+ *\n+ * <p>This interface is deprecated.  As of version 2.0, the {@link ContinuousDistribution}\n+ * interface will be extended to include a <code>density(double)<code> method.</p>\n+ *\n+ * @deprecated to be removed in math 3.0\n  * @version $Revision$ $Date$\n  */\n public interface HasDensity<P> {\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n     }\n     /**\n      * Modify the mean.\n-     * @param mean for this distribution\n-     */\n-    private void setMeanInternal(double mean) {\n-        this.mean = mean;\n+     * @param newMean for this distribution\n+     */\n+    private void setMeanInternal(double newMean) {\n+        this.mean = newMean;\n     }\n \n     /**\n      *\n      * @param x The point at which the density should be computed.\n      * @return The pdf at point x.\n+     * @deprecated\n      */\n     public double density(Double x) {\n+        return density(x.doubleValue());\n+    }\n+\n+    /**\n+     * Returns the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(double x) {\n         double x0 = x - mean;\n         return Math.exp(-x0 * x0 / (2 * standardDeviation * standardDeviation)) / (standardDeviation * SQRT2PI);\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.special.Gamma;\n \n /**\n  * Default implementation of\n     extends AbstractContinuousDistribution\n     implements TDistribution, Serializable  {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -5852615386664158222L;\n \n     /** The degrees of freedom*/\n     private double degreesOfFreedom;\n \n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a t distribution using the given degrees of freedom and the\n+     * specified inverse cumulative probability absolute accuracy.\n+     *\n+     * @param degreesOfFreedom the degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     */\n+    public TDistributionImpl(double degreesOfFreedom, double inverseCumAccuracy) {\n+        super();\n+        setDegreesOfFreedomInternal(degreesOfFreedom);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n     /**\n      * Create a t distribution using the given degrees of freedom.\n      * @param degreesOfFreedom the degrees of freedom.\n      */\n     public TDistributionImpl(double degreesOfFreedom) {\n-        super();\n-        setDegreesOfFreedomInternal(degreesOfFreedom);\n+        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n     }\n     /**\n      * Modify the degrees of freedom.\n-     * @param degreesOfFreedom the new degrees of freedom.\n-     */\n-    private void setDegreesOfFreedomInternal(double degreesOfFreedom) {\n-        if (degreesOfFreedom <= 0.0) {\n+     * @param newDegreesOfFreedom the new degrees of freedom.\n+     */\n+    private void setDegreesOfFreedomInternal(double newDegreesOfFreedom) {\n+        if (newDegreesOfFreedom <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"degrees of freedom must be positive ({0})\",\n-                  degreesOfFreedom);\n-        }\n-        this.degreesOfFreedom = degreesOfFreedom;\n+                  newDegreesOfFreedom);\n+        }\n+        this.degreesOfFreedom = newDegreesOfFreedom;\n     }\n \n     /**\n      */\n     public double getDegreesOfFreedom() {\n         return degreesOfFreedom;\n+    }\n+\n+    /**\n+     * Returns the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    @Override\n+    public double density(double x) {\n+        final double n = degreesOfFreedom;\n+        final double nPlus1Over2 = (n + 1) / 2;\n+        return Math.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (Math.log(Math.PI) + Math.log(n)) -\n+                Gamma.logGamma(n/2) - nPlus1Over2 * Math.log(1 + x * x /n));\n     }\n \n     /**\n     protected double getInitialDomain(double p) {\n         return 0.0;\n     }\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n public class WeibullDistributionImpl extends AbstractContinuousDistribution\n         implements WeibullDistribution, Serializable {\n \n+    /** Default inverse cumulative probability accuracy */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n \n     /** The scale parameter. */\n     private double scale;\n+\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n \n     /**\n      * Creates weibull distribution with the given shape and scale and a\n      * @param beta the scale parameter.\n      */\n     public WeibullDistributionImpl(double alpha, double beta){\n+        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Creates weibull distribution with the given shape, scale and inverse\n+     * cumulative probability accuracy and a location equal to zero.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     */\n+    public WeibullDistributionImpl(double alpha, double beta, double inverseCumAccuracy){\n         super();\n         setShapeInternal(alpha);\n         setScaleInternal(beta);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n      */\n     public double getScale() {\n         return scale;\n+    }\n+\n+    /**\n+     * Returns the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    @Override\n+    public double density(double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+\n+        final double xscale = x / scale;\n+        final double xscalepow = Math.pow(xscale, shape - 1);\n+\n+        /*\n+         * Math.pow(x / scale, shape) =\n+         * Math.pow(xscale, shape) =\n+         * Math.pow(xscale, shape - 1) * xscale\n+         */\n+        final double xscalepowshape = xscalepow * xscale;\n+\n+        return (shape / scale) * xscalepow * Math.exp(-xscalepowshape);\n     }\n \n     /**\n         // use median\n         return Math.pow(scale * Math.log(2.0), 1.0 / shape);\n     }\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n         super(arg0);\n     }\n \n+    // --------------------- Override tolerance  --------------\n+    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(defaultTolerance);\n+    }\n+\n     //-------------- Implementations for abstract methods -----------------------\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public CauchyDistribution makeDistribution() {\n         return new CauchyDistributionImpl(1.2, 2.1);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using Mathematica\n-        return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,\n-                -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,\n-                27.88302995d, 68.0230835d, 669.6485619d};\n+        // quantiles computed using R 2.9.2\n+        return new double[] {-667.24856187, -65.6230835029, -25.4830299460, -12.0588781808,\n+                -5.26313542807, 669.64856187, 68.0230835029, 27.8830299460, 14.4588781808, 7.66313542807};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n-                0.975d, 0.990d, 0.999d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,\n+                0.990, 0.975, 0.950, 0.900};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437,\n+                1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437};\n     }\n \n     //---------------------------- Additional test cases -------------------------\n--- a/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public ChiSquaredDistribution makeDistribution() {\n         return new ChiSquaredDistributionImpl(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,\n-                20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};\n+        // quantiles computed using R version 2.9.2\n+        return new double[] {0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,\n+                20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};\n     }\n \n     /** Creates the default inverse cumulative probability test input values */\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public double[] makeInverseCumulativeTestValues() {\n-        return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,\n-                20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d,\n+        return new double[] {0, 0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,\n+                20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978,\n                 Double.POSITIVE_INFINITY};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.0115379817652, 0.0415948507811, 0.0665060119842, 0.0919455953114, 0.121472591024,\n+                0.000433630076361, 0.00412780610309, 0.00999340341045, 0.0193246438937, 0.0368460089216};\n     }\n \n  // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n-        setTolerance(5e-6);\n+        setTolerance(1e-9);\n     }\n \n  //---------------------------- Additional test cases -------------------------\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n  * <p>\n  * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities\n  * makeCumulativeTestValues() -- expected cumulative probabilites\n+ * makeDensityTestValues() -- expected density values at cumulativeTestPoints\n  * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf\n  * makeInverseCumulativeTestValues() -- expected inverse cdf values\n  * <p>\n     /** Values used to test inverse cumulative probability density calculations */\n     private double[] inverseCumulativeTestValues;\n \n+    /** Values used to test density calculations */\n+    private double[] densityTestValues;\n+\n     //-------------------------------------------------------------------------\n \n     /**\n     /** Creates the default continuous distribution instance to use in tests. */\n     public abstract ContinuousDistribution makeDistribution();\n \n-    /** Creates the default cumulative probability density test input values */\n+    /** Creates the default cumulative probability test input values */\n     public abstract double[] makeCumulativeTestPoints();\n \n-    /** Creates the default cumulative probability density test expected values */\n+    /** Creates the default cumulative probability test expected values */\n     public abstract double[] makeCumulativeTestValues();\n+\n+    /** Creates the default density test expected values */\n+    public abstract double[] makeDensityTestValues();\n \n     //---- Default implementations of inverse test data generation methods ----\n \n         cumulativeTestValues = makeCumulativeTestValues();\n         inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n         inverseCumulativeTestValues = makeInverseCumulativeTestValues();\n+        densityTestValues = makeDensityTestValues();\n     }\n \n     /**\n         cumulativeTestValues = null;\n         inverseCumulativeTestPoints = null;\n         inverseCumulativeTestValues = null;\n+        densityTestValues = null;\n     }\n \n     //-------------------- Verification methods -------------------------------\n         }\n     }\n \n+    /**\n+     * Verifies that density calculations match expected values\n+     */\n+    protected void verifyDensities() throws Exception {\n+        for (int i = 0; i < cumulativeTestPoints.length; i++) {\n+            TestUtils.assertEquals(\"Incorrect probability density value returned for \"\n+                + cumulativeTestPoints[i], densityTestValues[i],\n+                 //TODO: remove cast when density(double) is added to ContinuousDistribution\n+                 ((AbstractContinuousDistribution) distribution).density(cumulativeTestPoints[i]),\n+                 getTolerance());\n+        }\n+    }\n+\n     //------------------------ Default test cases -----------------------------\n \n     /**\n      */\n     public void testInverseCumulativeProbabilities() throws Exception {\n         verifyInverseCumulativeProbabilities();\n+    }\n+\n+    /**\n+     * Verifies that density calculations return expected values\n+     * for default test instance data\n+     */\n+    public void testDensities() throws Exception {\n+        verifyDensities();\n     }\n \n     /**\n         this.cumulativeTestValues = cumulativeTestValues;\n     }\n \n+    protected double[] getDensityTestValues() {\n+        return densityTestValues;\n+    }\n+\n+    protected void setDensityTestValues(double[] densityTestValues) {\n+        this.densityTestValues = densityTestValues;\n+    }\n+\n     /**\n      * @return Returns the distribution.\n      */\n     /**\n      * @param distribution The distribution to set.\n      */\n-    protected void setDistribution(ContinuousDistribution distribution) {\n+    protected void setDistribution(AbstractContinuousDistribution distribution) {\n         this.distribution = distribution;\n     }\n \n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n         super(name);\n     }\n \n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(1E-9);\n+    }\n+\n     //-------------- Implementations for abstract methods -----------------------\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public ExponentialDistribution makeDistribution() {\n         return new ExponentialDistributionImpl(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d,\n-                34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};\n+        // quantiles computed using R version 2.9.2\n+        return new double[] {0.00500250166792, 0.0502516792675, 0.126589039921, 0.256466471938,\n+                0.526802578289, 34.5387763949, 23.0258509299, 18.4443972706, 14.9786613678, 11.5129254650};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,\n+                0.990, 0.975, 0.950, 0.900};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.1998, 0.198, 0.195, 0.19, 0.18, 0.000200000000000,\n+                0.00200000000002, 0.00499999999997, 0.00999999999994, 0.0199999999999};\n     }\n \n     //------------ Additional tests -------------------------------------------\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public FDistribution makeDistribution() {\n         return new FDistributionImpl(5.0, 6.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {0.03468084d ,0.09370091d, 0.1433137d,\n-            0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d,\n-            4.387374d, 3.107512d};\n+        // quantiles computed using R version 2.9.2\n+        return new double[] {0.0346808448626, 0.0937009113303, 0.143313661184, 0.202008445998, 0.293728320107,\n+                20.8026639595, 8.74589525602, 5.98756512605, 4.38737418741, 3.10751166664};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.0689156576706, 0.236735653193, 0.364074131941, 0.481570789649, 0.595880479994,\n+                0.000133443915657, 0.00286681303403, 0.00969192007502, 0.0242883861471, 0.0605491314658};\n     }\n \n     // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n-        setTolerance(4e-6);\n+        setTolerance(1e-9);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public GammaDistribution makeDistribution() {\n         return new GammaDistributionImpl(4d, 2d);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,\n-            3.489539, 26.12448, 20.09024, 17.53455,\n-            15.50731, 13.36157};\n+        // quantiles computed using R version 2.9.2\n+        return new double[] {0.857104827257, 1.64649737269, 2.17973074725, 2.7326367935, 3.48953912565,\n+                26.1244815584, 20.0902350297, 17.5345461395, 15.5073130559, 13.3615661365};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.00427280075546, 0.0204117166709, 0.0362756163658, 0.0542113174239, 0.0773195272491,\n+                0.000394468852816, 0.00366559696761, 0.00874649473311, 0.0166712508128, 0.0311798227954};\n     }\n \n     // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n-        setTolerance(6e-6);\n+        setTolerance(1e-9);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public NormalDistribution makeDistribution() {\n         return new NormalDistributionImpl(2.1, 1.4);\n     }\n \n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n                 0.990d, 0.975d, 0.950d, 0.900d};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380,\n+                0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380};\n     }\n \n     // --------------------- Override tolerance  --------------\n     }\n \n     public void testQuantiles() throws Exception {\n+        setDensityTestValues(new double[] {0.0385649760808, 0.172836231799, 0.284958771715, 0.172836231799, 0.0385649760808,\n+                0.00316560600853, 9.55930184035e-05, 1.06194251052e-06});\n         verifyQuantiles();\n+        verifyDensities();\n+\n         setDistribution(new NormalDistributionImpl(0, 1));\n+        setDensityTestValues(new double[] {0.0539909665132, 0.241970724519, 0.398942280401, 0.241970724519, 0.0539909665132,\n+                0.00443184841194, 0.000133830225765, 1.48671951473e-06});\n         verifyQuantiles();\n+        verifyDensities();\n+\n         setDistribution(new NormalDistributionImpl(0, 0.1));\n+        setDensityTestValues(new double[] {0.539909665132, 2.41970724519, 3.98942280401, 2.41970724519,\n+                0.539909665132, 0.0443184841194, 0.00133830225765, 1.48671951473e-05});\n         verifyQuantiles();\n+        verifyDensities();\n     }\n \n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public TDistribution makeDistribution() {\n         return new TDistributionImpl(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,\n-            -1.475884, 0.0, 5.89343, 3.36493, 2.570582,\n-            2.015048, 1.475884};\n+        // quantiles computed using R version 2.9.2\n+        return new double[] {-5.89342953136, -3.36492999891, -2.57058183564, -2.01504837333, -1.47588404882,\n+                5.89342953136, 3.36492999891, 2.57058183564, 2.01504837333, 1.47588404882};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,\n+                0.990, 0.975, 0.950, 0.900};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005,\n+                0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005};\n     }\n \n     // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n-        setTolerance(1E-6);\n+        setTolerance(1E-9);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n \n     public void testSmallDf() throws Exception {\n         setDistribution(new TDistributionImpl(1d));\n-        setTolerance(1E-4);\n-        // quantiles computed using R version 1.8.1 (linux version)\n-        setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752,\n-            -3.077684, 0.0, 318.3088, 31.82052, 12.70620,\n-            6.313752, 3.077684});\n+        // quantiles computed using R version 2.9.2\n+        setCumulativeTestPoints(new double[] {-318.308838986, -31.8205159538, -12.7062047362,\n+                -6.31375151468, -3.07768353718, 318.308838986, 31.8205159538, 12.7062047362,\n+                 6.31375151468, 3.07768353718});\n+        setDensityTestValues(new double[] {3.14158231817e-06, 0.000314055924703, 0.00195946145194,\n+                0.00778959736375, 0.0303958893917, 3.14158231817e-06, 0.000314055924703,\n+                0.00195946145194, 0.00778959736375, 0.0303958893917});\n         setInverseCumulativeTestValues(getCumulativeTestPoints());\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n+        verifyDensities();\n     }\n \n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n-    public ContinuousDistribution makeDistribution() {\n+    public WeibullDistribution makeDistribution() {\n         return new WeibullDistributionImpl(1.2, 2.1);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using Mathematica\n-        return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n-                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,\n-                6.232056007d, 7.497630467d, 10.51154969d};\n+        // quantiles computed using R version 2.9.2\n+        return new double[] {0.00664355180993, 0.0454328283309, 0.0981162737374, 0.176713524579, 0.321946865392,\n+                10.5115496887, 7.4976304671, 6.23205600701, 5.23968436955, 4.2079028257};\n     }\n \n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n-                0.975d, 0.990d, 0.999d};\n+        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] {0.180535929306, 0.262801138133, 0.301905425199, 0.330899152971,\n+          0.353441418887, 0.000788590320203, 0.00737060094841, 0.0177576041516, 0.0343043442574, 0.065664589369};\n     }\n \n     //---------------------------- Additional test cases -------------------------\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n         }\n \n     }\n-    /* TODO: re-enable when MATH-282 is resolved\n+\n     public void testNextPoissonConsistency() throws Exception {\n         // Small integral means\n         for (int i = 1; i < 100; i++) {\n             checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));\n         }\n     }\n-    */\n \n     /**\n      * Verifies that nextPoisson(mean) generates an empirical distribution of values", "timestamp": 1268844331, "metainfo": ""}