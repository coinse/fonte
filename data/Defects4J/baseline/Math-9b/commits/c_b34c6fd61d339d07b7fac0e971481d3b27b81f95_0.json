{"sha": "b34c6fd61d339d07b7fac0e971481d3b27b81f95", "log": "MATH-854: fill the \"throws\" clause of FieldVector, ArrayFieldVector.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapDivide(T d) {\n+    public FieldVector<T> mapDivide(T d)\n+        throws NullArgumentException, MathArithmeticException {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].divide(d);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapDivideToSelf(T d) {\n+    public FieldVector<T> mapDivideToSelf(T d)\n+        throws NullArgumentException, MathArithmeticException {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].divide(d);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapInv() {\n+    public FieldVector<T> mapInv() throws MathArithmeticException {\n         T[] out = buildArray(data.length);\n         final T one = field.getOne();\n         for (int i = 0; i < data.length; i++) {\n-            out[i] = one.divide(data[i]);\n+            try {\n+                out[i] = one.divide(data[i]);\n+            } catch (final MathArithmeticException e) {\n+                throw new MathArithmeticException(LocalizedFormats.ENTRY, i);\n+            }\n         }\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapInvToSelf() {\n+    public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n         final T one = field.getOne();\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = one.divide(data[i]);\n+            try {\n+                data[i] = one.divide(data[i]);\n+            } catch (final MathArithmeticException e) {\n+                throw new MathArithmeticException(LocalizedFormats.ENTRY, i);\n+            }\n         }\n         return this;\n     }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> ebeDivide(FieldVector<T> v)\n-        throws DimensionMismatchException {\n+        throws DimensionMismatchException, MathArithmeticException {\n         try {\n             return ebeDivide((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n             checkVectorDimensions(v);\n             T[] out = buildArray(data.length);\n             for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i].divide(v.getEntry(i));\n+                try {\n+                    out[i] = data[i].divide(v.getEntry(i));\n+                } catch (final MathArithmeticException e) {\n+                    throw new MathArithmeticException(LocalizedFormats.ENTRY, i);\n+                }\n             }\n             return new ArrayFieldVector<T>(field, out, false);\n         }\n      * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n      * @throws DimensionMismatchException if {@code v} is not the same size as\n      * {@code this}\n+     * @throws MathArithmeticException if one entry of {@code v} is zero.\n      */\n     public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n-        throws DimensionMismatchException {\n+        throws DimensionMismatchException, MathArithmeticException {\n         checkVectorDimensions(v.data.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n+            try {\n                 out[i] = data[i].divide(v.data[i]);\n+            } catch (final MathArithmeticException e) {\n+                throw new MathArithmeticException(LocalizedFormats.ENTRY, i);\n+            }\n         }\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> projection(FieldVector<T> v)\n-        throws DimensionMismatchException {\n+        throws DimensionMismatchException, MathArithmeticException {\n         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n     }\n \n      * @return projection of {@code this} onto {@code v}\n      * @throws DimensionMismatchException if {@code v} is not the same size as\n      * {@code this}\n+     * @throws MathArithmeticException if {@code v} is the null vector.\n      */\n     public ArrayFieldVector<T> projection(ArrayFieldVector<T> v)\n-        throws DimensionMismatchException {\n+        throws DimensionMismatchException, MathArithmeticException {\n         return (ArrayFieldVector<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> getSubVector(int index, int n) {\n+    public FieldVector<T> getSubVector(int index, int n)\n+        throws OutOfRangeException, NotPositiveException {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);\n+        }\n         ArrayFieldVector<T> out = new ArrayFieldVector<T>(field, n);\n         try {\n             System.arraycopy(data, index, out.data, 0, n);\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubVector(int index, FieldVector<T> v) {\n+    public void setSubVector(int index, FieldVector<T> v) throws OutOfRangeException {\n         try {\n             try {\n                 set(index, (ArrayFieldVector<T>) v);\n--- a/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n \n /**\n      * Map a division operation to each entry.\n      * @param d value to divide all entries by\n      * @return {@code this / d}\n-     */\n-    FieldVector<T> mapDivide(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws MathArithmeticException if {@code d} is zero.\n+     */\n+    FieldVector<T> mapDivide(T d)\n+        throws NullArgumentException, MathArithmeticException;\n \n     /**\n      * Map a division operation to each entry.\n      * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to divide all entries by\n      * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapDivideToSelf(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws MathArithmeticException if {@code d} is zero.\n+     */\n+    FieldVector<T> mapDivideToSelf(T d)\n+        throws NullArgumentException, MathArithmeticException;\n \n     /**\n      * Map the 1/x function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     */\n-    FieldVector<T> mapInv();\n+     * @return a vector containing the result of applying the function to each\n+     * entry.\n+     * @throws MathArithmeticException if one of the entries is zero.\n+     */\n+    FieldVector<T> mapInv() throws MathArithmeticException;\n \n     /**\n      * Map the 1/x function to each entry.\n      * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapInvToSelf();\n+     * @throws MathArithmeticException if one of the entries is zero.\n+     */\n+    FieldVector<T> mapInvToSelf() throws MathArithmeticException;\n \n     /**\n      * Element-by-element multiplication.\n      * {@code this}\n      */\n     FieldVector<T> ebeMultiply(FieldVector<T> v)\n-            throws DimensionMismatchException;\n+        throws DimensionMismatchException;\n \n     /**\n      * Element-by-element division.\n      * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n      * @throws DimensionMismatchException if {@code v} is not the same size as\n      * {@code this}\n+     * @throws MathArithmeticException if one entry of {@code v} is zero.\n      */\n     FieldVector<T> ebeDivide(FieldVector<T> v)\n-            throws DimensionMismatchException;\n+        throws DimensionMismatchException, MathArithmeticException;\n \n     /**\n      * Returns vector entries as a T array.\n      * @return projection of {@code this} onto {@code v}\n      * @throws DimensionMismatchException if {@code v} is not the same size as\n      * {@code this}\n-     */\n-    FieldVector<T> projection(FieldVector<T> v) throws DimensionMismatchException;\n+     * @throws MathArithmeticException if {@code v} is the null vector.\n+     */\n+    FieldVector<T> projection(FieldVector<T> v)\n+        throws DimensionMismatchException, MathArithmeticException;\n \n     /**\n      * Compute the outer product.\n      * @throws NotPositiveException if the number of elements if not positive.\n      */\n     FieldVector<T> getSubVector(int index, int n)\n-            throws OutOfRangeException, NotPositiveException;\n+        throws OutOfRangeException, NotPositiveException;\n \n     /**\n      * Set a set of consecutive elements.", "timestamp": 1347424067, "metainfo": ""}