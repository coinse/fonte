{"sha": "017f7648527d5935c46c28d699dd5073ba2396b5", "log": "Added a Brent-like solver that has higher (user specified) order and does bracket selection on the result: BracketingNthOrderBrentSolver.  JIRA: MATH-635  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements a modification of the <a\n+ * href=\"http://mathworld.wolfram.com/BrentsMethod.html\"> Brent algorithm</a>.\n+ * <p>\n+ * The changes with respect to the original Brent algorithm are:\n+ * <ul>\n+ *   <li>the returned value is chosen in the current interval according\n+ *   to user specified {@link AllowedSolutions},</li>\n+ *   <li>the maximal order for the invert polynomial root search is\n+ *   user-specified instead of being invert quadratic only</li>\n+ * </ul>\n+ * </p>\n+ * The given interval must bracket the root.\n+ *\n+ * @version $Id$\n+ */\n+public class BracketingNthOrderBrentSolver\n+    extends AbstractUnivariateRealSolver\n+    implements BracketedUnivariateRealSolver<UnivariateRealFunction> {\n+\n+    /** Default absolute accuracy. */\n+    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n+    /** Default maximal order. */\n+    private static final int DEFAULT_MAXIMAL_ORDER = 5;\n+\n+    /** Maximal aging triggering an attempt to balance the bracketing interval. */\n+    private static final int MAXIMAL_AGING = 2;\n+\n+    /** Reduction factor for attempts to balance the bracketing interval. */\n+    private static final double REDUCTION_FACTOR = 1.0 / 16.0;\n+\n+    /** Maximal order. */\n+    private final int maximalOrder;\n+\n+    /** The kinds of solutions that the algorithm may accept. */\n+    private AllowedSolutions allowed;\n+\n+    /**\n+     * Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)\n+     */\n+    public BracketingNthOrderBrentSolver() {\n+        this(DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_MAXIMAL_ORDER);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param maximalOrder maximal order.\n+     * @exception NumberIsTooSmallException if maximal order is lower than 2\n+     */\n+    public BracketingNthOrderBrentSolver(final double absoluteAccuracy,\n+                                         final int maximalOrder)\n+        throws NumberIsTooSmallException {\n+        super(absoluteAccuracy);\n+        if (maximalOrder < 2) {\n+            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n+        }\n+        this.maximalOrder = maximalOrder;\n+        this.allowed = AllowedSolutions.ANY_SIDE;\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param maximalOrder maximal order.\n+     * @exception NumberIsTooSmallException if maximal order is lower than 2\n+     */\n+    public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n+                                         final double absoluteAccuracy,\n+                                         final int maximalOrder)\n+        throws NumberIsTooSmallException {\n+        super(relativeAccuracy, absoluteAccuracy);\n+        if (maximalOrder < 2) {\n+            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n+        }\n+        this.maximalOrder = maximalOrder;\n+        this.allowed = AllowedSolutions.ANY_SIDE;\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param functionValueAccuracy Function value accuracy.\n+     * @param maximalOrder maximal order.\n+     * @exception NumberIsTooSmallException if maximal order is lower than 2\n+     */\n+    public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n+                                         final double absoluteAccuracy,\n+                                         final double functionValueAccuracy,\n+                                         final int maximalOrder)\n+        throws NumberIsTooSmallException {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+        if (maximalOrder < 2) {\n+            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n+        }\n+        this.maximalOrder = maximalOrder;\n+        this.allowed = AllowedSolutions.ANY_SIDE;\n+    }\n+\n+    /** Get the maximal order.\n+     * @return maximal order\n+     */\n+    public int getMaximalOrder() {\n+        return maximalOrder;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected double doSolve() {\n+\n+        // prepare arrays with the first points\n+        final double[] x = new double[maximalOrder + 1];\n+        final double[] y = new double[maximalOrder + 1];\n+        x[0] = getMin();\n+        x[1] = getStartValue();\n+        x[2] = getMax();\n+        verifySequence(x[0], x[1], x[2]);\n+\n+        // evaluate initial guess\n+        y[1] = computeObjectiveValue(x[1]);\n+        if (MathUtils.equals(y[1], 0.0, 1)) {\n+            // return the initial guess if it is a perfect root.\n+            return x[1];\n+        }\n+\n+        // evaluate first  endpoint\n+        y[0] = computeObjectiveValue(x[0]);\n+        if (MathUtils.equals(y[0], 0.0, 1)) {\n+            // return the first endpoint if it is a perfect root.\n+            return x[0];\n+        }\n+\n+        int nbPoints;\n+        int signChangeIndex;\n+        if (y[0] * y[1] < 0) {\n+\n+            // reduce interval if it brackets the root\n+            nbPoints        = 2;\n+            signChangeIndex = 1;\n+\n+        } else {\n+\n+            // evaluate second endpoint\n+            y[2] = computeObjectiveValue(x[2]);\n+            if (MathUtils.equals(y[2], 0.0, 1)) {\n+                // return the second endpoint if it is a perfect root.\n+                return x[2];\n+            }\n+\n+            if (y[1] * y[2] < 0) {\n+                // use all computed point as a start sampling array for solving\n+                nbPoints        = 3;\n+                signChangeIndex = 2;\n+            } else {\n+                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n+            }\n+\n+        }\n+\n+        // prepare a work array for inverse polynomial interpolation\n+        final double[] tmpX = new double[x.length];\n+\n+        // current tightest bracketing of the root\n+        double xA    = x[signChangeIndex - 1];\n+        double yA    = y[signChangeIndex - 1];\n+        double absYA = FastMath.abs(yA);\n+        int agingA   = 0;\n+        double xB    = x[signChangeIndex];\n+        double yB    = y[signChangeIndex];\n+        double absYB = FastMath.abs(yB);\n+        int agingB   = 0;\n+\n+        // search loop\n+        while (true) {\n+\n+            // check convergence of bracketing interval\n+            final double xTol = getAbsoluteAccuracy() +\n+                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n+            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n+                switch (allowed) {\n+                case ANY_SIDE :\n+                    return absYA < absYB ? xA : xB;\n+                case LEFT_SIDE :\n+                    return xA;\n+                case RIGHT_SIDE :\n+                    return xB;\n+                case BELOW_SIDE :\n+                    return (yA <= 0) ? xA : xB;\n+                case ABOVE_SIDE :\n+                    return (yA <  0) ? xB : xA;\n+                default :\n+                    // this should never happen\n+                    throw new MathInternalError(null);\n+                }\n+            }\n+\n+            // target for the next evaluation point\n+            double targetY;\n+            if (agingA >= MAXIMAL_AGING) {\n+                // we keep updating the high bracket, try to compensate this\n+                targetY = -REDUCTION_FACTOR * yB;\n+            } else if (agingB >= MAXIMAL_AGING) {\n+                // we keep updating the low bracket, try to compensate this\n+                targetY = -REDUCTION_FACTOR * yA;\n+            } else {\n+                // bracketing is balanced, try to find the root itself\n+                targetY = 0;\n+            }\n+\n+            // make a few attempts to guess a root,\n+            double nextX;\n+            int start = 0;\n+            int end   = nbPoints;\n+            do {\n+\n+                // guess a value for current target, using inverse polynomial interpolation\n+                System.arraycopy(x, start, tmpX, start, end - start);\n+                nextX = guessX(targetY, tmpX, y, start, end);\n+\n+                if (!((nextX > xA) && (nextX < xB))) {\n+                    // the guessed root is not strictly inside of the tightest bracketing interval\n+\n+                    // the guessed root is either not strictly inside the interval or it\n+                    // is a NaN (which occurs when some sampling points share the same y)\n+                    // we try again with a lower interpolation order\n+                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                        // we have more points before the sign change, drop the lowest point\n+                        ++start;\n+                    } else {\n+                        // we have more points after sign change, drop the highest point\n+                        --end;\n+                    }\n+\n+                    // we need to do one more attempt\n+                    nextX = Double.NaN;\n+\n+                }\n+\n+            } while (Double.isNaN(nextX) && (end - start > 1));\n+\n+            if (Double.isNaN(nextX)) {\n+                // fall back to bisection\n+                nextX = xA + 0.5 * (xB - xA);\n+                start = signChangeIndex - 1;\n+                end   = signChangeIndex;\n+            }\n+\n+            // evaluate the function at the guessed root\n+            final double nextY = computeObjectiveValue(nextX);\n+            if (MathUtils.equals(nextY, 0.0, 1)) {\n+                // we have found an exact root, since it is not an approximation\n+                // we don't need to bother about the allowed solutions setting\n+                return nextX;\n+            }\n+\n+            if ((nbPoints > 2) && (end - start != nbPoints)) {\n+\n+                // we have been forced to ignore some points to keep bracketing,\n+                // they are probably too far from the root, drop them from now on\n+                nbPoints = end - start;\n+                System.arraycopy(x, start, x, 0, nbPoints);\n+                System.arraycopy(y, start, y, 0, nbPoints);\n+                signChangeIndex -= start;\n+\n+            } else  if (nbPoints == x.length) {\n+\n+                // we have to drop one point in order to insert the new one\n+                nbPoints--;\n+\n+                // keep the tightest bracketing interval as centered as possible\n+                if (signChangeIndex >= (x.length + 1) / 2) {\n+                    // we drop the lowest point, we have to shift the arrays and the index\n+                    System.arraycopy(x, 1, x, 0, nbPoints);\n+                    System.arraycopy(y, 1, y, 0, nbPoints);\n+                    --signChangeIndex;\n+                }\n+\n+            }\n+\n+            // insert the last computed point\n+            //(by construction, we know it lies inside the tightest bracketing interval)\n+            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n+            x[signChangeIndex] = nextX;\n+            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n+            y[signChangeIndex] = nextY;\n+            ++nbPoints;\n+\n+            // update the bracketing interval\n+            if (nextY * yA <= 0) {\n+                // the sign change occurs before the inserted point\n+                xB = nextX;\n+                yB = nextY;\n+                absYB = FastMath.abs(yB);\n+                ++agingA;\n+                agingB = 0;\n+            } else {\n+                // the sign change occurs after the inserted point\n+                xA = nextX;\n+                yA = nextY;\n+                absYA = FastMath.abs(yA);\n+                agingA = 0;\n+                ++agingB;\n+\n+                // update the sign change index\n+                signChangeIndex++;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n+     * <p>\n+     * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q\n+     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),\n+     * Q(y<sub>i</sub>) = x<sub>i</sub>.\n+     * </p>\n+     * @param targetY target value for y\n+     * @param x reference points abscissas for interpolation,\n+     * note that this array <em>is</em> modified during computation\n+     * @param y reference points ordinates for interpolation\n+     * @param start start index of the points to consider (inclusive)\n+     * @param end end index of the points to consider (exclusive)\n+     * @return guessed root (will be a NaN if two points share the same y)\n+     */\n+    private double guessX(final double targetY, final double[] x, final double[] y,\n+                          final int start, final int end) {\n+\n+        // compute Q Newton coefficients by divided differences\n+        for (int i = start; i < end - 1; ++i) {\n+            final int delta = i + 1 - start;\n+            for (int j = end - 1; j > i; --j) {\n+                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n+            }\n+        }\n+\n+        // evaluate Q(targetY)\n+        double x0 = 0;\n+        for (int j = end - 1; j >= start; --j) {\n+            x0 = x[j] + x0 * (targetY - y[j]);\n+        }\n+\n+        return x0;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, UnivariateRealFunction f, double min,\n+                        double max, AllowedSolutions allowedSolutions) {\n+        this.allowed = allowedSolutions;\n+        return super.solve(maxEval, f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, UnivariateRealFunction f, double min,\n+                        double max, double startValue,\n+                        AllowedSolutions allowedSolutions) {\n+        this.allowed = allowedSolutions;\n+        return super.solve(maxEval, f, min, max, startValue);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test case for {@link BracketingNthOrderBrentSolver bracketing n<sup>th</sup> order Brent} solver.\n+ *\n+ * @version $Id$\n+ */\n+public final class BracketingNthOrderBrentSolverTest extends BaseSecantSolverAbstractTest {\n+    /** {@inheritDoc} */\n+    protected UnivariateRealSolver getSolver() {\n+        return new BracketingNthOrderBrentSolver();\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected int[] getQuinticEvalCounts() {\n+        return new int[] {1, 3, 8, 1, 9, 4, 8, 1, 12, 1, 14};\n+    }\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testInsufficientOrder1() {\n+        new BracketingNthOrderBrentSolver(1.0e-10, 1);\n+    }\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testInsufficientOrder2() {\n+        new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1);\n+    }\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testInsufficientOrder3() {\n+        new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 1);\n+    }\n+\n+    @Test\n+    public void testConstructorsOK() {\n+        Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 2).getMaximalOrder());\n+        Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 2).getMaximalOrder());\n+        Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 2).getMaximalOrder());\n+    }\n+\n+    @Test\n+    public void testConvergenceOnFunctionAccuracy() {\n+        BracketingNthOrderBrentSolver solver =\n+                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 0.001, 3);\n+        QuinticFunction f = new QuinticFunction();\n+        double result = solver.solve(20, f, 0.2, 0.9, 0.4, AllowedSolutions.BELOW_SIDE);\n+        Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());\n+        Assert.assertTrue(f.value(result) <= 0);\n+        Assert.assertTrue(result - 0.5 > solver.getAbsoluteAccuracy());\n+        result = solver.solve(20, f, -0.9, -0.2,  -0.4, AllowedSolutions.ABOVE_SIDE);\n+        Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());\n+        Assert.assertTrue(f.value(result) >= 0);\n+        Assert.assertTrue(result + 0.5 < -solver.getAbsoluteAccuracy());\n+    }\n+\n+    @Test\n+    public void testFasterThanNewton() {\n+        // the following test functions come from Beny Neta's paper:\n+        // \"Several New Methods for solving Equations\"\n+        // intern J. Computer Math Vol 23 pp 265-282\n+        // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF\n+        // the reference roots have been computed by the Dfp solver to more than\n+        // 80 digits and checked with emacs (only the first 20 digits are reproduced here)\n+        compare(new TestFunction(0.0, -2, 2) {\n+            public double value(double x)      { return FastMath.sin(x) - 0.5 * x; }\n+            public double derivative(double x) { return FastMath.cos(x) - 0.5; }\n+        });\n+        compare(new TestFunction(6.3087771299726890947, -5, 10) {\n+            public double value(double x)      { return FastMath.pow(x, 5) + x - 10000; }\n+            public double derivative(double x) { return 5 * FastMath.pow(x, 4) + 1; }\n+        });\n+        compare(new TestFunction(9.6335955628326951924, 0.001, 10) {\n+            public double value(double x)      { return FastMath.sqrt(x) - 1 / x - 3; }\n+            public double derivative(double x) { return 0.5 / FastMath.sqrt(x) + 1 / (x * x); }\n+        });\n+        compare(new TestFunction(2.8424389537844470678, -5, 5) {\n+            public double value(double x)      { return FastMath.exp(x) + x - 20; }\n+            public double derivative(double x) { return FastMath.exp(x) + 1; }\n+        });\n+        compare(new TestFunction(8.3094326942315717953, 0.001, 10) {\n+            public double value(double x)      { return FastMath.log(x) + FastMath.sqrt(x) - 5; }\n+            public double derivative(double x) { return 1 / x + 0.5 / FastMath.sqrt(x); }\n+        });\n+        compare(new TestFunction(1.4655712318767680266, -0.5, 1.5) {\n+            public double value(double x)      { return (x - 1) * x * x - 1; }\n+            public double derivative(double x) { return (3 * x - 2) * x; }\n+        });\n+\n+    }\n+\n+    private void compare(TestFunction f) {\n+        compare(f, f.getRoot(), f.getMin(), f.getMax());\n+    }\n+\n+    private void compare(DifferentiableUnivariateRealFunction f,\n+                         double root, double min, double max) {\n+        NewtonSolver newton = new NewtonSolver(1.0e-12);\n+        BracketingNthOrderBrentSolver bracketing =\n+                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-12, 1.0e-18, 5);\n+        double resultN;\n+        try {\n+            resultN = newton.solve(100, f, min, max);\n+        } catch (TooManyEvaluationsException tmee) {\n+            resultN = Double.NaN;\n+        }\n+        double resultB;\n+        try {\n+            resultB = bracketing.solve(100, f, min, max);\n+        } catch (TooManyEvaluationsException tmee) {\n+            resultB = Double.NaN;\n+        }\n+        Assert.assertEquals(root, resultN, newton.getAbsoluteAccuracy());\n+        Assert.assertEquals(root, resultB, bracketing.getAbsoluteAccuracy());\n+        Assert.assertTrue(bracketing.getEvaluations() < newton.getEvaluations());\n+    }\n+\n+    private static abstract class TestFunction implements DifferentiableUnivariateRealFunction {\n+\n+        private final double root;\n+        private final double min;\n+        private final double max;\n+\n+        protected TestFunction(final double root, final double min, final double max) {\n+            this.root = root;\n+            this.min  = min;\n+            this.max  = max;\n+        }\n+\n+        public double getRoot() {\n+            return root;\n+        }\n+\n+        public double getMin() {\n+            return min;\n+        }\n+\n+        public double getMax() {\n+            return max;\n+        }\n+\n+        public abstract double value(double x);\n+\n+        public abstract double derivative(double x);\n+\n+        public UnivariateRealFunction derivative() {\n+            return new UnivariateRealFunction() {\n+                public double value(double x) {\n+                     return derivative(x);\n+                }\n+            };\n+        }\n+\n+    }\n+\n+}", "timestamp": 1311954261, "metainfo": ""}