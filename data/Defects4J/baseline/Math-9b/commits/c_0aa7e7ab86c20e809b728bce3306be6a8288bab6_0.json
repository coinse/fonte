{"sha": "0aa7e7ab86c20e809b728bce3306be6a8288bab6", "log": "Added throw declarations for package complex.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n import java.util.List;\n \n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n      * @since 1.2\n      */\n     public Complex acos() {\n-        if (isNaN) {\n-            return NaN;\n-        }\n-\n-        return this.add(this.sqrt1z().multiply(I)).log()\n-            .multiply(I.negate());\n+        try {\n+            if (isNaN) {\n+                return NaN;\n+            }\n+\n+            return this.add(this.sqrt1z().multiply(I)).log()\n+                    .multiply(I.negate());\n+        } catch (NullArgumentException e) {\n+            // this should never happen as intermediat results are not null\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @since 1.2\n      */\n     public Complex asin() {\n-        if (isNaN) {\n-            return NaN;\n-        }\n-\n-        return sqrt1z().add(this.multiply(I)).log()\n-            .multiply(I.negate());\n+        try {\n+            if (isNaN) {\n+                return NaN;\n+            }\n+\n+            return sqrt1z().add(this.multiply(I)).log()\n+                    .multiply(I.negate());\n+        } catch (NullArgumentException e) {\n+            // this should never happen as intermediat results are not null\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @since 1.2\n      */\n     public Complex atan() {\n-        if (isNaN) {\n-            return NaN;\n-        }\n-\n-        return this.add(I).divide(I.subtract(this)).log()\n-            .multiply(I.divide(createComplex(2.0, 0.0)));\n+        try {\n+            if (isNaN) {\n+                return NaN;\n+            }\n+\n+            return this.add(I).divide(I.subtract(this)).log()\n+                    .multiply(I.divide(createComplex(2.0, 0.0)));\n+        } catch (NullArgumentException e) {\n+            // this should never happen as intermediat results are not null\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @since 1.2\n      */\n     public Complex sqrt1z() {\n-        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n+        try {\n+            return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n+        } catch (NullArgumentException e) {\n+            // this should never happen as intermediat results are not null\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @throws NotPositiveException if {@code n <= 0}.\n      * @since 2.0\n      */\n-    public List<Complex> nthRoot(int n) {\n+    public List<Complex> nthRoot(int n) throws NotPositiveException {\n \n         if (n <= 0) {\n             throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n--- a/src/main/java/org/apache/commons/math3/complex/ComplexFormat.java\n+++ b/src/main/java/org/apache/commons/math3/complex/ComplexFormat.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n-import org.apache.commons.math3.util.CompositeFormat;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.exception.MathParseException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.MathParseException;\n+import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.CompositeFormat;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n      * default number format for both real and imaginary parts.\n      */\n     public ComplexFormat() {\n-        this(DEFAULT_IMAGINARY_CHARACTER, CompositeFormat.getDefaultNumberFormat());\n+        this.imaginaryCharacter = DEFAULT_IMAGINARY_CHARACTER;\n+        this.imaginaryFormat = CompositeFormat.getDefaultNumberFormat();\n+        this.realFormat = imaginaryFormat;\n     }\n \n     /**\n      * Create an instance with a custom number format for both real and\n      * imaginary parts.\n      * @param format the custom format for both real and imaginary parts.\n-     */\n-    public ComplexFormat(NumberFormat format) {\n-        this(DEFAULT_IMAGINARY_CHARACTER, format);\n+     * @throws NullArgumentException if {@code realFormat} is {@code null}.\n+     */\n+    public ComplexFormat(NumberFormat format) throws NullArgumentException {\n+        if (format == null) {\n+            throw new NullArgumentException(LocalizedFormats.IMAGINARY_FORMAT);\n+        }\n+        this.imaginaryCharacter = DEFAULT_IMAGINARY_CHARACTER;\n+        this.imaginaryFormat = format;\n+        this.realFormat = format;\n     }\n \n     /**\n      * custom number format for the imaginary part.\n      * @param realFormat the custom format for the real part.\n      * @param imaginaryFormat the custom format for the imaginary part.\n-     */\n-    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n-        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n+     * @throws NullArgumentException if {@code imaginaryFormat} is {@code null}.\n+     * @throws NullArgumentException if {@code realFormat} is {@code null}.\n+      */\n+    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat)\n+        throws NullArgumentException {\n+        if (imaginaryFormat == null) {\n+            throw new NullArgumentException(LocalizedFormats.IMAGINARY_FORMAT);\n+        }\n+        if (realFormat == null) {\n+            throw new NullArgumentException(LocalizedFormats.REAL_FORMAT);\n+        }\n+\n+        this.imaginaryCharacter = DEFAULT_IMAGINARY_CHARACTER;\n+        this.imaginaryFormat = imaginaryFormat;\n+        this.realFormat = realFormat;\n     }\n \n     /**\n      * Create an instance with a custom imaginary character, and the default\n      * number format for both real and imaginary parts.\n      * @param imaginaryCharacter The custom imaginary character.\n-     */\n-    public ComplexFormat(String imaginaryCharacter) {\n+     * @throws NullArgumentException if {@code imaginaryCharacter} is\n+     * {@code null}.\n+     * @throws NoDataException if {@code imaginaryCharacter} is an\n+     * empty string.\n+     */\n+    public ComplexFormat(String imaginaryCharacter)\n+        throws NullArgumentException, NoDataException {\n         this(imaginaryCharacter, CompositeFormat.getDefaultNumberFormat());\n     }\n \n      * format for both real and imaginary parts.\n      * @param imaginaryCharacter The custom imaginary character.\n      * @param format the custom format for both real and imaginary parts.\n-     */\n-    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n+     * @throws NullArgumentException if {@code imaginaryCharacter} is\n+     * {@code null}.\n+     * @throws NoDataException if {@code imaginaryCharacter} is an\n+     * empty string.\n+     * @throws NullArgumentException if {@code format} is {@code null}.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat format)\n+        throws NullArgumentException, NoDataException {\n         this(imaginaryCharacter, format, format);\n     }\n \n      */\n     public ComplexFormat(String imaginaryCharacter,\n                          NumberFormat realFormat,\n-                         NumberFormat imaginaryFormat) {\n+                         NumberFormat imaginaryFormat)\n+        throws NullArgumentException, NoDataException {\n         if (imaginaryCharacter == null) {\n             throw new NullArgumentException();\n         }\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws IllegalArgumentException is {@code obj} is not a valid type.\n+     * @throws MathIllegalArgumentException is {@code obj} is not a valid type.\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-                               FieldPosition pos) {\n+                               FieldPosition pos)\n+        throws MathIllegalArgumentException {\n \n         StringBuffer ret = null;\n \n      * @return the complex format specific to the given locale.\n      */\n     public static ComplexFormat getInstance(Locale locale) {\n-        NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n-        return new ComplexFormat(f);\n+        try {\n+            NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n+            return new ComplexFormat(f);\n+        } catch (NullArgumentException nae) {\n+            // this should never happen\n+            throw new MathInternalError(nae);\n+        }\n     }\n \n     /**\n      * @param locale the specific locale used by the format.\n      * @param imaginaryCharacter Imaginary character.\n      * @return the complex format specific to the given locale.\n-     */\n-    public static ComplexFormat getInstance(String imaginaryCharacter,\n-                                            Locale locale) {\n+     * @throws NullArgumentException if {@code imaginaryCharacter} is\n+     * {@code null}.\n+     * @throws NoDataException if {@code imaginaryCharacter} is an\n+     * empty string.\n+     */\n+    public static ComplexFormat getInstance(String imaginaryCharacter, Locale locale)\n+        throws NullArgumentException, NoDataException {\n         NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n         return new ComplexFormat(imaginaryCharacter, f);\n     }\n      * @throws MathParseException if the beginning of the specified string\n      * cannot be parsed.\n      */\n-    public Complex parse(String source) {\n+    public Complex parse(String source) throws MathParseException {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Complex result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n--- a/src/main/java/org/apache/commons/math3/complex/ComplexUtils.java\n+++ b/src/main/java/org/apache/commons/math3/complex/ComplexUtils.java\n      * @throws MathIllegalArgumentException if {@code r} is negative.\n      * @since 1.1\n      */\n-    public static Complex polar2Complex(double r, double theta) {\n+    public static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {\n         if (r < 0) {\n             throw new MathIllegalArgumentException(\n                   LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);", "timestamp": 1346869808, "metainfo": ""}