{"sha": "654e874a0505edeee9096d72cf86a39bf437f26d", "log": "Added and used a specialized exception for continued fraction convergence errors  ", "commit": "\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.fraction;\n-\n-import java.math.BigInteger;\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.util.MathUtils;\n-\n-/**\n- * Representation of a rational number.\n- *\n- * @since 1.1\n- * @version $Revision$ $Date$\n- */\n-public class Fraction extends Number implements Comparable {\n-\n-    /** A fraction representing \"1 / 1\". */\n-    public static final Fraction ONE = new Fraction(1, 1);\n-\n-    /** A fraction representing \"0 / 1\". */\n-    public static final Fraction ZERO = new Fraction(0, 1);\n-    \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = 65382027393090L;\n-    \n-    /** The denominator. */\n-    private int denominator;\n-    \n-    /** The numerator. */\n-    private int numerator;\n-\n-    /**\n-     * Create a fraction given the double value.\n-     * @param value the double value to convert to a fraction.\n-     * @throws ConvergenceException if the continued fraction failed to\n-     *         converge.\n-     */\n-    public Fraction(double value) throws ConvergenceException {\n-        this(value, 1.0e-5, 100);\n-    }\n-\n-    /**\n-     * Create a fraction given the double value.\n-     * <p>\n-     * References:\n-     * <ul>\n-     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n-     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n-     * </ul>\n-     * </p>\n-     * @param value the double value to convert to a fraction.\n-     * @param epsilon maximum error allowed.  The resulting fraction is within\n-     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n-     * @param maxIterations maximum number of convergents\n-     * @throws ConvergenceException if the continued fraction failed to\n-     *         converge.\n-     */\n-    public Fraction(double value, double epsilon, int maxIterations)\n-        throws ConvergenceException\n-    {\n-        double r0 = value;\n-        int a0 = (int)Math.floor(r0);\n-\n-        // check for (almost) integer arguments, which should not go\n-        // to iterations.\n-        if (Math.abs(a0 - value) < epsilon) {\n-            this.numerator = a0;\n-            this.denominator = 1;\n-            return;\n-        }\n-        \n-        int p0 = 1;\n-        int q0 = 0;\n-        int p1 = a0;\n-        int q1 = 1;\n-\n-        int p2 = 0;\n-        int q2 = 1;\n-\n-        int n = 0;\n-        boolean stop = false;\n-        do {\n-            ++n;\n-            double r1 = 1.0 / (r0 - a0);\n-            int a1 = (int)Math.floor(r1);\n-            p2 = (a1 * p1) + p0;\n-            q2 = (a1 * q1) + q0;\n-            \n-            double convergent = (double)p2 / (double)q2;\n-            if (n < maxIterations && Math.abs(convergent - value) > epsilon) {\n-                p0 = p1;\n-                p1 = p2;\n-                q0 = q1;\n-                q1 = q2;\n-                a0 = a1;\n-                r0 = r1;\n-            } else {\n-                stop = true;\n-            }\n-        } while (!stop);\n-\n-        if (n >= maxIterations) {\n-            throw new ConvergenceException(\n-                    \"Unable to convert double to fraction\");\n-        }\n-        \n-        this.numerator = p2;\n-        this.denominator = q2;\n-        reduce();\n-    }\n-    \n-    /**\n-     * Create a fraction given the numerator and denominator.  The fraction is\n-     * reduced to lowest terms.\n-     * @param num the numerator.\n-     * @param den the denominator.\n-     * @throws ArithmeticException if the denomiator is <code>zero</code>\n-     */\n-    public Fraction(int num, int den) {\n-        super();\n-        if (den == 0) {\n-            throw new ArithmeticException(\"The denominator must not be zero\");\n-        }\n-        if (den < 0) {\n-            if (num == Integer.MIN_VALUE ||\n-                    den == Integer.MIN_VALUE) {\n-                throw new ArithmeticException(\"overflow: can't negate\");\n-            }\n-            num = -num;\n-            den = -den;\n-        }\n-        this.numerator = num;\n-        this.denominator = den;\n-        reduce();\n-    }\n-    \n-    /**\n-     * Returns the absolute value of this fraction.\n-     * @return the absolute value.\n-     */\n-    public Fraction abs() {\n-        Fraction ret;\n-        if (numerator >= 0) {\n-            ret = this;\n-        } else {\n-            ret = negate();\n-        }\n-        return ret;        \n-    }\n-    \n-    /**\n-     * Compares this object to another based on size.\n-     * @param object the object to compare to\n-     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n-     *         than <tt>object</tt>, 0 if they are equal.\n-     */\n-    public int compareTo(Object object) {\n-        int ret = 0;\n-        \n-        if (this != object) { \n-            Fraction other = (Fraction)object;\n-            double first = doubleValue();\n-            double second = other.doubleValue();\n-            \n-            if (first < second) {\n-                ret = -1;\n-            } else if (first > second) {\n-                ret = 1;\n-            }\n-        }\n-        \n-        return ret;\n-    }\n-    \n-    /**\n-     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n-     * the numerator divided by denominator.\n-     * @return the fraction as a <tt>double</tt>\n-     */\n-    public double doubleValue() {\n-        return (double)numerator / (double)denominator;\n-    }\n-    \n-    /**\n-     * Test for the equality of two fractions.  If the lowest term\n-     * numerator and denominators are the same for both fractions, the two\n-     * fractions are considered to be equal.\n-     * @param other fraction to test for equality to this fraction\n-     * @return true if two fractions are equal, false if object is\n-     *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal\n-     *         to this fraction instance.\n-     */\n-    public boolean equals(Object other) {\n-        boolean ret;\n-        \n-        if (this == other) { \n-            ret = true;\n-        } else if (other == null) {\n-            ret = false;\n-        } else {\n-            try {\n-                // since fractions are always in lowest terms, numerators and\n-                // denominators can be compared directly for equality.\n-                Fraction rhs = (Fraction)other;\n-                ret = (numerator == rhs.numerator) &&\n-                    (denominator == rhs.denominator);\n-            } catch (ClassCastException ex) {\n-                // ignore exception\n-                ret = false;\n-            }\n-        }\n-        \n-        return ret;\n-    }\n-    \n-    /**\n-     * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n-     * the numerator divided by denominator.\n-     * @return the fraction as a <tt>float</tt>\n-     */\n-    public float floatValue() {\n-        return (float)doubleValue();\n-    }\n-    \n-    /**\n-     * Access the denominator.\n-     * @return the denominator.\n-     */\n-    public int getDenominator() {\n-        return denominator;\n-    }\n-    \n-    /**\n-     * Access the numerator.\n-     * @return the numerator.\n-     */\n-    public int getNumerator() {\n-        return numerator;\n-    }\n-    \n-    /**\n-     * Gets a hashCode for the fraction.\n-     * @return a hash code value for this object\n-     */\n-    public int hashCode() {\n-        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n-    }\n-    \n-    /**\n-     * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n-     * of the fraction.\n-     * @return the whole number fraction part\n-     */\n-    public int intValue() {\n-        return (int)doubleValue();\n-    }\n-    \n-    /**\n-     * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n-     * of the fraction.\n-     * @return the whole number fraction part\n-     */\n-    public long longValue() {\n-        return (long)doubleValue();\n-    }\n-    \n-    /**\n-     * Return the additive inverse of this fraction.\n-     * @return the negation of this fraction.\n-     */\n-    public Fraction negate() {\n-        if (numerator==Integer.MIN_VALUE) {\n-            throw new ArithmeticException(\"overflow: too large to negate\");\n-        }\n-        return new Fraction(-numerator, denominator);\n-    }\n-\n-    /**\n-     * Return the multiplicative inverse of this fraction.\n-     * @return the reciprocal fraction\n-     */\n-    public Fraction reciprocal() {\n-        return new Fraction(denominator, numerator);\n-    }\n-    \n-    /**\n-     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n-     * The algorithm follows Knuth, 4.5.1.</p>\n-     *\n-     * @param fraction  the fraction to add, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n-     */\n-    public Fraction add(Fraction fraction) {\n-        return addSub(fraction, true /* add */);\n-    }\n-\n-    /**\n-     * <p>Subtracts the value of another fraction from the value of this one, \n-     * returning the result in reduced form.</p>\n-     *\n-     * @param fraction  the fraction to subtract, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator\n-     *   cannot be represented in an <code>int</code>.\n-     */\n-    public Fraction subtract(Fraction fraction) {\n-        return addSub(fraction, false /* subtract */);\n-    }\n-\n-    /** \n-     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n-     * \n-     * @param fraction the fraction to subtract, must not be <code>null</code>\n-     * @param isAdd true to add, false to subtract\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator\n-     *   cannot be represented in an <code>int</code>.\n-     */\n-    private Fraction addSub(Fraction fraction, boolean isAdd) {\n-        if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n-        }\n-        // zero is identity for addition.\n-        if (numerator == 0) {\n-            return isAdd ? fraction : fraction.negate();\n-        }\n-        if (fraction.numerator == 0) {\n-            return this;\n-        }     \n-        // if denominators are randomly distributed, d1 will be 1 about 61%\n-        // of the time.\n-        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n-        if (d1==1) {\n-            // result is ( (u*v' +/- u'v) / u'v')\n-            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n-            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n-            return new Fraction\n-                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n-                 MathUtils.subAndCheck(uvp, upv),\n-                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n-        }\n-        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n-        // exercise 7.  we're going to use a BigInteger.\n-        // t = u(v'/d1) +/- v(u'/d1)\n-        BigInteger uvp = BigInteger.valueOf(numerator)\n-        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n-        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n-        .multiply(BigInteger.valueOf(denominator/d1));\n-        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n-        // but d2 doesn't need extra precision because\n-        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n-        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n-        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n-\n-        // result is (t/d2) / (u'/d1)(v'/d2)\n-        BigInteger w = t.divide(BigInteger.valueOf(d2));\n-        if (w.bitLength() > 31) {\n-            throw new ArithmeticException\n-            (\"overflow: numerator too large after multiply\");\n-        }\n-        return new Fraction (w.intValue(), \n-                MathUtils.mulAndCheck(denominator/d1, \n-                        fraction.denominator/d2));\n-    }\n-\n-    /**\n-     * <p>Multiplies the value of this fraction by another, returning the \n-     * result in reduced form.</p>\n-     *\n-     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n-     */\n-    public Fraction multiply(Fraction fraction) {\n-        if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n-        }\n-        if (numerator == 0 || fraction.numerator == 0) {\n-            return ZERO;\n-        }\n-        // knuth 4.5.1\n-        // make sure we don't overflow unless the result *must* overflow.\n-        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n-        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n-        return getReducedFraction\n-        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n-                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n-    }\n-\n-    /**\n-     * <p>Divide the value of this fraction by another.</p>\n-     *\n-     * @param fraction  the fraction to divide by, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the fraction to divide by is zero\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n-     */\n-    public Fraction divide(Fraction fraction) {\n-        if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n-        }\n-        if (fraction.numerator == 0) {\n-            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n-        }\n-        return multiply(fraction.reciprocal());\n-    }\n-    \n-    /**\n-     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n-     * of a fraction Y/Z.</p>\n-     *\n-     * <p>Any negative signs are resolved to be on the numerator.</p>\n-     *\n-     * @param numerator  the numerator, for example the three in 'three sevenths'\n-     * @param denominator  the denominator, for example the seven in 'three sevenths'\n-     * @return a new fraction instance, with the numerator and denominator reduced\n-     * @throws ArithmeticException if the denominator is <code>zero</code>\n-     */\n-    public static Fraction getReducedFraction(int numerator, int denominator) {\n-        if (denominator == 0) {\n-            throw new ArithmeticException(\"The denominator must not be zero\");\n-        }\n-        if (numerator==0) {\n-            return ZERO; // normalize zero.\n-        }\n-        // allow 2^k/-2^31 as a valid fraction (where k>0)\n-        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n-            numerator/=2; denominator/=2;\n-        }\n-        if (denominator < 0) {\n-            if (numerator==Integer.MIN_VALUE ||\n-                    denominator==Integer.MIN_VALUE) {\n-                throw new ArithmeticException(\"overflow: can't negate\");\n-            }\n-            numerator = -numerator;\n-            denominator = -denominator;\n-        }\n-        // simplify fraction.\n-        int gcd = MathUtils.gcd(numerator, denominator);\n-        numerator /= gcd;\n-        denominator /= gcd;\n-        return new Fraction(numerator, denominator);\n-    }\n-    \n-    /**\n-     * Reduce this fraction to lowest terms.  This is accomplished by dividing\n-     * both numerator and denominator by their greatest common divisor.\n-     */\n-    private void reduce() {\n-        // reduce numerator and denominator by greatest common denominator.\n-        int d = MathUtils.gcd(numerator, denominator);\n-        if (d > 1) {\n-            numerator /= d;\n-            denominator /= d;\n-        }\n-\n-        // move sign to numerator.\n-        if (denominator < 0) {\n-            numerator *= -1;\n-            denominator *= -1;\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigInteger;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Representation of a rational number.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class Fraction extends Number implements Comparable {\n+\n+    /** A fraction representing \"1 / 1\". */\n+    public static final Fraction ONE = new Fraction(1, 1);\n+\n+    /** A fraction representing \"0 / 1\". */\n+    public static final Fraction ZERO = new Fraction(0, 1);\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 6222990762865980424L;\n+\n+    \n+    /** The denominator. */\n+    private int denominator;\n+    \n+    /** The numerator. */\n+    private int numerator;\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * @param value the double value to convert to a fraction.\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    public Fraction(double value) throws FractionConversionException {\n+        this(value, 1.0e-5, 100);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * @param value the double value to convert to a fraction.\n+     * @param epsilon maximum error allowed.  The resulting fraction is within\n+     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxIterations maximum number of convergents\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    public Fraction(double value, double epsilon, int maxIterations)\n+        throws FractionConversionException\n+    {\n+        double r0 = value;\n+        int a0 = (int)Math.floor(r0);\n+\n+        // check for (almost) integer arguments, which should not go\n+        // to iterations.\n+        if (Math.abs(a0 - value) < epsilon) {\n+            this.numerator = a0;\n+            this.denominator = 1;\n+            return;\n+        }\n+        \n+        int p0 = 1;\n+        int q0 = 0;\n+        int p1 = a0;\n+        int q1 = 1;\n+\n+        int p2 = 0;\n+        int q2 = 1;\n+\n+        int n = 0;\n+        boolean stop = false;\n+        do {\n+            ++n;\n+            double r1 = 1.0 / (r0 - a0);\n+            int a1 = (int)Math.floor(r1);\n+            p2 = (a1 * p1) + p0;\n+            q2 = (a1 * q1) + q0;\n+            \n+            double convergent = (double)p2 / (double)q2;\n+            if (n < maxIterations && Math.abs(convergent - value) > epsilon) {\n+                p0 = p1;\n+                p1 = p2;\n+                q0 = q1;\n+                q1 = q2;\n+                a0 = a1;\n+                r0 = r1;\n+            } else {\n+                stop = true;\n+            }\n+        } while (!stop);\n+\n+        if (n >= maxIterations) {\n+            throw new FractionConversionException(value, maxIterations);\n+        }\n+        \n+        this.numerator = p2;\n+        this.denominator = q2;\n+        reduce();\n+    }\n+    \n+    /**\n+     * Create a fraction given the numerator and denominator.  The fraction is\n+     * reduced to lowest terms.\n+     * @param num the numerator.\n+     * @param den the denominator.\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     */\n+    public Fraction(int num, int den) {\n+        super();\n+        if (den == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (den < 0) {\n+            if (num == Integer.MIN_VALUE ||\n+                    den == Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            num = -num;\n+            den = -den;\n+        }\n+        this.numerator = num;\n+        this.denominator = den;\n+        reduce();\n+    }\n+    \n+    /**\n+     * Returns the absolute value of this fraction.\n+     * @return the absolute value.\n+     */\n+    public Fraction abs() {\n+        Fraction ret;\n+        if (numerator >= 0) {\n+            ret = this;\n+        } else {\n+            ret = negate();\n+        }\n+        return ret;        \n+    }\n+    \n+    /**\n+     * Compares this object to another based on size.\n+     * @param object the object to compare to\n+     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n+     *         than <tt>object</tt>, 0 if they are equal.\n+     */\n+    public int compareTo(Object object) {\n+        int ret = 0;\n+        \n+        if (this != object) { \n+            Fraction other = (Fraction)object;\n+            double first = doubleValue();\n+            double second = other.doubleValue();\n+            \n+            if (first < second) {\n+                ret = -1;\n+            } else if (first > second) {\n+                ret = 1;\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * @return the fraction as a <tt>double</tt>\n+     */\n+    public double doubleValue() {\n+        return (double)numerator / (double)denominator;\n+    }\n+    \n+    /**\n+     * Test for the equality of two fractions.  If the lowest term\n+     * numerator and denominators are the same for both fractions, the two\n+     * fractions are considered to be equal.\n+     * @param other fraction to test for equality to this fraction\n+     * @return true if two fractions are equal, false if object is\n+     *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal\n+     *         to this fraction instance.\n+     */\n+    public boolean equals(Object other) {\n+        boolean ret;\n+        \n+        if (this == other) { \n+            ret = true;\n+        } else if (other == null) {\n+            ret = false;\n+        } else {\n+            try {\n+                // since fractions are always in lowest terms, numerators and\n+                // denominators can be compared directly for equality.\n+                Fraction rhs = (Fraction)other;\n+                ret = (numerator == rhs.numerator) &&\n+                    (denominator == rhs.denominator);\n+            } catch (ClassCastException ex) {\n+                // ignore exception\n+                ret = false;\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * @return the fraction as a <tt>float</tt>\n+     */\n+    public float floatValue() {\n+        return (float)doubleValue();\n+    }\n+    \n+    /**\n+     * Access the denominator.\n+     * @return the denominator.\n+     */\n+    public int getDenominator() {\n+        return denominator;\n+    }\n+    \n+    /**\n+     * Access the numerator.\n+     * @return the numerator.\n+     */\n+    public int getNumerator() {\n+        return numerator;\n+    }\n+    \n+    /**\n+     * Gets a hashCode for the fraction.\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n+    }\n+    \n+    /**\n+     * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n+     * of the fraction.\n+     * @return the whole number fraction part\n+     */\n+    public int intValue() {\n+        return (int)doubleValue();\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n+     * of the fraction.\n+     * @return the whole number fraction part\n+     */\n+    public long longValue() {\n+        return (long)doubleValue();\n+    }\n+    \n+    /**\n+     * Return the additive inverse of this fraction.\n+     * @return the negation of this fraction.\n+     */\n+    public Fraction negate() {\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: too large to negate\");\n+        }\n+        return new Fraction(-numerator, denominator);\n+    }\n+\n+    /**\n+     * Return the multiplicative inverse of this fraction.\n+     * @return the reciprocal fraction\n+     */\n+    public Fraction reciprocal() {\n+        return new Fraction(denominator, numerator);\n+    }\n+    \n+    /**\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n+     *\n+     * @param fraction  the fraction to add, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        // zero is identity for addition.\n+        if (numerator == 0) {\n+            return isAdd ? fraction : fraction.negate();\n+        }\n+        if (fraction.numerator == 0) {\n+            return this;\n+        }     \n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n+            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n+                 MathUtils.subAndCheck(uvp, upv),\n+                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+        .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw new ArithmeticException\n+            (\"overflow: numerator too large after multiply\");\n+        }\n+        return new Fraction (w.intValue(), \n+                MathUtils.mulAndCheck(denominator/d1, \n+                        fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction multiply(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (numerator == 0 || fraction.numerator == 0) {\n+            return ZERO;\n+        }\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n+        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n+        return getReducedFraction\n+        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n+                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n+     *\n+     * @param fraction  the fraction to divide by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction divide(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (fraction.numerator == 0) {\n+            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+        }\n+        return multiply(fraction.reciprocal());\n+    }\n+    \n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance, with the numerator and denominator reduced\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public static Fraction getReducedFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        // simplify fraction.\n+        int gcd = MathUtils.gcd(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n+    }\n+    \n+    /**\n+     * Reduce this fraction to lowest terms.  This is accomplished by dividing\n+     * both numerator and denominator by their greatest common divisor.\n+     */\n+    private void reduce() {\n+        // reduce numerator and denominator by greatest common denominator.\n+        int d = MathUtils.gcd(numerator, denominator);\n+        if (d > 1) {\n+            numerator /= d;\n+            denominator /= d;\n+        }\n+\n+        // move sign to numerator.\n+        if (denominator < 0) {\n+            numerator *= -1;\n+            denominator *= -1;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n+package org.apache.commons.math.fraction;\n+\n+import org.apache.commons.math.MaxIterationsExceededException;\n+\n+public class FractionConversionException extends MaxIterationsExceededException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4588659344016668813L;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param value double value to convert\n+     * @param maxIterations maximal number of iterations allowed\n+     */\n+    public FractionConversionException(double value, int maxIterations) {\n+        super(maxIterations,\n+              \"Unable to convert {0} to fraction after {1} iterations\",\n+              new Object[] { new Double(value), new Integer(maxIterations) });\n+    }\n+\n+}", "timestamp": 1171308197, "metainfo": ""}