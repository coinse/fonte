{"sha": "d370aea4cafe989b86ba397e7cf4fc203545194f", "log": "MATH-887 Made \"GaussNewtonOptimizer\" use the new methods in base class \"AbstractLeastSquaresOptimizer\" instead of modifying the (now deprecated) protected fields.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.java\n package org.apache.commons.math3.optimization.general;\n \n import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n  * @since 2.0\n  *\n  */\n-\n public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n     /** Indicator for using LU decomposition. */\n     private final boolean useLU;\n     /** {@inheritDoc} */\n     @Override\n     public PointVectorValuePair doOptimize() {\n-\n         final ConvergenceChecker<PointVectorValuePair> checker\n             = getConvergenceChecker();\n+\n+        // Computation will be useless without a checker (see \"for-loop\").\n+        if (checker == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        final double[] targetValues = getTarget();\n+        final int nR = targetValues.length; // Number of observed data.\n+\n+        final RealMatrix weightMatrix = getWeight();\n+        // Diagonal of the weight matrix.\n+        final double[] residualsWeights = new double[nR];\n+        for (int i = 0; i < nR; i++) {\n+            residualsWeights[i] = weightMatrix.getEntry(i, i);\n+        }\n+\n+        double[] currentPoint = getStartPoint();\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n-            updateResidualsAndCost();\n-            updateJacobian();\n-            current = new PointVectorValuePair(point, objective);\n-\n-            final double[] targetValues = getTargetRef();\n-            final double[] residualsWeights = getWeightRef();\n+            // Value of the objective function at \"currentPoint\".\n+            final double[] currentObjective = computeObjectiveValue(currentPoint);\n+            final double[] currentResiduals = computeResiduals(currentObjective);\n+            final RealMatrix weightedJacobian = computeJacobian(currentPoint);\n+            current = new PointVectorValuePair(currentPoint, currentObjective);\n \n             // build the linear problem\n             final double[]   b = new double[cols];\n             final double[][] a = new double[cols][cols];\n             for (int i = 0; i < rows; ++i) {\n \n-                final double[] grad   = weightedResidualJacobian[i];\n+                final double[] grad   = weightedJacobian.getRow(i);\n                 final double weight   = residualsWeights[i];\n-                final double residual = objective[i] - targetValues[i];\n+                // XXX Minus sign could be left out if \"weightedJacobian\"\n+                // would be defined differently.\n+                final double residual = -currentResiduals[i];\n \n                 // compute the normal equation\n                 final double wr = weight * residual;\n                 final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                 // update the estimated parameters\n                 for (int i = 0; i < cols; ++i) {\n-                    point[i] += dX[i];\n+                    currentPoint[i] += dX[i];\n                 }\n             } catch (SingularMatrixException e) {\n                 throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n             }\n \n-            // check convergence\n-            if (checker != null) {\n-                if (previous != null) {\n-                    converged = checker.converged(iter, previous, current);\n+            // Check convergence.\n+            if (previous != null) {\n+                converged = checker.converged(iter, previous, current);\n+                if (converged) {\n+                    cost = computeCost(currentResiduals);\n+                    return current;\n                 }\n             }\n         }\n-        // we have converged\n-        return current;\n+        // Must never happen.\n+        throw new MathInternalError();\n     }\n }", "timestamp": 1352378934, "metainfo": ""}