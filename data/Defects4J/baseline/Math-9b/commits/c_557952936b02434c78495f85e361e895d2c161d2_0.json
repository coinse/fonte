{"sha": "557952936b02434c78495f85e361e895d2c161d2", "log": "Simplified SubLine API by introducing a public Segment class.  JIRA: MATH-592  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n \n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.Interval;\n+import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.partitioning.AbstractSubHyperplane;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n+import org.apache.commons.math.geometry.partitioning.BoundaryAttribute;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n+import org.apache.commons.math.geometry.partitioning.utilities.OrderedTuple;\n import org.apache.commons.math.util.FastMath;\n \n /** This class represents a 2D region: a set of polygons.\n                 // sort the segments according to their start point\n                 final SegmentsBuilder visitor = new SegmentsBuilder();\n                 getTree(true).visit(visitor);\n-                final AVLTree<Segment> sorted = visitor.getSorted();\n+                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n \n                 // identify the loops, starting from the open ones\n                 // (their start segments are naturally at the sorted set beginning)\n-                final ArrayList<List<Segment>> loops = new ArrayList<List<Segment>>();\n+                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                 while (!sorted.isEmpty()) {\n-                    final AVLTree<Segment>.Node node = sorted.getSmallest();\n-                    final List<Segment> loop = followLoop(node, sorted);\n+                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n+                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                     if (loop != null) {\n                         loops.add(loop);\n                     }\n                 vertices = new Vector2D[loops.size()][];\n                 int i = 0;\n \n-                for (final List<Segment> loop : loops) {\n+                for (final List<ComparableSegment> loop : loops) {\n                     if (loop.size() < 2) {\n                         // single infinite line\n                         final Line line = loop.get(0).getLine();\n      * @return a list of connected sub-hyperplanes starting at\n      * {@code node}\n      */\n-    private List<Segment> followLoop(final AVLTree<Segment>.Node node,\n-                                     final AVLTree<Segment> sorted) {\n-\n-        final ArrayList<Segment> loop = new ArrayList<Segment>();\n-        Segment segment = node.getElement();\n+    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n+                                               final AVLTree<ComparableSegment> sorted) {\n+\n+        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n+        ComparableSegment segment = node.getElement();\n         loop.add(segment);\n         final Vector2D globalStart = segment.getStart();\n         Vector2D end = segment.getEnd();\n         while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n \n             // search the sub-hyperplane starting where the previous one ended\n-            AVLTree<Segment>.Node selectedNode = null;\n-            Segment       selectedSegment  = null;\n-            double        selectedDistance = Double.POSITIVE_INFINITY;\n-            final Segment lowerLeft        = new Segment(end, -1.0e-10, -1.0e-10);\n-            final Segment upperRight       = new Segment(end, +1.0e-10, +1.0e-10);\n-            for (AVLTree<Segment>.Node n = sorted.getNotSmaller(lowerLeft);\n+            AVLTree<ComparableSegment>.Node selectedNode = null;\n+            ComparableSegment       selectedSegment  = null;\n+            double                  selectedDistance = Double.POSITIVE_INFINITY;\n+            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n+            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n+            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                  (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                  n = n.getNext()) {\n-                segment = (Segment) n.getElement();\n+                segment = n.getElement();\n                 final double distance = end.distance(segment.getStart());\n                 if (distance < selectedDistance) {\n                     selectedNode     = n;\n \n     }\n \n+    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n+\n+        /** Sorting key. */\n+        private OrderedTuple sortingKey;\n+\n+        /** Build a segment.\n+         * @param start start point of the segment\n+         * @param end end point of the segment\n+         * @param line line containing the segment\n+         */\n+        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n+            super(start, end, line);\n+            sortingKey = (start == null) ?\n+                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n+                         new OrderedTuple(start.getX(), start.getY());\n+        }\n+\n+        /** Build a dummy segment.\n+         * <p>\n+         * The object built is not a real segment, only the sorting key is used to\n+         * allow searching in the neighborhood of a point. This is an horrible hack ...\n+         * </p>\n+         * @param start start point of the segment\n+         * @param dx abscissa offset from the start point\n+         * @param dy ordinate offset from the start point\n+         */\n+        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n+            super(null, null, null);\n+            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int compareTo(final ComparableSegment o) {\n+            return sortingKey.compareTo(o.sortingKey);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean equals(final Object other) {\n+            if (this == other) {\n+                return true;\n+            } else if (other instanceof ComparableSegment) {\n+                return compareTo((ComparableSegment) other) == 0;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int hashCode() {\n+            return getStart().hashCode() ^ getEnd().hashCode() ^\n+                   getLine().hashCode() ^ sortingKey.hashCode();\n+        }\n+\n+    }\n+\n+    /** Visitor building segments. */\n+    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n+\n+        /** Sorted segments. */\n+        private AVLTree<ComparableSegment> sorted;\n+\n+        /** Simple constructor. */\n+        public SegmentsBuilder() {\n+            sorted = new AVLTree<ComparableSegment>();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n+            return Order.MINUS_SUB_PLUS;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n+            @SuppressWarnings(\"unchecked\")\n+            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n+            if (attribute.getPlusOutside() != null) {\n+                addContribution(attribute.getPlusOutside(), false);\n+            }\n+            if (attribute.getPlusInside() != null) {\n+                addContribution(attribute.getPlusInside(), true);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n+        }\n+\n+        /** Add he contribution of a boundary facet.\n+         * @param sub boundary facet\n+         * @param reversed if true, the facet has the inside on its plus side\n+         */\n+        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n+            @SuppressWarnings(\"unchecked\")\n+            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n+                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n+            final Line line      = (Line) sub.getHyperplane();\n+            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n+            for (final Interval i : intervals) {\n+                final Vector2D start = Double.isInfinite(i.getLower()) ?\n+                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n+                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n+                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n+                if (reversed) {\n+                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n+                } else {\n+                    sorted.insert(new ComparableSegment(start, end, line));\n+                }\n+            }\n+        }\n+\n+        /** Get the sorted segments.\n+         * @return sorted segments\n+         */\n+        public AVLTree<ComparableSegment> getSorted() {\n+            return sorted;\n+        }\n+\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Segment.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Segment.java\n  */\n package org.apache.commons.math.geometry.euclidean.twod;\n \n-import org.apache.commons.math.geometry.partitioning.utilities.OrderedTuple;\n \n-/** This class holds segments information before they are connected.\n+/** Simple container for a two-points segment.\n  * @version $Id$\n  * @since 3.0\n  */\n-class Segment implements Comparable<Segment> {\n+public class Segment {\n \n     /** Start point of the segment. */\n-    private final Vector2D      start;\n+    private final Vector2D start;\n \n     /** End point of the segments. */\n-    private final Vector2D      end;\n+    private final Vector2D end;\n \n     /** Line containing the segment. */\n-    private final Line         line;\n-\n-    /** Sorting key. */\n-    private      OrderedTuple sortingKey;\n+    private final Line     line;\n \n     /** Build a segment.\n      * @param start start point of the segment\n         this.start  = start;\n         this.end    = end;\n         this.line   = line;\n-        sortingKey = (start == null) ?\n-                     new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n-                     new OrderedTuple(start.getX(), start.getY());\n-    }\n-\n-    /** Build a dummy segment.\n-     * <p>\n-     * The object built is not a real segment, only the sorting key is used to\n-     * allow searching in the neighborhood of a point. This is an horrible hack ...\n-     * </p>\n-     * @param start start point of the segment\n-     * @param dx abscissa offset from the start point\n-     * @param dy ordinate offset from the start point\n-     */\n-    public Segment(final Vector2D start, final double dx, final double dy) {\n-        this.start = null;\n-        this.end   = null;\n-        this.line  = null;\n-        sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n     }\n \n     /** Get the start point of the segment.\n         return line;\n     }\n \n-    /** {@inheritDoc} */\n-    public int compareTo(final Segment o) {\n-        return sortingKey.compareTo(o.sortingKey);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public boolean equals(final Object other) {\n-        if (this == other) {\n-            return true;\n-        } else if (other instanceof Segment) {\n-            return compareTo((Segment) other) == 0;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public int hashCode() {\n-        return start.hashCode() ^ end.hashCode() ^ line.hashCode() ^ sortingKey.hashCode();\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n         super(new Line(start, end), buildIntervalSet(start, end));\n     }\n \n+    /** Create a sub-line from a segment.\n+     * @param segment single segment forming the sub-line\n+     */\n+    public SubLine(final Segment segment) {\n+        super(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n+    }\n+\n     /** Get the endpoints of the sub-line.\n      * <p>\n      * A subline may be any arbitrary number of disjoints segments, so the endpoints\n      * </p>\n      * @return list of segments endpoints\n      */\n-    public List<Vector2D[]> getSegments() {\n+    public List<Segment> getSegments() {\n \n         final Line line = (Line) getHyperplane();\n         final List<Interval> list = ((IntervalsSet) getRemainingRegion()).asList();\n-        final List<Vector2D[]> segments = new ArrayList<Vector2D[]>();\n+        final List<Segment> segments = new ArrayList<Segment>();\n \n         for (final Interval interval : list) {\n             final Vector2D start = line.toSpace(new Vector1D(interval.getLower()));\n             final Vector2D end   = line.toSpace(new Vector1D(interval.getUpper()));\n-            segments.add(new Vector2D[] { start, end });\n+            segments.add(new Segment(start, end, line));\n         }\n \n         return segments;\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/twod/SubLineTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/twod/SubLineTest.java\n \n     @Test\n     public void testEndPoints() {\n-        SubLine sub = new SubLine(new Vector2D(-1, -7), new Vector2D(7, -1));\n-        List<Vector2D[]> segments = sub.getSegments();\n+        Vector2D p1 = new Vector2D(-1, -7);\n+        Vector2D p2 = new Vector2D(7, -1);\n+        Segment segment = new Segment(p1, p2, new Line(p1, p2));\n+        SubLine sub = new SubLine(segment);\n+        List<Segment> segments = sub.getSegments();\n         Assert.assertEquals(1, segments.size());\n-        Assert.assertEquals(-1, segments.get(0)[0].getX(), 1.0e-10);\n-        Assert.assertEquals(-7, segments.get(0)[0].getY(), 1.0e-10);\n-        Assert.assertEquals( 7, segments.get(0)[1].getX(), 1.0e-10);\n-        Assert.assertEquals(-1, segments.get(0)[1].getY(), 1.0e-10);\n+        Assert.assertEquals(0.0, new Vector2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10);\n+        Assert.assertEquals(0.0, new Vector2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10);\n     }\n \n     @Test\n     public void testNoEndPoints() {\n         SubLine wholeLine = new Line(new Vector2D(-1, 7), new Vector2D(7, 1)).wholeHyperplane();\n-        List<Vector2D[]> segments = wholeLine.getSegments();\n+        List<Segment> segments = wholeLine.getSegments();\n         Assert.assertEquals(1, segments.size());\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[0].getX()) &&\n-                          segments.get(0)[0].getX() < 0);\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[0].getY()) &&\n-                          segments.get(0)[0].getY() > 0);\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[1].getX()) &&\n-                          segments.get(0)[1].getX() > 0);\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[1].getY()) &&\n-                          segments.get(0)[1].getY() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&\n+                          segments.get(0).getStart().getX() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&\n+                          segments.get(0).getStart().getY() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&\n+                          segments.get(0).getEnd().getX() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&\n+                          segments.get(0).getEnd().getY() < 0);\n     }\n \n     @Test\n     public void testNoSegments() {\n         SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),\n                                     new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));\n-        List<Vector2D[]> segments = empty.getSegments();\n+        List<Segment> segments = empty.getSegments();\n         Assert.assertEquals(0, segments.size());\n     }\n \n         SubLine twoSubs = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),\n                                     new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2),\n                                                                            new IntervalsSet(3, 4)));\n-        List<Vector2D[]> segments = twoSubs.getSegments();\n+        List<Segment> segments = twoSubs.getSegments();\n         Assert.assertEquals(2, segments.size());\n     }\n \n     public void testHalfInfiniteNeg() {\n         SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),\n                                     new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0));\n-        List<Vector2D[]> segments = empty.getSegments();\n+        List<Segment> segments = empty.getSegments();\n         Assert.assertEquals(1, segments.size());\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[0].getX()) &&\n-                          segments.get(0)[0].getX() < 0);\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[0].getY()) &&\n-                          segments.get(0)[0].getY() < 0);\n-        Assert.assertEquals( 3, segments.get(0)[1].getX(), 1.0e-10);\n-        Assert.assertEquals(-4, segments.get(0)[1].getY(), 1.0e-10);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&\n+                          segments.get(0).getStart().getX() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&\n+                          segments.get(0).getStart().getY() < 0);\n+        Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10);\n     }\n \n     @Test\n     public void testHalfInfinitePos() {\n         SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),\n                                     new IntervalsSet(0.0, Double.POSITIVE_INFINITY));\n-        List<Vector2D[]> segments = empty.getSegments();\n+        List<Segment> segments = empty.getSegments();\n         Assert.assertEquals(1, segments.size());\n-        Assert.assertEquals( 3, segments.get(0)[0].getX(), 1.0e-10);\n-        Assert.assertEquals(-4, segments.get(0)[0].getY(), 1.0e-10);\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[1].getX()) &&\n-                          segments.get(0)[1].getX() > 0);\n-        Assert.assertTrue(Double.isInfinite(segments.get(0)[1].getY()) &&\n-                          segments.get(0)[1].getY() > 0);\n+        Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&\n+                          segments.get(0).getEnd().getX() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&\n+                          segments.get(0).getEnd().getY() > 0);\n     }\n \n     @Test", "timestamp": 1308597103, "metainfo": ""}