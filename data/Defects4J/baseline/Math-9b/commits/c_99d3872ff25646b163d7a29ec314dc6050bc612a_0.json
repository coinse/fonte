{"sha": "99d3872ff25646b163d7a29ec314dc6050bc612a", "log": "Rolling back to previous version.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  */\n public class StatUtils {\n \n-\t/**\n+    /**\n      * The sum of the values that have been added to Univariate.\n      * @param values Is a double[] containing the values\n      * @return the sum of the values or Double.NaN if the array is empty\n-\t */\n-\tpublic static double sum(double[] values) {\n-\t\tdouble accum = 0.0;\n-\t\tfor (int i = 0; i < values.length; i++) {\n-\t\t\taccum += values[i];\n-\t\t}\n-\t\treturn accum;\n-\t}\n-\n-\t/**\n+     */\n+    public static double sum(double[] values) {\n+        double accum = 0.0;\n+        for (int i = 0; i < values.length; i++) {\n+            accum += values[i];\n+        }\n+        return accum;\n+    }\n+\n+    /**\n      * Returns the sum of the squares of the available values.\n      * @param values Is a double[] containing the values\n      * @return the sum of the squared values or Double.NaN if the array is empty\n-\t */\n-\tpublic static double sumSq(double[] values) {\n-\t\tdouble accum = 0.0;\n-\t\tfor (int i = 0; i < values.length; i++) {\n-\t\t\taccum += Math.pow(values[i], 2.0);\n-\t\t}\n-\t\treturn accum;\n-\t}\n+     */\n+    public static double sumSq(double[] values) {\n+        double accum = 0.0;\n+        for (int i = 0; i < values.length; i++) {\n+            accum += Math.pow(values[i], 2.0);\n+        }\n+        return accum;\n+    }\n \n     /**\n      * Returns the product for this collection of values\n      */\n     public static double product(double[] values) {\n         double product = Double.NaN;\n-        if( values.length > 0 ) {\n+        if (values.length > 0) {\n             product = 1.0;\n-            for( int i = 0; i < values.length; i++) {\n+            for (int i = 0; i < values.length; i++) {\n                 product *= values[i];\n             }\n         }\n         return product;\n     }\n-    \n+\n     /**\n      * Returns the sum of the natural logs for this collection of values\n      * @param values Is a double[] containing the values\n      * @return the sumLog value or Double.NaN if the array is empty\n-\t */\n+     */\n     public static double sumLog(double[] values) {\n         double sumLog = Double.NaN;\n-        if( values.length > 0 ) {\n+        if (values.length > 0) {\n             sumLog = 0.0;\n-            for( int i = 0; i < values.length; i++) {\n+            for (int i = 0; i < values.length; i++) {\n                 sumLog += Math.log(values[i]);\n             }\n         }\n         return sumLog;\n     }\n-    \n+\n     /**\n      * Returns the geometric mean for this collection of values\n      * @param values Is a double[] containing the values\n      * @return the geometric mean or Double.NaN if the array is empty or\n      * any of the values are &lt;= 0.\n-\t */\n+     */\n     public static double geometricMean(double[] values) {\n-        return Math.exp(sumLog(values) / (double)values.length);\n-    }\n-\n-\t/**\n+        return Math.exp(sumLog(values) / (double) values.length);\n+    }\n+\n+    /**\n      * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n      * arithmetic mean </a> of the available values \n      * @param values Is a double[] containing the values\n      * @return the mean of the values or Double.NaN if the array is empty\n-\t */\n-\tpublic static double mean(double[] values) {\n-\t\treturn sum(values) / (double)values.length;\n-\t}\n+     */\n+    public static double mean(double[] values) {\n+        return sum(values) / (double) values.length;\n+    }\n \n     /**\n      *      \n         }\n         return (stdDev);\n     }\n-    \n-\t/**\n+\n+    /**\n      * Returns the variance of the available values. This uses a corrected\n      * two pass algorithm of the following \n      * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n      * @param values Is a double[] containing the values\n      * @return the result, Double.NaN if no values for an empty array \n      * or 0.0 for a single value set.  \n-\t */\n-\tpublic static double variance(double[] values) {\n-\t\tdouble variance = Double.NaN;\n-        \n-\t\tif (values.length == 1) {\n-\t\t\tvariance = 0;\n-\t\t} else if (values.length > 1) {\n-\t\t\tdouble mean = mean(values);\n-\t\t\tdouble accum = 0.0;\n+     */\n+    public static double variance(double[] values) {\n+        double variance = Double.NaN;\n+\n+        if (values.length == 1) {\n+            variance = 0;\n+        } else if (values.length > 1) {\n+            double mean = mean(values);\n+            double accum = 0.0;\n             double accum2 = 0.0;\n-\t\t\tfor (int i = 0; i < values.length; i++) {\n-\t\t\t\taccum += Math.pow((values[i] - mean), 2.0);\n+            for (int i = 0; i < values.length; i++) {\n+                accum += Math.pow((values[i] - mean), 2.0);\n                 accum2 += (values[i] - mean);\n-\t\t\t}\n-\t\t\tvariance = ((accum*(double)values.length) - Math.pow(accum2,2)) / \n-                (double)(values.length*(values.length - 1));\n-\t\t}\n-\t\treturn variance;\n-\t}\n+            }\n+            variance =\n+                (accum - (Math.pow(accum2, 2) / (double) values.length))\n+                    / (double) (values.length - 1);\n+        }\n+        return variance;\n+    }\n \n     /**\n      * Returns the skewness of a collection of values.  Skewness is a \n         double n = values.length;\n \n         double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n-        double termTwo = ((3 * Math.pow(n - 1, 2.0)) \n-                           / ((n - 2) * (n - 3))); \n+        double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n         // Calculate kurtosis\n         kurtosis = (coefficientOne * accum) - termTwo;\n \n         return kurtosis;\n     }\n-    \n-\t/**\n+\n+    /**\n      * Returns the maximum of the available values\n      * @param values Is a double[] containing the values\n-\t * @return the maximum of the values or Double.NaN if the array is empty\n-\t */\n-\tpublic static double max(double[] values) {\n-\t\tdouble max = Double.NaN;\n-\t\tfor (int i = 0; i < values.length; i++) {\n-\t\t\tif (i == 0) {\n-\t\t\t\tmax = values[i];\n-\t\t\t} else {\n-\t\t\t\tmax = Math.max(max, values[i]);\n-\t\t\t}\n-\t\t}\n-\t\treturn max;\n-\t}\n-\n-\t/**\n+     * @return the maximum of the values or Double.NaN if the array is empty\n+     */\n+    public static double max(double[] values) {\n+        double max = Double.NaN;\n+        for (int i = 0; i < values.length; i++) {\n+            if (i == 0) {\n+                max = values[i];\n+            } else {\n+                max = Math.max(max, values[i]);\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /**\n      * Returns the minimum of the available values\n      * @param values Is a double[] containing the values\n-\t * @return the minimum of the values or Double.NaN if the array is empty\n-\t */\n-\tpublic static double min(double[] values) {\n-\t\tdouble min = Double.NaN;\n-\t\tfor (int i = 0; i < values.length; i++) {\n-\t\t\tif (i == 0) {\n-\t\t\t\tmin = values[i];\n-\t\t\t} else {\n-\t\t\t\tmin = Math.min(min, values[i]);\n-\t\t\t}\n-\t\t}\n-\t\treturn min;\n-\t}\n-    \n+     * @return the minimum of the values or Double.NaN if the array is empty\n+     */\n+    public static double min(double[] values) {\n+        double min = Double.NaN;\n+        for (int i = 0; i < values.length; i++) {\n+            if (i == 0) {\n+                min = values[i];\n+            } else {\n+                min = Math.min(min, values[i]);\n+            }\n+        }\n+        return min;\n+    }\n+\n     /** \n      * Returns the mode of the values that have been added.  The mode is\n      * the element which occurs with the most frequency\n      * @return the mode\n      */\n-    public static double mode(){\n+    public static double mode() {\n         // Mode depends on a refactor Freq class\n         String msg = \"mode() is not yet implemented\";\n         throw new UnsupportedOperationException(msg);\n     }\n-    \n+\n     /** \n      * Returns the mode of the values that have been added.  The mode is\n      * the element which occurs with the most frequency\n      * @return the mode\n      */\n-    public static double median(double[] values){\n+    public static double median(double[] values) {\n         // Mode depends on a refactor Freq class\n         String msg = \"median() is not yet implemented\";\n         throw new UnsupportedOperationException(msg);", "timestamp": 1055940144, "metainfo": ""}