{"sha": "1e8f480962572c323e16e85c4381d18a53286345", "log": "MATH-438 Removed deprecated methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n  * @since 2.0\n  */\n public abstract class AbstractRealMatrix implements RealMatrix {\n-\n-\n-    /** Cached LU solver.\n-     * @deprecated as of release 2.0, since all methods using this are deprecated\n-     */\n-    @Deprecated\n-    private DecompositionSolver lu;\n-\n     /**\n      * Creates a matrix with no data\n      */\n-    protected AbstractRealMatrix() {\n-        lu = null;\n-    }\n+    protected AbstractRealMatrix() {}\n \n     /**\n      * Create a new RealMatrix with the supplied row and column dimensions.\n         if (columnDimension < 1) {\n             throw new NotStrictlyPositiveException(columnDimension);\n         }\n-        lu = null;\n     }\n \n     /** {@inheritDoc} */\n                 setEntry(row + i, column + j, subMatrix[i][j]);\n             }\n         }\n-\n-        lu = null;\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    @Deprecated\n-    public RealMatrix inverse()\n-        throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n-        }\n-        return lu.getInverse();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double getDeterminant()\n-        throws InvalidMatrixException {\n-        return new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getDeterminant();\n-    }\n-\n-    /** {@inheritDoc} */\n     public boolean isSquare() {\n         return getColumnDimension() == getRowDimension();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public boolean isSingular() {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n-       }\n-        return !lu.isNonSingular();\n     }\n \n     /** {@inheritDoc} */\n                 setEntry(row, column, newValue);\n             }\n         }\n-        lu = null;\n         return visitor.end();\n     }\n \n                 setEntry(row, column, newValue);\n             }\n         }\n-        lu = null;\n         return visitor.end();\n     }\n \n                 setEntry(row, column, newValue);\n             }\n         }\n-        lu = null;\n         return visitor.end();\n     }\n \n                 setEntry(row, column, newValue);\n             }\n         }\n-        lu = null;\n         return visitor.end();\n     }\n \n                                        final int startColumn, final int endColumn)\n         throws MatrixVisitorException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double[] solve(final double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n-        }\n-        return lu.solve(b);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public RealMatrix solve(final RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException  {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n-        }\n-        return lu.solve(b);\n-    }\n-\n-    /**\n-     * Computes a new\n-     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n-     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n-     * <p>\n-     * <strong>Implementation Note</strong>:<br>\n-     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n-     * Crout's algorithm</a>, with partial pivoting.</p>\n-     * <p>\n-     * <strong>Usage Note</strong>:<br>\n-     * This method should rarely be invoked directly. Its only use is\n-     * to force recomputation of the LU decomposition when changes have been\n-     * made to the underlying data using direct array references. Changes\n-     * made using setXxx methods will trigger recomputation when needed\n-     * automatically.</p>\n-     *\n-     * @throws InvalidMatrixException if the matrix is non-square or singular.\n-     * @deprecated as of release 2.0, replaced by {@link LUDecomposition}\n-     */\n-    @Deprecated\n-    public void luDecompose()\n-        throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n-        }\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n     RealMatrix transpose();\n \n     /**\n-     * Returns the inverse of this matrix.\n-     *\n-     * @return inverse matrix\n-     * @throws InvalidMatrixException if this is not invertible\n-     * @deprecated as of release 2.0, replaced by <code>\n-     * {@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n-     * new LUDecompositionImpl(m)}.{@link LUDecomposition#getSolver()\n-     * getSolver()}.{@link DecompositionSolver#getInverse()\n-     * getInverse()}</code>\n-     */\n-    @Deprecated\n-        RealMatrix inverse();\n-\n-    /**\n-     * Returns the determinant of this matrix.\n-     *\n-     * @return determinant\n-     * @deprecated as of release 2.0, replaced by <code>\n-     * {@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n-     * new LUDecompositionImpl(m)}.{@link LUDecomposition#getDeterminant()\n-     * getDeterminant()}</code>\n-     */\n-    @Deprecated\n-    double getDeterminant();\n-\n-    /**\n-     * Is this a singular matrix?\n-     * @return true if the matrix is singular\n-     * @deprecated as of release 2.0, replaced by the boolean negation of\n-     * <code>{@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n-     * new LUDecompositionImpl(m)}.{@link LUDecomposition#getSolver()\n-     * getSolver()}.{@link DecompositionSolver#isNonSingular()\n-     * isNonSingular()}</code>\n-     */\n-    @Deprecated\n-    boolean isSingular();\n-\n-    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      */\n     double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor,\n                                 int startRow, int endRow, int startColumn, int endColumn);\n-\n-    /**\n-     * Returns the solution vector for a linear system with coefficient\n-     * matrix = this and constant vector = <code>b</code>.\n-     *\n-     * @param b  constant vector\n-     * @return vector of solution values to AX = b, where A is *this\n-     * @throws IllegalArgumentException if this.rowDimension != b.length\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(double[])}\n-     */\n-    @Deprecated\n-    double[] solve(double[] b);\n-\n-    /**\n-     * Returns a matrix of (column) solution vectors for linear systems with\n-     * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>.\n-     *\n-     * @param b  matrix of constant vectors forming RHS of linear systems to\n-     * to solve\n-     * @return matrix of solution vectors\n-     * @throws IllegalArgumentException if this.rowDimension != row dimension\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(RealMatrix)}\n-     */\n-    @Deprecated\n-    RealMatrix solve(RealMatrix b);\n }", "timestamp": 1289515959, "metainfo": ""}