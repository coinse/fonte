{"sha": "7d9003b91aacba77f91556a590163824838b8db0", "log": "completed implementation of EigenDecompositionImpl. The implementation is now based on the very fast and accurate dqd/dqds algorithm. It is faster than Jama for all dimensions and speed gain increases with dimensions. The gain is about 30% below dimension 100, about 50% around dimension 250 and about 65% for dimensions around 700. It is also possible to compute only eigenvalues (and hence saving computation of eigenvectors, thus even increasing the speed gain). JIRA: MATH-220  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Calculates the eigen decomposition of a matrix.\n- * <p>The eigen decomposition of matrix A is a set of two matrices:\n- * V and D such that A = V &times; D &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then V is an m &times; m orthogonal matrix\n- * and D is a m &times; n diagonal matrix.</p>\n+ * Calculates the eigen decomposition of a <strong>symmetric</strong> matrix.\n+ * <p>The eigen decomposition of symmetric matrix A is a set of two matrices:\n+ * V and D such that A = V D V<sup>T</sup>. A, V and D are all m &times; m\n+ * matrices.</p>\n+ * <p>This implementation only uses the upper part of the matrix, the part below the\n+ * diagonal is not accessed at all.</p>\n+ * <p>Eigenvalues are computed as soon as the matrix is decomposed, but eigenvectors\n+ * are computed only when required, i.e. only when one of the {@link #getEigenvector(int)},\n+ * {@link #getV()}, {@link #getVT()}, {@link #getInverse()}, {@link #solve(double[])},\n+ * {@link #solve(RealMatrix)}, {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)}\n+ * methods is called.</p>\n  * <p>This implementation is based on Inderjit Singh Dhillon thesis\n  * <a href=\"http://www.cs.utexas.edu/users/inderjit/public_papers/thesis.pdf\">A\n  * New O(n<sup>2</sup>) Algorithm for the Symmetric Tridiagonal Eigenvalue/Eigenvector\n- * Problem</a>.</p>\n+ * Problem</a>, on Beresford N. Parlett and Osni A. Marques paper <a\n+ * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An Implementation of the\n+ * dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routines (DLARRE,\n+ * DLASQ2, DLAZQ3, DLAZQ4, DLASQ5 and DLASQ6).</p>\n+ * @author Beresford Parlett, University of California, Berkeley, USA (fortran version)\n+ * @author Jim Demmel, University of California, Berkeley, USA (fortran version)\n+ * @author Inderjit Dhillon, University of Texas, Austin, USA(fortran version)\n+ * @author Osni Marques, LBNL/NERSC, USA (fortran version)\n+ * @author Christof Voemel, University of California, Berkeley, USA(fortran version)\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class EigenDecompositionImpl implements EigenDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -8550254713195393577L;\n+    private static final long serialVersionUID = -4976315828448620858L;\n+\n+    /** Tolerance. */\n+    private static final double TOLERANCE = 100 * MathUtils.EPSILON;\n+\n+    /** Squared tolerance. */\n+    private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE;\n+\n+    /** Split tolerance. */\n+    private double splitTolerance;\n+\n+    /** Main diagonal of the tridiagonal matrix. */\n+    private double[] main;\n+\n+    /** Secondary diagonal of the tridiagonal matrix. */\n+    private double[] secondary;\n+\n+    /** Squared secondary diagonal of the tridiagonal matrix. */\n+    private double[] squaredSecondary;\n+\n+    /** Orthogonal matrix of tridiagonal transformation. */\n+    private RealMatrix orthoTridiag;\n+\n+    /** Lower bound of spectra. */\n+    private double lowerSpectra;\n+\n+    /** Upper bound of spectra. */\n+    private double upperSpectra;\n+\n+    /** Minimum pivot in the Sturm sequence. */\n+    private double minPivot;\n+\n+    /** Current shift. */\n+    private double sigma;\n+\n+    /** Low part of the current shift. */\n+    private double sigmaLow;\n+\n+    /** Shift increment to apply. */\n+    private double tau;\n+\n+    /** Work array for all decomposition algorithms. */\n+    private double[] work;\n+\n+    /** Shift within qd array for ping-pong implementation. */\n+    private int pingPong;\n+\n+    /** Max value of diagonal elements in current segment. */\n+    private double qMax;\n+\n+    /** Min value of off-diagonal elements in current segment. */\n+    private double eMin;\n+\n+    /** Type of the last dqds shift. */\n+    private int    tType;\n+\n+    /** Minimal value on current state of the diagonal. */\n+    private double dMin;\n+\n+    /** Minimal value on current state of the diagonal, excluding last element. */\n+    private double dMin1;\n+\n+    /** Minimal value on current state of the diagonal, excluding last two elements. */\n+    private double dMin2;\n+\n+    /** Last value on current state of the diagonal. */\n+    private double dN;\n+\n+    /** Last but one value on current state of the diagonal. */\n+    private double dN1;\n+\n+    /** Last but two on current state of the diagonal. */\n+    private double dN2;\n+\n+    /** Shift ratio with respect to dMin used when tType == 6. */\n+    private double g;\n \n     /** Eigenvalues. */\n     private double[] eigenvalues;\n      * @see #decompose(RealMatrix)\n      */\n     public EigenDecompositionImpl() {\n-    }\n-\n-    /**\n-     * Calculates the eigen decomposition of the given matrix. \n+        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n+    }\n+\n+    /**\n+     * Calculates the eigen decomposition of the given symmetric matrix. \n      * <p>Calling this constructor is equivalent to first call the no-arguments\n      * constructor and then call {@link #decompose(RealMatrix)}.</p>\n-     * @param matrix The matrix to decompose.\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix The <strong>symmetric</strong> matrix to decompose.\n      * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n      * if algorithm fails to converge\n      */\n-    public EigenDecompositionImpl(RealMatrix matrix)\n+    public EigenDecompositionImpl(final RealMatrix matrix)\n         throws InvalidMatrixException {\n+        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n         decompose(matrix);\n     }\n \n-    /** {@inheritDoc} */\n-    public void decompose(RealMatrix matrix)\n+    /**\n+     * Set split tolerance based on absolute off-diagonal elements.\n+     * @param tolerance tolerance to set\n+     */\n+    public void setAbsoluteSplitTolerance(final double tolerance) {\n+        splitTolerance = -Math.abs(tolerance);\n+    }\n+\n+    /**\n+     * Set split tolerance preserving relative accuracy.\n+     * @param tolerance tolerance to set\n+     */\n+    public void setRelativeAccuracySplitTolerance(final double tolerance) {\n+        splitTolerance = Math.abs(tolerance);\n+    }\n+\n+    /**\n+     * Decompose a <strong>symmetric</strong> matrix.\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix symmetric matrix to decompose\n+     * @exception InvalidMatrixException if matrix cannot be diagonalized\n+     */\n+    public void decompose(final RealMatrix matrix)\n         throws InvalidMatrixException {\n \n         cachedV  = null;\n         cachedD  = null;\n         cachedVt = null;\n-\n-        // transform the matrix to tridiagonal\n-        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n-        final double[] main      = transformer.getMainDiagonalRef();\n-        final double[] secondary = transformer.getSecondaryDiagonalRef();\n-        final int m = main.length;\n-\n-        // pre-compute the square of the secondary diagonal\n-        double[] squaredSecondary = new double[secondary.length];\n-        for (int i = 0; i < squaredSecondary.length; ++i) {\n-            final double s = secondary[i];\n-            squaredSecondary[i] = s * s;\n-        }\n-\n-        // compute the eigenvalues bounds\n-        List<GershgorinCirclesUnion> bounds =\n-            getEigenvaluesBounds(main, secondary);\n-\n-        // TODO this implementation is not finished yet\n-        // the MRRR algorithm is NOT implemented, Gershgorin circles are\n-        // merged together when they could be separated, we only perform blindly\n-        // the basic steps, we search all eigenvalues with an arbitrary\n-        // threshold, we use twisted factorization afterwards with no\n-        // heuristic to speed up the selection of the twist index ...\n-        // The decomposition does work in its current state and seems reasonably\n-        // efficient when eigenvalues are separated. However, it is expected to\n-        // fail in difficult cases and its performances can obviously be improved\n-        // for now, it is slower than JAMA for dimensions below 100 and faster\n-        // for dimensions above 100. The speed gain with respect to JAMA increase\n-        // regularly with dimension\n-\n-        // find eigenvalues using bisection\n-        eigenvalues = new double[m];\n-        final double low  = bounds.get(0).getLow();\n-        final double high = bounds.get(bounds.size() - 1).getHigh();\n-        final double threshold =\n-            1.0e-15 * Math.max(Math.abs(low), Math.abs(high));\n-        findEigenvalues(main, squaredSecondary, low, high, threshold, 0, m);\n-\n-        // find eigenvectors\n-        eigenvectors = new RealVectorImpl[m];\n-        final double[] eigenvector = new double[m];\n-        final double[] lp          = new double[m - 1];\n-        final double[] dp          = new double[m];\n-        final double[] um          = new double[m - 1];\n-        final double[] dm          = new double[m];\n-        final double[] gamma       = new double[m];\n-        for (int i = 0; i < m; ++i) {\n-\n-            // find the eigenvector of the tridiagonal matrix\n-            findEigenvector(eigenvalues[i], eigenvector,\n-                            main, secondary, lp, dp, um, dm, gamma);\n-\n-            // find the eigenvector of the original matrix\n-            eigenvectors[i] =\n-                new RealVectorImpl(transformer.getQ().operate(eigenvector), true);\n-\n-        }\n+        work     = new double[6 * matrix.getRowDimension()];\n+\n+        // compute tridiagonal representation of the initial matrix\n+        transformToTridiagonal(matrix);\n+        computeGershgorinCircles();\n+\n+        // find all the eigenvalues\n+        findEigenvalues();\n+\n+        // we will search for eigenvectors only if required\n+        eigenvectors = null;\n \n     }\n \n         if (cachedVt == null) {\n \n             checkDecomposed();\n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n \n             final double[][] vtData = new double[eigenvectors.length][];\n             for (int k = 0; k < eigenvectors.length; ++k) {\n     public RealVector getEigenvector(final int i)\n         throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n         checkDecomposed();\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n         return eigenvectors[i].copy();\n     }\n \n         final int m = eigenvalues.length;\n         if (b.length != m) {\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n         }\n \n         final double[] bp = new double[m];\n                 throw new IllegalArgumentException(\"constant vector has wrong length\");\n             }\n \n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n+\n             final double[] bp = new double[m];\n             for (int i = 0; i < m; ++i) {\n                 final RealVectorImpl v = eigenvectors[i];\n         }\n     }\n \n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n+    /**\n+     * Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X such that A &times; X = B\n      * @throws IllegalArgumentException if matrices dimensions don't match\n         final int m = eigenvalues.length;\n         if (b.getRowDimension() != m) {\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n         }\n \n         final int nColB = b.getColumnDimension();\n         final int m = eigenvalues.length;\n         final double[][] invData = new double[m][m];\n \n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+\n         for (int i = 0; i < m; ++i) {\n             final double[] invI = invData[i];\n             for (int j = 0; j < m; ++j) {\n     }\n \n     /**\n-     * Compute a set of possible bounding intervals for eigenvalues\n-     * of a symmetric tridiagonal matrix.\n-     * <p>The intervals are computed by applying the Gershgorin circle theorem.</p>\n-     * @param main main diagonal\n-     * @param secondary secondary diagonal of the tridiagonal matrix\n-     * @return a collection of disjoint intervals where eigenvalues must lie,\n-     * sorted in increasing order\n-     */\n-    private List<GershgorinCirclesUnion> getEigenvaluesBounds(final double[] main,\n-                                                              final double[] secondary) {\n-\n-        final SortedSet<GershgorinCirclesUnion> rawCircles =\n-            new TreeSet<GershgorinCirclesUnion>();\n-        final int m = main.length;\n-\n-        // compute all the Gershgorin circles independently\n-        rawCircles.add(new GershgorinCirclesUnion(main[0],\n-                                                  Math.abs(secondary[0])));\n-        for (int i = 1; i < m - 1; ++i) {\n-            rawCircles.add(new GershgorinCirclesUnion(main[i],\n-                                                      Math.abs(secondary[i - 1]) +\n-                                                      Math.abs(secondary[i])));\n-        }\n-        rawCircles.add(new GershgorinCirclesUnion(main[m - 1],\n-                                                  Math.abs(secondary[m - 2])));\n-\n-        // combine intersecting circles\n-        final ArrayList<GershgorinCirclesUnion> combined =\n-            new ArrayList<GershgorinCirclesUnion>();\n-        GershgorinCirclesUnion current = null;\n-        for (GershgorinCirclesUnion rawCircle : rawCircles) {\n-            if (current == null) {\n-                current = rawCircle;\n-            } else if (current.intersects(rawCircle)) {\n-                current.swallow(rawCircle);\n+     * Transform matrix to tridiagonal.\n+     * @param matrix matrix to transform\n+     */\n+    private void transformToTridiagonal(final RealMatrix matrix) {\n+\n+        // transform the matrix to tridiagonal\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        main      = transformer.getMainDiagonalRef();\n+        secondary = transformer.getSecondaryDiagonalRef();\n+\n+        // pre-compute some elements\n+        squaredSecondary = new double[secondary.length];\n+        for (int i = 0; i < squaredSecondary.length; ++i) {\n+            final double s = secondary[i];\n+            squaredSecondary[i] = s * s;\n+        }\n+\n+        orthoTridiag = transformer.getQ();\n+\n+    }\n+\n+    /**\n+     * Compute the Gershgorin circles for all rows.\n+     */\n+    private void computeGershgorinCircles() {\n+\n+        final int m     = main.length;\n+        final int lowerStart = 4 * m;\n+        final int upperStart = 5 * m;\n+        lowerSpectra = Double.POSITIVE_INFINITY;\n+        upperSpectra = Double.NEGATIVE_INFINITY;\n+        double eMax = 0;\n+\n+        double eCurrent = 0;\n+        for (int i = 0; i < m - 1; ++i) {\n+\n+            final double dCurrent = main[i];\n+            final double ePrevious = eCurrent;\n+            eCurrent = Math.abs(secondary[i]);\n+            eMax = Math.max(eMax, eCurrent);\n+            final double radius = ePrevious + eCurrent;\n+\n+            final double lower = dCurrent - radius;\n+            work[lowerStart + i] = lower;\n+            lowerSpectra = Math.min(lowerSpectra, lower);\n+\n+            final double upper = dCurrent + radius;\n+            work[upperStart + i] = upper;\n+            upperSpectra = Math.max(upperSpectra, upper);\n+            \n+        }\n+\n+        final double dCurrent = main[m - 1];\n+        work[lowerStart + m - 1] = dCurrent - eCurrent;\n+        work[upperStart + m - 1] = dCurrent + eCurrent;\n+        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n+\n+    }\n+\n+    /**\n+     * Find the eigenvalues.\n+     * @exception InvalidMatrixException if a block cannot be diagonalized\n+     */\n+    private void findEigenvalues()\n+        throws InvalidMatrixException {\n+\n+        // compute splitting points\n+        List<Integer> splitIndices = computeSplits();\n+\n+        // find eigenvalues in each block\n+        eigenvalues = new double[main.length];\n+        int begin = 0;\n+        for (final int end : splitIndices) {\n+            final int n = end - begin;\n+            switch (n) {\n+\n+            case 1:\n+                // apply dedicated method for dimension 1\n+                process1RowBlock(begin);\n+                break;\n+\n+            case 2:\n+                // apply dedicated method for dimension 2\n+                process2RowsBlock(begin);\n+                break;\n+\n+            case 3:\n+                // apply dedicated method for dimension 3\n+                process3RowsBlock(begin);\n+                break;\n+\n+            default:\n+\n+                // choose an initial shift for LDL<sup>T</sup> decomposition\n+                final double[] range       = eigenvaluesRange(begin, n);\n+                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n+                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n+                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n+                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n+                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n+                final double lambda        = chooseLeft ? range[0] : range[1];\n+\n+                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n+\n+                // decompose T&lambda;I as LDL<sup>T</sup>\n+                ldlTDecomposition(lambda, begin, n);\n+\n+                // apply general dqd/dqds method\n+                processGeneralBlock(n);\n+\n+                // extract eigenvalues\n+                if (chooseLeft) {\n+                    for (int i = 0; i < n; ++i) {\n+                        eigenvalues[begin + i] = lambda + work[4 * i];\n+                    }\n+                } else {\n+                    for (int i = 0; i < n; ++i) {\n+                        eigenvalues[begin + i] = lambda - work[4 * i];\n+                    }                    \n+                }\n+\n+            }\n+            begin = end;\n+        }\n+\n+        // sort the eigenvalues in decreasing order\n+        Arrays.sort(eigenvalues);\n+        for (int i = 0, j = eigenvalues.length - 1; i < j; ++i, --j) {\n+            final double tmp = eigenvalues[i];\n+            eigenvalues[i] = eigenvalues[j];\n+            eigenvalues[j] = tmp;\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute splitting points.\n+     * @return list of indices after matrix can be split\n+     */\n+    private List<Integer> computeSplits() {\n+\n+        final List<Integer> list = new ArrayList<Integer>();\n+\n+        if (splitTolerance < 0) {\n+            // splitting based on absolute off-diagonal value\n+            final double max = Math.abs(splitTolerance) * (upperSpectra - lowerSpectra);\n+            for (int i = 0; i < secondary.length; ++i) {\n+                if (Math.abs(secondary[i]) <= max) {\n+                    list.add(i + 1);\n+                    secondary[i] = 0;\n+                    squaredSecondary[i] = 0;\n+                }\n+            }\n+        } else {\n+            // splitting preserving relative accuracy\n+            double absDCurrent = Math.abs(0);\n+            for (int i = 0; i < secondary.length; ++i) {\n+                final double absDPrevious = absDCurrent;\n+                absDCurrent = Math.abs(i + 1);\n+                final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n+                if (Math.abs(secondary[i]) <= max) {\n+                    list.add(i + 1);\n+                    secondary[i] = 0;\n+                    squaredSecondary[i] = 0;\n+                }\n+            }            \n+        }\n+\n+        list.add(secondary.length + 1);\n+        return list;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalue in a block with 1 row.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     */\n+    private void process1RowBlock(final int index) {\n+        eigenvalues[index] = main[index];\n+    }\n+\n+    /**\n+     * Find eigenvalues in a block with 2 rows.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     * @exception InvalidMatrixException if characteristic polynomial cannot be solved\n+     */\n+    private void process2RowsBlock(final int index)\n+        throws InvalidMatrixException {\n+\n+        // the characteristic polynomial is\n+        // X^2 - (q0 + q1) X + q0 q1 - e1^2\n+        final double q0   = main[index];\n+        final double q1   = main[index + 1];\n+        final double e12  = squaredSecondary[index];\n+\n+        final double s     = q0 + q1;\n+        final double p     = q0 * q1 - e12;\n+        final double delta = s * s - 4 * p;\n+        if (delta < 0) {\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 2 });\n+        }\n+\n+        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n+        eigenvalues[index]     = largestRoot;\n+        eigenvalues[index + 1] = p / largestRoot;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalues in a block with 3 rows.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     * @exception InvalidMatrixException if diagonal elements are not positive\n+     */\n+    private void process3RowsBlock(final int index)\n+        throws InvalidMatrixException {\n+\n+        // the characteristic polynomial is\n+        // X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2\n+        final double q0       = main[index];\n+        final double q1       = main[index + 1];\n+        final double q2       = main[index + 2];\n+        final double e12      = squaredSecondary[index];\n+        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n+\n+        // compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0\n+        final double b        = -(q0 + q1 + q2);\n+        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n+        final double d        = q2 * e12 - q0 * q1q2Me22;\n+\n+        // solve cubic equation\n+        final double b2       = b * b;\n+        final double q        = (3 * c - b2) / 9;\n+        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n+        final double delta    = q * q * q + r * r;\n+        if (delta >= 0) {\n+            // in fact, there are solutions to the equation, but in the context\n+            // of symmetric eigenvalues problem, there should be three distinct\n+            // real roots, so we throw an error if this condition is not met\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 3 });           \n+        }\n+        final double sqrtMq = Math.sqrt(-q);\n+        final double theta  = Math.acos(r / (-q * sqrtMq));\n+        final double alpha  = 2 * sqrtMq;\n+        final double beta   = b / 3;\n+\n+        double z0 = alpha * Math.cos(theta / 3) - beta;\n+        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n+        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n+        if (z0 < z1) {\n+            final double t = z0;\n+            z0 = z1;\n+            z1 = t;\n+        }\n+        if (z1 < z2) {\n+            final double t = z1;\n+            z1 = z2;\n+            z2 = t;\n+        }\n+        if (z0 < z1) {\n+            final double t = z0;\n+            z0 = z1;\n+            z1 = t;\n+        }\n+        eigenvalues[index]     = z0;\n+        eigenvalues[index + 1] = z1;\n+        eigenvalues[index + 2] = z2;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalues using dqd/dqds algorithms.\n+     * <p>This implementation is based on Beresford N. Parlett\n+     * and Osni A. Marques paper <a\n+     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n+     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n+     * corresponding LAPACK routine DLASQ2.</p>\n+     * @param n number of rows of the block\n+     * @exception InvalidMatrixException if block cannot be diagonalized\n+     * after 30 * n iterations\n+     */\n+    private void processGeneralBlock(final int n)\n+        throws InvalidMatrixException {\n+\n+        // check decomposed matrix data range\n+        final int fourN1  = 4 * (n - 1);\n+        double sumDiag    = 0;\n+        double sumOffDiag = 0;\n+//        qMax = Double.NEGATIVE_INFINITY;\n+//        eMin = Double.POSITIVE_INFINITY;\n+        for (int i = 0; i < n - 1; ++i) {\n+            final int fourI = 4 * i;\n+            final double qi = work[fourI];\n+            final double ei = work[fourI + 2];\n+//            qMax = Math.max(qMax, qi);\n+//            eMin = Math.min(eMin, ei);\n+            sumDiag    += qi;\n+            sumOffDiag += ei;\n+        }\n+        final double qi = work[fourN1];\n+//        qMax = Math.max(qMax, qi);\n+        sumDiag += qi;\n+\n+        if (sumOffDiag == 0) {\n+            // matrix is already diagonal\n+            return;\n+        }\n+\n+        // initial checks for splits (see Parlett & Marques section 3.3)\n+        flipIfWarranted(n, 2);\n+\n+        // two iterations with Li's test for initial splits\n+        initialSplits(n);\n+\n+        // initialize parameters used by goodStep\n+        tType = 0;\n+        dMin1 = 0;\n+        dMin2 = 0;\n+        dN    = 0;\n+        dN1   = 0;\n+        dN2   = 0;\n+        tau   = 0;\n+\n+        // process split segments\n+        int i0 = 0;\n+        int n0 = n;\n+        while (n0 > 0) {\n+\n+            // retrieve shift that was temporarily stored as a negative off-diagonal element\n+            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n+            sigmaLow = 0;\n+\n+            // find start of a new split segment to process\n+            double eMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n+            double eMax = 0;\n+            double qMax = work[4 * n0 - 4];\n+            double qMin = qMax;\n+            i0 = 0;\n+            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n+                if (work[i + 2] <= 0) {\n+                    i0 = 1 + i / 4;\n+                    break;\n+                }\n+                if (qMin >= 4 * eMax) {\n+                    qMin = Math.min(qMin, work[i + 4]);\n+                    eMax = Math.max(eMax, work[i + 2]);\n+                }\n+                qMax = Math.max(qMax, work[i] + work[i + 2]);\n+                eMin = Math.min(eMin, work[i + 2]);\n+            }\n+            work[4 * n0 - 2] = eMin;\n+\n+            // lower bound of Gershgorin disk\n+            dMin = -Math.max(0, qMin - 2 * Math.sqrt(qMin * eMax));\n+\n+            pingPong = 0;\n+            int maxIter = 30 * (n0 - i0);\n+            for (int k = 0; i0 < n0; ++k) {\n+                if (k >= maxIter) {\n+                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n+                }\n+\n+                // perform one step\n+                n0 = goodStep(i0, n0);\n+                pingPong = 1 - pingPong;\n+\n+                // check for new splits after \"ping\" steps\n+                // when the last elements of qd array are very small\n+                if ((pingPong == 0) && (n0 - i0 > 3) &&\n+                    (work[4 * n0 - 1] <= TOLERANCE_2 * qMax) &&\n+                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n+                    int split = i0 - 1;\n+                    qMax = work[4 * i0];\n+                    eMin = work[4 * i0 + 2];\n+                    double previousEMin = work[4 * i0 + 3];\n+                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n+                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n+                            // insert a split here\n+                            work[i + 2]  = -sigma;\n+                            split        = i / 4;\n+                            qMax         = 0;\n+                            eMin         = work[i + 6];\n+                            previousEMin = work[i + 7];\n+                        } else {\n+                            qMax         = Math.max(qMax, work[i + 4]);\n+                            eMin         = Math.min(eMin, work[i + 2]);\n+                            previousEMin = Math.min(previousEMin, work[i + 3]);\n+                        }\n+                    }\n+                    work[4 * n0 - 2] = eMin;\n+                    work[4 * n0 - 1] = previousEMin;\n+                    i0 = split + 1;\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Perform two iterations with Li's tests for initial splits.\n+     * @param n number of rows of the matrix to process\n+     */\n+    private void initialSplits(final int n) {\n+\n+        pingPong = 0;\n+        for (int k = 0; k < 2; ++k) {\n+\n+            // apply Li's reverse test\n+            double d = work[4 * (n - 1) + pingPong];\n+            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n+                if (work[i + 2] <= TOLERANCE_2 * d) {\n+                    work[i + 2] = -0.0;\n+                    d = work[i];\n+                } else {\n+                    d *= work[i] / (d + work[i + 2]);\n+                }\n+            }\n+\n+            // apply dqd plus Li's forward test.\n+//            eMin = work[4 + pingPong];\n+            d = work[pingPong];\n+            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n+                final int j = i - 2 * pingPong - 1;\n+                work[j] = d + work[i];\n+                if (work[i] <= TOLERANCE_2 * d) {\n+                    work[i]     = -0.0;\n+                    work[j]     = d;\n+                    work[j + 2] = 0.0;\n+                    d = work[i + 2];\n+                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n+                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n+                    final double tmp = work[i + 2] / work[j];\n+                    work[j + 2] = work[i] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n+                    d *= work[i + 2] / work[j];\n+               }\n+//               eMin = Math.min(eMin, work[j + 2]);\n+            }\n+            work[4 * n - 3 - pingPong] = d;\n+\n+//            // find qMax\n+//            qMax = Double.NEGATIVE_INFINITY;\n+//            for (int i = 1 - pingPong; i < 4 * n; i += 4) {\n+//                qMax = Math.max(qMax, work[i]);\n+//            }\n+\n+            // from ping to pong\n+            pingPong = 1 - pingPong;\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Perform one \"good\" dqd/dqds step.\n+     * <p>This implementation is based on Beresford N. Parlett\n+     * and Osni A. Marques paper <a\n+     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n+     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n+     * corresponding LAPACK routine DLAZQ3.</p>\n+     * @param start start index\n+     * @param end end index\n+     * @return new end (maybe deflated)\n+     */\n+    private int goodStep(final int start, final int end) {\n+\n+        g = 0.0;\n+\n+        // step 1: accepting eigenvalues\n+        int deflatedEnd = end;\n+        for (boolean deflating = true; deflating;) {\n+\n+            if (start >= deflatedEnd) {\n+                // the array has been completely deflated\n+                return deflatedEnd;\n+            }\n+\n+            final int k = 4 * deflatedEnd + pingPong - 1;\n+\n+            if ((start == deflatedEnd - 1) ||\n+                ((start != deflatedEnd - 2) &&\n+                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n+                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n+\n+                // one eigenvalue found, deflate array\n+                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n+                deflatedEnd -= 1;\n+\n+            } else if ((start == deflatedEnd - 2) ||\n+                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n+                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n+\n+                // two eigenvalues found, deflate array\n+                if (work[k - 3] > work[k - 7]) {\n+                    final double tmp = work[k - 3];\n+                    work[k - 3] = work[k - 7];\n+                    work[k - 7] = tmp;\n+                }\n+\n+                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n+                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n+                    double s = work[k - 3] * (work[k - 5] / t);\n+                    if (s <= t) {\n+                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n+                    } else {\n+                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));                      \n+                    }\n+                    t = work[k - 7] + (s + work[k - 5]);\n+                    work[k - 3] *= work[k - 7] / t;\n+                    work[k - 7]  = t;\n+                }\n+                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n+                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n+                deflatedEnd -= 2;\n             } else {\n-                combined.add(current);\n-                current = rawCircle;\n-            }\n-        }\n-        if (current != null) {\n-            combined.add(current);\n-        }\n-        \n-        return combined;\n-\n-    }\n-\n-    /** Find eigenvalues in an interval.\n-     * @param main main diagonal of the tridiagonal matrix\n-     * @param squaredSecondary squared secondary diagonal of the tridiagonal matrix\n-     * @param low lower bound of the search interval\n-     * @param high higher bound of the search interval\n-     * @param threshold convergence threshold\n-     * @param iStart index of the first eigenvalue to find\n-     * @param iEnd index one unit past the last eigenvalue to find\n-     */\n-    private void findEigenvalues(final double[] main, final double[] squaredSecondary,\n-                                 final double low, final double high, final double threshold,\n-                                 final int iStart, final int iEnd) {\n-\n-        // use a simple loop to handle tail-recursion cases\n-        double currentLow   = low;\n-        double currentHigh  = high;\n-        int    currentStart = iStart;\n-        while (true) {\n-\n-            final double middle = 0.5 * (currentLow + currentHigh);\n-\n-            if (currentHigh - currentLow < threshold) {\n-                // we have found an elementary interval containing one or more eigenvalues\n-                Arrays.fill(eigenvalues, currentStart, iEnd, middle);\n-                return;\n-            }\n-\n-            // compute the number of eigenvalues below the middle interval point\n-            final int iMiddle = countEigenValues(main, squaredSecondary, middle);\n-            if (iMiddle == currentStart) {\n-                // all eigenvalues are in the upper half of the search interval\n-                // update the interval and iterate\n-                currentLow = middle;\n-            } else if (iMiddle == iEnd) {\n-                // all eigenvalues are in the lower half of the search interval\n-                // update the interval and iterate\n-                currentHigh = middle;                \n+\n+                // no more eigenvalues found, we need to iterate\n+                deflating = false;\n+\n+            }\n+\n+        }\n+\n+        final int l = 4 * deflatedEnd + pingPong - 1;\n+\n+        // step 2: flip array if needed\n+        if ((dMin <= 0) || (deflatedEnd < end)) {\n+            if (flipIfWarranted(deflatedEnd, 1)) {\n+                dMin2 = Math.min(dMin2, work[l - 1]);\n+                work[l - 1] =\n+                    Math.min(work[l - 1],\n+                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n+                work[l - 2 * pingPong] =\n+                    Math.min(work[l - 2 * pingPong],\n+                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n+                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n+                dMin  = -0.0;\n+            }\n+        }\n+\n+        if ((dMin < 0) ||\n+            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n+                                                  Math.min(work[l - 9],\n+                                                           dMin2 + work[l - 2 * pingPong])))) {\n+            // step 3: choose a shift\n+            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n+\n+            // step 4a: dqds\n+            for (boolean loop = true; loop;) {\n+\n+                // perform one dqds step with the chosen shift\n+                dqds(start, deflatedEnd);\n+\n+                // check result of the dqds step\n+                if ((dMin >= 0) && (dMin1 > 0)) {\n+                    // the shift was good\n+                    updateSigma(tau);\n+                    return deflatedEnd;\n+                } else if ((dMin < 0.0) &&\n+                           (dMin1 > 0.0) &&\n+                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n+                           (Math.abs(dN) < TOLERANCE * sigma)) {\n+                   // convergence hidden by negative DN.\n+                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n+                    dMin = 0.0;\n+                    updateSigma(tau);\n+                    return deflatedEnd;\n+                } else if (dMin < 0.0) {\n+                    // tau too big. Select new tau and try again.\n+                    if (tType < -22) {\n+                        // failed twice. Play it safe.\n+                        tau = 0.0;\n+                    } else if (dMin1 > 0.0) {\n+                        // late failure. Gives excellent shift.\n+                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n+                        tType -= 11;\n+                    } else {\n+                        // early failure. Divide by 4.\n+                        tau *= 0.25;\n+                        tType -= 12;\n+                    }\n+                } else if (Double.isNaN(dMin)) {\n+                    tau = 0.0;\n+                } else {\n+                    // possible underflow. Play it safe.\n+                    loop = false;\n+                }\n+            }\n+\n+        }\n+\n+        // perform a dqd step (i.e. no shift)\n+        dqd(start, deflatedEnd);\n+\n+        return deflatedEnd;\n+\n+    }\n+\n+    /**\n+     * Flip qd array if warranted.\n+     * @param n number of rows in the block\n+     * @param step within the array (1 for flipping all elements, 2 for flipping\n+     * only every other element)\n+     * @return true if qd array was flipped\n+     */\n+    private boolean flipIfWarranted(final int n, final int step) {\n+        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n+            // flip array\n+            for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {\n+                for (int k = 0; k < 4; k += step) {\n+                    final double tmp = work[i + k];\n+                    work[i + k] = work[j - k];\n+                    work[j - k] = tmp;\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Compute an interval containing all eigenvalues of a block.\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     * @return an interval containing the eigenvalues\n+     */\n+    private double[] eigenvaluesRange(final int index, final int n) {\n+\n+        // find the bounds of the spectra of the local block\n+        final int lowerStart = 4 * main.length;\n+        final int upperStart = 5 * main.length;\n+        double lower = Double.POSITIVE_INFINITY;\n+        double upper = Double.NEGATIVE_INFINITY;\n+        for (int i = 0; i < n; ++i) {\n+            lower = Math.min(lower, work[lowerStart + index +i]);\n+            upper = Math.max(upper, work[upperStart + index +i]);\n+        }\n+\n+        // set thresholds\n+        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n+        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n+        final double absoluteTolerance = 4 * minPivot;\n+        final int maxIter =\n+            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n+        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n+\n+        // search lower eigenvalue\n+        double left  = lower - margin;\n+        double right = upper + margin;\n+        for (int i = 0; i < maxIter; ++i) {\n+\n+            final double range = right - left;\n+            if ((range < absoluteTolerance) ||\n+                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n+                // search has converged\n+                break;\n+            }\n+\n+            final double middle = 0.5 * (left + right);\n+            if (countEigenValues(middle, index, n) >= 1) {\n+                right = middle;\n             } else {\n-                // split the interval and search eigenvalues in both sub-intervals\n-                findEigenvalues(main, squaredSecondary, currentLow, middle, threshold,\n-                                currentStart, iMiddle);\n-                currentLow   = middle;\n-                currentStart = iMiddle;\n-            }\n-\n-        }\n+                left = middle;\n+            }\n+\n+        }\n+        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n+\n+        // search upper eigenvalue\n+        left  = lower - margin;\n+        right = upper + margin;\n+        for (int i = 0; i < maxIter; ++i) {\n+\n+            final double range = right - left;\n+            if ((range < absoluteTolerance) ||\n+                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n+                // search has converged\n+                break;\n+            }\n+\n+            final double middle = 0.5 * (left + right);\n+            if (countEigenValues(middle, index, n) >= n) {\n+                right = middle;\n+            } else {\n+                left = middle;\n+            }\n+\n+        }\n+        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n+\n+        return new double[] { lower, upper };\n \n     }\n \n     /**\n      * Count the number of eigenvalues below a point.\n-     * @param main main diagonal of the tridiagonal matrix\n-     * @param squaredSecondary squared secondary diagonal of the tridiagonal matrix\n-     * @param mu value below which we must count the number of eigenvalues\n-     * @return number of eigenvalues smaller than mu\n-     */\n-    private int countEigenValues(final double[] main, final double[] squaredSecondary,\n-                                 final double mu) {\n-        double ratio = main[0] - mu;\n+     * @param t value below which we must count the number of eigenvalues\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     * @return number of eigenvalues smaller than t\n+     */\n+    private int countEigenValues(final double t, final int index, final int n) {\n+        double ratio = main[index] - t;\n         int count = (ratio > 0) ? 0 : 1;\n-        for (int i = 1; i < main.length; ++i) {\n-            ratio = main[i] - squaredSecondary[i - 1] / ratio - mu;\n+        for (int i = 1; i < n; ++i) {\n+            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n             if (ratio <= 0) {\n                 ++count;\n             }\n     }\n \n     /**\n-     * Decompose the shifted tridiagonal matrix A - lambda I as L<sub>+</sub>\n-     * &times; D<sub>+</sub> &times; U<sub>+</sub>.\n-     * <p>A shifted symmetric tridiagonal matrix can be decomposed as\n-     * L<sub>+</sub> &times; D<sub>+</sub> &times; U<sub>+</sub> where L<sub>+</sub>\n-     * is a lower bi-diagonal matrix with unit diagonal, D<sub>+</sub> is a diagonal\n-     * matrix and U<sub>+</sub> is the transpose of L<sub>+</sub>. The '+' indice\n-     * comes from Dhillon's notation since decomposition is done in\n-     * increasing rows order).</p>\n-     * @param main main diagonal of the tridiagonal matrix\n-     * @param secondary secondary diagonal of the tridiagonal matrix\n-     * @param lambda shift to apply to the matrix before decomposing it\n-     * @param r index at which factorization should stop (if r is\n-     * <code>main.length</code>, complete factorization is performed)\n-     * @param lp placeholder where to put the (r-1) first off-diagonal\n-     * elements of the L<sub>+</sub> matrix\n-     * @param dp placeholder where to put the r first diagonal elements\n-     * of the D<sub>+</sub> matrix\n-     */\n-    private void lduDecomposition(final double[] main, final double[] secondary,\n-                                  final double lambda, final int r,\n-                                  final double[] lp, final double[] dp) {\n-        double di = main[0] - lambda;\n-        dp[0] = di;\n-        for (int i = 1; i < r; ++i) {\n-            final double eiM1 = secondary[i - 1];\n+     * Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>.\n+     * <p>A shifted symmetric tridiagonal matrix T can be decomposed as\n+     * LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal\n+     * and D is a diagonal matrix. This method is an implementation of\n+     * algorithm 4.4.7 from Dhillon's thesis.</p>\n+     * @param lambda shift to add to the matrix before decomposing it\n+     * to ensure it is positive definite\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     */\n+    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n+        double di = main[index] - lambda;\n+        work[0] = Math.abs(di);\n+        for (int i = 1; i < n; ++i) {\n+            final int    fourI = 4 * i;\n+            final double eiM1  = secondary[index + i - 1];\n             final double ratio = eiM1 / di;\n-            di = main[i] - lambda - eiM1 * ratio;\n-            lp[i - 1] = ratio;\n-            dp[i] = di;\n-        }\n-    }\n-\n-    /**\n-     * Decompose the shifted tridiagonal matrix A - lambda I as U<sub>-</sub>\n-     * &times; D<sub>-</sub> &times; L<sub>-</sub>.\n-     * <p>A shifted symmetric tridiagonal matrix can be decomposed as\n-     * U<sub>-</sub> &times; D<sub>-</sub> &times; L<sub>-</sub> where U<sub>-</sub>\n-     * is an upper bi-diagonal matrix with unit diagonal, D<sub>-</sub> is a diagonal\n-     * matrix and L<sub>-</sub> is the transpose of U<sub>-</sub>. The '-' indice\n-     * comes from Dhillon's notation since decomposition is done in\n-     * decreasing rows order).</p>\n-     * @param main main diagonal of the tridiagonal matrix\n-     * @param secondary secondary diagonal of the tridiagonal matrix\n-     * @param lambda shift to apply to the matrix before decomposing it\n-     * @param r index at which factorization should stop (if r is 0, complete\n-     * factorization is performed)\n-     * @param um placeholder where to put the m-(r-1) last off-diagonal elements\n-     * of the U<sub>-</sub> matrix, where m is the size of the original matrix\n-     * @param dm placeholder where to put the m-r last diagonal elements\n-     * of the D<sub>-</sub> matrix, where m is the size of the original matrix\n-     */\n-    private void udlDecomposition(final double[] main, final double[] secondary,\n-                                  final double lambda, final int r,\n-                                  final double[] um, final double[] dm) {\n-        final int mM1 = main.length - 1;\n-        double di = main[mM1] - lambda;\n-        dm[mM1] = di;\n-        for (int i = mM1 - 1; i >= r; --i) {\n-            final double ei = secondary[i];\n-            final double ratio = ei / di;\n-            di = main[i] - lambda - ei * ratio;\n-            um[i] = ratio;\n-            dm[i] = di;\n-        }\n-    }\n-\n-    /**\n-     * Find an eigenvector corresponding to an eigenvalue.\n+            work[fourI - 2] = ratio * ratio * Math.abs(di);\n+            di = (main[index + i] - lambda) - eiM1 * ratio;\n+            work[fourI] = Math.abs(di);\n+        }\n+    }\n+\n+    /**\n+     * Perform a dqds step, using current shift increment.\n+     * <p>This implementation is a translation of the LAPACK routine DLASQ5.</p>\n+     * @param start start index\n+     * @param end end index\n+     */\n+    private void dqds(final int start, final int end) {\n+\n+        eMin = work[4 * start + pingPong + 4];\n+        double d = work[4 * start + pingPong] - tau;\n+        dMin = d;\n+        dMin1 = -work[4 * start + pingPong];\n+\n+        if (pingPong == 0) {\n+            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n+                work[j4 - 2] = d + work[j4 - 1];\n+                final double tmp = work[j4 + 1] / work[j4 - 2];\n+                d = d * tmp - tau;\n+                dMin = Math.min(dMin, d);\n+                work[j4] = work[j4 - 1] * tmp;\n+                eMin = Math.min(work[j4], eMin);\n+            }\n+        } else {\n+            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n+                work[j4 - 3] = d + work[j4];\n+                final double tmp = work[j4 + 2] / work[j4 - 3];\n+                d = d * tmp - tau;\n+                dMin = Math.min(dMin, d);\n+                work[j4 - 1] = work[j4] * tmp;\n+                eMin = Math.min(work[j4 - 1], eMin);\n+            }\n+        }\n+\n+        // unroll last two steps.\n+        dN2 = d;\n+        dMin2 = dMin;\n+        int j4 = 4 * (end - 2) - pingPong - 1;\n+        int j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN2 + work[j4p2];\n+        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n+        dMin = Math.min(dMin, dN1);\n+\n+        dMin1 = dMin;\n+        j4 = j4 + 4;\n+        j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN1 + work[j4p2];\n+        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n+        dMin = Math.min(dMin, dN);\n+\n+        work[j4 + 2] = dN;\n+        work[4 * end - pingPong - 1] = eMin;\n+\n+    }\n+\n+\n+    /**\n+     * Perform a dqd step.\n+     * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>\n+     * @param start start index\n+     * @param end end index\n+     */\n+    private void dqd(final int start, final int end) {\n+\n+        eMin = work[4 * start + pingPong + 4];\n+        double d = work[4 * start + pingPong];\n+        dMin = d;\n+\n+        if (pingPong == 0) {\n+            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n+                work[j4 - 2] = d + work[j4 - 1];\n+                if (work[j4 - 2] == 0.0) {\n+                    work[j4] = 0.0;\n+                    d = work[j4 + 1];\n+                    dMin = d;\n+                    eMin = 0.0;\n+                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n+                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n+                    final double tmp = work[j4 + 1] / work[j4 - 2];\n+                    work[j4] = work[j4 - 1] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n+                    d *= work[j4 + 1] / work[j4 - 2];\n+                }\n+                dMin = Math.min(dMin, d);\n+                eMin = Math.min(eMin, work[j4]);\n+            }\n+        } else {\n+            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n+                work[j4 - 3] = d + work[j4];\n+                if (work[j4 - 3] == 0.0) {\n+                    work[j4 - 1] = 0.0;\n+                    d = work[j4 + 2];\n+                    dMin = d;\n+                    eMin = 0.0;\n+                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n+                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n+                    final double tmp = work[j4 + 2] / work[j4 - 3];\n+                    work[j4 - 1] = work[j4] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n+                    d *= work[j4 + 2] / work[j4 - 3];\n+                }\n+                dMin = Math.min(dMin, d);\n+                eMin = Math.min(eMin, work[j4 - 1]);\n+            }\n+        }\n+\n+        // Unroll last two steps\n+        dN2   = d;\n+        dMin2 = dMin;\n+        int j4 = 4 * (end - 2) - pingPong - 1;\n+        int j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN2 + work[j4p2];\n+        if (work[j4 - 2] == 0.0) {\n+            work[j4] = 0.0;\n+            dN1  = work[j4p2 + 2];\n+            dMin = dN1;\n+            eMin = 0.0;\n+        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n+                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n+            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n+            work[j4] = work[j4p2] * tmp;\n+            dN1 = dN2 * tmp;\n+        } else {\n+            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n+        }\n+        dMin = Math.min(dMin, dN1);\n+\n+        dMin1 = dMin;\n+        j4 = j4 + 4;\n+        j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN1 + work[j4p2];\n+        if (work[j4 - 2] == 0.0) {\n+            work[j4] = 0.0;\n+            dN   = work[j4p2 + 2];\n+            dMin = dN;\n+            eMin = 0.0;\n+        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n+                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n+            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n+            work[j4] = work[j4p2] * tmp;\n+            dN = dN1 * tmp;\n+        } else {\n+            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n+        }\n+        dMin = Math.min(dMin, dN);\n+\n+        work[j4 + 2] = dN;\n+        work[4 * end - pingPong - 1] = eMin;\n+\n+    }\n+\n+    /**\n+     * Compute the shift increment as an estimate of the smallest eigenvalue.\n+     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n+     * @param start start index\n+     * @param end end index\n+     * @param deflated number of eigenvalues just deflated\n+     */\n+    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n+\n+        final double cnst1 = 0.563;\n+        final double cnst2 = 1.010;\n+        final double cnst3 = 1.05;\n+\n+        // a negative dMin forces the shift to take that absolute value\n+        // tType records the type of shift.\n+        if (dMin <= 0.0) {\n+            tau = -dMin;\n+            tType = -1;\n+            return;\n+        }\n+\n+        int nn = 4 * end + pingPong - 1;\n+        switch (deflated) {\n+\n+        case 0 : // no eigenvalues deflated. \n+            if (dMin == dN || dMin == dN1) {\n+\n+                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n+                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n+                double a2 = work[nn - 7] + work[nn - 5];\n+\n+                if (dMin == dN && dMin1 == dN1) {\n+                    // cases 2 and 3. \n+                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n+                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n+                    if (gap1 > 0.0 && gap1 > b1) {\n+                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n+                        tType = -2;\n+                    } else {\n+                        double s = 0.0;\n+                        if (dN > b1) {\n+                            s = dN - b1;\n+                        }\n+                        if (a2 > (b1 + b2)) {\n+                            s = Math.min(s, a2 - (b1 + b2));\n+                        }\n+                        tau   = Math.max(s, 0.333 * dMin);\n+                        tType = -3;\n+                    }\n+                } else {\n+                    // case 4.\n+                    tType = -4;\n+                    double s = 0.25 * dMin;\n+                    double gam;\n+                    int np;\n+                    if (dMin == dN) {\n+                        gam = dN;\n+                        a2 = 0.0;\n+                        if (work[nn - 5]  >  work[nn - 7]) {\n+                            return;\n+                        }\n+                        b2 = work[nn - 5] / work[nn - 7];\n+                        np = nn - 9;\n+                    } else {\n+                        np = nn - 2 * pingPong;\n+                        b2 = work[np - 2];\n+                        gam = dN1;\n+                        if (work[np - 4]  >  work[np - 2]) {\n+                            return;\n+                        }\n+                        a2 = work[np - 4] / work[np - 2];\n+                        if (work[nn - 9]  >  work[nn - 11]) {\n+                            return;\n+                        }\n+                        b2 = work[nn - 9] / work[nn - 11];\n+                        np = nn - 13;\n+                    }\n+\n+                    // approximate contribution to norm squared from i < nn-1.\n+                    a2 = a2 + b2;\n+                    for (int i4 = np; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {\n+                        if(b2 == 0.0) {\n+                            break;\n+                        }\n+                        b1 = b2;\n+                        if (work[i4]  >  work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                        a2 = a2 + b2;\n+                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n+                            break;\n+                        }\n+                    }\n+                    a2 = cnst3 * a2;\n+\n+                    // rayleigh quotient residual bound.\n+                    if (a2 < cnst1) {\n+                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n+                    }\n+                    tau = s;\n+\n+                }\n+            } else if (dMin == dN2) {\n+\n+                // case 5.\n+                tType = -5;\n+                double s = 0.25 * dMin;\n+\n+                // compute contribution to norm squared from i > nn-2.\n+                final int np = nn - 2 * pingPong;\n+                double b1 = work[np - 2];\n+                double b2 = work[np - 6];\n+                final double gam = dN2;\n+                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                    return;\n+                }\n+                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n+\n+                // approximate contribution to norm squared from i < nn-2.\n+                if (end - start > 2) {\n+                    b2 = work[nn - 13] / work[nn - 15];\n+                    a2 = a2 + b2;\n+                    for (int i4 = nn - 17; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {\n+                        if (b2 == 0.0) {\n+                            break;\n+                        }\n+                        b1 = b2;\n+                        if (work[i4]  >  work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                        a2 = a2 + b2;\n+                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n+                            break;\n+                        }\n+                    }\n+                    a2 = cnst3 * a2;\n+                }\n+\n+                if (a2 < cnst1) {\n+                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n+                } else {\n+                    tau = s;\n+                }\n+\n+            } else {\n+\n+                // case 6, no information to guide us.\n+                if (tType == -6) {\n+                    g += 0.333 * (1 - g);\n+                } else if (tType == -18) {\n+                    g = 0.25 * 0.333;\n+                } else {\n+                    g = 0.25;\n+                }\n+                tau   = g * dMin;\n+                tType = -6;\n+\n+            }\n+            break;\n+\n+        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n+            if (dMin1 == dN1 && dMin2 == dN2) { \n+\n+                // cases 7 and 8.\n+                tType = -7;\n+                double s = 0.333 * dMin1;\n+                if (work[nn - 5] > work[nn - 7]) {\n+                    return;\n+                }\n+                double b1 = work[nn - 5] / work[nn - 7];\n+                double b2 = b1;\n+                if (b2 != 0.0) {\n+                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {\n+                        final double oldB1 = b1;\n+                        if (work[i4] > work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b1 = b1 * (work[i4] / work[i4 - 2]);\n+                        b2 = b2 + b1;\n+                        if (100 * Math.max(b1, oldB1) < b2) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                b2 = Math.sqrt(cnst3 * b2);\n+                final double a2 = dMin1 / (1 + b2 * b2);\n+                final double gap2 = 0.5 * dMin2 - a2;\n+                if (gap2 > 0.0 && gap2 > b2 * a2) {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n+                } else {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n+                    tType = -8;\n+                }\n+            } else {\n+\n+                // case 9.\n+                tau = 0.25 * dMin1;\n+                if (dMin1 == dN1) {\n+                    tau = 0.5 * dMin1;\n+                }\n+                tType = -9;\n+            }\n+            break;\n+\n+        case 2 : // two eigenvalues deflated. use dMin2, dN2 for dMin and dN.\n+\n+            // cases 10 and 11.\n+            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { \n+                tType = -10;\n+                final double s = 0.333 * dMin2;\n+                if (work[nn - 5] > work[nn - 7]) {\n+                    return;\n+                }\n+                double b1 = work[nn - 5] / work[nn - 7];\n+                double b2 = b1;\n+                if (b2 != 0.0){\n+                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {\n+                        if (work[i4] > work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b1 *= work[i4] / work[i4 - 2];\n+                        b2 += b1;\n+                        if (100 * b1 < b2) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                b2 = Math.sqrt(cnst3 * b2);\n+                final double a2 = dMin2 / (1 + b2 * b2);\n+                final double gap2 = work[nn - 7] + work[nn - 9] -\n+                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n+                if (gap2 > 0.0 && gap2 > b2 * a2) {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n+                } else {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n+                }\n+            } else {\n+                tau   = 0.25 * dMin2;\n+                tType = -11;\n+            }\n+            break;\n+\n+        default : // case 12, more than two eigenvalues deflated. no information.\n+            tau   = 0.0;\n+            tType = -12;\n+        }\n+\n+    }\n+\n+    /**\n+     * Update sigma.\n+     * @param tau shift to apply to sigma\n+     */\n+    private void updateSigma(final double tau) {\n+        // BEWARE: do NOT attempt to simplify the following statements\n+        // the expressions below take care to accumulate the part of sigma\n+        // that does not fit within a double variable into sigmaLow\n+        if (tau < sigma) {\n+            sigmaLow += tau;\n+            final double t = sigma + sigmaLow;\n+            sigmaLow -= t - sigma;\n+            sigma = t;\n+        } else {\n+            final double t = sigma + tau;\n+            sigmaLow += sigma - (t - tau);\n+            sigma = t;\n+        }\n+    }\n+\n+    /**\n+     * Find eigenvectors.\n+     */\n+    private void findEigenVectors() {\n+\n+        final int m = main.length;\n+        eigenvectors = new RealVectorImpl[m];\n+\n+        // perform an initial non-shifted LDLt decomposition\n+        final double[] d = new double[m];\n+        final double[] l = new double[m - 1];\n+        double di = main[0];\n+        d[0] = di;\n+        for (int i = 1; i < m; ++i) {\n+            final double eiM1  = secondary[i - 1];\n+            final double ratio = eiM1 / di;\n+            di       = main[i] - eiM1 * ratio;\n+            l[i - 1] = ratio;\n+            d[i]     = di;\n+        }\n+\n+        // compute eigenvectors\n+        for (int i = 0; i < m; ++i) {\n+            eigenvectors[i] = findEigenvector(eigenvalues[i], d, l);\n+        }\n+\n+    }\n+\n+    /**\n+     * Find an eigenvector corresponding to an eigenvalue, using bidiagonals.\n+     * <p>This method corresponds to algorithm X from Dhillon's thesis.</p>\n+     * \n      * @param eigenvalue eigenvalue for which eigenvector is desired\n-     * @param eigenvector placeholder where to put the eigenvector\n-     * @param main main diagonal of the tridiagonal matrix\n-     * @param secondary secondary diagonal of the tridiagonal matrix\n-     * @param lp placeholder where to put the off-diagonal elements of the\n-     * L<sub>+</sub> matrix\n-     * @param dp placeholder where to put the diagonal elements of the\n-     * D<sub>+</sub> matrix\n-     * @param um placeholder where to put the off-diagonal elements of the\n-     * U<sub>-</sub> matrix\n-     * @param dm placeholder where to put the diagonal elements of the\n-     * D<sub>-</sub> matrix\n-     * @param gamma placeholder where to put the twist elements for all\n-     * possible twist indices\n-     */\n-    private void findEigenvector(final double eigenvalue, final double[] eigenvector,\n-                                 final double[] main, final double[] secondary,\n-                                 final double[] lp, final double[] dp,\n-                                 final double[] um, final double[] dm,\n-                                 final double[] gamma) {\n-\n-        // compute the LDU and UDL decomposition of the\n+     * @param d diagonal elements of the initial non-shifted D matrix\n+     * @param l off-diagonal elements of the initial non-shifted L matrix\n+     * @return an eigenvector\n+     */\n+    private RealVectorImpl findEigenvector(final double eigenvalue,\n+                                           final double[] d, final double[] l) {\n+\n+        // compute the LDLt and UDUt decompositions of the\n         // perfectly shifted tridiagonal matrix\n         final int m = main.length;\n-        lduDecomposition(main, secondary, eigenvalue, m, lp, dp);\n-        udlDecomposition(main, secondary, eigenvalue, 0, um, dm);\n+        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n+        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n \n         // select the twist index leading to\n         // the least diagonal element in the twisted factorization\n-        int r = 0;\n-        double g = dp[0] + dm[0] + eigenvalue - main[0];\n-        gamma[0] = g;\n-        double minG = Math.abs(g);\n-        for (int i = 1; i < m; ++i) {\n-            if (i < m - 1) {\n-                g *= dm[i + 1] / dp[i];\n-            } else {\n-                g = dp[m - 1] + dm[m - 1] + eigenvalue - main[m - 1];\n-            }\n-            gamma[i] = g;\n+        int r = m - 1;\n+        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n+        for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {\n+            final double g = work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10];\n             final double absG = Math.abs(g);\n             if (absG < minG) {\n                 r = i;\n \n         // solve the singular system by ignoring the equation\n         // at twist index and propagating upwards and downwards\n+        double[] eigenvector = new double[m];\n         double n2 = 1;\n         eigenvector[r] = 1;\n         double z = 1;\n         for (int i = r - 1; i >= 0; --i) {\n-            z *= -lp[i];\n+            z *= -work[6 * i + 2];\n             eigenvector[i] = z;\n             n2 += z * z;\n         }\n         z = 1;\n         for (int i = r + 1; i < m; ++i) {\n-            z *= -um[i-1];\n+            z *= -work[6 * i - 1];\n             eigenvector[i] = z;\n             n2 += z * z;\n         }\n             eigenvector[i] *= inv;\n         }\n \n+        return new RealVectorImpl(orthoTridiag.operate(eigenvector), true);\n+\n+    }\n+\n+    /**\n+     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n+     * L<sub>+</sub>D<sub>+</sub>L<sub>+</sub><sup>T</sup>.\n+     * <p>This method corresponds to algorithm 4.4.3 (dstqds) from Dhillon's thesis.</p>\n+     * @param d diagonal elements of D,\n+     * @param l off-diagonal elements of L\n+     * @param lambda shift to apply\n+     */\n+    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\n+                                                       final double lambda) {\n+        final int nM1 = d.length - 1;\n+        double si = -lambda;\n+        for (int i = 0, sixI = 0; i < nM1; ++i, sixI += 6) {\n+            final double di   = d[i];\n+            final double li   = l[i];\n+            final double diP1 = di + si;\n+            final double liP1 = li * di / diP1;\n+            work[sixI]        = si;\n+            work[sixI + 1]    = diP1;\n+            work[sixI + 2]    = liP1;\n+            si = li * liP1 * si - lambda;\n+        }\n+        work[6 * nM1 + 1] = d[nM1] + si;\n+        work[6 * nM1]     = si;\n+    }\n+\n+    /**\n+     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n+     * U<sub>-</sub>D<sub>-</sub>U<sub>-</sub><sup>T</sup>.\n+     * <p>This method corresponds to algorithm 4.4.5 (dqds) from Dhillon's thesis.</p>\n+     * @param d diagonal elements of D\n+     * @param l off-diagonal elements of L\n+     * @param lambda shift to apply\n+     */\n+    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\n+                                                        final double lambda) {\n+        final int nM1 = d.length - 1;\n+        double pi = d[nM1] - lambda;\n+        for (int i = nM1 - 1, sixI = 6 * i; i >= 0; --i, sixI -= 6) {\n+            final double di   = d[i];\n+            final double li   = l[i];\n+            final double diP1 = di * li * li + pi;\n+            final double t    = di / diP1;\n+            work[sixI +  9]   = pi;\n+            work[sixI + 10]   = diP1;\n+            work[sixI +  5]   = li * t;\n+            pi = pi * t - lambda;\n+        }\n+        work[3] = pi;\n+        work[4] = pi;\n     }\n \n     /**\n     private void checkDecomposed()\n         throws IllegalStateException {\n         if (eigenvalues == null) {\n-            throw new IllegalStateException(\"no matrix have been decomposed yet\");\n+            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n         }\n     }\n \n      * Check if decomposed matrix is non singular.\n      * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n      * has not been called\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @exception SingularMatrixException if decomposed matrix is singular\n      */\n     private void checkNonSingular()\n-        throws IllegalStateException, InvalidMatrixException {\n+        throws IllegalStateException, SingularMatrixException {\n         checkDecomposed();\n         if (!isNonSingular()) {\n-            throw new IllegalStateException(\"matrix is singular\");\n+            throw new SingularMatrixException();\n         }\n     }\n \n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n+import java.util.Arrays;\n import java.util.Random;\n \n import junit.framework.Test;\n \n     private double[] refValues;\n     private RealMatrix matrix;\n-\n-    private static final double normTolerance = 1.e-10;\n \n     public EigenDecompositionImplTest(String name) {\n         super(name);\n         TestSuite suite = new TestSuite(EigenDecompositionImplTest.class);\n         suite.setName(\"EigenDecompositionImpl Tests\");\n         return suite;\n+    }\n+\n+    public void testDimension1() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   { 1.5 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15);\n+    }\n+\n+    public void testDimension2() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {       59.0, 12.0 },\n+                                   { Double.NaN, 66.0 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15);\n+    }\n+\n+    public void testDimension3() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {    39632.0,    -4824.0, -16560.0 },\n+                                   { Double.NaN,     8693.0,   7920.0 },\n+                                   { Double.NaN, Double.NaN,  17300.0 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11);\n+        assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11);\n+        assertEquals( 3125.0, ed.getEigenvalue(2), 3.0e-11);\n+    }\n+\n+    public void testDimension4WithSplit() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {      0.784,     -0.288,       0.000,  0.000 },\n+                                   { Double.NaN,      0.616,       0.000,  0.000 },\n+                                   { Double.NaN, Double.NaN,       0.164, -0.048 },\n+                                   { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n+    }\n+\n+    public void testDimension4WithoutSplit() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {  0.5608, -0.2016,  0.1152, -0.2976 },\n+                                   { -0.2016,  0.4432, -0.2304,  0.1152 },\n+                                   {  0.1152, -0.2304,  0.3088, -0.1344 },\n+                                   { -0.2976,  0.1152, -0.1344,  0.3872 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n     }\n \n     /** test dimensions */\n         double[] eigenValues = ed.getEigenvalues();\n         assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n-            assertEquals(refValues[i], eigenValues[eigenValues.length - 1 - i], 3.0e-15);\n+            assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n+        }\n+    }\n+\n+    /** test eigenvalues for a big matrix. */\n+    public void testBigMatrix() {\n+        Random r = new Random(17748333525117l);\n+        double[] bigValues = new double[200];\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            bigValues[i] = 2 * r.nextDouble() - 1;\n+        }\n+        Arrays.sort(bigValues);\n+        EigenDecomposition ed = new EigenDecompositionImpl(createTestMatrix(r, bigValues));\n+        double[] eigenValues = ed.getEigenvalues();\n+        assertEquals(bigValues.length, eigenValues.length);\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n         }\n     }\n \n         RealMatrix d  = ed.getD();\n         RealMatrix vT = ed.getVT();\n         double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        assertEquals(0, norm, 6.0e-13);\n     }\n \n     /** test that V is orthogonal */\n         RealMatrix v = new EigenDecompositionImpl(matrix).getV();\n         RealMatrix vTv = v.transpose().multiply(v);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n-        assertEquals(0, vTv.subtract(id).getNorm(), normTolerance);\n+        assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n     }\n \n     /** test solve dimension errors */\n         });\n \n         // using RealMatrix\n-        assertEquals(0, ed.solve(b).subtract(xRef).getNorm(), normTolerance);\n+        assertEquals(0, ed.solve(b).subtract(xRef).getNorm(), 2.0e-12);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n     }\n \n     private RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n-        final RealMatrix v = createOrthogonalMatrix(r, eigenValues.length);\n-        final RealMatrix d = createDiagonalMatrix(eigenValues, eigenValues.length);\n+        final int n = eigenValues.length;\n+        final RealMatrix v = createOrthogonalMatrix(r, n);\n+        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);\n         return v.multiply(d).multiply(v.transpose());\n     }\n \n-    private RealMatrix createOrthogonalMatrix(final Random r, final int size) {\n+    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {\n+\n         final double[][] data = new double[size][size];\n+\n         for (int i = 0; i < size; ++i) {\n-            for (int j = 0; j < size; ++j) {\n-                data[i][j] = 2 * r.nextDouble() - 1;\n-            }\n-        }\n-        final RealMatrix m = new RealMatrixImpl(data, false);\n-        return new QRDecompositionImpl(m).getQ();\n-    }\n-\n-    private RealMatrix createDiagonalMatrix(final double[] data, final int rows) {\n-        final double[][] dData = new double[rows][rows];\n-        for (int i = 0; i < data.length; ++i) {\n-            dData[i][i] = data[i];\n+            final double[] dataI = data[i];\n+            double norm2 = 0;\n+            do {\n+\n+                // generate randomly row I\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] = 2 * r.nextDouble() - 1;\n+                }\n+\n+                // project the row in the subspace orthogonal to previous rows\n+                for (int k = 0; k < i; ++k) {\n+                    final double[] dataK = data[k];\n+                    double dotProduct = 0;\n+                    for (int j = 0; j < size; ++j) {\n+                        dotProduct += dataI[j] * dataK[j];\n+                    }\n+                    for (int j = 0; j < size; ++j) {\n+                        dataI[j] -= dotProduct * dataK[j];\n+                    }\n+                }\n+\n+                // normalize the row\n+                norm2 = 0;\n+                for (final double dataIJ : dataI) {\n+                    norm2 += dataIJ * dataIJ;\n+                }\n+                final double inv = 1.0 / Math.sqrt(norm2);\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] *= inv;\n+                }\n+\n+            } while (norm2 * size < 0.01);\n+        }\n+\n+        return new RealMatrixImpl(data, false);\n+\n+    }\n+\n+    public static RealMatrix createDiagonalMatrix(final double[] diagonal,\n+                                                  final int rows, final int columns) {\n+        final double[][] dData = new double[rows][columns];\n+        for (int i = 0; i < Math.min(rows, columns); ++i) {\n+            dData[i][i] = diagonal[i];\n         }\n         return new RealMatrixImpl(dData, false);\n     }", "timestamp": 1227801042, "metainfo": ""}