{"sha": "8c0f61d6ee6d269dc9ab7b6b9f34f4f92590f694", "log": "MATH-768 Provided access to methods for finding complex roots of a polynomial in \"LaguerreSolver\" class. Added utility for converting an array of doubles to an array of \"Complex\" objects.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n package org.apache.commons.math3.analysis.solvers;\n \n import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.NoDataException;\n      */\n     public double laguerre(double lo, double hi,\n                            double fLo, double fHi) {\n-        double coefficients[] = getCoefficients();\n-        Complex c[] = new Complex[coefficients.length];\n-        for (int i = 0; i < coefficients.length; i++) {\n-            c[i] = new Complex(coefficients[i], 0);\n-        }\n+        final Complex c[] = ComplexUtils.convertToComplex(getCoefficients());\n+\n         Complex initial = new Complex(0.5 * (lo + hi), 0);\n         Complex z = complexSolver.solve(c, initial);\n         if (complexSolver.isRoot(lo, hi, z)) {\n             }\n             return r;\n         }\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given\n+     * coefficients, starting from the given initial value.\n+     * <br/>\n+     * Note: This method is not part of the API of {@link BaseUnivariateSolver}.\n+     *\n+     * @param coefficients Polynomial coefficients.\n+     * @param initial Start value.\n+     * @return the point at which the function value is zero.\n+     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n+     * if the maximum number of evaluations is exceeded.\n+     * @throws NullArgumentException if the {@code coefficients} is\n+     * {@code null}.\n+     * @throws NoDataException if the {@code coefficients} array is empty.\n+     */\n+    public Complex[] solveAllComplex(double[] coefficients,\n+                                     double initial) {\n+        setup(Integer.MAX_VALUE,\n+              new PolynomialFunction(coefficients),\n+              Double.NEGATIVE_INFINITY,\n+              Double.POSITIVE_INFINITY,\n+              initial);\n+        return complexSolver.solveAll(ComplexUtils.convertToComplex(coefficients),\n+                                      new Complex(initial, 0d));\n+    }\n+\n+    /**\n+     * Find a complex root for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * <br/>\n+     * Note: This method is not part of the API of {@link BaseUnivariateSolver}.\n+     *\n+     * @param coefficients Polynomial coefficients.\n+     * @param initial Start value.\n+     * @return the point at which the function value is zero.\n+     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n+     * if the maximum number of evaluations is exceeded.\n+     * @throws NullArgumentException if the {@code coefficients} is\n+     * {@code null}.\n+     * @throws NoDataException if the {@code coefficients} array is empty.\n+     */\n+    public Complex solveComplex(double[] coefficients,\n+                                double initial) {\n+        setup(Integer.MAX_VALUE,\n+              new PolynomialFunction(coefficients),\n+              Double.NEGATIVE_INFINITY,\n+              Double.POSITIVE_INFINITY,\n+              initial);\n+        return complexSolver.solve(ComplexUtils.convertToComplex(coefficients),\n+                                   new Complex(initial, 0d));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/complex/ComplexUtils.java\n+++ b/src/main/java/org/apache/commons/math3/complex/ComplexUtils.java\n     /**\n      * Default constructor.\n      */\n-    private ComplexUtils() {\n-        super();\n-    }\n+    private ComplexUtils() {}\n \n     /**\n      * Creates a complex number from the given polar representation.\n      * @param r the modulus of the complex number to create\n      * @param theta  the argument of the complex number to create\n      * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n-     * @throws MathIllegalArgumentException  if r is negative\n+     * @throws MathIllegalArgumentException if {@code r} is negative.\n      * @since 1.1\n      */\n     public static Complex polar2Complex(double r, double theta) {\n         return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n     }\n \n+    /**\n+     * Convert an array of primitive doubles to an array of {@code Complex} objects.\n+     *\n+     * @param real Array of numbers to be converted to their {@code Complex}\n+     * equivalent.\n+     * @return an array of {@code Complex} objects.\n+     *\n+     * @since 3.1\n+     */\n+    public static Complex[] convertToComplex(double[] real) {\n+        final Complex c[] = new Complex[real.length];\n+        for (int i = 0; i < real.length; i++) {\n+            c[i] = new Complex(real[i], 0);\n+        }\n+\n+        return c;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/solvers/LaguerreSolverTest.java\n import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.complex.Complex;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.TestUtils;\n import org.junit.Assert;\n import org.junit.Test;\n \n     }\n \n     /**\n-     * Test of solver for the quintic function using solveAll().\n-     * XXX commented out because \"solveAll\" is not part of the API.\n+     * Test of solver for the quintic function using\n+     * {@link LaguerreSolver#solveAllComplex(double[],double) solveAllComplex}.\n      */\n-    // public void testQuinticFunction2() {\n-    //     double initial = 0.0, tolerance;\n-    //     Complex expected, result[];\n+    @Test\n+    public void testQuinticFunction2() {\n+        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n+        final double[] coefficients = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n+        final LaguerreSolver solver = new LaguerreSolver();\n+        final Complex[] result = solver.solveAllComplex(coefficients, 0);\n \n-    //     // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n-    //     double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n-    //     LaguerreSolver solver = new LaguerreSolver();\n-    //     result = solver.solveAll(coefficients, initial);\n-\n-    //     expected = new Complex(0.0, -2.0);\n-    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-    //     TestUtils.assertContains(result, expected, tolerance);\n-\n-    //     expected = new Complex(0.0, 2.0);\n-    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-    //     TestUtils.assertContains(result, expected, tolerance);\n-\n-    //     expected = new Complex(0.5, 0.5 * FastMath.sqrt(3.0));\n-    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-    //     TestUtils.assertContains(result, expected, tolerance);\n-\n-    //     expected = new Complex(-1.0, 0.0);\n-    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-    //     TestUtils.assertContains(result, expected, tolerance);\n-\n-    //     expected = new Complex(0.5, -0.5 * FastMath.sqrt(3.0));\n-    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-    //     TestUtils.assertContains(result, expected, tolerance);\n-    // }\n+        for (Complex expected : new Complex[] { new Complex(0, -2),\n+                                                new Complex(0, 2),\n+                                                new Complex(0.5, 0.5 * FastMath.sqrt(3)),\n+                                                new Complex(-1, 0),\n+                                                new Complex(0.5, -0.5 * FastMath.sqrt(3.0)) }) {\n+            final double tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                                                  FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n+            TestUtils.assertContains(result, expected, tolerance);\n+        }\n+    }\n \n     /**\n      * Test of parameters for the solver.\n--- a/src/test/java/org/apache/commons/math3/complex/ComplexUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math3/complex/ComplexUtilsTest.java\n import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Test;\n-\n+import org.junit.Assert;\n \n /**\n  * @version $Id$\n         TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));\n     }\n \n+    @Test\n+    public void testConvertToComplex() {\n+        final double[] real = new double[] { negInf, -123.45, 0, 1, 234.56, pi, inf };\n+        final Complex[] complex = ComplexUtils.convertToComplex(real);\n+\n+        for (int i = 0; i < real.length; i++) {\n+            Assert.assertEquals(real[i], complex[i].getReal(), 0d);\n+        }\n+    }\n }", "timestamp": 1342385413, "metainfo": ""}