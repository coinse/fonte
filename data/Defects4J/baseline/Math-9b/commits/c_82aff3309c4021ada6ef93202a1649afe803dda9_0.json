{"sha": "82aff3309c4021ada6ef93202a1649afe803dda9", "log": "Added support for sparse real matrices JIRA: MATH-230  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n \n     /** {@inheritDoc} */\n     public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" addition compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(),\n-                                                                          getColumnDimension(),\n-                                                                          m.getRowDimension(),\n-                                                                          m.getColumnDimension()\n-                                                                      });\n-        }\n-\n         final RealMatrix out = createMatrix(rowCount, columnCount);\n         for (int row = 0; row < rowCount; ++row) {\n             for (int col = 0; col < columnCount; ++col) {\n \n     /** {@inheritDoc} */\n     public RealMatrix subtract(final RealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" subtraction compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(),\n-                                                                          getColumnDimension(),\n-                                                                          m.getRowDimension(),\n-                                                                          m.getColumnDimension()\n-                                                                      });\n-        }\n-\n         final RealMatrix out = createMatrix(rowCount, columnCount);\n         for (int row = 0; row < rowCount; ++row) {\n             for (int col = 0; col < columnCount; ++col) {\n     /** {@inheritDoc} */\n     public RealMatrix multiply(final RealMatrix m)\n         throws IllegalArgumentException {\n-        if (getColumnDimension() != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" multiplication compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(),\n-                                                                          getColumnDimension(),\n-                                                                          m.getRowDimension(),\n-                                                                          m.getColumnDimension()\n-                                                                      });\n-        }\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n \n         final int nRows = getRowDimension();\n         final int nCols = m.getColumnDimension();\n-        final int nSum = getColumnDimension();\n+        final int nSum  = getColumnDimension();\n         final RealMatrix out = createMatrix(nRows, nCols);\n         for (int row = 0; row < nRows; ++row) {\n             for (int col = 0; col < nCols; ++col) {\n     }\n \n     /** {@inheritDoc} */\n-    public abstract double[][] getData();\n+    public double[][] getData() {\n+\n+        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n+\n+        for (int i = 0; i < data.length; ++i) {\n+            final double[] dataI = data[i];\n+            for (int j = 0; j < dataI.length; ++j) {\n+                dataI[j] = getEntry(i, j);\n+            }\n+        }\n+\n+        return data;\n+\n+    }\n \n     /** {@inheritDoc} */\n     public double getNorm() {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final StringBuffer res = new StringBuffer();\n-        res.append(\"RealMatrixImpl{\");\n+        String fullClassName = getClass().getName();\n+        String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);\n+        res.append(shortClassName).append(\"{\");\n \n         for (int i = 0; i < nRows; ++i) {\n             if (i > 0) {\n      * @param row row index to check\n      * @exception MatrixIndexException if index is not valid\n      */\n-    private void checkRowIndex(final int row) {\n+    protected void checkRowIndex(final int row) {\n         if (row < 0 || row >= getRowDimension()) {\n             throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n                                            new Object[] { row, 0, getRowDimension() - 1});\n      * @param column column index to check\n      * @exception MatrixIndexException if index is not valid\n      */\n-    private void checkColumnIndex(final int column)\n+    protected void checkColumnIndex(final int column)\n         throws MatrixIndexException {\n         if (column < 0 || column >= getColumnDimension()) {\n             throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n         }\n     }\n \n+    /**\n+     * Check if a matrix is addition compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not addition compatible with instance\n+     */\n+    protected void checkAdditionCompatible(final RealMatrix m) {\n+        if ((getRowDimension()    != m.getRowDimension()) ||\n+            (getColumnDimension() != m.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n+                                                                      \" addition compatible\",\n+                                                                      new Object[] {\n+                                                                          getRowDimension(),\n+                                                                          getColumnDimension(),\n+                                                                          m.getRowDimension(),\n+                                                                          m.getColumnDimension()\n+                                                                      });\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is subtraction compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not subtraction compatible with instance\n+     */\n+    protected void checkSubtractionCompatible(final RealMatrix m) {\n+        if ((getRowDimension()    != m.getRowDimension()) ||\n+            (getColumnDimension() != m.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n+                                                                      \" subtraction compatible\",\n+                                                                      new Object[] {\n+                                                                          getRowDimension(),\n+                                                                          getColumnDimension(),\n+                                                                          m.getRowDimension(),\n+                                                                          m.getColumnDimension()\n+                                                                      });\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is multiplication compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not multiplication compatible with instance\n+     */\n+    protected void checkMultiplicationCompatible(final RealMatrix m) {\n+        if (getColumnDimension() != m.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n+                                                                      \" multiplication compatible\",\n+                                                                      new Object[] {\n+                                                                          getRowDimension(),\n+                                                                          getColumnDimension(),\n+                                                                          m.getRowDimension(),\n+                                                                          m.getColumnDimension()\n+                                                                      });\n+        }\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n      */\n     public RealMatrixImpl add(final RealMatrixImpl m)\n         throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" addition compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(), getColumnDimension(),\n-                                                                          m.getRowDimension(), m.getColumnDimension()\n-                                                                      });\n-        }\n         final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n             final double[] dataRow    = data[row];\n             final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n                 outDataRow[col] = dataRow[col] + mRow[col];\n-            }  \n-        }\n+            }\n+        }\n+\n         return new RealMatrixImpl(outData, false);\n+\n     }\n \n     /** {@inheritDoc} */\n      */\n     public RealMatrixImpl subtract(final RealMatrixImpl m)\n         throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" subtraction compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(), getColumnDimension(),\n-                                                                          m.getRowDimension(), m.getColumnDimension()\n-                                                                      });\n-        }\n         final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n             final double[] dataRow    = data[row];\n             final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n                 outDataRow[col] = dataRow[col] - mRow[col];\n-            }  \n-        }\n+            }\n+        }\n+\n         return new RealMatrixImpl(outData, false);\n+\n     }\n \n     /** {@inheritDoc} */\n      */\n     public RealMatrixImpl multiply(final RealMatrixImpl m)\n         throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" multiplication compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(), getColumnDimension(),\n-                                                                          m.getRowDimension(), m.getColumnDimension()\n-                                                                      });\n-        }\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n         final int nRows = this.getRowDimension();\n         final int nCols = m.getColumnDimension();\n         final int nSum = this.getColumnDimension();\n                 }\n                 outDataRow[col] = sum;\n             }\n-        }            \n+        }\n+\n         return new RealMatrixImpl(outData, false);\n+\n     }\n \n     /** {@inheritDoc} */\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n+\n+/**\n+ * Sparse matrix implementation based on an open addressed map.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SparseRealMatrix extends AbstractRealMatrix {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5962461716457143437L;\n+\n+    /** Number of rows of the matrix. */\n+    private final int rowDimension;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columnDimension;\n+\n+    /** Storage for (sparse) matrix elements. */\n+    private OpenIntToDoubleHashMap entries;\n+\n+    /**\n+     * Build a sparse matrix with the supplied row and column dimensions.\n+     * @param rowDimension number of rows of the matrix\n+     * @param columnDimension number of columns of the matrix\n+     */\n+    public SparseRealMatrix(int rowDimension, int columnDimension) {\n+        super(rowDimension, columnDimension);\n+        this.rowDimension = rowDimension;\n+        this.columnDimension = columnDimension;\n+        this.entries = new OpenIntToDoubleHashMap();\n+    }\n+  \n+    /**\n+     * Build a matrix by copying another one.\n+     * @param matrix matrix to copy\n+     */\n+    public SparseRealMatrix(SparseRealMatrix matrix) {\n+        this.rowDimension = matrix.rowDimension;\n+        this.columnDimension = matrix.columnDimension;\n+        this.entries = new OpenIntToDoubleHashMap(matrix.entries);\n+    }\n+  \n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix copy() {\n+        return new SparseRealMatrix(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix createMatrix(int rowDimension, int columnDimension)\n+            throws IllegalArgumentException {\n+        return new SparseRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columnDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((SparseRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix add(SparseRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final RealMatrix out = new SparseRealMatrix(this);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n+            final OpenIntToDoubleHashMap.Entry entry = iterator.next();\n+            final int row = entry.key() / columnDimension;\n+            final int col = entry.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) + entry.value());\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((SparseRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix subtract(SparseRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final RealMatrix out = new SparseRealMatrix(this);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n+            final OpenIntToDoubleHashMap.Entry entry = iterator.next();\n+            final int row = entry.key() / columnDimension;\n+            final int col = entry.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) - entry.value());\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(int row, int column) throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        return entries.get(computeKey(row, column));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rowDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(int row, int column, double value)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        if (value == 0.0) {\n+            entries.remove(computeKey(row, column));\n+        } else {\n+            entries.put(computeKey(row, column), value);\n+        }\n+    }\n+\n+    /**\n+     * Compute the key to access a matrix element\n+     * @param row row index of the matrix element\n+     * @param column column index of the matrix element\n+     * @return key within the map to access the matrix element\n+     */\n+    private int computeKey(int row, int column) {\n+        return row * columnDimension + column;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SparseRealMatrix} class.\n+ * \n+ * @version $Revision$ $Date: 2008-11-07 06:48:13 -0800 (Fri, 07 Nov\n+ *          2008) $\n+ */\n+public final class SparseRealMatrixTest extends TestCase {\n+\n+    // 3 x 3 identity matrix\n+    protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };\n+    // Test data for group operations\n+    protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d },\n+            { 1d, 0d, 8d } };\n+    protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d },\n+            { 0.5d, 0.2d, .2d } };\n+    protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d },\n+            { 3d, 2d, 10d } };\n+    protected double[][] testDataMinus = { { -1d, -2d, -3d },\n+            { -2d, -5d, -3d }, { -1d, 0d, -8d } };\n+    protected double[] testDataRow1 = { 1d, 2d, 3d };\n+    protected double[] testDataCol3 = { 3d, 3d, 8d };\n+    protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d },\n+            { 5d, -2d, -1d } };\n+    protected double[] preMultTest = { 8, 12, 33 };\n+    protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };\n+    protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } };\n+    protected double[][] testDataPlusInv = { { -39d, 18d, 12d },\n+            { 15d, 0d, 0d }, { 6d, -2d, 7d } };\n+\n+    // lu decomposition tests\n+    protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } };\n+    protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d },\n+            { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } };\n+\n+    // singular matrices\n+    protected double[][] singular = { { 2d, 3d }, { 2d, 3d } };\n+    protected double[][] bigSingular = { { 1d, 2d, 3d, 4d },\n+            { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th\n+\n+    // row\n+    // =\n+    // 1st\n+    // +\n+    // 2nd\n+    protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d },\n+            { 7d, 8d, 10d } };\n+    protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } };\n+\n+    // vectors\n+    protected double[] testVector = { 1, 2, 3 };\n+    protected double[] testVector2 = { 1, 2, 3, 4 };\n+\n+    // submatrix accessor tests\n+    protected double[][] subTestData = { { 1, 2, 3, 4 },\n+            { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } };\n+\n+    // array selections\n+    protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } };\n+    protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } };\n+    protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } };\n+\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } };\n+    protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } };\n+\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } };\n+    protected double[][] subRows23Cols00 = { { 2 }, { 4 } };\n+    protected double[][] subRows00Cols33 = { { 4 } };\n+\n+    // row matrices\n+    protected double[][] subRow0 = { { 1, 2, 3, 4 } };\n+    protected double[][] subRow3 = { { 4, 5, 6, 7 } };\n+\n+    // column matrices\n+    protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } };\n+    protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } };\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    public SparseRealMatrixTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SparseRealMatrixTest.class);\n+        suite.setName(\"SparseRealMatrix Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix m2 = createSparseMatrix(testData2);\n+        assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n+        assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n+        assertTrue(\"testData is square\", m.isSquare());\n+        assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n+        assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n+        assertTrue(\"testData2 is not square\", !m2.isSquare());\n+    }\n+\n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        SparseRealMatrix m1 = createSparseMatrix(testData);\n+        RealMatrix m2 = m1.copy();\n+        assertTrue(m2 instanceof SparseRealMatrix);\n+        assertEquals(((SparseRealMatrix) m2), m1);\n+        SparseRealMatrix m3 = createSparseMatrix(testData);\n+        RealMatrix m4 = m3.copy();\n+        assertTrue(m4 instanceof SparseRealMatrix);\n+        assertEquals(((SparseRealMatrix) m4), m3);\n+    }\n+\n+    /** test add */\n+    public void testAdd() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix mInv = createSparseMatrix(testDataInv);\n+        SparseRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\", \n+                    mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col), \n+                    entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test add failure */\n+    public void testAddFail() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix m2 = createSparseMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+\n+    /** test norm */\n+    public void testNorm() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix m2 = createSparseMatrix(testData2);\n+        assertEquals(\"testData norm\", 14d, m.getNorm(), entryTolerance);\n+        assertEquals(\"testData2 norm\", 7d, m2.getNorm(), entryTolerance);\n+    }\n+\n+    /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix n = createSparseMatrix(testDataInv);\n+        assertClose(\"m-n = m + -n\", m.subtract(n),\n+            n.scalarMultiply(-1d).add(m), entryTolerance);\n+        try {\n+            m.subtract(createSparseMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+\n+    /** test multiply */\n+    public void testMultiply() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix mInv = createSparseMatrix(testDataInv);\n+        SparseRealMatrix identity = createSparseMatrix(id);\n+        SparseRealMatrix m2 = createSparseMatrix(testData2);\n+        assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.multiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.multiply(mInv), mInv,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m2.multiply(identity), m2,\n+                entryTolerance);\n+        try {\n+            m.multiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+\n+    // Additional Test for RealMatrixImplTest.testMultiply\n+\n+    private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n+    private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };\n+    private double[][] d5 = new double[][] { { 30 }, { 70 } };\n+\n+    public void testMultiply2() {\n+        RealMatrix m3 = createSparseMatrix(d3);\n+        RealMatrix m4 = createSparseMatrix(d4);\n+        RealMatrix m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+    }\n+\n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = createSparseMatrix(id);\n+        assertEquals(\"identity trace\", 3d, m.getTrace(), entryTolerance);\n+        m = createSparseMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            ;\n+        }\n+    }\n+\n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2), \n+            m.scalarAdd(2d), entryTolerance);\n+    }\n+\n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = createSparseMatrix(id);\n+        assertClose(\"identity operate\", testVector, m.operate(testVector),\n+                entryTolerance);\n+        assertClose(\"identity operate\", testVector, m.operate(\n+                new RealVectorImpl(testVector)).getData(), entryTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = createSparseMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 } });\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals(3.0, b[0], 1.0e-12);\n+        assertEquals(7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+\n+    /** test transpose */\n+    public void testTranspose() {\n+        \n+        RealMatrix m = createSparseMatrix(testData); \n+        RealMatrix mIT = new LUSolver(new LUDecompositionImpl(m)).getInverse().transpose();\n+        RealMatrix mTI = new LUSolver(new LUDecompositionImpl(m.transpose())).getInverse();\n+        assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = createSparseMatrix(testData2);\n+        RealMatrix mt = createSparseMatrix(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+\n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n+            normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(\n+            new RealVectorImpl(testVector).getData()), preMultTest, normTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+\n+    public void testPremultiply() {\n+        RealMatrix m3 = createSparseMatrix(d3);\n+        RealMatrix m4 = createSparseMatrix(d4);\n+        RealMatrix m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix mInv = createSparseMatrix(testDataInv);\n+        SparseRealMatrix identity = createSparseMatrix(id);\n+        assertClose(\"inverse multiply\", m.preMultiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.preMultiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.preMultiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.preMultiply(mInv), mInv,\n+                entryTolerance);\n+        try {\n+            m.preMultiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+\n+    public void testGetVectors() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertClose(\"get row\", m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+    }\n+\n+    public void testGetEntry() {\n+        RealMatrix m = createSparseMatrix(testData);\n+        assertEquals(\"get entry\", m.getEntry(0, 1), 2d, entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };\n+        RealMatrix m = createSparseMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } };\n+        RealMatrix n = createSparseMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUSolver(new LUDecompositionImpl(p)).getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+\n+        // Solve example\n+        double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },\n+                { 4, -3, -5 } };\n+        RealMatrix coefficients = createSparseMatrix(coefficientsData);\n+        double[] constants = { 1, -2, 1 };\n+        double[] solution = new LUSolver(new LUDecompositionImpl(coefficients)).solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],\n+                constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],\n+                constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],\n+                constants[2], 1E-12);\n+\n+    }\n+\n+    // test submatrix accessors\n+    public void testSubMatrix() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);\n+        RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33);\n+        RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23);\n+        RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13);\n+        RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12);\n+        RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);\n+        RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);\n+        RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);\n+        assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n+        assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n+        assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n+        assertEquals(\"Rows02Cols13\", mRows02Cols13, \n+            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n+        assertEquals(\"Rows03Cols12\", mRows03Cols12, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n+        assertEquals(\"Rows03Cols123\", mRows03Cols123, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows20Cols123\", mRows20Cols123, \n+            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(-1, 1, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {}, new int[] { 0 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealMatrix mRow0 = createSparseMatrix(subRow0);\n+        RealMatrix mRow3 = createSparseMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnMatrix() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealMatrix mColumn1 = createSparseMatrix(subColumn1);\n+        RealMatrix mColumn3 = createSparseMatrix(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnVector() {\n+        RealMatrix m = createSparseMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new RealVectorImpl(data, false);\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        SparseRealMatrix m1 = (SparseRealMatrix) m.copy();\n+        SparseRealMatrix mt = (SparseRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(createSparseMatrix(bigSingular)));\n+    }\n+\n+    public void testToString() {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        assertEquals(\"SparseRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\", \n+            m.toString());\n+        m = new SparseRealMatrix(1, 1);\n+        assertEquals(\"SparseRealMatrix{{0.0}}\", m.toString());\n+    }\n+\n+    public void testSetSubMatrix() throws Exception {\n+        SparseRealMatrix m = createSparseMatrix(testData);\n+        m.setSubMatrix(detData2, 1, 1);\n+        RealMatrix expected = createSparseMatrix(new double[][] {\n+                { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(detData2, 0, 0);\n+        expected = createSparseMatrix(new double[][] {\n+                { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2, 0, 0);\n+        expected = createSparseMatrix(new double[][] {\n+                { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });\n+        assertEquals(expected, m);\n+\n+        // javadoc example\n+        SparseRealMatrix matrix = \n+            (SparseRealMatrix) createSparseMatrix(new double[][] { \n+            { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });\n+        matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);\n+        expected = createSparseMatrix(new double[][] {\n+                { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });\n+        assertEquals(expected, matrix);\n+\n+        // dimension overflow\n+        try {\n+            m.setSubMatrix(testData, 1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {\n+            m.setSubMatrix(testData, -1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {\n+            m.setSubMatrix(testData, 1, -1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+\n+        // null\n+        try {\n+            m.setSubMatrix(null, 1, 1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            new SparseRealMatrix(0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] { {} }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    // --------------- -----------------Protected methods\n+\n+    /** verifies that two matrices are close (1-norm) */\n+    protected void assertClose(String msg, RealMatrix m, RealMatrix n,\n+            double tolerance) {\n+        assertTrue(msg, m.subtract(n).getNorm() < tolerance);\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" + i + \" elements differ\", m[i], n[i],\n+                    tolerance);\n+        }\n+    }\n+    \n+    private SparseRealMatrix createSparseMatrix(double[][] data) {\n+        SparseRealMatrix matrix = new SparseRealMatrix(data.length, data[0].length);\n+        for (int row = 0; row < data.length; row++) {\n+            for (int col = 0; col < data[row].length; col++) {\n+                matrix.setEntry(row, col, data[row][col]);\n+            }\n+        }\n+        return matrix;\n+    }\n+}", "timestamp": 1229267062, "metainfo": ""}