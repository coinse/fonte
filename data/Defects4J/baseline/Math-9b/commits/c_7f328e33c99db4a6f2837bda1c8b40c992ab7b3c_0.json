{"sha": "7f328e33c99db4a6f2837bda1c8b40c992ab7b3c", "log": "Dummy tests removed after revision 910475  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n         Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);\n     }\n \n-    // Forget about this test, SVD is no longer truncated!\n-    // @Test\n-    public void testTruncated() {\n-\n-        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n-            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n-        });\n-        double s439  = Math.sqrt(439.0);\n-        double[] reference = new double[] {\n-            Math.sqrt(3.0 * (21.0 + s439))\n-        };\n-        SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(rm, 1);\n-\n-        // check we get the expected theoretical singular values\n-        double[] singularValues = svd.getSingularValues();\n-        Assert.assertEquals(reference.length, singularValues.length);\n-        for (int i = 0; i < reference.length; ++i) {\n-            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n-        }\n-\n-        // check the truncated decomposition DON'T allows to recover the original matrix\n-        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n-        Assert.assertTrue(recomposed.subtract(rm).getNorm() > 1.4);\n-\n-    }\n-\n-    // Forget about this test, SVD is no longer truncated!\n-    //@Test\n-    public void testMath320A() {\n-        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n-            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n-        });\n-        double s439  = Math.sqrt(439.0);\n-        double[] reference = new double[] {\n-            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n-        };\n-        SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(rm);\n-\n-        // check we get the expected theoretical singular values\n-        double[] singularValues = svd.getSingularValues();\n-        Assert.assertEquals(reference.length, singularValues.length);\n-        for (int i = 0; i < reference.length; ++i) {\n-            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n-        }\n-\n-        // check the decomposition allows to recover the original matrix\n-        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n-        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\n-\n-        // check we can solve a singular system\n-        double[] b = new double[] { 5.0, 6.0, 7.0 };\n-        double[] resSVD = svd.getSolver().solve(b);\n-        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n-\n-        // check the solution really minimizes the residuals\n-        double svdMinResidual = residual(rm, resSVD, b);\n-        double epsilon = 2 * Math.ulp(svdMinResidual);\n-        double h = 0.1;\n-        int    k = 3;\n-        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n-            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n-                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n-                    double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\n-                    Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\n-                }\n-            }\n-        }\n-\n-    }\n-\n     @Test\n     public void testMath320B() {\n         RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n         Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n     }\n \n-    private double residual(RealMatrix a, double[] x, double[] b) {\n-        double[] ax = a.operate(x);\n-        double sum = 0;\n-        for (int i = 0; i < ax.length; ++i) {\n-            sum += (ax[i] - b[i]) * (ax[i] - b[i]);\n-        }\n-        return Math.sqrt(sum);\n-    }\n-\n }", "timestamp": 1266319217, "metainfo": ""}