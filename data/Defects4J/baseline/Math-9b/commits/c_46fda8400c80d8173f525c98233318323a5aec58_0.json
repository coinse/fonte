{"sha": "46fda8400c80d8173f525c98233318323a5aec58", "log": "Final keyword.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/regression/MillerUpdatingRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/MillerUpdatingRegression.java\n         if (!this.hasIntercept) {\n             include(MathArrays.copyOf(x, x.length), 1.0, y);\n         } else {\n-            double[] tmp = new double[x.length + 1];\n+            final double[] tmp = new double[x.length + 1];\n             System.arraycopy(x, 0, tmp, 1, x.length);\n             tmp[0] = 1.0;\n             include(tmp, 1.0, y);\n             _w = w;\n             if (di != 0.0) {\n                 dpi = smartAdd(di, wxi * xi);\n-                double tmp = wxi * xi / di;\n+                final double tmp = wxi * xi / di;\n                 if (FastMath.abs(tmp) > Precision.EPSILON) {\n                     w = (di * w) / dpi;\n                 }\n      * @return the sum of the a and b\n      */\n     private double smartAdd(double a, double b) {\n-        double _a = FastMath.abs(a);\n-        double _b = FastMath.abs(b);\n+        final double _a = FastMath.abs(a);\n+        final double _b = FastMath.abs(b);\n         if (_a > _b) {\n-            double eps = _a * Precision.EPSILON;\n+            final double eps = _a * Precision.EPSILON;\n             if (_b > eps) {\n                 return a + b;\n             }\n             return a;\n         } else {\n-            double eps = _b * Precision.EPSILON;\n+            final double eps = _b * Precision.EPSILON;\n             if (_a > eps) {\n                 return a + b;\n             }\n         if (!this.tol_set) {\n             tolset();\n         }\n-        double[] ret = new double[nreq];\n+        final double[] ret = new double[nreq];\n         boolean rankProblem = false;\n         for (int i = nreq - 1; i > -1; i--) {\n             if (Math.sqrt(d[i]) < tol[i]) {\n      * columns.\n      */\n     private void singcheck() {\n-        double temp;\n-        double y;\n-        double weight;\n         int pos;\n         for (int i = 0; i < nvars; i++) {\n             work_sing[i] = Math.sqrt(d[i]);\n             // Set elements within R to zero if they are less than tol(col) in\n             // absolute value after being scaled by the square root of their row\n             // multiplier\n-            temp = tol[col];\n+            final double temp = tol[col];\n             pos = col - 1;\n             for (int row = 0; row < col - 1; row++) {\n                 if (Math.abs(r[pos]) * work_sing[row] < temp) {\n                         x_sing[_xi] = r[_pi];\n                         r[_pi] = 0.0;\n                     }\n-                    y = rhs[col];\n-                    weight = d[col];\n+                    final double y = rhs[col];\n+                    final double weight = d[col];\n                     d[col] = 0.0;\n                     rhs[col] = 0.0;\n                     this.include(x_sing, weight, y);\n                 rnk += 1.0;\n             }\n         }\n-        double var = rss[nreq - 1] / (nobs - rnk);\n-        double[] rinv = new double[nreq * (nreq - 1) / 2];\n+        final double var = rss[nreq - 1] / (nobs - rnk);\n+        final double[] rinv = new double[nreq * (nreq - 1) / 2];\n         inverse(rinv, nreq);\n-        double[] covmat = new double[nreq * (nreq + 1) / 2];\n+        final double[] covmat = new double[nreq * (nreq + 1) / 2];\n         Arrays.fill(covmat, Double.NaN);\n         int pos2;\n         int pos1;\n         int pos1 = -1;\n         int pos2 = -1;\n         double total = 0.0;\n-        int start;\n         Arrays.fill(rinv, Double.NaN);\n         for (int row = nreq - 1; row > 0; --row) {\n             if (!this.lindep[row]) {\n-                start = (row - 1) * (nvars + nvars - row) / 2;\n+                final int start = (row - 1) * (nvars + nvars - row) / 2;\n                 for (int col = nreq; col > row; --col) {\n                     pos1 = start;\n                     pos2 = pos;\n      * regressors with each other and the regressand, in lower triangular form\n      */\n     public double[] getPartialCorrelations(int in) {\n-        double[] output = new double[(nvars - in + 1) * (nvars - in) / 2];\n-        int base_pos;\n+        final double[] output = new double[(nvars - in + 1) * (nvars - in) / 2];\n         int pos;\n         int pos1;\n         int pos2;\n-        int rms_off = -in;\n-        int wrk_off = -(in + 1);\n-        double[] rms = new double[nvars - in];\n-        double[] work = new double[nvars - in - 1];\n+        final int rms_off = -in;\n+        final int wrk_off = -(in + 1);\n+        final double[] rms = new double[nvars - in];\n+        final double[] work = new double[nvars - in - 1];\n         double sumxx;\n         double sumxy;\n         double sumyy;\n-        int offXX = (nvars - in) * (nvars - in - 1) / 2;\n+        final int offXX = (nvars - in) * (nvars - in - 1) / 2;\n         if (in < -1 || in >= nvars) {\n             return null;\n         }\n-        int nvm = nvars - 1;\n-        base_pos = r.length - (nvm - in) * (nvm - in + 1) / 2;\n+        final int nvm = nvars - 1;\n+        final int base_pos = r.length - (nvm - in) * (nvm - in + 1) / 2;\n         if (d[in] > 0.0) {\n             rms[in + rms_off] = 1.0 / Math.sqrt(d[in]);\n         }", "timestamp": 1349102515, "metainfo": ""}