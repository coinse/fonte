{"sha": "e30f62314b487158b4ba77e8379cd4f2cd4c77a9", "log": "Phil Steitz wrote:  This commit contains the suite of random data generation utilities that I originally proposed as extensions to lang.math.  There is some functional overlap with lang.math, but the contract and intention of this implementation is different in several significant ways.  * the lang implementation maintains \"immutability\" of the underlying    random number generator (emulating Math). The RandomData    implementation allows users to reseed the random number generator(s)    (this is in effect possible in the recent extensions to lang.math by    passing in a user-supplied random as an actual parameter to the    next() methods) Users can also reset the PRNG algorithm and provider    used by the \"secure\" methods.  * RandomData includes \"secure\" methods (delegating to SecureRandom)  * RandomData will generate random deviates from exponential and poisson,    as well as Gaussian and Uniform distributions.  These are useful in    simulation applications.  * Overlapping somewhat with lang.StringUtils, RandomData will generate    random hex strings.  There is a nextSecureHexString method that will    (I claim :-) generate cryptographically secure string identifiers. I    would appreciate feedback on this algorithm, which I have seen used    elsewhere (similar to what tomcat does to generate session ids); but    not documented as a standard.  PR: Bugzilla 20013 Obtained from: Phil S. Submitted by: Phil S. Reviewed by: Tim O.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/RandomData.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math;\n+\n+/**\n+ * Random data generation utilities\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/05/18 00:58:51 $\n+ */\n+public interface RandomData {      \n+    /**\n+     * Generates a random string of hex characters of length\n+     * <code>len</code>.<br>\n+     * The generated string will be random, but not cryptographically \n+     * secure. To generate cryptographically secure strings, use \n+     * <code>nextSecureHexString</code>\n+     * @param len the length of the string to be generated\n+     * @throws IllegalArgumentException if <code>len</code> is not positive.\n+     */\n+    public String nextHexString(int len);  \n+    \n+    /**\n+     * Generates a uniformly distributed random integer between \n+     * <code>lower</code> and <code>upper</code> (endpoints included).<br>\n+     * The generated integer will be random, but not cryptographically secure.\n+     * To generate cryptographically secure integer sequences, use \n+     * <code>nextSecureInt</code>.\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @exception IllegalArgumentException thrown if\n+     * <code>lower</code> is not strictly less than <code>upper</code>.\n+     * @return a random integer greater than or equal to <code>lower</code> \n+     * and less than or equal to <code>upper</code>.\n+     */\n+    public int nextInt(int lower, int upper);  \n+    \n+    /**\n+     * Generates a uniformly distributed random long integer between <\n+     * code>lower</code> and <code>upper</code> (endpoints included).\n+     * The generated long integer values will be random, but not \n+     * cryptographically secure.<br> \n+     * To generate cryptographically secure sequences of longs, use \n+     * <code>nextSecureLong</code>\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @exception IllegalArgumentException Thrown if lower > upper\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    public long nextLong(long lower, long upper);  \n+    \n+    /**\n+     * Generates a random string of hex characters from a secure random sequence.\n+     * If cryptographic security is not required, \n+     * use <code>nextHexString()</code>.\n+     * @param len length of return string\n+     * @exception IllegalArgumentException thrown if len <= 0 \n+     * @return the random hex string\n+     */\n+    public String nextSecureHexString(int len);  \n+    \n+    /**\n+     * Generates a uniformly distributed random integer between \n+     * <code>lower</code> and <code>upper</code> (endpoints included) \n+     * from a secure random sequence.<br>\n+     * The generated sequence will be cryptographically secure.<br>\n+     * If cryptographic security is not required, <code>nextInt</code>\n+     * should be used.<br>\n+     * <strong>Definition</strong>(secure random sequence):\n+     * http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator<br>\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @exception IllegalArgumentException thrown if\n+     * <code>lower</code> is not strictly less than <code>upper</code>.\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    public int nextSecureInt(int lower, int upper);  \n+    \n+    /**\n+     * Generates a random long integer between <code>lower</code>\n+     * and <code>upper</code> (endpoints included).<br>\n+     * The generated long sequence will be cryptographically secure.<br>\n+     * If cryptographic security is not required,\n+     * use <code>nextLong</code><br>\n+     * <strong>Definition</strong>:\n+     * <a href=http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator>\n+     * Secure Random Sequence</a>\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @exception IllegalArgumentException thrown if\n+     * <code>lower</code> is not strictly less than <code>upper</code>.\n+     * @return a long integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    public long nextSecureLong(long lower, long upper);  \n+    \n+    /** \n+     * Generates a random value from the Poisson distribution with \n+     * the given mean.<br>\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm>\n+     * Poisson Distribution</a><br>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The specified mean <i>must</i> be positive </li>\n+     * </ul>\n+     * @param mean Mean of the distribution\n+     * @returns long\n+     * @throws IllegalArgumentException if mean <= 0\n+     */\n+    public long nextPoisson(double mean);  \n+    \n+    /** \n+     * Generates a random value from the\n+     * Normal (a.k.a. Gaussian) distribution with the given mean\n+     * and standard deviation.<br>\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm>\n+     * Normal Distribution</a><br>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The specified standard deviation <i>must</i> be positive </li>\n+     * </ul>\n+     * @param mu Mean of the distribution\n+     * @param sigma Standard deviation of the distribution\n+     * @return random value from Gaussian distribution with mean = mu,\n+     * standard deviation = sigma\n+     * @throws IllegalArgumentExcption if sigma <= 0\n+     */\n+    public double nextGaussian(double mu,double sigma);  \n+    \n+    /**\n+     * Generates a random value from the exponential distribution\n+     * with expected value = <code>mean</code><br>\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm>\n+     * Exponential Distribution</a><br>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The specified mean <i>must</i> be non-negative</li>\n+     * </ul>\n+     * @param mu Mean of the distribution\n+     * @return random value from exponential distribution\n+     */\n+    public double nextExponential(double mean);   \n+    \n+    /**\n+     * Generates a uniformly distributed random value from the opem interval\n+     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded)\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm>\n+     * Uniform Distribution</a> <code>lower</code> and <code>upper - lower</code>\n+     * are the \n+     * <a href = http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm>\n+     * location and scale parameters</a>, respectively<br>\n+     * @param lower lower endpoint of the interval of support\n+     * @param upper upper endpoint of the interval of support\n+     * @return uniformly distributed random value between lower\n+     * and upper (exclusive)\n+     * @exception IllegalArgumentException thrown if\n+     * <code>lower</code> is not strictly less than <code>upper</code>.\n+     */\n+    public double nextUniform(double lower, double upper);   \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/RandomDataImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.security.MessageDigest;\n+import java.security.SecureRandom;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.util.Random;\n+\n+/**\n+ * Implements the <code>RandomData</code> interface using \n+ * <code>java.util.Random</code> and \n+ * <code>java.util.Random.SecureRandom</code> instances to generate data.\n+ * Supports reseeding the underlying \n+ * <a href=http://www.wikipedia.org/wiki/Pseudo-random_number_generator>PRNG</a>. \n+ * The <code>SecurityProvider</code> and <code>Algorithm</code>\n+ * used by the <code>SecureRandom</code> instance can also be reset.<p>\n+ * For details on the PRNGs, see the JDK documentation for \n+ * <code>java.util.Random</code> and \n+ * <code>java.util.Random.SecureRandom</code></p><p>\n+ * <strong>Usage Notes</strong>: <ul>\n+ * <li>Instance variables are used to maintain <code>Random</code> and \n+ * <code>SecureRandom</code> instances used in data generation. Therefore,\n+ * to generate a random sequence of values or strings, you should use just\n+ * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n+ * <li>The \"secure\" methods are *much* slower.  These should be used only when\n+ * a <a href=http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator>\n+ * Secure Random Sequence</a> is required.</li>\n+ *<li>When a new <code>RandomDataImpl</code> is created, the underlying random\n+ * number generators are <strong>not</strong> intialized.  The first call to a\n+ * data generation method, or to a <code>reSeed()</code> method instantiates\n+ * the appropriate generator.  If you do not explicitly seed the generator, it\n+ * is by default seeded with the current time in milliseconds</li>\n+ * <li>The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate to\n+ * the corresponding methods on the underlying <code>Random</code> and <code>\n+ * SecureRandom</code> instances.  Therefore, the contracts of these methods\n+ * are as defined in the JDK documentation.  In particular, <code>reSeed(long)\n+ * </code> fully resets the initial state of the non-secure random number \n+ * generator (so that reseeding with a specific value always results in the\n+ * same subsequent random sequence); whereas reSeedSecure(long) does <strong> not \n+ * </strong> reinitialize the secure random number generator (so secure sequences\n+ * started with calls to reseedSecure(long) won't be identical).</li></ul>\n+ *</p>\n+ * \n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/05/18 00:58:51 $\n+ */\n+public class RandomDataImpl implements RandomData{\n+    \n+    /** underlying random number generator */\n+    private Random rand = null;\n+    \n+    /** underlying secure random number generator */\n+    private SecureRandom secRand = null;\n+    \n+    public RandomDataImpl(){\n+    }\n+          \n+    /**\n+     * Generates a random string of hex characters\n+     * If cryptographic security is required, use \n+     * <code>nextSecureHexString()</code>.<br>\n+     * <strong>Algorithm Description:</strong> hex strings are generated \n+     * using a 2-step process. <ol>\n+     * <li>len/2+1 binary bytes are generated using the underlying Random</li>\n+     * <li>Each binary byte is translated into 2 hex digits</li></ol>\n+     * @param len length of return string\n+     * @exception IllegalArgumentException thrown if len <= 0 \n+     * @return the random hex string\n+     */\n+    public String nextHexString(int len) {\n+        if (len <= 0) {\n+            throw new IllegalArgumentException(\"length must be positive\");\n+        }\n+            \n+        //Get a random number generator\n+        Random ran = getRan();\n+        \n+        //Initialize output buffer\n+        StringBuffer outBuffer = new StringBuffer();\n+            \n+        //Get int(len/2)+1 random bytes\n+        byte[] randomBytes = new byte[(len / 2) + 1];\n+        ran.nextBytes(randomBytes);\n+ \n+        //Convert each byte to 2 hex digits\n+        for (int i = 0; i < randomBytes.length; i++) {\n+            Integer c = new Integer(randomBytes[i]);\n+                \n+            /* Add 128 to byte value to make interval 0-255 before\n+             * doing hex conversion.\n+             * This guarantees <= 2 hex digits from toHexString()\n+             * toHexString would otherwise add 2^32 to negative arguments.\n+             */\n+             String hex = Integer.toHexString(c.intValue()+128);\n+                \n+             // Make sure we add 2 hex digits for each byte\n+             if (hex.length() == 1) hex = \"0\" + hex;\n+             outBuffer.append(hex);\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+    \n+     \n+    public int nextInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"incorrect bounds for rendomInt\");\n+        }\n+        Random rand = getRan();\n+        return lower + (int)(Math.random() * (upper-lower+1));\n+    }\n+    \n+    public long nextLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"upper bound must be >= lower bound\");\n+        }\n+        Random rand = getRan();\n+        return lower + (long)(rand.nextDouble() * (upper-lower+1));\n+    }\n+    \n+     /**\n+     * Generates a random string of hex characters from a secure random sequence.\n+     * If cryptographic security is not required, \n+     * use <code>nextHexString()</code>.<br>\n+     * <strong>Algorithm Description:</strong> hex strings are generated in 40-byte\n+     * segments using a 3-step process. <ol>\n+     * <li>20 random bytes are generated using the underlying SecureRandom</li>\n+     * <li>SHA-1 hash is applied to yield a 20-byte binary digest</li>\n+     * <li>Each byte of the binary digest is converted to 2 hex digits</li></ol><p>\n+     * TODO: find external reference or provide justification for the claim that this\n+     * yields a cryptographically secure sequence of hex strings.</p>\n+     * @param len length of return string\n+     * @exception IllegalArgumentException thrown if len <= 0 \n+     * @return the random hex string\n+     */\n+    public String nextSecureHexString(int len) {\n+        if (len <= 0) {\n+            throw new IllegalArgumentException(\"length must be positive\");\n+        }\n+       \n+       // Get SecureRandom and setup Digest provider\n+       SecureRandom secRan = getSecRan();\n+       MessageDigest alg = null;\n+       try {\n+            alg = MessageDigest.getInstance(\"SHA-1\");\n+       } catch (NoSuchAlgorithmException ex) {\n+           return null; // gulp FIXME? -- this *should* never fail. OK to swallow????\n+       }\n+       alg.reset(); \n+       \n+       //Compute number of iterations required (40 bytes each)\n+       int numIter = (len / 40) + 1;\n+       \n+       StringBuffer outBuffer = new StringBuffer();\n+       for (int iter = 1; iter < numIter + 1; iter++) {\n+            byte[] randomBytes = new byte[40];\n+            secRan.nextBytes(randomBytes);\n+            alg.update(randomBytes);\n+    \n+            //Compute hash -- will create 20-byte binary hash\n+            byte hash[] = alg.digest();\n+            \n+            //Loop over the hash, converting each byte to 2 hex digits\n+            for (int i = 0; i < hash.length; i++) {\n+                Integer c = new Integer(hash[i]);\n+        \n+                /* Add 128 to byte value to make interval 0-255\n+                 * This guarantees <= 2 hex digits from toHexString()\n+                 * toHexString would otherwise add 2^32 to negative \n+                 * arguments\n+                 */\n+                String hex = Integer.toHexString(c.intValue()+128);\n+                    \n+               //Keep strings uniform length -- guarantees 40 bytes\n+               if (hex.length() == 1) hex = \"0\" + hex;\n+               outBuffer.append(hex);\n+            }\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+    \n+    public int nextSecureInt(int lower, int upper) {\n+          if (lower >= upper) {\n+              throw new IllegalArgumentException\n+                (\"lower bound must be <= upper bound\");\n+          }\n+          SecureRandom sec = getSecRan();\n+          return lower + (int)(sec.nextDouble() * (upper-lower+1));\n+    }\n+    \n+    \n+    public long nextSecureLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+            (\"lower bound must be <= upper bound\");\n+        }\n+        SecureRandom sec = getSecRan();\n+        return lower + (long)(sec.nextDouble() * (upper-lower+1));\n+    }\n+    \n+    /** \n+     * Generates a random value from the Poisson distribution with \n+     * the given mean.<br>\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm>\n+     * Poisson Distribution</a><br>\n+     * <strong>Algorithm Description</strong>:\n+     * Uses simulation of a Poisson process using Uniform deviates, as described \n+     * <a href = http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm>\n+     * here</a>\n+     * @param mean Mean of the distribution\n+     * @returns long\n+     * @throws IllegalArgumentException if mean <= 0\n+     */\n+    public long nextPoisson(double mean) {\n+        double p = Math.exp(-mean);\n+        long n = 0;\n+        double r = 1.0d;\n+        Random rand = getRan();\n+        if (mean <= 0) {\n+            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n+        }\n+        while (true) {\n+            double rnd = rand.nextDouble();\n+            r = r * rnd;\n+            if (r >= p) {\n+                n++;\n+            } else {\n+                return n;\n+            }\n+        }\n+    }\n+    \n+    public double nextGaussian(double mu,double sigma) {\n+        if (sigma <= 0) {\n+            throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n+        }\n+        Random rand = getRan();\n+        return sigma*rand.nextGaussian() + mu;\n+    }\n+    \n+    /**\n+     * Generates a random value from the exponential distribution\n+     * with expected value = <code>mean</code><br>\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm>\n+     * Exponential Distribution</a><br>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The specified mean <i>must</i> be non-negative</li>\n+     * </ul>\n+     * <strong>Algorithm Description</strong>:  Uses the \n+     * <a href=http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html> \n+     * Inversion Method</a> to generate exponential from uniform deviates.\n+     * @param mu Mean of the distribution\n+     * @return random value from exponential distribution\n+     */\n+    public double nextExponential(double mean)  {\n+        if (mean < 0.0) throw new IllegalArgumentException\n+            (\"Exponential mean must be >= 0\");\n+        Random rand = getRan();\n+        double unif = rand.nextDouble();\n+        while (unif == 0.0d) {\n+            unif = rand.nextDouble();\n+        }\n+        return -mean*Math.log(unif);\n+    }\n+    \n+    /**\n+     * Generates a uniformly distributed random value from the open interval\n+     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded)\n+     * <strong>Definition</strong>: \n+     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm>\n+     * Uniform Distribution</a> <code>lower</code> and <code>upper - lower</code>\n+     * are the \n+     * <a href = http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm>\n+     * location and scale parameters</a>, respectively<br>\n+     * <strong>Algorithm Description</strong>: scales the output of \n+     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n+     * random double if Random.nextDouble() returns 0).  This is necessary to\n+     * provide a symmetric output interval (both endpoints excluded).\n+     * @param lower lower endpoint of the interval of support\n+     * @param upper upper endpoint of the interval of support\n+     * @return uniformly distributed random value between lower\n+     * and upper (exclusive)\n+     * @exception IllegalArgumentException thrown if\n+     * <code>lower</code> is not strictly less than <code>upper</code>.\n+     */\n+    public double nextUniform(double lower, double upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+            (\"lower bound must be <= upper bound\");\n+        }\n+        Random rand = getRan();\n+        double result = lower + rand.nextDouble()*(upper-lower);\n+        while (result == lower) {\n+              result = lower + rand.nextDouble()*(upper-lower);\n+        }\n+        return result;   \n+    }\n+    \n+    /** \n+     * Returns the static Random used to generate random data.<br>\n+     * Creates and initializes if null\n+     * @return the static Random used to generate random data\n+     */\n+    private Random getRan() {\n+        if (rand == null) {\n+            rand = new Random();\n+            rand.setSeed(System.currentTimeMillis());\n+        }\n+        return rand;\n+    }\n+    \n+    /** \n+     * Returns the static SecureRandom used to generate secure random data.<br>\n+     * Creates and initializes if null.\n+     * @return the static SecureRandom used to generate secure random data\n+     */\n+    private SecureRandom getSecRan() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+            secRand.setSeed(System.currentTimeMillis());\n+        }\n+        return secRand;\n+    }\n+    \n+    /**\n+     * Reseeds the random number generator with the supplied seed.  Will\n+     * create and initialize if null.\n+     * @param seed the seed value to use\n+     */\n+    public void reSeed(long seed) {\n+        if (rand == null) {\n+            rand = new Random();\n+        }\n+        rand.setSeed(seed);\n+    }\n+    \n+    /**\n+     * Reseeds the secure random number generator with the current time\n+     * in milliseconds.  Will create and initialize if null.\n+     */\n+    public void reSeedSecure() {\n+        if (rand == null) {\n+            rand = new Random();\n+        }\n+        rand.setSeed(System.currentTimeMillis());\n+    }\n+    \n+    /**\n+     * Reseeds the secure random number generator with the supplied seed.\n+     * Will create and initialize if null.\n+     * @param seed the seed value to use\n+     */\n+    public void reSeedSecure(long seed) {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(seed);\n+    }\n+    \n+    /**\n+     * Reseeds the random number generator with the current time\n+     * in milliseconds\n+     */\n+    public void reSeed() {\n+        if (rand == null) {\n+            rand = new Random();\n+        }\n+        rand.setSeed(System.currentTimeMillis());\n+    }\n+    \n+    /**\n+     * Sets the PRNG algorithm for the underlying SecureRandom instance\n+     * using the Security Provider API, as defined in \n+     * <a href=http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA>\n+     * Java Cryptography Architecture API Specification & Reference</a><p>\n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i> overhead\n+     * and may take several seconds to execute.</p>\n+     * @param algorithm the name of the PRNG algorithm\n+     * @param provider the name of the provider \n+     * @throws NoSuchAlgorithmException if the specified algorithm is not available\n+     * @throws NoSuchProviderException if the specified provider is not installed\n+     */\n+    public void setSecureAlgorithm(String algorithm, String provider) \n+        throws NoSuchAlgorithmException,NoSuchProviderException {\n+        secRand = SecureRandom.getInstance(algorithm,provider);\n+    }\n+        \n+}\n--- a/src/test/org/apache/commons/math/MathTestSuite.java\n+++ b/src/test/org/apache/commons/math/MathTestSuite.java\n  * Test suite for the Math package.\n  *\n  * @author Phil Steitz\n- * @version $Id: MathTestSuite.java,v 1.2 2003/05/15 05:39:01 tobrien Exp $\n+ * @version $Id: MathTestSuite.java,v 1.3 2003/05/18 00:58:52 tobrien Exp $\n  */\n public class MathTestSuite extends TestCase {\n     \n         suite.addTest(RealMatrixImplTest.suite());\n         suite.addTest(FreqTest.suite());\n         suite.addTest(UnivariateImplTest.suite());\n+        suite.addTest(TestStatisticTest.suite());\n+        suite.addTest(RandomDataTest.suite());\n         return suite;\n     }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/RandomDataTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution. \n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.framework.AssertionFailedError;\n+import java.security.NoSuchProviderException;\n+import java.security.NoSuchAlgorithmException;\n+/**\n+ * Test cases for the RandomData class.\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/05/18 00:58:52 $\n+ */\n+\n+public final class RandomDataTest extends TestCase {\n+\n+    public RandomDataTest(String name) {\n+        super(name);\n+    }\n+\n+    private long smallSampleSize = 1000;\n+    private double[] expected = {250,250,250,250};\n+    private int largeSampleSize = 10000;\n+    private int tolerance = 50;\n+    private String[] hex = \n+        {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"}; \n+    private RandomDataImpl randomData = new RandomDataImpl(); \n+    private TestStatisticImpl testStatistic = new TestStatisticImpl();\n+    \n+    \n+    public void setUp() { \n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomDataTest.class);\n+        suite.setName(\"RandomData Tests\");\n+        return suite;\n+    }\n+\n+    /** test dispersion and failure modes for nextInt() */\n+    public void testNextInt() {\n+        try {\n+            int x = randomData.nextInt(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Freq freq = new Freq();\n+        int value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextInt(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** test dispersion and failure modes for nextLong() */\n+    public void testNextLong() {\n+       try {\n+            long x = randomData.nextLong(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+       Freq freq = new Freq();\n+       long value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextLong(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** test dispersion and failure modes for nextSecureLong() */\n+    public void testNextSecureLong() {\n+        try {\n+            long x = randomData.nextSecureLong(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Freq freq = new Freq();\n+        long value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextSecureLong(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** test dispersion and failure modes for nextSecureInt() */\n+    public void testNextSecureInt() {\n+        try {\n+            long x = randomData.nextSecureInt(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Freq freq = new Freq();\n+        int value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextSecureInt(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** \n+     * Make sure that empirical distribution of random Poisson(4)'s \n+     * has P(X <= 5) close to actual cumulative Poisson probablity\n+     * and that nextPoisson fails when mean is non-positive\n+     * TODO: replace with statistical test, adding test stat to TestStatistic\n+     */\n+    public void testNextPoisson() {\n+        try {\n+            long x = randomData.nextPoisson(0);\n+            fail(\"zero mean -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Freq f = new Freq();\n+        long v = 0;\n+        for (int i = 0; i<largeSampleSize; i++) {\n+            try {\n+                f.addValue(randomData.nextPoisson(4.0d));\n+            } catch (Exception ex) {\n+                fail(ex.getMessage());\n+            }\n+        }\n+        long cumFreq = f.getCount(\"0\") + f.getCount(\"1\") + f.getCount(\"2\") + \n+                        f.getCount(\"3\") + f.getCount(\"4\") + f.getCount(\"5\");\n+        long sumFreq = f.getSumFreq();\n+        double cumPct = \n+            new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();\n+        assertEquals(\"cum Poisson(4)\",cumPct,0.7851,0.2);\n+        try {\n+            long x = randomData.nextPoisson(-1);\n+            fail(\"negative mean supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            long x = randomData.nextPoisson(0);\n+            fail(\"0 mean supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        \n+    }\n+    \n+    /** test dispersion and failute modes for nextHex() */\n+    public void testNextHex() {\n+        try {\n+            String x = randomData.nextHexString(-1);\n+            fail(\"negative length supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            String x = randomData.nextHexString(0);\n+            fail(\"zero length supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        String hexString = randomData.nextHexString(3);\n+        if (hexString.length() != 3) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextHexString(1);\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextHexString(0);\n+            fail(\"zero length requested -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }      \n+        Freq f = new Freq();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextHexString(100);\n+            if (hexString.length() != 100) {\n+                fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j,j+1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        double[] observed = new double[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double)smallSampleSize*100/(double)16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001\n+         * Change to 30.58 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 37.70);    \n+    }\n+    \n+    /** test dispersion and failute modes for nextHex() */\n+    public void testNextSecureHex() {\n+        try {\n+            String x = randomData.nextSecureHexString(-1);\n+            fail(\"negative length -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            String x = randomData.nextSecureHexString(0);\n+            fail(\"zero length -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        String hexString = randomData.nextSecureHexString(3);\n+        if (hexString.length() != 3) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextSecureHexString(1);\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextSecureHexString(0);\n+            fail(\"zero length requested -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }      \n+        Freq f = new Freq();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextSecureHexString(100);\n+            if (hexString.length() != 100) {\n+                fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j,j+1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        double[] observed = new double[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double)smallSampleSize*100/(double)16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001\n+         * Change to 30.58 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 37.70);    \n+    }\n+    \n+    /** test failure modes and dispersion of nextUniform() */  \n+    public void testNextUniform() {    \n+        try {\n+            double x = randomData.nextUniform(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = randomData.nextUniform(3,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        double[] expected = new double[] {500,500};\n+        double[] observed = new double[] {0,0};\n+        double lower = -1d;\n+        double upper = 20d;\n+        double midpoint = (lower + upper)/2d;\n+        double result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result = randomData.nextUniform(lower,upper);\n+            if ((result == lower) || (result == upper)) {\n+                fail(\"generated value equal to an endpoint: \" + result);\n+            } \n+            if (result < midpoint) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.64 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 10.83);  \n+    }\n+    \n+    /** test failure modes and distribution of nextGaussian() */  \n+    public void testNextGaussian() { \n+        try {\n+            double x = randomData.nextGaussian(0,0);\n+            fail(\"zero sigma -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Univariate u = new UnivariateImpl();\n+        for (int i = 0; i<largeSampleSize; i++) {\n+            u.addValue(randomData.nextGaussian(0,1));\n+        }\n+        double xbar = u.getMean();\n+        double s = u.getStandardDeviation();\n+        double n = u.getN(); \n+        /* t-test at .001-level TODO: replace with externalized t-test, with\n+         * test statistic defined in TestStatistic\n+         */\n+        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);\n+    }\n+    \n+    /** test failure modes and distribution of nextExponential() */  \n+    public void testNextExponential() {\n+        try {\n+            double x = randomData.nextExponential(-1);\n+            fail(\"negative mean -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        assertEquals(\"0 mean\", 0,randomData.nextExponential(0),10E-8); \n+        long cumFreq = 0;\n+        double v = 0;\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            v = randomData.nextExponential(1);\n+            assertTrue(\"exponential deviate postive\", v > 0);\n+            if (v < 2) cumFreq++;\n+        }\n+        /* TODO: Replace with a statistical test, with statistic added to\n+         * TestStatistic.  Check below compares observed cumulative distribution\n+         * evaluated at 2 with exponential CDF \n+         */\n+        assertEquals(\"exponential cumulative distribution\",\n+            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);\n+    } \n+    \n+    /** test reseeding, algorithm/provider games */\n+    public void testConfig() throws NoSuchProviderException, \n+      NoSuchAlgorithmException{\n+        randomData.reSeed(1000);\n+        double v = randomData.nextUniform(0,1);\n+        randomData.reSeed();\n+        assertTrue(\"different seeds\", \n+            Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);\n+        randomData.reSeed(1000);\n+        assertEquals(\"same seeds\",v,randomData.nextUniform(0,1),10E-12);\n+        randomData.reSeedSecure(1000);\n+        String hex = randomData.nextSecureHexString(40);\n+        randomData.reSeedSecure();\n+        assertTrue(\"different seeds\",\n+            !hex.equals(randomData.nextSecureHexString(40)));\n+        randomData.reSeedSecure(1000);\n+        assertTrue(\"same seeds\",\n+            !hex.equals(randomData.nextSecureHexString(40))); \n+        \n+        /* TODO: probably should remove this test as the package grows,\n+         * since it takes about 4 seconds\n+         */\n+        randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\");\n+        assertTrue(\"different seeds\",\n+            !hex.equals(randomData.nextSecureHexString(40)));\n+        try {\n+            randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n+            fail(\"expecting NoSuchAlgorithmException\");\n+        } catch (NoSuchAlgorithmException ex) {\n+            ;\n+        }\n+        \n+        try {\n+            randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n+            fail(\"expecting NoSuchProviderException\");\n+        } catch (NoSuchProviderException ex) {\n+            ;\n+        }      \n+    }\n+}\n+", "timestamp": 1053219532, "metainfo": ""}