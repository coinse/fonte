{"sha": "322706393973a99fc70f0cbd8cadee38bae3aa94", "log": "PR: 29000 Made ComplexFormat extend java.text.Format providing complex object formatting and parsing.   ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n \n package org.apache.commons.math.complex;\n \n+import java.text.FieldPosition;\n+import java.text.Format;\n import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n- * be replaced with 'j', and the number of decimal places to display \n+ * be replaced with 'j', and the number format for both real and imaginary parts\n  * can be configured.\n  *\n  * @author Apache Software Foundation\n- * @version $Revision: 1.6 $ $Date: 2004/05/23 00:52:32 $\n+ * @version $Revision: 1.7 $ $Date: 2004/06/01 13:47:17 $\n  */\n-public class ComplexFormat {\n-\n+public class ComplexFormat extends Format {\n+    \n     /** The default complex format. */ \n \tprivate static final ComplexFormat DEFAULT = new ComplexFormat();\n \n-\t/** The notation used to signify the imaginary part of the complex number. */\n-    private String imaginaryCharacter = \"i\";\n-\n-    /** The maximum number of decimal digits in the formatted output. */ \n-    private int fractionDigits = 2;\n-\n-    /**\n-     * Create an instance with the default imaginary character 'i', and the default\n-     * number of decimal places - 2.\n-     */\n-    public ComplexFormat() {}\n-\n-    /**\n-     * Create an instance with a custom imaginary character, and the default number\n-     * of decimal places - 2.\n+    /** The default imaginary character. */\n+    private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n+    \n+    /** The notation used to signify the imaginary part of the complex number. */\n+    private String imaginaryCharacter;\n+    \n+    /** The format used for the imaginary part. */\n+    private NumberFormat imaginaryFormat;\n+\n+    /** The format used for the real part. */\n+    private NumberFormat realFormat;\n+    \n+    /**\n+     * Create an instance with the default imaginary character, 'i', and the\n+     * default number format for both real and imaginary parts.\n+     */\n+    public ComplexFormat() {\n+        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for both real and\n+     * imaginary parts.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(NumberFormat format) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, format);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom number format for the real part and a\n+     * custom number format for the imaginary part.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, and the default\n+     * number format for both real and imaginary parts.\n      * @param imaginaryCharacter The custom imaginary character.\n      */\n     public ComplexFormat(String imaginaryCharacter) {\n-        this.imaginaryCharacter = imaginaryCharacter;\n-    }\n-\n-    /**\n-     * Create an instance with a custom imaginary character, and a custom number of\n-     * decimal places.\n+        this(imaginaryCharacter, getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, and a custom number\n+     * format for both real and imaginary parts.\n      * @param imaginaryCharacter The custom imaginary character.\n-     * @param fractionDigits The custom number of decimal places.\n-     */\n-    public ComplexFormat(String imaginaryCharacter, int fractionDigits) {\n-        this.imaginaryCharacter = imaginaryCharacter;\n-        this.fractionDigits = fractionDigits;\n-    }\n-\n-    /**\n-     * Formats a Complex object and returns a String representing the \"cartesian\n-     * form\" of a complex number.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n+        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, a custom number\n+     * format for the real part, and a custom number format for the imaginary\n+     * part.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        super();\n+        setImaginaryCharacter(imaginaryCharacter);\n+        setImaginaryFormat(imaginaryFormat);\n+        setRealFormat(realFormat);\n+    }\n+\n+    /**\n+     * This static method calls formatComplex() on a default instance of\n+     * ComplexFormat.\n      *\n      * @param c Complex object to format\n      * @return A formatted number in the form \"Re(c) + Im(c)i\"\n      */\n-    public String format(Complex c) {\n-\n-        NumberFormat format = NumberFormat.getInstance();\n-        format.setMaximumFractionDigits( fractionDigits );\n-\n-        StringBuffer buffer = new StringBuffer();\n-\n-\t\tif( Double.isNaN( c.getReal() ) || Double.isInfinite( c.getReal() ) ) {\n-\t\t\tbuffer.append( \"(\" + c.getReal() + \")\" );\n-\t\t} else {\n-\t\t\tbuffer.append( format.format( c.getReal() ) );\n-\t\t}\n-\n-        if( c.getImaginary() < 0 ) {\n-            buffer.append( \" - \" );\n-        } else if( c.getImaginary() > 0 || Double.isNaN( c.getImaginary() )) {\n-            buffer.append( \" + \" );\n-        }            \n-\n-\t\tif( c.getImaginary() != 0 ) {\n-\t\t\tif( Double.isNaN( c.getImaginary() ) || Double.isInfinite( c.getImaginary() ) ) {\n-\t\t\t\tbuffer.append( \"(\" + Math.abs( c.getImaginary() ) + \")\" );\n-\t\t\t} else {\n-\t\t\t\tbuffer.append( format.format( Math.abs(c.getImaginary()) ) );\n-\t\t\t}\n-\t\t\tbuffer.append( imaginaryCharacter );\n-\t\t}\n-        \n-        return( buffer.toString() );\n-\n-    }\n-    \n-    /**\n-     * This static method calls formatComplex() on a default instance of\n-     * ComplexFormat.\n-     *\n-     * @param c Complex object to format\n-     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n-     */\n     public static String formatComplex( Complex c ) {\n     \treturn DEFAULT.format( c );\n     }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing is the\n+     * maximum number of fraction digits, which is set to 2.  \n+     *\n+     * @return the default number format.\n+     */\n+    private static NumberFormat getDefaultNumberFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+    \n+    /**\n+     * Formats a {@link Complex} object to produce a string.\n+     *\n+     * @param complex the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format real\n+        double re = complex.getReal();\n+        formatDouble(re, getRealFormat(), toAppendTo, pos);\n+        \n+        // format sign and imaginary\n+        double im = complex.getImaginary();\n+        if (im < 0.0) {\n+            toAppendTo.append(\" - \");\n+            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        } else if (im > 0.0 || Double.isNaN(im)) {\n+            toAppendTo.append(\" + \");\n+            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        }\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats a object to produce a string.  <code>obj</code> must be either a \n+     * {@link Complex} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        StringBuffer ret = null;\n+        \n+        if (obj instanceof Complex) {\n+            ret = format( (Complex)obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n+                toAppendTo, pos);\n+        } else { \n+            throw new IllegalArgumentException(\n+                \"Cannot format given Object as a Date\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Formats a double value to produce a string.  In general, the value is\n+     * formatted using the formatting rules of <code>format</code>.  There are\n+     * three exceptions to this:\n+     * <ol>\n+     * <li>NaN is formatted as '(NaN)'</li>\n+     * <li>Positive infinity is formatted as '(Infinity)'</li>\n+     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n+     * </ol>\n+     *\n+     * @param value the double to format.\n+     * @param format the format used.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    private StringBuffer formatDouble(double value, NumberFormat format,\n+            StringBuffer toAppendTo, FieldPosition pos) {\n+        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n+            toAppendTo.append('(');\n+            toAppendTo.append(value);\n+            toAppendTo.append(')');\n+        } else {\n+            getRealFormat().format(value, toAppendTo, pos);\n+        }\n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Access the imaginaryCharacter.\n+     * @return the imaginaryCharacter.\n+     */\n+    public String getImaginaryCharacter() {\n+        return imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Access the imaginaryFormat.\n+     * @return the imaginaryFormat.\n+     */\n+    public NumberFormat getImaginaryFormat() {\n+        return imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Access the realFormat.\n+     * @return the realFormat.\n+     */\n+    public NumberFormat getRealFormat() {\n+        return realFormat;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @return the parsed {@link Complex} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Complex parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Complex result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n+                \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Complex} object.\n+     */\n+    public Complex parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse real\n+        Number re = parseNumber(source, getRealFormat(), pos);\n+        if (re == null) {\n+            // invalid real number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse sign\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        int sign = 0;\n+        switch (c) {\n+        case 0 :\n+            // no sign\n+            // return real only complex number\n+            return new Complex(re.doubleValue(), 0.0);\n+        case '-' :\n+            sign = -1;\n+            break;\n+        case '+' :\n+            sign = 1;\n+            break;\n+        default :\n+            // invalid sign\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse imaginary\n+        Number im = parseNumber(source, getRealFormat(), pos);\n+        if (im == null) {\n+            // invalid imaginary number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse imaginary character\n+        int n = getImaginaryCharacter().length();\n+        startIndex = pos.getIndex();\n+        int endIndex = startIndex + n;\n+        if (source.substring(startIndex, endIndex).compareTo(\n+            getImaginaryCharacter()) != 0) {\n+            // set index back to initial, error index should be the start index\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+        pos.setIndex(endIndex);\n+\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    }\n+     \n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    private char parseNextCharacter(String source, ParsePosition pos) {\n+         int index = pos.getIndex();\n+         int n = source.length();\n+         char ret = 0;\n+\n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+    \n+    /**\n+     * Parses <code>source</code> for a special double values.  These values\n+     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param value the special value to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the special number.\n+     */\n+    private Number parseNumber(String source, double value, ParsePosition pos) {\n+        Number ret = null;\n+        \n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        sb.append(value);\n+        sb.append(')');\n+        \n+        int n = sb.length();\n+        int startIndex = pos.getIndex();\n+        int endIndex = startIndex + n;\n+        if (endIndex < source.length()) {\n+            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n+                ret = new Double(value);\n+                pos.setIndex(endIndex);\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Parses <code>source</code> for a number.  This method can parse normal,\n+     * numeric values as well as special values.  These special values include\n+     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param format the number format used to parse normal, numeric values.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed number.\n+     */\n+    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n+        int startIndex = pos.getIndex();\n+        Number number = getRealFormat().parse(source, pos);\n+        int endIndex = pos.getIndex();\n+        \n+        // check for error parsing number\n+        if (startIndex == endIndex) {\n+            // try parsing special numbers\n+            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n+            for (int i = 0; i < special.length; ++i) {\n+                number = parseNumber(source, special[i], pos);\n+                if (number != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        return number;\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+    /**\n+     * Modify the imaginaryCharacter.\n+     * @param imaginaryCharacter The new imaginaryCharacter value.\n+     * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is\n+     *         <code>null</code> or an empty string.\n+     */\n+    public void setImaginaryCharacter(String imaginaryCharacter) {\n+        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n+            throw new IllegalArgumentException(\n+                \"imaginaryCharacter must be a non-empty string.\");\n+        }\n+        this.imaginaryCharacter = imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Modify the imaginaryFormat.\n+     * @param imaginaryFormat The new imaginaryFormat value.\n+     * @throws IllegalArgumentException if <code>imaginaryFormat</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n+        if (imaginaryFormat == null) {\n+            throw new IllegalArgumentException(\n+                \"imaginaryFormat can not be null.\");\n+        }\n+        this.imaginaryFormat = imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Modify the realFormat.\n+     * @param realFormat The new realFormat value.\n+     * @throws IllegalArgumentException if <code>realFormat</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setRealFormat(NumberFormat realFormat) {\n+        if (realFormat == null) {\n+            throw new IllegalArgumentException(\n+                \"realFormat can not be null.\");\n+        }\n+        this.realFormat = realFormat;\n+    }\n }\n-\n-\n-    \n--- a/src/test/org/apache/commons/math/complex/ComplexFormatTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexFormatTest.java\n \n package org.apache.commons.math.complex;\n \n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+\n import junit.framework.TestCase;\n \n public class ComplexFormatTest extends TestCase {\n    \n     public void testSimpleNoDecimals() {\n         Complex c = new Complex(1, 1);\n-        assertEquals( complexFormat.format( c ), \"1 + 1i\" );\n+        String expected = \"1 + 1i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n     }\n \n \tpublic void testSimpleWithDecimals() {\n \t\tComplex c = new Complex(1.23, 1.43);\n-\t\tassertEquals( complexFormat.format( c ), \"1.23 + 1.43i\" );\n+        String expected = \"1.23 + 1.43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testSimpleWithDecimalsTrunc() {\n \t\tComplex c = new Complex(1.2323, 1.4343);\n-\t\tassertEquals( complexFormat.format( c ), \"1.23 + 1.43i\" );\n+        String expected = \"1.23 + 1.43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testNegativeReal() {\n \t\tComplex c = new Complex(-1.2323, 1.4343);\n-\t\tassertEquals( complexFormat.format( c ), \"-1.23 + 1.43i\" );\n+        String expected = \"-1.23 + 1.43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testNegativeImaginary() {\n \t\tComplex c = new Complex(1.2323, -1.4343);\n-\t\tassertEquals( complexFormat.format( c ), \"1.23 - 1.43i\" );\n+        String expected = \"1.23 - 1.43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testNegativeBoth() {\n \t\tComplex c = new Complex(-1.2323, -1.4343);\n-\t\tassertEquals( complexFormat.format( c ), \"-1.23 - 1.43i\" );\n+        String expected = \"-1.23 - 1.43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testZeroReal() {\n \t\tComplex c = new Complex(0.0, -1.4343);\n-\t\tassertEquals( complexFormat.format( c ), \"0 - 1.43i\" );\n+        String expected = \"0 - 1.43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testZeroImaginary() {\n \t\tComplex c = new Complex(30.233, 0);\n-\t\tassertEquals( complexFormat.format( c ), \"30.23\" );\n+        String expected = \"30.23\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testDifferentImaginaryChar() {\n \t\tComplex c = new Complex(1, 1);\n-\t\tassertEquals( complexFormatJ.format( c ), \"1 + 1j\" );\n+        String expected = \"1 + 1j\";\n+        String actual = complexFormatJ.format(c); \n+        assertEquals(expected, actual);\n \t}\n \t\n \tpublic void testStaticFormatComplex() {\n \t\tComplex c = new Complex(232.222, -342.33);\n-\t\tassertEquals( ComplexFormat.formatComplex( c ), \"232.22 - 342.33i\" );\n+        String expected = \"232.22 - 342.33i\";\n+        String actual = ComplexFormat.formatComplex(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testNan() {\n \t\tComplex c = new Complex(Double.NaN, Double.NaN);\n-\t\tassertEquals( complexFormat.format( c ), \"(NaN) + (NaN)i\" );\n+        String expected = \"(NaN) + (NaN)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testPositiveInfinity() {\n \t\tComplex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n-\t\tassertEquals( complexFormat.format( c ), \"(Infinity) + (Infinity)i\" );\n+        String expected = \"(Infinity) + (Infinity)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n \t}\n \n \tpublic void testNegativeInfinity() {\n \t\tComplex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n-\t\tassertEquals( complexFormat.format( c ), \"(-Infinity) - (Infinity)i\" );\n-\t}\n-\n+        String expected = \"(-Infinity) - (Infinity)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+    \n+    public void testParseSimpleNoDecimals() {\n+        String source = \"1 + 1i\";\n+        Complex expected = new Complex(1, 1);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source = \"1.23 + 1.43i\";\n+        Complex expected = new Complex(1.23, 1.43);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source = \"1.2323 + 1.4343i\";\n+        Complex expected = new Complex(1.2323, 1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeReal() {\n+        String source = \"-1.2323 + 1.4343i\";\n+        Complex expected = new Complex(-1.2323, 1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeImaginary() {\n+        String source = \"1.2323 - 1.4343i\";\n+        Complex expected = new Complex(1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeBoth() {\n+        String source = \"-1.2323 - 1.4343i\";\n+        Complex expected = new Complex(-1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroReal() {\n+        String source = \"0.0 - 1.4343i\";\n+        Complex expected = new Complex(0.0, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroImaginary() {\n+        String source = \"-1.2323\";\n+        Complex expected = new Complex(-1.2323, 0);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseDifferentImaginaryChar() {\n+        String source = \"-1.2323 - 1.4343j\";\n+        Complex expected = new Complex(-1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormatJ.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"(NaN) + (NaN)i\";\n+        Complex expected = new Complex(Double.NaN, Double.NaN);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"(Infinity) + (Infinity)i\";\n+        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testPaseNegativeInfinity() {\n+        String source = \"(-Infinity) - (Infinity)i\";\n+        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getRealFormat());\n+    }\n+    \n+    public void testGetImaginaryFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat();\n+        \n+        assertNotSame(nf, cf.getImaginaryFormat());\n+        cf.setImaginaryFormat(nf);\n+        assertSame(nf, cf.getImaginaryFormat());\n+    }\n+    \n+    public void testSetImaginaryFormatNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryFormat(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetRealFormatNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setRealFormat(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testGetRealFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat();\n+        \n+        assertNotSame(nf, cf.getRealFormat());\n+        cf.setRealFormat(nf);\n+        assertSame(nf, cf.getRealFormat());\n+    }\n+    \n+    public void testSetImaginaryCharacterNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryCharacter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetImaginaryCharacterEmpty() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryCharacter(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testFormatNumber() {\n+        ComplexFormat cf = new ComplexFormat();\n+        Double pi = new Double(Math.PI);\n+        String text = cf.format(pi);\n+        assertEquals(\"3.14\", text);\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n }", "timestamp": 1086097637, "metainfo": ""}