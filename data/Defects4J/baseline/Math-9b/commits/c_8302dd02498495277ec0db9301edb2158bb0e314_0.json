{"sha": "8302dd02498495277ec0db9301edb2158bb0e314", "log": "removed FunctionEvaluationException, DerivativeException and MatrixVisitorException these exception were  deprecated in 2.2 and a smooth transition path was set up to help users, now all user functions should use the new unchecked MathUserException  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n \n     };\n \n     /** {@inheritDoc} */\n-    public abstract double value(double x, double y) throws FunctionEvaluationException;\n+    public abstract double value(double x, double y) throws MathUserException;\n \n     /** Get a composable function by fixing the first argument of the instance.\n      * @param fixedX fixed value of the first argument\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return BinaryFunction.this.value(fixedX, x);\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return BinaryFunction.this.value(x, fixedY);\n             }\n         };\n--- a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * An interface representing a bivariate real function.\n      * @param x Abscissa for which the function value should be computed.\n      * @param y Ordinate for which the function value should be computed.\n      * @return the value.\n-     * @throws FunctionEvaluationException if the function evaluation fails.\n+     * @throws MathUserException if the function evaluation fails.\n      */\n     double value(double x, double y)\n-        throws FunctionEvaluationException;\n+        throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n \n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(f.value(x));\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return f.value(ComposableFunction.this.value(x));\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return combiner.value(ComposableFunction.this.value(x), f.value(x));\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(x) + f.value(x);\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(x) + a;\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(x) - f.value(x);\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(x) * f.value(x);\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(x) * scaleFactor;\n             }\n         };\n         return new ComposableFunction() {\n             @Override\n             /** {@inheritDoc} */\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) throws MathUserException {\n                 return ComposableFunction.this.value(x) / f.value(x);\n             }\n         };\n         return new MultivariateRealFunction() {\n             /** {@inheritDoc} */\n             public double value(double[] point)\n-                throws FunctionEvaluationException, IllegalArgumentException {\n+                throws MathUserException, IllegalArgumentException {\n                 double result = initialValue;\n                 for (final double entry : point) {\n                     result = combiner.value(result, ComposableFunction.this.value(entry));\n     }\n \n     /** {@inheritDoc} */\n-    public abstract double value(double x) throws FunctionEvaluationException;\n+    public abstract double value(double x) throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n \n package org.apache.commons.math.analysis;\n \n+import org.apache.commons.math.exception.MathUserException;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a multivariate matrix function.\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n-     * @exception FunctionEvaluationException if the function evaluation fails\n+     * @exception MathUserException if the function evaluation fails\n      * @exception IllegalArgumentException if points dimension is wrong\n      */\n     double[][] value(double[] point)\n-        throws FunctionEvaluationException, IllegalArgumentException;\n+        throws MathUserException, IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * An interface representing a multivariate real function.\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n-     * @exception FunctionEvaluationException if the function evaluation fails\n+     * @exception MathUserException if the function evaluation fails\n      * @exception IllegalArgumentException if points dimension is wrong\n      */\n     double value(double[] point)\n-        throws FunctionEvaluationException, IllegalArgumentException;\n+        throws MathUserException, IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * An interface representing a multivariate vectorial function.\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n-     * @exception FunctionEvaluationException if the function evaluation fails\n+     * @exception MathUserException if the function evaluation fails\n      * @exception IllegalArgumentException if points dimension is wrong\n      */\n     double[] value(double[] point)\n-        throws FunctionEvaluationException, IllegalArgumentException;\n+        throws MathUserException, IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * An interface representing a trivariate real function.\n      * @param y y-coordinate for which the function value should be computed.\n      * @param z z-coordinate for which the function value should be computed.\n      * @return the value.\n-     * @throws FunctionEvaluationException if the function evaluation fails.\n+     * @throws MathUserException if the function evaluation fails.\n      */\n     double value(double x, double y, double z)\n-        throws FunctionEvaluationException;\n+        throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * An interface representing a univariate matrix function.\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n-     * @throws FunctionEvaluationException if the function evaluation fails\n+     * @throws MathUserException if the function evaluation fails\n      */\n-    double[][] value(double x) throws FunctionEvaluationException;\n+    double[][] value(double x) throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n+import org.apache.commons.math.exception.MathUserException;\n+\n /**\n  * An interface representing a univariate real function.\n  *\n      * majority of cases where Commons-Math throws IllegalArgumentException,\n      * it is the result of argument checking of actual parameters immediately\n      * passed to a method.\n-     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n-     * when the method may encounter errors during evaluation.\n+     * @throws MathUserException when the method may encounter errors during evaluation.\n      * This should be thrown only in circumstances where, at the level of the\n      * activated function, IllegalArgumentException is not appropriate and it\n      * should indicate that while formal preconditions of the method have not\n      * function at some (usually lower) level of the call stack.\n      * Convergence failures, runtime exceptions (even IllegalArgumentException)\n      * in user code or lower level methods can cause (and should be wrapped in)\n-     * a FunctionEvaluationException.\n+     * a MathUserException.\n      */\n-    double value(double x);\n+    double value(double x) throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * An interface representing a univariate vectorial function.\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n-     * @throws FunctionEvaluationException if the function evaluation fails\n+     * @throws MathUserException if the function evaluation fails\n      */\n-    double[] value(double x) throws FunctionEvaluationException;\n+    double[] value(double x) throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public double integrate(final double min, final double max)\n-        throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n+        throws ConvergenceException,  MathUserException, IllegalArgumentException {\n         return integrate(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f,\n-            final double min, final double max)\n-        throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n+    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n+        throws ConvergenceException,  MathUserException, IllegalArgumentException {\n \n         clearResult();\n         verifyInterval(min, max);\n      * @param max the upper bound for the interval\n      * @param n number of steps\n      * @return the value of n-th stage integral\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * @throws MathUserException if an error occurs evaluating the\n      * function\n      */\n     private double stage(final UnivariateRealFunction f,\n                          final double min, final double max, final int n)\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         // set up the step for the current stage\n         final double step     = (max - min) / n;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n     /** {@inheritDoc} */\n     @Deprecated\n     public double integrate(final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        throws MaxIterationsExceededException, MathUserException, IllegalArgumentException {\n         return integrate(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f,\n-                            final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n+        throws MaxIterationsExceededException, MathUserException, IllegalArgumentException {\n \n         final int m = maximalIterationCount + 1;\n         double previousRow[] = new double[m];\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n     /** {@inheritDoc} */\n     @Deprecated\n     public double integrate(final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        throws MaxIterationsExceededException, MathUserException, IllegalArgumentException {\n         return integrate(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f,\n-                            final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n+        throws MaxIterationsExceededException, MathUserException, IllegalArgumentException {\n \n         clearResult();\n         verifyInterval(min, max);\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n      * @param max the upper bound for the interval\n      * @param n the stage of 1/2 refinement, n = 0 is no refinement\n      * @return the value of n-th stage integral\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      */\n     double stage(final UnivariateRealFunction f,\n                  final double min, final double max, final int n)\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         if (n == 0) {\n             s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n     /** {@inheritDoc} */\n     @Deprecated\n     public double integrate(final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        throws MaxIterationsExceededException, MathUserException, IllegalArgumentException {\n         return integrate(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(final UnivariateRealFunction f,\n-                            final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+    public double integrate(final UnivariateRealFunction f, final double min, final double max)\n+        throws MaxIterationsExceededException, MathUserException, IllegalArgumentException {\n \n         clearResult();\n         verifyInterval(min, max);\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.ConvergingAlgorithm;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n      * @return the value of integral\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * @throws MathUserException if an error occurs evaluating the\n      * function\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n      * satisfy the requirements specified by the integrator\n      * since 2.0\n      */\n     @Deprecated\n-    double integrate(double min, double max) throws ConvergenceException,\n-        FunctionEvaluationException, IllegalArgumentException;\n+    double integrate(double min, double max)\n+        throws ConvergenceException, MathUserException, IllegalArgumentException;\n \n     /**\n      * Integrate the function in the given interval.\n      * @return the value of integral\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n      * satisfy the requirements specified by the integrator\n      */\n-    double integrate(UnivariateRealFunction f, double min, double max) throws ConvergenceException,\n-        FunctionEvaluationException, IllegalArgumentException;\n+    double integrate(UnivariateRealFunction f, double min, double max)\n+        throws ConvergenceException, MathUserException, IllegalArgumentException;\n \n     /**\n      * Get the result of the last run of the integrator.\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n         return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         clearResult();\n         verifyInterval(min,max);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n      * @param initial the start value to use (must be set to min if no\n      * initial point is known).\n      * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException the maximum iteration count\n-     * is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     *  the function\n+     * @throws MaxIterationsExceededException the maximum iteration count is exceeded\n+     * @throws MathUserException if an error occurs evaluating  the function\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         clearResult();\n         if ((initial < min) || (initial > max)) {\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws MaxIterationsExceededException,\n-        FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         clearResult();\n         verifyInterval(min, max);\n      * known, this will force starting with linear interpolation)\n      * @param y2 function value at the bracket point.\n      * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count\n-     * is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws MathUserException if an error occurs evaluating the function\n      */\n     private double solve(final UnivariateRealFunction f,\n                          double x0, double y0,\n                          double x1, double y1,\n                          double x2, double y2)\n-    throws MaxIterationsExceededException, FunctionEvaluationException {\n+    throws MaxIterationsExceededException, MathUserException {\n \n         double delta = x1 - x0;\n         double oldDelta = delta;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n      * @return the point at which the function value is zero\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws ConvergenceException, MathUserException {\n \n         // check for zeros before verifying bracketing\n         if (f.value(min) == 0.0) {\n      * @return the point at which the function value is zero\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws ConvergenceException, MathUserException {\n \n         // check function type\n         if (!(f instanceof PolynomialFunction)) {\n      * @return the point at which the function value is zero\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] solveAll(double coefficients[], double initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n+        ConvergenceException, MathUserException {\n \n         Complex c[] = new Complex[coefficients.length];\n         Complex z = new Complex(initial, 0.0);\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n-        MaxIterationsExceededException, FunctionEvaluationException {\n+        MaxIterationsExceededException, MathUserException {\n \n         int n = coefficients.length - 1;\n         int iterationCount = 0;\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex solve(Complex coefficients[], Complex initial) throws\n-        MaxIterationsExceededException, FunctionEvaluationException {\n+        MaxIterationsExceededException, MathUserException {\n \n         int n = coefficients.length - 1;\n         if (n < 1) {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         // check for zeros before verifying bracketing\n         if (f.value(min) == 0.0) { return min; }\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         // [x0, x2] is the bracketing interval in each iteration\n         // x1 is the last approximation and an interpolation point in (x0, x2)\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve2(final UnivariateRealFunction f,\n                          final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         // x2 is the last root approximation\n         // x is the new approximation and new x2 for next round\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n      * @param max the upper bound for the interval\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function or derivative\n+     * @throws MathUserException if an error occurs evaluating the function or derivative\n      * @throws IllegalArgumentException if min is not less than max\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        throws MaxIterationsExceededException, MathUserException  {\n         return solve(f, min, max, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n \n      * @param startValue the start value to use.\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function or derivative\n+     * @throws MathUserException if an error occurs evaluating the function or derivative\n      * @throws IllegalArgumentException if startValue is not between min and max or\n      * if function is not a {@link DifferentiableUnivariateRealFunction} instance\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double startValue)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         try {\n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n      * @param initial the start value to use\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         // check for zeros before verifying bracketing\n         if (f.value(min) == 0.0) { return min; }\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         // [x1, x2] is the bracketing interval in each iteration\n         // x3 is the midpoint of [x1, x2]\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n      * @param initial the start value to use (ignored)\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n         return solve(f, min, max);\n     }\n \n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, MathUserException {\n \n         clearResult();\n         verifyInterval(min, max);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.ConvergingAlgorithm;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n \n      * @return a value where the function is zero\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n      * satisfy the requirements specified by the solver\n      * @since 2.0\n      */\n     double solve(UnivariateRealFunction f, double min, double max)\n-        throws ConvergenceException,\n-        FunctionEvaluationException;\n+        throws ConvergenceException, MathUserException;\n \n     /**\n      * Solve for a zero in the given interval, start at startValue.\n      * @return a value where the function is zero\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if min > max or the arguments do not\n      * satisfy the requirements specified by the solver\n      * @since 2.0\n      */\n     double solve(UnivariateRealFunction f, double min, double max, double startValue)\n-        throws ConvergenceException, FunctionEvaluationException, IllegalArgumentException;\n+        throws ConvergenceException, MathUserException, IllegalArgumentException;\n \n     /**\n      * Get the result of the last run of the solver.\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergingAlgorithmImpl;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NullArgumentException;\n \n /**\n      * @param upper  the upper endpoint\n      * @param function the function\n      * @return true if f(lower) * f(upper) < 0\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function at the endpoints\n+     * @throws MathUserException if an error occurs evaluating the function at the endpoints\n      */\n     protected boolean isBracketing(final double lower, final double upper,\n                                    final UnivariateRealFunction function)\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n         final double f1 = function.value(lower);\n         final double f2 = function.value(upper);\n         return (f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0);\n      * @param upper upper endpoint\n      * @param function function\n      * @throws IllegalArgumentException\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function at the endpoints\n+     * @throws MathUserException if an error occurs evaluating the function at the endpoints\n      */\n     protected void verifyBracketing(final double lower, final double upper,\n                                     final UnivariateRealFunction function)\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         verifyInterval(lower, upper);\n         if (!isBracketing(lower, upper, function)) {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.FastMath;\n \n      * @param x1 the upper bound for the interval.\n      * @return a value where the function is zero.\n      * @throws ConvergenceException if the iteration count was exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if f is null or the endpoints do not\n      * specify a valid interval\n      */\n     public static double solve(UnivariateRealFunction f, double x0, double x1)\n-    throws ConvergenceException, FunctionEvaluationException {\n+    throws ConvergenceException, MathUserException {\n         setup(f);\n         return LazyHolder.FACTORY.newDefaultSolver().solve(f, x0, x1);\n     }\n      * @param absoluteAccuracy the accuracy to be used by the solver\n      * @return a value where the function is zero\n      * @throws ConvergenceException if the iteration count is exceeded\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if f is null, the endpoints do not\n      * specify a valid interval, or the absoluteAccuracy is not valid for the\n      * default solver\n      */\n     public static double solve(UnivariateRealFunction f, double x0, double x1,\n             double absoluteAccuracy) throws ConvergenceException,\n-            FunctionEvaluationException {\n+            MathUserException {\n \n         setup(f);\n         UnivariateRealSolver solver = LazyHolder.FACTORY.newDefaultSolver();\n      * value)\n      * @return a two element array holding {a, b}\n      * @throws ConvergenceException if a root can not be bracketted\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if function is null, maximumIterations\n      * is not positive, or initial is not between lowerBound and upperBound\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n             double initial, double lowerBound, double upperBound)\n-    throws ConvergenceException, FunctionEvaluationException {\n+    throws ConvergenceException, MathUserException {\n         return bracket( function, initial, lowerBound, upperBound,\n             Integer.MAX_VALUE ) ;\n     }\n      * @return a two element array holding {a, b}.\n      * @throws ConvergenceException if the algorithm fails to find a and b\n      * satisfying the desired conditions\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if function is null, maximumIterations\n      * is not positive, or initial is not between lowerBound and upperBound\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n             double initial, double lowerBound, double upperBound,\n             int maximumIterations) throws ConvergenceException,\n-            FunctionEvaluationException {\n+            MathUserException {\n \n         if (function == null) {\n             throw new NullArgumentException(LocalizedFormats.FUNCTION);\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathUnsupportedOperationException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.BinaryFunction;\n import org.apache.commons.math.analysis.ComposableFunction;\n     /** {@inheritDoc} */\n     public RealVector mapAddToSelf(double d) {\n         if (d != 0) {\n-            try {\n-                return mapToSelf(BinaryFunction.ADD.fix1stArgument(d));\n-            } catch (FunctionEvaluationException e) {\n-                throw new IllegalArgumentException(e);\n-            }\n+            return mapToSelf(BinaryFunction.ADD.fix1stArgument(d));\n         }\n         return this;\n     }\n     public RealVector mapAbsToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.ABS);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapAcosToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.ACOS);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapAsinToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.ASIN);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapAtanToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.ATAN);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapCbrtToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.CBRT);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapCeilToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.CEIL);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapCosToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.COS);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapCoshToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.COSH);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapDivideToSelf(double d){\n         try {\n             return mapToSelf(BinaryFunction.DIVIDE.fix2ndArgument(d));\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapExpToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.EXP);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapExpm1ToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.EXPM1);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapFloorToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.FLOOR);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapInvToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.INVERT);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapLogToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.LOG);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapLog10ToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.LOG10);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapLog1pToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.LOG1P);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapMultiplyToSelf(double d){\n         try {\n             return mapToSelf(BinaryFunction.MULTIPLY.fix1stArgument(d));\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapPowToSelf(double d){\n         try {\n             return mapToSelf(BinaryFunction.POW.fix2ndArgument(d));\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapRintToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.RINT);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapSignumToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.SIGNUM);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapSinToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.SIN);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapSinhToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.SINH);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapSqrtToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.SQRT);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapTanToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.TAN);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapTanhToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.TANH);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     public RealVector mapUlpToSelf() {\n         try {\n             return mapToSelf(ComposableFunction.ULP);\n-        } catch (FunctionEvaluationException e) {\n+        } catch (MathUserException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {\n+    public RealVector map(UnivariateRealFunction function) throws MathUserException {\n         return copy().mapToSelf(function);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {\n+    public RealVector mapToSelf(UnivariateRealFunction function) throws MathUserException {\n         Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n--- a/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Default implementation of the {@link FieldMatrixChangingVisitor} interface.\n--- a/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Default implementation of the {@link FieldMatrixPreservingVisitor} interface.\n--- a/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Default implementation of the {@link RealMatrixChangingVisitor} interface.\n--- a/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Default implementation of the {@link RealMatrixPreservingVisitor} interface.\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining field-valued matrix with basic algebraic operations.\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining a visitor for matrix entries.\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining a visitor for matrix entries.\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.exception.MathUserException;\n+\n \n /**\n  * Interface defining a real-valued matrix with basic algebraic operations.\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining a visitor for matrix entries.\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining a visitor for matrix entries.\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n \n import java.util.Iterator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n \n \n /**\n      *\n      * @param function Function to apply to each entry.\n      * @return this vector.\n-     * @throws FunctionEvaluationException if the function throws it.\n-     */\n-    RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException;\n+     * @throws MathUserException if the function throws it.\n+     */\n+    RealVector mapToSelf(UnivariateRealFunction function) throws MathUserException;\n \n     /**\n      * Acts as if implemented as:\n      *\n      * @param function Functin to apply to each entry.\n      * @return a new vector.\n-     * @throws FunctionEvaluationException if the function throws it.\n-     */\n-    RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException;\n+     * @throws MathUserException if the function throws it.\n+     */\n+    RealVector map(UnivariateRealFunction function) throws MathUserException;\n \n     /** Class representing a modifiable entry in the vector. */\n     public abstract class Entry {\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import java.util.Collections;\n \n import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.events.EventHandler;\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the state vector\n      * @param yDot placeholder array where to put the time derivative of the state vector\n-     * @throws DerivativeException this exception is propagated to the caller if the\n-     * underlying user function triggers one\n+     * @throws MathUserException this user-defined exception should be used if an error is\n+     * is triggered by user code\n      */\n     public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n-        throws DerivativeException {\n+        throws MathUserException {\n         if (++evaluations > maxEvaluations) {\n-            throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+            throw new MathUserException(new MaxEvaluationsExceededException(maxEvaluations));\n         }\n         equations.computeDerivatives(t, y, yDot);\n     }\n--- a/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n   /** Append another model at the end of the instance.\n    * @param model model to add at the end of the instance\n-   * @exception DerivativeException if some step interpolators from\n-   * the appended model cannot be copied\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n    * @exception IllegalArgumentException if the model to append is not\n    * compatible with the instance (dimension of the state vector,\n    * propagation direction, hole between the dates)\n    */\n   public void append(final ContinuousOutputModel model)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     if (model.steps.size() == 0) {\n       return;\n    * the instance for later use.\n    * @param interpolator interpolator for the last accepted step.\n    * @param isLast true if the step is the last one\n-   * @throws DerivativeException this exception is propagated to the\n-   * caller if the underlying user function triggers one\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n    */\n   public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     if (steps.size() == 0) {\n       initialTime = interpolator.getPreviousTime();\n   /**\n    * Get the state vector of the interpolated point.\n    * @return state vector at time {@link #getInterpolatedTime}\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n-   */\n-  public double[] getInterpolatedState() throws DerivativeException {\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n+   */\n+  public double[] getInterpolatedState() throws MathUserException {\n     return steps.get(index).getInterpolatedState();\n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /** This class converts second order differential equations to first\n  * order ones.\n    * @param t current value of the independent <I>time</I> variable\n    * @param y array containing the current value of the state vector\n    * @param yDot placeholder array where to put the time derivative of the state vector\n-   * @throws DerivativeException this exception is propagated to the caller if the\n+   * @throws MathUserException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n   public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n-      throws DerivativeException {\n+      throws MathUserException {\n \n     // split the state vector in two\n     System.arraycopy(y, 0,         z,    0, dimension);\n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n \n /** This interface represents a first order differential equations set.\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the state vector\n      * @param yDot placeholder array where to put the time derivative of the state vector\n-     * @throws DerivativeException this exception is propagated to the caller if the\n-     * underlying user function triggers one\n+     * @throws MathUserException this user-defined exception should be used if an error is\n+     * is triggered by user code\n      */\n-    void computeDerivatives(double t, double[] y, double[] yDot) throws DerivativeException;\n+    void computeDerivatives(double t, double[] y, double[] yDot)\n+        throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /** This interface represents a first order integrator for\n  * differential equations.\n    * target, but may be different if some {@link\n    * org.apache.commons.math.ode.events.EventHandler} stops it at some point.\n    * @throws IntegratorException if the integrator cannot perform integration\n-   * @throws DerivativeException this exception is propagated to the caller if\n+   * @throws MathUserException this exception is propagated to the caller if\n    * the underlying user function triggers one\n    */\n   double integrate (FirstOrderDifferentialEquations equations,\n                     double t0, double[] y0,\n-                    double t, double[] y) throws DerivativeException, IntegratorException;\n+                    double t, double[] y) throws MathUserException, IntegratorException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n package org.apache.commons.math.ode;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n      * @param t target time for the integration\n      * (can be set to a value smaller than <code>t0</code> for backward integration)\n      * @throws IntegratorException if the integrator cannot perform integration\n-     * @throws DerivativeException this exception is propagated to the caller if\n+     * @throws MathUserException this exception is propagated to the caller if\n      * the underlying user function triggers one\n      */\n     protected void start(final double t0, final double[] y0, final double t)\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n \n         // make sure NO user event nor user step handler is triggered,\n         // this is the task of the top level integrator, not the task\n         try {\n             starter.integrate(new CountingDifferentialEquations(y0.length),\n                               t0, y0, t, new double[y0.length]);\n-        } catch (DerivativeException de) {\n-            if (!(de instanceof InitializationCompletedMarkerException)) {\n+        } catch (MathUserException mue) {\n+            if (!(mue instanceof InitializationCompletedMarkerException)) {\n                 // this is not the expected nominal interruption of the start integrator\n-                throw de;\n+                throw mue;\n             }\n         }\n \n \n         /** {@inheritDoc} */\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-            throws DerivativeException {\n+            throws MathUserException {\n \n             final double prev = interpolator.getPreviousTime();\n             final double curr = interpolator.getCurrentTime();\n \n     /** Marker exception used ONLY to stop the starter integrator after first step. */\n     private static class InitializationCompletedMarkerException\n-        extends DerivativeException {\n+        extends MathUserException {\n \n         /** Serializable version identifier. */\n         private static final long serialVersionUID = -4105805787353488365L;\n \n         /** {@inheritDoc} */\n         public void computeDerivatives(double t, double[] y, double[] dot)\n-                throws DerivativeException {\n+                throws MathUserException {\n             MultistepIntegrator.this.computeDerivatives(t, y, dot);\n         }\n \n--- a/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n /** This interface represents a second order differential equations set.\n \n      * of the state vector\n      * @param yDDot placeholder array where to put the second time derivative\n      * of the state vector\n-     * @throws DerivativeException this exception is propagated to the caller if the\n-     * underlying user function triggers one\n+     * @throws MathUserException this user-defined exception should be used if an error is\n+     * is triggered by user code\n      */\n-    void computeSecondDerivatives(double t, double[] y, double[] yDot,\n-                                  double[] yDDot) throws DerivativeException;\n+    void computeSecondDerivatives(double t, double[] y, double[] yDot, double[] yDDot)\n+        throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.exception.MathUserException;\n \n \n /** This interface represents a second order integrator for\n    * @param yDot placeholder where to put the first derivative of\n    * the state vector at time t, can be the same object as yDot0\n    * @throws IntegratorException if the integrator cannot perform integration\n-   * @throws DerivativeException this exception is propagated to the caller if the\n+   * @throws MathUserException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n   void integrate(SecondOrderDifferentialEquations equations,\n                  double t0, double[] y0, double[] yDot0,\n                  double t, double[] y, double[] yDot)\n-      throws DerivativeException, IntegratorException;\n+      throws MathUserException, IntegratorException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n import java.util.List;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n      * @return true if at least one event handler triggers an event\n      * before the end of the proposed step (this implies the step should\n      * be rejected)\n-     * @exception DerivativeException if the interpolator fails to\n+     * @exception MathUserException if the interpolator fails to\n      * compute the function somewhere within the step\n      * @exception IntegratorException if an event cannot be located\n      */\n     public boolean evaluateStep(final StepInterpolator interpolator)\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n         try {\n \n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n package org.apache.commons.math.ode.events;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n \n                 g0Positive = g0 >= 0;\n             }\n \n-        } catch (DerivativeException de) {\n-            throw new EventException(de);\n+        } catch (MathUserException mue) {\n+            throw new EventException(mue);\n         }\n     }\n \n      * @return true if the event handler triggers an event before\n      * the end of the proposed step (this implies the step should be\n      * rejected)\n-     * @exception DerivativeException if the interpolator fails to\n+     * @exception MathUserException if the interpolator fails to\n      * compute the switching function somewhere within the step\n      * @exception EventException if the switching function\n      * cannot be evaluated\n      * @exception ConvergenceException if an event cannot be located\n      */\n     public boolean evaluateStep(final StepInterpolator interpolator)\n-        throws DerivativeException, EventException, ConvergenceException {\n+        throws MathUserException, EventException, ConvergenceException {\n \n         try {\n \n                     increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                        public double value(final double t) throws FunctionEvaluationException {\n+                        public double value(final double t) throws MathUserException {\n                             try {\n                                 interpolator.setInterpolatedTime(t);\n                                 return handler.g(t, interpolator.getInterpolatedState());\n-                            } catch (DerivativeException e) {\n-                                throw new FunctionEvaluationException(e, t);\n                             } catch (EventException e) {\n-                                throw new FunctionEvaluationException(e, t);\n+                                throw new MathUserException(e);\n                             }\n                         }\n                     };\n             pendingEventTime = Double.NaN;\n             return false;\n \n-        } catch (FunctionEvaluationException e) {\n-            final Throwable cause = e.getCause();\n-            if ((cause != null) && (cause instanceof DerivativeException)) {\n-                throw (DerivativeException) cause;\n-            } else if ((cause != null) && (cause instanceof EventException)) {\n+        } catch (MathUserException mue) {\n+            final Throwable cause = mue.getCause();\n+            if ((cause != null) && (cause instanceof EventException)) {\n                 throw (EventException) cause;\n             }\n-            throw new EventException(e);\n+            throw mue;\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n      * @return stop time, will be the same as target time if integration reached its\n      * target, but may be different if some event handler stops it at some point.\n      * @throws IntegratorException if the integrator cannot perform integration\n-     * @throws DerivativeException this exception is propagated to the caller if\n+     * @throws MathUserException this exception is propagated to the caller if\n      * the underlying user function triggers one\n      */\n     public double integrate(final double t0, final double[] y0, final double[][] dY0dP,\n                             final double t, final double[] y,\n                             final double[][] dYdY0, final double[][] dYdP)\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n \n         final int n = ode.getDimension();\n         final int k = ode.getParametersDimension();\n \n         /** {@inheritDoc} */\n         public void computeDerivatives(final double t, final double[] z, final double[] zDot)\n-            throws DerivativeException {\n+            throws MathUserException {\n \n             final int n = y.length;\n             final int k = dFdP[0].length;\n             // compute raw ODE and its jacobians: dy/dt, d[dy/dt]/dy0 and d[dy/dt]/dp\n             System.arraycopy(z,    0, y,    0, n);\n             if (++evaluations > maxEvaluations) {\n-                throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+                throw new MathUserException(new MaxEvaluationsExceededException(maxEvaluations));\n             }\n             ode.computeDerivatives(t, y, yDot);\n             ode.computeJacobians(t, y, yDot, dFdY, dFdP);\n         }\n \n         /** {@inheritDoc} */\n-        public void computeDerivatives(double t, double[] y, double[] yDot) throws DerivativeException {\n+        public void computeDerivatives(double t, double[] y, double[] yDot) throws MathUserException {\n             // this call to computeDerivatives has already been counted,\n             // we must not increment the counter again\n             ode.computeDerivatives(t, y, yDot);\n         /** {@inheritDoc} */\n         public void computeJacobians(double t, double[] y, double[] yDot,\n                                      double[][] dFdY, double[][] dFdP)\n-            throws DerivativeException {\n+            throws MathUserException {\n \n             final int n = hY.length;\n             final int k = hP.length;\n \n             evaluations += n + k;\n             if (evaluations > maxEvaluations) {\n-                throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+                throw new MathUserException(new MaxEvaluationsExceededException(maxEvaluations));\n             }\n \n             // compute df/dy where f is the ODE and y is the state array\n \n         /** {@inheritDoc} */\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-            throws DerivativeException {\n+            throws MathUserException {\n             handler.handleStep(new StepInterpolatorWrapper(interpolator, n, k), isLast);\n         }\n \n         }\n \n         /** {@inheritDoc} */\n-        public double[] getInterpolatedY() throws DerivativeException {\n+        public double[] getInterpolatedY() throws MathUserException {\n             double[] extendedState = interpolator.getInterpolatedState();\n             System.arraycopy(extendedState, 0, y, 0, y.length);\n             return y;\n         }\n \n         /** {@inheritDoc} */\n-        public double[][] getInterpolatedDyDy0() throws DerivativeException {\n+        public double[][] getInterpolatedDyDy0() throws MathUserException {\n             double[] extendedState = interpolator.getInterpolatedState();\n             final int n = y.length;\n             int start = n;\n         }\n \n         /** {@inheritDoc} */\n-        public double[][] getInterpolatedDyDp() throws DerivativeException {\n+        public double[][] getInterpolatedDyDp() throws MathUserException {\n             double[] extendedState = interpolator.getInterpolatedState();\n             final int n = y.length;\n             final int k = dydp[0].length;\n         }\n \n         /** {@inheritDoc} */\n-        public double[] getInterpolatedYDot() throws DerivativeException {\n+        public double[] getInterpolatedYDot() throws MathUserException {\n             double[] extendedDerivatives = interpolator.getInterpolatedDerivatives();\n             System.arraycopy(extendedDerivatives, 0, yDot, 0, yDot.length);\n             return yDot;\n         }\n \n         /** {@inheritDoc} */\n-        public double[][] getInterpolatedDyDy0Dot() throws DerivativeException {\n+        public double[][] getInterpolatedDyDy0Dot() throws MathUserException {\n             double[] extendedDerivatives = interpolator.getInterpolatedDerivatives();\n             final int n = y.length;\n             int start = n;\n         }\n \n         /** {@inheritDoc} */\n-        public double[][] getInterpolatedDyDpDot() throws DerivativeException {\n+        public double[][] getInterpolatedDyDpDot() throws MathUserException {\n             double[] extendedDerivatives = interpolator.getInterpolatedDerivatives();\n             final int n = y.length;\n             final int k = dydpDot[0].length;\n         }\n \n         /** {@inheritDoc} */\n-        public StepInterpolatorWithJacobians copy() throws DerivativeException {\n+        public StepInterpolatorWithJacobians copy() throws MathUserException {\n             final int n = y.length;\n             final int k = dydp[0].length;\n             StepInterpolatorWrapper copied =\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/ODEWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/ODEWithJacobians.java\n \n package org.apache.commons.math.ode.jacobians;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n \n \n      * @param yDot array containing the current value of the time derivative of the state vector\n      * @param dFdY placeholder array where to put the jacobian of the ODE with respect to the state vector\n      * @param dFdP placeholder array where to put the jacobian of the ODE with respect to the parameters\n-     * @throws DerivativeException this exception is propagated to the caller if the\n+     * @throws MathUserException this exception is propagated to the caller if the\n      * underlying user function triggers one\n      */\n     void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP)\n-        throws DerivativeException;\n+        throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/StepHandlerWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/StepHandlerWithJacobians.java\n \n package org.apache.commons.math.ode.jacobians;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface represents a handler that should be called after\n    * Keeping only a reference to the interpolator and reusing it will\n    * result in unpredictable behavior (potentially crashing the application).\n    * @param isLast true if the step is the last one\n-   * @throws DerivativeException this exception is propagated to the\n+   * @throws MathUserException this exception is propagated to the\n    * caller if the underlying user function triggers one\n    */\n-  void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast) throws DerivativeException;\n+  void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast) throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/StepInterpolatorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/StepInterpolatorWithJacobians.java\n \n import java.io.Externalizable;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /** This interface represents an interpolator over the last step\n  * during an ODE integration.\n    * to be preserved across several calls.</p>\n    * @return state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedYDot()\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  double[] getInterpolatedY() throws DerivativeException;\n+  double[] getInterpolatedY() throws MathUserException;\n \n   /**\n    * Get the partial derivatives of the state vector with respect to\n    * @return partial derivatives of the state vector with respect to\n    * the initial state at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedY()\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  double[][] getInterpolatedDyDy0() throws DerivativeException;\n+  double[][] getInterpolatedDyDy0() throws MathUserException;\n \n   /**\n    * Get the partial derivatives of the state vector with respect to\n    * @return partial derivatives of the state vector with respect to\n    * the ODE parameters at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedY()\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  double[][] getInterpolatedDyDp() throws DerivativeException;\n+  double[][] getInterpolatedDyDp() throws MathUserException;\n \n   /**\n    * Get the time derivatives of the state vector of the interpolated point.\n    * to be preserved across several calls.</p>\n    * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedY()\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  double[] getInterpolatedYDot() throws DerivativeException;\n+  double[] getInterpolatedYDot() throws MathUserException;\n \n   /**\n    * Get the time derivatives of the jacobian of the state vector\n    * @return time derivatives of the jacobian of the state vector\n    * with respect to the initial state at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedY()\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  double[][] getInterpolatedDyDy0Dot() throws DerivativeException;\n+  double[][] getInterpolatedDyDy0Dot() throws MathUserException;\n \n   /**\n    * Get the time derivatives of the jacobian of the state vector\n    * @return time derivatives of the jacobian of the state vector\n    * with respect to the ODE parameters at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedY()\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  double[][] getInterpolatedDyDpDot() throws DerivativeException;\n+  double[][] getInterpolatedDyDpDot() throws MathUserException;\n \n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by\n    * original one. Both can be used with different settings for\n    * interpolated time without any side effect.</p>\n    * @return a deep copy of the instance, which can be used independently.\n-   * @throws DerivativeException if this call induces an automatic\n+   * @throws MathUserException if this call induces an automatic\n    * step finalization that throws one\n    * @see #setInterpolatedTime(double)\n    */\n-   StepInterpolatorWithJacobians copy() throws DerivativeException;\n+   StepInterpolatorWithJacobians copy() throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n     public double integrate(final FirstOrderDifferentialEquations equations,\n                             final double t0, final double[] y0,\n                             final double t, final double[] y)\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n \n         final int n = y0.length;\n         sanityChecks(equations, t0, y0, t, y);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.MultistepIntegrator;\n     public abstract double integrate(final FirstOrderDifferentialEquations equations,\n                                      final double t0, final double[] y0,\n                                      final double t, final double[] y)\n-        throws DerivativeException, IntegratorException;\n+        throws MathUserException, IntegratorException;\n \n     /** {@inheritDoc} */\n     @Override\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n \n import java.util.Arrays;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n     public double integrate(final FirstOrderDifferentialEquations equations,\n                             final double t0, final double[] y0,\n                             final double t, final double[] y)\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n \n         final int n = y0.length;\n         sanityChecks(equations, t0, y0, t, y);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n    * @param y1 work array for a state vector\n    * @param yDot1 work array for the first time derivative of y1\n    * @return first integration step\n-   * @exception DerivativeException this exception is propagated to\n+   * @exception MathUserException this exception is propagated to\n    * the caller if the underlying user function triggers one\n    */\n   public double initializeStep(final FirstOrderDifferentialEquations equations,\n                                final boolean forward, final int order, final double[] scale,\n                                final double t0, final double[] y0, final double[] yDot0,\n                                final double[] y1, final double[] yDot1)\n-      throws DerivativeException {\n+      throws MathUserException {\n \n     if (initialStep > 0) {\n       // use the user provided value\n   public abstract double integrate (FirstOrderDifferentialEquations equations,\n                                     double t0, double[] y0,\n                                     double t, double[] y)\n-    throws DerivativeException, IntegratorException;\n+    throws MathUserException, IntegratorException;\n \n   /** {@inheritDoc} */\n   @Override\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n     @Override\n     protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                             final double oneMinusThetaH)\n-        throws DerivativeException {\n+        throws MathUserException {\n \n         final double fourTheta      = 4 * theta;\n         final double oneMinusTheta  = 1 - theta;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     if (! vectorsInitialized) {\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n import java.io.ObjectOutput;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     if (! vectorsInitialized) {\n \n   /** {@inheritDoc} */\n   @Override\n   protected void doFinalize()\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     if (currentState == null) {\n       // we are finalizing an uninitialized instance\n     try {\n       // save the local attributes\n       finalizeStep();\n-    } catch (DerivativeException e) {\n+    } catch (MathUserException e) {\n       throw MathRuntimeException.createIOException(e);\n     }\n     final int dimension = (currentState == null) ? -1 : currentState.length;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n   public double integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0,\n                           final double t, final double[] y)\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n       interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n \n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     final double twoTheta  = 2 * theta;\n     final double fourTheta = 4 * theta;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.events.EventHandler;\n    * @param yTmp placeholder for one state vector\n    * @return true if computation was done properly,\n    *         false if stability check failed before end of computation\n-   * @throws DerivativeException this exception is propagated to the caller if the\n+   * @throws MathUserException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n   private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                           final double[] scale, final double[][] f,\n                           final double[] yMiddle, final double[] yEnd,\n                           final double[] yTmp)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     final int    n        = sequence[k];\n     final double subStep  = step / n;\n   @Override\n   public double integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0, final double t, final double[] y)\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     final int dimension = currentState.length;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     final double theta2 = theta * theta;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     final double coeff1    = oneMinusThetaH * theta;\n     final double coeff2    = oneMinusThetaH * (1.0 + theta);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n package org.apache.commons.math.ode.nonstiff;\n \n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n   public double integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0,\n                           final double t, final double[] y)\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                           final double oneMinusThetaH)\n-      throws DerivativeException {\n+      throws MathUserException {\n \n       final double fourTheta2 = 4 * theta * theta;\n       final double s          = oneMinusThetaH / 8.0;\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n import java.io.ObjectOutput;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /** This abstract class represents an interpolator over the last step\n  * during an ODE integration.\n   }\n \n   /** {@inheritDoc} */\n-   public StepInterpolator copy() throws DerivativeException {\n+   public StepInterpolator copy() throws MathUserException {\n \n      // finalize the step before performing copy\n      finalizeStep();\n    * (theta is zero at the previous time step and one at the current time step)\n    * @param oneMinusThetaH time gap between the interpolated time and\n    * the current time\n-   * @throws DerivativeException this exception is propagated to the caller if the\n+   * @throws MathUserException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n   protected abstract void computeInterpolatedStateAndDerivatives(double theta,\n                                                                  double oneMinusThetaH)\n-    throws DerivativeException;\n-\n-  /** {@inheritDoc} */\n-  public double[] getInterpolatedState() throws DerivativeException {\n+    throws MathUserException;\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedState() throws MathUserException {\n \n       // lazy evaluation of the state\n       if (dirtyState) {\n   }\n \n   /** {@inheritDoc} */\n-  public double[] getInterpolatedDerivatives() throws DerivativeException {\n+  public double[] getInterpolatedDerivatives() throws MathUserException {\n \n       // lazy evaluation of the state\n       if (dirtyState) {\n    * Therefore, subclasses are not allowed not reimplement it, they\n    * should rather reimplement <code>doFinalize</code>.</p>\n \n-   * @throws DerivativeException this exception is propagated to the\n+   * @throws MathUserException this exception is propagated to the\n    * caller if the underlying user function triggers one\n    */\n   public final void finalizeStep()\n-    throws DerivativeException {\n+    throws MathUserException {\n     if (! finalized) {\n       doFinalize();\n       finalized = true;\n   /**\n    * Really finalize the step.\n    * The default implementation of this method does nothing.\n-   * @throws DerivativeException this exception is propagated to the\n+   * @throws MathUserException this exception is propagated to the\n    * caller if the underlying user function triggers one\n    */\n   protected void doFinalize()\n-    throws DerivativeException {\n+    throws MathUserException {\n   }\n \n   /** {@inheritDoc} */\n     // finalize the step (and don't bother saving the now true flag)\n     try {\n       finalizeStep();\n-    } catch (DerivativeException e) {\n+    } catch (MathUserException e) {\n       throw MathRuntimeException.createIOException(e);\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n import java.io.IOException;\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n-\n-import org.apache.commons.math.ode.DerivativeException;\n \n /** This class is a step interpolator that does nothing.\n  *\n    * (theta is zero at the previous time step and one at the current time step)\n    * @param oneMinusThetaH time gap between the interpolated time and\n    * the current time\n-   * @throws DerivativeException this exception is propagated to the caller if the\n-   * underlying user function triggers one\n    */\n   @Override\n-  protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n-    throws DerivativeException {\n+  protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n       System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n       System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n   }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n \n package org.apache.commons.math.ode.sampling;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface represents a handler that should be called after\n    * provide at the end of the integration a complete array of all\n    * steps), it should build a local copy store this copy.\n    * @param isLast true if the step is the last one\n-   * @throws DerivativeException if some error condition is encountered\n+   * @throws MathUserException if some error condition is encountered\n    */\n-  void handleStep(double t, double[] y, double[] yDot, boolean isLast) throws DerivativeException;\n+  void handleStep(double t, double[] y, double[] yDot, boolean isLast) throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n import java.io.ObjectOutput;\n import java.util.Arrays;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n      * to be preserved across several calls.</p>\n      * @return state vector at time {@link #getInterpolatedTime}\n      * @see #getInterpolatedDerivatives()\n-     * @throws DerivativeException if this call induces an automatic\n+     * @throws MathUserException if this call induces an automatic\n      * step finalization that throws one\n      */\n     public double[] getInterpolatedStateVariation()\n-        throws DerivativeException {\n+        throws MathUserException {\n         // compute and ignore interpolated state\n         // to make sure state variation is computed as a side effect\n         getInterpolatedState();\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n \n package org.apache.commons.math.ode.sampling;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface represents a handler that should be called after\n    * Keeping only a reference to the interpolator and reusing it will\n    * result in unpredictable behavior (potentially crashing the application).\n    * @param isLast true if the step is the last one\n-   * @throws DerivativeException this exception is propagated to the\n-   * caller if the underlying user function triggers one\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n    */\n-  void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException;\n+  void handleStep(StepInterpolator interpolator, boolean isLast) throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n \n import java.io.Externalizable;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /** This interface represents an interpolator over the last step\n  * during an ODE integration.\n    * to be preserved across several calls.</p>\n    * @return state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedDerivatives()\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n    */\n-  double[] getInterpolatedState() throws DerivativeException;\n+  double[] getInterpolatedState() throws MathUserException;\n \n   /**\n    * Get the derivatives of the state vector of the interpolated point.\n    * to be preserved across several calls.</p>\n    * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedState()\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n    * @since 2.0\n    */\n-  double[] getInterpolatedDerivatives() throws DerivativeException;\n+  double[] getInterpolatedDerivatives() throws MathUserException;\n \n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by\n    * original one. Both can be used with different settings for\n    * interpolated time without any side effect.</p>\n    * @return a deep copy of the instance, which can be used independently.\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n+   * @exception MathUserException if user code called from step interpolator\n+   * finalization triggers one\n    * @see #setInterpolatedTime(double)\n    */\n-   StepInterpolator copy() throws DerivativeException;\n+   StepInterpolator copy() throws MathUserException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n \n package org.apache.commons.math.ode.sampling;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n      * should build a local copy using the clone method and store this\n      * copy.\n      * @param isLast true if the step is the last one\n-     * @throws DerivativeException this exception is propagated to the\n+     * @throws MathUserException this exception is propagated to the\n      * caller if the underlying user function triggers one\n      */\n     public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n-        throws DerivativeException {\n+        throws MathUserException {\n \n         if (lastState == null) {\n \n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n      */\n     public RealPointValuePair optimize(final FUNC f,\n                                        final GoalType goal,\n-                                       double[] startPoint) {\n+                                       double[] startPoint) throws MathUserException {\n         MathUserException lastException = null;\n         optima = new RealPointValuePair[starts];\n         totalEvaluations = 0;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n     public VectorialPointValuePair optimize(final FUNC f,\n                                             double[] target, double[] weights,\n                                             double[] startPoint)\n-        throws FunctionEvaluationException {\n-\n+        throws MathUserException {\n+\n+        MathUserException lastException = null;\n         optima = new VectorialPointValuePair[starts];\n \n         // Multi-start loop.\n             try {\n                 optima[i] = optimizer.optimize(f, target, weights,\n                                                i == 0 ? startPoint : generator.nextVector());\n-            } catch (FunctionEvaluationException fee) {\n+            } catch (MathUserException mue) {\n+                lastException = mue;\n                 optima[i] = null;\n             } catch (ConvergenceException oe) {\n                 optima[i] = null;\n         sortPairs(target, weights);\n \n         if (optima[0] == null) {\n-            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n-                                           starts);\n+            throw lastException;\n         }\n \n         // Return the found point given the best objective function value.\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n+     * @throws MathUserException if objective function throws one during search\n      */\n-    RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint);\n+    RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint) throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n+     * @throws MathUserException if function throws one during search.\n      */\n     VectorialPointValuePair optimize(FUNC f, double[] target, double[] weight,\n-                                     double[] startPoint);\n+                                     double[] startPoint) throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.RealMatrix;\n \n /** This class converts {@link MultivariateVectorialFunction vectorial\n     }\n \n     /** {@inheritDoc} */\n-    public double value(final double[] point) {\n+    public double value(final double[] point) throws MathUserException {\n         // compute residuals\n         final double[] residuals = function.value(point);\n         if (residuals.length != observations.length) {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.ZeroException;\n      * to worst.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the algorithm fails to converge.\n+     * @throws MathUserException if evaluation function throws one\n      */\n     public abstract void iterate(final MultivariateRealFunction evaluationFunction,\n-                                 final Comparator<RealPointValuePair> comparator);\n+                                 final Comparator<RealPointValuePair> comparator)\n+        throws MathUserException;\n \n     /**\n      * Build an initial simplex.\n      * @param comparator Comparator to use to sort simplex vertices from best to worst.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n+     * @throws MathUserException if evaluation function throws one\n      */\n     public void evaluate(final MultivariateRealFunction evaluationFunction,\n-                         final Comparator<RealPointValuePair> comparator) {\n+                         final Comparator<RealPointValuePair> comparator)\n+        throws MathUserException {\n         // Evaluate the objective function at all non-evaluated simplex points.\n         for (int i = 0; i < simplex.length; i++) {\n             final RealPointValuePair vertex = simplex[i];\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n      * @return the objective function value at the specified point.\n      * @throws TooManyEvaluationsException if the maximal number of\n      * evaluations is exceeded.\n+     * @throws MathUserException if objective function throws one\n      */\n-    protected double computeObjectiveValue(double[] point) {\n+    protected double computeObjectiveValue(double[] point) throws MathUserException {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     /** {@inheritDoc} */\n     public RealPointValuePair optimize(FUNC f,\n                                        GoalType goalType,\n-                                       double[] startPoint) {\n+                                       double[] startPoint) throws MathUserException {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n      * Perform the bulk of the optimization algorithm.\n      *\n      * @return the point/value pair giving the optimal value for objective function.\n+     * @throws MathUserException if objective function throws one\n      */\n-    protected abstract RealPointValuePair doOptimize();\n+    protected abstract RealPointValuePair doOptimize() throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n      * @return the objective function value at the specified point.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n+     * @throws MathUserException if objective function throws one\n      */\n-    protected double[] computeObjectiveValue(double[] point) {\n+    protected double[] computeObjectiveValue(double[] point) throws MathUserException {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     }\n \n     /** {@inheritDoc} */\n-    public VectorialPointValuePair optimize(FUNC f,\n-                                            double[] t, double[] w,\n-                                            double[] startPoint) {\n+    public VectorialPointValuePair optimize(FUNC f, double[] t, double[] w, double[] startPoint)\n+        throws MathUserException {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n      * Perform the bulk of the optimization algorithm.\n      *\n      * @return the point/value pair giving the optimal value for objective function\n+     * @throws MathUserException if function throws one during search.\n      */\n-    protected abstract VectorialPointValuePair doOptimize();\n+    protected abstract VectorialPointValuePair doOptimize() throws MathUserException;\n \n     /**\n      * @return a reference to the {@link #target array}.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateRealFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator) {\n+                        final Comparator<RealPointValuePair> comparator)\n+        throws MathUserException {\n         // Save the original simplex.\n         final RealPointValuePair[] original = getPoints();\n         final RealPointValuePair best = original[0];\n         }\n \n         // Compute the contracted simplex.\n-        final RealPointValuePair contracted = evaluateNewSimplex(evaluationFunction,\n-                                                                 original, gamma, comparator);\n+        evaluateNewSimplex(evaluationFunction, original, gamma, comparator);\n+\n     }\n \n     /**\n      * @return the best point in the transformed simplex.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n+     * @throws MathUserException if function cannot be evaluated at some points\n      */\n     private RealPointValuePair evaluateNewSimplex(final MultivariateRealFunction evaluationFunction,\n                                                   final RealPointValuePair[] original,\n                                                   final double coeff,\n-                                                  final Comparator<RealPointValuePair> comparator) {\n+                                                  final Comparator<RealPointValuePair> comparator)\n+        throws MathUserException {\n         final double[] xSmallest = original[0].getPointRef();\n         // Perform a linear transformation on all the simplex points,\n         // except the first one.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n \n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This class implements the Nelder-Mead simplex algorithm.\n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateRealFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator) {\n+                        final Comparator<RealPointValuePair> comparator)\n+        throws MathUserException {\n         // The simplex has n + 1 points if dimension is n.\n         final int n = getDimension();\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.GoalType;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected RealPointValuePair doOptimize() throws MathUserException {\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n          * @return the optimum.\n          * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n          * if the number of evaluations is exceeded.\n+         * @throws MathUserException if objective function throws one.\n          */\n-        public UnivariateRealPointValuePair search(final double[] p,\n-                                                   final double[] d) {\n+        public UnivariateRealPointValuePair search(final double[] p, final double[] d)\n+            throws MathUserException {\n             final int n = p.length;\n             final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                    public double value(double alpha) {\n+                    public double value(double alpha) throws MathUserException {\n                         final double[] x = new double[n];\n                         for (int i = 0; i < n; i++) {\n                             x[i] = p[i] + alpha * d[i];\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected RealPointValuePair doOptimize() throws MathUserException {\n         if (simplex == null) {\n             throw new NullArgumentException();\n         }\n         // evaluations counter.\n         final MultivariateRealFunction evalFunc\n             = new MultivariateRealFunction() {\n-                public double value(double[] point) {\n+                public double value(double[] point) throws MathUserException {\n                     return computeObjectiveValue(point);\n                 }\n             };\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n \n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n      * if the algorithm failed to converge.\n      * @exception org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n+     * @throws MathUserException if the parametric function throws one\n      */\n     public double[] fit(final ParametricRealFunction f,\n-                        final double[] initialGuess) {\n+                        final double[] initialGuess) throws MathUserException {\n         // prepare least squares problem\n         double[] target  = new double[observations.size()];\n         double[] weights = new double[observations.size()];\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n      *\n      * @throws DimensionMismatchException if the Jacobian dimension does not\n      * match problem dimension.\n-     */\n-    protected void updateJacobian() {\n+     * @throws MathUserException if users jacobian function throws one\n+     */\n+    protected void updateJacobian() throws MathUserException {\n         ++jacobianEvaluations;\n         weightedResidualJacobian = jF.value(point);\n         if (weightedResidualJacobian.length != rows) {\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n-    protected void updateResidualsAndCost() {\n+    protected void updateResidualsAndCost() throws MathUserException {\n         objective = computeObjectiveValue(point);\n         if (objective.length != rows) {\n             throw new DimensionMismatchException(objective.length, rows);\n      * @return the covariance matrix.\n      * @throws org.apache.commons.math.exception.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n-     */\n-    public double[][] getCovariances() {\n+     * @throws MathUserException if jacobian function throws one\n+     */\n+    public double[][] getCovariances() throws MathUserException {\n         // set up the jacobian\n         updateJacobian();\n \n      * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n      * positive, i.e. the number of measurements is less or equal to the number of\n      * parameters.\n-     */\n-    public double[] guessParametersErrors() {\n+     * @throws MathUserException if jacobian function throws one\n+     */\n+    public double[] guessParametersErrors() throws MathUserException {\n         if (rows <= cols) {\n             throw new NumberIsTooSmallException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                                                 rows, cols, false);\n     @Override\n     public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                             final double[] target, final double[] weights,\n-                                            final double[] startPoint) {\n+                                            final double[] startPoint) throws MathUserException {\n         // Reset counter.\n         jacobianEvaluations = 0;\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n \n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n      * @return the gradient at the specified point.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the allowed number of evaluations is exceeded.\n+     * @throws MathUserException if objective function gradient throws one\n      */\n-    protected double[] computeObjectiveGradient(final double[] evaluationPoint) {\n+    protected double[] computeObjectiveGradient(final double[] evaluationPoint)\n+        throws MathUserException {\n         return gradient.value(evaluationPoint);\n     }\n \n     @Override\n     public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n-                                       final double[] startPoint) {\n+                                       final double[] startPoint) throws MathUserException {\n         // Store optimization problem characteristics.\n         gradient = f.gradient();\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n     /** {@inheritDoc} */\n     @Override\n-    public VectorialPointValuePair doOptimize() {\n+    public VectorialPointValuePair doOptimize() throws MathUserException {\n \n         final ConvergenceChecker<VectorialPointValuePair> checker\n             = getConvergenceChecker();\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected VectorialPointValuePair doOptimize() {\n+    protected VectorialPointValuePair doOptimize() throws MathUserException {\n         // arrays shared with the other private methods\n         solvedCols  = FastMath.min(rows, cols);\n         diagR       = new double[cols];\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n \n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() {\n+    protected RealPointValuePair doOptimize() throws MathUserException {\n         // Initialization.\n         if (preconditioner == null) {\n             preconditioner = new IdentityPreconditioner();\n      * @param h initial step to try.\n      * @return b such that f(a) and f(b) have opposite signs.\n      * @exception MathIllegalStateException if no bracket can be found.\n+     * @exception MathUserException if function throws one.\n      */\n     private double findUpperBound(final UnivariateRealFunction f,\n-                                  final double a, final double h) {\n+                                  final double a, final double h)\n+        throws MathUserException {\n         final double yA = f.value(a);\n         double yB = yA;\n         for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n         }\n \n         /** {@inheritDoc} */\n-        public double value(double x) {\n+        public double value(double x) throws MathUserException {\n \n             // current point in the search direction\n             final double[] shiftedPoint = point.clone();\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n      * @return the objective function value at specified point.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n+     * @throws MathUserException if objective function throws one\n      */\n-    protected double computeObjectiveValue(double point) {\n+    protected double computeObjectiveValue(double point) throws MathUserException {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max,\n-                                                 double startValue) {\n+                                                 double startValue) throws MathUserException {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                  GoalType goalType,\n-                                                 double min, double max) {\n+                                                 double min, double max) throws MathUserException {\n         return optimize(f, goalType, min, max, min + 0.5 * (max - min));\n     }\n \n      * @return the optimum and its corresponding function value.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n+     * @throws MathUserException if the function to optimize throws one during search.\n      */\n-    protected abstract UnivariateRealPointValuePair doOptimize();\n+    protected abstract UnivariateRealPointValuePair doOptimize() throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.BaseOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n \n      * if the optimizer detects a convergence problem.\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n+     * @throws MathUserException if the function to optimize throws one during search.\n      */\n     UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n-                                          double min, double max);\n+                                          double min, double max) throws MathUserException;\n \n     /**\n      * Find an optimum in the given interval, start at startValue.\n      * do not satisfy the requirements specified by the optimizer.\n      * @throws org.apache.commons.math.exception.NullArgumentException if any\n      * argument is {@code null}.\n+     * @throws MathUserException if the function to optimize throws one during search.\n      */\n     UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n                                           double min, double max,\n-                                          double startValue);\n+                                          double startValue) throws MathUserException;\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n     /**\n      * Search new points that bracket a local optimum of the function.\n      *\n-     * @param func Function whose optimum should be bracketted.\n+     * @param func Function whose optimum should be bracketed.\n      * @param goal {@link GoalType Goal type}.\n      * @param xA Initial point.\n      * @param xB Initial point.\n      * @throws TooManyEvaluationsException if the maximum number of evaluations\n      * is exceeded.\n-     */\n-    public void search(UnivariateRealFunction func,\n-                       GoalType goal,\n-                       double xA,\n-                       double xB) {\n+     * @throws MathUserException if function throw one\n+     */\n+    public void search(UnivariateRealFunction func, GoalType goal, double xA, double xB)\n+        throws MathUserException {\n         evaluations.resetCount();\n         final boolean isMinim = goal == GoalType.MINIMIZE;\n \n      * @return {@code f(x)}\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n-     */\n-    private double eval(UnivariateRealFunction f,\n-                        double x) {\n+     * @throws MathUserException if f throws one.\n+     */\n+    private double eval(UnivariateRealFunction f, double x) throws MathUserException {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n \n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealPointValuePair doOptimize() {\n+    protected UnivariateRealPointValuePair doOptimize() throws MathUserException {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final double lo = getMin();\n         final double mid = getStartValue();\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n-                                                 final double min, final double max) {\n+                                                 final double min, final double max)\n+        throws MathUserException {\n         return optimize(f, goal, min, max, min + 0.5 * (max - min));\n     }\n \n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n                                                  final double min, final double max,\n-                                                 final double startValue) {\n+                                                 final double startValue)\n+        throws MathUserException {\n         MathUserException lastException = null;\n         optima = new UnivariateRealPointValuePair[starts];\n         totalEvaluations = 0;\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform(UnivariateRealFunction f,\n                               double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         return fct(data);\n     }\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform2(UnivariateRealFunction f,\n                                double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         double scaling_coefficient = FastMath.sqrt(2.0 / (n-1));\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n+     * @throws MathUserException if function cannot be evaluated at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] inversetransform(UnivariateRealFunction f,\n                                      double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         double scaling_coefficient = 2.0 / (n - 1);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n+     * @throws MathUserException if function cannot be evaluated at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] inversetransform2(UnivariateRealFunction f,\n                                       double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         return transform2(f, min, max, n);\n     }\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] transform(UnivariateRealFunction f,\n                                double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n         double data[] = sample(f, min, max, n);\n         return fft(data, false);\n     }\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] transform2(UnivariateRealFunction f,\n                                 double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n         double scaling_coefficient = 1.0 / FastMath.sqrt(n);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] inversetransform(UnivariateRealFunction f,\n                                       double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n         double scaling_coefficient = 1.0 / n;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] inversetransform2(UnivariateRealFunction f,\n                                        double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n         double scaling_coefficient = 1.0 / FastMath.sqrt(n);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the samples array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public static double[] sample(UnivariateRealFunction f,\n-                                  double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+     * @throws MathUserException if function cannot be evaluated at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public static double[] sample(UnivariateRealFunction f, double min, double max, int n)\n+        throws MathUserException, IllegalArgumentException {\n \n         if (n <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n     /** {@inheritDoc} */\n     public double[] transform(UnivariateRealFunction f,\n                               double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n         return fht(FastFourierTransformer.sample(f, min, max, n));\n     }\n \n     /** {@inheritDoc} */\n     public double[] inversetransform(UnivariateRealFunction f,\n                                      double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n         final double[] unscaled =\n             fht(FastFourierTransformer.sample(f, min, max, n));\n         return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform(UnivariateRealFunction f,\n                               double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * @throws MathUserException if function cannot be evaluated\n      * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform2(\n         UnivariateRealFunction f, double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n+     * @throws MathUserException if function cannot be evaluated at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n+     * @throws MathUserException if function cannot be evaluated at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] inversetransform2(UnivariateRealFunction f, double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        throws MathUserException, IllegalArgumentException {\n \n         return transform2(f, min, max, n);\n     }\n--- a/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n+     * @throws MathUserException if function cannot be evaluated at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     double[] transform(UnivariateRealFunction f, double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException;\n+        throws MathUserException, IllegalArgumentException;\n \n     /**\n      * Inversely transform the given real data set.\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws FunctionEvaluationException if function cannot be evaluated\n-     * at some point\n+     * @throws MathUserException if function cannot be evaluated at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n-        throws FunctionEvaluationException, IllegalArgumentException;\n+        throws MathUserException, IllegalArgumentException;\n \n }\n--- a/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n public class BinaryFunctionTest {\n \n     @Test\n-    public void testAdd() throws FunctionEvaluationException {\n+    public void testAdd() throws MathUserException {\n         Assert.assertEquals(5.0, BinaryFunction.ADD.value(2, 3), 1.0e-15);\n         Assert.assertEquals(0.0, BinaryFunction.ADD.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n-    public void testSubtract() throws FunctionEvaluationException {\n+    public void testSubtract() throws MathUserException {\n         Assert.assertEquals(-1.0, BinaryFunction.SUBTRACT.value(2, 3), 1.0e-15);\n         Assert.assertEquals(-2.0, BinaryFunction.SUBTRACT.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n-    public void testMultiply() throws FunctionEvaluationException {\n+    public void testMultiply() throws MathUserException {\n         Assert.assertEquals(6.0, BinaryFunction.MULTIPLY.value(2, 3), 1.0e-15);\n         Assert.assertEquals(-1.0, BinaryFunction.MULTIPLY.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n-    public void testDivide() throws FunctionEvaluationException {\n+    public void testDivide() throws MathUserException {\n         Assert.assertEquals(1.5, BinaryFunction.DIVIDE.value(3, 2), 1.0e-15);\n         Assert.assertEquals(-1.0, BinaryFunction.DIVIDE.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n-    public void testPow() throws FunctionEvaluationException {\n+    public void testPow() throws MathUserException {\n         Assert.assertEquals(9.0, BinaryFunction.POW.value(3, 2), 1.0e-15);\n         Assert.assertEquals(-1.0, BinaryFunction.POW.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n-    public void testAtan2() throws FunctionEvaluationException {\n+    public void testAtan2() throws MathUserException {\n         Assert.assertEquals(FastMath.PI / 4, BinaryFunction.ATAN2.value(1, 1), 1.0e-15);\n         Assert.assertEquals(-FastMath.PI / 4, BinaryFunction.ATAN2.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n-    public void testFix1st() throws FunctionEvaluationException {\n+    public void testFix1st() throws MathUserException {\n         ComposableFunction f = BinaryFunction.POW.fix1stArgument(2);\n         for (double x = 0.0; x < 1.0; x += 0.01) {\n             Assert.assertEquals(FastMath.pow(2.0, x), f.value(x), 1.0e-15);\n     }\n \n     @Test\n-    public void testFix2nd() throws FunctionEvaluationException {\n+    public void testFix2nd() throws MathUserException {\n         ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);\n         for (double y = 0.0; y < 1.0; y += 0.01) {\n             Assert.assertEquals(y * y, f.value(y), 1.0e-15);\n--- a/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n public class ComposableFunctionTest {\n \n     @Test\n-    public void testZero() throws FunctionEvaluationException {\n+    public void testZero() throws MathUserException {\n         Assert.assertEquals(0.0, ComposableFunction.ZERO.value(1), 1.0e-15);\n         Assert.assertEquals(0.0, ComposableFunction.ZERO.value(2), 1.0e-15);\n     }\n \n     @Test\n-    public void testOne() throws FunctionEvaluationException {\n+    public void testOne() throws MathUserException {\n         Assert.assertEquals(1.0, ComposableFunction.ONE.value(1), 1.0e-15);\n         Assert.assertEquals(1.0, ComposableFunction.ONE.value(2), 1.0e-15);\n     }\n \n     @Test\n-    public void testIdentity() throws FunctionEvaluationException {\n+    public void testIdentity() throws MathUserException {\n         Assert.assertEquals(1.0, ComposableFunction.IDENTITY.value(1), 1.0e-15);\n         Assert.assertEquals(2.0, ComposableFunction.IDENTITY.value(2), 1.0e-15);\n     }\n \n     @Test\n-    public void testRint() throws FunctionEvaluationException {\n+    public void testRint() throws MathUserException {\n         Assert.assertEquals(1.0, ComposableFunction.RINT.value(0.9), 1.0e-15);\n         Assert.assertEquals(2.0, ComposableFunction.RINT.value(2.2), 1.0e-15);\n     }\n \n     @Test\n-    public void testSignum() throws FunctionEvaluationException {\n+    public void testSignum() throws MathUserException {\n         Assert.assertEquals(1.0, ComposableFunction.SIGNUM.value(12.3), 1.0e-15);\n         Assert.assertEquals(-1.0, ComposableFunction.SIGNUM.value(-6), 1.0e-15);\n     }\n \n     @Test\n-    public void testComposition() throws FunctionEvaluationException {\n+    public void testComposition() throws MathUserException {\n         ComposableFunction abs    = ComposableFunction.ABS;\n         ComposableFunction acos   = ComposableFunction.ACOS;\n         ComposableFunction asin   = ComposableFunction.ASIN;\n     }\n \n     @Test\n-    public void testCombine() throws FunctionEvaluationException {\n+    public void testCombine() throws MathUserException {\n \n         ComposableFunction f =\n             ComposableFunction.COS.combine(ComposableFunction.ASIN, BinaryFunction.POW);\n     }\n \n     @Test\n-    public void testSimpleCombination() throws FunctionEvaluationException {\n+    public void testSimpleCombination() throws MathUserException {\n \n         ComposableFunction f1 = ComposableFunction.COS.add(3);\n         ComposableFunction f2 = ComposableFunction.COS.add(ComposableFunction.SIN);\n     }\n \n     @Test\n-    public void testCollector() throws FunctionEvaluationException {\n+    public void testCollector() throws MathUserException {\n \n         ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);\n         Assert.assertEquals(30, f.asCollector().value(new double[] { 1, 2, 3, 4 }), 1.0e-15);\n--- a/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n+++ b/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  */\n public class Expm1Function implements DifferentiableUnivariateRealFunction {\n \n-    public double value(double x) throws FunctionEvaluationException {\n-        // FastMath.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n-        return FastMath.exp(x) - 1.0;\n+    public double value(double x) {\n+        return FastMath.expm1(x);\n     }\n \n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) {\n                 return FastMath.exp(x);\n             }\n         };\n--- a/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Wrapper class for counting functions calls.\n         return callsCount;\n     }\n \n-    public double value(double x) throws FunctionEvaluationException {\n+    public double value(double x) throws MathUserException {\n         ++callsCount;\n         return f.value(x);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-\n /**\n  * Auxiliary class for testing solvers.\n  *\n     /* Evaluate quintic.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n      */\n-    public double value(double x) throws FunctionEvaluationException {\n+    public double value(double x) {\n         return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);\n     }\n \n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) {\n                 return (5*x*x-3.75)*x*x+0.25;\n             }\n         };\n--- a/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n     /* Evaluate sinus fuction.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n      */\n-    public double value(double x) throws FunctionEvaluationException {\n+    public double value(double x) {\n         return FastMath.sin(x);\n     }\n \n      */\n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n-            public double value(double x) throws FunctionEvaluationException {\n+            public double value(double x) {\n                 return FastMath.cos(x);\n             }\n         };\n--- a/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Auxiliary class for testing optimizers.\n      * @param point Argument.\n      * @return the value of this function at point {@code x}.\n      */\n-    public double value(double[] point) throws FunctionEvaluationException {\n+    public double value(double[] point) throws MathUserException {\n         double sum = 0;\n         for (int i = 0, max = point.length; i < max; i++) {\n             final double x = point[i];\n      */\n     public MultivariateRealFunction partialDerivative(final int k) {\n         return new MultivariateRealFunction() {\n-            public double value(double[] point) throws FunctionEvaluationException {\n+            public double value(double[] point) throws MathUserException {\n                 return sincDeriv.value(point[k]);\n             }\n         };\n     public MultivariateVectorialFunction gradient() {\n         return new MultivariateVectorialFunction() {\n             public double[] value(double[] point)\n-                throws FunctionEvaluationException {\n+                throws MathUserException {\n                 final int n = point.length;\n                 final double[] r = new double[n];\n                 for (int i = 0; i < n; i++) {\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n import java.util.Random;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n     }\n \n     public void testExactIntegration()\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws ConvergenceException, MathUserException {\n         Random random = new Random(86343623467878363l);\n         for (int n = 2; n < 6; ++n) {\n             LegendreGaussIntegrator integrator =\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n \n     }\n \n-    public void testWalk() {\n+    public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n \n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n     }\n \n-    public void testWalk() {\n+    public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n \n     }\n \n-    public void testWalk() {\n+    public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n \n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n     }\n \n-    public void testWalk() {\n+    public void testWalk() throws MathUserException {\n         int rows    = 150;\n         int columns = 75;\n \n--- a/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n+\n import junit.framework.TestCase;\n \n public class QRDecompositionImplTest extends TestCase {\n         super(name);\n     }\n \n-    /** test dimensions */\n-    public void testDimensions() {\n+    /** test dimensions \n+     * @throws MathUserException */\n+    public void testDimensions() throws MathUserException {\n         checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n         checkDimension(MatrixUtils.createRealMatrix(testData4x3));\n         assertEquals(columns, qr.getR().getColumnDimension());\n     }\n \n-    /** test A = QR */\n-    public void testAEqualQR() {\n+    /** test A = QR \n+     * @throws MathUserException */\n+    public void testAEqualQR() throws MathUserException {\n         checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n         checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));\n         assertEquals(0, norm, normTolerance);\n     }\n \n-    /** test the orthogonality of Q */\n-    public void testQOrthogonal() {\n+    /** test the orthogonality of Q \n+     * @throws MathUserException */\n+    public void testQOrthogonal() throws MathUserException {\n         checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n         checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));\n     }\n \n     /** test that R is upper triangular */\n-    public void testRUpperTriangular() {\n+    public void testRUpperTriangular() throws MathUserException {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n \n \n     }\n \n-    private void checkUpperTriangular(RealMatrix m) {\n+    private void checkUpperTriangular(RealMatrix m) throws MathUserException {\n         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             @Override\n             public void visit(int row, int column, double value) {\n         });\n     }\n \n-    /** test that H is trapezoidal */\n-    public void testHTrapezoidal() {\n+    /** test that H is trapezoidal \n+     * @throws MathUserException */\n+    public void testHTrapezoidal() throws MathUserException {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n \n \n     }\n \n-    private void checkTrapezoidal(RealMatrix m) {\n+    private void checkTrapezoidal(RealMatrix m) throws MathUserException {\n         m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             @Override\n             public void visit(int row, int column, double value) {\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.SingularMatrixException;\n import junit.framework.TestCase;\n \n \n     }\n \n-    public void testOverdetermined() {\n+    public void testOverdetermined() throws MathUserException {\n         final Random r    = new Random(5559252868205245l);\n         int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n \n     }\n \n-    public void testUnderdetermined() {\n+    public void testUnderdetermined() throws MathUserException {\n         final Random r    = new Random(42185006424567123l);\n         int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n import junit.framework.*;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n   }\n \n   public void testBoundaries()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n   }\n \n   public void testRandomAccess()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     ContinuousOutputModel cm = new ContinuousOutputModel();\n     integ.addStepHandler(cm);\n   }\n \n   public void testModelsMerging()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n       // theoretical solution: y[0] = cos(t), y[1] = sin(t)\n       FirstOrderDifferentialEquations problem =\n           new FirstOrderDifferentialEquations() {\n               private static final long serialVersionUID = 2472449657345878299L;\n               public void computeDerivatives(double t, double[] y, double[] dot)\n-                  throws DerivativeException {\n+                  throws MathUserException {\n                   dot[0] = -y[1];\n                   dot[1] =  y[0];\n               }\n   }\n \n   public void testErrorConditions()\n-    throws DerivativeException {\n+    throws MathUserException {\n \n       ContinuousOutputModel cm = new ContinuousOutputModel();\n       cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);\n \n   private boolean checkAppendError(ContinuousOutputModel cm,\n                                    double t0, double[] y0, double t1)\n-  throws DerivativeException {\n+  throws MathUserException {\n       try {\n           ContinuousOutputModel otherCm = new ContinuousOutputModel();\n           otherCm.handleStep(buildInterpolator(t0, y0, t1), true);\n--- a/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n \n package org.apache.commons.math.ode;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderConverter;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n   }\n \n   public void testDecreasingSteps()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     double previousError = Double.NaN;\n     for (int i = 0; i < 10; ++i) {\n   }\n \n   public void testSmallStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n                    - FastMath.sin(4.0);\n     assertTrue(FastMath.abs(error) < 1.0e-10);\n   }\n \n   public void testBigStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n                    - FastMath.sin(4.0);\n     assertTrue(FastMath.abs(error) > 0.1);\n   private double integrateWithSpecifiedStep(double omega,\n                                             double t0, double t,\n                                             double step)\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     double[] y0 = new double[2];\n     y0[0] = FastMath.sin(omega * t0);\n     y0[1] = omega * FastMath.cos(omega * t0);\n--- a/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n \n package org.apache.commons.math.ode;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ODEIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n   public void handleStep(StepInterpolator interpolator,\n                          boolean isLast)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     double start = integrator.getCurrentStepStart();\n     if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {\n--- a/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n import junit.framework.Assert;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.junit.Test;\n     // JIRA: MATH-322\n     @Test\n     public void closeEvents()\n-        throws EventException, ConvergenceException, DerivativeException {\n+        throws EventException, ConvergenceException, MathUserException {\n \n         final double r1  = 90.0;\n         final double r2  = 135.0;\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n \n package org.apache.commons.math.ode.jacobians;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n \n     @Test\n     public void testLowAccuracyExternalDifferentiation()\n-        throws IntegratorException, DerivativeException {\n+        throws IntegratorException, MathUserException {\n         // this test does not really test FirstOrderIntegratorWithJacobians,\n         // it only shows that WITHOUT this class, attempting to recover\n         // the jacobians from external differentiation on simple integration\n \n     @Test\n     public void testHighAccuracyExternalDifferentiation()\n-        throws IntegratorException, DerivativeException {\n+        throws IntegratorException, MathUserException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double hP = 1.0e-12;\n \n     @Test\n     public void testInternalDifferentiation()\n-        throws IntegratorException, DerivativeException {\n+        throws IntegratorException, MathUserException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         double hP = 1.0e-12;\n \n     @Test\n     public void testAnalyticalDifferentiation()\n-        throws IntegratorException, DerivativeException {\n+        throws IntegratorException, MathUserException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n     }\n \n     @Test\n-    public void testFinalResult() throws IntegratorException, DerivativeException {\n+    public void testFinalResult() throws IntegratorException, MathUserException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n     }\n \n     @Test\n-    public void testStepHandlerResult() throws IntegratorException, DerivativeException {\n+    public void testStepHandlerResult() throws IntegratorException, MathUserException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n             }\n \n             public void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast)\n-                throws DerivativeException {\n+                throws MathUserException {\n                 double     t     = interpolator.getCurrentTime();\n                 double[]   y     = interpolator.getInterpolatedY();\n                 double[][] dydy0 = interpolator.getInterpolatedDyDy0();\n     }\n \n     @Test\n-    public void testEventHandler() throws IntegratorException, DerivativeException {\n+    public void testEventHandler() throws IntegratorException, MathUserException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n public class AdamsBashforthIntegratorTest {\n \n     @Test(expected=IntegratorException.class)\n-    public void dimensionCheck() throws DerivativeException, IntegratorException {\n+    public void dimensionCheck() throws MathUserException, IntegratorException {\n         TestProblem1 pb = new TestProblem1();\n         FirstOrderIntegrator integ =\n             new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n     }\n \n     @Test(expected=IntegratorException.class)\n-    public void testMinStep() throws DerivativeException, IntegratorException {\n+    public void testMinStep() throws MathUserException, IntegratorException {\n \n           TestProblem1 pb = new TestProblem1();\n           double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n \n     @Test\n     public void testIncreasingTolerance()\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n \n         int previousCalls = Integer.MAX_VALUE;\n         for (int i = -12; i < -5; ++i) {\n \n     }\n \n-    @Test(expected = DerivativeException.class)\n-    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {\n+    @Test(expected = MathUserException.class)\n+    public void exceedMaxEvaluations() throws MathUserException, IntegratorException {\n \n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n     }\n \n     @Test\n-    public void backward() throws DerivativeException, IntegratorException {\n+    public void backward() throws MathUserException, IntegratorException {\n \n         TestProblem5 pb = new TestProblem5();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n     }\n \n     @Test\n-    public void polynomial() throws DerivativeException, IntegratorException {\n+    public void polynomial() throws MathUserException, IntegratorException {\n         TestProblem6 pb = new TestProblem6();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n public class AdamsMoultonIntegratorTest {\n \n     @Test(expected=IntegratorException.class)\n-    public void dimensionCheck() throws DerivativeException, IntegratorException {\n+    public void dimensionCheck() throws MathUserException, IntegratorException {\n         TestProblem1 pb = new TestProblem1();\n         FirstOrderIntegrator integ =\n             new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);\n     }\n \n     @Test(expected=IntegratorException.class)\n-    public void testMinStep() throws DerivativeException, IntegratorException {\n+    public void testMinStep() throws MathUserException, IntegratorException {\n \n           TestProblem1 pb = new TestProblem1();\n           double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n \n     @Test\n     public void testIncreasingTolerance()\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n \n         int previousCalls = Integer.MAX_VALUE;\n         for (int i = -12; i < -2; ++i) {\n \n     }\n \n-    @Test(expected = DerivativeException.class)\n-    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {\n+    @Test(expected = MathUserException.class)\n+    public void exceedMaxEvaluations() throws MathUserException, IntegratorException {\n \n         TestProblem1 pb  = new TestProblem1();\n         double range = pb.getFinalTime() - pb.getInitialTime();\n     }\n \n     @Test\n-    public void backward() throws DerivativeException, IntegratorException {\n+    public void backward() throws MathUserException, IntegratorException {\n \n         TestProblem5 pb = new TestProblem5();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n     }\n \n     @Test\n-    public void polynomial() throws DerivativeException, IntegratorException {\n+    public void polynomial() throws MathUserException, IntegratorException {\n         TestProblem6 pb = new TestProblem6();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n \n import junit.framework.*;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n     super(name);\n   }\n \n-  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n+  public void testMissedEndEvent() throws IntegratorException, MathUserException {\n       final double   t0     = 1878250320.0000029;\n       final double   tEvent = 1878250379.9999986;\n       final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n                                                         0.0, new double[pb.getDimension()+10],\n                                                         1.0, new double[pb.getDimension()]);\n         fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n                                                           0.0, new double[pb.getDimension()],\n                                                           1.0, new double[pb.getDimension()+10]);\n           fail(\"an exception should have been thrown\");\n-      } catch(DerivativeException de) {\n+      } catch(MathUserException de) {\n         fail(\"wrong exception caught\");\n       } catch(IntegratorException ie) {\n       }\n                                                         0.0, new double[pb.getDimension()],\n                                                         0.0, new double[pb.getDimension()]);\n         fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testDecreasingSteps()\n-    throws DerivativeException, IntegratorException  {\n+    throws MathUserException, IntegratorException  {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n   }\n \n   public void testSmallStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testBigStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n   }\n \n   public void testBackward()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem5 pb = new TestProblem5();\n     double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n       maxError = 0;\n     }\n     public void handleStep(StepInterpolator interpolator,\n-                           boolean isLast) throws DerivativeException {\n+                           boolean isLast) throws MathUserException {\n \n       double[] interpolatedY = interpolator.getInterpolatedState ();\n       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n   }\n \n   public void testStepSize()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testSmallLastStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblemAbstract pb = new TestProblem5();\n     double minStep = 1.25;\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n   }\n \n   public void testIncreasingTolerance()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -2; ++i) {\n   }\n \n   public void testEvents()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n   }\n \n   public void testVariableSteps()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n     }\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n       ++nbSteps;\n       for (int a = 1; a < 10; ++a) {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.1);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n \n   @Test\n   public void checkClone()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       TestProblem3 pb = new TestProblem3(0.9);\n       double minStep = 0;\n       double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                                       scalRelativeTolerance);\n       integ.addStepHandler(new StepHandler() {\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-          throws DerivativeException {\n+          throws MathUserException {\n               StepInterpolator cloned = interpolator.copy();\n               double tA = cloned.getPreviousTime();\n               double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n     super(name);\n   }\n \n-  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n+  public void testMissedEndEvent() throws IntegratorException, MathUserException {\n       final double   t0     = 1878250320.0000029;\n       final double   tEvent = 1878250379.9999986;\n       final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n                            0.0, new double[pb.getDimension()],\n                            0.0, new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testIncreasingTolerance()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -2; ++i) {\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n   }\n \n   public void testEvents()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n   }\n \n   public void testVariableSteps()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n   }\n \n   public void testNoDenseOutput()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     TestProblem1 pb1 = new TestProblem1();\n     TestProblem1 pb2 = pb1.copy();\n     double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n   }\n \n   public void testUnstableDerivative()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n     }\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n       ++nbSteps;\n       for (int a = 1; a < 10; ++a) {\n     }\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast)\n-    throws DerivativeException {\n+    throws MathUserException {\n       double prev = interpolator.getPreviousTime();\n       double curr = interpolator.getCurrentTime();\n       interpolator.setInterpolatedTime(0.5*(prev + curr));\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.1);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n \n   @Test\n   public void checklone()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                                       scalRelativeTolerance);\n     integ.addStepHandler(new StepHandler() {\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-        throws DerivativeException {\n+        throws MathUserException {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n \n import junit.framework.*;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n                                           0.0, new double[pb.getDimension()+10],\n                                           1.0, new double[pb.getDimension()+10]);\n         fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testDecreasingSteps()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n   }\n \n   public void testSmallStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testBigStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testStepSize()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new EulerIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n import org.apache.commons.math.ode.TestProblem3;\n public class EulerStepInterpolatorTest {\n \n   @Test\n-  public void noReset() throws DerivativeException {\n+  public void noReset() throws MathUserException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n \n   @Test\n   public void interpolationAtBounds()\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     double   t0 = 0;\n     double[] y0 = {0.0, 1.0, -2.0};\n \n   @Test\n   public void interpolationInside()\n-  throws DerivativeException {\n+  throws MathUserException {\n \n     double[]   y    =   { 1.0, 3.0, -4.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     EulerIntegrator integ = new EulerIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem1 pb = new TestProblem1();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n \n import junit.framework.*;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n                                          0.0, new double[pb.getDimension()+10],\n                                          1.0, new double[pb.getDimension()+10]);\n         fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testDecreasingSteps()\n-    throws DerivativeException, IntegratorException  {\n+    throws MathUserException, IntegratorException  {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n   }\n \n   public void testSmallStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testBigStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n   }\n \n   public void testUnstableDerivative()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ = new GillIntegrator(0.3);\n     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n       maxError = 0;\n     }\n     public void handleStep(StepInterpolator interpolator,\n-                           boolean isLast) throws DerivativeException {\n+                           boolean isLast) throws MathUserException {\n \n       double[] interpolatedY = interpolator.getInterpolatedState();\n       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n   }\n \n   public void testStepSize()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new GillIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n import java.io.ObjectInputStream;\n import java.io.IOException;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n \n   @Test\n   public void testDerivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     GillIntegrator integ = new GillIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n                            0.0, new double[pb.getDimension()],\n                            0.0, new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n   }\n \n   public void testIncreasingTolerance()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -4; ++i) {\n   }\n \n   public void testIntegratorControls()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n \n     TestProblem3 pb = new TestProblem3(0.999);\n     GraggBulirschStoerIntegrator integ =\n   }\n \n   private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n       integrator.addStepHandler(handler);\n       integrator.integrate(pb,\n   }\n \n   public void testEvents()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb = new TestProblem3(0.9);\n     double minStep        = 0;\n   }\n \n   public void testVariableSteps()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb = new TestProblem3(0.9);\n     double minStep        = 0;\n   }\n \n   public void testUnstableDerivative()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n     }\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast)\n-    throws DerivativeException {\n+    throws MathUserException {\n \n       ++nbSteps;\n       for (int a = 1; a < 100; ++a) {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep   = 0;\n     double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb  = new TestProblem3(0.9);\n \n   @Test\n   public void checklone()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                                           scalRelativeTolerance);\n     integ.addStepHandler(new StepHandler() {\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-        throws DerivativeException {\n+        throws MathUserException {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n           new FirstOrderDifferentialEquations() {\n             private static final long serialVersionUID = -1157081786301178032L;\n             public void computeDerivatives(double t, double[] y, double[] dot)\n-            throws DerivativeException {\n+            throws MathUserException {\n             if (t < -0.5) {\n-                throw new DerivativeException(LocalizedFormats.SIMPLE_MESSAGE, \"oops\");\n+                throw new MathUserException(LocalizedFormats.SIMPLE_MESSAGE, \"oops\");\n             } else {\n-                throw new DerivativeException(new RuntimeException(\"oops\"));\n+                throw new MathUserException(new RuntimeException(\"oops\"));\n            }\n           }\n           public int getDimension() {\n       try  {\n         integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);\n         fail(\"an exception should have been thrown\");\n-      } catch(DerivativeException de) {\n+      } catch(MathUserException de) {\n         // expected behavior\n       }\n \n       try  {\n         integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);\n         fail(\"an exception should have been thrown\");\n-      } catch(DerivativeException de) {\n+      } catch(MathUserException de) {\n         // expected behavior\n       }\n \n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testIncreasingTolerance()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     int previousCalls = Integer.MAX_VALUE;\n     for (int i = -12; i < -2; ++i) {\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double minStep = 0;\n   }\n \n   public void testEvents()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem4 pb = new TestProblem4();\n     double minStep = 0;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double minStep = 0;\n       maxError = 0;\n     }\n     public void handleStep(StepInterpolator interpolator,\n-                           boolean isLast) throws DerivativeException {\n+                           boolean isLast) throws MathUserException {\n \n       ++nbSteps;\n       double[] interpolatedY = interpolator.getInterpolatedState();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.1);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n \n   @Test\n   public void checkClone()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double minStep = 0;\n     double maxStep = pb.getFinalTime() - pb.getInitialTime();\n                                                               scalRelativeTolerance);\n     integ.addStepHandler(new StepHandler() {\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-        throws DerivativeException {\n+        throws MathUserException {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n \n import junit.framework.*;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n                                              0.0, new double[pb.getDimension()+10],\n                                              1.0, new double[pb.getDimension()+10]);\n         fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testDecreasingSteps()\n-    throws DerivativeException, IntegratorException  {\n+    throws MathUserException, IntegratorException  {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n   }\n \n   public void testSmallStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testBigStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb  = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testStepSize()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new MidpointIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n import org.apache.commons.math.ode.TestProblem3;\n \n   @Test\n   public void testDerivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     MidpointIntegrator integ = new MidpointIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem1 pb = new TestProblem1();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n \n import junit.framework.*;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n                                                   0.0, new double[pb.getDimension()+10],\n                                                   1.0, new double[pb.getDimension()+10]);\n         fail(\"an exception should have been thrown\");\n-    } catch(DerivativeException de) {\n+    } catch(MathUserException de) {\n       fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n   public void testDecreasingSteps()\n-    throws DerivativeException, IntegratorException  {\n+    throws MathUserException, IntegratorException  {\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n   }\n \n  public void testSmallStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testBigStep()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n   }\n \n   public void testBackward()\n-      throws DerivativeException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n       double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n   }\n \n   public void testKepler()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n \n     final TestProblem3 pb  = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n     }\n \n     public void handleStep(StepInterpolator interpolator,\n-                           boolean isLast) throws DerivativeException {\n+                           boolean isLast) throws MathUserException {\n \n       double[] interpolatedY = interpolator.getInterpolatedState();\n       double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n   }\n \n   public void testStepSize()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n       integ.addStepHandler(new StepHandler() {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   @Test\n   public void derivativesConsistency()\n-  throws DerivativeException, IntegratorException {\n+  throws MathUserException, IntegratorException {\n     TestProblem3 pb = new TestProblem3();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n \n   @Test\n   public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n            IOException, ClassNotFoundException {\n \n     TestProblem3 pb = new TestProblem3(0.9);\n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n import java.io.ObjectInputStream;\n import java.io.IOException;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.util.FastMath;\n public class DummyStepInterpolatorTest {\n \n   @Test\n-  public void testNoReset() throws DerivativeException {\n+  public void testNoReset() throws MathUserException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);\n \n   @Test\n   public void testFixedState()\n-    throws DerivativeException {\n+    throws MathUserException {\n \n     double[]   y    =   { 1.0, 3.0, -4.0 };\n     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);\n \n   @Test\n   public void testSerialization()\n-  throws DerivativeException, IOException, ClassNotFoundException {\n+  throws MathUserException, IOException, ClassNotFoundException {\n \n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);\n           super(y, new double[y.length], forward);\n       }\n       @Override\n-      protected void doFinalize()\n-      throws DerivativeException {\n-          throw new DerivativeException(null);\n+      protected void doFinalize() throws MathUserException {\n+          throw new MathUserException((Localizable) null, LocalizedFormats.SIMPLE_MESSAGE, \"\");\n       }\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n import java.io.ObjectOutputStream;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.ContinuousOutputModel;\n-import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n import org.apache.commons.math.ode.TestProblem3;\n \n     @Test\n     public void derivativesConsistency()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n         TestProblem3 pb = new TestProblem3();\n         AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);\n         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 7e-10);\n \n     @Test\n     public void serialization()\n-    throws DerivativeException, IntegratorException,\n+    throws MathUserException, IntegratorException,\n     IOException, ClassNotFoundException {\n \n         TestProblem1 pb = new TestProblem1();\n--- a/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n \n import static org.junit.Assert.assertEquals;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblemAbstract;\n     public static void checkDerivativesConsistency(final FirstOrderIntegrator integrator,\n                                                    final TestProblemAbstract problem,\n                                                    final double threshold)\n-        throws DerivativeException, IntegratorException {\n+        throws MathUserException, IntegratorException {\n         integrator.addStepHandler(new StepHandler() {\n \n             public boolean requiresDenseOutput() {\n             }\n \n             public void handleStep(StepInterpolator interpolator, boolean isLast)\n-                throws DerivativeException {\n+                throws MathUserException {\n \n                 final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());\n                 final double t = interpolator.getCurrentTime() - 300 * h;\n--- a/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n \n package org.apache.commons.math.ode.sampling;\n \n-import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem3;\n   }\n \n   public void testBoundaries()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     double range = pb.getFinalTime() - pb.getInitialTime();\n     setLastSeen(false);\n     integ.addStepHandler(new StepNormalizer(range / 10.0,\n   }\n \n   public void testBeforeEnd()\n-    throws DerivativeException, IntegratorException {\n+    throws MathUserException, IntegratorException {\n     final double range = pb.getFinalTime() - pb.getInitialTime();\n     setLastSeen(false);\n     integ.addStepHandler(new StepNormalizer(range / 10.5,\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n import java.awt.geom.Point2D;\n import java.util.ArrayList;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n import org.apache.commons.math.random.GaussianRandomGenerator;\n public class MultiStartDifferentiableMultivariateRealOptimizerTest {\n \n     @Test\n-    public void testCircleFitting() throws FunctionEvaluationException {\n+    public void testCircleFitting() throws MathUserException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         }\n \n         public double value(double[] variables)\n-        throws IllegalArgumentException, FunctionEvaluationException {\n+        throws IllegalArgumentException, MathUserException {\n \n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n             double radius = getRadius(center);\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {\n \n     @Test\n-    public void testTrivial() throws FunctionEvaluationException {\n+    public void testTrivial() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n         assertEquals(100, optimizer.getMaxEvaluations());\n     }\n \n-    @Test(expected = ConvergenceException.class)\n-    public void testNoOptimum() throws FunctionEvaluationException {\n+    @Test(expected = MathUserException.class)\n+    public void testNoOptimum() throws MathUserException {\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n                 public MultivariateMatrixFunction jacobian() {\n                     return null;\n                 }\n-                public double[] value(double[] point) throws FunctionEvaluationException {\n-                    throw new FunctionEvaluationException(point[0]);\n+                public double[] value(double[] point) throws MathUserException {\n+                    throw new MathUserException();\n                 }\n             }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });\n     }\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.direct.SimplexOptimizer;\n import org.apache.commons.math.optimization.direct.NelderMeadSimplex;\n import org.apache.commons.math.random.GaussianRandomGenerator;\n \n public class MultiStartMultivariateRealOptimizerTest {\n     @Test\n-    public void testRosenbrock() {\n+    public void testRosenbrock() throws MathUserException {\n         Rosenbrock rosenbrock = new Rosenbrock();\n         SimplexOptimizer underlying = new SimplexOptimizer();\n         NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {\n--- a/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n  */\n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.SumSincFunction;\n     @Test\n     public void testQuadratic() throws MathException {\n         final MultivariateRealFunction func = new MultivariateRealFunction() {\n-                public double value(double[] x)\n-                    throws FunctionEvaluationException {\n+                public double value(double[] x) {\n                     final double a = x[0] - 1;\n                     final double b = x[1] - 1;\n                     return a * a + b * b + 1;\n     @Test\n     public void testMaximizeQuadratic() throws MathException {\n         final MultivariateRealFunction func = new MultivariateRealFunction() {\n-                public double value(double[] x)\n-                    throws FunctionEvaluationException {\n+                public double value(double[] x) {\n                     final double a = x[0] - 1;\n                     final double b = x[1] - 1;\n                     return -a * a - b * b + 1;\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n public class SimplexOptimizerMultiDirectionalTest {\n     @Test\n-    public void testMinimizeMaximize() throws FunctionEvaluationException {\n+    public void testMinimizeMaximize() throws MathUserException {\n         // the following function has 4 local extrema:\n         final double xM        = -3.841947088256863675365;\n         final double yM        = -1.391745200270734924416;\n         final double valueXpYp = -valueXpYm;                // global maximum\n         MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -7039124064449091152L;\n-                public double value(double[] variables) throws FunctionEvaluationException {\n+                public double value(double[] variables) throws MathUserException {\n                     final double x = variables[0];\n                     final double y = variables[1];\n                     return ((x == 0) || (y == 0)) ? 0 :\n     }\n \n     @Test\n-    public void testRosenbrock() throws FunctionEvaluationException {\n+    public void testRosenbrock() throws MathUserException {\n         MultivariateRealFunction rosenbrock =\n             new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -9044950469615237490L;\n-                public double value(double[] x) throws FunctionEvaluationException {\n+                public double value(double[] x) throws MathUserException {\n                     ++count;\n                     double a = x[1] - x[0] * x[0];\n                     double b = 1.0 - x[0];\n     }\n \n     @Test\n-    public void testPowell() throws FunctionEvaluationException {\n+    public void testPowell() throws MathUserException {\n         MultivariateRealFunction powell =\n             new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -832162886102041840L;\n-                public double value(double[] x) throws FunctionEvaluationException {\n+                public double value(double[] x) throws MathUserException {\n                     ++count;\n                     double a = x[0] + 10 * x[1];\n                     double b = x[2] - x[3];\n     }\n \n     @Test\n-    public void testMath283() throws FunctionEvaluationException {\n+    public void testMath283() throws MathUserException {\n         // fails because MultiDirectional.iterateSimplex is looping forever\n         // the while(true) should be replaced with a convergence check\n         SimplexOptimizer optimizer = new SimplexOptimizer();\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n public class SimplexOptimizerNelderMeadTest {\n     @Test\n     public void testMinimizeMaximize()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         // the following function has 4 local extrema:\n         final double xM        = -3.841947088256863675365;\n         final double valueXpYp = -valueXpYm;                // global maximum\n         MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -7039124064449091152L;\n-                public double value(double[] variables) throws FunctionEvaluationException {\n+                public double value(double[] variables) {\n                     final double x = variables[0];\n                     final double y = variables[1];\n                     return (x == 0 || y == 0) ? 0 :\n \n     @Test\n     public void testRosenbrock()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         Rosenbrock rosenbrock = new Rosenbrock();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n \n     @Test\n     public void testPowell()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         Powell powell = new Powell();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n \n     @Test\n     public void testLeastSquares1()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         final RealMatrix factors =\n             new Array2DRowRealMatrix(new double[][] {\n \n     @Test\n     public void testLeastSquares2()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         final RealMatrix factors =\n             new Array2DRowRealMatrix(new double[][] {\n \n     @Test\n     public void testLeastSquares3()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         final RealMatrix factors =\n             new Array2DRowRealMatrix(new double[][] {\n     }\n \n     @Test(expected = TooManyEvaluationsException.class)\n-    public void testMaxIterations() throws FunctionEvaluationException {\n+    public void testMaxIterations() throws MathUserException {\n         Powell powell = new Powell();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n         optimizer.setMaxEvaluations(20);\n             count = 0;\n         }\n \n-        public double value(double[] x) throws FunctionEvaluationException {\n+        public double value(double[] x) throws MathUserException {\n             ++count;\n             double a = x[1] - x[0] * x[0];\n             double b = 1.0 - x[0];\n             count = 0;\n         }\n \n-        public double value(double[] x) throws FunctionEvaluationException {\n+        public double value(double[] x) {\n             ++count;\n             double a = x[0] + 10 * x[1];\n             double b = x[2] - x[3];\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n \n     @Test\n     public void testMath303()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter fitter = new CurveFitter(optimizer);\n \n     @Test\n     public void testMath304()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter fitter = new CurveFitter(optimizer);\n \n     @Test\n     public void testMath372()\n-    throws FunctionEvaluationException {\n+    throws MathUserException {\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter curveFitter = new CurveFitter(optimizer);\n \n--- a/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n \n import static org.junit.Assert.assertEquals;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.\n        LevenbergMarquardtOptimizer;\n      * Basic.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit01()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET1, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Zero points is not enough observed points.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test(expected=IllegalArgumentException.class)\n     public void testFit02()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         fitter.fit();\n     }\n      * Two points is not enough observed points.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test(expected=IllegalArgumentException.class)\n     public void testFit03()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(new double[][] {\n             {4.0254623,  531026.0},\n      * Poor data: right of peak not symmetric with left of peak.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit04()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET2, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Poor data: long tails.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit05()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET3, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Poor data: right of peak is missing.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit06()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET4, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Basic with smaller dataset.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit07()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET5, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n      * Using not-so-good initial parameters.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit01()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToCurveFitter(DATASET1, fitter);\n         double[] parameters = fitter.fit(new ParametricGaussianFunction(),\n      * Using eye-balled guesses for initial parameters.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit02()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws OptimizationException, MathUserException {\n         CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToCurveFitter(DATASET1, fitter);\n         double[] parameters = fitter.fit(new ParametricGaussianFunction(),\n     /**\n      * The parameters array is null.\n      *\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test(expected=IllegalArgumentException.class)\n-    public void testValue01() throws FunctionEvaluationException {\n+    public void testValue01() throws MathUserException {\n         ParametricGaussianFunction f = new ParametricGaussianFunction();\n         f.value(0.0, null);\n     }\n     /**\n      * The parameters array length is not 4.\n      *\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test(expected=IllegalArgumentException.class)\n-    public void testValue02() throws FunctionEvaluationException {\n+    public void testValue02() throws MathUserException {\n         ParametricGaussianFunction f = new ParametricGaussianFunction();\n         f.value(0.0, new double[] {0.0, 1.0});\n     }\n     /**\n      * The parameters d is 0.\n      *\n-     * @throws FunctionEvaluationException in the event of a test case error\n+     * @throws MathUserException in the event of a test case error\n      */\n     @Test(expected=ZeroException.class)\n-    public void testValue03() throws FunctionEvaluationException {\n+    public void testValue03() throws MathUserException {\n         ParametricGaussianFunction f = new ParametricGaussianFunction();\n         f.value(0.0, new double[] {0.0, 1.0, 1.0, 0.0});\n     }\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.SingularMatrixException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n         super(name);\n     }\n \n-    public void testTrivial() throws FunctionEvaluationException {\n+    public void testTrivial() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testColumnsPermutation() throws FunctionEvaluationException {\n+    public void testColumnsPermutation() throws MathUserException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n \n     }\n \n-    public void testNoDependency() throws FunctionEvaluationException {\n+    public void testNoDependency() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws FunctionEvaluationException {\n+    public void testOneSet() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n \n     }\n \n-    public void testTwoSets() throws FunctionEvaluationException {\n+    public void testTwoSets() throws MathUserException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n         }\n     }\n \n-    public void testIllConditioned() throws FunctionEvaluationException {\n+    public void testIllConditioned() throws MathUserException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n         }\n     }\n \n-    public void testRedundantEquations() throws FunctionEvaluationException {\n+    public void testRedundantEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentEquations() throws FunctionEvaluationException {\n+    public void testInconsistentEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentSizes() throws FunctionEvaluationException {\n+    public void testInconsistentSizes() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n         }\n     }\n \n-    public void testCircleFitting() throws FunctionEvaluationException {\n+    public void testCircleFitting() throws MathUserException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         assertEquals(48.135167894714,   center.y, 1.0e-10);\n     }\n \n-    public void testCircleFittingBadInit() throws FunctionEvaluationException {\n+    public void testCircleFittingBadInit() throws MathUserException {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.SingularMatrixException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n-import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n-import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.util.FastMath;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n         super(name);\n     }\n \n-    public void testTrivial() {\n+    public void testTrivial() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testQRColumnsPermutation() {\n+    public void testQRColumnsPermutation() throws MathUserException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n         assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n     }\n \n-    public void testNoDependency() {\n+    public void testNoDependency() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() {\n+    public void testOneSet() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n         assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n     }\n \n-    public void testTwoSets() {\n+    public void testTwoSets() throws MathUserException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n         assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n     }\n \n-    public void testNonInvertible() {\n+    public void testNonInvertible() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n         }\n     }\n \n-    public void testIllConditioned() {\n+    public void testIllConditioned() throws MathUserException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n         assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n     }\n \n-    public void testMoreEstimatedParametersSimple() {\n+    public void testMoreEstimatedParametersSimple() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n     }\n \n-    public void testMoreEstimatedParametersUnsorted() {\n+    public void testMoreEstimatedParametersUnsorted() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n         assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n     }\n \n-    public void testRedundantEquations() {\n+    public void testRedundantEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n     }\n \n-    public void testInconsistentEquations() {\n+    public void testInconsistentEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         assertTrue(optimizer.getRMS() > 0.1);\n     }\n \n-    public void testInconsistentSizes() {\n+    public void testInconsistentSizes() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         }\n     }\n \n-    public void testControlParameters() {\n+    public void testControlParameters() throws MathUserException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n     private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,\n                                double initialStepBoundFactor, int maxCostEval,\n                                double costRelativeTolerance, double parRelativeTolerance,\n-                               double orthoTolerance, boolean shouldFail) {\n+                               double orthoTolerance, boolean shouldFail) throws MathUserException {\n         try {\n             LevenbergMarquardtOptimizer optimizer\n                 = new LevenbergMarquardtOptimizer(initialStepBoundFactor,\n         }\n     }\n \n-    public void testCircleFitting() {\n+    public void testCircleFitting() throws MathUserException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         assertEquals(0.004, errors[1], 0.001);\n     }\n \n-    public void testCircleFittingBadInit() {\n+    public void testCircleFittingBadInit() throws MathUserException {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n         assertEquals( 0.2075001, center.y,      1.0e-6);\n     }\n \n-    public void testMath199() {\n+    public void testMath199() throws MathUserException {\n         try {\n             QuadraticProblem problem = new QuadraticProblem();\n             problem.addPoint (0, -3.182591015485607);\n             return jacobian;\n         }\n \n-        public double[] value(double[] variables)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n+        public double[] value(double[] variables) {\n \n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n             double radius = getRadius(center);\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n           function.checkTheoreticalMinParams(optimum);\n       } catch (TooManyEvaluationsException e) {\n           assertTrue(exceptionExpected);\n-      } catch (FunctionEvaluationException fe) {\n+      } catch (MathUserException fe) {\n           assertTrue(exceptionExpected);\n       }\n   }\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n         super(name);\n     }\n \n-    public void testTrivial() throws FunctionEvaluationException {\n+    public void testTrivial() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n         assertEquals(0.0, optimum.getValue(), 1.0e-10);\n     }\n \n-    public void testColumnsPermutation() throws FunctionEvaluationException {\n+    public void testColumnsPermutation() throws MathUserException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n \n     }\n \n-    public void testNoDependency() throws FunctionEvaluationException {\n+    public void testNoDependency() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws FunctionEvaluationException {\n+    public void testOneSet() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n \n     }\n \n-    public void testTwoSets() throws FunctionEvaluationException {\n+    public void testTwoSets() throws MathUserException {\n         final double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n \n     }\n \n-    public void testNonInversible() throws FunctionEvaluationException {\n+    public void testNonInversible() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n         assertTrue(optimum.getValue() > 0.5);\n     }\n \n-    public void testIllConditioned() throws FunctionEvaluationException {\n+    public void testIllConditioned() throws MathUserException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n     }\n \n     public void testMoreEstimatedParametersSimple()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n     }\n \n     public void testMoreEstimatedParametersUnsorted()\n-        throws FunctionEvaluationException {\n+        throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                  { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                  { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n         assertEquals(0, optimum.getValue(), 1.0e-10);\n     }\n \n-    public void testRedundantEquations() throws FunctionEvaluationException {\n+    public void testRedundantEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentEquations() throws FunctionEvaluationException {\n+    public void testInconsistentEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testCircleFitting() throws FunctionEvaluationException {\n+    public void testCircleFitting() throws MathUserException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n             return p;\n         }\n \n-        public double value(double[] variables) throws FunctionEvaluationException {\n+        public double value(double[] variables) throws MathUserException {\n             double[] y = factors.operate(variables);\n             double sum = 0;\n             for (int i = 0; i < y.length; ++i) {\n         }\n \n         public double value(double[] variables)\n-                throws IllegalArgumentException, FunctionEvaluationException {\n+                throws IllegalArgumentException, MathUserException {\n \n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n             double radius = getRadius(center);\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n     public void testCubicMin() throws MathException {\n         final BracketFinder bFind = new BracketFinder();\n         final UnivariateRealFunction func = new UnivariateRealFunction() {\n-                public double value(double x)\n-                    throws FunctionEvaluationException {\n+                public double value(double x) {\n                     if (x < -2) {\n                         return value(-2);\n                     }\n     public void testCubicMax() throws MathException {\n         final BracketFinder bFind = new BracketFinder();\n         final UnivariateRealFunction func = new UnivariateRealFunction() {\n-                public double value(double x)\n-                    throws FunctionEvaluationException {\n+                public double value(double x) {\n                     if (x < -2) {\n                         return value(-2);\n                     }\n     @Test\n     public void testMinimumIsOnIntervalBoundary() throws MathException {\n         final UnivariateRealFunction func = new UnivariateRealFunction() {\n-                public double value(double x)\n-                    throws FunctionEvaluationException {\n+                public double value(double x) {\n                     return x * x;\n                 }\n             };\n     @Test\n     public void testIntervalBoundsOrdering() throws MathException {\n         final UnivariateRealFunction func = new UnivariateRealFunction() {\n-                public double value(double x)\n-                    throws FunctionEvaluationException {\n+                public double value(double x) {\n                     return x * x;\n                 }\n             };\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n public class MultiStartUnivariateRealOptimizerTest {\n \n     @Test\n-    public void testSinMin() {\n+    public void testSinMin() throws MathUserException {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);\n         underlying.setMaxEvaluations(300);\n     }\n \n     @Test\n-    public void testQuinticMin() {\n+    public void testQuinticMin() throws MathUserException {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         UnivariateRealFunction f = new QuinticFunction();\n     }\n \n     @Test(expected=MathUserException.class)\n-    public void testBadFunction() {\n+    public void testBadFunction() throws MathUserException {\n         UnivariateRealFunction f = new UnivariateRealFunction() {\n-                public double value(double x) {\n+                public double value(double x) throws MathUserException {\n                     if (x < 0) {\n                         throw new MathUserException();\n                     }\n         MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n             new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);\n \n-        UnivariateRealPointValuePair optimum\n-            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n+        optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n     }\n }", "timestamp": 1290286910, "metainfo": ""}