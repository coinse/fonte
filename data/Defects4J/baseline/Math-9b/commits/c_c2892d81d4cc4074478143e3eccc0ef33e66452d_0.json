{"sha": "c2892d81d4cc4074478143e3eccc0ef33e66452d", "log": "[MATH-235] Added random data test for eigen decomposition, improved error handling.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n package org.apache.commons.math3.linear;\n \n import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n     /**\n      * Calculates the eigen decomposition of the given real matrix.\n+     * <p>\n+     * Supports decomposition of a general matrix since 3.1.\n      *\n      * @param matrix Matrix to decompose.\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n+     * @throws MathArithmeticException if the decomposition of a general matrix\n+     * results in a matrix with zero norm\n      */\n     public EigenDecomposition(final RealMatrix matrix)  {\n         if (isSymmetric(matrix, false)) {\n         }\n         // return the cached matrix\n         return cachedV;\n-\n     }\n \n     /**\n      * @see #getImagEigenvalues()\n      */\n     public RealMatrix getD() {\n+\n         if (cachedD == null) {\n             // cache the matrix for subsequent calls\n             cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n     /**\n      * Gets a solver for finding the A &times; X = B solution in exact\n      * linear sense.\n-     *\n-     * @return a solver.\n+     * <p>\n+     * Since 3.1, eigen decomposition of a general matrix is supported,\n+     * but the {@link DecompositionSolver} only supports real eigenvalues.\n+     *\n+     * @return a solver\n+     * @throws MathUnsupportedOperationException if the decomposition resulted in\n+     * complex eigenvalues\n      */\n     public DecompositionSolver getSolver() {\n+        for (int i = 0; i < imagEigenvalues.length; i++) {\n+            if (imagEigenvalues[i] != 0.0) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+        }\n         return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n     }\n \n      * Find eigenvectors from a matrix transformed to Schur form.\n      *\n      * @param schur the schur transformation of the matrix\n+     * @throws MathArithmeticException if the Schur form has a norm of zero\n      */\n     private void findEigenVectorsFromSchur(final SchurTransformer schur) {\n         final double[][] matrixT = schur.getT().getData();\n            }\n         }\n \n-        if (Precision.equals(norm, 0.0)) {\n-            // TODO: we can not handle a zero matrix, what exception to throw?\n-           return;\n+        // we can not handle a matrix with zero norm\n+        if (Precision.equals(norm, 0.0, epsilon)) {\n+           throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n \n         // Backsubstitute to find vectors of upper triangular form\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n      * Contains variable names as present in the original JAMA code.\n      */\n     private static class ShiftInfo {\n-        /** TODO: describe */\n+        // CHECKSTYLE: stop all\n+\n+        /** x shift info */\n         double x;\n-        /** TODO: describe */\n+        /** y shift info */\n         double y;\n-        /** TODO: describe */\n+        /** w shift info */\n         double w;\n         /** Indicates an exceptional shift. */\n         double exShift;\n+\n+        // CHECKSTYLE: resume all\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.java\n import java.util.Random;\n \n \n+import org.apache.commons.math3.distribution.NormalDistribution;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Precision;\n import org.junit.After;\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n     }\n \n                     { 12.0, 66.0 }\n             });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n         Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n     }\n                                    { -16560.0,  7920.0,  17300.0 }\n                                });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n         Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n         Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n                     { 15,   30,   45 }\n             });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);\n         Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);\n         Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);\n                                    {  0.000,  0.000, -0.048,  0.136 }\n                                });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n         Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n         Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n                                });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n         Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n         Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n         };\n \n         EigenDecomposition decomposition;\n-        decomposition = new EigenDecomposition(mainTridiagonal,\n-                                                   secondaryTridiagonal,\n-                                                   Precision.SAFE_MIN);\n+        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n \n         // the following line triggers the exception\n         EigenDecomposition decomposition;\n-        decomposition = new EigenDecomposition(mainTridiagonal,\n-                                                   secondaryTridiagonal,\n-                                                   Precision.SAFE_MIN);\n+        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n \n         // the following line triggers the exception\n         EigenDecomposition decomposition;\n-        decomposition = new EigenDecomposition(mainTridiagonal,\n-                                                   secondaryTridiagonal,\n-                                                   Precision.SAFE_MIN);\n+        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n         TriDiagonalTransformer t =\n             new TriDiagonalTransformer(createTestMatrix(r, ref));\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(t.getMainDiagonalRef(),\n-                                        t.getSecondaryDiagonalRef(),\n-                                        Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(t.getMainDiagonalRef(), t.getSecondaryDiagonalRef());\n         double[] eigenValues = ed.getRealEigenvalues();\n         Assert.assertEquals(ref.length, eigenValues.length);\n         for (int i = 0; i < ref.length; ++i) {\n     public void testDimensions() {\n         final int m = matrix.getRowDimension();\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         Assert.assertEquals(m, ed.getV().getRowDimension());\n         Assert.assertEquals(m, ed.getV().getColumnDimension());\n         Assert.assertEquals(m, ed.getD().getColumnDimension());\n     @Test\n     public void testEigenvalues() {\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         double[] eigenValues = ed.getRealEigenvalues();\n         Assert.assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n         }\n         Arrays.sort(bigValues);\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(createTestMatrix(r, bigValues),\n-                                        Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(createTestMatrix(r, bigValues));\n         double[] eigenValues = ed.getRealEigenvalues();\n         Assert.assertEquals(bigValues.length, eigenValues.length);\n         for (int i = 0; i < bigValues.length; ++i) {\n         });\n \n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(symmetric, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(symmetric);\n         \n         RealMatrix d = ed.getD();\n         RealMatrix v = ed.getV();\n \n         double norm = v.multiply(d).multiply(vT).subtract(symmetric).getNorm();\n         Assert.assertEquals(0, norm, 6.0e-13);\n-\n-//           check(A.times(V),V.times(D));\n     }\n \n     @Test\n         checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(randData2));\n     }\n     \n+    @Test\n+    public void testRandomUnsymmetricMatrix() {\n+        for (int run = 0; run < 100; run++) {\n+            Random r = new Random(System.currentTimeMillis());\n+\n+            // matrix size\n+            int size = r.nextInt(20) + 4;\n+\n+            double[][] data = new double[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    data[i][j] = r.nextInt(100);\n+                }\n+            }\n+\n+            RealMatrix m = MatrixUtils.createRealMatrix(data);\n+            checkUnsymmetricMatrix(m);\n+        }        \n+    }\n+    \n+    @Test\n+    public void testNormalDistributionUnsymmetricMatrix() {\n+        for (int run = 0; run < 100; run++) {\n+            Random r = new Random(System.currentTimeMillis());\n+            NormalDistribution dist = new NormalDistribution(0.0, r.nextDouble() * 5);\n+\n+            // matrix size\n+            int size = r.nextInt(20) + 4;\n+\n+            double[][] data = new double[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    data[i][j] = dist.sample();\n+                }\n+            }\n+\n+            RealMatrix m = MatrixUtils.createRealMatrix(data);\n+            checkUnsymmetricMatrix(m);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by\n+     * checking: A*V = V*D\n+     */\n     private void checkUnsymmetricMatrix(final RealMatrix m) {\n-        EigenDecomposition ed = new EigenDecomposition(m, Precision.SAFE_MIN);\n+        EigenDecomposition ed = new EigenDecomposition(m);\n         \n         RealMatrix d = ed.getD();\n         RealMatrix v = ed.getV();\n         \n         RealMatrix invV = new LUDecomposition(v).getSolver().getInverse();\n         double norm = v.multiply(d).multiply(invV).subtract(m).getNorm();\n-        Assert.assertEquals(0.0, norm, 6.0e-13);\n+        Assert.assertEquals(0.0, norm, 1.0e-10);\n     }\n \n     /** test eigenvectors */\n     @Test\n     public void testEigenvectors() {\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n             double lambda = ed.getRealEigenvalue(i);\n             RealVector v  = ed.getEigenvector(i);\n     @Test\n     public void testAEqualVDVt() {\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix);\n         RealMatrix v  = ed.getV();\n         RealMatrix d  = ed.getD();\n         RealMatrix vT = ed.getVT();\n     /** test that V is orthogonal */\n     @Test\n     public void testVOrthogonal() {\n-        RealMatrix v = new EigenDecomposition(matrix, Precision.SAFE_MIN).getV();\n+        RealMatrix v = new EigenDecomposition(matrix).getV();\n         RealMatrix vTv = v.transpose().multiply(v);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n         Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n         RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(m, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(m);\n         Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n         Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n         Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n                 {4,  2,  3}\n         });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(repeated, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(repeated);\n         checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n         checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n     }\n                 {-4, -4, 8}\n         });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(distinct, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(distinct);\n         checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n         checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n         checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n                 { -1.0,0.0, 1.0 }\n         });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(indefinite, Precision.SAFE_MIN);\n+        ed = new EigenDecomposition(indefinite);\n         checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);\n         double isqrt3 = 1/FastMath.sqrt(3.0);\n         checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);", "timestamp": 1342644583, "metainfo": ""}