{"sha": "136132c0e8a4ac69ad12adf445dd35895784b36f", "log": "added composition features for real functions JIRA: MATH-313  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+\n+\n+/**\n+ * Base class for {@link BivariateRealFunction} that can be composed with other functions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class BinaryFunction implements BivariateRealFunction {\n+\n+    /** The + operator method wrapped as a {@link BinaryFunction}. */\n+    public static final BinaryFunction ADD = new BinaryFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double x, double y) {\n+            return x + y;\n+        }\n+    };\n+\n+    /** The - operator method wrapped as a {@link BinaryFunction}. */\n+    public static final BinaryFunction SUBTRACT = new BinaryFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double x, double y) {\n+            return x - y;\n+        }\n+    };\n+\n+    /** The * operator method wrapped as a {@link BinaryFunction}. */\n+    public static final BinaryFunction MULTIPLY = new BinaryFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double x, double y) {\n+            return x * y;\n+        }\n+    };\n+\n+    /** The / operator method wrapped as a {@link BinaryFunction}. */\n+    public static final BinaryFunction DIVIDE = new BinaryFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double x, double y) {\n+            return x / y;\n+        }\n+    };\n+\n+    /** The {@code Math.pow} method wrapped as a {@link BinaryFunction}. */\n+    public static final BinaryFunction POW = new BinaryFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double x, double y) {\n+            return Math.pow(x, y);\n+        }\n+    };\n+\n+    /** The {@code Math.atan2} method wrapped as a {@link BinaryFunction}. */\n+    public static final BinaryFunction ATAN2 = new BinaryFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double x, double y) {\n+            return Math.atan2(x, y);\n+        }\n+    };\n+\n+    /** {@inheritDoc} */\n+    public abstract double value(double x, double y) throws FunctionEvaluationException;\n+\n+    /** Get a composable function by fixing the first argument of the instance.\n+     * @param fixedX fixed value of the first argument\n+     * @return a function such that {@code f.value(y) == value(fixedX, y)}\n+     */\n+    public ComposableFunction fix1stArgument(final double fixedX) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return BinaryFunction.this.value(fixedX, x);\n+            }\n+        };\n+    }\n+\n+    /** Get a composable function by fixing the second argument of the instance.\n+     * @param fixedY fixed value of the second argument\n+     * @return a function such that {@code f.value(x) == value(x, fixedY)}\n+     */\n+    public ComposableFunction fix2ndArgument(final double fixedY) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return BinaryFunction.this.value(x, fixedY);\n+            }\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+\n+\n+/**\n+ * An interface representing a bivariate real function.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface BivariateRealFunction {\n+\n+    /**\n+     * Compute the value for the function.\n+     * @param x abscissa for which the function value should be computed\n+     * @param y ordinate for which the function value should be computed\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    double value(double x, double y) throws FunctionEvaluationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+\n+/**\n+ * Base class for {@link UnivariateRealFunction} that can be composed with other functions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class ComposableFunction implements UnivariateRealFunction {\n+\n+    /** The constant function always returning 0. */\n+    public static final ComposableFunction ZERO = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return 0;\n+        }\n+    };\n+\n+    /** The constant function always returning 1. */\n+    public static final ComposableFunction ONE = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return 1;\n+        }\n+    };\n+\n+    /** The identity function. */\n+    public static final ComposableFunction IDENTITY = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return d;\n+        }\n+    };\n+\n+    /** The {@code Math.abs} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction ABS = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.abs(d);\n+        }\n+    };\n+\n+    /** The - operator wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction NEGATE = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return -d;\n+        }\n+    };\n+\n+    /** The {@code Math.sin} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction SIN = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.sin(d);\n+        }\n+    };\n+\n+    /** The {@code Math.sqrt} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction SQRT = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.sqrt(d);\n+        }\n+    };\n+\n+    /** The {@code Math.sinh} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction SINH = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.sinh(d);\n+        }\n+    };\n+\n+    /** The {@code Math.exp} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction EXP = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.exp(d);\n+        }\n+    };\n+\n+    /** The {@code Math.expm1} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction EXPM1 = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.expm1(d);\n+        }\n+    };\n+\n+    /** The {@code Math.asin} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction ASIN = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.asin(d);\n+        }\n+    };\n+\n+    /** The {@code Math.atan} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction ATAN = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.atan(d);\n+        }\n+    };\n+\n+    /** The {@code Math.tan} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction TAN = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.tan(d);\n+        }\n+    };\n+\n+    /** The {@code Math.tanh} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction TANH = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.tanh(d);\n+        }\n+    };\n+\n+    /** The {@code Math.cbrt} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction CBRT = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.cbrt(d);\n+        }\n+    };\n+\n+    /** The {@code Math.ceil} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction CEIL = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.ceil(d);\n+        }\n+    };\n+\n+    /** The {@code Math.floor} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction FLOOR = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.floor(d);\n+        }\n+    };\n+\n+    /** The {@code Math.log} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction LOG = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.log(d);\n+        }\n+    };\n+\n+    /** The {@code Math.log10} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction LOG10 = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.log10(d);\n+        }\n+    };\n+\n+    /** The {@code Math.cos} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction COS = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.cos(d);\n+        }\n+    };\n+\n+    /** The {@code Math.abs} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction ACOS = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.acos(d);\n+        }\n+    };\n+\n+    /** The {@code Math.cosh} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction COSH = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.cosh(d);\n+        }\n+    };\n+\n+    /** The {@code Math.rint} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction RINT = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.rint(d);\n+        }\n+    };\n+\n+    /** The {@code Math.signum} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction SIGNUM = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.signum(d);\n+        }\n+    };\n+\n+    /** The {@code Math.ulp} method wrapped as a {@link ComposableFunction}. */\n+    public static final ComposableFunction ULP = new ComposableFunction() {\n+        /** {@inheritDoc} */\n+        public double value(double d) {\n+            return Math.ulp(d);\n+        }\n+    };\n+\n+    /** Precompose the instance with another function.\n+     * <p>\n+     * The composed function h created by {@code h = g.of(f)} is such\n+     * that {@code h.value(x) == g.value(f.value(x))} for all x.\n+     * </p>\n+     * @param f function to compose with\n+     * @return a new function which computes {@code this.value(f.value(x))}\n+     * @see #postCompose(UnivariateRealFunction)\n+     */\n+    public ComposableFunction of(final UnivariateRealFunction f) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(f.value(x));\n+            }\n+        };\n+    }\n+\n+    /** Postcompose the instance with another function.\n+     * <p>\n+     * The composed function h created by {@code h = g.postCompose(f)} is such\n+     * that {@code h.value(x) == f.value(g.value(x))} for all x.\n+     * </p>\n+     * @param f function to compose with\n+     * @return a new function which computes {@code f.value(this.value(x))}\n+     * @see #of(UnivariateRealFunction)\n+     */\n+    public ComposableFunction postCompose(final UnivariateRealFunction f) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return f.value(ComposableFunction.this.value(x));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a function combining the instance and another function.\n+     * <p>\n+     * The function h created by {@code h = g.combine(f, combiner)} is such that\n+     * {@code h.value(x) == combiner.value(g.value(x), f.value(x))} for all x.\n+     * </p>\n+     * @param f function to combine with the instance\n+     * @param combiner bivariate function used for combining\n+     * @return a new function which computes {@code combine.value(this.value(x), f.value(x))}\n+     */\n+    public ComposableFunction combine(final UnivariateRealFunction f,\n+                                      final BivariateRealFunction combiner) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return combiner.value(ComposableFunction.this.value(x), f.value(x));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a function adding the instance and another function.\n+     * @param f function to combine with the instance\n+     * @return a new function which computes {@code this.value(x) + f.value(x)}\n+     */\n+    public ComposableFunction add(final UnivariateRealFunction f) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(x) + f.value(x);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a function adding a constant term to the instance.\n+     * @param a term to add\n+     * @return a new function which computes {@code this.value(x) + a}\n+     */\n+    public ComposableFunction add(final double a) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(x) + a;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a function subtracting another function from the instance.\n+     * @param f function to combine with the instance\n+     * @return a new function which computes {@code this.value(x) - f.value(x)}\n+     */\n+    public ComposableFunction subtract(final UnivariateRealFunction f) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(x) - f.value(x);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a function multiplying the instance and another function.\n+     * @param f function to combine with the instance\n+     * @return a new function which computes {@code this.value(x) * f.value(x)}\n+     */\n+    public ComposableFunction multiply(final UnivariateRealFunction f) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(x) * f.value(x);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a function scaling the instance by a constant factor.\n+     * @param scaleFactor constant scaling factor\n+     * @return a new function which computes {@code this.value(x) * scaleFactor}\n+     */\n+    public ComposableFunction multiply(final double scaleFactor) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(x) * scaleFactor;\n+            }\n+        };\n+    }\n+    /**\n+     * Return a function dividing the instance by another function.\n+     * @param f function to combine with the instance\n+     * @return a new function which computes {@code this.value(x) / f.value(x)}\n+     */\n+    public ComposableFunction divide(final UnivariateRealFunction f) {\n+        return new ComposableFunction() {\n+            @Override\n+            /** {@inheritDoc} */\n+            public double value(double x) throws FunctionEvaluationException {\n+                return ComposableFunction.this.value(x) / f.value(x);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Generates a function that iteratively apply instance function on all\n+     * elements of an array.\n+     * <p>\n+     * The generated function behaves as follows:\n+     * <ul>\n+     *   <li>initialize result = initialValue</li>\n+     *   <li>iterate: {@code result = combiner.value(result,\n+     *   this.value(nextMultivariateEntry));}</li>\n+     *   <li>return result</li>\n+     * </ul>\n+     * </p>\n+     * @param combiner combiner to use between entries\n+     * @param initialValue initial value to use before first entry\n+     * @return a new function that iteratively applie instance function on all\n+     * elements of an array.\n+     */\n+    public MultivariateRealFunction asCollector(final BivariateRealFunction combiner,\n+                                                final double initialValue) {\n+        return new MultivariateRealFunction() {\n+            /** {@inheritDoc} */\n+            public double value(double[] point)\n+                throws FunctionEvaluationException, IllegalArgumentException {\n+                double result = initialValue;\n+                for (final double entry : point) {\n+                    result = combiner.value(result, ComposableFunction.this.value(entry));\n+                }\n+                return result;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Generates a function that iteratively apply instance function on all\n+     * elements of an array.\n+     * <p>\n+     * Calling this method is equivalent to call {@link\n+     * #asCollector(BivariateRealFunction, double) asCollector(BivariateRealFunction, 0.0)}.\n+     * </p>\n+     * @param combiner combiner to use between entries\n+     * @return a new function that iteratively applie instance function on all\n+     * elements of an array.\n+     * @see #asCollector(BivariateRealFunction, double)\n+     */\n+    public  MultivariateRealFunction asCollector(final BivariateRealFunction combiner) {\n+        return asCollector(combiner, 0.0);\n+    }\n+\n+    /**\n+     * Generates a function that iteratively apply instance function on all\n+     * elements of an array.\n+     * <p>\n+     * Calling this method is equivalent to call {@link\n+     * #asCollector(BivariateRealFunction, double) asCollector(BinaryFunction.ADD, initialValue)}.\n+     * </p>\n+     * @param initialValue initial value to use before first entry\n+     * @return a new function that iteratively applie instance function on all\n+     * elements of an array.\n+     * @see #asCollector(BivariateRealFunction, double)\n+     * @see BinaryFunction#ADD\n+     */\n+    public  MultivariateRealFunction asCollector(final double initialValue) {\n+        return asCollector(BinaryFunction.ADD, initialValue);\n+    }\n+\n+    /**\n+     * Generates a function that iteratively apply instance function on all\n+     * elements of an array.\n+     * <p>\n+     * Calling this method is equivalent to call {@link\n+     * #asCollector(BivariateRealFunction, double) asCollector(BinaryFunction.ADD, 0.0)}.\n+     * </p>\n+     * @return a new function that iteratively applie instance function on all\n+     * elements of an array.\n+     * @see #asCollector(BivariateRealFunction, double)\n+     * @see BinaryFunction#ADD\n+     */\n+    public  MultivariateRealFunction asCollector() {\n+        return asCollector(BinaryFunction.ADD, 0.0);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract double value(double x) throws FunctionEvaluationException;\n+\n+}\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunctions;\n+import org.apache.commons.math.analysis.ComposableFunction;\n \n /**\n  * This class provides default basic implementations for many methods in the\n     /** {@inheritDoc} */\n     public RealVector mapAbsToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.ABS);\n+            return mapToSelf(ComposableFunction.ABS);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapAcosToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.ACOS);\n+            return mapToSelf(ComposableFunction.ACOS);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapAsinToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.ASIN);\n+            return mapToSelf(ComposableFunction.ASIN);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapAtanToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.ATAN);\n+            return mapToSelf(ComposableFunction.ATAN);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapCbrtToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.CBRT);\n+            return mapToSelf(ComposableFunction.CBRT);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapCeilToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.CEIL);\n+            return mapToSelf(ComposableFunction.CEIL);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapCosToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.COS);\n+            return mapToSelf(ComposableFunction.COS);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapCoshToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.COSH);\n+            return mapToSelf(ComposableFunction.COSH);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapExpToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.EXP);\n+            return mapToSelf(ComposableFunction.EXP);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapExpm1ToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.EXP1M);\n+            return mapToSelf(ComposableFunction.EXPM1);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapFloorToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.FLOOR);\n+            return mapToSelf(ComposableFunction.FLOOR);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapLogToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.LOG);\n+            return mapToSelf(ComposableFunction.LOG);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapLog10ToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.LOG10);\n+            return mapToSelf(ComposableFunction.LOG10);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapLog1pToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.ASIN);\n+            return mapToSelf(ComposableFunction.ASIN);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapRintToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.RINT);\n+            return mapToSelf(ComposableFunction.RINT);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapSignumToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.SIGNUM);\n+            return mapToSelf(ComposableFunction.SIGNUM);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapSinToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.SIN);\n+            return mapToSelf(ComposableFunction.SIN);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapSinhToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.SINH);\n+            return mapToSelf(ComposableFunction.SINH);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapSqrtToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.SQRT);\n+            return mapToSelf(ComposableFunction.SQRT);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapTanToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.TAN);\n+            return mapToSelf(ComposableFunction.TAN);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapTanhToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.TANH);\n+            return mapToSelf(ComposableFunction.TANH);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n     /** {@inheritDoc} */\n     public RealVector mapUlpToSelf() {\n         try {\n-            return mapToSelf(UnivariateRealFunctions.ULP);\n+            return mapToSelf(ComposableFunction.ULP);\n         } catch (FunctionEvaluationException e) {\n             throw new IllegalArgumentException(e);\n         }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class BinaryFunctionTest {\n+\n+    @Test\n+    public void testAdd() throws FunctionEvaluationException {\n+        Assert.assertEquals(5.0, BinaryFunction.ADD.value(2, 3), 1.0e-15);\n+        Assert.assertEquals(0.0, BinaryFunction.ADD.value(-1, 1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testSubtract() throws FunctionEvaluationException {\n+        Assert.assertEquals(-1.0, BinaryFunction.SUBTRACT.value(2, 3), 1.0e-15);\n+        Assert.assertEquals(-2.0, BinaryFunction.SUBTRACT.value(-1, 1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testMultiply() throws FunctionEvaluationException {\n+        Assert.assertEquals(6.0, BinaryFunction.MULTIPLY.value(2, 3), 1.0e-15);\n+        Assert.assertEquals(-1.0, BinaryFunction.MULTIPLY.value(-1, 1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testDivide() throws FunctionEvaluationException {\n+        Assert.assertEquals(1.5, BinaryFunction.DIVIDE.value(3, 2), 1.0e-15);\n+        Assert.assertEquals(-1.0, BinaryFunction.DIVIDE.value(-1, 1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testPow() throws FunctionEvaluationException {\n+        Assert.assertEquals(9.0, BinaryFunction.POW.value(3, 2), 1.0e-15);\n+        Assert.assertEquals(-1.0, BinaryFunction.POW.value(-1, 1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testAtan2() throws FunctionEvaluationException {\n+        Assert.assertEquals(Math.PI / 4, BinaryFunction.ATAN2.value(1, 1), 1.0e-15);\n+        Assert.assertEquals(-Math.PI / 4, BinaryFunction.ATAN2.value(-1, 1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testFix1st() throws FunctionEvaluationException {\n+        ComposableFunction f = BinaryFunction.POW.fix1stArgument(2);\n+        for (double x = 0.0; x < 1.0; x += 0.01) {\n+            Assert.assertEquals(Math.pow(2.0, x), f.value(x), 1.0e-15);\n+        }\n+    }\n+\n+    @Test\n+    public void testFix2nd() throws FunctionEvaluationException {\n+        ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);\n+        for (double y = 0.0; y < 1.0; y += 0.01) {\n+            Assert.assertEquals(y * y, f.value(y), 1.0e-15);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ComposableFunctionTest {\n+\n+    @Test\n+    public void testZero() throws FunctionEvaluationException {\n+        Assert.assertEquals(0.0, ComposableFunction.ZERO.value(1), 1.0e-15);\n+        Assert.assertEquals(0.0, ComposableFunction.ZERO.value(2), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testOne() throws FunctionEvaluationException {\n+        Assert.assertEquals(1.0, ComposableFunction.ONE.value(1), 1.0e-15);\n+        Assert.assertEquals(1.0, ComposableFunction.ONE.value(2), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testIdentity() throws FunctionEvaluationException {\n+        Assert.assertEquals(1.0, ComposableFunction.IDENTITY.value(1), 1.0e-15);\n+        Assert.assertEquals(2.0, ComposableFunction.IDENTITY.value(2), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testRint() throws FunctionEvaluationException {\n+        Assert.assertEquals(1.0, ComposableFunction.RINT.value(0.9), 1.0e-15);\n+        Assert.assertEquals(2.0, ComposableFunction.RINT.value(2.2), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testSignum() throws FunctionEvaluationException {\n+        Assert.assertEquals(1.0, ComposableFunction.SIGNUM.value(12.3), 1.0e-15);\n+        Assert.assertEquals(-1.0, ComposableFunction.SIGNUM.value(-6), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testComposition() throws FunctionEvaluationException {\n+        ComposableFunction abs    = ComposableFunction.ABS;\n+        ComposableFunction acos   = ComposableFunction.ACOS;\n+        ComposableFunction asin   = ComposableFunction.ASIN;\n+        ComposableFunction atan   = ComposableFunction.ATAN;\n+        ComposableFunction cbrt   = ComposableFunction.CBRT;\n+        ComposableFunction ceil   = ComposableFunction.CEIL;\n+        ComposableFunction cos    = ComposableFunction.COS;\n+        ComposableFunction cosh   = ComposableFunction.COSH;\n+        ComposableFunction exp    = ComposableFunction.EXP;\n+        ComposableFunction expm1  = ComposableFunction.EXPM1;\n+        ComposableFunction floor  = ComposableFunction.FLOOR;\n+        ComposableFunction id     = ComposableFunction.IDENTITY;\n+        ComposableFunction log    = ComposableFunction.LOG;\n+        ComposableFunction log10  = ComposableFunction.LOG10;\n+        ComposableFunction negate = ComposableFunction.NEGATE;\n+        ComposableFunction sin    = ComposableFunction.SIN;\n+        ComposableFunction sinh   = ComposableFunction.SINH;\n+        ComposableFunction sqrt   = ComposableFunction.SQRT;\n+        ComposableFunction tan    = ComposableFunction.TAN;\n+        ComposableFunction tanh   = ComposableFunction.TANH;\n+        ComposableFunction ulp    = ComposableFunction.ULP;\n+\n+        ComposableFunction f1 = sqrt.of(abs.of(expm1.of(cbrt.of(tanh).of(id))));\n+        for (double x = 0.1; x < 0.9; x += 0.01) {\n+            Assert.assertEquals(Math.sqrt(Math.abs(Math.expm1(Math.cbrt(Math.tanh(x))))),\n+                                f1.value(x), 1.0e-15);\n+        }\n+\n+        ComposableFunction f2 = cosh.of(sinh.of(tanh.of(ceil.postCompose(log.postCompose(cosh)))));\n+        for (double x = 0.1; x < 12.9; x += 1.0) {\n+            Assert.assertEquals(Math.cosh(Math.sinh(Math.tanh(Math.cosh(Math.log(Math.ceil(x)))))),\n+                                f2.value(x), 1.0e-15);\n+        }\n+\n+        ComposableFunction f3 = cos.of(sin.of(tan.of(acos.of(asin.of(log10.of(log.of(ulp)))))));\n+        for (double x = 1.0e16; x < 1.0e17; x += 1.0e16) {\n+            Assert.assertEquals(Math.cos(Math.sin(Math.tan(Math.acos(Math.asin(Math.log10(Math.log(Math.ulp(x)))))))),\n+                                f3.value(x), 1.0e-15);\n+        }\n+\n+        ComposableFunction f4 = atan.of(exp.of(negate.of(floor)));\n+        for (double x = 1.1; x < 10.2; x += 1.0) {\n+            Assert.assertEquals(Math.atan(Math.exp(-Math.floor(x))),\n+                                f4.value(x), 1.0e-15);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testCombine() throws FunctionEvaluationException {\n+\n+        ComposableFunction f =\n+            ComposableFunction.COS.combine(ComposableFunction.ASIN, BinaryFunction.POW);\n+        for (double x = 0.1; x < 0.9; x += 0.01) {\n+            Assert.assertEquals(Math.pow(Math.cos(x), Math.asin(x)), f.value(x), 1.0e-15);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSimpleCombination() throws FunctionEvaluationException {\n+\n+        ComposableFunction f1 = ComposableFunction.COS.add(3);\n+        ComposableFunction f2 = ComposableFunction.COS.add(ComposableFunction.SIN);\n+        ComposableFunction f3 = ComposableFunction.COS.subtract(ComposableFunction.SIN);\n+        ComposableFunction f4 = ComposableFunction.COS.multiply(ComposableFunction.SIN);\n+        ComposableFunction f5 = ComposableFunction.COS.multiply(5);\n+        ComposableFunction f6 = ComposableFunction.COS.divide(ComposableFunction.SIN);\n+        for (double x = 0.1; x < 0.9; x += 0.01) {\n+            Assert.assertEquals(Math.cos(x) + 3, f1.value(x), 1.0e-15);\n+            Assert.assertEquals(Math.cos(x) + Math.sin(x), f2.value(x), 1.0e-15);\n+            Assert.assertEquals(Math.cos(x) - Math.sin(x), f3.value(x), 1.0e-15);\n+            Assert.assertEquals(Math.cos(x) * Math.sin(x), f4.value(x), 1.0e-15);\n+            Assert.assertEquals(Math.cos(x) * 5, f5.value(x), 1.0e-15);\n+            Assert.assertEquals(Math.cos(x) / Math.sin(x), f6.value(x), 1.0e-15);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testCollector() throws FunctionEvaluationException {\n+\n+        ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);\n+        Assert.assertEquals(30, f.asCollector().value(new double[] { 1, 2, 3, 4 }), 1.0e-15);\n+        Assert.assertEquals(33, f.asCollector(3).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);\n+        Assert.assertEquals(-30, f.asCollector(BinaryFunction.SUBTRACT).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);\n+        Assert.assertEquals(1152, f.asCollector(BinaryFunction.MULTIPLY, 2).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);\n+    }\n+\n+}", "timestamp": 1260659732, "metainfo": ""}