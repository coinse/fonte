{"sha": "3c3ccb79d4e909ddbb552a07a7e9acf2c4e75377", "log": "MATH-428 Refactoring of \"DirectSearchOptimizer\" to separate the optimization and simplex management aspects. Old classes are deprecated.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n \n /**\n  * Base class for all preconditions violation exceptions.\n- * This class is not intended to be instantiated directly: it should serve\n- * as a base class to create all the exceptions that share the semantics of\n- * the standard {@link IllegalArgumentException}, but must also provide a\n+ * In most cases, this class should not be instantiated directly: it should\n+ * serve as a base class to create all the exceptions that share the semantics\n+ * of the standard {@link IllegalArgumentException}, but must also provide a\n  * localized message.\n  *\n  * @since 2.2\n      * @param general Message pattern explaining the cause of the error.\n      * @param args Arguments.\n      */\n-    protected MathIllegalArgumentException(Localizable specific,\n-                                           Localizable general,\n-                                           Object ... args) {\n+    public MathIllegalArgumentException(Localizable specific,\n+                                        Localizable general,\n+                                        Object ... args) {\n         this.specific = specific;\n         this.general = general;\n         arguments = ArgUtils.flatten(args);\n      * @param general Message pattern explaining the cause of the error.\n      * @param args Arguments.\n      */\n-    protected MathIllegalArgumentException(Localizable general,\n-                                           Object ... args) {\n+    public MathIllegalArgumentException(Localizable general,\n+                                        Object ... args) {\n         this(null, general, args);\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n public class RealPointValuePair implements Serializable {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 1003888396256744753L;\n-\n     /** Point coordinates. */\n     private final double[] point;\n-\n     /** Value of the objective function at the point. */\n     private final double value;\n \n      */\n     public RealPointValuePair(final double[] point, final double value) {\n         this.point = (point == null) ? null : point.clone();\n-        this.value  = value;\n+        this.value = value;\n     }\n \n     /** Build a point/objective function value pair.\n         this.point = copyArray ?\n                      ((point == null) ? null : point.clone()) :\n                      point;\n-        this.value  = value;\n+        this.value = value;\n     }\n \n     /** Get the point.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/**\n+ * This class implements the simplex concept.\n+ * It is intended to be used in conjunction with {@link SimplexOptimizer}.\n+ * <br/>\n+ * The initial configuration of the simplex is set by the constructors\n+ * {@link #AbstractSimplex(double[])} or {@link #AbstractSimplex(double[][])}.\n+ * The other {@link #AbstractSimplex(int) constructor} will set all steps\n+ * to 1, thus building a default configuration from a unit hypercube.\n+ * <br/>\n+ * Users <em>must</em> call the {@link #build(double[]) build} method in order\n+ * to create the data structure that will be acted on by the other methods of\n+ * this class.\n+ *\n+ * @see SimplexOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class AbstractSimplex {\n+    /** Simplex. */\n+    private RealPointValuePair[] simplex;\n+    /** Start simplex configuration. */\n+    private double[][] startConfiguration;\n+    /** Simplex dimension (must be equal to {@code simplex.length - 1}). */\n+    private final int dimension;\n+\n+    /**\n+     * Default constructor.\n+     * Build a unit hypercube.\n+     *\n+     * @param n Dimension of the simplex.\n+     */\n+    protected AbstractSimplex(int n) {\n+        this(createUnitHypercubeSteps(n));\n+    }\n+\n+    /**\n+     * The start configuration for simplex is built from a box parallel to\n+     * the canonical axes of the space. The simplex is the subset of vertices\n+     * of a box parallel to the canonical axes. It is built as the path followed\n+     * while traveling from one vertex of the box to the diagonally opposite\n+     * vertex moving only along the box edges. The first vertex of the box will\n+     * be located at the start point of the optimization.\n+     * As an example, in dimension 3 a simplex has 4 vertices. Setting the\n+     * steps to (1, 10, 2) and the start point to (1, 1, 1) would imply the\n+     * start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }.\n+     * The first vertex would be set to the start point at (1, 1, 1) and the\n+     * last vertex would be set to the diagonally opposite vertex at (2, 11, 3).\n+     *\n+     * @param steps Steps along the canonical axes representing box edges. They\n+     * may be negative but not zero.\n+     * @throws NullArgumentException if {@code steps} is {@code null}.\n+     * @throws ZeroException if one of the steps is zero.\n+     */\n+    protected AbstractSimplex(final double[] steps) {\n+        if (steps == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (steps.length == 0) {\n+            throw new ZeroException();\n+        }\n+        dimension = steps.length;\n+\n+        // Only the relative position of the n final vertices with respect\n+        // to the first one are stored.\n+        startConfiguration = new double[dimension][dimension];\n+        for (int i = 0; i < dimension; i++) {\n+            final double[] vertexI = startConfiguration[i];\n+            for (int j = 0; j < i + 1; j++) {\n+                if (steps[j] == 0) {\n+                    throw new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX);\n+                }\n+                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The real initial simplex will be set up by moving the reference\n+     * simplex such that its first point is located at the start point of the\n+     * optimization.\n+     *\n+     * @param referenceSimplex Reference simplex.\n+     * @throws NotStrictlyPositiveException if the reference simplex does not\n+     * contain at least one point.\n+     * @throws DimensionMismatchException if there is a dimension mismatch\n+     * in the reference simplex.\n+     * @throws IllegalArgumentException if one of its vertices is duplicated.\n+     */\n+    protected AbstractSimplex(final double[][] referenceSimplex) {\n+        if (referenceSimplex.length <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SIMPLEX_NEED_ONE_POINT,\n+                                                   referenceSimplex.length);\n+        }\n+        dimension = referenceSimplex.length - 1;\n+\n+        // Only the relative position of the n final vertices with respect\n+        // to the first one are stored.\n+        startConfiguration = new double[dimension][dimension];\n+        final double[] ref0 = referenceSimplex[0];\n+\n+        // Loop over vertices.\n+        for (int i = 0; i < referenceSimplex.length; i++) {\n+            final double[] refI = referenceSimplex[i];\n+\n+            // Safety checks.\n+            if (refI.length != dimension) {\n+                throw new DimensionMismatchException(refI.length, dimension);\n+            }\n+            for (int j = 0; j < i; j++) {\n+                final double[] refJ = referenceSimplex[j];\n+                boolean allEquals = true;\n+                for (int k = 0; k < dimension; k++) {\n+                    if (refI[k] != refJ[k]) {\n+                        allEquals = false;\n+                        break;\n+                    }\n+                }\n+                if (allEquals) {\n+                    throw new MathIllegalArgumentException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX,\n+                                                           i, j);\n+                }\n+            }\n+\n+            // Store vertex i position relative to vertex 0 position.\n+            if (i > 0) {\n+                final double[] confI = startConfiguration[i - 1];\n+                for (int k = 0; k < dimension; k++) {\n+                    confI[k] = refI[k] - ref0[k];\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get simplex dimension.\n+     *\n+     * @return the dimension of the simplex.\n+     */\n+    public int getDimension() {\n+        return dimension;\n+    }\n+\n+    /**\n+     * Get simplex size.\n+     * After calling the {@link #build(double[]) build} method, this method will\n+     * will be equivalent to {@code getDimension() + 1}.\n+     *\n+     * @return the size of the simplex.\n+     */\n+    public int getSize() {\n+        return simplex.length;\n+    }\n+\n+    /**\n+     * Compute the next simplex of the algorithm.\n+     *\n+     * @param evaluationFunction Evaluation function.\n+     * @param comparator Comparator to use to sort simplex vertices from best\n+     * to worst.\n+     * @throws FunctionEvaluationException if the function cannot be evaluated\n+     * at some point.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the algorithm fails to converge.\n+     */\n+    public abstract void iterate(final MultivariateRealFunction evaluationFunction,\n+                                 final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * Build an initial simplex.\n+     *\n+     * @param startPoint First point of the simplex.\n+     * @throws DimensionMismatchException if the start point does not match\n+     * simplex dimension.\n+     */\n+    public void build(final double[] startPoint) {\n+        if (dimension != startPoint.length) {\n+            throw new DimensionMismatchException(dimension, startPoint.length);\n+        }\n+\n+        // Set first vertex.\n+        simplex = new RealPointValuePair[dimension + 1];\n+        simplex[0] = new RealPointValuePair(startPoint, Double.NaN);\n+\n+        // Set remaining vertices.\n+        for (int i = 0; i < dimension; i++) {\n+            final double[] confI = startConfiguration[i];\n+            final double[] vertexI = new double[dimension];\n+            for (int k = 0; k < dimension; k++) {\n+                vertexI[k] = startPoint[k] + confI[k];\n+            }\n+            simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);\n+        }\n+    }\n+\n+    /**\n+     * Evaluate all the non-evaluated points of the simplex.\n+     *\n+     * @param evaluationFunction Evaluation function.\n+     * @param comparator Comparator to use to sort simplex vertices from best to worst.\n+     * @throws FunctionEvaluationException if no value can be computed for the parameters.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     */\n+    public void evaluate(final MultivariateRealFunction evaluationFunction,\n+                         final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException {\n+\n+        // Evaluate the objective function at all non-evaluated simplex points.\n+        for (int i = 0; i < simplex.length; i++) {\n+            final RealPointValuePair vertex = simplex[i];\n+            final double[] point = vertex.getPointRef();\n+            if (Double.isNaN(vertex.getValue())) {\n+                simplex[i] = new RealPointValuePair(point, evaluationFunction.value(point), false);\n+            }\n+        }\n+\n+        // Sort the simplex from best to worst.\n+        Arrays.sort(simplex, comparator);\n+    }\n+\n+    /**\n+     * Replace the worst point of the simplex by a new point.\n+     *\n+     * @param pointValuePair Point to insert.\n+     * @param comparator Comparator to use for sorting the simplex vertices\n+     * from best to worst.\n+     */\n+    protected void replaceWorstPoint(RealPointValuePair pointValuePair,\n+                                     final Comparator<RealPointValuePair> comparator) {\n+        for (int i = 0; i < dimension; i++) {\n+            if (comparator.compare(simplex[i], pointValuePair) > 0) {\n+                RealPointValuePair tmp = simplex[i];\n+                simplex[i] = pointValuePair;\n+                pointValuePair = tmp;\n+            }\n+        }\n+        simplex[dimension] = pointValuePair;\n+    }\n+\n+    /**\n+     * Get the points of the simplex.\n+     *\n+     * @return all the simplex points.\n+     */\n+    public RealPointValuePair[] getPoints() {\n+        final RealPointValuePair[] copy = new RealPointValuePair[simplex.length];\n+        System.arraycopy(simplex, 0, copy, 0, simplex.length);\n+        return copy;\n+    }\n+\n+    /**\n+     * Get the simplex point stored at the requested {@code index}.\n+     *\n+     * @param index Location.\n+     * @return the point at location {@code index}.\n+     */\n+    public RealPointValuePair getPoint(int index) {\n+        if (index < 0 ||\n+            index >= simplex.length) {\n+            throw new OutOfRangeException(index, 0, simplex.length - 1);\n+        }\n+        return simplex[index];\n+    }\n+\n+    /**\n+     * Store a new point at location {@code index}.\n+     * Note that no deep-copy of {@code point} is performed.\n+     *\n+     * @param index Location.\n+     * @param point New value.\n+     */\n+    protected void setPoint(int index, RealPointValuePair point) {\n+        if (index < 0 ||\n+            index >= simplex.length) {\n+            throw new OutOfRangeException(index, 0, simplex.length - 1);\n+        }\n+        simplex[index] = point;\n+    }\n+\n+    /**\n+     * Replace all points.\n+     * Note that no deep-copy of {@code points} is performed.\n+     *\n+     * @param points New Points.\n+     */\n+    protected void setPoints(RealPointValuePair[] points) {\n+        if (points.length != simplex.length) {\n+            throw new DimensionMismatchException(points.length, simplex.length);\n+        }\n+        simplex = points;\n+    }\n+\n+    /**\n+     * Create steps for a unit hypercube.\n+     *\n+     * @param n Dimension of the hypercube.\n+     * @return unit steps.\n+     */\n+    private static double[] createUnitHypercubeSteps(int n) {\n+        final double[] steps = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            steps[i] = 1;\n+        }\n+        return steps;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n  * @see MultiDirectional\n  * @version $Revision$ $Date$\n  * @since 1.2\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use {@link SimplexOptimizer} instead.\n  */\n public abstract class DirectSearchOptimizer\n     extends BaseAbstractScalarOptimizer<MultivariateRealFunction> {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n  *\n  * @version $Revision$ $Date$\n  * @see NelderMead\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use {@link MultiDirectionalSimplex} instead.\n  * @since 1.2\n  */\n public class MultiDirectional extends DirectSearchOptimizer\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/**\n+ * This class implements the multi-directional direct search method.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class MultiDirectionalSimplex extends AbstractSimplex {\n+    /** Default value for {@link #khi}: {@value}. */\n+    private static final double DEFAULT_KHI = 2;\n+    /** Default value for {@link #gamma}: {@value}. */\n+    private static final double DEFAULT_GAMMA = 0.5;\n+    /** Expansion coefficient. */\n+    private final double khi;\n+    /** Contraction coefficient. */\n+    private final double gamma;\n+\n+    /**\n+     * Build a multi-directional simplex with default coefficients.\n+     * The default values are 2.0 for khi and 0.5 for gamma.\n+     *\n+     * @param n Dimension of the simplex.\n+     */\n+    public MultiDirectionalSimplex(final int n) {\n+        this(n, DEFAULT_KHI, DEFAULT_GAMMA);\n+    }\n+\n+    /**\n+     * Build a multi-directional simplex with specified coefficients.\n+     *\n+     * @param n Dimension of the simplex. See\n+     * {@link AbstractSimplex#AbstractSimplex(int)}.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     */\n+    public MultiDirectionalSimplex(final int n,\n+                                   final double khi, final double gamma) {\n+        super(n);\n+\n+        this.khi   = khi;\n+        this.gamma = gamma;\n+    }\n+\n+    /**\n+     * Build a multi-directional simplex with default coefficients.\n+     * The default values are 2.0 for khi and 0.5 for gamma.\n+     *\n+     * @param steps Steps along the canonical axes representing box edges.\n+     * They may be negative but not zero. See\n+     */\n+    public MultiDirectionalSimplex(final double[] steps) {\n+        this(steps, DEFAULT_KHI, DEFAULT_GAMMA);\n+    }\n+\n+    /**\n+     * Build a multi-directional simplex with specified coefficients.\n+     *\n+     * @param steps Steps along the canonical axes representing box edges.\n+     * They may be negative but not zero. See\n+     * {@link AbstractSimplex#AbstractSimplex(double[])}.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     */\n+    public MultiDirectionalSimplex(final double[] steps,\n+                                   final double khi, final double gamma) {\n+        super(steps);\n+\n+        this.khi   = khi;\n+        this.gamma = gamma;\n+    }\n+\n+    /**\n+     * Build a multi-directional simplex with default coefficients.\n+     * The default values are 2.0 for khi and 0.5 for gamma.\n+     *\n+     * @param referenceSimplex Reference simplex. See\n+     * {@link AbstractSimplex#AbstractSimplex(double[][])}.\n+     */\n+    public MultiDirectionalSimplex(final double[][] referenceSimplex) {\n+        this(referenceSimplex, DEFAULT_KHI, DEFAULT_GAMMA);\n+    }\n+\n+    /**\n+     * Build a multi-directional simplex with specified coefficients.\n+     *\n+     * @param referenceSimplex Reference simplex. See\n+     * {@link AbstractSimplex#AbstractSimplex(double[][])}.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the reference simplex does not contain at least one point.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if there is a dimension mismatch in the reference simplex.\n+     */\n+    public MultiDirectionalSimplex(final double[][] referenceSimplex,\n+                                   final double khi, final double gamma) {\n+        super(referenceSimplex);\n+\n+        this.khi   = khi;\n+        this.gamma = gamma;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void iterate(final MultivariateRealFunction evaluationFunction,\n+                        final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException {\n+        // Save the original simplex.\n+        final RealPointValuePair[] original = getPoints();\n+        final RealPointValuePair best = original[0];\n+\n+        // Perform a reflection step.\n+        final RealPointValuePair reflected = evaluateNewSimplex(evaluationFunction,\n+                                                                original, 1, comparator);\n+        if (comparator.compare(reflected, best) < 0) {\n+            // Compute the expanded simplex.\n+            final RealPointValuePair[] reflectedSimplex = getPoints();\n+            final RealPointValuePair expanded = evaluateNewSimplex(evaluationFunction,\n+                                                                   original, khi, comparator);\n+            if (comparator.compare(reflected, expanded) <= 0) {\n+                // Keep the reflected simplex.\n+                setPoints(reflectedSimplex);\n+            }\n+            // Keep the expanded simplex.\n+            return;\n+        }\n+\n+        // Compute the contracted simplex.\n+        final RealPointValuePair contracted = evaluateNewSimplex(evaluationFunction,\n+                                                                 original, gamma, comparator);\n+    }\n+\n+    /**\n+     * Compute and evaluate a new simplex.\n+     *\n+     * @param evaluationFunction Evaluation function.\n+     * @param original Original simplex (to be preserved).\n+     * @param coeff Linear coefficient.\n+     * @param comparator Comparator to use to sort simplex vertices from best\n+     * to poorest.\n+     * @return the best point in the transformed simplex.\n+     * @throws FunctionEvaluationException if the function cannot be\n+     * evaluated at some point.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     */\n+    private RealPointValuePair evaluateNewSimplex(final MultivariateRealFunction evaluationFunction,\n+                                                  final RealPointValuePair[] original,\n+                                                  final double coeff,\n+                                                  final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException {\n+        final double[] xSmallest = original[0].getPointRef();\n+        // Perform a linear transformation on all the simplex points,\n+        // except the first one.\n+        setPoint(0, original[0]);\n+        final int dim = getDimension();\n+        for (int i = 1; i < getSize(); i++) {\n+            final double[] xOriginal = original[i].getPointRef();\n+            final double[] xTransformed = new double[dim];\n+            for (int j = 0; j < dim; j++) {\n+                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n+            }\n+            setPoint(i, new RealPointValuePair(xTransformed, Double.NaN, false));\n+        }\n+\n+        // Evaluate the simplex.\n+        evaluate(evaluationFunction, comparator);\n+\n+        return getPoint(0);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n  * @version $Revision$ $Date$\n  * @see MultiDirectional\n  * @since 1.2\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use {@link NelderMeadSimplex} instead.\n  */\n public class NelderMead extends DirectSearchOptimizer\n     implements MultivariateRealOptimizer {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/**\n+ * This class implements the Nelder-Mead simplex algorithm.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class NelderMeadSimplex extends AbstractSimplex {\n+    /** Default value for {@link #rho}: {@value}. */\n+    private static final double DEFAULT_RHO = 1;\n+    /** Default value for {@link #khi}: {@value}. */\n+    private static final double DEFAULT_KHI = 2;\n+    /** Default value for {@link #gamma}: {@value}. */\n+    private static final double DEFAULT_GAMMA = 0.5;\n+    /** Default value for {@link #sigma}: {@value}. */\n+    private static final double DEFAULT_SIGMA = 0.5;\n+    /** Reflection coefficient. */\n+    private final double rho;\n+    /** Expansion coefficient. */\n+    private final double khi;\n+    /** Contraction coefficient. */\n+    private final double gamma;\n+    /** Shrinkage coefficient. */\n+    private final double sigma;\n+\n+    /**\n+     * Build a Nelder-Mead simplex with default coefficients.\n+     * The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+     * for both gamma and sigma.\n+     *\n+     * @param n Dimension of the simplex.\n+     */\n+    public NelderMeadSimplex(final int n) {\n+        this(n, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA);\n+    }\n+\n+    /**\n+     * Build a Nelder-Mead simplex with specified coefficients.\n+     *\n+     * @param n Dimension of the simplex. See\n+     * {@link AbstractSimplex#AbstractSimplex(int)}.\n+     * @param rho Reflection coefficient.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @param sigma Shrinkage coefficient.\n+     */\n+    public NelderMeadSimplex(final int n,\n+                             final double rho, final double khi,\n+                             final double gamma, final double sigma) {\n+        super(n);\n+\n+        this.rho = rho;\n+        this.khi = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+    }\n+\n+    /**\n+     * Build a Nelder-Mead simplex with default coefficients.\n+     * The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+     * for both gamma and sigma.\n+     *\n+     * @param steps Steps along the canonical axes representing box edges.\n+     * They may be negative but not zero. See\n+     */\n+    public NelderMeadSimplex(final double[] steps) {\n+        this(steps, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA);\n+    }\n+\n+    /**\n+     * Build a Nelder-Mead simplex with specified coefficients.\n+     *\n+     * @param steps Steps along the canonical axes representing box edges.\n+     * They may be negative but not zero. See\n+     * {@link AbstractSimplex#AbstractSimplex(double[])}.\n+     * @param rho Reflection coefficient.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @param sigma Shrinkage coefficient.\n+     * @throws IllegalArgumentException if one of the steps is zero.\n+     */\n+    public NelderMeadSimplex(final double[] steps,\n+                             final double rho, final double khi,\n+                             final double gamma, final double sigma) {\n+        super(steps);\n+\n+        this.rho = rho;\n+        this.khi = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+    }\n+\n+    /**\n+     * Build a Nelder-Mead simplex with default coefficients.\n+     * The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+     * for both gamma and sigma.\n+     *\n+     * @param referenceSimplex Reference simplex. See\n+     * {@link AbstractSimplex#AbstractSimplex(double[][])}.\n+     */\n+    public NelderMeadSimplex(final double[][] referenceSimplex) {\n+        this(referenceSimplex, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA);\n+    }\n+\n+    /**\n+     * Build a Nelder-Mead simplex with specified coefficients.\n+     *\n+     * @param referenceSimplex Reference simplex. See\n+     * {@link AbstractSimplex#AbstractSimplex(double[][])}.\n+     * @param rho Reflection coefficient.\n+     * @param khi Expansion coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @param sigma Shrinkage coefficient.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the reference simplex does not contain at least one point.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if there is a dimension mismatch in the reference simplex.\n+     */\n+    public NelderMeadSimplex(final double[][] referenceSimplex,\n+                             final double rho, final double khi,\n+                             final double gamma, final double sigma) {\n+        super(referenceSimplex);\n+\n+        this.rho = rho;\n+        this.khi = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void iterate(final MultivariateRealFunction evaluationFunction,\n+                        final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException {\n+\n+        // The simplex has n + 1 points if dimension is n.\n+        final int n = getDimension();\n+\n+        // Interesting values.\n+        final RealPointValuePair best = getPoint(0);\n+        final RealPointValuePair secondBest = getPoint(n - 1);\n+        final RealPointValuePair worst = getPoint(n);\n+        final double[] xWorst = worst.getPointRef();\n+\n+        // Compute the centroid of the best vertices (dismissing the worst\n+        // point at index n).\n+        final double[] centroid = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            final double[] x = getPoint(i).getPointRef();\n+            for (int j = 0; j < n; j++) {\n+                centroid[j] += x[j];\n+            }\n+        }\n+        final double scaling = 1.0 / n;\n+        for (int j = 0; j < n; j++) {\n+            centroid[j] *= scaling;\n+        }\n+\n+        // compute the reflection point\n+        final double[] xR = new double[n];\n+        for (int j = 0; j < n; j++) {\n+            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n+        }\n+        final RealPointValuePair reflected\n+            = new RealPointValuePair(xR, evaluationFunction.value(xR), false);\n+\n+        if (comparator.compare(best, reflected) <= 0 &&\n+            comparator.compare(reflected, secondBest) < 0) {\n+            // Accept the reflected point.\n+            replaceWorstPoint(reflected, comparator);\n+        } else if (comparator.compare(reflected, best) < 0) {\n+            // Compute the expansion point.\n+            final double[] xE = new double[n];\n+            for (int j = 0; j < n; j++) {\n+                xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n+            }\n+            final RealPointValuePair expanded\n+                = new RealPointValuePair(xE, evaluationFunction.value(xE), false);\n+\n+            if (comparator.compare(expanded, reflected) < 0) {\n+                // Accept the expansion point.\n+                replaceWorstPoint(expanded, comparator);\n+            } else {\n+                // Accept the reflected point.\n+                replaceWorstPoint(reflected, comparator);\n+            }\n+        } else {\n+            if (comparator.compare(reflected, worst) < 0) {\n+                // Perform an outside contraction.\n+                final double[] xC = new double[n];\n+                for (int j = 0; j < n; j++) {\n+                    xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n+                }\n+                final RealPointValuePair outContracted\n+                    = new RealPointValuePair(xC, evaluationFunction.value(xC), false);\n+                if (comparator.compare(outContracted, reflected) <= 0) {\n+                    // Accept the contraction point.\n+                    replaceWorstPoint(outContracted, comparator);\n+                    return;\n+                }\n+            } else {\n+                // Perform an inside contraction.\n+                final double[] xC = new double[n];\n+                for (int j = 0; j < n; j++) {\n+                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n+                }\n+                final RealPointValuePair inContracted\n+                    = new RealPointValuePair(xC, evaluationFunction.value(xC), false);\n+\n+                if (comparator.compare(inContracted, worst) < 0) {\n+                    // Accept the contraction point.\n+                    replaceWorstPoint(inContracted, comparator);\n+                    return;\n+                }\n+            }\n+\n+            // Perform a shrink.\n+            final double[] xSmallest = getPoint(0).getPointRef();\n+            for (int i = 1; i <= n; i++) {\n+                final double[] x = getPoint(i).getPoint();\n+                for (int j = 0; j < n; j++) {\n+                    x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n+                }\n+                setPoint(i, new RealPointValuePair(x, Double.NaN, false));\n+            }\n+            evaluate(evaluationFunction, comparator);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * This class implements simplex-based direct search optimization.\n+ *\n+ * <p>\n+ *  Direct search methods only use objective function values, they do\n+ *  not need derivatives and don't either try to compute approximation\n+ *  of the derivatives. According to a 1996 paper by Margaret H. Wright\n+ *  (<a href=\"http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz\">Direct\n+ *  Search Methods: Once Scorned, Now Respectable</a>), they are used\n+ *  when either the computation of the derivative is impossible (noisy\n+ *  functions, unpredictable discontinuities) or difficult (complexity,\n+ *  computation cost). In the first cases, rather than an optimum, a\n+ *  <em>not too bad</em> point is desired. In the latter cases, an\n+ *  optimum is desired but cannot be reasonably found. In all cases\n+ *  direct search methods can be useful.\n+ * </p>\n+ * <p>\n+ *  Simplex-based direct search methods are based on comparison of\n+ *  the objective function values at the vertices of a simplex (which is a\n+ *  set of n+1 points in dimension n) that is updated by the algorithms\n+ *  steps.\n+ * <p>\n+ * <p>\n+ *  The {@link #setSimplex(AbstractSimplex) setSimplex} method <em>must</em>\n+ *  be called prior to calling the {@code optimize} method.\n+ * </p>\n+ * <p>\n+ *  Each call to {@link #optimize(MultivariateRealFunction,GoalType,double[])\n+ *  optimize} will re-use the start configuration of the current simplex and\n+ *  move it such that its first vertex is at the provided start point of the\n+ *  optimization. If the {@code optimize} method is called to solve a different\n+ *  problem and the number of parameters change, the simplex must be\n+ *  re-initialized to one with the appropriate dimensions.\n+ * </p>\n+ * <p>\n+ *  If {@link #setConvergenceChecker(ConvergenceChecker)} is not called,\n+ *  a default {@link SimpleScalarValueChecker} is used.\n+ * </p>\n+ * <p>\n+ *  Convergence is checked by providing the <em>worst</em> points of\n+ *  previous and current simplex to the convergence checker, not the best\n+ *  ones.\n+ * </p>\n+ *\n+ * @see AbstractSimplex\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class SimplexOptimizer\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction> {\n+    /** Simplex. */\n+    private AbstractSimplex simplex;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public SimplexOptimizer() {\n+        setConvergenceChecker(new SimpleScalarValueChecker());\n+    }\n+\n+    /**\n+     * @param rel Relative threshold.\n+     * @param abs Absolute threshold.\n+     */\n+    public SimplexOptimizer(double rel, double abs) {\n+        setConvergenceChecker(new SimpleScalarValueChecker(rel, abs));\n+    }\n+\n+    /**\n+     * Set the simplex algorithm.\n+     *\n+     * @param simplex Simplex.\n+     */\n+    public void setSimplex(AbstractSimplex simplex) {\n+        this.simplex = simplex;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException {\n+        if (simplex == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        // Indirect call to \"computeObjectiveValue\" in order to update the\n+        // evaluations counter.\n+        final MultivariateRealFunction evalFunc\n+            = new MultivariateRealFunction() {\n+                public double value(double[] point)\n+                    throws FunctionEvaluationException {\n+                    return computeObjectiveValue(point);\n+                }\n+            };\n+\n+        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n+        final Comparator<RealPointValuePair> comparator\n+            = new Comparator<RealPointValuePair>() {\n+            public int compare(final RealPointValuePair o1,\n+                               final RealPointValuePair o2) {\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        };\n+\n+        // Initialize search.\n+        simplex.build(getStartPoint());\n+        simplex.evaluate(evalFunc, comparator);\n+\n+        RealPointValuePair[] previous = null;\n+        int iteration = 0;\n+        final ConvergenceChecker<RealPointValuePair> checker = getConvergenceChecker();\n+        while (true) {\n+            if (iteration > 0) {\n+                boolean converged = true;\n+                for (int i = 0; i < simplex.getSize(); i++) {\n+                    converged &= checker.converged(iteration, previous[i], simplex.getPoint(i));\n+                }\n+                if (converged) {\n+                    // We have found an optimum.\n+                    return simplex.getPoint(0);\n+                }\n+            }\n+\n+            // We still need to search.\n+            previous = simplex.getPoints();\n+            simplex.iterate(evalFunc, comparator);\n+            ++iteration;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SimplexOptimizerMultiDirectionalTest {\n+    @Test\n+    public void testMinimizeMaximize() throws FunctionEvaluationException {\n+        // the following function has 4 local extrema:\n+        final double xM        = -3.841947088256863675365;\n+        final double yM        = -1.391745200270734924416;\n+        final double xP        =  0.2286682237349059125691;\n+        final double yP        = -yM;\n+        final double valueXmYm =  0.2373295333134216789769; // local  maximum\n+        final double valueXmYp = -valueXmYm;                // local  minimum\n+        final double valueXpYm = -0.7290400707055187115322; // global minimum\n+        final double valueXpYp = -valueXpYm;                // global maximum\n+        MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n+                private static final long serialVersionUID = -7039124064449091152L;\n+                public double value(double[] variables) throws FunctionEvaluationException {\n+                    final double x = variables[0];\n+                    final double y = variables[1];\n+                    return ((x == 0) || (y == 0)) ? 0 :\n+                        (FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y));\n+                }\n+            };\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n+        optimizer.setMaxEvaluations(200);\n+        optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n+        RealPointValuePair optimum;\n+\n+        // minimization\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n+        Assert.assertEquals(xM,        optimum.getPoint()[0], 4e-6);\n+        Assert.assertEquals(yP,        optimum.getPoint()[1], 3e-6);\n+        Assert.assertEquals(valueXmYp, optimum.getValue(),    8e-13);\n+        Assert.assertTrue(optimizer.getEvaluations() > 120);\n+        Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n+        Assert.assertEquals(xP,        optimum.getPoint()[0], 2e-8);\n+        Assert.assertEquals(yM,        optimum.getPoint()[1], 3e-6);\n+        Assert.assertEquals(valueXpYm, optimum.getValue(),    2e-12);\n+        Assert.assertTrue(optimizer.getEvaluations() > 120);\n+        Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+        // maximization\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+        Assert.assertEquals(xM,        optimum.getPoint()[0], 7e-7);\n+        Assert.assertEquals(yM,        optimum.getPoint()[1], 3e-7);\n+        Assert.assertEquals(valueXmYm, optimum.getValue(),    2e-14);\n+        Assert.assertTrue(optimizer.getEvaluations() > 120);\n+        Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1e-15, 1e-30));\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n+        Assert.assertEquals(xP,        optimum.getPoint()[0], 2e-8);\n+        Assert.assertEquals(yP,        optimum.getPoint()[1], 3e-6);\n+        Assert.assertEquals(valueXpYp, optimum.getValue(),    2e-12);\n+        Assert.assertTrue(optimizer.getEvaluations() > 180);\n+        Assert.assertTrue(optimizer.getEvaluations() < 220);\n+    }\n+\n+    @Test\n+    public void testRosenbrock() throws FunctionEvaluationException {\n+        MultivariateRealFunction rosenbrock =\n+            new MultivariateRealFunction() {\n+                private static final long serialVersionUID = -9044950469615237490L;\n+                public double value(double[] x) throws FunctionEvaluationException {\n+                    ++count;\n+                    double a = x[1] - x[0] * x[0];\n+                    double b = 1.0 - x[0];\n+                    return 100 * a * a + b * b;\n+                }\n+            };\n+\n+        count = 0;\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n+        optimizer.setMaxEvaluations(100);\n+        optimizer.setSimplex(new MultiDirectionalSimplex(new double[][] {\n+                    { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+                }));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n+\n+        Assert.assertEquals(count, optimizer.getEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 50);\n+        Assert.assertTrue(optimizer.getEvaluations() < 100);\n+        Assert.assertTrue(optimum.getValue() > 1e-2);\n+    }\n+\n+    @Test\n+    public void testPowell() throws FunctionEvaluationException {\n+        MultivariateRealFunction powell =\n+            new MultivariateRealFunction() {\n+                private static final long serialVersionUID = -832162886102041840L;\n+                public double value(double[] x) throws FunctionEvaluationException {\n+                    ++count;\n+                    double a = x[0] + 10 * x[1];\n+                    double b = x[2] - x[3];\n+                    double c = x[1] - 2 * x[2];\n+                    double d = x[0] - x[3];\n+                    return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+                }\n+            };\n+\n+        count = 0;\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n+        optimizer.setMaxEvaluations(1000);\n+        optimizer.setSimplex(new MultiDirectionalSimplex(4));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n+        Assert.assertEquals(count, optimizer.getEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 800);\n+        Assert.assertTrue(optimizer.getEvaluations() < 900);\n+        Assert.assertTrue(optimum.getValue() > 1e-2);\n+    }\n+\n+    @Test\n+    public void testMath283() throws FunctionEvaluationException {\n+        // fails because MultiDirectional.iterateSimplex is looping forever\n+        // the while(true) should be replaced with a convergence check\n+        SimplexOptimizer optimizer = new SimplexOptimizer();\n+        optimizer.setMaxEvaluations(1000);\n+        optimizer.setSimplex(new MultiDirectionalSimplex(2));\n+        final Gaussian2D function = new Gaussian2D(0, 0, 1);\n+        RealPointValuePair estimate = optimizer.optimize(function,\n+                                                         GoalType.MAXIMIZE, function.getMaximumPosition());\n+        final double EPSILON = 1e-5;\n+        final double expectedMaximum = function.getMaximum();\n+        final double actualMaximum = estimate.getValue();\n+        Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);\n+\n+        final double[] expectedPosition = function.getMaximumPosition();\n+        final double[] actualPosition = estimate.getPoint();\n+        Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n+        Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n+    }\n+\n+    private static class Gaussian2D implements MultivariateRealFunction {\n+        private final double[] maximumPosition;\n+        private final double std;\n+\n+        public Gaussian2D(double xOpt, double yOpt, double std) {\n+            maximumPosition = new double[] { xOpt, yOpt };\n+            this.std = std;\n+        }\n+\n+        public double getMaximum() {\n+            return value(maximumPosition);\n+        }\n+\n+        public double[] getMaximumPosition() {\n+            return maximumPosition.clone();\n+        }\n+\n+        public double value(double[] point) {\n+            final double x = point[0], y = point[1];\n+            final double twoS2 = 2.0 * std * std;\n+            return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2);\n+        }\n+    }\n+\n+    private int count;\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.LeastSquaresConverter;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.junit.Test;\n+import org.junit.Ignore;\n+\n+public class SimplexOptimizerNelderMeadTest {\n+    @Test\n+    public void testMinimizeMaximize()\n+        throws FunctionEvaluationException {\n+\n+        // the following function has 4 local extrema:\n+        final double xM        = -3.841947088256863675365;\n+        final double yM        = -1.391745200270734924416;\n+        final double xP        =  0.2286682237349059125691;\n+        final double yP        = -yM;\n+        final double valueXmYm =  0.2373295333134216789769; // local  maximum\n+        final double valueXmYp = -valueXmYm;                // local  minimum\n+        final double valueXpYm = -0.7290400707055187115322; // global minimum\n+        final double valueXpYp = -valueXpYm;                // global maximum\n+        MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n+                private static final long serialVersionUID = -7039124064449091152L;\n+                public double value(double[] variables) throws FunctionEvaluationException {\n+                    final double x = variables[0];\n+                    final double y = variables[1];\n+                    return (x == 0 || y == 0) ? 0 :\n+                        (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n+                }\n+            };\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setMaxEvaluations(100);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n+        RealPointValuePair optimum;\n+\n+        // minimization\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n+        assertEquals(xM,        optimum.getPoint()[0], 2e-7);\n+        assertEquals(yP,        optimum.getPoint()[1], 2e-5);\n+        assertEquals(valueXmYp, optimum.getValue(),    6e-12);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n+        assertEquals(xP,        optimum.getPoint()[0], 5e-6);\n+        assertEquals(yM,        optimum.getPoint()[1], 6e-6);\n+        assertEquals(valueXpYm, optimum.getValue(),    1e-11);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+\n+        // maximization\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 });\n+        assertEquals(xM,        optimum.getPoint()[0], 1e-5);\n+        assertEquals(yM,        optimum.getPoint()[1], 3e-6);\n+        assertEquals(valueXmYm, optimum.getValue(),    3e-12);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n+        assertEquals(xP,        optimum.getPoint()[0], 4e-6);\n+        assertEquals(yP,        optimum.getPoint()[1], 5e-6);\n+        assertEquals(valueXpYp, optimum.getValue(),    7e-12);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+    }\n+\n+    @Test\n+    public void testRosenbrock()\n+        throws FunctionEvaluationException {\n+\n+        Rosenbrock rosenbrock = new Rosenbrock();\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n+        optimizer.setMaxEvaluations(100);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+                    { -1.2,  1 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+                }));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n+\n+        assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+        assertTrue(optimizer.getEvaluations() > 40);\n+        assertTrue(optimizer.getEvaluations() < 50);\n+        assertTrue(optimum.getValue() < 8e-4);\n+    }\n+\n+    @Test\n+    public void testPowell()\n+        throws FunctionEvaluationException {\n+\n+        Powell powell = new Powell();\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n+        optimizer.setMaxEvaluations(200);\n+        optimizer.setSimplex(new NelderMeadSimplex(4));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n+        assertEquals(powell.getCount(), optimizer.getEvaluations());\n+        assertTrue(optimizer.getEvaluations() > 110);\n+        assertTrue(optimizer.getEvaluations() < 130);\n+        assertTrue(optimum.getValue() < 2e-3);\n+    }\n+\n+    @Test\n+    public void testLeastSquares1()\n+        throws FunctionEvaluationException {\n+\n+        final RealMatrix factors =\n+            new Array2DRowRealMatrix(new double[][] {\n+                    { 1, 0 },\n+                    { 0, 1 }\n+                }, false);\n+        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+                public double[] value(double[] variables) {\n+                    return factors.operate(variables);\n+                }\n+            }, new double[] { 2.0, -3.0 });\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n+        optimizer.setMaxEvaluations(200);\n+        optimizer.setSimplex(new NelderMeadSimplex(2));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n+        assertEquals( 2, optimum.getPointRef()[0], 3e-5);\n+        assertEquals(-3, optimum.getPointRef()[1], 4e-4);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 80);\n+        assertTrue(optimum.getValue() < 1.0e-6);\n+    }\n+\n+    @Test\n+    public void testLeastSquares2()\n+        throws FunctionEvaluationException {\n+\n+        final RealMatrix factors =\n+            new Array2DRowRealMatrix(new double[][] {\n+                    { 1, 0 },\n+                    { 0, 1 }\n+                }, false);\n+        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+                public double[] value(double[] variables) {\n+                    return factors.operate(variables);\n+                }\n+            }, new double[] { 2, -3 }, new double[] { 10, 0.1 });\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n+        optimizer.setMaxEvaluations(200);\n+        optimizer.setSimplex(new NelderMeadSimplex(2));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n+        assertEquals( 2, optimum.getPointRef()[0], 5e-5);\n+        assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 80);\n+        assertTrue(optimum.getValue() < 1e-6);\n+    }\n+\n+    @Test\n+    public void testLeastSquares3()\n+        throws FunctionEvaluationException {\n+\n+        final RealMatrix factors =\n+            new Array2DRowRealMatrix(new double[][] {\n+                    { 1, 0 },\n+                    { 0, 1 }\n+                }, false);\n+        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+                public double[] value(double[] variables) {\n+                    return factors.operate(variables);\n+                }\n+            }, new double[] { 2, -3 }, new Array2DRowRealMatrix(new double [][] {\n+                    { 1, 1.2 }, { 1.2, 2 }\n+                }));\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n+        optimizer.setMaxEvaluations(200);\n+        optimizer.setSimplex(new NelderMeadSimplex(2));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n+        assertEquals( 2, optimum.getPointRef()[0], 2e-3);\n+        assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 80);\n+        assertTrue(optimum.getValue() < 1e-6);\n+    }\n+\n+    @Test(expected = TooManyEvaluationsException.class)\n+    public void testMaxIterations() throws FunctionEvaluationException {\n+        Powell powell = new Powell();\n+        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n+        optimizer.setMaxEvaluations(20);\n+        optimizer.setSimplex(new NelderMeadSimplex(4));\n+        optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n+    }\n+\n+    private static class Rosenbrock implements MultivariateRealFunction {\n+        private int count;\n+\n+        public Rosenbrock() {\n+            count = 0;\n+        }\n+\n+        public double value(double[] x) throws FunctionEvaluationException {\n+            ++count;\n+            double a = x[1] - x[0] * x[0];\n+            double b = 1.0 - x[0];\n+            return 100 * a * a + b * b;\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    private static class Powell implements MultivariateRealFunction {\n+        private int count;\n+\n+        public Powell() {\n+            count = 0;\n+        }\n+\n+        public double value(double[] x) throws FunctionEvaluationException {\n+            ++count;\n+            double a = x[0] + 10 * x[1];\n+            double b = x[2] - x[3];\n+            double c = x[1] - 2 * x[2];\n+            double d = x[0] - x[3];\n+            return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+}", "timestamp": 1287999753, "metainfo": ""}