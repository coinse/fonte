{"sha": "34fef656d03a5ba75047a55a894f6f72cbe59f2e", "log": "MATH-621  Change history:  Constants in procedures replaced by static final fields.  NF eliminated (function evaluation counting is done in base class).  MAXFUN eliminated (exception is thrown by base class).  -1e300 replaced by NEGATIVE_INFINITY.  1e300 replaced by POSITIVE_INFINITY.  Number of interpolation points set at construction (no automatic default to \"2n+1\" if set to \"-1\").  Replaced \"checkParameters()\" with \"setup()\" and moved validity checks from \"doOptimize()\" to \"setup()\".  Replaced \"boundaries[][]\" with two \"double[]\" for the constraints.  Removed unit test \"testBoundariesNoData\" (\"null\" is interpreted as \"no constraints\").  Replaced \"xl\" and \"xu\" with \"lowerBound\" and \"upperBound\", respectively (Fortran 1-based indexing still used).  Replaced \"x\" with \"currentBest\".  Replaced \"rhobeg\" with \"initialTrustRegionRadius\". Using instance field directly instead of passing it as function argument.  Replaced \"rhoend\" with \"stoppingTrustRegionRadius\". Using instance field directly instead of passing it as function argument.  Removed all parameters from \"bobyqa\" function (using instance fields directly).  Removed (from \"bobyqa\" function) a test on the bound difference: It would never fail because of the auto-correction in \"setup\".  Replaced \"ScopedPtr\" by \"FortranArray\" for all one-dimensional data.  0-based loop in \"bobyqa\".  Replaced \"ScopedPtr\" by \"FortranMatrix\" for all matrix data.  Loop-local counters in all functions.  Replaced kopt with \"trustRegionCenterInterpolationPointIndex\" instance variable.  Removed \"ndim\", \"n\" and \"npt\" from the arguments list of all functions.  Removed \"w\" from the arguments list of \"update\".  Removed \"w\" from the arguments list of \"altmov\" (replaced with local variables \"work1\" and \"work2\").  In \"trsbox\" arguments list, replaced \"ScopedPtr\" (\"gnew\", \"xbdi\", \"s\", \"hs\", \"hred\") by \"FortranArray\".  Removed \"ptsaux\", \"ptsid\" from arguments list of \"rescue\" (replaced with local variables).  Corrected bug in \"rescue\" function.  Removed \"w\" from arguments list of \"rescue\".  Removed \"glag\" and \"hcol\" from arguments list of \"altmov\" (replaced by local variables).  Removed \"w\" from arguments list of \"bobyqb\" (replaced by local variables).  Removed global work space \"w\".  Removed auxiliary class \"ScopedPtr\".  Removed \"alpha\" and \"cauchy\" (\"DoubleRef\") in \"altmov\" arguments list: Values returned in a \"double[]\" array.  Removed \"dsq\" and \"crvmin\" (\"DoubleRef\") in \"trsbox\" arguments list: Values returned in a \"double[]\" array.  Removed \"DoubleRef\" auxiliary class.  Removed unused local variables; changed some to be \"final\".  This is still an intermediate version. Please do not commit any changes without discussing it on JIRA.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.MultiDimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n \n /**\n- * BOBYQA algorithm. This code is translated and adapted from the Fortran version\n- * of this algorithm as implemented in http://plato.asu.edu/ftp/other_software/bobyqa.zip .\n- * <em>http://</em>. <br>\n- * See <em>http://www.optimization-online.org/DB_HTML/2010/05/2616.html</em>\n- * for an introduction.\n+ * Powell's BOBYQA algorithm. This implementation is translated and\n+ * adapted from the Fortran version available\n+ * <a href=\"http://plato.asu.edu/ftp/other_software/bobyqa.zip\">here</a>.\n+ * See <a href=\"http://www.optimization-online.org/DB_HTML/2010/05/2616.html\">\n+ * this paper</a> for an introduction.\n+ * <br/>\n+ * BOBYQA is particularly well suited for high dimensional problems\n+ * where derivatives are not available. In most cases it outperforms the\n+ * {@link PowellOptimizer} significantly. Stochastic algorithms like\n+ * {@link CMAESOptimizer} succeed more often than BOBYQA, but are more\n+ * expensive. BOBYQA could also be considered as a replacement of any\n+ * derivative-based optimizer when the derivatives are approximated by\n+ * finite differences.\n  *\n- * <p>BOBYQA is particularly well suited for high dimensional problems\n- * where derivatives are not available. In most cases it outperforms the\n- * PowellOptimizer significantly. Stochastic algorithms like CMAESOptimizer\n- * succeed more often than BOBYQA, but are more expensive. BOBYQA could\n- * also be considered if you currently use a derivative based (Differentiable)\n- * optimizer approximating the derivatives by finite differences.\n- *\n- * Comments of the subroutines were copied directly from the original sources.\n- *\n- * @version $Revision$ $Date$\n+ * @version $Id$\n  * @since 3.0\n  */\n-\n-public class BOBYQAOptimizer extends\n-BaseAbstractScalarOptimizer<MultivariateRealFunction> implements\n-MultivariateRealOptimizer {\n-\n+public class BOBYQAOptimizer\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    implements MultivariateRealOptimizer {\n+    private static final double ZERO = 0d;\n+    private static final double ONE = 1d;\n+    private static final double TWO = 2d;\n+    private static final double TEN = 10d;\n+    private static final double SIXTEEN = 16d;\n+    private static final double TWO_HUNDRED_FIFTY = 250d;\n+    private static final double MINUS_ONE = -ONE;\n+    private static final double HALF = ONE / 2;\n+    private static final double ONE_OVER_FOUR = ONE / 4;\n+    private static final double ONE_OVER_EIGHT = ONE / 8;\n+    private static final double ONE_OVER_TEN = ONE / 10;\n+    private static final double ONE_OVER_A_THOUSAND = ONE / 1000;\n+\n+    /** Minimum dimension of the problem: {@value} */\n+    public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n     /** Default value for {@link #initialTrustRegionRadius}: {@value} . */\n     public static final double DEFAULT_INITIAL_RADIUS = 10.0;\n     /** Default value for {@link #stoppingTrustRegionRadius}: {@value} . */\n     public static final double DEFAULT_STOPPING_RADIUS = 1E-8;\n \n     /**\n-     * numberOfInterpolationPoints\n+     * numberOfInterpolationPoints XXX\n      */\n-    private int numberOfInterpolationPoints;\n+    private final int numberOfInterpolationPoints;\n     /**\n-     * initialTrustRegionRadius;\n+     * initialTrustRegionRadius XXX\n      */\n     private double initialTrustRegionRadius;\n     /**\n-     * stoppingTrustRegionRadius;\n+     * stoppingTrustRegionRadius XXX\n      */\n-    private double stoppingTrustRegionRadius;\n+    private final double stoppingTrustRegionRadius;\n     /**\n-     * Lower and upper boundaries of the objective variables. boundaries == null\n-     * means no boundaries.\n+     * Lower bounds of the objective variables.\n+     * {@code null} means no bounds.\n+     * XXX Should probably be passed to the \"optimize\" method (overload not existing yet).\n      */\n-    private double[][] boundaries;\n-    /** Number of objective variables/problem dimension */\n-    private int dimension;\n-    /** goal (minimize or maximize) */\n-    private boolean isMinimize = true;\n-\n+    private double[] lowerBound;\n     /**\n-     * Default constructor, uses default parameters\n+     * Upper bounds of the objective variables.\n+     * {@code null} means no bounds.\n+     * XXX Should probably be passed to the \"optimize\" method (overload not existing yet).\n      */\n-    public BOBYQAOptimizer() {\n-        this(null);\n+    private double[] upperBound;\n+\n+    /** Goal type (minimize or maximize). */\n+    private boolean isMinimize;\n+    /**\n+     * Current best values for the variables to be optimized.\n+     * The vector will be changed in-place to contain the values of the least\n+     * calculated objective function values.\n+     */\n+    private ArrayRealVector currentBest;\n+    /** Differences between the upper and lower bounds. */\n+    private double[] boundDifference;\n+    /**\n+     * Index of the interpolation point at the trust region center.\n+     */\n+    private int trustRegionCenterInterpolationPointIndex;\n+\n+    /**\n+     * @param numberOfInterpolationPoints Number of interpolation conditions.\n+     * For a problem of dimension {@code n}, its value must be in the interval\n+     * {@code [n+2, (n+1)(n+2)/2]}.\n+     * Choices that exceed {@code 2n+1} are not recommended.\n+     */\n+    public BOBYQAOptimizer(int numberOfInterpolationPoints) {\n+        this(numberOfInterpolationPoints, null, null);\n     }\n \n     /**\n-     * @param boundaries\n-     *             Boundaries for objective variables.\n+     * @param numberOfInterpolationPoints Number of interpolation conditions.\n+     * For a problem of dimension {@code n}, its value must be in the interval\n+     * {@code [n+2, (n+1)(n+2)/2]}.\n+     * Choices that exceed {@code 2n+1} are not recommended.\n+     * @param lowerBound Lower bounds (constraints) of the objective variables.\n+     * @param upperBound Upperer bounds (constraints) of the objective variables.\n      */\n-    public BOBYQAOptimizer(double[][] boundaries) {\n-        this(boundaries, -1, DEFAULT_INITIAL_RADIUS,\n-                DEFAULT_STOPPING_RADIUS);\n+    public BOBYQAOptimizer(int numberOfInterpolationPoints,\n+                           double[] lowerBound,\n+                           double[] upperBound) {\n+        this(numberOfInterpolationPoints,\n+             lowerBound,\n+             upperBound,\n+             DEFAULT_INITIAL_RADIUS,\n+             DEFAULT_STOPPING_RADIUS);\n     }\n \n     /**\n-     * @param boundaries\n-     *            Boundaries for objective variables.\n-     * @param numberOfInterpolationPoints\n-     *            number of interpolation conditions. Its value must be for\n-     *            dimension=N in the interval [N+2,(N+1)(N+2)/2]. Choices that\n-     *            exceed 2*N+1 are not recommended. -1 means undefined, then\n-     *            2*N+1 is used as default.\n-     * @param initialTrustRegionRadius\n-     *            initial trust region radius.\n-     * @param stoppingTrustRegionRadius\n-     *            stopping trust region radius.\n+     * @param numberOfInterpolationPoints Number of interpolation conditions.\n+     * For a problem of dimension {@code n}, its value must be in the interval\n+     * {@code [n+2, (n+1)(n+2)/2]}.\n+     * Choices that exceed {@code 2n+1} are not recommended.\n+     * @param lowerBound Lower bounds (constraints) of the objective variables.\n+     * @param upperBound Upperer bounds (constraints) of the objective variables.\n+     * @param initialTrustRegionRadius Initial trust region radius.\n+     * @param stoppingTrustRegionRadius Stopping trust region radius.\n      */\n-    public BOBYQAOptimizer(double[][] boundaries,\n-            int numberOfInterpolationPoints, double initialTrustRegionRadius,\n-            double stoppingTrustRegionRadius) {\n-        this.boundaries = boundaries;\n+    public BOBYQAOptimizer(int numberOfInterpolationPoints,\n+                           double[] lowerBound,\n+                           double[] upperBound,\n+                           double initialTrustRegionRadius,\n+                           double stoppingTrustRegionRadius) {\n+        this.lowerBound = lowerBound == null ? null : MathUtils.copyOf(lowerBound);\n+        this.upperBound = upperBound == null ? null : MathUtils.copyOf(upperBound);\n         this.numberOfInterpolationPoints = numberOfInterpolationPoints;\n         this.initialTrustRegionRadius = initialTrustRegionRadius;\n         this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n     /** {@inheritDoc} */\n     @Override\n     protected RealPointValuePair doOptimize() {\n-        // -------------------- Initialization --------------------------------\n-        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n-        final double[] guess = getStartPoint();\n-        // number of objective variables/problem dimension\n-        dimension = guess.length;\n-        checkParameters();\n-        if (numberOfInterpolationPoints < 0)\n-            numberOfInterpolationPoints = 2 * dimension + 1;\n-        ScopedPtr x = new ScopedPtr(guess.clone(), 0);\n-        ScopedPtr xl;\n-        ScopedPtr xu;\n-        if (boundaries != null) {\n-            xl = new ScopedPtr(boundaries[0].clone(), 0);\n-            xu = new ScopedPtr(boundaries[1].clone(), 0);\n-            double minDiff = Double.MAX_VALUE;\n-            for (int i = 0; i < dimension; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                minDiff = Math.min(minDiff, diff);\n-            }\n-            if (minDiff < 2 * initialTrustRegionRadius)\n-                initialTrustRegionRadius = minDiff / 3.0;\n-        } else {\n-            xl = new ScopedPtr(point(dimension, -1e300), 0);\n-            xu = new ScopedPtr(point(dimension, 1e300), 0);\n-        }\n-        double value = bobyqa(dimension, numberOfInterpolationPoints, x, xl,\n-                xu, initialTrustRegionRadius, stoppingTrustRegionRadius,\n-                getMaxEvaluations());\n-        return new RealPointValuePair(x.getAll(), isMinimize ? value : -value);\n+        // Validity checks.\n+        setup();\n+\n+        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n+        currentBest = new ArrayRealVector(getStartPoint());\n+\n+        final double value = bobyqa();\n+\n+        return new RealPointValuePair(currentBest.getDataRef(),\n+                                      isMinimize ? value : -value);\n     }\n \n     /**\n      *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.\n      *     The array W will be used for working space. Its length must be at least\n      *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.\n-     * @param n\n-     * @param npt\n-     * @param x\n-     * @param xl\n-     * @param xu\n-     * @param rhobeg\n-     * @param rhoend\n-     * @param maxfun\n      * @return\n      */\n-    private double bobyqa(\n-            int n,\n-            int npt,\n-            ScopedPtr x,\n-            ScopedPtr xl,\n-            ScopedPtr xu,\n-            double rhobeg,\n-            double rhoend,\n-            int maxfun\n-    ) {\n-\n-        ScopedPtr w = new ScopedPtr(new double[(npt+5)*(npt+n)+3*n*(n+5)/2],0);\n-\n-        // System generated locals\n-        int i__1;\n-        double d__1, d__2;\n-\n-        // Local variables\n-        int j, id_, np, iw, igo, ihq, ixb, ixa, ifv, isl, jsl, ipq, ivl, ixn, ixo, ixp, isu, jsu, ndim;\n-        double temp, zero;\n-        int ibmat, izmat;\n-\n-        // Parameter adjustments\n-        w = w.ptr(-1);\n-        xu = xu.ptr(-1);\n-        xl = xl.ptr(-1);\n-        x = x.ptr(-1);\n-\n-        // Function Body\n-        np = n + 1;\n-\n-        // Return if the value of NPT is unacceptable.\n-        if (npt < n + 2 || npt > (n + 2) * np / 2)\n-            throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS, npt);\n+    private double bobyqa() {\n+        // System.out.println(\"bobyqa\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+\n+        final int np = n + 1;\n+        final int ndim = npt + n;\n \n         // Partition the working space array, so that different parts of it can\n         // be treated separately during the calculation of BOBYQB. The partition\n         // requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the\n         // space that is taken by the last array in the argument list of BOBYQB.\n \n-        ndim = npt + n;\n-        ixb = 1;\n-        ixp = ixb + n;\n-        ifv = ixp + n * npt;\n-        ixo = ifv + npt;\n-        igo = ixo + n;\n-        ihq = igo + n;\n-        ipq = ihq + n * np / 2;\n-        ibmat = ipq + npt;\n-        izmat = ibmat + ndim * n;\n-        isl = izmat+ npt * (npt - np);\n-        isu = isl + n;\n-        ixn = isu + n;\n-        ixa = ixn + n;\n-        id_ = ixa + n;\n-        ivl = id_ + n;\n-        iw = ivl + ndim;\n+        final FortranArray xbase = new FortranArray(n);\n+        final FortranMatrix xpt = new FortranMatrix(npt, n);\n+        final FortranArray fval = new FortranArray(npt);\n+        final FortranArray xopt = new FortranArray(n);\n+        final FortranArray gopt = new FortranArray(n);\n+        final FortranArray hq = new FortranArray(n * np / 2);\n+        final FortranArray pq = new FortranArray(npt);\n+        final FortranMatrix bmat = new FortranMatrix(ndim, n);\n+        final FortranMatrix zmat = new FortranMatrix(npt, (npt - np));\n+        final ArrayRealVector sl = new ArrayRealVector(n);\n+        final ArrayRealVector su = new ArrayRealVector(n);\n+        final FortranArray xnew = new FortranArray(n);\n+        final FortranArray xalt = new FortranArray(n);\n+        final FortranArray d__ = new FortranArray(n);\n+        final FortranArray vlag = new FortranArray(ndim);\n \n         // Return if there is insufficient space between the bounds. Modify the\n         // initial X if necessary in order to avoid conflicts between the bounds\n         // partitions of W, in order to provide useful and exact information about\n         // components of X that become within distance RHOBEG from their bounds.\n \n-        zero = 0.;\n-        i__1 = n;\n-        for (j = 1; j <= i__1; j++) {\n-            temp = xu.get(j) - xl.get(j);\n-            if (temp < rhobeg + rhobeg) {\n-                throw new NumberIsTooSmallException(temp, rhobeg + rhobeg, true);\n-            }\n-            jsl = isl + j - 1;\n-            jsu = jsl + n;\n-            w.set(jsl, xl.get(j) - x.get(j));\n-            w.set(jsu, xu.get(j) - x.get(j));\n-            if (w.get(jsl) >= -rhobeg) {\n-                if (w.get(jsl) >= zero) {\n-                    x.set(j, xl.get(j));\n-                    w.set(jsl, zero);\n-                    w.set(jsu, temp);\n+        for (int j = 0; j < n; j++) {\n+            final double boundDiff = boundDifference[j];\n+            sl.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n+            su.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n+            if (sl.getEntry(j) >= -initialTrustRegionRadius) {\n+                if (sl.getEntry(j) >= ZERO) {\n+                    currentBest.setEntry(j, lowerBound[j]);\n+                    sl.setEntry(j, ZERO);\n+                    su.setEntry(j, boundDiff);\n                 } else {\n-                    x.set(j, xl.get(j) + rhobeg);\n-                    w.set(jsl, -rhobeg);\n+                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n+                    sl.setEntry(j, -initialTrustRegionRadius);\n                     // Computing MAX\n-                    d__1 = xu.get(j) - x.get(j);\n-                    w.set(jsu, Math.max(d__1,rhobeg));\n-                }\n-            } else if (w.get(jsu) <= rhobeg) {\n-                if (w.get(jsu) <= zero) {\n-                    x.set(j, xu.get(j));\n-                    w.set(jsl, -temp);\n-                    w.set(jsu, zero);\n+                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n+                    su.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n+                }\n+            } else if (su.getEntry(j) <= initialTrustRegionRadius) {\n+                if (su.getEntry(j) <= ZERO) {\n+                    currentBest.setEntry(j, upperBound[j]);\n+                    sl.setEntry(j, -boundDiff);\n+                    su.setEntry(j, ZERO);\n                 } else {\n-                    x.set(j, xu.get(j) - rhobeg);\n+                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                     // Computing MIN\n-                    d__1 = xl.get(j) - x.get(j);\n-                    d__2 = -rhobeg;\n-                    w.set(jsl, Math.min(d__1,d__2));\n-                    w.set(jsu, rhobeg);\n+                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n+                    final double deltaTwo = -initialTrustRegionRadius;\n+                    sl.setEntry(j, Math.min(deltaOne, deltaTwo));\n+                    su.setEntry(j, initialTrustRegionRadius);\n                 }\n             }\n         }\n \n         // Make the call of BOBYQB.\n \n-        return bobyqb(n, npt, x, xl, xu, rhobeg, rhoend, maxfun,\n-                w.ptr(ixb-1), w.ptr(ixp-npt-1), w.ptr(ifv-1), w.ptr(ixo-1), w.ptr(igo-1), w.ptr(ihq-1), w.ptr(ipq-1),\n-                w.ptr(ibmat-ndim-1), w.ptr(izmat-npt-1), ndim, w.ptr(isl-1), w.ptr(isu-1), w.ptr(ixn-1), w.ptr(ixa-1),\n-                w.ptr(id_-1), w.ptr(ivl-1), w.ptr(iw-1));\n+        return bobyqb(xbase,\n+                      xpt,\n+                      fval,\n+                      xopt,\n+                      gopt,\n+                      hq,\n+                      pq,\n+                      bmat,\n+                      zmat,\n+                      new FortranArray(sl),\n+                      new FortranArray(su),\n+                      xnew,\n+                      xalt,\n+                      d__,\n+                      vlag);\n     } // bobyqa\n \n     // ----------------------------------------------------------------------------------------\n      *     W is a one-dimensional array that is used for working space. Its length\n      *       must be at least 3*NDIM = 3*(NPT+N).\n      *\n-     * @param n\n-     * @param npt\n-     * @param x\n-     * @param xl\n-     * @param xu\n-     * @param rhobeg\n-     * @param rhoend\n-     * @param maxfun\n      * @param xbase\n      * @param xpt\n      * @param fval\n      * @param pq\n      * @param bmat\n      * @param zmat\n-     * @param ndim\n      * @param sl\n      * @param su\n      * @param xnew\n      * @param xalt\n      * @param d__\n      * @param vlag\n-     * @param w\n      * @return\n      */\n     private double bobyqb(\n-            int n,\n-            int npt,\n-            ScopedPtr x,\n-            ScopedPtr xl,\n-            ScopedPtr xu,\n-            double rhobeg,\n-            double rhoend,\n-            int maxfun,\n-            ScopedPtr xbase, \n-            ScopedPtr xpt,\n-            ScopedPtr fval,\n-            ScopedPtr xopt,\n-            ScopedPtr gopt,\n-            ScopedPtr hq,\n-            ScopedPtr pq,\n-            ScopedPtr bmat,\n-            ScopedPtr zmat,\n-            int ndim,\n-            ScopedPtr sl,\n-            ScopedPtr su, \n-            ScopedPtr xnew,\n-            ScopedPtr xalt,\n-            ScopedPtr d__,\n-            ScopedPtr vlag,\n-            ScopedPtr w\n+            FortranArray xbase, \n+            FortranMatrix xpt,\n+            FortranArray fval,\n+            FortranArray xopt,\n+            FortranArray gopt,\n+            FortranArray hq,\n+            FortranArray pq,\n+            FortranMatrix bmat,\n+            FortranMatrix zmat,\n+            FortranArray sl,\n+            FortranArray su,\n+            FortranArray xnew,\n+            FortranArray xalt,\n+            FortranArray d__,\n+            FortranArray vlag\n     ) {\n+        // System.out.println(\"bobyqb\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+        final int ndim = bmat.getRowDimension();\n+        final int np = n + 1;\n+        final int nptm = npt - np;\n+        final int nh = n * np / 2;\n+\n+        final FortranArray work1 = new FortranArray(n);\n+        final FortranArray work2 = new FortranArray(npt);\n+        final FortranArray work3 = new FortranArray(npt);\n+\n+        double cauchy = Double.NaN;\n+        double alpha = Double.NaN;\n+        double dsq = Double.NaN;\n+        double crvmin = Double.NaN;\n+\n         // System generated locals\n-        int xpt_dim1, bmat_dim1, zmat_dim1; \n-        int i__1, i__2, i__3;\n+        int xpt_offset;\n         double d__1, d__2, d__3, d__4;\n \n         // Local variables\n         double f = 0;\n-        int i__, j, k, ih, jj, nh, ip, jp;\n+        int ih, ip, jp;\n         double dx;\n-        int np;\n-        double den = 0, one = 0, ten = 0, rho = 0, sum = 0, two = 0, diff = 0, half = 0, beta = 0, gisq = 0;\n+        double den = 0, rho = 0, sum = 0, diff = 0, beta = 0, gisq = 0;\n         int knew = 0;\n         double temp, suma, sumb, bsum, fopt;\n-        int nptm;\n-        double zero, curv;\n+        double curv;\n         int ksav;\n         double gqsq = 0, dist = 0, sumw = 0, sumz = 0, diffa = 0, diffb = 0, diffc = 0, hdiag = 0;\n         int kbase;\n         double delta = 0, adelt = 0, denom = 0, fsave = 0, bdtol = 0, delsq = 0;\n         int nresc, nfsav;\n-        double ratio = 0, dnorm = 0, vquad = 0, pqold = 0, tenth = 0;\n+        double ratio = 0, dnorm = 0, vquad = 0, pqold = 0;\n         int itest;\n         double sumpq, scaden;\n         double errbig, fracsq, biglsq, densav;\n         double frhosq;\n         double distsq = 0;\n         int ntrits;\n-        double xoptsq;\n \n         // Set some constants.\n         // Parameter adjustments\n-        zmat_dim1 = npt;\n-        xpt_dim1 = npt;\n-        bmat_dim1 = ndim;\n- \n+\n         // Function Body\n-        half = .5;\n-        one = 1.;\n-        ten = 10.;\n-        tenth = .1;\n-        two = 2.;\n-        zero = 0.;\n-        np = n + 1;\n-        nptm = npt - np;\n-        nh = n * np / 2;\n \n         // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n         // BMAT and ZMAT for the first iteration, with the corresponding values of\n         // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n         // less than NPT. GOPT will be updated if KOPT is different from KBASE.\n \n-        IntRef nf = new IntRef(0);\n-        IntRef kopt = new IntRef(0);\n-        DoubleRef dsq = new DoubleRef(0);\n-        DoubleRef crvmin = new DoubleRef(0);\n-        DoubleRef cauchy = new DoubleRef(0);\n-        DoubleRef alpha = new DoubleRef(0);\n-\n-        prelim(n, npt, x, xl, xu, rhobeg, maxfun, xbase,\n-                xpt, fval, gopt, hq, pq, bmat,\n-                zmat, ndim, sl, su, nf, kopt);\n-        xoptsq = zero;\n-        i__1 = n;\n-        for (i__ = 1; i__ <= i__1; i__++) {\n-            xopt.set(i__, xpt.get(kopt.value + i__ * xpt_dim1));\n+        trustRegionCenterInterpolationPointIndex = 0;\n+\n+        prelim(currentBest, xbase,\n+               xpt, fval, gopt, hq, pq, bmat,\n+                zmat, sl, su);\n+        double xoptsq = ZERO;\n+        for (int i = 1; i <= n; i++) {\n+            xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n             // Computing 2nd power\n-            d__1 = xopt.get(i__);\n-            xoptsq += d__1 * d__1;\n-        }\n-        fsave = fval.get(1);\n-        if (nf.value < npt) { // should not happen\n-            throw new RuntimeException(\"Return from BOBYQA because the objective function has been called \" +\n-                    nf.value + \" times.\");\n-        }\n+            final double deltaOne = xopt.getEntry(i);\n+            xoptsq += deltaOne * deltaOne;\n+        }\n+        fsave = fval.getEntry(1);\n         kbase = 1;\n \n         // Complete the settings that are required for the iterative procedure.\n \n-        rho = rhobeg;\n+        rho = initialTrustRegionRadius;\n         delta = rho;\n-        nresc = nf.value;\n+        nresc = getEvaluations();\n         ntrits = 0;\n-        diffa = zero;\n-        diffb = zero;\n+        diffa = ZERO;\n+        diffb = ZERO;\n         itest = 0;\n-        nfsav = nf.value;\n+        nfsav = getEvaluations();\n \n         // Update GOPT if necessary before the first iteration and after each\n         // call of RESCUE that makes a call of CALFUN.\n         int state = 20;\n         for(;;) switch (state) {\n         case 20: {\n-            if (kopt.value != kbase) {\n+            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                 ih = 0;\n-                i__1 = n;\n-                for (j = 1; j <= i__1; j++) {\n-                    i__2 = j;\n-                    for (i__ = 1; i__ <= i__2; i__++) {\n+                for (int j = 1; j <= n; j++) {\n+                    for (int i = 1; i <= j; i++) {\n                         ++ih;\n-                        if (i__ < j) {\n-                            gopt.set(j,  gopt.get(j) + hq.get(ih) * xopt.get(i__));\n+                        if (i < j) {\n+                            gopt.setEntry(j,  gopt.getEntry(j) + hq.getEntry(ih) * xopt.getEntry(i));\n                         }\n-                        gopt.set(i__,  gopt.get(i__) + hq.get(ih) * xopt.get(j));\n-                    }\n-                }\n-                if (nf.value > npt) {\n-                    i__2 = npt;\n-                    for (k = 1; k <= i__2; k++) {\n-                        temp = zero;\n-                        i__1 = n;\n-                        for (j = 1; j <= i__1; j++) {\n-                            temp += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+                        gopt.setEntry(i,  gopt.getEntry(i) + hq.getEntry(ih) * xopt.getEntry(j));\n+                    }\n+                }\n+                if (getEvaluations() > npt) {\n+                    for (int k = 1; k <= npt; k++) {\n+                        temp = ZERO;\n+                        for (int j = 1; j <= n; j++) {\n+                            temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n                         }\n-                        temp = pq.get(k) * temp;\n-                        i__1 = n;\n-                        for (i__ = 1; i__ <= i__1; i__++) {\n-                            gopt.set(i__, gopt.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+                        temp = pq.getEntry(k) * temp;\n+                        for (int i = 1; i <= n; i++) {\n+                            gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n                         }\n                     }\n                 }\n             // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n \n         }\n-        case 60: {\t        \n-            trsbox(n, npt, xpt, xopt, gopt, hq, pq, sl,\n-                    su, delta, xnew, d__, w, w.ptr(np-1), w.ptr(np+n-1),\n-                    w.ptr(np + (n << 1)-1), w.ptr(np + n*3-1), dsq, crvmin);\n+        case 60: {\n+            final FortranArray gnew = new FortranArray(n);\n+            final FortranArray xbdi = new FortranArray(n);\n+            final FortranArray s = new FortranArray(n);\n+            final FortranArray hs = new FortranArray(n);\n+            final FortranArray hred = new FortranArray(n);\n+\n+            final double[] dsqCrvmin = trsbox(xpt, xopt, gopt, hq, pq, sl,\n+                                              su, delta, xnew, d__, gnew, xbdi, s,\n+                                              hs, hred);\n+            dsq = dsqCrvmin[0];\n+            crvmin = dsqCrvmin[1];\n \n             // Computing MIN\n-            d__1 = delta;\n-            d__2 = Math.sqrt(dsq.value);\n-            dnorm = Math.min(d__1,d__2);\n-            if (dnorm < half * rho) {\n+            double deltaOne = delta;\n+            double deltaTwo = Math.sqrt(dsq);\n+            dnorm = Math.min(deltaOne, deltaTwo);\n+            if (dnorm < HALF * rho) {\n                 ntrits = -1;\n                 // Computing 2nd power\n-                d__1 = ten * rho;\n-                distsq = d__1 * d__1;\n-                if (nf.value <= nfsav + 2) {\n+                deltaOne = TEN * rho;\n+                distsq = deltaOne * deltaOne;\n+                if (getEvaluations() <= nfsav + 2) {\n                     state = 650; break;\n                 }\n \n                 // of likely improvements to the model within distance HALF*RHO of XOPT.\n \n                 // Computing MAX\n-                d__1 = Math.max(diffa,diffb);\n-                errbig = Math.max(d__1,diffc);\n-                frhosq = rho * .125 * rho;\n-                if (crvmin.value > zero && errbig > frhosq * crvmin.value) {\n+                deltaOne = Math.max(diffa, diffb);\n+                errbig = Math.max(deltaOne, diffc);\n+                frhosq = rho * ONE_OVER_EIGHT * rho;\n+                if (crvmin > ZERO &&\n+                    errbig > frhosq * crvmin) {\n                     state = 650; break;\n                 }\n                 bdtol = errbig / rho;\n-                i__1 = n;\n-                for (j = 1; j <= i__1; j++) {\n+                for (int j = 1; j <= n; j++) {\n                     bdtest = bdtol;\n-                    if (xnew.get(j) == sl.get(j)) {\n-                        bdtest = w.get(j);\n-                    }\n-                    if (xnew.get(j) == su.get(j)) {\n-                        bdtest = -w.get(j);\n+                    if (xnew.getEntry(j) == sl.getEntry(j)) {\n+                        bdtest = work1.getEntry(j);\n+                    }\n+                    if (xnew.getEntry(j) == su.getEntry(j)) {\n+                        bdtest = -work1.getEntry(j);\n                     }\n                     if (bdtest < bdtol) {\n-                        curv = hq.get((j + j * j) / 2);\n-                        i__2 = npt;\n-                        for (k = 1; k <= i__2; k++) {\n+                        curv = hq.getEntry((j + j * j) / 2);\n+                        for (int k = 1; k <= npt; k++) {\n                             // Computing 2nd power\n-                            d__1 = xpt.get(k + j * xpt_dim1);\n-                            curv += pq.get(k) * (d__1 * d__1);\n+                            final double d1 = xpt.getEntry(k, j);\n+                            curv += pq.getEntry(k) * (d1 * d1);\n                         }\n-                        bdtest += half * curv * rho;\n+                        bdtest += HALF * curv * rho;\n                         if (bdtest < bdtol) {\n                             state = 650; break;\n                         }\n \n         }\n         case 90: {\n-            if (dsq.value <= xoptsq * .001) {\n-                fracsq = xoptsq * .25;\n-                sumpq = zero;\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    sumpq += pq.get(k);\n-                    sum = -half * xoptsq;\n-                    i__2 = n;\n-                    for (i__ = 1; i__ <= i__2; i__++) {\n-                        sum += xpt.get(k + i__ * xpt_dim1) * xopt.get(i__);\n-                    }\n-                    w.set(npt + k, sum);\n-                    temp = fracsq - half * sum;\n-                    i__2 = n;\n-                    for (i__ = 1; i__ <= i__2; i__++) {\n-                        w.set(i__, bmat.get(k + i__ * bmat_dim1));\n-                        vlag.set(i__, sum * xpt.get(k + i__ * xpt_dim1) + temp * xopt.get(i__));\n-                        ip = npt + i__;\n-                        i__3 = i__;\n-                        for (j = 1; j <= i__3; j++) {\n-                            bmat.set(ip + j * bmat_dim1, bmat.get(ip + j *\n-                                    bmat_dim1) + w.get(i__) * vlag.get(j) + vlag.get(i__) * w.get(j));\n+            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n+                fracsq = xoptsq * ONE_OVER_FOUR;\n+                sumpq = ZERO;\n+                for (int k = 1; k <= npt; k++) {\n+                    sumpq += pq.getEntry(k);\n+                    sum = -HALF * xoptsq;\n+                    for (int i = 1; i <= n; i++) {\n+                        sum += xpt.getEntry(k, i) * xopt.getEntry(i);\n+                    }\n+                    work2.setEntry(k, sum);\n+                    temp = fracsq - HALF * sum;\n+                    for (int i = 1; i <= n; i++) {\n+                        work1.setEntry(i, bmat.getEntry(k, i));\n+                        vlag.setEntry(i, sum * xpt.getEntry(k, i) + temp * xopt.getEntry(i));\n+                        ip = npt + i;\n+                        for (int j = 1; j <= i; j++) {\n+                            bmat.setEntry(ip, j,\n+                                          bmat.getEntry(ip, j)\n+                                          + work1.getEntry(i) * vlag.getEntry(j)\n+                                          + vlag.getEntry(i) * work1.getEntry(j));\n                         }\n                     }\n                 }\n \n                 // Then the revisions of BMAT that depend on ZMAT are calculated.\n \n-                i__3 = nptm;\n-                for (jj = 1; jj <= i__3; jj++) {\n-                    sumz = zero;\n-                    sumw = zero;\n-                    i__2 = npt;\n-                    for (k = 1; k <= i__2; k++) {\n-                        sumz += zmat.get(k + jj * zmat_dim1);\n-                        vlag.set(k, w.get(npt + k) * zmat.get(k + jj * zmat_dim1));\n-                        sumw += vlag.get(k);\n-                    }\n-                    i__2 = n;\n-                    for (j = 1; j <= i__2; j++) {\n-                        sum = (fracsq * sumz - half * sumw) * xopt.get(j);\n-                        i__1 = npt;\n-                        for (k = 1; k <= i__1; k++) {\n-                            sum += vlag.get(k) * xpt.get(k + j * xpt_dim1);\n+                for (int m = 1; m <= nptm; m++) {\n+                    sumz = ZERO;\n+                    sumw = ZERO;\n+                    for (int k = 1; k <= npt; k++) {\n+                        sumz += zmat.getEntry(k, m);\n+                        vlag.setEntry(k, work2.getEntry(k) * zmat.getEntry(k, m));\n+                        sumw += vlag.getEntry(k);\n+                    }\n+                    for (int j = 1; j <= n; j++) {\n+                        sum = (fracsq * sumz - HALF * sumw) * xopt.getEntry(j);\n+                        for (int k = 1; k <= npt; k++) {\n+                            sum += vlag.getEntry(k) * xpt.getEntry(k, j);\n                         }\n-                        w.set(j, sum);\n-                        i__1 = npt;\n-                        for (k = 1; k <= i__1; k++) {\n-                            bmat.set(k + j * bmat_dim1,  bmat.get(k + j * bmat_dim1) +\n-                                    sum * zmat.get(k + jj * zmat_dim1));\n+                        work1.setEntry(j, sum);\n+                        for (int k = 1; k <= npt; k++) {\n+                            bmat.setEntry(k, j,\n+                                          bmat.getEntry(k, j)\n+                                          + sum * zmat.getEntry(k, m));\n                         }\n                     }\n-                    i__1 = n;\n-                    for (i__ = 1; i__ <= i__1; i__++) {\n-                        ip = i__ + npt;\n-                        temp = w.get(i__);\n-                        i__2 = i__;\n-                        for (j = 1; j <= i__2; j++) {\n-                            bmat.set(ip + j * bmat_dim1,  bmat.get(ip + j * bmat_dim1) +\n-                                    temp * w.get(j));\n+                    for (int i = 1; i <= n; i++) {\n+                        ip = i + npt;\n+                        temp = work1.getEntry(i);\n+                        for (int j = 1; j <= i; j++) {\n+                            bmat.setEntry(ip, j,\n+                                          bmat.getEntry(ip, j)\n+                                          + temp * work1.getEntry(j));\n                         }\n                     }\n                 }\n                 // to the second derivative parameters of the quadratic model.\n \n                 ih = 0;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n-                    w.set(j, -half * sumpq * xopt.get(j));\n-                    i__1 = npt;\n-                    for (k = 1; k <= i__1; k++) {\n-                        w.set(j, w.get(j) + pq.get(k) * xpt.get(k + j * xpt_dim1));\n-                        xpt.set(k + j * xpt_dim1, xpt.get(k + j * xpt_dim1) - xopt.get(j));\n-                    }\n-                    i__1 = j;\n-                    for (i__ = 1; i__ <= i__1; i__++) {\n+                for (int j = 1; j <= n; j++) {\n+                    work1.setEntry(j, -HALF * sumpq * xopt.getEntry(j));\n+                    for (int k = 1; k <= npt; k++) {\n+                        work1.setEntry(j, work1.getEntry(j) + pq.getEntry(k) * xpt.getEntry(k, j));\n+                        xpt.setEntry(k, j, xpt.getEntry(k, j) - xopt.getEntry(j));\n+                    }\n+                    for (int i = 1; i <= j; i++) {\n                         ++ih;\n-                        hq.set(ih, hq.get(ih) + w.get(i__) * xopt.get(j) + xopt.get(i__) * w.get(j));\n-                        bmat.set(npt + i__ + j * bmat_dim1, bmat.get(npt + j + i__ * bmat_dim1));\n-                    }\n-                }\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    xbase.set(i__, xbase.get(i__) + xopt.get(i__));\n-                    xnew.set(i__, xnew.get(i__) - xopt.get(i__));\n-                    sl.set(i__, sl.get(i__) - xopt.get(i__));\n-                    su.set(i__, su.get(i__) - xopt.get(i__));\n-                    xopt.set(i__, zero);\n-                }\n-                xoptsq = zero;\n+                        hq.setEntry(ih,\n+                                    hq.getEntry(ih)\n+                                    + work1.getEntry(i) * xopt.getEntry(j)\n+                                    + xopt.getEntry(i) * work1.getEntry(j));\n+                        bmat.setEntry(npt + i, j, bmat.getEntry(npt + j, i));\n+                    }\n+                }\n+                for (int i = 1; i <= n; i++) {\n+                    xbase.setEntry(i, xbase.getEntry(i) + xopt.getEntry(i));\n+                    xnew.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n+                    sl.setEntry(i, sl.getEntry(i) - xopt.getEntry(i));\n+                    su.setEntry(i, su.getEntry(i) - xopt.getEntry(i));\n+                    xopt.setEntry(i, ZERO);\n+                }\n+                xoptsq = ZERO;\n             }\n             if (ntrits == 0) {\n                 state = 210; break;\n \n         }\n         case 190: {\n-            nfsav = nf.value;\n-            kbase = kopt.value;\n-\n-            rescue(n, npt, xl, xu, maxfun, xbase, xpt,\n+            nfsav = getEvaluations();\n+            kbase = trustRegionCenterInterpolationPointIndex;\n+\n+            rescue(xbase, xpt,\n                     fval, xopt, gopt, hq, pq, bmat,\n-                    zmat, ndim,  sl, su, nf, delta,\n-                    kopt, vlag, w.ptr(-2), w.ptr(n+np-1), w.ptr(ndim+np-1));\n+                    zmat, sl, su, delta,\n+                   vlag);\n \n             // XOPT is updated now in case the branch below to label 720 is taken.\n             // Any updating of GOPT occurs after the branch below to label 20, which\n             // leads to a trust region iteration as does the branch to label 60.\n \n-            xoptsq = zero;\n-            if (kopt.value != kbase) {\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    xopt.set(i__, xpt.get(kopt.value + i__ * xpt_dim1));\n+            xoptsq = ZERO;\n+            if (trustRegionCenterInterpolationPointIndex != kbase) {\n+                for (int i = 1; i <= n; i++) {\n+                    xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n                     // Computing 2nd power\n-                    d__1 = xopt.get(i__);\n-                    xoptsq += d__1 * d__1;\n-                }\n-            }\n-            nresc = nf.value;\n-            if (nfsav < nf.value) {\n-                nfsav = nf.value;\n+                    final double d1 = xopt.getEntry(i);\n+                    xoptsq += d1 * d1;\n+                }\n+            }\n+            nresc = getEvaluations();\n+            if (nfsav < getEvaluations()) {\n+                nfsav = getEvaluations();\n                 state = 20; break;\n             }\n             if (ntrits > 0) {\n             // being returned in CAUCHY. The choice between these alternatives is\n             // going to be made when the denominator is calculated.\n \n-            altmov(n, npt, xpt, xopt,\n-                    bmat, zmat,\n-                    ndim, sl, su, kopt.value, knew, adelt, xnew, xalt, alpha, cauchy,\n-                    w, w.ptr(np-1), w.ptr(ndim));\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                d__.set(i__, xnew.get(i__) - xopt.get(i__));\n+            final double[] alphaCauchy = altmov(xpt, xopt,\n+                                                bmat, zmat,\n+                                                sl, su, knew, adelt, xnew, xalt);\n+            alpha = alphaCauchy[0];\n+            cauchy = alphaCauchy[1];\n+\n+            for (int i = 1; i <= n; i++) {\n+                d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n             }\n \n             // Calculate VLAG and BETA for the current choice of D. The scalar\n \n         }\n         case 230: {\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n-                suma = zero;\n-                sumb = zero;\n-                sum = zero;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n-                    suma += xpt.get(k + j * xpt_dim1) * d__.get(j);\n-                    sumb += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n-                    sum += bmat.get(k + j * bmat_dim1) * d__.get(j);\n-                }\n-                w.set(k, suma * (half * suma + sumb));\n-                vlag.set(k, sum);\n-                w.set(npt + k, suma);\n-            }\n-            beta = zero;\n-            i__1 = nptm;\n-            for (jj = 1; jj <= i__1; jj++) {\n-                sum = zero;\n-                i__2 = npt;\n-                for (k = 1; k <= i__2; k++) {\n-                    sum += zmat.get(k + jj * zmat_dim1) * w.get(k);\n+            for (int k = 1; k <= npt; k++) {\n+                suma = ZERO;\n+                sumb = ZERO;\n+                sum = ZERO;\n+                for (int j = 1; j <= n; j++) {\n+                    suma += xpt.getEntry(k, j) * d__.getEntry(j);\n+                    sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n+                    sum += bmat.getEntry(k, j) * d__.getEntry(j);\n+                }\n+                work3.setEntry(k, suma * (HALF * suma + sumb));\n+                vlag.setEntry(k, sum);\n+                work2.setEntry(k, suma);\n+            }\n+            beta = ZERO;\n+            for (int m = 1; m <= nptm; m++) {\n+                sum = ZERO;\n+                for (int k = 1; k <= npt; k++) {\n+                    sum += zmat.getEntry(k, m) * work3.getEntry(k);\n                 }\n                 beta -= sum * sum;\n-                i__2 = npt;\n-                for (k = 1; k <= i__2; k++) {\n-                    vlag.set(k, vlag.get(k) + sum * zmat.get(k + jj * zmat_dim1));\n-                }\n-            }\n-            dsq.value = zero;\n-            bsum = zero;\n-            dx = zero;\n-            i__2 = n;\n-            for (j = 1; j <= i__2; j++) {\n+                for (int k = 1; k <= npt; k++) {\n+                    vlag.setEntry(k, vlag.getEntry(k) + sum * zmat.getEntry(k, m));\n+                }\n+            }\n+            dsq = ZERO;\n+            bsum = ZERO;\n+            dx = ZERO;\n+            for (int j = 1; j <= n; j++) {\n                 // Computing 2nd power\n-                d__1 = d__.get(j);\n-                dsq.value += d__1 * d__1;\n-                sum = zero;\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    sum += w.get(k) * bmat.get(k + j * bmat_dim1);\n-                }\n-                bsum += sum * d__.get(j);\n+                final double d1 = d__.getEntry(j);\n+                dsq += d1 * d1;\n+                sum = ZERO;\n+                for (int k = 1; k <= npt; k++) {\n+                    sum += work3.getEntry(k) * bmat.getEntry(k, j);\n+                }\n+                bsum += sum * d__.getEntry(j);\n                 jp = npt + j;\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    sum += bmat.get(jp + i__ * bmat_dim1) * d__.get(i__);\n-                }\n-                vlag.set(jp, sum);\n-                bsum += sum * d__.get(j);\n-                dx += d__.get(j) * xopt.get(j);\n-            }\n-            beta = dx * dx + dsq.value * (xoptsq + dx + dx + half * dsq.value) + beta - bsum;\n-            vlag.set(kopt.value, vlag.get(kopt.value) + one);\n+                for (int i = 1; i <= n; i++) {\n+                    sum += bmat.getEntry(jp, i) * d__.getEntry(i);\n+                }\n+                vlag.setEntry(jp, sum);\n+                bsum += sum * d__.getEntry(j);\n+                dx += d__.getEntry(j) * xopt.getEntry(j);\n+            }\n+            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum;\n+            vlag.setEntry(trustRegionCenterInterpolationPointIndex, vlag.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n \n             // If NTRITS is zero, the denominator may be increased by replacing\n             // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n \n             if (ntrits == 0) {\n                 // Computing 2nd power\n-                d__1 = vlag.get(knew);\n-                denom = d__1 * d__1 + alpha.value * beta;\n-                if (denom < cauchy.value && cauchy.value > zero) {\n-                    i__2 = n;\n-                    for (i__ = 1; i__ <= i__2; i__++) {\n-                        xnew.set(i__, xalt.get(i__));\n-                        d__.set(i__, xnew.get(i__) - xopt.get(i__));\n-                    }\n-                    cauchy.value = zero;\n+                d__1 = vlag.getEntry(knew); // XXX Same statement as a few lines below?\n+                denom = d__1 * d__1 + alpha * beta;\n+                if (denom < cauchy && cauchy > ZERO) {\n+                    for (int i = 1; i <= n; i++) {\n+                        xnew.setEntry(i, xalt.getEntry(i));\n+                        d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n+                    }\n+                    cauchy = ZERO; // XXX Useful statement?\n                     state = 230; break;\n                 }\n                 // Computing 2nd power\n-                d__1 = vlag.get(knew);\n-                if (denom <= half * (d__1 * d__1)) {\n-                    if (nf.value > nresc) {\n+                d__1 = vlag.getEntry(knew); // XXX Same statement as a few lines above?\n+                if (denom <= HALF * (d__1 * d__1)) {\n+                    if (getEvaluations() > nresc) {\n                         state = 190; break;\n                     }\n                     throw new MathIllegalStateException(LocalizedFormats.TOO_MUCH_CANCELLATION, vquad);\n \n             } else {\n                 delsq = delta * delta;\n-                scaden = zero;\n-                biglsq = zero;\n+                scaden = ZERO;\n+                biglsq = ZERO;\n                 knew = 0;\n-                i__2 = npt;\n-                for (k = 1; k <= i__2; k++) {\n-                    if (k == kopt.value) {\n+                for (int k = 1; k <= npt; k++) {\n+                    if (k == trustRegionCenterInterpolationPointIndex) {\n                         continue;\n                     }\n-                    hdiag = zero;\n-                    i__1 = nptm;\n-                    for (jj = 1; jj <= i__1; jj++) {\n+                    hdiag = ZERO;\n+                    for (int m = 1; m <= nptm; m++) {\n                         // Computing 2nd power\n-                        d__1 = zmat.get(k + jj * zmat_dim1);\n-                        hdiag += d__1 * d__1;\n+                        final double d1 = zmat.getEntry(k, m);\n+                        hdiag += d1 * d1;\n                     }\n                     // Computing 2nd power\n-                    d__1 = vlag.get(k);\n+                    d__1 = vlag.getEntry(k);\n                     den = beta * hdiag + d__1 * d__1;\n-                    distsq = zero;\n-                    i__1 = n;\n-                    for (j = 1; j <= i__1; j++) {\n+                    distsq = ZERO;\n+                    for (int j = 1; j <= n; j++) {\n                         // Computing 2nd power\n-                        d__1 = xpt.get(k + j * xpt_dim1) - xopt.get(j);\n-                        distsq += d__1 * d__1;\n+                        final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n+                        distsq += d1 * d1;\n                     }\n                     // Computing MAX\n                     // Computing 2nd power\n                     d__3 = distsq / delsq;\n-                    d__1 = one;\n+                    d__1 = ONE;\n                     d__2 = d__3 * d__3;\n                     temp = Math.max(d__1,d__2);\n                     if (temp * den > scaden) {\n                     }\n                     // Computing MAX\n                     // Computing 2nd power\n-                    d__3 = vlag.get(k);\n+                    d__3 = vlag.getEntry(k);\n                     d__1 = biglsq;\n                     d__2 = temp * (d__3 * d__3);\n-                    biglsq = Math.max(d__1,d__2);\n-                }\n-                if (scaden <= half * biglsq) {\n-                    if (nf.value > nresc) {\n+                    biglsq = Math.max(d__1, d__2);\n+                }\n+                if (scaden <= HALF * biglsq) {\n+                    if (getEvaluations() > nresc) {\n                         state = 190; break;\n                     }\n                     throw new MathIllegalStateException(LocalizedFormats.TOO_MUCH_CANCELLATION, vquad);\n \n         }\n         case 360: {\n-            i__2 = n;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n+            for (int i = 1; i <= n; i++) {\n                 // Computing MIN\n                 // Computing MAX\n-                d__3 = xl.get(i__);\n-                d__4 = xbase.get(i__) + xnew.get(i__);\n-                d__1 = Math.max(d__3,d__4);\n-                d__2 = xu.get(i__);\n-                x.set(i__, Math.min(d__1,d__2));\n-                if (xnew.get(i__) == sl.get(i__)) {\n-                    x.set(i__, xl.get(i__));\n-                }\n-                if (xnew.get(i__) == su.get(i__)) {\n-                    x.set(i__, xu.get(i__));\n-                }\n-            }\n-            if (nf.value > maxfun) { // should not happen,\n-                // TooManyEvaluationsException is thrown before\n-                throw new RuntimeException(\"Return from BOBYQA because the objective function has been called max_f_evals times.\");\n-            }\n-            nf.value++;\n-            f = computeObjectiveValue(x.getAll());\n+                d__3 = lowerBound[f2jai(i)];\n+                d__4 = xbase.getEntry(i) + xnew.getEntry(i);\n+                d__1 = Math.max(d__3, d__4);\n+                d__2 = upperBound[f2jai(i)];\n+                currentBest.setEntry(f2jai(i), Math.min(d__1, d__2));\n+                if (xnew.getEntry(i) == sl.getEntry(i)) {\n+                    currentBest.setEntry(f2jai(i), lowerBound[f2jai(i)]);\n+                }\n+                if (xnew.getEntry(i) == su.getEntry(i)) {\n+                    currentBest.setEntry(f2jai(i), upperBound[f2jai(i)]);\n+                }\n+            }\n+\n+            f = computeObjectiveValue(currentBest.getData());\n+\n             if (!isMinimize)\n                 f = -f;\n             if (ntrits == -1) {\n             // Use the quadratic model to predict the change in F due to the step D,\n             //   and set DIFF to the error of this prediction.\n \n-            fopt = fval.get(kopt.value);\n-            vquad = zero;\n+            fopt = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n+            vquad = ZERO;\n             ih = 0;\n-            i__2 = n;\n-            for (j = 1; j <= i__2; j++) {\n-                vquad += d__.get(j) * gopt.get(j);\n-                i__1 = j;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n+            for (int j = 1; j <= n; j++) {\n+                vquad += d__.getEntry(j) * gopt.getEntry(j);\n+                for (int i = 1; i <= j; i++) {\n                     ++ih;\n-                    temp = d__.get(i__) * d__.get(j);\n-                    if (i__ == j) {\n-                        temp = half * temp;\n-                    }\n-                    vquad += hq.get(ih) * temp;\n-                }\n-            }\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n+                    temp = d__.getEntry(i) * d__.getEntry(j);\n+                    if (i == j) {\n+                        temp = HALF * temp;\n+                    }\n+                    vquad += hq.getEntry(ih) * temp;\n+                }\n+            }\n+            for (int k = 1; k <= npt; k++) {\n                 // Computing 2nd power\n-                d__1 = w.get(npt + k);\n-                vquad += half * pq.get(k) * (d__1 * d__1);\n+                final double d1 = work2.getEntry(k);\n+                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n+                vquad += HALF * pq.getEntry(k) * d2;\n             }\n             diff = f - fopt - vquad;\n             diffc = diffb;\n             diffb = diffa;\n             diffa = Math.abs(diff);\n             if (dnorm > rho) {\n-                nfsav = nf.value;\n+                nfsav = getEvaluations();\n             }\n \n             // Pick the next value of DELTA after a trust region step.\n \n             if (ntrits > 0) {\n-                if (vquad >= zero) {\n+                if (vquad >= ZERO) {\n                     throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                 }\n                 ratio = (f - fopt) / vquad;\n-                if (ratio <= tenth) {\n+                if (ratio <= ONE_OVER_TEN) {\n                     // Computing MIN\n-                    d__1 = half * delta;\n+                    d__1 = HALF * delta;\n                     delta = Math.min(d__1,dnorm);\n                 } else if (ratio <= .7) {\n                     // Computing MAX\n-                    d__1 = half * delta;\n+                    d__1 = HALF * delta;\n                     delta = Math.max(d__1,dnorm);\n                 } else {\n                     // Computing MAX\n-                    d__1 = half * delta;\n+                    d__1 = HALF * delta;\n                     d__2 = dnorm + dnorm;\n                     delta = Math.max(d__1,d__2);\n                 }\n                     ksav = knew;\n                     densav = denom;\n                     delsq = delta * delta;\n-                    scaden = zero;\n-                    biglsq = zero;\n+                    scaden = ZERO;\n+                    biglsq = ZERO;\n                     knew = 0;\n-                    i__1 = npt;\n-                    for (k = 1; k <= i__1; k++) {\n-                        hdiag = zero;\n-                        i__2 = nptm;\n-                        for (jj = 1; jj <= i__2; jj++) {\n+                    for (int k = 1; k <= npt; k++) {\n+                        hdiag = ZERO;\n+                        for (int m = 1; m <= nptm; m++) {\n                             // Computing 2nd power\n-                            d__1 = zmat.get(k + jj * zmat_dim1);\n-                            hdiag += d__1 * d__1;\n+                            final double d1 = zmat.getEntry(k, m);\n+                            hdiag += d1 * d1;\n                         }\n                         // Computing 2nd power\n-                        d__1 = vlag.get(k);\n+                        d__1 = vlag.getEntry(k);\n                         den = beta * hdiag + d__1 * d__1;\n-                        distsq = zero;\n-                        i__2 = n;\n-                        for (j = 1; j <= i__2; j++) {\n+                        distsq = ZERO;\n+                        for (int j = 1; j <= n; j++) {\n                             // Computing 2nd power\n-                            d__1 = xpt.get(k + j * xpt_dim1) - xnew.get(j);\n-                            distsq += d__1 * d__1;\n+                            final double d1 = xpt.getEntry(k, j) - xnew.getEntry(j);\n+                            distsq += d1 * d1;\n                         }\n                         // Computing MAX\n                         // Computing 2nd power\n                         d__3 = distsq / delsq;\n-                        d__1 = one;\n+                        d__1 = ONE;\n                         d__2 = d__3 * d__3;\n-                        temp = Math.max(d__1,d__2);\n+                        temp = Math.max(d__1, d__2);\n                         if (temp * den > scaden) {\n                             scaden = temp * den;\n                             knew = k;\n                         }\n                         // Computing MAX\n                         // Computing 2nd power\n-                        d__3 = vlag.get(k);\n+                        d__3 = vlag.getEntry(k);\n                         d__1 = biglsq;\n                         d__2 = temp * (d__3 * d__3);\n-                        biglsq = Math.max(d__1,d__2);\n-                    }\n-                    if (scaden <= half * biglsq) {\n+                        biglsq = Math.max(d__1, d__2);\n+                    }\n+                    if (scaden <= HALF * biglsq) {\n                         knew = ksav;\n                         denom = densav;\n                     }\n             // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n             // moved. Also update the second derivative terms of the model.\n \n-            update(n, npt, bmat, zmat, ndim, vlag,\n-                    beta, denom, knew, w);\n+            update(bmat, zmat, vlag,\n+                    beta, denom, knew);\n \n             ih = 0;\n-            pqold = pq.get(knew);\n-            pq.set(knew, zero);\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                temp = pqold * xpt.get(knew + i__ * xpt_dim1);\n-                i__2 = i__;\n-                for (j = 1; j <= i__2; j++) {\n+            pqold = pq.getEntry(knew);\n+            pq.setEntry(knew, ZERO);\n+            for (int i = 1; i <= n; i++) {\n+                temp = pqold * xpt.getEntry(knew, i);\n+                for (int j = 1; j <= i; j++) {\n                     ++ih;\n-                    hq.set(ih, hq.get(ih) + temp * xpt.get(knew + j * xpt_dim1));\n-                }\n-            }\n-            i__2 = nptm;\n-            for (jj = 1; jj <= i__2; jj++) {\n-                temp = diff * zmat.get(knew + jj * zmat_dim1);\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    pq.set(k, pq.get(k) + temp * zmat.get(k + jj * zmat_dim1));\n+                    hq.setEntry(ih, hq.getEntry(ih) + temp * xpt.getEntry(knew, j));\n+                }\n+            }\n+            for (int m = 1; m <= nptm; m++) {\n+                temp = diff * zmat.getEntry(knew, m);\n+                for (int k = 1; k <= npt; k++) {\n+                    pq.setEntry(k, pq.getEntry(k) + temp * zmat.getEntry(k, m));\n                 }\n             }\n \n             // Include the new interpolation point, and make the changes to GOPT at\n             // the old XOPT that are caused by the updating of the quadratic model.\n \n-            fval.set(knew,  f);\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                xpt.set(knew + i__ * xpt_dim1, xnew.get(i__));\n-                w.set(i__, bmat.get(knew + i__ * bmat_dim1));\n-            }\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n-                suma = zero;\n-                i__2 = nptm;\n-                for (jj = 1; jj <= i__2; jj++) {\n-                    suma += zmat.get(knew + jj * zmat_dim1) * zmat.get(k + jj * zmat_dim1);\n-                }\n-                sumb = zero;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n-                    sumb += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+            fval.setEntry(knew,  f);\n+            for (int i = 1; i <= n; i++) {\n+                xpt.setEntry(knew, i, xnew.getEntry(i));\n+                work1.setEntry(i, bmat.getEntry(knew, i));\n+            }\n+            for (int k = 1; k <= npt; k++) {\n+                suma = ZERO;\n+                for (int m = 1; m <= nptm; m++) {\n+                    suma += zmat.getEntry(knew, m) * zmat.getEntry(k, m);\n+                }\n+                sumb = ZERO;\n+                for (int j = 1; j <= n; j++) {\n+                    sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n                 }\n                 temp = suma * sumb;\n-                i__2 = n;\n-                for (i__ = 1; i__ <= i__2; i__++) {\n-                    w.set(i__, w.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n-                }\n-            }\n-            i__2 = n;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n-                gopt.set(i__, gopt.get(i__) + diff * w.get(i__));\n+                for (int i = 1; i <= n; i++) {\n+                    work1.setEntry(i, work1.getEntry(i) + temp * xpt.getEntry(k, i));\n+                }\n+            }\n+            for (int i = 1; i <= n; i++) {\n+                gopt.setEntry(i, gopt.getEntry(i) + diff * work1.getEntry(i));\n             }\n \n             // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n \n             if (f < fopt) {\n-                kopt.value = knew;\n-                xoptsq = zero;\n+                trustRegionCenterInterpolationPointIndex = knew;\n+                xoptsq = ZERO;\n                 ih = 0;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n-                    xopt.set(j, xnew.get(j));\n+                for (int j = 1; j <= n; j++) {\n+                    xopt.setEntry(j, xnew.getEntry(j));\n                     // Computing 2nd power\n-                    d__1 = xopt.get(j);\n-                    xoptsq += d__1 * d__1;\n-                    i__1 = j;\n-                    for (i__ = 1; i__ <= i__1; i__++) {\n+                    final double d1 = xopt.getEntry(j);\n+                    xoptsq += d1 * d1;\n+                    for (int i = 1; i <= j; i++) {\n                         ++ih;\n-                        if (i__ < j) {\n-                            gopt.set(j, gopt.get(j) + hq.get(ih) * d__.get(i__));\n+                        if (i < j) {\n+                            gopt.setEntry(j, gopt.getEntry(j) + hq.getEntry(ih) * d__.getEntry(i));\n                         }\n-                        gopt.set(i__, gopt.get(i__) + hq.get(ih) * d__.get(j));\n-                    }\n-                }\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    temp = zero;\n-                    i__2 = n;\n-                    for (j = 1; j <= i__2; j++) {\n-                        temp += xpt.get(k + j * xpt_dim1) * d__.get(j);\n-                    }\n-                    temp = pq.get(k) * temp;\n-                    i__2 = n;\n-                    for (i__ = 1; i__ <= i__2; i__++) {\n-                        gopt.set(i__, gopt.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+                        gopt.setEntry(i, gopt.getEntry(i) + hq.getEntry(ih) * d__.getEntry(j));\n+                    }\n+                }\n+                for (int k = 1; k <= npt; k++) {\n+                    temp = ZERO;\n+                    for (int j = 1; j <= n; j++) {\n+                        temp += xpt.getEntry(k, j) * d__.getEntry(j);\n+                    }\n+                    temp = pq.getEntry(k) * temp;\n+                    for (int i = 1; i <= n; i++) {\n+                        gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n                     }\n                 }\n             }\n             // into VLAG(NPT+I), I=1,2,...,N.\n \n             if (ntrits > 0) {\n-                i__2 = npt;\n-                for (k = 1; k <= i__2; k++) {\n-                    vlag.set(k, fval.get(k) - fval.get(kopt.value));\n-                    w.set(k, zero);\n-                }\n-                i__2 = nptm;\n-                for (j = 1; j <= i__2; j++) {\n-                    sum = zero;\n-                    i__1 = npt;\n-                    for (k = 1; k <= i__1; k++) {\n-                        sum += zmat.get(k + j * zmat_dim1) * vlag.get(k);\n-                    }\n-                    i__1 = npt;\n-                    for (k = 1; k <= i__1; k++) {\n-                        w.set(k, w.get(k) + sum * zmat.get(k + j * zmat_dim1));\n-                    }\n-                }\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    sum = zero;\n-                    i__2 = n;\n-                    for (j = 1; j <= i__2; j++) {\n-                        sum += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n-                    }\n-                    w.set(k + npt, w.get(k));\n-                    w.set(k, sum * w.get(k));\n-                }\n-                gqsq = zero;\n-                gisq = zero;\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    sum = zero;\n-                    i__2 = npt;\n-                    for (k = 1; k <= i__2; k++) {\n-                        sum = sum + bmat.get(k + i__ * bmat_dim1) *\n-                        vlag.get(k) + xpt.get(k + i__ * xpt_dim1) * w.get(k);\n-                    }\n-                    if (xopt.get(i__) == sl.get(i__)) {\n+                for (int k = 1; k <= npt; k++) {\n+                    vlag.setEntry(k, fval.getEntry(k) - fval.getEntry(trustRegionCenterInterpolationPointIndex));\n+                    work3.setEntry(k, ZERO);\n+                }\n+                for (int j = 1; j <= nptm; j++) {\n+                    sum = ZERO;\n+                    for (int k = 1; k <= npt; k++) {\n+                        sum += zmat.getEntry(k, j) * vlag.getEntry(k);\n+                    }\n+                    for (int k = 1; k <= npt; k++) {\n+                        work3.setEntry(k, work3.getEntry(k) + sum * zmat.getEntry(k, j));\n+                    }\n+                }\n+                for (int k = 1; k <= npt; k++) {\n+                    sum = ZERO;\n+                    for (int j = 1; j <= n; j++) {\n+                        sum += xpt.getEntry(k, j) * xopt.getEntry(j);\n+                    }\n+                    work2.setEntry(k, work3.getEntry(k));\n+                    work3.setEntry(k, sum * work3.getEntry(k));\n+                }\n+                gqsq = ZERO;\n+                gisq = ZERO;\n+                for (int i = 1; i <= n; i++) {\n+                    sum = ZERO;\n+                    for (int k = 1; k <= npt; k++) {\n+                        sum += bmat.getEntry(k, i) *\n+                            vlag.getEntry(k) + xpt.getEntry(k, i) * work3.getEntry(k);\n+                    }\n+                    if (xopt.getEntry(i) == sl.getEntry(i)) {\n                         // Computing MIN\n-                        d__2 = zero;\n-                        d__3 = gopt.get(i__);\n+                        d__2 = ZERO;\n+                        d__3 = gopt.getEntry(i);\n                         // Computing 2nd power\n-                        d__1 = Math.min(d__2,d__3);\n+                        d__1 = Math.min(d__2, d__3);\n                         gqsq += d__1 * d__1;\n                         // Computing 2nd power\n-                        d__1 = Math.min(zero,sum);\n+                        d__1 = Math.min(ZERO, sum);\n                         gisq += d__1 * d__1;\n-                    } else if (xopt.get(i__) == su.get(i__)) {\n+                    } else if (xopt.getEntry(i) == su.getEntry(i)) {\n                         // Computing MAX\n-                        d__2 = zero;\n-                        d__3 = gopt.get(i__);\n+                        d__2 = ZERO;\n+                        d__3 = gopt.getEntry(i);\n                         // Computing 2nd power\n-                        d__1 = Math.max(d__2,d__3);\n+                        d__1 = Math.max(d__2, d__3);\n                         gqsq += d__1 * d__1;\n                         // Computing 2nd power\n-                        d__1 = Math.max(zero,sum);\n+                        d__1 = Math.max(ZERO, sum);\n                         gisq += d__1 * d__1;\n                     } else {\n                         // Computing 2nd power\n-                        d__1 = gopt.get(i__);\n+                        d__1 = gopt.getEntry(i);\n                         gqsq += d__1 * d__1;\n                         gisq += sum * sum;\n                     }\n-                    vlag.set(npt + i__, sum);\n+                    vlag.setEntry(npt + i, sum);\n                 }\n \n                 // Test whether to replace the new quadratic model by the least Frobenius\n                 // norm interpolant, making the replacement if the test is satisfied.\n \n                 ++itest;\n-                if (gqsq < ten * gisq) {\n+                if (gqsq < TEN * gisq) {\n                     itest = 0;\n                 }\n                 if (itest >= 3) {\n-                    i__1 = Math.max(npt,nh);\n-                    for (i__ = 1; i__ <= i__1; i__++) {\n-                        if (i__ <= n) {\n-                            gopt.set(i__, vlag.get(npt + i__));\n+                    for (int i = 1, max = Math.max(npt, nh); i <= max; i++) {\n+                        if (i <= n) {\n+                            gopt.setEntry(i, vlag.getEntry(npt + i));\n                         }\n-                        if (i__ <= npt) {\n-                            pq.set(i__, w.get(npt + i__));\n+                        if (i <= npt) {\n+                            pq.setEntry(i, work2.getEntry(i));\n                         }\n-                        if (i__ <= nh) {\n-                            hq.set(i__, zero);\n+                        if (i <= nh) {\n+                            hq.setEntry(i, ZERO);\n                         }\n                         itest = 0;\n                     }\n             if (ntrits == 0) {\n                 state = 60; break;\n             }\n-            if (f <= fopt + tenth * vquad) {\n+            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                 state = 60; break;\n             }\n \n \n             // Computing MAX\n             // Computing 2nd power\n-            d__3 = two * delta;\n+            d__3 = TWO * delta;\n             // Computing 2nd power\n-            d__4 = ten * rho;\n+            d__4 = TEN * rho;\n             d__1 = d__3 * d__3;\n             d__2 = d__4 * d__4;\n-            distsq = Math.max(d__1,d__2);\n+            distsq = Math.max(d__1, d__2);\n         }\n         case 650: {\n             knew = 0;\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n-                sum = zero;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n+            for (int k = 1; k <= npt; k++) {\n+                sum = ZERO;\n+                for (int j = 1; j <= n; j++) {\n                     // Computing 2nd power\n-                    d__1 = xpt.get(k + j * xpt_dim1) - xopt.get(j);\n-                    sum += d__1 * d__1;\n+                    final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n+                    sum += d1 * d1;\n                 }\n                 if (sum > distsq) {\n                     knew = k;\n                 dist = Math.sqrt(distsq);\n                 if (ntrits == -1) {\n                     // Computing MIN\n-                    d__1 = tenth * delta;\n-                    d__2 = half * dist;\n+                    d__1 = ONE_OVER_TEN * delta;\n+                    d__2 = HALF * dist;\n                     delta = Math.min(d__1,d__2);\n                     if (delta <= rho * 1.5) {\n                         delta = rho;\n                 ntrits = 0;\n                 // Computing MAX\n                 // Computing MIN\n-                d__2 = tenth * dist;\n-                d__1 = Math.min(d__2,delta);\n-                adelt = Math.max(d__1,rho);\n-                dsq.value = adelt * adelt;\n+                d__2 = ONE_OVER_TEN * dist;\n+                d__1 = Math.min(d__2, delta);\n+                adelt = Math.max(d__1, rho);\n+                dsq = adelt * adelt;\n                 state = 90; break;\n             }\n             if (ntrits == -1) {\n                 state = 680; break;\n             }\n-            if (ratio > zero) {\n+            if (ratio > ZERO) {\n                 state = 60; break;\n             }\n-            if (Math.max(delta,dnorm) > rho) {\n+            if (Math.max(delta, dnorm) > rho) {\n                 state = 60; break;\n             }\n \n             //   next values of RHO and DELTA.\n         }\n         case 680: {\n-            if (rho > rhoend) {\n-                delta = half * rho;\n-                ratio = rho / rhoend;\n-                if (ratio <= 16.) {\n-                    rho = rhoend;\n-                } else if (ratio <= 250.) {\n-                    rho = Math.sqrt(ratio) * rhoend;\n+            if (rho > stoppingTrustRegionRadius) {\n+                delta = HALF * rho;\n+                ratio = rho / stoppingTrustRegionRadius;\n+                if (ratio <= SIXTEEN) {\n+                    rho = stoppingTrustRegionRadius;\n+                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n+                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                 } else {\n-                    rho = tenth * rho;\n-                }\n-                delta = Math.max(delta,rho);\n+                    rho = ONE_OVER_TEN * rho;\n+                }\n+                delta = Math.max(delta, rho);\n                 ntrits = 0;\n-                nfsav = nf.value;\n+                nfsav = getEvaluations();\n                 state = 60; break;\n             }\n \n             }\n         }\n         case 720: {\n-            if (fval.get(kopt.value) <= fsave) {\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n+            if (fval.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n+                for (int i = 1; i <= n; i++) {\n                     // Computing MIN\n                     // Computing MAX\n-                    d__3 = xl.get(i__);\n-                    d__4 = xbase.get(i__) + xopt.get(i__);\n-                    d__1 = Math.max(d__3,d__4);\n-                    d__2 = xu.get(i__);\n-                    x.set(i__, Math.min(d__1,d__2));\n-                    if (xopt.get(i__) == sl.get(i__)) {\n-                        x.set(i__, xl.get(i__));\n-                    }\n-                    if (xopt.get(i__) == su.get(i__)) {\n-                        x.set(i__, xu.get(i__));\n-                    }\n-                }\n-                f = fval.get(kopt.value);\n+                    d__3 = lowerBound[f2jai(i)];\n+                    d__4 = xbase.getEntry(i) + xopt.getEntry(i);\n+                    d__1 = Math.max(d__3, d__4);\n+                    d__2 = upperBound[f2jai(i)];\n+                    currentBest.setEntry(f2jai(i), Math.min(d__1, d__2));\n+                    if (xopt.getEntry(i) == sl.getEntry(i)) {\n+                        currentBest.setEntry(f2jai(i), lowerBound[f2jai(i)]);\n+                    }\n+                    if (xopt.getEntry(i) == su.getEntry(i)) {\n+                        currentBest.setEntry(f2jai(i), upperBound[f2jai(i)]);\n+                    }\n+                }\n+                f = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n             }\n             return f;\n         }}\n      *\n      *     Set the first NPT components of W to the leading elements of the\n      *     KNEW-th column of the H matrix.\n-     * @param n\n-     * @param npt\n      * @param xpt\n      * @param xopt\n      * @param bmat\n      * @param zmat\n-     * @param ndim\n      * @param sl\n      * @param su\n-     * @param kopt\n      * @param knew\n      * @param adelt\n      * @param xnew\n      * @param xalt\n-     * @param alpha\n-     * @param cauchy\n-     * @param glag\n-     * @param hcol\n-     * @param w\n      */\n-    private void altmov(\n-            int n,\n-            int npt,\n-            ScopedPtr xpt,\n-            ScopedPtr xopt,\n-            ScopedPtr bmat,\n-            ScopedPtr zmat,\n-            int ndim, \n-            ScopedPtr sl,\n-            ScopedPtr su,\n-            int kopt,\n+    private double[] altmov(\n+            FortranMatrix xpt,\n+            FortranArray xopt,\n+            FortranMatrix bmat,\n+            FortranMatrix zmat,\n+            FortranArray sl,\n+            FortranArray su,\n             int knew,\n             double adelt,\n-            ScopedPtr xnew,\n-            ScopedPtr xalt,\n-            DoubleRef alpha,\n-            DoubleRef cauchy,\n-            ScopedPtr glag,\n-            ScopedPtr hcol,\n-            ScopedPtr w\n+            FortranArray xnew,\n+            FortranArray xalt\n     ) {\n+        // System.out.println(\"altmov\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+        final int ndim = bmat.getRowDimension();\n+\n+        final FortranArray glag = new FortranArray(n);\n+        final FortranArray hcol = new FortranArray(npt);\n+\n+        final FortranArray work1 = new FortranArray(n);\n+        final FortranArray work2 = new FortranArray(n);\n+\n+        double alpha = Double.NaN;\n+        double cauchy = Double.NaN;\n+\n         // System generated locals\n-        int xpt_dim1, bmat_dim1, zmat_dim1, i__1, i__2;\n         double d__1, d__2, d__3, d__4;\n \n         // Local variables\n-        int i__, j, k;\n-        double ha, gw, one, diff, half;\n+        double ha, gw, diff;\n         int ilbd, isbd;\n         double slbd;\n         int iubd;\n         double vlag, subd, temp;\n         int ksav = 0;\n-        double step = 0, zero = 0, curv = 0;\n+        double step = 0, curv = 0;\n         int iflag;\n         double scale = 0, csave = 0, tempa = 0, tempb = 0, tempd = 0, const__ = 0, sumin = 0, \n         ggfree = 0;\n         double dderiv = 0, bigstp = 0, predsq = 0, presav = 0, distsq = 0, stpsav = 0, wfixsq = 0, wsqsav = 0;\n \n \n-        zmat_dim1 = npt;\n-        xpt_dim1 = npt;\n-        bmat_dim1 = ndim;\n-\n         // Function Body\n-        half = .5;\n-        one = 1.;\n-        zero = 0.;\n-        const__ = one + Math.sqrt(2.);\n-        i__1 = npt;\n-        for (k = 1; k <= i__1; k++) {\n-            hcol.set(k, zero);\n-        }\n-        i__1 = npt - n - 1;\n-        for (j = 1; j <= i__1; j++) {\n-            temp = zmat.get(knew + j * zmat_dim1);\n-            i__2 = npt;\n-            for (k = 1; k <= i__2; k++) {\n-                hcol.set(k, hcol.get(k) + temp * zmat.get(k + j * zmat_dim1));\n-            }\n-        }\n-        alpha.value = hcol.get(knew);\n-        ha = half * alpha.value;\n+        const__ = ONE + Math.sqrt(2.);\n+        for (int k = 1; k <= npt; k++) {\n+            hcol.setEntry(k, ZERO);\n+        }\n+        for (int j = 1, max = npt - n - 1; j <= max; j++) {\n+            temp = zmat.getEntry(knew, j);\n+            for (int k = 1; k <= npt; k++) {\n+                hcol.setEntry(k, hcol.getEntry(k) + temp * zmat.getEntry(k, j));\n+            }\n+        }\n+        alpha = hcol.getEntry(knew);\n+        ha = HALF * alpha;\n \n         // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n \n-        i__2 = n;\n-        for (i__ = 1; i__ <= i__2; i__++) {\n-            glag.set(i__, bmat.get(knew + i__ * bmat_dim1));\n-        }\n-        i__2 = npt;\n-        for (k = 1; k <= i__2; k++) {\n-            temp = zero;\n-            i__1 = n;\n-            for (j = 1; j <= i__1; j++) {\n-                temp += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n-            }\n-            temp = hcol.get(k) * temp;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                glag.set(i__, glag.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+        for (int i = 1; i <= n; i++) {\n+            glag.setEntry(i, bmat.getEntry(knew, i));\n+        }\n+        for (int k = 1; k <= npt; k++) {\n+            temp = ZERO;\n+            for (int j = 1; j <= n; j++) {\n+                temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n+            }\n+            temp = hcol.getEntry(k) * temp;\n+            for (int i = 1; i <= n; i++) {\n+                glag.setEntry(i, glag.getEntry(i) + temp * xpt.getEntry(k, i));\n             }\n         }\n \n         // set to the square of the predicted denominator for each line. PRESAV\n         // will be set to the largest admissible value of PREDSQ that occurs.\n \n-        presav = zero;\n-        i__1 = npt;\n-        for (k = 1; k <= i__1; k++) {\n-            if (k == kopt) {\n+        presav = ZERO;\n+        for (int k = 1; k <= npt; k++) {\n+            if (k == trustRegionCenterInterpolationPointIndex) {\n                 continue;\n             }\n-            dderiv = zero;\n-            distsq = zero;\n-            i__2 = n;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n-                temp = xpt.get(k + i__ * xpt_dim1) - xopt.get(i__);\n-                dderiv += glag.get(i__) * temp;\n+            dderiv = ZERO;\n+            distsq = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                temp = xpt.getEntry(k, i) - xopt.getEntry(i);\n+                dderiv += glag.getEntry(i) * temp;\n                 distsq += temp * temp;\n             }\n             subd = adelt / Math.sqrt(distsq);\n             slbd = -subd;\n             ilbd = 0;\n             iubd = 0;\n-            sumin = Math.min(one,subd);\n+            sumin = Math.min(ONE, subd);\n \n             // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n \n-            i__2 = n;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n-                temp = xpt.get(k + i__ * xpt_dim1) - xopt.get(i__);\n-                if (temp > zero) {\n-                    if (slbd * temp < sl.get(i__) - xopt.get(i__)) {\n-                        slbd = (sl.get(i__) - xopt.get(i__)) / temp;\n-                        ilbd = -i__;\n-                    }\n-                    if (subd * temp > su.get(i__) - xopt.get(i__)) {\n+            for (int i = 1; i <= n; i++) {\n+                temp = xpt.getEntry(k, i) - xopt.getEntry(i);\n+                if (temp > ZERO) {\n+                    if (slbd * temp < sl.getEntry(i) - xopt.getEntry(i)) {\n+                        slbd = (sl.getEntry(i) - xopt.getEntry(i)) / temp;\n+                        ilbd = -i;\n+                    }\n+                    if (subd * temp > su.getEntry(i) - xopt.getEntry(i)) {\n                         // Computing MAX\n                         d__1 = sumin;\n-                        d__2 = (su.get(i__) - xopt.get(i__)) / temp;\n-                        subd = Math.max(d__1,d__2);\n-                        iubd = i__;\n-                    }\n-                } else if (temp < zero) {\n-                    if (slbd * temp > su.get(i__) - xopt.get(i__)) {\n-                        slbd = (su.get(i__) - xopt.get(i__)) / temp;\n-                        ilbd = i__;\n-                    }\n-                    if (subd * temp < sl.get(i__) - xopt.get(i__)) {\n+                        d__2 = (su.getEntry(i) - xopt.getEntry(i)) / temp;\n+                        subd = Math.max(d__1, d__2);\n+                        iubd = i;\n+                    }\n+                } else if (temp < ZERO) {\n+                    if (slbd * temp > su.getEntry(i) - xopt.getEntry(i)) {\n+                        slbd = (su.getEntry(i) - xopt.getEntry(i)) / temp;\n+                        ilbd = i;\n+                    }\n+                    if (subd * temp < sl.getEntry(i) - xopt.getEntry(i)) {\n                         // Computing MAX\n                         d__1 = sumin;\n-                        d__2 = (sl.get(i__) - xopt.get(i__)) / temp;\n-                        subd = Math.max(d__1,d__2);\n-                        iubd = -i__;\n+                        d__2 = (sl.getEntry(i) - xopt.getEntry(i)) / temp;\n+                        subd = Math.max(d__1, d__2);\n+                        iubd = -i;\n                     }\n                 }\n             }\n             // of the other interpolation point on the line through XOPT is KNEW.\n \n             if (k == knew) {\n-                diff = dderiv - one;\n+                diff = dderiv - ONE;\n                 step = slbd;\n                 vlag = slbd * (dderiv - slbd * diff);\n                 isbd = ilbd;\n                     vlag = temp;\n                     isbd = iubd;\n                 }\n-                tempd = half * dderiv;\n+                tempd = HALF * dderiv;\n                 tempa = tempd - diff * slbd;\n                 tempb = tempd - diff * subd;\n-                if (tempa * tempb < zero) {\n+                if (tempa * tempb < ZERO) {\n                     temp = tempd * tempd / diff;\n                     if (Math.abs(temp) > Math.abs(vlag)) {\n                         step = tempd / diff;\n \n             } else {\n                 step = slbd;\n-                vlag = slbd * (one - slbd);\n+                vlag = slbd * (ONE - slbd);\n                 isbd = ilbd;\n-                temp = subd * (one - subd);\n+                temp = subd * (ONE - subd);\n                 if (Math.abs(temp) > Math.abs(vlag)) {\n                     step = subd;\n                     vlag = temp;\n                     isbd = iubd;\n                 }\n-                if (subd > half) {\n+                if (subd > HALF) {\n                     if (Math.abs(vlag) < .25) {\n-                        step = half;\n-                        vlag = .25;\n+                        step = HALF;\n+                        vlag = ONE_OVER_FOUR;\n                         isbd = 0;\n                     }\n                 }\n \n             // Calculate PREDSQ for the current line search and maintain PRESAV.\n \n-            temp = step * (one - step) * distsq;\n+            temp = step * (ONE - step) * distsq;\n             predsq = vlag * vlag * (vlag * vlag + ha * temp * temp);\n             if (predsq > presav) {\n                 presav = predsq;\n \n         // Construct XNEW in a way that satisfies the bound constraints exactly.\n \n-        i__1 = n;\n-        for (i__ = 1; i__ <= i__1; i__++) {\n-            temp = xopt.get(i__) + stpsav * (xpt.get(ksav + i__ * xpt_dim1) - xopt.get(i__));\n+        for (int i = 1; i <= n; i++) {\n+            temp = xopt.getEntry(i) + stpsav * (xpt.getEntry(ksav, i) - xopt.getEntry(i));\n             // Computing MAX\n             // Computing MIN\n-            d__3 = su.get(i__);\n-            d__1 = sl.get(i__);\n-            d__2 = Math.min(d__3,temp);\n-            xnew.set(i__, Math.max(d__1,d__2));\n+            d__3 = su.getEntry(i);\n+            d__1 = sl.getEntry(i);\n+            d__2 = Math.min(d__3, temp);\n+            xnew.setEntry(i, Math.max(d__1, d__2));\n         }\n         if (ibdsav < 0) {\n-            xnew.set(-ibdsav, sl.get(-ibdsav));\n+            xnew.setEntry(-ibdsav, sl.getEntry(-ibdsav));\n         }\n         if (ibdsav > 0) {\n-            xnew.set(ibdsav, su.get(ibdsav));\n+            xnew.setEntry(ibdsav, su.getEntry(ibdsav));\n         }\n \n         // Prepare for the iterative method that assembles the constrained Cauchy\n         iflag = 0;\n \n         L100: for(;;) {\n-            wfixsq = zero;\n-            ggfree = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                w.set(i__, zero);\n+            wfixsq = ZERO;\n+            ggfree = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                work1.setEntry(i, ZERO);\n                 // Computing MIN\n-                d__1 = xopt.get(i__) - sl.get(i__);\n-                d__2 = glag.get(i__);\n-                tempa = Math.min(d__1,d__2);\n+                d__1 = xopt.getEntry(i) - sl.getEntry(i);\n+                d__2 = glag.getEntry(i);\n+                tempa = Math.min(d__1, d__2);\n                 // Computing MAX\n-                d__1 = xopt.get(i__) - su.get(i__);\n-                d__2 = glag.get(i__);\n-                tempb = Math.max(d__1,d__2);\n-                if (tempa > zero || tempb < zero) {\n-                    w.set(i__, bigstp);\n+                d__1 = xopt.getEntry(i) - su.getEntry(i);\n+                d__2 = glag.getEntry(i);\n+                tempb = Math.max(d__1, d__2);\n+                if (tempa > ZERO || tempb < ZERO) {\n+                    work1.setEntry(i, bigstp);\n                     // Computing 2nd power\n-                    d__1 = glag.get(i__);\n-                    ggfree += d__1 * d__1;\n-                }\n-            }\n-            if (ggfree == zero) {\n-                cauchy.value = zero;\n-                return;\n+                    final double d1 = glag.getEntry(i);\n+                    ggfree += d1 * d1;\n+                }\n+            }\n+            if (ggfree == ZERO) {\n+                cauchy = ZERO;\n+                return new double[] { alpha, cauchy };\n             }\n \n             // Investigate whether more components of W can be fixed.\n             L120: {\n                 temp = adelt * adelt - wfixsq;\n-                if (temp > zero) {\n+                if (temp > ZERO) {\n                     wsqsav = wfixsq;\n                     step = Math.sqrt(temp / ggfree);\n-                    ggfree = zero;\n-                    i__1 = n;\n-                    for (i__ = 1; i__ <= i__1; i__++) {\n-                        if (w.get(i__) == bigstp) {\n-                            temp = xopt.get(i__) - step * glag.get(i__);\n-                            if (temp <= sl.get(i__)) {\n-                                w.set(i__, sl.get(i__) - xopt.get(i__));\n+                    ggfree = ZERO;\n+                    for (int i = 1; i <= n; i++) {\n+                        if (work1.getEntry(i) == bigstp) {\n+                            temp = xopt.getEntry(i) - step * glag.getEntry(i);\n+                            if (temp <= sl.getEntry(i)) {\n+                                work1.setEntry(i, sl.getEntry(i) - xopt.getEntry(i));\n                                 // Computing 2nd power\n-                                d__1 = w.get(i__);\n-                                wfixsq += d__1 * d__1;\n-                            } else if (temp >= su.get(i__)) {\n-                                w.set(i__, su.get(i__) - xopt.get(i__));\n+                                final double d1 = work1.getEntry(i);\n+                                wfixsq += d1 * d1;\n+                            } else if (temp >= su.getEntry(i)) {\n+                                work1.setEntry(i, su.getEntry(i) - xopt.getEntry(i));\n                                 // Computing 2nd power\n-                                d__1 = w.get(i__);\n-                                wfixsq += d__1 * d__1;\n+                                final double d1 = work1.getEntry(i);\n+                                wfixsq += d1 * d1;\n                             } else {\n                                 // Computing 2nd power\n-                                d__1 = glag.get(i__);\n-                                ggfree += d__1 * d__1;\n+                                final double d1 = glag.getEntry(i);\n+                                ggfree += d1 * d1;\n                             }\n                         }\n                     }\n-                    if (!(wfixsq > wsqsav && ggfree > zero)) {\n+                    if (!(wfixsq > wsqsav && ggfree > ZERO)) {\n                         break L120;\n                     }\n                 }} // end L120\n             // Set the remaining free components of W and all components of XALT,\n             // except that W may be scaled later.\n \n-            gw = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (w.get(i__) == bigstp) {\n-                    w.set(i__, -step * glag.get(i__));\n-                    // Computing MAX\n-                    // Computing MIN\n-                    d__3 = su.get(i__);\n-                    d__4 = xopt.get(i__) + w.get(i__);\n-                    d__1 = sl.get(i__);\n-                    d__2 = Math.min(d__3,d__4);\n-                    xalt.set(i__, Math.max(d__1,d__2));\n-                } else if (w.get(i__) == zero) {\n-                    xalt.set(i__, xopt.get(i__));\n-                } else if (glag.get(i__) > zero) {\n-                    xalt.set(i__, sl.get(i__));\n+            gw = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                if (work1.getEntry(i) == bigstp) {\n+                    work1.setEntry(i, -step * glag.getEntry(i));\n+                    final double min = Math.min(su.getEntry(i),\n+                                                xopt.getEntry(i) + work1.getEntry(i));\n+                    xalt.setEntry(i, Math.max(sl.getEntry(i), min));\n+                } else if (work1.getEntry(i) == ZERO) {\n+                    xalt.setEntry(i, xopt.getEntry(i));\n+                } else if (glag.getEntry(i) > ZERO) {\n+                    xalt.setEntry(i, sl.getEntry(i));\n                 } else {\n-                    xalt.set(i__, su.get(i__));\n-                }\n-                gw += glag.get(i__) * w.get(i__);\n+                    xalt.setEntry(i, su.getEntry(i));\n+                }\n+                gw += glag.getEntry(i) * work1.getEntry(i);\n             }\n \n             // Set CURV to the curvature of the KNEW-th Lagrange function along W.\n             // the Lagrange function at XOPT+W. Set CAUCHY to the final value of\n             // the square of this function.\n \n-            curv = zero;\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n-                temp = zero;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n-                    temp += xpt.get(k + j * xpt_dim1) * w.get(j);\n-                }\n-                curv += hcol.get(k) * temp * temp;\n+            curv = ZERO;\n+            for (int k = 1; k <= npt; k++) {\n+                temp = ZERO;\n+                for (int j = 1; j <= n; j++) {\n+                    temp += xpt.getEntry(k, j) * work1.getEntry(j);\n+                }\n+                curv += hcol.getEntry(k) * temp * temp;\n             }\n             if (iflag == 1) {\n                 curv = -curv;\n             }\n             if (curv > -gw && curv < -const__ * gw) {\n                 scale = -gw / curv;\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    temp = xopt.get(i__) + scale * w.get(i__);\n+                for (int i = 1; i <= n; i++) {\n+                    temp = xopt.getEntry(i) + scale * work1.getEntry(i);\n                     // Computing MAX\n                     // Computing MIN\n-                    d__3 = su.get(i__);\n-                    d__1 = sl.get(i__);\n-                    d__2 = Math.min(d__3,temp);\n-                    xalt.set(i__, Math.max(d__1,d__2));\n+                    d__3 = su.getEntry(i);\n+                    d__2 = Math.min(d__3, temp);\n+                    xalt.setEntry(i, Math.max(sl.getEntry(i), d__2));\n                 }\n                 // Computing 2nd power\n-                d__1 = half * gw * scale;\n-                cauchy.value = d__1 * d__1;\n+                final double d1 = HALF * gw * scale;\n+                cauchy = d1 * d1;\n             } else {\n                 // Computing 2nd power\n-                d__1 = gw + half * curv;\n-                cauchy.value = d__1 * d__1;\n+                final double d1 = gw + HALF * curv;\n+                cauchy = d1 * d1;\n             }\n \n             // If IFLAG is zero, then XALT is calculated as before after reversing\n             // is chosen is the one that gives the larger value of CAUCHY.\n \n             if (iflag == 0) {\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    glag.set(i__, -glag.get(i__));\n-                    w.set(n + i__, xalt.get(i__));\n-                }\n-                csave = cauchy.value;\n+                for (int i = 1; i <= n; i++) {\n+                    glag.setEntry(i, -glag.getEntry(i));\n+                    work2.setEntry(i, xalt.getEntry(i));\n+                }\n+                csave = cauchy;\n                 iflag = 1;\n             } else {\n                 break L100;\n             }} // end L100\n-        if (csave > cauchy.value) {\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                xalt.set(i__, w.get(n + i__));\n-            }\n-            cauchy.value = csave;\n-        }\n+        if (csave > cauchy) {\n+            for (int i = 1; i <= n; i++) {\n+                xalt.setEntry(i, work2.getEntry(i));\n+            }\n+            cauchy = csave;\n+        }\n+\n+        return new double[] { alpha, cauchy };\n     } // altmov\n \n     // ----------------------------------------------------------------------------------------\n      *     KOPT will be such that the least calculated value of F so far is at\n      *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n      *\n-     * @param n\n-     * @param npt\n-     * @param x\n-     * @param xl\n-     * @param xu\n-     * @param rhobeg\n-     * @param maxfun\n+     * @param currentBest\n      * @param xbase\n      * @param xpt\n      * @param fval\n      * @param pq\n      * @param bmat\n      * @param zmat\n-     * @param ndim\n      * @param sl\n      * @param su\n-     * @param nf\n-     * @param kopt\n      */\n     private void prelim(\n-            int n,\n-            int npt,\n-            ScopedPtr x,\n-            ScopedPtr xl,\n-            ScopedPtr xu,\n-            double rhobeg,\n-            int maxfun,\n-            ScopedPtr xbase,\n-            ScopedPtr xpt,\n-            ScopedPtr fval,\n-            ScopedPtr gopt,\n-            ScopedPtr hq,\n-            ScopedPtr pq,\n-            ScopedPtr bmat,\n-            ScopedPtr zmat,\n-            int ndim,\n-            ScopedPtr sl,\n-            ScopedPtr su,\n-            IntRef nf,\n-            IntRef kopt\n+            ArrayRealVector currentBest,\n+            FortranArray xbase,\n+            FortranMatrix xpt,\n+            FortranArray fval,\n+            FortranArray gopt,\n+            FortranArray hq,\n+            FortranArray pq,\n+            FortranMatrix bmat,\n+            FortranMatrix zmat,\n+            FortranArray sl,\n+            FortranArray su\n     ) {\n+        // System.out.println(\"prelim\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+        final int ndim = bmat.getRowDimension();\n+\n+        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n+        final double recip = ONE / rhosq;\n+        final int np = n + 1;\n+\n         // System generated locals\n-        int xpt_dim1, bmat_dim1, zmat_dim1, i__1, i__2;\n         double d__1, d__2, d__3, d__4;\n \n         // Local variables\n         double f;\n-        int i__, j, k, ih, np, nfm;\n-        double one;\n+        int ih, nfm;\n         int nfx = 0, ipt = 0, jpt = 0;\n-        double two = 0, fbeg = 0, diff = 0, half = 0, temp = 0, zero = 0, recip = 0, stepa = 0, stepb = 0;\n+        double fbeg = 0, diff = 0, temp = 0, stepa = 0, stepb = 0;\n         int itemp;\n-        double rhosq;\n \n         // Set some constants.\n \n-        zmat_dim1 = npt;\n-        xpt_dim1 = npt;\n-        bmat_dim1 = ndim;\n-\n         // Function Body\n-        half = .5;\n-        one = 1.;\n-        two = 2.;\n-        zero = 0.;\n-        rhosq = rhobeg * rhobeg;\n-        recip = one / rhosq;\n-        np = n + 1;\n \n         // Set XBASE to the initial vector of variables, and set the initial\n         // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n \n-        i__1 = n;\n-        for (j = 1; j <= i__1; j++) {\n-            xbase.set(j, x.get(j));\n-            i__2 = npt;\n-            for (k = 1; k <= i__2; k++) {\n-                xpt.set(k + j * xpt_dim1, zero);\n-            }\n-            i__2 = ndim;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n-                bmat.set(i__ + j * bmat_dim1, zero);\n-            }\n-        }\n-        i__2 = n * np / 2;\n-        for (ih = 1; ih <= i__2; ih++) {\n-            hq.set(ih, zero);\n-        }\n-        i__2 = npt;\n-        for (k = 1; k <= i__2; k++) {\n-            pq.set(k, zero);\n-            i__1 = npt - np;\n-            for (j = 1; j <= i__1; j++) {\n-                zmat.set(k + j * zmat_dim1, zero);\n+        for (int j = 1; j <= n; j++) {\n+            xbase.setEntry(j, currentBest.getEntry(f2jai(j)));\n+            for (int k = 1; k <= npt; k++) {\n+                xpt.setEntry(k, j, ZERO);\n+            }\n+            for (int i = 1; i <= ndim; i++) {\n+                bmat.setEntry(i, j, ZERO);\n+            }\n+        }\n+        for (int i = 1, max = n * np / 2; i <= max; i++) {\n+            hq.setEntry(i, ZERO);\n+        }\n+        for (int k = 1; k <= npt; k++) {\n+            pq.setEntry(k, ZERO);\n+            for (int j = 1, max = npt - np; j <= max; j++) {\n+                zmat.setEntry(k, j, ZERO);\n             }\n         }\n \n         // of function values so far. The coordinates of the displacement of the\n         // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n \n-        nf.value = 0;\n         do {\n-            nfm = nf.value;\n-            nfx = nf.value - n;\n-            nf.value++;\n+            nfm = getEvaluations();\n+            nfx = getEvaluations() - n;\n+            final int curNumEvalPlusOne = getEvaluations() + 1;\n             if (nfm <= n << 1) {\n                 if (nfm >= 1 && nfm <= n) {\n-                    stepa = rhobeg;\n-                    if (su.get(nfm) == zero) {\n+                    stepa = initialTrustRegionRadius;\n+                    if (su.getEntry(nfm) == ZERO) {\n                         stepa = -stepa;\n                     }\n-                    xpt.set(nf.value + nfm * xpt_dim1, stepa);\n+                    xpt.setEntry(curNumEvalPlusOne, nfm, stepa);\n                 } else if (nfm > n) {\n-                    stepa = xpt.get(nf.value - n + nfx * xpt_dim1);\n-                    stepb = -rhobeg;\n-                    if (sl.get(nfx) == zero) {\n+                    stepa = xpt.getEntry(curNumEvalPlusOne - n, nfx);\n+                    stepb = -initialTrustRegionRadius;\n+                    if (sl.getEntry(nfx) == ZERO) {\n                         // Computing MIN\n-                        d__1 = two * rhobeg;\n-                        d__2 = su.get(nfx);\n-                        stepb = Math.min(d__1,d__2);\n-                    }\n-                    if (su.get(nfx) == zero) {\n+                        final double d1 = TWO * initialTrustRegionRadius;\n+                        stepb = Math.min(d1, su.getEntry(nfx));\n+                    }\n+                    if (su.getEntry(nfx) == ZERO) {\n                         // Computing MAX\n-                        d__1 = -two * rhobeg;\n-                        d__2 = sl.get(nfx);\n-                        stepb = Math.max(d__1,d__2);\n-                    }\n-                    xpt.set(nf.value + nfx * xpt_dim1, stepb);\n+                        final double d1 = -TWO * initialTrustRegionRadius;\n+                        stepb = Math.max(d1, sl.getEntry(nfx));\n+                    }\n+                    xpt.setEntry(curNumEvalPlusOne, nfx, stepb);\n                 }\n             } else {\n                 itemp = (nfm - np) / n;\n                     jpt = ipt - n;\n                     ipt = itemp;\n                 }\n-                xpt.set(nf.value + ipt * xpt_dim1, xpt.get(ipt + 1 + ipt * xpt_dim1));\n-                xpt.set(nf.value + jpt * xpt_dim1, xpt.get(jpt + 1 + jpt * xpt_dim1));\n+                xpt.setEntry(curNumEvalPlusOne, ipt, xpt.getEntry(ipt + 1, ipt));\n+                xpt.setEntry(curNumEvalPlusOne, jpt, xpt.getEntry(jpt + 1, jpt));\n             }\n \n             // Calculate the next value of F. The least function value so far and\n             // its index are required.\n \n-            i__1 = n;\n-            for (j = 1; j <= i__1; j++) {\n+            for (int j = 1; j <= n; j++) {\n                 // Computing MIN\n                 // Computing MAX\n-                d__3 = xl.get(j);\n-                d__4 = xbase.get(j) + xpt.get(nf.value + j * xpt_dim1);\n-                d__1 = Math.max(d__3,d__4);\n-                d__2 = xu.get(j);\n-                x.set(j, Math.min(d__1,d__2));\n-                if (xpt.get(nf.value + j * xpt_dim1) == sl.get(j)) {\n-                    x.set(j, xl.get(j));\n-                }\n-                if (xpt.get(nf.value + j * xpt_dim1) == su.get(j)) {\n-                    x.set(j, xu.get(j));\n-                }\n-            }\n-            f = computeObjectiveValue(x.getAll());\n+                d__3 = lowerBound[f2jai(j)];\n+                d__4 = xbase.getEntry(j) + xpt.getEntry(curNumEvalPlusOne, j);\n+                d__1 = Math.max(d__3, d__4);\n+                d__2 = upperBound[f2jai(j)];\n+                currentBest.setEntry(f2jai(j), Math.min(d__1, d__2));\n+                if (xpt.getEntry(curNumEvalPlusOne, j) == sl.getEntry(j)) {\n+                    currentBest.setEntry(f2jai(j), lowerBound[f2jai(j)]);\n+                }\n+                if (xpt.getEntry(curNumEvalPlusOne, j) == su.getEntry(j)) {\n+                    currentBest.setEntry(f2jai(j), upperBound[f2jai(j)]);\n+                }\n+            }\n+\n+            f = computeObjectiveValue(currentBest.getData());\n+\n             if (!isMinimize)\n                 f = -f;\n-            fval.set(nf.value, f);\n-            if (nf.value == 1) {\n+            fval.setEntry(getEvaluations(), f);\n+            if (getEvaluations() == 1) {\n                 fbeg = f;\n-                kopt.value = 1;\n-            } else if (f < fval.get(kopt.value)) {\n-                kopt.value = nf.value;\n+                trustRegionCenterInterpolationPointIndex = 1;\n+            } else if (f < fval.getEntry(trustRegionCenterInterpolationPointIndex)) {\n+                trustRegionCenterInterpolationPointIndex = getEvaluations();\n             }\n \n             // Set the nonzero initial elements of BMAT and the quadratic model in the\n             // order that the function value at the first of them contributes to the\n             // off-diagonal second derivative terms of the initial quadratic model.\n \n-            if (nf.value <= (n << 1) + 1) {\n-                if (nf.value >= 2 && nf.value <= n + 1) {\n-                    gopt.set( nfm, (f - fbeg) / stepa);\n-                    if (npt < nf.value + n) {\n-                        bmat.set( nfm * bmat_dim1 + 1, -one / stepa);\n-                        bmat.set( nf.value + nfm * bmat_dim1, one / stepa);\n-                        bmat.set( npt + nfm + nfm * bmat_dim1, -half * rhosq);\n-                    }\n-                } else if (nf.value >= n + 2) {\n+            if (getEvaluations() <= (n << 1) + 1) {\n+                if (getEvaluations() >= 2 && getEvaluations() <= n + 1) {\n+                    gopt.setEntry( nfm, (f - fbeg) / stepa);\n+                    if (npt < getEvaluations() + n) {\n+                        bmat.setEntry(1, nfm, -ONE / stepa);\n+                        bmat.setEntry( getEvaluations(), nfm, ONE / stepa);\n+                        bmat.setEntry( npt + nfm, nfm, -HALF * rhosq);\n+                    }\n+                } else if (getEvaluations() >= n + 2) {\n                     ih = nfx * (nfx + 1) / 2;\n                     temp = (f - fbeg) / stepb;\n                     diff = stepb - stepa;\n-                    hq.set(ih, two * (temp - gopt.get(nfx)) / diff);\n-                    gopt.set(nfx, (gopt.get(nfx) * stepb - temp * stepa) / diff);\n-                    if (stepa * stepb < zero) {\n-                        if (f < fval.get(nf.value - n)) {\n-                            fval.set(nf.value, fval.get(nf.value - n));\n-                            fval.set(nf.value - n, f);\n-                            if (kopt.value == nf.value) {\n-                                kopt.value = nf.value - n;\n+                    hq.setEntry(ih, TWO * (temp - gopt.getEntry(nfx)) / diff);\n+                    gopt.setEntry(nfx, (gopt.getEntry(nfx) * stepb - temp * stepa) / diff);\n+                    if (stepa * stepb < ZERO) {\n+                        if (f < fval.getEntry(getEvaluations() - n)) {\n+                            fval.setEntry(getEvaluations(), fval.getEntry(getEvaluations() - n));\n+                            fval.setEntry(getEvaluations() - n, f);\n+                            if (trustRegionCenterInterpolationPointIndex == getEvaluations()) {\n+                                trustRegionCenterInterpolationPointIndex = getEvaluations() - n;\n                             }\n-                            xpt.set(nf.value - n + nfx * xpt_dim1, stepb);\n-                            xpt.set(nf.value + nfx * xpt_dim1, stepa);\n+                            xpt.setEntry(getEvaluations() - n, nfx, stepb);\n+                            xpt.setEntry(getEvaluations(), nfx, stepa);\n                         }\n                     }\n-                    bmat.set( nfx * bmat_dim1 + 1, -(stepa + stepb) / (stepa * stepb));\n-                    bmat.set( nf.value + nfx * bmat_dim1, -half /\n-                            xpt.get(nf.value - n + nfx * xpt_dim1));\n-                    bmat.set( nf.value - n + nfx * bmat_dim1, -bmat.get( nfx * bmat_dim1 + 1) -\n-                            bmat.get( nf.value + nfx * bmat_dim1));\n-                    zmat.set( nfx * zmat_dim1 + 1, Math.sqrt(two) / (stepa * stepb));\n-                    zmat.set( nf.value + nfx * zmat_dim1, Math.sqrt(half) / rhosq);\n-                    zmat.set( nf.value - n + nfx * zmat_dim1, -zmat.get( nfx * zmat_dim1 + 1) -\n-                            zmat.get( nf.value + nfx * zmat_dim1));\n+                    bmat.setEntry(1, nfx, -(stepa + stepb) / (stepa * stepb));\n+                    bmat.setEntry( getEvaluations(), nfx, -HALF /\n+                                   xpt.getEntry(getEvaluations() - n, nfx));\n+                    bmat.setEntry( getEvaluations() - n, nfx, -bmat.getEntry(1, nfx) -\n+                                   bmat.getEntry( getEvaluations(), nfx));\n+                    zmat.setEntry(1, nfx, Math.sqrt(TWO) / (stepa * stepb));\n+                    zmat.setEntry( getEvaluations(), nfx, Math.sqrt(HALF) / rhosq);\n+                    zmat.setEntry( getEvaluations() - n, nfx, -zmat.getEntry(1, nfx) -\n+                                   zmat.getEntry( getEvaluations(), nfx));\n                 }\n \n                 // Set the off-diagonal second derivatives of the Lagrange functions and\n \n             } else {\n                 ih = ipt * (ipt - 1) / 2 + jpt;\n-                zmat.set( nfx * zmat_dim1 + 1, recip);\n-                zmat.set( nf.value + nfx * zmat_dim1, recip);\n-                zmat.set(ipt + 1 + nfx * zmat_dim1, -recip);\n-                zmat.set( jpt + 1 + nfx * zmat_dim1, -recip);\n-                temp = xpt.get(nf.value + ipt * xpt_dim1) * xpt.get(nf.value + jpt * xpt_dim1);\n-                hq.set(ih, (fbeg - fval.get(ipt + 1) - fval.get(jpt + 1) + f) / temp);\n-            }\n-        } while (nf.value < npt && nf.value < maxfun);\n+                zmat.setEntry(1, nfx, recip);\n+                zmat.setEntry( getEvaluations(), nfx, recip);\n+                zmat.setEntry(ipt + 1, nfx, -recip);\n+                zmat.setEntry( jpt + 1, nfx, -recip);\n+                temp = xpt.getEntry(getEvaluations(), ipt) * xpt.getEntry(getEvaluations(), jpt);\n+                hq.setEntry(ih, (fbeg - fval.getEntry(ipt + 1) - fval.getEntry(jpt + 1) + f) / temp);\n+            }\n+        } while (getEvaluations() < npt);\n     } // prelim\n \n     // ----------------------------------------------------------------------------------------\n      *       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise\n      *       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or\n      *       p=0, respectively.\n-     * @param n\n-     * @param npt\n-     * @param xl\n-     * @param xu\n-     * @param maxfun\n      * @param xbase\n      * @param xpt\n      * @param fval\n      * @param pq\n      * @param bmat\n      * @param zmat\n-     * @param ndim\n      * @param sl\n      * @param su\n-     * @param nf\n      * @param delta\n-     * @param kopt\n      * @param vlag\n-     * @param ptsaux\n-     * @param ptsid\n-     * @param w\n      */\n-    private void rescue (\n-            int n,\n-            int npt,\n-            ScopedPtr xl,\n-            ScopedPtr xu,\n-            int maxfun,\n-            ScopedPtr xbase,\n-            ScopedPtr xpt,\n-            ScopedPtr fval,\n-            ScopedPtr xopt,\n-            ScopedPtr gopt,\n-            ScopedPtr hq,\n-            ScopedPtr pq,\n-            ScopedPtr bmat,\n-            ScopedPtr zmat,\n-            int ndim,\n-            ScopedPtr sl,\n-            ScopedPtr su,\n-            IntRef nf,\n+    private void rescue(\n+            FortranArray xbase,\n+            FortranMatrix xpt,\n+            FortranArray fval,\n+            FortranArray xopt,\n+            FortranArray gopt,\n+            FortranArray hq,\n+            FortranArray pq,\n+            FortranMatrix bmat,\n+            FortranMatrix zmat,\n+            FortranArray sl,\n+            FortranArray su,\n             double delta,\n-            IntRef kopt,\n-            ScopedPtr vlag,\n-            ScopedPtr ptsaux,\n-            ScopedPtr ptsid,\n-            ScopedPtr w\n+            FortranArray vlag\n     ) {\n+        // System.out.println(\"rescue\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+        final int ndim = bmat.getRowDimension();\n+\n+        final FortranMatrix ptsaux = new FortranMatrix(n, 2);\n+        final FortranArray ptsid = new FortranArray(npt);\n+\n+        final FortranArray work1 = new FortranArray(npt); // Originally: w(1 .. npt).\n+        final FortranArray work2 = new FortranArray(n); // Originally: w(npt+1 .. npt+n).\n+        final FortranArray work3 = new FortranArray(npt); // Originally: w(npt+n+1 .. npt+n+npt).\n+\n+        final int np = n + 1;\n+        final double sfrac = HALF / (double) np;\n+        final int nptm = npt - np;\n+\n         // System generated locals\n-        int xpt_dim1, bmat_dim1, zmat_dim1,\n-        i__1, i__2, i__3;\n         double d__1, d__2, d__3, d__4;\n \n \n         // Local variables\n         double f;\n-        int i__, j, k, ih, jp, ip, iq, np;\n+        int ih, jp, ip, iq;\n         double xp = 0, xq = 0, den = 0;\n         int ihp = 0;\n-        double one;\n         int jpn, kpt;\n-        double sum = 0, diff = 0, half = 0, beta = 0;\n+        double sum = 0, diff = 0, beta = 0;\n         int kold;\n         double winc;\n         int nrem, knew;\n         double temp, bsum;\n-        int nptm;\n-        double zero = 0, hdiag = 0, fbase = 0, sfrac = 0, denom = 0, vquad = 0, sumpq = 0;\n+        double hdiag = 0, fbase = 0, denom = 0, vquad = 0, sumpq = 0;\n         double dsqmin, distsq, vlmxsq;\n \n         // Set some constants.\n-        zmat_dim1 = npt;\n-        xpt_dim1 = npt;\n-        bmat_dim1 = ndim;\n \n         // Function Body\n-        half = .5;\n-        one = 1.;\n-        zero = 0.;\n-        np = n + 1;\n-        sfrac = half / (double) np;\n-        nptm = npt - np;\n \n         // Shift the interpolation points so that XOPT becomes the origin, and set\n         // the elements of ZMAT to zero. The value of SUMPQ is required in the\n         // may be added later to these squares to balance the consideration of\n         // the choice of point that is going to become current.\n \n-        sumpq = zero;\n-        winc = zero;\n-        i__1 = npt;\n-        for (k = 1; k <= i__1; k++) {\n-            distsq = zero;\n-            i__2 = n;\n-            for (j = 1; j <= i__2; j++) {\n-                xpt.set(k + j * xpt_dim1, xpt.get(k + j * xpt_dim1) - xopt.get(j));\n+        sumpq = ZERO;\n+        winc = ZERO;\n+        for (int k = 1; k <= npt; k++) {\n+            distsq = ZERO;\n+            for (int j = 1; j <= n; j++) {\n+                xpt.setEntry(k, j, xpt.getEntry(k, j) - xopt.getEntry(j));\n                 // Computing 2nd power\n-                d__1 = xpt.get(k + j * xpt_dim1);\n-                distsq += d__1 * d__1;\n-            }\n-            sumpq += pq.get(k);\n-            w.set(ndim + k, distsq);\n-            winc = Math.max(winc,distsq);\n-            i__2 = nptm;\n-            for (j = 1; j <= i__2; j++) {\n-                zmat.set(k + j * zmat_dim1, zero);\n+                final double d1 = xpt.getEntry(k, j);\n+                distsq += d1 * d1;\n+            }\n+            sumpq += pq.getEntry(k);\n+            work3.setEntry(k, distsq);\n+            winc = Math.max(winc, distsq);\n+            for (int j = 1; j <= nptm; j++) {\n+                zmat.setEntry(k, j, ZERO);\n             }\n         }\n \n         // after XBASE has been shifted to the trust region centre.\n \n         ih = 0;\n-        i__2 = n;\n-        for (j = 1; j <= i__2; j++) {\n-            w.set(j, half * sumpq * xopt.get(j));\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n-                w.set(j, w.get(j) + pq.get(k) * xpt.get(k + j * xpt_dim1));\n-            }\n-            i__1 = j;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n+        for (int j = 1; j <= n; j++) {\n+            work2.setEntry(j, HALF * sumpq * xopt.getEntry(j));\n+            for (int k = 1; k <= npt; k++) {\n+                work2.setEntry(j, work2.getEntry(j) + pq.getEntry(k) * xpt.getEntry(k, j));\n+            }\n+            for (int i = 1; i <= j; i++) {\n                 ++ih;\n-                hq.set(ih, hq.get(ih) + w.get(i__) * xopt.get(j) + w.get(j) * xopt.get(i__));\n+                hq.setEntry(ih, hq.getEntry(ih) + work2.getEntry(i) * xopt.getEntry(j) + work2.getEntry(j) * xopt.getEntry(i));\n             }\n         }\n \n         // Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and\n         // also set the elements of PTSAUX.\n \n-        i__1 = n;\n-        for (j = 1; j <= i__1; j++) {\n-            xbase.set(j, xbase.get(j) + xopt.get(j));\n-            sl.set(j, sl.get(j) - xopt.get(j));\n-            su.set(j, su.get(j) - xopt.get(j));\n-            xopt.set(j, zero);\n+        for (int j = 1; j <= n; j++) {\n+            xbase.setEntry(j, xbase.getEntry(j) + xopt.getEntry(j));\n+            sl.setEntry(j, sl.getEntry(j) - xopt.getEntry(j));\n+            su.setEntry(j, su.getEntry(j) - xopt.getEntry(j));\n+            xopt.setEntry(j, ZERO);\n             // Computing MIN\n             d__1 = delta;\n-            d__2 = su.get(j);\n-            ptsaux.set((j << 1) + 1, Math.min(d__1,d__2));\n+            d__2 = su.getEntry(j);\n+            ptsaux.setEntry(j, 1, Math.min(d__1, d__2));\n             // Computing MAX\n             d__1 = -delta;\n-            d__2 = sl.get(j);\n-            ptsaux.set((j << 1) + 2, Math.max(d__1,d__2));\n-            if (ptsaux.get((j << 1) + 1) + ptsaux.get((j << 1) + 2) < zero) {\n-                temp = ptsaux.get((j << 1) + 1);\n-                ptsaux.set((j << 1) + 1, ptsaux.get((j << 1) + 2));\n-                ptsaux.set((j << 1) + 2, temp);\n-            }\n-            d__2 = ptsaux.get((j << 1) + 2);\n-            d__1 = ptsaux.get((j << 1) + 1);\n-            if (Math.abs(d__2) < half * Math.abs(d__1)) {\n-                ptsaux.set((j << 1) + 2, half * ptsaux.get((j << 1) + 1));\n-            }\n-            i__2 = ndim;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n-                bmat.set(i__ + j * bmat_dim1, zero);\n-            }\n-        }\n-        fbase = fval.get(kopt.value);\n+            d__2 = sl.getEntry(j);\n+            ptsaux.setEntry(j, 2, Math.max(d__1, d__2));\n+            if (ptsaux.getEntry(j, 1) + ptsaux.getEntry(j, 2) < ZERO) {\n+                temp = ptsaux.getEntry(j, 1);\n+                ptsaux.setEntry(j, 1, ptsaux.getEntry(j, 2));\n+                ptsaux.setEntry(j, 2, temp);\n+            }\n+            d__2 = ptsaux.getEntry(j, 2);\n+            d__1 = ptsaux.getEntry(j, 1);\n+            if (Math.abs(d__2) < HALF * Math.abs(d__1)) {\n+                ptsaux.setEntry(j, 2, HALF * ptsaux.getEntry(j, 1));\n+            }\n+            for (int i = 1; i <= ndim; i++) {\n+                bmat.setEntry(i, j, ZERO);\n+            }\n+        }\n+        fbase = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n \n         // Set the identifiers of the artificial interpolation points that are\n         // along a coordinate direction from XOPT, and set the corresponding\n         // nonzero elements of BMAT and ZMAT.\n \n-        ptsid.set(1, sfrac);\n-        i__2 = n;\n-        for (j = 1; j <= i__2; j++) {\n+        ptsid.setEntry(1, sfrac);\n+        for (int j = 1; j <= n; j++) {\n             jp = j + 1;\n             jpn = jp + n;\n-            ptsid.set(jp, (double) j + sfrac);\n+            ptsid.setEntry(jp, (double) j + sfrac);\n             if (jpn <= npt) {\n-                ptsid.set(jpn, (double) j / (double) np + sfrac);\n-                temp = one / (ptsaux.get((j << 1) + 1) - ptsaux.get((j << 1) + 2));\n-                bmat.set(jp + j * bmat_dim1, -temp + one / ptsaux.get((j << 1) + 1));\n-                bmat.set(jpn + j * bmat_dim1, temp + one / ptsaux.get((j << 1) + 2));\n-                bmat.set(j * bmat_dim1 + 1, -bmat.get(jp + j * bmat_dim1) - bmat.get(jpn +\n-                        j * bmat_dim1));\n-                d__1 = ptsaux.get((j << 1) + 1) * ptsaux.get((j << 1) + 2);\n-                zmat.set(j * zmat_dim1 + 1,  Math.sqrt(2.) / Math.abs(d__1));\n-                zmat.set(jp + j * zmat_dim1, zmat.get(j * zmat_dim1 + 1) *\n-                        ptsaux.get((j << 1) + 2) * temp);\n-                zmat.set(jpn + j * zmat_dim1, -zmat.get(j * zmat_dim1 + 1) *\n-                        ptsaux.get((j << 1) + 1) * temp);\n+                ptsid.setEntry(jpn, (double) j / (double) np + sfrac);\n+                temp = ONE / (ptsaux.getEntry(j, 1) - ptsaux.getEntry(j, 2));\n+                bmat.setEntry(jp, j, -temp + ONE / ptsaux.getEntry(j, 1));\n+                bmat.setEntry(jpn, j, temp + ONE / ptsaux.getEntry(j, 2));\n+                bmat.setEntry(1, j, -bmat.getEntry(jp, j) - bmat.getEntry(jpn, j));\n+                final double d1 = ptsaux.getEntry(j, 1) * ptsaux.getEntry(j, 2);\n+                zmat.setEntry(1, j,  Math.sqrt(TWO) / Math.abs(d1));\n+                zmat.setEntry(jp, j, zmat.getEntry(1, j) *\n+                        ptsaux.getEntry(j, 2) * temp);\n+                zmat.setEntry(jpn, j, -zmat.getEntry(1, j) *\n+                        ptsaux.getEntry(j, 1) * temp);\n             } else {\n-                bmat.set(j * bmat_dim1 + 1, -one / ptsaux.get((j << 1) + 1));\n-                bmat.set(jp + j * bmat_dim1, one / ptsaux.get((j << 1) + 1));\n+                bmat.setEntry(1, j, -ONE / ptsaux.getEntry(j, 1));\n+                bmat.setEntry(jp, j, ONE / ptsaux.getEntry(j, 1));\n                 // Computing 2nd power\n-                d__1 = ptsaux.get((j << 1) + 1);\n-                bmat.set(j + npt + j * bmat_dim1, -half * (d__1 * d__1));\n+                final double d1 = ptsaux.getEntry(j, 1);\n+                bmat.setEntry(j + npt, j, -HALF * (d1 * d1));\n             }\n         }\n \n         // Set any remaining identifiers with their nonzero elements of ZMAT.\n \n         if (npt >= n + np) {\n-            i__2 = npt;\n-            for (k = np << 1; k <= i__2; k++) {\n-                int iw = (int) (((double) (k - np) - half) / (double) n);\n+            for (int k = np << 1; k <= npt; k++) {\n+                int iw = (int) (((double) (k - np) - HALF) / (double) n);\n                 ip = k - np - iw * n;\n                 iq = ip + iw;\n                 if (iq > n) {\n                     iq -= n;\n                 }\n-                ptsid.set(k, (double) ip + (double) iq / (double) np +\n+                ptsid.setEntry(k, (double) ip + (double) iq / (double) np +\n                         sfrac);\n-                temp = one / (ptsaux.get((ip << 1) + 1) * ptsaux.get((iq << 1) + 1));\n-                zmat.set((k - np) * zmat_dim1 + 1, temp);\n-                zmat.set(ip + 1 + (k - np) * zmat_dim1, -temp);\n-                zmat.set(iq + 1 + (k - np) * zmat_dim1, -temp);\n-                zmat.set(k + (k - np) * zmat_dim1, temp);\n+                temp = ONE / (ptsaux.getEntry(ip, 1) * ptsaux.getEntry(iq, 1));\n+                zmat.setEntry(1, (k - np), temp);\n+                zmat.setEntry(ip + 1, k - np, -temp);\n+                zmat.setEntry(iq + 1, k - np, -temp);\n+                zmat.setEntry(k, k - np, temp);\n             }\n         }\n         nrem = npt;\n         kold = 1;\n-        knew = kopt.value;\n+        knew = trustRegionCenterInterpolationPointIndex;\n \n         // Reorder the provisional points in the way that exchanges PTSID(KOLD)\n         // with PTSID(KNEW).\n         int state = 80;\n         for(;;) switch (state) {\n         case 80: {\n-            i__2 = n;\n-            for (j = 1; j <= i__2; j++) {\n-                temp = bmat.get(kold + j * bmat_dim1);\n-                bmat.set(kold + j * bmat_dim1, bmat.get(knew + j * bmat_dim1));\n-                bmat.set(knew + j * bmat_dim1, temp);\n-            }\n-            i__2 = nptm;\n-            for (j = 1; j <= i__2; j++) {\n-                temp = zmat.get(kold + j * zmat_dim1);\n-                zmat.set(kold + j * zmat_dim1, zmat.get(knew + j * zmat_dim1));\n-                zmat.set(knew + j * zmat_dim1, temp);\n-            }\n-            ptsid.set(kold, ptsid.get(knew));\n-            ptsid.set(knew, zero);\n-            w.set(ndim + knew, zero);\n+            for (int j = 1; j <= n; j++) {\n+                temp = bmat.getEntry(kold, j);\n+                bmat.setEntry(kold, j, bmat.getEntry(knew, j));\n+                bmat.setEntry(knew, j, temp);\n+            }\n+            for (int j = 1; j <= nptm; j++) {\n+                temp = zmat.getEntry(kold, j);\n+                zmat.setEntry(kold, j, zmat.getEntry(knew, j));\n+                zmat.setEntry(knew, j, temp);\n+            }\n+            ptsid.setEntry(kold, ptsid.getEntry(knew));\n+            ptsid.setEntry(knew, ZERO);\n+            work3.setEntry(knew, ZERO);\n             --nrem;\n-            if (knew != kopt.value) {\n-                temp = vlag.get(kold);\n-                vlag.set(kold, vlag.get(knew));\n-                vlag.set(knew, temp);\n+            if (knew != trustRegionCenterInterpolationPointIndex) {\n+                temp = vlag.getEntry(kold);\n+                vlag.setEntry(kold, vlag.getEntry(knew));\n+                vlag.setEntry(knew, temp);\n \n                 // Update the BMAT and ZMAT matrices so that the status of the KNEW-th\n                 // interpolation point can be changed from provisional to original. The\n                 // branch to label 350 occurs if all the original points are reinstated.\n                 // The nonnegative values of W(NDIM+K) are required in the search below.\n \n-                update(n, npt, bmat, zmat, ndim, vlag,\n-                        beta, denom, knew, w);\n+                update(bmat, zmat, vlag,\n+                        beta, denom, knew);\n \n                 if (nrem == 0) {\n                     return;\n                 }\n-                i__2 = npt;\n-                for (k = 1; k <= i__2; k++) {\n-                    d__1 = w.get(ndim + k);\n-                    w.set(ndim + k, Math.abs(d__1));\n+                for (int k = 1; k <= npt; k++) {\n+                    work3.setEntry(k, Math.abs(work3.getEntry(k)));\n                 }\n             }\n \n             // attention to the closeness to XOPT and to previous tries with KNEW.\n         }\n         case 120: {\n-            dsqmin = zero;\n-            i__2 = npt;\n-            for (k = 1; k <= i__2; k++) {\n-                if (w.get(ndim + k) > zero) {\n-                    if (dsqmin == zero || w.get(ndim + k) < dsqmin) {\n+            dsqmin = ZERO;\n+            for (int k = 1; k <= npt; k++) {\n+                final double v1 = work3.getEntry(k);\n+                if (v1 > ZERO) {\n+                    if (dsqmin == ZERO ||\n+                        v1 < dsqmin) {\n                         knew = k;\n-                        dsqmin = w.get(ndim + k);\n-                    }\n-                }\n-            }\n-            if (dsqmin == zero) {\n+                        dsqmin = v1;\n+                    }\n+                }\n+            }\n+            if (dsqmin == ZERO) {\n                 state = 260; break;\n             }\n \n             // Form the W-vector of the chosen original interpolation point.\n \n-            i__2 = n;\n-            for (j = 1; j <= i__2; j++) {\n-                w.set(npt + j, xpt.get(knew + j * xpt_dim1));\n-            }\n-            i__2 = npt;\n-            for (k = 1; k <= i__2; k++) {\n-                sum = zero;\n-                if (k == kopt.value) {\n-                } else if (ptsid.get(k) == zero) {\n-                    i__1 = n;\n-                    for (j = 1; j <= i__1; j++) {\n-                        sum += w.get(npt + j) * xpt.get(k + j * xpt_dim1);\n+            for (int j = 1; j <= n; j++) {\n+                work2.setEntry(j, xpt.getEntry(knew, j));\n+            }\n+            for (int k = 1; k <= npt; k++) {\n+                sum = ZERO;\n+                if (k == trustRegionCenterInterpolationPointIndex) {\n+                } else if (ptsid.getEntry(k) == ZERO) {\n+                    for (int j = 1; j <= n; j++) {\n+                        sum += work2.getEntry(j) * xpt.getEntry(k, j);\n                     }\n                 } else {\n-                    ip = (int) ptsid.get(k);\n+                    ip = (int) ptsid.getEntry(k);\n                     if (ip > 0) {\n-                        sum = w.get(npt + ip) * ptsaux.get((ip << 1) + 1);\n-                    }\n-                    iq = (int) ((double) np * ptsid.get(k) - (double) (ip * np));\n+                        sum = work2.getEntry(ip) * ptsaux.getEntry(ip, 1);\n+                    }\n+                    iq = (int) ((double) np * ptsid.getEntry(k) - (double) (ip * np));\n                     if (iq > 0) {\n                         int iw = 1;\n                         if (ip == 0) {\n                             iw = 2;\n                         }\n-                        sum += w.get(npt + iq) * ptsaux.get(iw + (iq << 1));\n-                    }\n-                }\n-                w.set(k, half * sum * sum);\n+                        sum += work2.getEntry(iq) * ptsaux.getEntry(iq, iw);\n+                    }\n+                }\n+                work1.setEntry(k, HALF * sum * sum);\n             }\n \n             // Calculate VLAG and BETA for the required updating of the H matrix if\n             // XPT(KNEW,.) is reinstated in the set of interpolation points.\n \n-            i__2 = npt;\n-            for (k = 1; k <= i__2; k++) {\n-                sum = zero;\n-                i__1 = n;\n-                for (j = 1; j <= i__1; j++) {\n-                    sum += bmat.get(k + j * bmat_dim1) * w.get(npt + j);\n-                }\n-                vlag.set(k, sum);\n-            }\n-            beta = zero;\n-            i__2 = nptm;\n-            for (j = 1; j <= i__2; j++) {\n-                sum = zero;\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    sum += zmat.get(k + j * zmat_dim1) * w.get(k);\n+            for (int k = 1; k <= npt; k++) {\n+                sum = ZERO;\n+                for (int j = 1; j <= n; j++) {\n+                    sum += bmat.getEntry(k, j) * work2.getEntry(j);\n+                }\n+                vlag.setEntry(k, sum);\n+            }\n+            beta = ZERO;\n+            for (int j = 1; j <= nptm; j++) {\n+                sum = ZERO;\n+                for (int k = 1; k <= npt; k++) {\n+                    sum += zmat.getEntry(k, j) * work1.getEntry(k);\n                 }\n                 beta -= sum * sum;\n-                i__1 = npt;\n-                for (k = 1; k <= i__1; k++) {\n-                    vlag.set(k, vlag.get(k) + sum * zmat.get(k + j * zmat_dim1));\n-                }\n-            }\n-            bsum = zero;\n-            distsq = zero;\n-            i__1 = n;\n-            for (j = 1; j <= i__1; j++) {\n-                sum = zero;\n-                i__2 = npt;\n-                for (k = 1; k <= i__2; k++) {\n-                    sum += bmat.get(k + j * bmat_dim1) * w.get(k);\n+                for (int k = 1; k <= npt; k++) {\n+                    vlag.setEntry(k, vlag.getEntry(k) + sum * zmat.getEntry(k, j));\n+                }\n+            }\n+            bsum = ZERO;\n+            distsq = ZERO;\n+            for (int j = 1; j <= n; j++) {\n+                sum = ZERO;\n+                for (int k = 1; k <= npt; k++) {\n+                    sum += bmat.getEntry(k, j) * work1.getEntry(k);\n                 }\n                 jp = j + npt;\n-                bsum += sum * w.get(jp);\n-                i__2 = ndim;\n-                for (ip = npt; ip <= i__2; ip++) {\n-                    sum += bmat.get(ip + j * bmat_dim1) * w.get(ip);\n-                }\n-                bsum += sum * w.get(jp);\n-                vlag.set(jp, sum);\n+                bsum += sum * work2.getEntry(j);\n+                for (int k = 1; k <= n; k++) {\n+                    sum += bmat.getEntry(npt + k, j) * work2.getEntry(k);\n+                }\n+                bsum += sum * work2.getEntry(j);\n+                vlag.setEntry(jp, sum);\n                 // Computing 2nd power\n-                d__1 = xpt.get(knew + j * xpt_dim1);\n-                distsq += d__1 * d__1;\n-            }\n-            beta = half * distsq * distsq + beta - bsum;\n-            vlag.set(kopt.value, vlag.get(kopt.value) + one);\n+                final double d1 = xpt.getEntry(knew, j);\n+                distsq += d1 * d1;\n+            }\n+            beta = HALF * distsq * distsq + beta - bsum;\n+            vlag.setEntry(trustRegionCenterInterpolationPointIndex, vlag.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n \n             // KOLD is set to the index of the provisional interpolation point that is\n             // going to be deleted to make way for the KNEW-th original interpolation\n             // point. The choice of KOLD is governed by the avoidance of a small value\n             // of the denominator in the updating calculation of UPDATE.\n \n-            denom = zero;\n-            vlmxsq = zero;\n-            i__1 = npt;\n-            for (k = 1; k <= i__1; k++) {\n-                if (ptsid.get(k) != zero) {\n-                    hdiag = zero;\n-                    i__2 = nptm;\n-                    for (j = 1; j <= i__2; j++) {\n+            denom = ZERO;\n+            vlmxsq = ZERO;\n+            for (int k = 1; k <= npt; k++) {\n+                if (ptsid.getEntry(k) != ZERO) {\n+                    hdiag = ZERO;\n+                    for (int j = 1; j <= nptm; j++) {\n                         // Computing 2nd power\n-                        d__1 = zmat.get(k + j * zmat_dim1);\n-                        hdiag += d__1 * d__1;\n+                        final double d1 = zmat.getEntry(k, j);\n+                        hdiag += d1 * d1;\n                     }\n                     // Computing 2nd power\n-                    d__1 = vlag.get(k);\n-                    den = beta * hdiag + d__1 * d__1;\n+                    final double d1 = vlag.getEntry(k);\n+                    den = beta * hdiag + d1 * d1;\n                     if (den > denom) {\n                         kold = k;\n                         denom = den;\n                 }\n                 // Computing MAX\n                 // Computing 2nd power\n-                d__3 = vlag.get(k);\n-                d__1 = vlmxsq;\n-                d__2 = d__3 * d__3;\n-                vlmxsq = Math.max(d__1,d__2);\n+                final double d3 = vlag.getEntry(k);\n+                vlmxsq = Math.max(vlmxsq , d3 * d3);\n             }\n             if (denom <= vlmxsq * .01) {\n-                w.set(ndim + knew, -w.get(ndim + knew) - winc);\n+                work3.setEntry(knew, -work3.getEntry(knew) - winc);\n                 state = 120; break;\n             }\n             state = 80; break;\n \n         }\n         case 260: {\n-            i__1 = npt;\n-            for (kpt = 1; kpt <= i__1; kpt++) {\n-                if (ptsid.get(kpt) == zero) {\n+            for (kpt = 1; kpt <= npt; kpt++) {\n+                if (ptsid.getEntry(kpt) == ZERO) {\n                     continue;\n                 }\n-                if (nf.value >= maxfun) {\n-                    nf.value = -1;\n-                    return;\n-                }\n                 ih = 0;\n-                i__2 = n;\n-                for (j = 1; j <= i__2; j++) {\n-                    w.set(j, xpt.get(kpt + j * xpt_dim1));\n-                    xpt.set(kpt + j * xpt_dim1, zero);\n-                    temp = pq.get(kpt) * w.get(j);\n-                    i__3 = j;\n-                    for (i__ = 1; i__ <= i__3; i__++) {\n+                for (int j = 1; j <= n; j++) {\n+                    work2.setEntry(j, xpt.getEntry(kpt, j));\n+                    xpt.setEntry(kpt, j, ZERO);\n+                    temp = pq.getEntry(kpt) * work2.getEntry(j);\n+                    for (int i = 1; i <= j; i++) {\n                         ++ih;\n-                        hq.set(ih, hq.get(ih) + temp * w.get(i__));\n-                    }\n-                }\n-                pq.set(kpt, zero);\n-                ip = (int) ptsid.get(kpt);\n-                iq = (int) ((double) np * ptsid.get(kpt) - (double) (ip * np))\n-                ;\n+                        hq.setEntry(ih, hq.getEntry(ih) + temp * work2.getEntry(i));\n+                    }\n+                }\n+                pq.setEntry(kpt, ZERO);\n+                ip = (int) ptsid.getEntry(kpt);\n+                iq = (int) ((double) np * ptsid.getEntry(kpt) - (double) (ip * np));\n                 if (ip > 0) {\n-                    xp = ptsaux.get((ip << 1) + 1);\n-                    xpt.set(kpt + ip * xpt_dim1, xp);\n+                    xp = ptsaux.getEntry(ip, 1);\n+                    xpt.setEntry(kpt, ip, xp);\n                 }\n                 if (iq > 0) {\n-                    xq = ptsaux.get((iq << 1) + 1);\n+                    xq = ptsaux.getEntry(iq, 1);\n                     if (ip == 0) {\n-                        xq = ptsaux.get((iq << 1) + 2);\n-                    }\n-                    xpt.set(kpt + iq * xpt_dim1, xq);\n+                        xq = ptsaux.getEntry(iq, 2);\n+                    }\n+                    xpt.setEntry(kpt, iq, xq);\n                 }\n \n                 // Set VQUAD to the value of the current model at the new point.\n                 vquad = fbase;\n                 if (ip > 0) {\n                     ihp = (ip + ip * ip) / 2;\n-                    vquad += xp * (gopt.get(ip) + half * xp * hq.get(ihp));\n+                    vquad += xp * (gopt.getEntry(ip) + HALF * xp * hq.getEntry(ihp));\n                 }\n                 if (iq > 0) {\n                     int ihq = (iq + iq * iq) / 2;\n-                    vquad += xq * (gopt.get(iq) + half * xq * hq.get(ihq));\n+                    vquad += xq * (gopt.getEntry(iq) + HALF * xq * hq.getEntry(ihq));\n                     if (ip > 0) {\n-                        i__3 = ip - iq;\n-                        int iiw = Math.max(ihp,ihq) - Math.abs(i__3);\n-                        vquad += xp * xq * hq.get(iiw);\n-                    }\n-                }\n-                i__3 = npt;\n-                for (k = 1; k <= i__3; k++) {\n-                    temp = zero;\n+                        int iiw = Math.max(ihp, ihq) - Math.abs(ip - iq);\n+                        vquad += xp * xq * hq.getEntry(iiw);\n+                    }\n+                }\n+                for (int k = 1; k <= npt; k++) {\n+                    temp = ZERO;\n                     if (ip > 0) {\n-                        temp += xp * xpt.get(k + ip * xpt_dim1);\n+                        temp += xp * xpt.getEntry(k, ip);\n                     }\n                     if (iq > 0) {\n-                        temp += xq * xpt.get(k + iq * xpt_dim1);\n-                    }\n-                    vquad += half * pq.get(k) * temp * temp;\n+                        temp += xq * xpt.getEntry(k, iq);\n+                    }\n+                    vquad += HALF * pq.getEntry(k) * temp * temp;\n                 }\n \n                 // Calculate F at the new interpolation point, and set DIFF to the factor\n                 // that is going to multiply the KPT-th Lagrange function when the model\n                 // is updated to provide interpolation to the new function value.\n \n-                i__3 = n;\n-                for (i__ = 1; i__ <= i__3; i__++) {\n+                for (int i = 1; i <= n; i++) {\n                     // Computing MIN\n                     // Computing MAX\n-                    d__3 = xl.get(i__);\n-                    d__4 = xbase.get(i__) + xpt.get(kpt + i__ * xpt_dim1);\n-                    d__1 = Math.max(d__3,d__4);\n-                    d__2 = xu.get(i__);\n-                    w.set(i__, Math.min(d__1,d__2));\n-                    if (xpt.get(kpt + i__ * xpt_dim1) == sl.get(i__)) {\n-                        w.set(i__, xl.get(i__));\n-                    }\n-                    if (xpt.get(kpt + i__ * xpt_dim1) == su.get(i__)) {\n-                        w.set(i__, xu.get(i__));\n-                    }\n-                }\n-                nf.value++;\n-                f = computeObjectiveValue(w.getAll(1,n));\n+                    d__3 = lowerBound[f2jai(i)];\n+                    d__4 = xbase.getEntry(i) + xpt.getEntry(kpt, i);\n+                    d__1 = Math.max(d__3, d__4);\n+                    d__2 = upperBound[f2jai(i)];\n+                    work2.setEntry(i, Math.min(d__1, d__2));\n+                    if (xpt.getEntry(kpt, i) == sl.getEntry(i)) {\n+                        work2.setEntry(i, lowerBound[f2jai(i)]);\n+                    }\n+                    if (xpt.getEntry(kpt, i) == su.getEntry(i)) {\n+                        work2.setEntry(i, upperBound[f2jai(i)]);\n+                    }\n+                }\n+\n+                f = computeObjectiveValue(work2.getData());\n+\n                 if (!isMinimize)\n                     f = -f;\n-                fval.set(kpt, f);\n-                if (f < fval.get(kopt.value)) {\n-                    kopt.value = kpt;\n+                fval.setEntry(kpt, f);\n+                if (f < fval.getEntry(trustRegionCenterInterpolationPointIndex)) {\n+                    trustRegionCenterInterpolationPointIndex = kpt;\n                 }\n                 diff = f - vquad;\n \n                 // Update the quadratic model. The RETURN from the subroutine occurs when\n                 // all the new interpolation points are included in the model.\n \n-                i__3 = n;\n-                for (i__ = 1; i__ <= i__3; i__++) {\n-                    gopt.set(i__, gopt.get(i__) + diff * bmat.get(kpt + i__ * bmat_dim1));\n-                }\n-                i__3 = npt;\n-                for (k = 1; k <= i__3; k++) {\n-                    sum = zero;\n-                    i__2 = nptm;\n-                    for (j = 1; j <= i__2; j++) {\n-                        sum += zmat.get(k + j * zmat_dim1) * zmat.get(kpt + j * zmat_dim1);\n+                for (int i = 1; i <= n; i++) {\n+                    gopt.setEntry(i, gopt.getEntry(i) + diff * bmat.getEntry(kpt, i));\n+                }\n+                for (int k = 1; k <= npt; k++) {\n+                    sum = ZERO;\n+                    for (int j = 1; j <= nptm; j++) {\n+                        sum += zmat.getEntry(k, j) * zmat.getEntry(kpt, j);\n                     }\n                     temp = diff * sum;\n-                    if (ptsid.get(k) == zero) {\n-                        pq.set(k, pq.get(k) + temp);\n+                    if (ptsid.getEntry(k) == ZERO) {\n+                        pq.setEntry(k, pq.getEntry(k) + temp);\n                     } else {\n-                        ip = (int) ptsid.get(k);\n-                        iq = (int) ((double) np * ptsid.get(k) - (double) (ip * np));\n+                        ip = (int) ptsid.getEntry(k);\n+                        iq = (int) ((double) np * ptsid.getEntry(k) - (double) (ip * np));\n                         int ihq = (iq * iq + iq) / 2;\n                         if (ip == 0) {\n                             // Computing 2nd power\n-                            d__1 = ptsaux.get((iq << 1) + 2);\n-                            hq.set(ihq, hq.get(ihq) + temp * (d__1 * d__1));\n+                            final double d1 = ptsaux.getEntry(iq, 2);\n+                            hq.setEntry(ihq, hq.getEntry(ihq) + temp * (d1 * d1));\n                         } else {\n                             ihp = (ip * ip + ip) / 2;\n                             // Computing 2nd power\n-                            d__1 = ptsaux.get((ip << 1) + 1);\n-                            hq.set(ihp, hq.get(ihp) + temp * (d__1 * d__1));\n+                            final double d1 = ptsaux.getEntry(ip, 1);\n+                            hq.setEntry(ihp, hq.getEntry(ihp) + temp * (d1 * d1));\n                             if (iq > 0) {\n                                 // Computing 2nd power\n-                                d__1 = ptsaux.get((iq << 1) + 1);\n-                                hq.set(ihq, hq.get(ihq) + temp * (d__1 * d__1));\n-                                i__2 = iq - ip;\n-                                int iw = Math.max(ihp,ihq) - Math.abs(i__2);\n-                                hq.set(iw, hq.get(iw) + temp * ptsaux.get((ip << 1) + 1) * ptsaux.get((iq <<\n-                                        1) + 1));\n+                                final double d2 = ptsaux.getEntry(iq, 1);\n+                                hq.setEntry(ihq, hq.getEntry(ihq) + temp * (d2 * d2));\n+                                int iw = Math.max(ihp,ihq) - Math.abs(iq - ip);\n+                                hq.setEntry(iw, hq.getEntry(iw)\n+                                            + temp * ptsaux.getEntry(ip, 1) * ptsaux.getEntry(iq, 1));\n                             }\n                         }\n                     }\n                 }\n-                ptsid.set(kpt, zero);\n+                ptsid.setEntry(kpt, ZERO);\n             }\n             return;\n         }}\n     } // rescue\n+\n \n \n     // ----------------------------------------------------------------------------------------\n      *       gradient searches that are not restricted by any constraints. The\n      *       value CRVMIN=-1.0D0 is set, however, if all of these searches are\n      *       constrained.\n-     * @param n\n-     * @param npt\n      * @param xpt\n      * @param xopt\n      * @param gopt\n      * @param s\n      * @param hs\n      * @param hred\n-     * @param dsq\n-     * @param crvmin\n      */\n-    private void trsbox(\n-            int n,\n-            int npt,\n-            ScopedPtr xpt,\n-            ScopedPtr xopt,\n-            ScopedPtr gopt,\n-            ScopedPtr hq,\n-            ScopedPtr pq,\n-            ScopedPtr sl,\n-            ScopedPtr su,\n+    private double[] trsbox(\n+            FortranMatrix xpt,\n+            FortranArray xopt,\n+            FortranArray gopt,\n+            FortranArray hq,\n+            FortranArray pq,\n+            FortranArray sl,\n+            FortranArray su,\n             double delta,\n-            ScopedPtr xnew,\n-            ScopedPtr d__,\n-            ScopedPtr gnew,\n-            ScopedPtr xbdi,\n-            ScopedPtr s,\n-            ScopedPtr hs,\n-            ScopedPtr hred,\n-            DoubleRef dsq,\n-            DoubleRef crvmin\n+            FortranArray xnew,\n+            FortranArray d__,\n+            FortranArray gnew,\n+            FortranArray xbdi,\n+            FortranArray s,\n+            FortranArray hs,\n+            FortranArray hred\n     ) {\n+        // System.out.println(\"trsbox\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+\n+        double dsq = Double.NaN;\n+        double crvmin = Double.NaN;\n+\n         // System generated locals\n-        int xpt_dim1, i__1, i__2;\n         double d__1, d__2, d__3, d__4;\n \n         // Local variables\n-        int i__, j, k, ih;\n+        int ih;\n         double ds;\n         int iu;\n-        double dhd, dhs, cth, one, shs, sth, ssq, half, beta=0, sdec, blen;\n+        double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;\n         int iact = 0, nact = 0;\n         double angt = 0, qred;\n         int isav;\n-        double temp = 0, zero = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n+        double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n         int iterc;\n         double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n-        redmax = 0, dredsq = 0, redsav = 0, onemin = 0, gredsq = 0, rednew = 0;\n+        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;\n         int itcsav = 0;\n         double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;\n         int itermax = 0;\n \n         // Set some constants.\n-        xpt_dim1 = npt;\n \n         // Function Body\n-        half = .5;\n-        one = 1.;\n-        onemin = -1.;\n-        zero = 0.;\n \n         // The sign of GOPT(I) gives the sign of the change to the I-th variable\n         // that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether\n \n         iterc = 0;\n         nact = 0;\n-        i__1 = n;\n-        for (i__ = 1; i__ <= i__1; i__++) {\n-            xbdi.set(i__, zero);\n-            if (xopt.get(i__) <= sl.get(i__)) {\n-                if (gopt.get(i__) >= zero) {\n-                    xbdi.set(i__, onemin);\n-                }\n-            } else if (xopt.get(i__) >= su.get(i__)) {\n-                if (gopt.get(i__) <= zero) {\n-                    xbdi.set(i__, one);\n-                }\n-            }\n-            if (xbdi.get(i__) != zero) {\n+        for (int i = 1; i <= n; i++) {\n+            xbdi.setEntry(i, ZERO);\n+            if (xopt.getEntry(i) <= sl.getEntry(i)) {\n+                if (gopt.getEntry(i) >= ZERO) {\n+                    xbdi.setEntry(i, MINUS_ONE);\n+                }\n+            } else if (xopt.getEntry(i) >= su.getEntry(i)) {\n+                if (gopt.getEntry(i) <= ZERO) {\n+                    xbdi.setEntry(i, ONE);\n+                }\n+            }\n+            if (xbdi.getEntry(i) != ZERO) {\n                 ++nact;\n             }\n-            d__.set(i__, zero);\n-            gnew.set(i__, gopt.get(i__));\n+            d__.setEntry(i, ZERO);\n+            gnew.setEntry(i, gopt.getEntry(i));\n         }\n         delsq = delta * delta;\n-        qred = zero;\n-        crvmin.value = onemin;\n+        qred = ZERO;\n+        crvmin = MINUS_ONE;\n \n         // Set the next search direction of the conjugate gradient method. It is\n         // the steepest descent direction initially and when the iterations are\n         for(;;) switch (state) {\n \n         case 20: {\n-            beta = zero;\n+            beta = ZERO;\n         }\n         case 30: {\n-            stepsq = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (xbdi.get(i__) != zero) {\n-                    s.set(i__, zero);\n-                } else if (beta == zero) {\n-                    s.set(i__, -gnew.get(i__));\n+            stepsq = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                if (xbdi.getEntry(i) != ZERO) {\n+                    s.setEntry(i, ZERO);\n+                } else if (beta == ZERO) {\n+                    s.setEntry(i, -gnew.getEntry(i));\n                 } else {\n-                    s.set(i__, beta * s.get(i__) - gnew.get(i__));\n+                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                 }\n                 // Computing 2nd power\n-                d__1 = s.get(i__);\n-                stepsq += d__1 * d__1;\n-            }\n-            if (stepsq == zero) {\n+                final double d1 = s.getEntry(i);\n+                stepsq += d1 * d1;\n+            }\n+            if (stepsq == ZERO) {\n                 state = 190; break;\n             }\n-            if (beta == zero) {\n+            if (beta == ZERO) {\n                 gredsq = stepsq;\n                 itermax = iterc + n - nact;\n             }\n         }\n         case 50: {\n             resid = delsq;\n-            ds = zero;\n-            shs = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (xbdi.get(i__) == zero) {\n+            ds = ZERO;\n+            shs = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                if (xbdi.getEntry(i) == ZERO) {\n                     // Computing 2nd power\n-                    d__1 = d__.get(i__);\n-                    resid -= d__1 * d__1;\n-                    ds += s.get(i__) * d__.get(i__);\n-                    shs += s.get(i__) * hs.get(i__);\n-                }\n-            }\n-            if (resid <= zero) {\n+                    final double d1 = d__.getEntry(i);\n+                    resid -= d1 * d1;\n+                    ds += s.getEntry(i) * d__.getEntry(i);\n+                    shs += s.getEntry(i) * hs.getEntry(i);\n+                }\n+            }\n+            if (resid <= ZERO) {\n                 state = 90; break;\n             }\n             temp = Math.sqrt(stepsq * resid + ds * ds);\n-            if (ds < zero) {\n+            if (ds < ZERO) {\n                 blen = (temp - ds) / stepsq;\n             } else {\n                 blen = resid / (temp + ds);\n             }\n             stplen = blen;\n-            if (shs > zero) {\n+            if (shs > ZERO) {\n                 // Computing MIN\n-                d__1 = blen;\n-                d__2 = gredsq / shs;\n-                stplen = Math.min(d__1,d__2);\n+                stplen = Math.min(blen, gredsq / shs);\n             }\n \n             // Reduce STPLEN if necessary in order to preserve the simple bounds,\n             // letting IACT be the index of the new constrained variable.\n \n             iact = 0;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (s.get(i__) != zero) {\n-                    xsum = xopt.get(i__) + d__.get(i__);\n-                    if (s.get(i__) > zero) {\n-                        temp = (su.get(i__) - xsum) / s.get(i__);\n+            for (int i = 1; i <= n; i++) {\n+                if (s.getEntry(i) != ZERO) {\n+                    xsum = xopt.getEntry(i) + d__.getEntry(i);\n+                    if (s.getEntry(i) > ZERO) {\n+                        temp = (su.getEntry(i) - xsum) / s.getEntry(i);\n                     } else {\n-                        temp = (sl.get(i__) - xsum) / s.get(i__);\n+                        temp = (sl.getEntry(i) - xsum) / s.getEntry(i);\n                     }\n                     if (temp < stplen) {\n                         stplen = temp;\n-                        iact = i__;\n+                        iact = i;\n                     }\n                 }\n             }\n \n             // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n \n-            sdec = zero;\n-            if (stplen > zero) {\n+            sdec = ZERO;\n+            if (stplen > ZERO) {\n                 ++iterc;\n                 temp = shs / stepsq;\n-                if (iact == 0 && temp > zero) {\n-                    crvmin.value = Math.min(crvmin.value,temp);\n-                    if (crvmin.value == onemin) {\n-                        crvmin.value = temp;\n+                if (iact == 0 && temp > ZERO) {\n+                    crvmin = Math.min(crvmin,temp);\n+                    if (crvmin == MINUS_ONE) {\n+                        crvmin = temp;\n                     }\n                 }\n                 ggsav = gredsq;\n-                gredsq = zero;\n-                i__1 = n;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    gnew.set(i__, gnew.get(i__) + stplen * hs.get(i__));\n-                    if (xbdi.get(i__) == zero) {\n+                gredsq = ZERO;\n+                for (int i = 1; i <= n; i++) {\n+                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n+                    if (xbdi.getEntry(i) == ZERO) {\n                         // Computing 2nd power\n-                        d__1 = gnew.get(i__);\n-                        gredsq += d__1 * d__1;\n-                    }\n-                    d__.set(i__, d__.get(i__) + stplen * s.get(i__));\n+                        final double d1 = gnew.getEntry(i);\n+                        gredsq += d1 * d1;\n+                    }\n+                    d__.setEntry(i, d__.getEntry(i) + stplen * s.getEntry(i));\n                 }\n                 // Computing MAX\n-                d__1 = stplen * (ggsav - half * stplen * shs);\n-                sdec = Math.max(d__1,zero);\n+                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n+                sdec = Math.max(d1, ZERO);\n                 qred += sdec;\n             }\n \n \n             if (iact > 0) {\n                 ++nact;\n-                xbdi.set(iact, one);\n-                if (s.get(iact) < zero) {\n-                    xbdi.set(iact, onemin);\n+                xbdi.setEntry(iact, ONE);\n+                if (s.getEntry(iact) < ZERO) {\n+                    xbdi.setEntry(iact, MINUS_ONE);\n                 }\n                 // Computing 2nd power\n-                d__1 = d__.get(iact);\n-                delsq -= d__1 * d__1;\n-                if (delsq <= zero) {\n+                final double d1 = d__.getEntry(iact);\n+                delsq -= d1 * d1;\n+                if (delsq <= ZERO) {\n                     state = 190; break;\n                 }\n                 state = 20; break;\n             }\n         }\n         case 90: {\n-            crvmin.value = zero;\n+            crvmin = ZERO;\n \n             // Prepare for the alternative iteration by calculating some scalars\n             // and by multiplying the reduced D by the second derivative matrix of\n             if (nact >= n - 1) {\n                 state = 190; break;\n             }\n-            dredsq = zero;\n-            dredg = zero;\n-            gredsq = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (xbdi.get(i__) == zero) {\n+            dredsq = ZERO;\n+            dredg = ZERO;\n+            gredsq = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                if (xbdi.getEntry(i) == ZERO) {\n                     // Computing 2nd power\n-                    d__1 = d__.get(i__);\n-                    dredsq += d__1 * d__1;\n-                    dredg += d__.get(i__) * gnew.get(i__);\n+                    double d1 = d__.getEntry(i);\n+                    dredsq += d1 * d1;\n+                    dredg += d__.getEntry(i) * gnew.getEntry(i);\n                     // Computing 2nd power\n-                    d__1 = gnew.get(i__);\n-                    gredsq += d__1 * d__1;\n-                    s.set(i__, d__.get(i__));\n+                    d1 = gnew.getEntry(i);\n+                    gredsq += d1 * d1;\n+                    s.setEntry(i, d__.getEntry(i));\n                 } else {\n-                    s.set(i__, zero);\n+                    s.setEntry(i, ZERO);\n                 }\n             }\n             itcsav = iterc;\n                 state = 190; break;\n             }\n             temp = Math.sqrt(temp);\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (xbdi.get(i__) == zero) {\n-                    s.set(i__, (dredg * d__.get(i__) - dredsq * gnew.get(i__)) / temp);\n+            for (int i = 1; i <= n; i++) {\n+                if (xbdi.getEntry(i) == ZERO) {\n+                    s.setEntry(i, (dredg * d__.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                 } else {\n-                    s.set(i__, zero);\n+                    s.setEntry(i, ZERO);\n                 }\n             }\n             sredg = -temp;\n             // namely ANGBD, except that, if already a free variable has reached a\n             // bound, there is a branch back to label 100 after fixing that variable.\n \n-            angbd = one;\n+            angbd = ONE;\n             iact = 0;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (xbdi.get(i__) == zero) {\n-                    tempa = xopt.get(i__) + d__.get(i__) - sl.get(i__);\n-                    tempb = su.get(i__) - xopt.get(i__) - d__.get(i__);\n-                    if (tempa <= zero) {\n+            for (int i = 1; i <= n; i++) {\n+                if (xbdi.getEntry(i) == ZERO) {\n+                    tempa = xopt.getEntry(i) + d__.getEntry(i) - sl.getEntry(i);\n+                    tempb = su.getEntry(i) - xopt.getEntry(i) - d__.getEntry(i);\n+                    if (tempa <= ZERO) {\n                         ++nact;\n-                        xbdi.set(i__, onemin);\n+                        xbdi.setEntry(i, MINUS_ONE);\n                         state = 100; break;\n-                    } else if (tempb <= zero) {\n+                    } else if (tempb <= ZERO) {\n                         ++nact;\n-                        xbdi.set(i__, one);\n+                        xbdi.setEntry(i, ONE);\n                         state = 100; break;\n                     }\n                     // Computing 2nd power\n-                    d__1 = d__.get(i__);\n+                    double d1 = d__.getEntry(i);\n                     // Computing 2nd power\n-                    d__2 = s.get(i__);\n-                    ssq = d__1 * d__1 + d__2 * d__2;\n+                    double d2 = s.getEntry(i);\n+                    ssq = d1 * d1 + d2 * d2;\n                     // Computing 2nd power\n-                    d__1 = xopt.get(i__) - sl.get(i__);\n-                    temp = ssq - d__1 * d__1;\n-                    if (temp > zero) {\n-                        temp = Math.sqrt(temp) - s.get(i__);\n+                    d1 = xopt.getEntry(i) - sl.getEntry(i);\n+                    temp = ssq - d1 * d1;\n+                    if (temp > ZERO) {\n+                        temp = Math.sqrt(temp) - s.getEntry(i);\n                         if (angbd * temp > tempa) {\n                             angbd = tempa / temp;\n-                            iact = i__;\n-                            xsav = onemin;\n+                            iact = i;\n+                            xsav = MINUS_ONE;\n                         }\n                     }\n                     // Computing 2nd power\n-                    d__1 = su.get(i__) - xopt.get(i__);\n-                    temp = ssq - d__1 * d__1;\n-                    if (temp > zero) {\n-                        temp = Math.sqrt(temp) + s.get(i__);\n+                    d1 = su.getEntry(i) - xopt.getEntry(i);\n+                    temp = ssq - d1 * d1;\n+                    if (temp > ZERO) {\n+                        temp = Math.sqrt(temp) + s.getEntry(i);\n                         if (angbd * temp > tempb) {\n                             angbd = tempb / temp;\n-                            iact = i__;\n-                            xsav = one;\n+                            iact = i;\n+                            xsav = ONE;\n                         }\n                     }\n                 }\n             state = 210; break;\n         }\n         case 150: {\n-            shs = zero;\n-            dhs = zero;\n-            dhd = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                if (xbdi.get(i__) == zero) {\n-                    shs += s.get(i__) * hs.get(i__);\n-                    dhs += d__.get(i__) * hs.get(i__);\n-                    dhd += d__.get(i__) * hred.get(i__);\n+            shs = ZERO;\n+            dhs = ZERO;\n+            dhd = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                if (xbdi.getEntry(i) == ZERO) {\n+                    shs += s.getEntry(i) * hs.getEntry(i);\n+                    dhs += d__.getEntry(i) * hs.getEntry(i);\n+                    dhd += d__.getEntry(i) * hred.getEntry(i);\n                 }\n             }\n \n             // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n             // the alternative iteration.\n \n-            redmax = zero;\n+            redmax = ZERO;\n             isav = 0;\n-            redsav = zero;\n+            redsav = ZERO;\n             iu = (int) (angbd * 17. + 3.1);\n-            i__1 = iu;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                angt = angbd * (double) i__ / (double) iu;\n-                sth = (angt + angt) / (one + angt * angt);\n+            for (int i = 1; i <= iu; i++) {\n+                angt = angbd * (double) i / (double) iu;\n+                sth = (angt + angt) / (ONE + angt * angt);\n                 temp = shs + angt * (angt * dhd - dhs - dhs);\n-                rednew = sth * (angt * dredg - sredg - half * sth * temp);\n+                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                 if (rednew > redmax) {\n                     redmax = rednew;\n-                    isav = i__;\n+                    isav = i;\n                     rdprev = redsav;\n-                } else if (i__ == isav + 1) {\n+                } else if (i == isav + 1) {\n                     rdnext = rednew;\n                 }\n                 redsav = rednew;\n             }\n             if (isav < iu) {\n                 temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n-                angt = angbd * ((double) isav + half * temp) / (double) iu;\n-            }\n-            cth = (one - angt * angt) / (one + angt * angt);\n-            sth = (angt + angt) / (one + angt * angt);\n+                angt = angbd * ((double) isav + HALF * temp) / (double) iu;\n+            }\n+            cth = (ONE - angt * angt) / (ONE + angt * angt);\n+            sth = (angt + angt) / (ONE + angt * angt);\n             temp = shs + angt * (angt * dhd - dhs - dhs);\n-            sdec = sth * (angt * dredg - sredg - half * sth * temp);\n-            if (sdec <= zero) {\n+            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n+            if (sdec <= ZERO) {\n                 state = 190; break;\n             }\n \n             // is restricted by a bound on a free variable, that variable is fixed\n             // at the bound.\n \n-            dredg = zero;\n-            gredsq = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                gnew.set(i__, gnew.get(i__) + (cth - one) * hred.get(i__) + sth * hs.get(i__));\n-                if (xbdi.get(i__) == zero) {\n-                    d__.set(i__, cth * d__.get(i__) + sth * s.get(i__));\n-                    dredg += d__.get(i__) * gnew.get(i__);\n+            dredg = ZERO;\n+            gredsq = ZERO;\n+            for (int i = 1; i <= n; i++) {\n+                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n+                if (xbdi.getEntry(i) == ZERO) {\n+                    d__.setEntry(i, cth * d__.getEntry(i) + sth * s.getEntry(i));\n+                    dredg += d__.getEntry(i) * gnew.getEntry(i);\n                     // Computing 2nd power\n-                    d__1 = gnew.get(i__);\n-                    gredsq += d__1 * d__1;\n-                }\n-                hred.set(i__, cth * hred.get(i__) + sth * hs.get(i__));\n+                    final double d1 = gnew.getEntry(i);\n+                    gredsq += d1 * d1;\n+                }\n+                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n             }\n             qred += sdec;\n             if (iact > 0 && isav == iu) {\n                 ++nact;\n-                xbdi.set(iact, xsav);\n+                xbdi.setEntry(iact, xsav);\n                 state = 100; break;\n             }\n \n             }\n         }\n         case 190: {\n-            dsq.value = zero;\n-            i__1 = n;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n+            dsq = ZERO;\n+            for (int i = 1; i <= n; i++) {\n                 // Computing MAX\n                 // Computing MIN\n-                d__3 = xopt.get(i__) + d__.get(i__);\n-                d__4 = su.get(i__);\n-                d__1 = Math.min(d__3,d__4);\n-                d__2 = sl.get(i__);\n-                xnew.set(i__, Math.max(d__1,d__2));\n-                if (xbdi.get(i__) == onemin) {\n-                    xnew.set(i__, sl.get(i__));\n-                }\n-                if (xbdi.get(i__) == one) {\n-                    xnew.set(i__, su.get(i__));\n-                }\n-                d__.set(i__, xnew.get(i__) - xopt.get(i__));\n+                final double min = Math.min(xopt.getEntry(i) + d__.getEntry(i),\n+                                            su.getEntry(i));\n+                xnew.setEntry(i, Math.max(min, sl.getEntry(i)));\n+                if (xbdi.getEntry(i) == MINUS_ONE) {\n+                    xnew.setEntry(i, sl.getEntry(i));\n+                }\n+                if (xbdi.getEntry(i) == ONE) {\n+                    xnew.setEntry(i, su.getEntry(i));\n+                }\n+                d__.setEntry(i, xnew.getEntry(i) - xopt.getEntry(i));\n                 // Computing 2nd power\n-                d__1 = d__.get(i__);\n-                dsq.value += d__1 * d__1;\n-            }\n-            return;\n+                final double d1 = d__.getEntry(i);\n+                dsq += d1 * d1;\n+            }\n+            return new double[] { dsq, crvmin };\n             // The following instructions multiply the current S-vector by the second\n             // derivative matrix of the quadratic model, putting the product in HS.\n             // They are reached from three different parts of the software above and\n         }\n         case 210: {\n             ih = 0;\n-            i__1 = n;\n-            for (j = 1; j <= i__1; j++) {\n-                hs.set(j, zero);\n-                i__2 = j;\n-                for (i__ = 1; i__ <= i__2; i__++) {\n+            for (int j = 1; j <= n; j++) {\n+                hs.setEntry(j, ZERO);\n+                for (int i = 1; i <= j; i++) {\n                     ++ih;\n-                    if (i__ < j) {\n-                        hs.set(j, hs.get(j) + hq.get(ih) * s.get(i__));\n-                    }\n-                    hs.set(i__, hs.get(i__) + hq.get(ih) * s.get(j));\n-                }\n-            }\n-            i__2 = npt;\n-            for (k = 1; k <= i__2; k++) {\n-                if (pq.get(k) != zero) {\n-                    temp = zero;\n-                    i__1 = n;\n-                    for (j = 1; j <= i__1; j++) {\n-                        temp += xpt.get(k + j * xpt_dim1) * s.get(j);\n-                    }\n-                    temp *= pq.get(k);\n-                    i__1 = n;\n-                    for (i__ = 1; i__ <= i__1; i__++) {\n-                        hs.set(i__, hs.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n-                    }\n-                }\n-            }\n-            if (crvmin.value != zero) {\n+                    if (i < j) {\n+                        hs.setEntry(j, hs.getEntry(j) + hq.getEntry(ih) * s.getEntry(i));\n+                    }\n+                    hs.setEntry(i, hs.getEntry(i) + hq.getEntry(ih) * s.getEntry(j));\n+                }\n+            }\n+            for (int k = 1; k <= npt; k++) {\n+                if (pq.getEntry(k) != ZERO) {\n+                    temp = ZERO;\n+                    for (int j = 1; j <= n; j++) {\n+                        temp += xpt.getEntry(k, j) * s.getEntry(j);\n+                    }\n+                    temp *= pq.getEntry(k);\n+                    for (int i = 1; i <= n; i++) {\n+                        hs.setEntry(i, hs.getEntry(i) + temp * xpt.getEntry(k, i));\n+                    }\n+                }\n+            }\n+            if (crvmin != ZERO) {\n                 state = 50; break;\n             }\n             if (iterc > itcsav) {\n                 state = 150; break;\n             }\n-            i__2 = n;\n-            for (i__ = 1; i__ <= i__2; i__++) {\n-                hred.set(i__, hs.get(i__));\n+            for (int i = 1; i <= n; i++) {\n+                hred.setEntry(i, hs.getEntry(i));\n             }\n             state = 120; break;\n         }}\n      *     with that name, and DENOM is set to the denominator of the updating\n      *     formula. Elements of ZMAT may be treated as zero if their moduli are\n      *     at most ZTEST. The first NDIM elements of W are used for working space.\n-     * @param n\n-     * @param npt\n      * @param bmat\n      * @param zmat\n-     * @param ndim\n      * @param vlag\n      * @param beta\n      * @param denom\n      * @param knew\n-     * @param w\n      */\n     private void update(\n-            int n,\n-            int npt,\n-            ScopedPtr bmat,\n-            ScopedPtr zmat,\n-            int ndim,\n-            ScopedPtr vlag,\n+            FortranMatrix bmat,\n+            FortranMatrix zmat,\n+            FortranArray vlag,\n             double beta,\n             double denom,\n-            int knew,\n-            ScopedPtr w\n+            int knew\n     ) {\n+        // System.out.println(\"update\"); // XXX\n+\n+        final int n = currentBest.getDimension();\n+        final int npt = numberOfInterpolationPoints;\n+        final int nptm = npt - n - 1;\n+\n+        // XXX Should probably be split into two arrays.\n+        final FortranArray work = new FortranArray(npt + n);\n+\n+\n         // System generated locals\n-        int bmat_dim1, zmat_dim1, i__1, i__2;\n         double d__1, d__2, d__3;\n \n         // Local variables\n-        int i__, j, k, jp;\n-        double one, tau, temp;\n-        int nptm;\n-        double zero, alpha, tempa, tempb, ztest;\n-\n-        zmat_dim1 = npt;\n-        bmat_dim1 = ndim;\n+        int jp;\n+        double tau, temp;\n+        double alpha, tempa, tempb, ztest;\n \n         // Function Body\n-        one = 1.;\n-        zero = 0.;\n-        nptm = npt - n - 1;\n-        ztest = zero;\n-        i__1 = npt;\n-        for (k = 1; k <= i__1; k++) {\n-            i__2 = nptm;\n-            for (j = 1; j <= i__2; j++) {\n+\n+        ztest = ZERO;\n+        for (int k = 1; k <= npt; k++) {\n+            for (int j = 1; j <= nptm; j++) {\n                 // Computing MAX\n-                d__2 = ztest;\n-                d__1 = zmat.get(k + j * zmat_dim1);\n-                d__3 = Math.abs(d__1);\n-                ztest = Math.max(d__2,d__3);\n+                ztest = Math.max(ztest, Math.abs(zmat.getEntry(k, j)));\n             }\n         }\n         ztest *= 1e-20;\n \n         // Apply the rotations that put zeros in the KNEW-th row of ZMAT.\n \n-        i__2 = nptm;\n-        for (j = 2; j <= i__2; j++) {\n-            d__1 = zmat.get(knew + j * zmat_dim1);\n+        for (int j = 2; j <= nptm; j++) {\n+            d__1 = zmat.getEntry(knew, j);\n             if (Math.abs(d__1) > ztest) {\n                 // Computing 2nd power\n-                d__1 = zmat.get(knew + zmat_dim1);\n+                d__1 = zmat.getEntry(knew, 1);\n                 // Computing 2nd power\n-                d__2 = zmat.get(knew + j * zmat_dim1);\n+                d__2 = zmat.getEntry(knew, j);\n                 temp = Math.sqrt(d__1 * d__1 + d__2 * d__2);\n-                tempa = zmat.get(knew + zmat_dim1) / temp;\n-                tempb = zmat.get(knew + j * zmat_dim1) / temp;\n-                i__1 = npt;\n-                for (i__ = 1; i__ <= i__1; i__++) {\n-                    temp = tempa * zmat.get(i__ + zmat_dim1) + tempb * zmat.get(i__ + j *\n-                            zmat_dim1);\n-                    zmat.set(i__ + j * zmat_dim1, tempa * zmat.get(i__ + j * zmat_dim1) -\n-                            tempb * zmat.get(i__ + zmat_dim1));\n-                    zmat.set(i__ + zmat_dim1, temp);\n-                }\n-            }\n-            zmat.set(knew + j * zmat_dim1, zero);\n+                tempa = zmat.getEntry(knew, 1) / temp;\n+                tempb = zmat.getEntry(knew, j) / temp;\n+                for (int i = 1; i <= npt; i++) {\n+                    temp = tempa * zmat.getEntry(i, 1) + tempb * zmat.getEntry(i, j);\n+                    zmat.setEntry(i, j, tempa * zmat.getEntry(i, j) -\n+                                  tempb * zmat.getEntry(i, 1));\n+                    zmat.setEntry(i, 1, temp);\n+                }\n+            }\n+            zmat.setEntry(knew, j, ZERO);\n         }\n \n         // Put the first NPT components of the KNEW-th column of HLAG into W,\n         // and calculate the parameters of the updating formula.\n \n-        i__2 = npt;\n-        for (i__ = 1; i__ <= i__2; i__++) {\n-            w.set(i__, zmat.get(knew + zmat_dim1) * zmat.get(i__ + zmat_dim1));\n-        }\n-        alpha = w.get(knew);\n-        tau = vlag.get(knew);\n-        vlag.set(knew, vlag.get(knew) - one);\n+        for (int i = 1; i <= npt; i++) {\n+            work.setEntry(i, zmat.getEntry(knew, 1) * zmat.getEntry(i, 1));\n+        }\n+        alpha = work.getEntry(knew);\n+        tau = vlag.getEntry(knew);\n+        vlag.setEntry(knew, vlag.getEntry(knew) - ONE);\n \n         // Complete the updating of ZMAT.\n \n         temp = Math.sqrt(denom);\n-        tempb = zmat.get(knew + zmat_dim1) / temp;\n+        tempb = zmat.getEntry(knew, 1) / temp;\n         tempa = tau / temp;\n-        i__2 = npt;\n-        for (i__ = 1; i__ <= i__2; i__++) {\n-            zmat.set(i__ + zmat_dim1, tempa * zmat.get(i__ + zmat_dim1) -\n-                    tempb * vlag.get(i__));\n+        for (int i= 1; i <= npt; i++) {\n+            zmat.setEntry(i, 1, tempa * zmat.getEntry(i, 1) -\n+                    tempb * vlag.getEntry(i));\n         }\n \n         // Finally, update the matrix BMAT.\n \n-        i__2 = n;\n-        for (j = 1; j <= i__2; j++) {\n+        for (int j = 1; j <= n; j++) {\n             jp = npt + j;\n-            w.set(jp, bmat.get(knew + j * bmat_dim1));\n-            tempa = (alpha * vlag.get(jp) - tau * w.get(jp)) / denom;\n-            tempb = (-beta * w.get(jp) - tau * vlag.get(jp)) / denom;\n-            i__1 = jp;\n-            for (i__ = 1; i__ <= i__1; i__++) {\n-                bmat.set(i__ + j * bmat_dim1, bmat.get(i__ + j * bmat_dim1) + tempa *\n-                        vlag.get(i__) + tempb * w.get(i__));\n-                if (i__ > npt) {\n-                    bmat.set(jp + (i__ - npt) * bmat_dim1, bmat.get(i__ + j * bmat_dim1));\n+            work.setEntry(jp, bmat.getEntry(knew, j));\n+            tempa = (alpha * vlag.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n+            tempb = (-beta * work.getEntry(jp) - tau * vlag.getEntry(jp)) / denom;\n+            for (int i = 1; i <= jp; i++) {\n+                bmat.setEntry(i, j, bmat.getEntry(i, j) + tempa *\n+                        vlag.getEntry(i) + tempb * work.getEntry(i));\n+                if (i > npt) {\n+                    bmat.setEntry(jp, (i - npt), bmat.getEntry(i, j));\n                 }\n             }\n         }\n     } // update\n \n     /**\n-     * Checks dimensions and values of boundaries and inputSigma if defined.\n+     * Performs validity checks and adapt the {@link #lowerBound} and\n+     * {@link #upperBound} array if no constraints were provided.\n      */\n-    private void checkParameters() {\n+    private void setup() {\n+        // System.out.println(\"setup\"); // XXX\n+\n         double[] init = getStartPoint();\n-        if (boundaries != null) {\n-            if (boundaries.length != 2) {\n-                throw new MultiDimensionMismatchException(\n-                        new Integer[] { boundaries.length },\n-                        new Integer[] { 2 });\n-            }\n-            if (boundaries[0] == null || boundaries[1] == null) {\n-                throw new NoDataException();\n-            }\n-            if (boundaries[0].length != init.length) {\n-                throw new MultiDimensionMismatchException(\n-                        new Integer[] { boundaries[0].length },\n-                        new Integer[] { init.length });\n-            }\n-            if (boundaries[1].length != init.length) {\n-                throw new MultiDimensionMismatchException(\n-                        new Integer[] { boundaries[1].length },\n-                        new Integer[] { init.length });\n-            }\n-            for (int i = 0; i < init.length; i++) {\n-                if (boundaries[0][i] > init[i] || boundaries[1][i] < init[i]) {\n-                    throw new OutOfRangeException(init[i], boundaries[0][i],\n-                            boundaries[1][i]);\n-                }\n-            }\n+        final int dimension = init.length;\n+\n+        // Check problem dimension.\n+        if (dimension < MINIMUM_PROBLEM_DIMENSION) {\n+            throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);\n+        }\n+        // Check number of interpolation points.\n+        final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\n+        if (numberOfInterpolationPoints < nPointsInterval[0] ||\n+            numberOfInterpolationPoints > nPointsInterval[1]) {\n+            throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n+                                          numberOfInterpolationPoints,\n+                                          nPointsInterval[0],\n+                                          nPointsInterval[1]);\n+        }\n+\n+        // Check (and possibly adapt) bounds.\n+        if (lowerBound == null) {\n+            lowerBound = fillNewArray(dimension, Double.NEGATIVE_INFINITY);\n+        } else if (lowerBound.length != init.length) {\n+            throw new DimensionMismatchException(lowerBound.length, dimension);\n+        }\n+\n+        if (upperBound == null) {\n+            upperBound = fillNewArray(dimension, Double.POSITIVE_INFINITY);\n+        } else if (upperBound.length != init.length) {\n+            throw new DimensionMismatchException(upperBound.length, dimension);\n+        }\n+\n+        for (int i = 0; i < dimension; i++) {\n+            final double v = init[i];\n+            final double lo = lowerBound[i];\n+            final double hi = upperBound[i];\n+            if (v < lo || v > hi) {\n+                throw new OutOfRangeException(v, lo, hi);\n+            }\n+        }\n+\n+        // Initialize bound differences.\n+        boundDifference = new double[dimension];\n+\n+        double requiredMinDiff = 2 * initialTrustRegionRadius;\n+        double minDiff = Double.POSITIVE_INFINITY;\n+        for (int i = 0; i < dimension; i++) {\n+            boundDifference[i] = upperBound[i] - lowerBound[i];\n+            minDiff = Math.min(minDiff, boundDifference[i]);\n+        }\n+        if (minDiff < requiredMinDiff) {\n+            initialTrustRegionRadius = minDiff / 3.0;\n         }\n     }\n \n+\n     // auxiliary subclasses\n \n     /**\n-     * Double reference\n+     * 1-based indexing vector\n      */\n-    private static class DoubleRef {\n-        /**\n-         * stored double value.\n-         */\n-        private double value;\n-\n-        /**\n-         * @param value stored double value.\n-         */\n-        DoubleRef(double value) {\n-            this.value = value;\n+    private static class FortranArray extends ArrayRealVector {\n+        public FortranArray(int size) {\n+            super(size);\n+        }\n+        public FortranArray(ArrayRealVector data) {\n+            super(data, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getEntry(int index) {\n+            return super.getEntry(index - 1);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setEntry(int index, double value) {\n+            super.setEntry(index - 1, value);\n         }\n     }\n \n     /**\n-     * Integer reference\n+     * 1-based indexing matrix\n      */\n-    private static class IntRef {\n-        /**\n-         * stored int value.\n-         */\n-        private int value;\n-\n-        /**\n-         * @param value stored int value.\n-         */\n-        IntRef(int value) {\n-            this.value = value;\n+    private static class FortranMatrix extends Array2DRowRealMatrix {\n+        public FortranMatrix(int row, int column) {\n+            super(row, column);\n+        }\n+        /** {@inheritDoc} */\n+        public double getEntry(int row, int col) {\n+            return super.getEntry(row - 1, col - 1);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setEntry(int row, int col, double value) {\n+            super.setEntry(row - 1, col - 1, value);\n         }\n     }\n \n     /**\n-     * Used to simulate Fortran pointers.\n+     * Creates a new array.\n+     *\n+     * @param n Dimension of the returned array.\n+     * @param value Value for each element.\n+     * @return an array containing {@code n} elements set to the given\n+     * {@code value}.\n      */\n-    private static class ScopedPtr {\n-        /**\n-         * array storing elements.\n-         */\n-        private double[] w;\n-        /**\n-         * base index for access.\n-         */\n-        private int base;\n-\n-        /**\n-         * @param w array storing elements.\n-         * @param base base index for access.\n-         */\n-        ScopedPtr(double[] w, int base) {\n-            this.w = w;\n-            this.base = base;\n-        }\n-\n-        /**\n-         * @param index realtive index of returned ScopedPtr\n-         * @return ScopedPtr with new base = this.base + index\n-         */\n-        ScopedPtr ptr(int index) {\n-            return new ScopedPtr(w, base + index);\n-        }\n-\n-        /**\n-         * @param index of accessed element relative to base.\n-         * @return value returned value at index.\n-         */\n-        double get(int index) {\n-            return w[base + index];\n-        }\n-\n-        /**\n-         * @param index of accessed elements relative to base.\n-         * @param n number of values to be returned.\n-         * @return n values starting at index.\n-         */\n-        double[] getAll(int index, int n) {\n-            return Arrays.copyOfRange(w, base+index, base+index+n);\n-        }\n-\n-        /**\n-         * @return all elements.\n-         */\n-        double[] getAll() {\n-            return w;\n-        }\n-\n-        /**\n-         * @param index index of accessed element relative to base.\n-         * @param value stored at index.\n-         */\n-        void set(int index, double value) {\n-            w[base + index] = value;\n-        }\n-\n-        /* (non-Javadoc)\n-         * @see java.lang.Object#toString()\n-         */\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            for (int i = 0; i < 20; i++)\n-                if (base + i >= 0 && base + i < w.length)\n-                    sb.append(\"\" + i + \":\" + w[base + i] + \"\\n\");\n-            return sb.toString();\n-        }\n-\n-    }\n-\n-    /**\n-     * @param n dimension.\n-     * @param value value set for each element.\n-     * @return array containing n values.\n-     */\n-    private static double[] point(int n, double value) {\n+    private static double[] fillNewArray(int n,\n+                                         double value) {\n         double[] ds = new double[n];\n         Arrays.fill(ds, value);\n         return ds;\n     }\n \n+    // Fortan (1-based) to Java (0-based) array index.\n+    // For use in Fortran-like 1-based loops.  Calls to this offset\n+    // function will be removed when all loops are converted to 0-base.\n+    private static int f2jai(int j) {\n+        return j - 1;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n  */\n package org.apache.commons.math.optimization.direct;\n \n-import static org.junit.Assert.fail;\n-\n import java.util.Arrays;\n import java.util.Random;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MultiDimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n import org.apache.commons.math.optimization.RealPointValuePair;\n public class BOBYQAOptimizerTest {\n \n     static final int DIM = 13;\n- \n-    @Test(expected = OutOfRangeException.class)\n-    public void testInitOutofbounds() {\n-        double[] startPoint = point(DIM,3);\n-        double[][] boundaries = boundaries(DIM,-1,2);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+   \n+    @Test(expected=OutOfRangeException.class)\n+    public void testInitOutOfBounds() {\n+        double[] startPoint = point(DIM, 3);\n+        double[][] boundaries = boundaries(DIM, -1, 2);\n         doTest(new Rosen(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n-                1e-13, 1e-6, 2000, expected);\n+                1e-13, 1e-6, 2000, null);\n     }\n     \n-    @Test(expected = MultiDimensionMismatchException.class)\n+    @Test(expected=DimensionMismatchException.class)\n     public void testBoundariesDimensionMismatch() {\n-        double[] startPoint = point(DIM,0.5);\n-        double[][] boundaries = boundaries(DIM+1,-1,2);\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        double[] startPoint = point(DIM, 0.5);\n+        double[][] boundaries = boundaries(DIM + 1, -1, 2);\n         doTest(new Rosen(), startPoint, boundaries,\n-                GoalType.MINIMIZE, \n-                1e-13, 1e-6, 2000, expected);\n-    }\n-\n-    @Test(expected = NoDataException.class)\n-    public void testBoundariesNoData() {\n-        double[] startPoint = point(DIM,0.5);\n-        double[][] boundaries = boundaries(DIM,-1,2);\n-        boundaries[1] = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+               GoalType.MINIMIZE, \n+               1e-13, 1e-6, 2000, null);\n+    }\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testProblemDimensionTooSmall() {\n+        double[] startPoint = point(1, 0.5);\n+        double[][] boundaries = null;\n+        doTest(new Rosen(), startPoint, null,\n+               GoalType.MINIMIZE,\n+               1e-13, 1e-6, 2000, null);\n+    }\n+\n+    @Test(expected=TooManyEvaluationsException.class)\n+    public void testMaxEvaluations() {\n+        final int lowMaxEval = 2;\n+        double[] startPoint = point(DIM, 0.1);\n+        double[][] boundaries = null;\n         doTest(new Rosen(), startPoint, boundaries,\n-                GoalType.MINIMIZE, \n-                1e-13, 1e-6, 2000, expected);\n-    }\n-    \n+               GoalType.MINIMIZE, \n+               1e-13, 1e-6, lowMaxEval, null);\n+     }\n+\n+    @Test(expected=TooManyEvaluationsException.class)\n+    public void testRescue() {\n+        double[] startPoint = point(DIM, 1);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =  new RealPointValuePair(point(DIM, 0), 0);\n+        doTest(new MinusElli(), startPoint, boundaries,\n+               GoalType.MINIMIZE, \n+               1e-13, 1e-6, 1000, expected);\n+    }\n+\n     @Test\n     public void testRosen() {\n         double[] startPoint = point(DIM,0.1);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,1.0),0.0);\n+        RealPointValuePair expected = new RealPointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, boundaries,\n                 GoalType.MINIMIZE, \n                 1e-13, 1e-6, 2000, expected);\n      }\n-    \n-    @Test\n-    public void testRescue() {\n-        double[] startPoint = point(13,1.0);\n-        double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(13,0.0),0);\n-        try {\n-            doTest(new MinusElli(), startPoint, boundaries,\n-                GoalType.MINIMIZE, \n-                1e-13, 1e-6, 1000, expected);\n-            fail(\"An TooManyEvaluationsException should have been thrown\");\n-        } catch(TooManyEvaluationsException e) {\n-        }\n-    }\n \n     @Test\n     public void testMaximize() {\n         double[] startPoint = point(DIM,1.0);\n         double[][] boundaries = null;\n-        RealPointValuePair expected =\n-            new RealPointValuePair(point(DIM,0.0),1.0);\n+        RealPointValuePair expected = new RealPointValuePair(point(DIM,0.0),1.0);\n         doTest(new MinusElli(), startPoint, boundaries,\n                 GoalType.MAXIMIZE, \n                 2e-10, 5e-6, 1000, expected);\n             double pointTol,\n             int maxEvaluations,\n             RealPointValuePair expected) {\n+\n+        System.out.println(func.getClass().getName() + \" BEGIN\"); // XXX\n+\n         int dim = startPoint.length;\n //        MultivariateRealOptimizer optim =\n //            new PowellOptimizer(1e-13, Math.ulp(1d));\n //        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);\n+        final double[] lB = boundaries == null ? null : boundaries[0];\n+        final double[] uB = boundaries == null ? null : boundaries[1];\n         MultivariateRealOptimizer optim =\n-            new BOBYQAOptimizer(boundaries);\n+            new BOBYQAOptimizer(2 * dim + 1, lB, uB);\n         RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);        \n //        System.out.println(func.getClass().getName() + \" = \" \n //        \t\t+ optim.getEvaluations() + \" f(\");\n             Assert.assertEquals(expected.getPoint()[i],\n                     result.getPoint()[i], pointTol);\n         }\n+\n+        System.out.println(func.getClass().getName() + \" END\"); // XXX\n     }\n \n     private static double[] point(int n, double value) {\n     }\n \n     private static class MinusElli implements MultivariateRealFunction {\n-        private int fcount = 0;\n-        public double value(double[] x) {\n-          double f = 1.0-(new Elli().value(x));\n-//          System.out.print(\"\" + (fcount++) + \") \");\n-//          for (int i = 0; i < x.length; i++)\n-//              System.out.print(x[i] +  \" \");\n-//          System.out.println(\" = \" + f);\n-          return f;\n-       }\n+        private final Elli elli = new Elli();\n+        public double value(double[] x) {\n+            return 1.0 - elli.value(x);\n+        }\n     }\n \n     private static class DiffPow implements MultivariateRealFunction {", "timestamp": 1312650398, "metainfo": ""}