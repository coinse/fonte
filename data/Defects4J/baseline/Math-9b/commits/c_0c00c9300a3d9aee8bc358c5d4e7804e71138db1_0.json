{"sha": "0c00c9300a3d9aee8bc358c5d4e7804e71138db1", "log": "avoid division by zero when dealing with single-point intervals sets  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java\n import org.apache.commons.math3.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math3.geometry.partitioning.BSPTree;\n import org.apache.commons.math3.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math3.util.Precision;\n \n /** This class represents a 1D region: a set of intervals.\n  * @version $Id$\n         if (Double.isInfinite(upper) && (upper > 0)) {\n             // the tree must be open on the positive infinity side\n             return new BSPTree<Euclidean1D>(lowerCut,\n-                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n-                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n-                               null);\n+                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n+                                            null);\n         }\n \n         // the tree must be bounded on the two sides\n         final SubHyperplane<Euclidean1D> upperCut =\n             new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n         return new BSPTree<Euclidean1D>(lowerCut,\n-                           new BSPTree<Euclidean1D>(Boolean.FALSE),\n-                           new BSPTree<Euclidean1D>(upperCut,\n-                                       new BSPTree<Euclidean1D>(Boolean.FALSE),\n-                                       new BSPTree<Euclidean1D>(Boolean.TRUE),\n-                                       null),\n-                                       null);\n+                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                                        new BSPTree<Euclidean1D>(upperCut,\n+                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n+                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n+                                                                 null),\n+                                        null);\n \n     }\n \n                 sum  += interval.getLength() * interval.getMidPoint();\n             }\n             setSize(size);\n-            setBarycenter(Double.isInfinite(size) ? Vector1D.NaN : new Vector1D(sum / size));\n+            if (Double.isInfinite(size)) {\n+                setBarycenter(Vector1D.NaN);\n+            } else if (size >= Precision.SAFE_MIN) {\n+                setBarycenter(new Vector1D(sum / size));\n+            } else {\n+                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n+            }\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSetTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSetTest.java\n import org.apache.commons.math3.geometry.partitioning.Region;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n \n \n     }\n \n+    @Test\n+    public void testSinglePoint() {\n+        IntervalsSet set = new IntervalsSet(1.0, 1.0);\n+        Assert.assertEquals(0.0, set.getSize(), Precision.SAFE_MIN);\n+        Assert.assertEquals(1.0, ((Vector1D) set.getBarycenter()).getX(), Precision.EPSILON);\n+    }\n+\n }", "timestamp": 1335124904, "metainfo": ""}