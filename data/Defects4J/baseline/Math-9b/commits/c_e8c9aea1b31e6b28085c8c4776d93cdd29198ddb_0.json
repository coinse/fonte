{"sha": "e8c9aea1b31e6b28085c8c4776d93cdd29198ddb", "log": "added column walking order renamed walkInInternalOrder into walkInOptimizedOrder  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n  */\n public abstract class AbstractRealMatrix implements RealMatrix, Serializable {\n     \n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -3665653040524315561L;\n \n     /** Cached LU solver.\n \n     /** {@inheritDoc} */\n     public double getNorm() {\n-        final int rowCount    = getRowDimension();\n-        final int columnCount = getColumnDimension();\n-        double maxColSum = 0;\n-        for (int col = 0; col < columnCount; ++col) {\n-            double sum = 0;\n-            for (int row = 0; row < rowCount; ++row) {\n-                sum += Math.abs(getEntry(row, col));\n-            }\n-            maxColSum = Math.max(maxColSum, sum);\n-        }\n-        return maxColSum;\n+        return walkInColumnOrder(new RealMatrixPreservingVisitor() {\n+\n+            /** Serializable version identifier */\n+            private static final long serialVersionUID = -2452270856202894168L;\n+\n+            /** Last row index. */\n+            private double endRow;\n+\n+            /** Sum of absolute values on one column. */\n+            private double columnSum;\n+\n+            /** Maximal sum across all columns. */\n+            private double maxColSum;\n+\n+            /** {@inheritDoc} */\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                this.endRow = endRow;\n+                columnSum   = 0;\n+                maxColSum   = 0;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void visit(final int row, final int column, final double value) {\n+                columnSum += Math.abs(value);\n+                if (row == endRow) {\n+                    maxColSum = Math.max(maxColSum, columnSum);\n+                    columnSum = 0;\n+                }\n+            }\n+\n+            /** {@inheritDoc} */\n+            public double end() {\n+                return maxColSum;\n+            }\n+\n+        });\n     }\n     \n     /** {@inheritDoc} */\n     public double getFrobeniusNorm() {\n-        final int rowCount    = getRowDimension();\n-        final int columnCount = getColumnDimension();\n-        double sum2 = 0;\n-        for (int col = 0; col < columnCount; ++col) {\n-            for (int row = 0; row < rowCount; ++row) {\n-                final double mij = getEntry(row, col);\n-                sum2 += mij * mij;\n-            }\n-        }\n-        return Math.sqrt(sum2);\n+        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n+\n+            /** Serializable version identifier */\n+            private static final long serialVersionUID = -6065411033772300640L;\n+\n+            /** Sum of squared entries. */\n+            private double sum;\n+\n+            /** {@inheritDoc} */\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                sum = 0;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void visit(final int row, final int column, final double value) {\n+                sum += value * value;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public double end() {\n+                return Math.sqrt(sum);\n+            }\n+\n+        });\n     }\n     \n     /** {@inheritDoc} */\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final RealMatrix out = createMatrix(nCols, nRows);\n-        for (int row = 0; row < nRows; ++row) {\n-            for (int col = 0; col < nCols; ++col) {\n-                out.setEntry(col, row, getEntry(row, col));\n-            }\n-        }\n+        walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n+\n+            /** Serializable version identifier */\n+            private static final long serialVersionUID = 3807296710038754174L;\n+\n+            /** {@inheritDoc} */\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void visit(final int row, final int column, final double value) {\n+                out.setEntry(column, row, value);\n+            }\n+\n+            /** {@inheritDoc} */\n+            public double end() {\n+                return 0;\n+            }\n+\n+        });\n \n         return out;\n \n     }\n \n     /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n         final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int row = 0; row < rows; ++row) {\n             for (int column = 0; column < columns; ++column) {\n                 final double oldValue = getEntry(row, column);\n             }\n         }\n         lu = null;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n         final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int row = 0; row < rows; ++row) {\n             for (int column = 0; column < columns; ++column) {\n                 visitor.visit(row, column, getEntry(row, column));\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixChangingVisitor visitor,\n-                               final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n         for (int row = startRow; row <= endRow; ++row) {\n             for (int column = startColumn; column <= endColumn; ++column) {\n                 final double oldValue = getEntry(row, column);\n             }\n         }\n         lu = null;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n-                               final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n         for (int row = startRow; row <= endRow; ++row) {\n             for (int column = startColumn; column <= endColumn; ++column) {\n                 visitor.visit(row, column, getEntry(row, column));\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor)\n+        return visitor.end();\n+    }\n+\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n-        walkInRowOrder(visitor);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor)\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n-        walkInRowOrder(visitor);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor,\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n-        walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor,\n+    throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n     }\n \n     /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n                 }\n              }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n                 }\n              }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixChangingVisitor visitor,\n-                               final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n             final int pStart = Math.max(startRow, p0);\n                 }\n              }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n-                               final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n             final int pStart = Math.max(startRow, p0);\n                 }\n              }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n                 }\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n                 }\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixChangingVisitor visitor,\n-                                    final int startRow, final int endRow,\n-                                    final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n             final int pStart = Math.max(startRow, p0);\n                 }\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInInternalOrder(final RealMatrixPreservingVisitor visitor,\n-                                    final int startRow, final int endRow,\n-                                    final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n             final int pStart = Math.max(startRow, p0);\n                 }\n             }\n         }\n+        return visitor.end();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n \n     /**\n      * Visit (and possibly change) all matrix entries in row order.\n-     * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInRowOrder(RealMatrixChangingVisitor visitor) throws MatrixVisitorException;\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException;\n \n     /**\n      * Visit (but don't change) all matrix entries in row order.\n-     * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInRowOrder(RealMatrixPreservingVisitor visitor) throws MatrixVisitorException;\n-\n-    /**\n-     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n      * @param visitor visitor used to process all matrix entries\n      * @param startRow Initial row index\n      * @param endRow Final row index (inclusive)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInRowOrder(RealMatrixChangingVisitor visitor,\n-                        int startRow, int endRow, int startColumn, int endColumn)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixChangingVisitor visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n         throws MatrixIndexException, MatrixVisitorException;\n \n     /**\n-     * Visit (but don't change) all matrix entries in row order.\n+     * Visit (but don't change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n      * @param visitor visitor used to process all matrix entries\n      * @param startRow Initial row index\n      * @param endRow Final row index (inclusive)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInRowOrder(RealMatrixPreservingVisitor visitor,\n-                        int startRow, int endRow, int startColumn, int endColumn)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixPreservingVisitor visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n         throws MatrixIndexException, MatrixVisitorException;\n \n     /**\n-     * Visit (and possibly change) all matrix entries in row order.\n-     * <p>The matrix internal order depends on the exact matrix class. It may be\n-     * different from traditional row order, but is generally faster. If there is no need\n-     * for an explicit walk order, this method should be preferred to the {@link\n-     * #walkInRowOrder(RealMatrixChangingVisitor)} one.</p>\n-     * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInInternalOrder(RealMatrixChangingVisitor visitor) throws MatrixVisitorException;\n-\n-    /**\n-     * Visit (but don't change) all matrix entries in row order.\n-     * <p>The matrix internal order depends on the exact matrix class. It may be\n-     * different from traditional row order, but is generally faster. If there is no need\n-     * for an explicit walk order, this method should be preferred to the {@link\n-     * #walkInRowOrder(RealMatrixPreservingVisitor)} one.</p>\n-     * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInInternalOrder(RealMatrixPreservingVisitor visitor) throws MatrixVisitorException;\n-\n-    /**\n-     * Visit (and possibly change) all matrix entries in row order.\n-     * <p>The matrix internal order depends on the exact matrix class. It may be\n-     * different from traditional row order, but is generally faster. If there is no need\n-     * for an explicit walk order, this method should be preferred to the {@link\n-     * #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)} one.</p>\n+     * Visit (and possibly change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixChangingVisitor visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixPreservingVisitor visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n      * @param visitor visitor used to process all matrix entries\n      * @param startRow Initial row index\n      * @param endRow Final row index (inclusive)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     */\n-    void walkInInternalOrder(RealMatrixChangingVisitor visitor,\n-                             int startRow, int endRow, int startColumn, int endColumn)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixChangingVisitor visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n         throws MatrixIndexException, MatrixVisitorException;\n \n     /**\n-     * Visit (but don't change) all matrix entries in row order.\n-     * Visit (and possibly change) all matrix entries in row order.\n-     * <p>The matrix internal order depends on the exact matrix class. It may be\n-     * different from traditional row order, but is generally faster. If there is no need\n-     * for an explicit walk order, this method should be preferred to the {@link\n-     * #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)} one.</p>\n+     * Visit (but don't change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n      * @param visitor visitor used to process all matrix entries\n      * @param startRow Initial row index\n      * @param endRow Final row index (inclusive)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixPreservingVisitor)\n-     * @see #walkInInternalOrder(RealMatrixChangingVisitor, int, int, int, int)\n-     */\n-    void walkInInternalOrder(RealMatrixPreservingVisitor visitor,\n-                             int startRow, int endRow, int startColumn, int endColumn)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n         throws MatrixIndexException, MatrixVisitorException;\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n public interface RealMatrixChangingVisitor extends Serializable {\n \n     /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n      * Visit one matrix entry.\n      * @param row row index of the entry\n      * @param column column index of the entry\n     double visit(int row, int column, double value)\n         throws MatrixVisitorException;\n \n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    double end();\n+\n }\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     }\n \n     /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n         final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int i = 0; i < rows; ++i) {\n             final double[] rowI = data[i];\n             for (int j = 0; j < columns; ++j) {\n                 rowI[j] = visitor.visit(i, j, rowI[j]);\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         final int rows    = getRowDimension();\n         final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int i = 0; i < rows; ++i) {\n             final double[] rowI = data[i];\n             for (int j = 0; j < columns; ++j) {\n                 visitor.visit(i, j, rowI[j]);\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixChangingVisitor visitor,\n-                               final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n         for (int i = startRow; i <= endRow; ++i) {\n             final double[] rowI = data[i];\n             for (int j = startColumn; j <= endColumn; ++j) {\n                 rowI[j] = visitor.visit(i, j, rowI[j]);\n             }\n         }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n-                               final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn)\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n         for (int i = startRow; i <= endRow; ++i) {\n             final double[] rowI = data[i];\n             for (int j = startColumn; j <= endColumn; ++j) {\n                 visitor.visit(i, j, rowI[j]);\n             }\n         }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n public interface RealMatrixPreservingVisitor extends Serializable {\n \n     /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n      * Visit one matrix entry.\n      * @param row row index of the entry\n      * @param column column index of the entry\n     void visit(int row, int column, double value)\n         throws MatrixVisitorException;\n \n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    double end();\n+\n }\n--- a/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n     /** test transpose */\n     public void testTranspose() {\n         RealMatrix m = new DenseRealMatrix(testData); \n-        RealMatrix mIT = new LUSolver(new LUDecompositionImpl(m)).getInverse().transpose();\n-        RealMatrix mTI = new LUSolver(new LUDecompositionImpl(m.transpose())).getInverse();\n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n         assertClose(mIT, mTI, normTolerance);\n         m = new DenseRealMatrix(testData2);\n         RealMatrix mt = new DenseRealMatrix(testData2T);\n         RealMatrix m = new DenseRealMatrix(rows, columns);\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n-        m.walkInInternalOrder(getVisitor);\n+        m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new DenseRealMatrix(rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n-        m.walkInInternalOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n             assertEquals(0.0, m.getEntry(i, 0), 0);                    \n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n-\n         m = new DenseRealMatrix(rows, columns);\n-        m.walkInInternalOrder(new SetVisitor());\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new DenseRealMatrix(rows, columns);\n-        m.walkInInternalOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n     }\n     \n     private static class SetVisitor implements RealMatrixChangingVisitor {\n         private static final long serialVersionUID = -5724808764099124932L;\n+        public void start(int rows, int columns, int startRow, int endRow,\n+                int startColumn, int endColumn) {\n+        }\n         public double visit(int i, int j, double value) {\n             return i + j / 1024.0;\n+        }\n+        public double end() {\n+            return 0;\n         }\n     }\n \n     private static class GetVisitor implements RealMatrixPreservingVisitor {\n         private static final long serialVersionUID = 1299771253908695242L;\n         int count = 0;\n+        public void start(int rows, int columns, int startRow, int endRow,\n+                int startColumn, int endColumn) {\n+        }\n         public void visit(int i, int j, double value) {\n             ++count;\n             assertEquals(i + j / 1024.0, value, 0.0);\n         }\n         public int getCount() {\n             return count;\n+        }\n+        public double end() {\n+            return 0;\n         }\n     };\n \n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         RealMatrix m = new RealMatrixImpl(rows, columns);\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n-        m.walkInInternalOrder(getVisitor);\n+        m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new RealMatrixImpl(rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n-        m.walkInInternalOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n             assertEquals(0.0, m.getEntry(i, 0), 0);                    \n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n-\n         m = new RealMatrixImpl(rows, columns);\n-        m.walkInInternalOrder(new SetVisitor());\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n         m = new RealMatrixImpl(rows, columns);\n-        m.walkInInternalOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new RealMatrixImpl(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n     }\n     \n     private static class SetVisitor implements RealMatrixChangingVisitor {\n         private static final long serialVersionUID = -5724808764099124932L;\n+        public void start(int rows, int columns, int startRow, int endRow,\n+                int startColumn, int endColumn) {\n+        }\n         public double visit(int i, int j, double value) {\n             return i + j / 1024.0;\n+        }\n+        public double end() {\n+            return 0;\n         }\n     }\n \n     private static class GetVisitor implements RealMatrixPreservingVisitor {\n         private static final long serialVersionUID = 1299771253908695242L;\n         int count = 0;\n+        public void start(int rows, int columns, int startRow, int endRow,\n+                int startColumn, int endColumn) {\n+        }\n         public void visit(int i, int j, double value) {\n             ++count;\n             assertEquals(i + j / 1024.0, value, 0.0);\n         }\n         public int getCount() {\n             return count;\n+        }\n+        public double end() {\n+            return 0;\n         }\n     };\n ", "timestamp": 1230916062, "metainfo": ""}