{"sha": "59bd46bae7e8e8dc2be5cc319564b31ae20d5d81", "log": "MATH-664 Replaced \"LUDecomposition\" by \"QRDecomposition\" in the covariance matrix computation.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n             // R is supposed to be m x n\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            double[][] ra = new double[m][n];         \n+            double[][] ra = new double[m][n];\n             // copy the diagonal from rDiag and the upper triangle of qr\n             for (int row = FastMath.min(m, n) - 1; row >= 0; row--) {\n                 ra[row][row] = rDiag[row];\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.linear.LUDecomposition;\n+import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n      * @return the covariance matrix.\n      * @throws org.apache.commons.math.linear.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n+     *\n+     * @see #getCovriances(double)\n      */\n     public double[][] getCovariances() {\n         return getCovariances(DEFAULT_SINGULARITY_THRESHOLD);\n \n     /**\n      * Get the covariance matrix of the optimized parameters.\n+     * <br/>\n+     * Note that this operation involves the inversion of the\n+     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n+     * Jacobian matrix.\n+     * The {@code threshold} parameter is a way for the caller to specify\n+     * that the result of this computation should be considered meaningless,\n+     * and thus trigger an exception.\n      *\n      * @param threshold Singularity threshold.\n      * @return the covariance matrix.\n \n         // Compute the covariances matrix.\n         final DecompositionSolver solver\n-            = new LUDecomposition(MatrixUtils.createRealMatrix(jTj), threshold).getSolver();\n+            = new QRDecomposition(MatrixUtils.createRealMatrix(jTj), threshold).getSolver();\n         return solver.getInverse().getData();\n     }\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n                              new double[] { 0, 0, 0 });\n         Assert.assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n \n-        optimizer.getCovariances();\n+        // The default singularity threshold (1e-14) does not trigger the\n+        // expected exception.\n+        double[][] cov = optimizer.getCovariances(1.5e-14);\n     }\n \n     @Test", "timestamp": 1326887808, "metainfo": ""}