{"sha": "79c28fac1984f6fb380359082e1c6180f3cdaecf", "log": "added multidimensional interpolation using the microsphere algorithm. JIRA: MATH-300  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.random.UncorrelatedRandomVectorGenerator\n     // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression\n     // org.apache.commons.math.stat.inference.ChiSquareTestImpl\n+    // org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatingFunction\n     { \"dimension mismatch {0} != {1}\",\n       \"dimensions incompatibles {0} != {1}\" },\n \n-    // org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException\n+    // org.apache.commons.math.analysis.interpolation.MicrosphereInterpolatingFunction\n+    { \"no data\",\n+      \"aucune donn\\u00e9e\" },\n+\n+    // org.apache.commons.math.analysis.interpolation.MicrosphereInterpolator\n+    { \"brightness exponent should be positive or null, but got {0}\",\n+      \"l''exposant de brillance devrait \\u00eatre positif ou null, or e = {0}\" },\n+    { \"number of microsphere elements must be positive, but got {0}\",\n+      \"le nombre d''\\u00e9l\\u00e9ments de la microsph\\u00e8re devrait \\u00eatre positif, or n = {0}\" },\n+\n+   // org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException\n     { \"not positive definite matrix\",\n       \"matrice non d\\u00e9finie positive\" },\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.HashMap;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n+\n+/**\n+ * Interpolating function that implements the\n+ * <a href=\"http://www.dudziak.com/microsphere.php\">Microsphere Projection</a>.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class MicrosphereInterpolatingFunction\n+    implements MultivariateRealFunction {\n+    /**\n+     * Space dimension.\n+     */\n+    private final int dimension;\n+    /**\n+     * Internal accounting data for the interpolation algorithm.\n+     * Each element of the list corresponds to one surface element of\n+     * the microsphere.\n+     */\n+    private final List<MicrosphereSurfaceElement> microsphere;\n+    /**\n+     * Exponent used in the power law that computes the weights of the\n+     * sample data.\n+     */\n+    private final double brightnessExponent;\n+    /**\n+     * Sample data.\n+     */\n+    private final Map<RealVector, Double> samples;\n+\n+    /**\n+     * Class for storing the accounting data needed to perform the\n+     * microsphere projection.\n+     */\n+    private static class MicrosphereSurfaceElement {\n+\n+        /** Normal vector characterizing a surface element. */\n+        private final RealVector normal;\n+\n+        /** Illumination received from the brightest sample. */\n+        private double brightestIllumination;\n+\n+        /** Brightest sample. */\n+        private Map.Entry<RealVector, Double> brightestSample;\n+\n+        /**\n+         * @param n Normal vector characterizing a surface element\n+         * of the microsphere.\n+         */\n+        MicrosphereSurfaceElement(double[] n) {\n+            normal = new ArrayRealVector(n);\n+        }\n+\n+        /**\n+         * Return the normal vector.\n+         * @return the normal vector\n+         */\n+        RealVector normal() {\n+            return normal;\n+        }\n+\n+        /**\n+         * Reset \"illumination\" and \"sampleIndex\".\n+         */\n+        void reset() {\n+            brightestIllumination = 0;\n+            brightestSample = null;\n+        }\n+\n+        /**\n+         * Store the illumination and index of the brightest sample.\n+         * @param illuminationFromSample illumination received from sample\n+         * @param sample current sample illuminating the element\n+         */\n+        void store(final double illuminationFromSample,\n+                   final Map.Entry<RealVector, Double> sample) {\n+            if (illuminationFromSample > this.brightestIllumination) {\n+                this.brightestIllumination = illuminationFromSample;\n+                this.brightestSample = sample;\n+            }\n+        }\n+\n+        /**\n+         * Get the illumination of the element.\n+         * @return the illumination.\n+         */\n+        double illumination() {\n+            return brightestIllumination;\n+        }\n+\n+        /**\n+         * Get the sample illuminating the element the most.\n+         * @return the sample.\n+         */\n+        Map.Entry<RealVector, Double> sample() {\n+            return brightestSample;\n+        }\n+    }\n+\n+    /**\n+     * @param xval the arguments for the interpolation points.\n+     * {@code xval[i][0]} is the first component of interpolation point\n+     * {@code i}, {@code xval[i][1]} is the second component, and so on\n+     * until {@code xval[i][d-1]}, the last component of that interpolation\n+     * point (where {@code dimension} is thus the dimension of the sampled\n+     * space).\n+     * @param yval the values for the interpolation points\n+     * @param brightnessExponent Brightness dimming factor.\n+     * @param microsphereElements Number of surface elements of the\n+     * microsphere.\n+     * @param rand Unit vector generator for creating the microsphere.\n+     * @throws DimensionMismatchException if the lengths of {@code yval} and\n+     * {@code xval} (equal to {@code n}, the number of interpolation points)\n+     * do not match, or the the arrays {@code xval[0]} ... {@code xval[n]},\n+     * have lengths different from {@code dimension}.\n+     * @throws IllegalArgumentException if there are no data (xval null or zero length)\n+     */\n+    public MicrosphereInterpolatingFunction(double[][] xval,\n+                                            double[] yval,\n+                                            int brightnessExponent,\n+                                            int microsphereElements,\n+                                            UnitSphereRandomVectorGenerator rand)\n+        throws DimensionMismatchException, IllegalArgumentException {\n+        if (xval.length == 0 || xval[0] == null) {\n+            MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+\n+        if (xval.length != yval.length) {\n+            throw new DimensionMismatchException(xval.length, yval.length);\n+        }\n+\n+        dimension = xval[0].length;\n+        this.brightnessExponent = brightnessExponent;\n+\n+        // Copy data samples.\n+        samples = new HashMap<RealVector, Double>(yval.length);\n+        for (int i = 0, max = xval.length; i < max; i++) {\n+            if (xval[i].length != dimension) {\n+                throw new DimensionMismatchException(xval.length, yval.length);\n+            }\n+\n+            samples.put(new ArrayRealVector(xval[i]), yval[i]);\n+        }\n+\n+        microsphere = new ArrayList<MicrosphereSurfaceElement>(microsphereElements);\n+        // Generate the microsphere, assuming that a fairly large number of\n+        // randomly generated normals will represent a sphere.\n+        for (int i = 0; i < microsphereElements; i++) {\n+            microsphere.add(new MicrosphereSurfaceElement(rand.nextVector()));\n+        }\n+\n+    }\n+\n+    /**\n+     * @param point Interpolation point.\n+     * @return the interpolated value.\n+     */\n+    public double value(double[] point)\n+        throws FunctionEvaluationException {\n+\n+        final RealVector p = new ArrayRealVector(point);\n+\n+        // Reset.\n+        for (MicrosphereSurfaceElement md : microsphere) {\n+            md.reset();\n+        }\n+\n+        // Compute contribution of each sample points to the microsphere elements illumination\n+        for (Map.Entry<RealVector, Double> sd : samples.entrySet()) {\n+\n+            // Vector between interpolation point and current sample point.\n+            final RealVector diff = sd.getKey().subtract(p);\n+            final double diffNorm = diff.getNorm();\n+\n+            if (Math.abs(diffNorm) < Math.ulp(1d)) {\n+                // No need to interpolate, as the interpolation point is\n+                // actually (very close to) one of the sampled points.\n+                return sd.getValue();\n+            }\n+\n+            for (MicrosphereSurfaceElement md : microsphere) {\n+                final double w = Math.pow(diffNorm, -brightnessExponent);\n+                md.store(cosAngle(diff, md.normal()) * w, sd);\n+            }\n+\n+        }\n+\n+        // Interpolation calculation.\n+        double value = 0;\n+        double totalWeight = 0;\n+        for (MicrosphereSurfaceElement md : microsphere) {\n+            final double iV = md.illumination();\n+            final Map.Entry<RealVector, Double> sd = md.sample();\n+            if (sd != null) {\n+                value += iV * sd.getValue();\n+                totalWeight += iV;\n+            }\n+        }\n+\n+        return value / totalWeight;\n+\n+    }\n+\n+    /**\n+     * Compute the cosine of the angle between 2 vectors.\n+     *\n+     * @param v Vector.\n+     * @param w Vector.\n+     */\n+    private double cosAngle(final RealVector v, final RealVector w) {\n+        return v.dotProduct(w) / (v.getNorm() * w.getNorm());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n+\n+/**\n+ * Interpolator that implements the algorithm described in\n+ * <em>William Dudziak</em>'s\n+ * <a href=\"http://www.dudziak.com/microsphere.pdf\">MS thesis</a>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class MicrosphereInterpolator\n+    implements MultivariateRealInterpolator {\n+\n+    /**\n+     * Default number of surface elements that composes the microsphere.\n+     */\n+    public static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;\n+\n+    /**\n+     * Default exponent used the weights calculation.\n+     */\n+    public static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;\n+\n+    /**\n+     * Number of surface elements of the microsphere.\n+     */\n+    private int microsphereElements;\n+\n+    /**\n+     * Exponent used in the power law that computes the weights of the\n+     * sample data.\n+     */\n+    private int brightnessExponent;\n+\n+    /** Create a microsphere interpolator with default settings.\n+     * <p>Calling this constructor is equivalent to call {@link\n+     * #MicrosphereInterpolator(int, int)\n+     * MicrosphereInterpolator(MicrosphereInterpolator.DEFAULT_MICROSPHERE_ELEMENTS,\n+     * MicrosphereInterpolator.DEFAULT_BRIGHTNESS_EXPONENT)}.</p>\n+     * weights of the sample data\n+     */\n+    public MicrosphereInterpolator() {\n+        this(DEFAULT_MICROSPHERE_ELEMENTS, DEFAULT_BRIGHTNESS_EXPONENT);\n+    }\n+\n+    /** Create a microsphere interpolator.\n+     * @param microsphereElements number of surface elements of the microsphere\n+     * @param brightnessExponent exponent used in the power law that computes the\n+     * weights of the sample data\n+     * @throws IllegalArgumentException if {@code microsphereElements <= 0}\n+     * or {@code brightnessExponent < 0}\n+     */\n+    public MicrosphereInterpolator(final int microsphereElements,\n+                                   final int brightnessExponent) {\n+        setMicropshereElements(microsphereElements);\n+        setBrightnessExponent(brightnessExponent);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public MultivariateRealFunction interpolate(final double[][] xval,\n+                                                final double[] yval)\n+        throws MathException, IllegalArgumentException {\n+        final UnitSphereRandomVectorGenerator rand\n+            = new UnitSphereRandomVectorGenerator(xval[0].length);\n+        return new MicrosphereInterpolatingFunction(xval, yval,\n+                                                    brightnessExponent,\n+                                                    microsphereElements,\n+                                                    rand);\n+    }\n+\n+    /**\n+     * Set the brightness exponent.\n+     * @param brightnessExponent Exponent for computing the distance dimming\n+     * factor.\n+     * @throws IllegalArgumentException if {@code brightnessExponent < 0}.\n+     */\n+    public void setBrightnessExponent(final int brightnessExponent) {\n+        if (brightnessExponent < 0) {\n+            MathRuntimeException.createIllegalArgumentException(\n+                \"brightness exponent should be positive or null, but got {0}\",\n+                brightnessExponent);\n+        }\n+        this.brightnessExponent = brightnessExponent;\n+    }\n+\n+    /**\n+     * Set the number of microsphere elements.\n+     * @param microsphereElements Number of surface elements of the microsphere.\n+     * @throws IllegalArgumentException if {@code microsphereElements <= 0}.\n+     */\n+    public void setMicropshereElements(final int microsphereElements) {\n+        if (microsphereElements < 0) {\n+            MathRuntimeException.createIllegalArgumentException(\n+                \"number of microsphere elements must be positive, but got {0}\",\n+                microsphereElements);\n+        }\n+        this.microsphereElements = microsphereElements;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MultivariateRealInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/**\n+ * Interface representing a univariate real interpolating function.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface MultivariateRealInterpolator {\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param xval the arguments for the interpolation points.\n+     * {@code xval[i][0]} is the first component of interpolation point\n+     * {@code i}, {@code xval[i][1]} is the second component, and so on\n+     * until {@code xval[i][d-1]}, the last component of that interpolation\n+     * point (where {@code d} is thus the dimension of the space).\n+     * @param yval the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolation algorithm or some dimension mismatch occurs\n+     * @throws IllegalArgumentException if there are no data (xval null or zero length)\n+     */\n+    public MultivariateRealFunction interpolate(double[][] xval,\n+                                                double[] yval)\n+        throws MathException, IllegalArgumentException;\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n      * @param yval the values for the interpolation points\n      * @return a function which interpolates the data set\n      * @throws MathException if arguments violate assumptions made by the\n-     *         interpolationg algorithm\n+     *         interpolation algorithm\n      */\n     UnivariateRealFunction interpolate(double xval[], double yval[])\n         throws MathException;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/UnitSphereRandomVectorGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+\n+/**\n+ * Generate random vectors isotropically located on the surface of a sphere.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class UnitSphereRandomVectorGenerator\n+    implements RandomVectorGenerator {\n+    /**\n+     * RNG used for generating the individual components of the vectors.\n+     */\n+    private final RandomGenerator rand;\n+    /**\n+     * Space dimension.\n+     */\n+    private final int dimension;\n+\n+    /**\n+     * @param dimension Space dimension.\n+     * @param rand RNG for the individual components of the vectors.\n+     */\n+    public UnitSphereRandomVectorGenerator(final int dimension,\n+                                           final RandomGenerator rand) {\n+        this.dimension = dimension;\n+        this.rand = rand;\n+    }\n+    /**\n+     * Create an object that will use a default RNG ({@link MersenneTwister}),\n+     * in order to generate the individual components.\n+     *\n+     * @param dimension Space dimension.\n+     */\n+    public UnitSphereRandomVectorGenerator(final int dimension) {\n+        this(dimension, new MersenneTwister());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] nextVector() {\n+\n+        final double[] v = new double[dimension];\n+\n+        double normSq;\n+        do {\n+            normSq = 0;\n+            for (int i = 0; i < dimension; i++) {\n+                final double comp = 2 * rand.nextDouble() - 1;\n+                v[i] = comp;\n+                normSq += comp * comp;\n+            }\n+        } while (normSq > 1);\n+\n+        final double f = 1 / Math.sqrt(normSq);\n+        for (int i = 0; i < dimension; i++) {\n+            v[i] *= f;\n+        }\n+\n+        return v;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the \"microsphere projection\" interpolator.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class MicrosphereInterpolatorTest {\n+    /**\n+     * Test of interpolator for a plane.\n+     * <p>\n+     * y = 2 x<sub>1</sub> - 3 x<sub>2</sub> + 5\n+     */\n+    @Test\n+    public void testLinearFunction2D() throws MathException {\n+        MultivariateRealFunction f = new MultivariateRealFunction() {\n+                public double value(double[] x) {\n+                    if (x.length != 2) {\n+                        throw new IllegalArgumentException();\n+                    }\n+                    return 2 * x[0] - 3 * x[1] + 5;\n+                }\n+            };\n+\n+        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();\n+\n+        // Interpolating points in [-1, 1][-1, 1] by steps of 1.\n+        final int n = 9;\n+        final int dim = 2;\n+        double[][] x = new double[n][dim];\n+        double[] y = new double[n];\n+        int index = 0;\n+        for (int i = -1; i <= 1; i++) {\n+            for (int j = -1; j <= 1; j++) {\n+                x[index][0] = i;\n+                x[index][1] = j;\n+                y[index] = f.value(x[index]);\n+                ++index;\n+            }\n+        }\n+\n+        MultivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        double[] c = new double[dim];\n+        double expected, result;\n+\n+        c[0] = 0;\n+        c[1] = 0;\n+        expected = f.value(c);\n+        result = p.value(c);\n+        Assert.assertEquals(\"On sample point\", expected, result, Math.ulp(1d));\n+\n+        c[0] = 0 + 1e-5;\n+        c[1] = 1 - 1e-5;\n+        expected = f.value(c);\n+        result = p.value(c);\n+        Assert.assertEquals(\"1e-5 away from sample point\", expected, result, 1e-4);\n+    }\n+\n+    /**\n+     * Test of interpolator for a quadratic function.\n+     * <p>\n+     * y = 2 x<sub>1</sub><sup>2</sup> - 3 x<sub>2</sub><sup>2</sup>\n+     *     + 4 x<sub>1</sub> x<sub>2</sub> - 5\n+     */\n+    @Test\n+    public void testParaboloid2D() throws MathException {\n+        MultivariateRealFunction f = new MultivariateRealFunction() {\n+                public double value(double[] x) {\n+                    if (x.length != 2) {\n+                        throw new IllegalArgumentException();\n+                    }\n+                    return 2 * x[0] * x[0] - 3 * x[1] * x[1] + 4 * x[0] * x[1] - 5;\n+                }\n+            };\n+\n+        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();\n+\n+        // Interpolating points in [-10, 10][-10, 10] by steps of 2.\n+        final int n = 121;\n+        final int dim = 2;\n+        double[][] x = new double[n][dim];\n+        double[] y = new double[n];\n+        int index = 0;\n+        for (int i = -10; i <= 10; i += 2) {\n+            for (int j = -10; j <= 10; j += 2) {\n+                x[index][0] = i;\n+                x[index][1] = j;\n+                y[index] = f.value(x[index]);\n+                ++index;\n+            }\n+        }\n+\n+        MultivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        double[] c = new double[dim];\n+        double expected, result;\n+\n+        c[0] = 0;\n+        c[1] = 0;\n+        expected = f.value(c);\n+        result = p.value(c);\n+        Assert.assertEquals(\"On sample point\", expected, result, Math.ulp(1d));\n+\n+        c[0] = 2 + 1e-5;\n+        c[1] = 2 - 1e-5;\n+        expected = f.value(c);\n+        result = p.value(c);\n+        Assert.assertEquals(\"1e-5 away from sample point\", expected, result, 1e-3);\n+    }\n+}", "timestamp": 1254693450, "metainfo": ""}