{"sha": "b67bf47e45fa177c25fd5c445011d868a5383a6d", "log": "MATH-517 \"HarmonicFitter\" refactored to include the functionality of \"HarmonicCoefficientsGuesser\" as an inner class, and now using \"HarmonicOscillator\" (from package \"analysis.function\") instead of \"HarmonicFunction\" (from package \"optimization.fitting\").   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.analysis.function.HarmonicOscillator;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n \n-/** This class implements a curve fitting specialized for sinusoids.\n- * <p>Harmonic fitting is a very simple case of curve fitting. The\n+/**\n+ * Class that implements a curve fitting specialized for sinusoids.\n+ *\n+ * Harmonic fitting is a very simple case of curve fitting. The\n  * estimated coefficients are the amplitude a, the pulsation &omega; and\n  * the phase &phi;: <code>f (t) = a cos (&omega; t + &phi;)</code>. They are\n  * searched by a least square estimator initialized with a rough guess\n- * based on integrals.</p>\n+ * based on integrals.\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class HarmonicFitter {\n-\n-    /** Fitter for the coefficients. */\n-    private final CurveFitter fitter;\n-\n-    /** Values for amplitude, pulsation &omega; and phase &phi;. */\n-    private double[] parameters;\n-\n-    /** Simple constructor.\n-     * @param optimizer optimizer to use for the fitting\n+public class HarmonicFitter extends CurveFitter {\n+    /**\n+     * Simple constructor.\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        this.fitter = new CurveFitter(optimizer);\n-        parameters  = null;\n-    }\n-\n-    /** Simple constructor.\n-     * <p>This constructor can be used when a first guess of the\n-     * coefficients is already known.</p>\n-     * @param optimizer optimizer to use for the fitting\n-     * @param initialGuess guessed values for amplitude (index 0),\n-     * pulsation &omega; (index 1) and phase &phi; (index 2)\n-     */\n-    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,\n-                          final double[] initialGuess) {\n-        this.fitter     = new CurveFitter(optimizer);\n-        this.parameters = initialGuess.clone();\n-    }\n-\n-    /** Add an observed weighted (x,y) point to the sample.\n-     * @param weight weight of the observed point in the fit\n-     * @param x abscissa of the point\n-     * @param y observed value of the point at x, after fitting we should\n-     * have P(x) as close as possible to this value\n-     */\n-    public void addObservedPoint(double weight, double x, double y) {\n-        fitter.addObservedPoint(weight, x, y);\n+        super(optimizer);\n     }\n \n     /**\n      * Fit an harmonic function to the observed points.\n      *\n-     * @return harmonic Function that best fits the observed points.\n-     * @throws NumberIsTooSmallException if the sample is too short or if\n-     * the first guess cannot be computed.\n-     * @throws OptimizationException\n+     * @param initialGuess First guess values in the following order:\n+     * <ul>\n+     *  <li>Amplitude</li>\n+     *  <li>Angular frequency</li>\n+     *  <li>Phase</li>\n+     * </ul>\n+     * @return the parameters of the harmonic function that best fits the\n+     * observed points (in the same order as above).\n      */\n-    public HarmonicFunction fit() throws OptimizationException {\n-        // shall we compute the first guess of the parameters ourselves ?\n-        if (parameters == null) {\n-            final WeightedObservedPoint[] observations = fitter.getObservations();\n+    public double[] fit(double[] initialGuess) {\n+        return fit(new HarmonicOscillator.Parametric(), initialGuess);\n+    }\n+\n+    /**\n+     * Fit an harmonic function to the observed points.\n+     * An initial guess will be automatically computed.\n+     *\n+     * @return the parameters of the harmonic function that best fits the\n+     * observed points (see the other {@link #fit(double[]) fit} method.\n+     * @throws NumberIsTooSmallException if the sample is too short for the\n+     * the first guess to be computed.\n+     * @throws ZeroException if the first guess cannot be computed because\n+     * the abscissa range is zero.\n+     */\n+    public double[] fit() {\n+        return fit((new ParameterGuesser(getObservations())).guess());\n+    }\n+\n+    /**\n+     * This class guesses harmonic coefficients from a sample.\n+     * <p>The algorithm used to guess the coefficients is as follows:</p>\n+     *\n+     * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,\n+     * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).\n+     * </p>\n+     *\n+     * <p>From the analytical expression, we can compute two primitives :\n+     * <pre>\n+     *     If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2\n+     *     If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2\n+     *     where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)\n+     * </pre>\n+     * </p>\n+     *\n+     * <p>We can remove S between these expressions :\n+     * <pre>\n+     *     If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)\n+     * </pre>\n+     * </p>\n+     *\n+     * <p>The preceding expression shows that If'2 (t) is a linear\n+     * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)\n+     * </p>\n+     *\n+     * <p>From the primitive, we can deduce the same form for definite\n+     * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :\n+     * <pre>\n+     *   If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))\n+     * </pre>\n+     * </p>\n+     *\n+     * <p>We can find the coefficients A and B that best fit the sample\n+     * to this linear expression by computing the definite integrals for\n+     * each sample points.\n+     * </p>\n+     *\n+     * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the\n+     * coefficients A and B that minimize a least square criterion\n+     * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>\n+     * <pre>\n+     *\n+     *         &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+     *     A = ------------------------\n+     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+     *\n+     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>\n+     *     B = ------------------------\n+     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+     * </pre>\n+     * </p>\n+     *\n+     *\n+     * <p>In fact, we can assume both a and &omega; are positive and\n+     * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that\n+     * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>\n+     * <pre>\n+     *\n+     * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:\n+     *   f  (t<sub>i</sub>)\n+     *   f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)\n+     *   x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>\n+     *   y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+     *   z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+     *   update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>\n+     * end for\n+     *\n+     *            |--------------------------\n+     *         \\  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+     * a     =  \\ | ------------------------\n+     *           \\| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+     *\n+     *\n+     *            |--------------------------\n+     *         \\  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+     * &omega;     =  \\ | ------------------------\n+     *           \\| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+     *\n+     * </pre>\n+     * </p>\n+     *\n+     * <p>Once we know &omega;, we can compute:\n+     * <pre>\n+     *    fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)\n+     *    fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)\n+     * </pre>\n+     * </p>\n+     *\n+     * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and\n+     * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these\n+     * expressions to compute &phi;. The best estimate over the sample is\n+     * given by averaging these expressions.\n+     * </p>\n+     *\n+     * <p>Since integrals and means are involved in the preceding\n+     * estimations, these operations run in O(n) time, where n is the\n+     * number of measurements.</p>\n+     */\n+    public static class ParameterGuesser {\n+        /** Sampled observations. */\n+        private final WeightedObservedPoint[] observations;\n+        /** Amplitude. */\n+        private double a;\n+        /** Angular frequency. */\n+        private double omega;\n+        /** Phase. */\n+        private double phi;\n+\n+        /**\n+         * Simple constructor.\n+         * @param observations sampled observations\n+         * @throws NumberIsTooSmallException if the sample is too short or if\n+         * the first guess cannot be computed.\n+         */\n+        public ParameterGuesser(WeightedObservedPoint[] observations) {\n             if (observations.length < 4) {\n                 throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                     observations.length, 4, true);\n             }\n \n-            HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);\n-            guesser.guess();\n-            parameters = new double[] {\n-                guesser.getGuessedAmplitude(),\n-                guesser.getGuessedPulsation(),\n-                guesser.getGuessedPhase()\n-            };\n-        }\n-\n-        double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);\n-        return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n+            this.observations = observations.clone();\n+        }\n+\n+        /**\n+         * Estimate a first guess of the coefficients.\n+         *\n+         * @return the guessed coefficients, in the following order:\n+         * <ul>\n+         *  <li>Amplitude</li>\n+         *  <li>Angular frequency</li>\n+         *  <li>Phase</li>\n+         * </ul>\n+         */\n+        public double[] guess() {\n+            sortObservations();\n+            guessAOmega();\n+            guessPhi();\n+            return new double[] { a, omega, phi };\n+        }\n+\n+        /**\n+         * Sort the observations with respect to the abscissa.\n+         */\n+        private void sortObservations() {\n+            // Since the samples are almost always already sorted, this\n+            // method is implemented as an insertion sort that reorders the\n+            // elements in place. Insertion sort is very efficient in this case.\n+            WeightedObservedPoint curr = observations[0];\n+            for (int j = 1; j < observations.length; ++j) {\n+                WeightedObservedPoint prec = curr;\n+                curr = observations[j];\n+                if (curr.getX() < prec.getX()) {\n+                    // the current element should be inserted closer to the beginning\n+                    int i = j - 1;\n+                    WeightedObservedPoint mI = observations[i];\n+                    while ((i >= 0) && (curr.getX() < mI.getX())) {\n+                        observations[i + 1] = mI;\n+                        if (i-- != 0) {\n+                            mI = observations[i];\n+                        }\n+                    }\n+                    observations[i + 1] = curr;\n+                    curr = observations[j];\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Estimate a first guess of the amplitude and angular frequency.\n+         * This method assumes that the {@link #sortObservations()} method\n+         * has been called previously.\n+         *\n+         * @throws ZeroException if the abscissa range is zero.\n+         */\n+        private void guessAOmega() {\n+            // initialize the sums for the linear model between the two integrals\n+            double sx2 = 0;\n+            double sy2 = 0;\n+            double sxy = 0;\n+            double sxz = 0;\n+            double syz = 0;\n+\n+            double currentX = observations[0].getX();\n+            double currentY = observations[0].getY();\n+            double f2Integral = 0;\n+            double fPrime2Integral = 0;\n+            final double startX = currentX;\n+            for (int i = 1; i < observations.length; ++i) {\n+                // one step forward\n+                final double previousX = currentX;\n+                final double previousY = currentY;\n+                currentX = observations[i].getX();\n+                currentY = observations[i].getY();\n+\n+                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n+                // considering a linear model for f (and therefore constant f')\n+                final double dx = currentX - previousX;\n+                final double dy = currentY - previousY;\n+                final double f2StepIntegral =\n+                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n+                final double fPrime2StepIntegral = dy * dy / dx;\n+\n+                final double x = currentX - startX;\n+                f2Integral += f2StepIntegral;\n+                fPrime2Integral += fPrime2StepIntegral;\n+\n+                sx2 += x * x;\n+                sy2 += f2Integral * f2Integral;\n+                sxy += x * f2Integral;\n+                sxz += x * fPrime2Integral;\n+                syz += f2Integral * fPrime2Integral;\n+            }\n+\n+            // compute the amplitude and pulsation coefficients\n+            double c1 = sy2 * sxz - sxy * syz;\n+            double c2 = sxy * sxz - sx2 * syz;\n+            double c3 = sx2 * sy2 - sxy * sxy;\n+            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n+                a = 0;\n+\n+                // Range of the observations, assuming that the\n+                // observations are sorted.\n+                final double range = observations[observations.length - 1].getX() -\n+                    observations[0].getX();\n+\n+                if (range == 0) {\n+                    throw new ZeroException();\n+                }\n+                omega = 2 * Math.PI / range;\n+            } else {\n+                a = FastMath.sqrt(c1 / c2);\n+                omega = FastMath.sqrt(c2 / c3);\n+            }\n+        }\n+\n+        /**\n+         * Estimate a first guess of the phase.\n+         */\n+        private void guessPhi() {\n+            // initialize the means\n+            double fcMean = 0;\n+            double fsMean = 0;\n+\n+            double currentX = observations[0].getX();\n+            double currentY = observations[0].getY();\n+            for (int i = 1; i < observations.length; ++i) {\n+                // one step forward\n+                final double previousX = currentX;\n+                final double previousY = currentY;\n+                currentX = observations[i].getX();\n+                currentY = observations[i].getY();\n+                final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n+\n+                double omegaX = omega * currentX;\n+                double cosine = FastMath.cos(omegaX);\n+                double sine = FastMath.sin(omegaX);\n+                fcMean += omega * currentY * cosine - currentYPrime * sine;\n+                fsMean += omega * currentY * sine + currentYPrime * cosine;\n+            }\n+\n+            phi = FastMath.atan2(-fsMean, fcMean);\n+        }\n     }\n-\n-    /** Parametric harmonic function. */\n-    private static class ParametricHarmonicFunction implements ParametricUnivariateRealFunction {\n-\n-        /** {@inheritDoc} */\n-        public double value(double x, double[] parameters) {\n-            final double a     = parameters[0];\n-            final double omega = parameters[1];\n-            final double phi   = parameters[2];\n-            return a * FastMath.cos(omega * x + phi);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double[] gradient(double x, double[] parameters) {\n-            final double a     = parameters[0];\n-            final double omega = parameters[1];\n-            final double phi   = parameters[2];\n-            final double alpha = omega * x + phi;\n-            final double cosAlpha = FastMath.cos(alpha);\n-            final double sinAlpha = FastMath.sin(alpha);\n-            return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };\n-        }\n-\n-    }\n-\n }\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n \n import java.util.Random;\n \n-import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.analysis.function.HarmonicOscillator;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n public class HarmonicFitterTest {\n \n     @Test\n-    public void testNoError() throws OptimizationException {\n-        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+    public void testNoError() {\n+        final double a = 0.2;\n+        final double w = 3.4;\n+        final double p = 4.1;\n+        HarmonicOscillator f = new HarmonicOscillator(a, w, p);\n \n         HarmonicFitter fitter =\n             new HarmonicFitter(new LevenbergMarquardtOptimizer());\n         for (double x = 0.0; x < 1.3; x += 0.01) {\n-            fitter.addObservedPoint(1.0, x, f.value(x));\n+            fitter.addObservedPoint(1, x, f.value(x));\n         }\n \n-        HarmonicFunction fitted = fitter.fit();\n-        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.0e-13);\n-        assertEquals(f.getPulsation(), fitted.getPulsation(), 1.0e-13);\n-        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.0e-13);\n+        final double[] fitted = fitter.fit();\n+        assertEquals(a, fitted[0], 1.0e-13);\n+        assertEquals(w, fitted[1], 1.0e-13);\n+        assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1e-13);\n+\n+        HarmonicOscillator ff = new HarmonicOscillator(fitted[0], fitted[1], fitted[2]);\n \n         for (double x = -1.0; x < 1.0; x += 0.01) {\n-            assertTrue(FastMath.abs(f.value(x) - fitted.value(x)) < 1.0e-13);\n+            assertTrue(FastMath.abs(f.value(x) - ff.value(x)) < 1e-13);\n         }\n+    }\n+\n+    @Test\n+    public void test1PercentError() {\n+        Random randomizer = new Random(64925784252l);\n+        final double a = 0.2;\n+        final double w = 3.4;\n+        final double p = 4.1;\n+        HarmonicOscillator f = new HarmonicOscillator(a, w, p);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+        for (double x = 0.0; x < 10.0; x += 0.1) {\n+            fitter.addObservedPoint(1, x,\n+                                   f.value(x) + 0.01 * randomizer.nextGaussian());\n+        }\n+\n+        final double[] fitted = fitter.fit();\n+        assertEquals(a, fitted[0], 7.6e-4);\n+        assertEquals(w, fitted[1], 2.7e-3);\n+        assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.3e-2);\n \n     }\n \n     @Test\n-    public void test1PercentError() throws OptimizationException {\n-        Random randomizer = new Random(64925784252l);\n-        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+    public void testInitialGuess() {\n+        Random randomizer = new Random(45314242l);\n+        final double a = 0.2;\n+        final double w = 3.4;\n+        final double p = 4.1;\n+        HarmonicOscillator f = new HarmonicOscillator(a, w, p);\n \n         HarmonicFitter fitter =\n             new HarmonicFitter(new LevenbergMarquardtOptimizer());\n         for (double x = 0.0; x < 10.0; x += 0.1) {\n-            fitter.addObservedPoint(1.0, x,\n+            fitter.addObservedPoint(1, x,\n                                    f.value(x) + 0.01 * randomizer.nextGaussian());\n         }\n \n-        HarmonicFunction fitted = fitter.fit();\n-        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);\n-        assertEquals(f.getPulsation(), fitted.getPulsation(), 2.7e-3);\n-        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.3e-2);\n-\n+        final double[] fitted = fitter.fit(new double[] { 0.15, 3.6, 4.5 });\n+        assertEquals(a, fitted[0], 1.2e-3);\n+        assertEquals(w, fitted[1], 3.3e-3);\n+        assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.7e-2);\n     }\n \n     @Test\n-    public void testInitialGuess() throws OptimizationException {\n-        Random randomizer = new Random(45314242l);\n-        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n-\n-        HarmonicFitter fitter =\n-            new HarmonicFitter(new LevenbergMarquardtOptimizer(), new double[] { 0.15, 3.6, 4.5 });\n-        for (double x = 0.0; x < 10.0; x += 0.1) {\n-            fitter.addObservedPoint(1.0, x,\n-                                   f.value(x) + 0.01 * randomizer.nextGaussian());\n-        }\n-\n-        HarmonicFunction fitted = fitter.fit();\n-        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.2e-3);\n-        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.3e-3);\n-        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.7e-2);\n-\n-    }\n-\n-    @Test\n-    public void testUnsorted() throws OptimizationException {\n+    public void testUnsorted() {\n         Random randomizer = new Random(64925784252l);\n-        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+        final double a = 0.2;\n+        final double w = 3.4;\n+        final double p = 4.1;\n+        HarmonicOscillator f = new HarmonicOscillator(a, w, p);\n \n         HarmonicFitter fitter =\n             new HarmonicFitter(new LevenbergMarquardtOptimizer());\n \n         // pass it to the fitter\n         for (int i = 0; i < size; ++i) {\n-            fitter.addObservedPoint(1.0, xTab[i], yTab[i]);\n+            fitter.addObservedPoint(1, xTab[i], yTab[i]);\n         }\n \n-        HarmonicFunction fitted = fitter.fit();\n-        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);\n-        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.5e-3);\n-        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.5e-2);\n-\n+        final double[] fitted = fitter.fit();\n+        assertEquals(a, fitted[0], 7.6e-4);\n+        assertEquals(w, fitted[1], 3.5e-3);\n+        assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.5e-2);\n     }\n-\n }", "timestamp": 1298391236, "metainfo": ""}