{"sha": "b52eeaf76ed3a4a126d196da5c04895b18a1254a", "log": "[MATH-235] add SchurTransformer to transform a general real matrix to Schur form.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n+\n+/**\n+ * Class transforming a general real matrix to Schur form.\n+ * <p>A m &times; m matrix A can be written as the product of three matrices: A = P\n+ * &times; T &times; P<sup>T</sup> with P an orthogonal matrix and T an quasi-triangular\n+ * matrix. Both P and T are m &times; m matrices.</p>\n+ * <p>Transformation to Schur form is often not a goal by itself, but it is an\n+ * intermediate step in more general decomposition algorithms like\n+ * {@link EigenDecomposition eigen decomposition}. This class is therefore\n+ * intended for internal use by the library and is not public. As a consequence\n+ * of this explicitly limited scope, many methods directly returns references to\n+ * internal arrays, not copies.</p>\n+ * <p>This class is based on the method hqr2 in class EigenvalueDecomposition\n+ * from the <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/SchurDecomposition.html\">Schur Decomposition - MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Schur_decomposition\">Schur Decomposition - Wikipedia</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Householder_transformation\">Householder Transformations</a>\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+class SchurTransformer {\n+    /** P matrix. */\n+    private final double matrixP[][];\n+    /** T matrix. */\n+    private final double matrixT[][];\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+    /** Cached value of T. */\n+    private RealMatrix cachedT;\n+    /** Cached value of PT. */\n+    private RealMatrix cachedPt;\n+\n+    /** Maximum allowed iterations for convergence of the transformation. */\n+    private final int maxIterations = 40;\n+\n+    /** Epsilon criteria taken from JAMA code (2^-52). */\n+    private final double epsilon = 2.220446049250313E-16;\n+\n+    /**\n+     * Build the transformation to Schur form of a general real matrix.\n+     *\n+     * @param matrix matrix to transform\n+     * @throws NonSquareMatrixException if the matrix is not square\n+     */\n+    public SchurTransformer(final RealMatrix matrix) {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n+        matrixT = transformer.getH().getData();\n+        matrixP = transformer.getP().getData();\n+        cachedT = null;\n+        cachedP = null;\n+        cachedPt = null;\n+\n+        // transform matrix\n+        transform();\n+    }\n+\n+    /**\n+     * Returns the matrix P of the transform.\n+     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\n+     *\n+     * @return the P matrix\n+     */\n+    public RealMatrix getP() {\n+        if (cachedP == null) {\n+            cachedP = MatrixUtils.createRealMatrix(matrixP);\n+        }\n+        return cachedP;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix P of the transform.\n+     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\n+     *\n+     * @return the transpose of the P matrix\n+     */\n+    public RealMatrix getPT() {\n+        if (cachedPt == null) {\n+            cachedPt = getP().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedPt;\n+    }\n+\n+    /**\n+     * Returns the quasi-triangular Schur matrix T of the transform.\n+     *\n+     * @return the T matrix\n+     */\n+    public RealMatrix getT() {\n+        if (cachedT == null) {\n+            cachedT = MatrixUtils.createRealMatrix(matrixT);\n+        }\n+\n+        // return the cached matrix\n+        return cachedT;\n+    }\n+\n+    /**\n+     * Transform original matrix to Schur form.\n+     * @throws TooManyEvaluationsException if the transformation does not converge\n+     */\n+    private void transform() {\n+        final int n = matrixT.length;\n+\n+        // compute matrix norm\n+        final double norm = getNorm();\n+\n+        // shift information\n+        final ShiftInfo shift = new ShiftInfo();\n+\n+        // Outer loop over eigenvalue index\n+        int iteration = 0;\n+        int idx = n - 1;\n+        while (idx >= 0) {\n+\n+            // Look for single small sub-diagonal element\n+            final int l = findSmallSubDiagonalElement(idx, norm);\n+\n+            // Check for convergence\n+            if (l == idx) {\n+                // One root found\n+                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n+                idx--;\n+                iteration = 0;\n+            } else if (l == idx - 1) {\n+                // Two roots found\n+                shift.w = matrixT[idx][idx-1] * matrixT[idx-1][idx];\n+                double p = (matrixT[idx-1][idx-1] - matrixT[idx][idx]) / 2.0;\n+                double q = p * p + shift.w;\n+                double z = FastMath.sqrt(FastMath.abs(q));\n+                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n+                matrixT[idx-1][idx-1] = matrixT[idx-1][idx-1] + shift.exShift;\n+                shift.x = matrixT[idx][idx];\n+\n+                if (q >= 0) {\n+                    if (p >= 0) {\n+                        z = p + z;\n+                    } else {\n+                        z = p - z;\n+                    }\n+                    shift.x = matrixT[idx][idx-1];\n+                    double s = FastMath.abs(shift.x) + FastMath.abs(z);\n+                    p = shift.x / s;\n+                    q = z / s;\n+                    double r = FastMath.sqrt(p * p + q * q);\n+                    p = p / r;\n+                    q = q / r;\n+\n+                    // Row modification\n+                    for (int j = idx-1; j < n; j++) {\n+                        z = matrixT[idx-1][j];\n+                        matrixT[idx-1][j] = q * z + p * matrixT[idx][j];\n+                        matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n+                    }\n+\n+                    // Column modification\n+                    for (int i = 0; i <= idx; i++) {\n+                        z = matrixT[i][idx-1];\n+                        matrixT[i][idx-1] = q * z + p * matrixT[i][idx];\n+                        matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n+                    }\n+\n+                    // Accumulate transformations\n+                    for (int i = 0; i <= n - 1; i++) {\n+                        z = matrixP[i][idx-1];\n+                        matrixP[i][idx-1] = q * z + p * matrixP[i][idx];\n+                        matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n+                    }\n+                }\n+                idx -= 2;\n+                iteration = 0;\n+            } else {\n+                // No convergence yet\n+\n+                computeShift(l, idx, iteration, shift);\n+\n+                // stop transformation after too many iterations\n+                if (++iteration > maxIterations) {\n+                    throw new TooManyEvaluationsException(maxIterations);\n+                }\n+\n+                // Look for two consecutive small sub-diagonal elements\n+                int m = idx - 2;\n+\n+                // the initial houseHolder vector for the QR step\n+                final double[] hVec = new double[3];\n+\n+                while (m >= l) {\n+                    double z = matrixT[m][m];\n+                    hVec[2] = shift.x - z;\n+                    double s = shift.y - z;\n+                    hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n+                    hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n+                    hVec[2] = matrixT[m + 2][m + 1];\n+                    s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n+\n+                    if (m == l) {\n+                        break;\n+                    }\n+\n+                    for (int i = 0; i < hVec.length; i++) {\n+                        hVec[i] /= s;\n+                    }\n+\n+                    final double lhs = FastMath.abs(matrixT[m][m - 1]) *\n+                            (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n+\n+                    final double rhs = FastMath.abs(hVec[0]) *\n+                            (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) +\n+                             FastMath.abs(matrixT[m + 1][m + 1]));\n+\n+                    if (lhs < epsilon * rhs) {\n+                        break;\n+                    }\n+                    m--;\n+                }\n+\n+                performDoubleQRStep(l, m, idx, shift, hVec);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Computes the L1 norm of the (quasi-)triangular matrix T.\n+     *\n+     * @return the L1 norm of matrix T\n+     */\n+    private double getNorm() {\n+        double norm = 0.0;\n+        for (int i = 0; i < matrixT.length; i++) {\n+            // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n+            for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n+                norm += FastMath.abs(matrixT[i][j]);\n+            }\n+        }\n+        return norm;\n+    }\n+\n+    /**\n+     * Find the first small sub-diagonal element and returns its index.\n+     *\n+     * @param startIdx the starting index for the search\n+     * @param norm the L1 norm of the matrix\n+     * @return the index of the first small sub-diagonal element\n+     */\n+    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n+        int l = startIdx;\n+        while (l > 0) {\n+            double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n+            if (Precision.equals(s, 0.0, epsilon)) {\n+                s = norm;\n+            }\n+            if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n+                break;\n+            }\n+            l--;\n+        }\n+        return l;\n+    }\n+\n+    /**\n+     * Compute the shift for the current iteration.\n+     *\n+     * @param l the index of the small sub-diagonal element\n+     * @param idx the current eigenvalue index\n+     * @param iteration the current iteration\n+     * @param shift holder for shift information\n+     */\n+    private void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\n+        // Form shift\n+        shift.x = matrixT[idx][idx];\n+        shift.y = shift.w = 0.0;\n+        if (l < idx) {\n+            shift.y = matrixT[idx - 1][idx - 1];\n+            shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n+        }\n+\n+        // Wilkinson's original ad hoc shift\n+        if (iteration == 10) {\n+            shift.exShift += shift.x;\n+            for (int i = 0; i <= idx; i++) {\n+                matrixT[i][i] -= shift.x;\n+            }\n+            double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n+            shift.x = shift.y = 0.75 * s;\n+            shift.w = -0.4375 * s * s;\n+        }\n+\n+        // MATLAB's new ad hoc shift\n+        if (iteration == 30) {\n+            double s = (shift.y - shift.x) / 2.0;\n+            s = s * s + shift.w;\n+            if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\n+                s = FastMath.sqrt(s);\n+                if (shift.y < shift.x) {\n+                    s = -s;\n+                }\n+                s = shift.x - shift.w / ((shift.y - shift.x) / 2.0 + s);\n+                for (int i = 0; i <= idx; i++) {\n+                    matrixT[i][i] -= s;\n+                }\n+                shift.exShift += s;\n+                shift.x = shift.y = shift.w = 0.964;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Perform a double QR step involving rows l:idx and columns m:n\n+     *\n+     * @param l the index of the small sub-diagonal element\n+     * @param m the start index for the QR step\n+     * @param idx the current eigenvalue index\n+     * @param shift shift information holder\n+     * @param hVec the initial houseHolder vector\n+     */\n+    private void performDoubleQRStep(final int l, final int m, final int idx,\n+                                     final ShiftInfo shift, final double[] hVec) {\n+\n+        final int n = matrixT.length;\n+        double p = hVec[0];\n+        double q = hVec[1];\n+        double r = hVec[2];\n+\n+        for (int k = m; k <= idx - 1; k++) {\n+            boolean notlast = k != idx - 1;\n+            if (k != m) {\n+                p = matrixT[k][k - 1];\n+                q = matrixT[k + 1][k - 1];\n+                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n+                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n+                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n+                    p = p / shift.x;\n+                    q = q / shift.x;\n+                    r = r / shift.x;\n+                }\n+            }\n+            if (Precision.equals(shift.x, 0.0, epsilon)) {\n+                break;\n+            }\n+            double s = FastMath.sqrt(p * p + q * q + r * r);\n+            if (Precision.compareTo(p, 0.0, epsilon) < 0) {\n+                s = -s;\n+            }\n+            if (!Precision.equals(s, 0.0, epsilon)) {\n+                if (k != m) {\n+                    matrixT[k][k - 1] = -s * shift.x;\n+                } else if (l != m) {\n+                    matrixT[k][k - 1] = -matrixT[k][k - 1];\n+                }\n+                p = p + s;\n+                shift.x = p / s;\n+                shift.y = q / s;\n+                double z = r / s;\n+                q = q / p;\n+                r = r / p;\n+\n+                // Row modification\n+                for (int j = k; j < n; j++) {\n+                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n+                    if (notlast) {\n+                        p = p + r * matrixT[k + 2][j];\n+                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n+                    }\n+                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n+                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n+                }\n+\n+                // Column modification\n+                for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n+                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n+                    if (notlast) {\n+                        p = p + z * matrixT[i][k + 2];\n+                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n+                    }\n+                    matrixT[i][k] = matrixT[i][k] - p;\n+                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n+                }\n+\n+                // Accumulate transformations\n+                final int high = matrixT.length - 1;\n+                for (int i = 0; i <= high; i++) {\n+                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n+                    if (notlast) {\n+                        p = p + z * matrixP[i][k + 2];\n+                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n+                    }\n+                    matrixP[i][k] = matrixP[i][k] - p;\n+                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n+                }\n+            }  // (s != 0)\n+        }  // k loop\n+\n+        // clean up pollution due to round-off errors\n+        for (int i = m+2; i <= idx; i++) {\n+            matrixT[i][i-2] = 0.0;\n+            if (i > m+2) {\n+                matrixT[i][i-3] = 0.0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal data structure holding the current shift information.\n+     * Contains variable names as present in the original JAMA code.\n+     */\n+    private static class ShiftInfo {\n+        /** TODO: document */\n+        double x;\n+        /** TODO: document */\n+        double y;\n+        /** TODO: document */\n+        double w;\n+        /** Indicates an exceptional shift. */\n+        double exShift;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/SchurTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class SchurTransformerTest {\n+\n+    private double[][] testSquare5 = {\n+            { 5, 4, 3, 2, 1 },\n+            { 1, 4, 0, 3, 3 },\n+            { 2, 0, 3, 0, 0 },\n+            { 3, 2, 1, 2, 5 },\n+            { 4, 2, 1, 4, 1 }\n+    };\n+\n+    private double[][] testSquare3 = {\n+            {  2, -1, 1 },\n+            { -1,  2, 1 },\n+            {  1, -1, 2 }\n+    };\n+\n+    // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html\n+    private double[][] testRandom = {\n+            {  0.680, -0.3300, -0.2700, -0.717, -0.687,  0.0259 },\n+            { -0.211,  0.5360,  0.0268,  0.214, -0.198,  0.6780 },\n+            {  0.566, -0.4440,  0.9040, -0.967, -0.740,  0.2250 },\n+            {  0.597,  0.1080,  0.8320, -0.514, -0.782, -0.4080 },\n+            {  0.823, -0.0452,  0.2710, -0.726,  0.998,  0.2750 },\n+            { -0.605,  0.2580,  0.4350,  0.608, -0.563,  0.0486 }\n+    };\n+\n+    @Test\n+    public void testNonSquare() {\n+        try {\n+            new SchurTransformer(MatrixUtils.createRealMatrix(new double[3][2]));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonSquareMatrixException ime) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAEqualPTPt() {\n+        checkAEqualPTPt(MatrixUtils.createRealMatrix(testSquare5));\n+        checkAEqualPTPt(MatrixUtils.createRealMatrix(testSquare3));\n+        checkAEqualPTPt(MatrixUtils.createRealMatrix(testRandom));\n+   }\n+\n+    private void checkAEqualPTPt(RealMatrix matrix) {\n+        SchurTransformer transformer = new SchurTransformer(matrix);\n+        RealMatrix p  = transformer.getP();\n+        RealMatrix t  = transformer.getT();\n+        RealMatrix pT = transformer.getPT();\n+        \n+        RealMatrix result = p.multiply(t).multiply(pT);\n+\n+        double norm = result.subtract(matrix).getNorm();\n+        Assert.assertEquals(0, norm, 4.0e-14);\n+    }\n+\n+    @Test\n+    public void testPOrthogonal() {\n+        checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getP());\n+        checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getP());\n+        checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getP());        \n+    }\n+\n+    @Test\n+    public void testPTOrthogonal() {\n+        checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getPT());\n+        checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getPT());\n+        checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getPT());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);\n+    }\n+\n+    @Test\n+    public void testSchurForm() {\n+        checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());\n+        checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());\n+        checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getT());\n+    }\n+\n+    private void checkSchurForm(final RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if (i > j + 1) {\n+                    Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                }\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private void checkMatricesValues(double[][] matrix, double[][] pRef, double[][] hRef) {\n+\n+        SchurTransformer transformer =\n+            new SchurTransformer(MatrixUtils.createRealMatrix(matrix));\n+\n+        // check values against known references\n+        RealMatrix p = transformer.getP();\n+        Assert.assertEquals(0, p.subtract(MatrixUtils.createRealMatrix(pRef)).getNorm(), 1.0e-14);\n+\n+        RealMatrix t = transformer.getT();\n+        Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(hRef)).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(p == transformer.getP());\n+        Assert.assertTrue(t == transformer.getT());\n+    }\n+}", "timestamp": 1336314762, "metainfo": ""}