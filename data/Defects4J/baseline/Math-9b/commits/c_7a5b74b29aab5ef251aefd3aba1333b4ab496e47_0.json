{"sha": "7a5b74b29aab5ef251aefd3aba1333b4ab496e47", "log": "Added converters for multivariate functions.  The converters allow to convert back and forth between the older and the newer differentiation API. They are considered temporary methods for version 3.1 and will be removed in 4.0 as only the new API will remain.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java\n package org.apache.commons.math3.analysis;\n \n import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableFunction;\n+import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction;\n import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction;\n import org.apache.commons.math3.analysis.function.Identity;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n \n     /** Convert a {@link DifferentiableUnivariateFunction} into a {@link UnivariateDifferentiableFunction}.\n      * <p>\n-     * Note that the converted function is able to handle {@link DerivativeStructure} with\n-     * <em>only</em> one parameter and up to order one. If the function is called with\n-     * more parameters or higher order, a {@link DimensionMismatchException} will be thrown.\n+     * Note that the converted function is able to handle {@link DerivativeStructure} up to order one.\n+     * If the function is called with higher order, a {@link NumberIsTooLargeException} will be thrown.\n      * </p>\n      * @param f function to convert\n      * @return converted function\n             }\n \n             /** {@inheritDoc}\n+             * @exception NumberIsTooLargeException if derivation order is greater than 1\n+             */\n+            public DerivativeStructure value(final DerivativeStructure t)\n+                throws NumberIsTooLargeException {\n+                switch (t.getOrder()) {\n+                    case 0 :\n+                        return new DerivativeStructure(t.getFreeParameters(), 0, f.value(t.getValue()));\n+                    case 1 : {\n+                        final int parameters = t.getFreeParameters();\n+                        final double[] derivatives = new double[parameters + 1];\n+                        derivatives[0] = f.value(t.getValue());\n+                        final double fPrime = f.derivative().value(t.getValue());\n+                        int[] orders = new int[parameters];\n+                        for (int i = 0; i < parameters; ++i) {\n+                            orders[i] = 1;\n+                            derivatives[i + 1] = fPrime * t.getPartialDerivative(orders);\n+                            orders[i] = 0;\n+                        }\n+                        return new DerivativeStructure(parameters, 1, derivatives);\n+                    }\n+                    default :\n+                        throw new NumberIsTooLargeException(t.getOrder(), 1, true);\n+                }\n+            }\n+\n+        };\n+    }\n+\n+    /** Convert a {@link MultivariateDifferentiableFunction} into a {@link DifferentiableMultivariateFunction}.\n+     * @param f function to convert\n+     * @return converted function\n+     * @deprecated this conversion method is temporary in version 3.1, as the {@link\n+     * DifferentiableMultivariateFunction} interface itself is deprecated\n+     */\n+    @Deprecated\n+    public static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f) {\n+        return new DifferentiableMultivariateFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double value(final double[] x) {\n+                return f.value(x);\n+            }\n+\n+            /** {@inheritDoc} */\n+            public MultivariateFunction partialDerivative(final int k) {\n+                return new MultivariateFunction() {\n+                    /** {@inheritDoc} */\n+                    public double value(final double[] x) {\n+\n+                        final int n = x.length;\n+\n+                        // delegate computation to underlying function\n+                        final DerivativeStructure[] dsX = new DerivativeStructure[n];\n+                        for (int i = 0; i < n; ++i) {\n+                            if (i == k) {\n+                                dsX[i] = new DerivativeStructure(1, 1, 0, x[i]);\n+                            } else {\n+                                dsX[i] = new DerivativeStructure(1, 1, x[i]);\n+                            }\n+                        }\n+                        final DerivativeStructure y = f.value(dsX);\n+\n+                        // extract partial derivative\n+                        return y.getPartialDerivative(1);\n+\n+                    }\n+                };\n+            }\n+\n+            public MultivariateVectorFunction gradient() {\n+                return new MultivariateVectorFunction() {\n+                    /** {@inheritDoc} */\n+                    public double[] value(final double[] x) {\n+\n+                        final int n = x.length;\n+\n+                        // delegate computation to underlying function\n+                        final DerivativeStructure[] dsX = new DerivativeStructure[n];\n+                        for (int i = 0; i < n; ++i) {\n+                            dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n+                        }\n+                        final DerivativeStructure y = f.value(dsX);\n+\n+                        // extract gradient\n+                        final double[] gradient = new double[n];\n+                        final int[] orders = new int[n];\n+                        for (int i = 0; i < n; ++i) {\n+                            orders[i]   = 1;\n+                            gradient[i] = y.getPartialDerivative(orders);\n+                            orders[i]   = 0;\n+                        }\n+\n+                        return gradient;\n+\n+                    }\n+                };\n+            }\n+\n+        };\n+    }\n+\n+    /** Convert a {@link DifferentiableMultivariateFunction} into a {@link MultivariateDifferentiableFunction}.\n+     * <p>\n+     * Note that the converted function is able to handle {@link DerivativeStructure} elements\n+     * that all have the same number of free parameters and order, and with order at most 1.\n+     * If the function is called with inconsistent numbers of free parameters or higher order, a\n+     * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n+     * </p>\n+     * @param f function to convert\n+     * @return converted function\n+     * @deprecated this conversion method is temporary in version 3.1, as the {@link\n+     * DifferentiableMultivariateFunction} interface itself is deprecated\n+     */\n+    @Deprecated\n+    public static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f) {\n+        return new MultivariateDifferentiableFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double value(final double[] x) {\n+                return f.value(x);\n+            }\n+\n+            /** {@inheritDoc}\n              * @exception DimensionMismatchException if number of parameters or derivation\n              * order are higher than 1\n              */\n-            public DerivativeStructure value(final DerivativeStructure t)\n-                throws DimensionMismatchException {\n-                if (t.getFreeParameters() != 1) {\n-                    throw new DimensionMismatchException(t.getFreeParameters(), 1);\n-                }\n-                if (t.getOrder() > 1) {\n-                    throw new DimensionMismatchException(t.getOrder(), 1);\n-                }\n-                return t.compose(new double[] {\n-                    f.value(t.getValue()),\n-                    f.derivative().value(t.getValue())\n-                });\n+            public DerivativeStructure value(final DerivativeStructure[] t)\n+                throws DimensionMismatchException, NumberIsTooLargeException {\n+\n+                // check parameters and orders limits\n+                final int parameters = t[0].getFreeParameters();\n+                final int order      = t[0].getOrder();\n+                final int n          = t.length;\n+                if (order > 1) {\n+                    throw new NumberIsTooLargeException(order, 1, true);\n+                }\n+\n+                // check all elements in the array are consistent\n+                for (int i = 0; i < n; ++i) {\n+                    if (t[i].getFreeParameters() != parameters) {\n+                        throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n+                    }\n+\n+                    if (t[i].getOrder() != order) {\n+                        throw new DimensionMismatchException(t[i].getOrder(), order);\n+                    }\n+                }\n+\n+                // delegate computation to underlying function\n+                final double[] point = new double[n];\n+                for (int i = 0; i < n; ++i) {\n+                    point[i] = t[i].getValue();\n+                }\n+                final double value      = f.value(point);\n+                final double[] gradient = f.gradient().value(point);\n+\n+                // merge value and gradient into one DerivativeStructure\n+                final double[] derivatives = new double[parameters + 1];\n+                derivatives[0] = value;\n+                final int[] orders = new int[parameters];\n+                for (int i = 0; i < parameters; ++i) {\n+                    orders[i] = 1;\n+                    for (int j = 0; j < n; ++j) {\n+                        derivatives[i + 1] += gradient[j] * t[j].getPartialDerivative(orders);\n+                    }\n+                    orders[i] = 0;\n+                }\n+\n+                return new DerivativeStructure(parameters, order, derivatives);\n+\n+            }\n+\n+        };\n+    }\n+\n+    /** Convert a {@link MultivariateDifferentiableVectorFunction} into a {@link DifferentiableMultivariateVectorFunction}.\n+     * @param f function to convert\n+     * @return converted function\n+     * @deprecated this conversion method is temporary in version 3.1, as the {@link\n+     * DifferentiableMultivariateVectorFunction} interface itself is deprecated\n+     */\n+    @Deprecated\n+    public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f) {\n+        return new DifferentiableMultivariateVectorFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double[] value(final double[] x) {\n+                return f.value(x);\n+            }\n+\n+            public MultivariateMatrixFunction jacobian() {\n+                return new MultivariateMatrixFunction() {\n+                    /** {@inheritDoc} */\n+                    public double[][] value(final double[] x) {\n+\n+                        final int n = x.length;\n+\n+                        // delegate computation to underlying function\n+                        final DerivativeStructure[] dsX = new DerivativeStructure[n];\n+                        for (int i = 0; i < n; ++i) {\n+                            dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n+                        }\n+                        final DerivativeStructure[] y = f.value(dsX);\n+\n+                        // extract Jacobian\n+                        final double[][] jacobian = new double[y.length][n];\n+                        final int[] orders = new int[n];\n+                        for (int i = 0; i < y.length; ++i) {\n+                            for (int j = 0; j < n; ++j) {\n+                                orders[j]      = 1;\n+                                jacobian[i][j] = y[i].getPartialDerivative(orders);\n+                                orders[j]      = 0;\n+                            }\n+                        }\n+\n+                        return jacobian;\n+\n+                    }\n+                };\n+            }\n+\n+        };\n+    }\n+\n+    /** Convert a {@link DifferentiableMultivariateVectorFunction} into a {@link MultivariateDifferentiableVectorFunction}.\n+     * <p>\n+     * Note that the converted function is able to handle {@link DerivativeStructure} elements\n+     * that all have the same number of free parameters and order, and with order at most 1.\n+     * If the function is called with inconsistent numbers of free parameters or higher order, a\n+     * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n+     * </p>\n+     * @param f function to convert\n+     * @return converted function\n+     * @deprecated this conversion method is temporary in version 3.1, as the {@link\n+     * DifferentiableMultivariateFunction} interface itself is deprecated\n+     */\n+    @Deprecated\n+    public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n+        return new MultivariateDifferentiableVectorFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double[] value(final double[] x) {\n+                return f.value(x);\n+            }\n+\n+            /** {@inheritDoc}\n+             * @exception DimensionMismatchException if number of parameters or derivation\n+             * order are higher than 1\n+             */\n+            public DerivativeStructure[] value(final DerivativeStructure[] t)\n+                throws DimensionMismatchException, NumberIsTooLargeException {\n+\n+                // check parameters and orders limits\n+                final int parameters = t[0].getFreeParameters();\n+                final int order      = t[0].getOrder();\n+                final int n          = t.length;\n+                if (order > 1) {\n+                    throw new NumberIsTooLargeException(order, 1, true);\n+                }\n+\n+                // check all elements in the array are consistent\n+                for (int i = 0; i < n; ++i) {\n+                    if (t[i].getFreeParameters() != parameters) {\n+                        throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n+                    }\n+\n+                    if (t[i].getOrder() != order) {\n+                        throw new DimensionMismatchException(t[i].getOrder(), order);\n+                    }\n+                }\n+\n+                // delegate computation to underlying function\n+                final double[] point = new double[n];\n+                for (int i = 0; i < n; ++i) {\n+                    point[i] = t[i].getValue();\n+                }\n+                final double[] value      = f.value(point);\n+                final double[][] jacobian = f.jacobian().value(point);\n+\n+                // merge value and Jacobian into a DerivativeStructure array\n+                final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n+                for (int k = 0; k < merged.length; ++k) {\n+                    final double[] derivatives = new double[parameters + 1];\n+                    derivatives[0] = value[k];\n+                    final int[] orders = new int[parameters];\n+                    for (int i = 0; i < parameters; ++i) {\n+                        orders[i] = 1;\n+                        for (int j = 0; j < n; ++j) {\n+                            derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n+                        }\n+                        orders[i] = 0;\n+                    }\n+                    merged[k] = new DerivativeStructure(parameters, order, derivatives);\n+                }\n+\n+                return merged;\n+\n             }\n \n         };\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n      * @exception DimensionMismatchException if the number of derivatives\n      * in the array is not equal to {@link #getOrder() order} + 1\n      */\n-    public DerivativeStructure compose(final double[] f) {\n+    public DerivativeStructure compose(final double ... f) {\n         if (f.length != getOrder() + 1) {\n             throw new DimensionMismatchException(f.length, getOrder() + 1);\n         }\n--- a/src/test/java/org/apache/commons/math3/analysis/FunctionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/FunctionUtilsTest.java\n package org.apache.commons.math3.analysis;\n \n import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableFunction;\n import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction;\n import org.apache.commons.math3.analysis.function.Add;\n import org.apache.commons.math3.analysis.function.Constant;\n             Assert.assertEquals(\"x = \" + x, FastMath.sin(x), actual[i], 0.0);\n         }\n     }\n+\n+    @Test\n+    @Deprecated\n+    public void testToDifferentiableUnivariateFunction() {\n+\n+        // Sin implements both UnivariateDifferentiableFunction and DifferentiableUnivariateFunction\n+        Sin sin = new Sin();\n+        DifferentiableUnivariateFunction converted = FunctionUtils.toDifferentiableUnivariateFunction(sin);\n+        for (double x = 0.1; x < 0.5; x += 0.01) {\n+            Assert.assertEquals(sin.value(x), converted.value(x), 1.0e-10);\n+            Assert.assertEquals(sin.derivative().value(x), converted.derivative().value(x), 1.0e-10);\n+        }\n+\n+    }\n+\n+    @Test\n+    @Deprecated\n+    public void testToUnivariateDifferential() {\n+\n+        // Sin implements both UnivariateDifferentiableFunction and DifferentiableUnivariateFunction\n+        Sin sin = new Sin();\n+        UnivariateDifferentiableFunction converted = FunctionUtils.toUnivariateDifferential(sin);\n+        for (double x = 0.1; x < 0.5; x += 0.01) {\n+            DerivativeStructure t = new DerivativeStructure(2, 1, x, 1.0, 2.0);\n+            Assert.assertEquals(sin.value(t).getValue(), converted.value(t).getValue(), 1.0e-10);\n+            Assert.assertEquals(sin.value(t).getPartialDerivative(1, 0),\n+                                converted.value(t).getPartialDerivative(1, 0),\n+                                1.0e-10);\n+            Assert.assertEquals(sin.value(t).getPartialDerivative(0, 1),\n+                                converted.value(t).getPartialDerivative(0, 1),\n+                                1.0e-10);\n+        }\n+\n+    }\n+\n+    @Test\n+    @Deprecated\n+    public void testToDifferentiableMultivariateFunction() {\n+\n+        MultivariateDifferentiableFunction hypot = new MultivariateDifferentiableFunction() {\n+            \n+            public double value(double[] point) {\n+                return FastMath.hypot(point[0], point[1]);\n+            }\n+            \n+            public DerivativeStructure value(DerivativeStructure[] point) {\n+                return DerivativeStructure.hypot(point[0], point[1]);\n+            }\n+        };\n+\n+        DifferentiableMultivariateFunction converted = FunctionUtils.toDifferentiableMultivariateFunction(hypot);\n+        for (double x = 0.1; x < 0.5; x += 0.01) {\n+            for (double y = 0.1; y < 0.5; y += 0.01) {\n+                double[] point = new double[] { x, y };\n+                Assert.assertEquals(hypot.value(point), converted.value(point), 1.0e-10);\n+                Assert.assertEquals(x / hypot.value(point), converted.gradient().value(point)[0], 1.0e-10);\n+                Assert.assertEquals(y / hypot.value(point), converted.gradient().value(point)[1], 1.0e-10);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    @Deprecated\n+    public void testToMultivariateDifferentiableFunction() {\n+\n+        DifferentiableMultivariateFunction hypot = new DifferentiableMultivariateFunction() {\n+            \n+            public double value(double[] point) {\n+                return FastMath.hypot(point[0], point[1]);\n+            }\n+\n+            public MultivariateFunction partialDerivative(final int k) {\n+                return new MultivariateFunction() {\n+                    public double value(double[] point) {\n+                        return point[k] / FastMath.hypot(point[0], point[1]);\n+                    }\n+                };\n+            }\n+\n+            public MultivariateVectorFunction gradient() {\n+                return new MultivariateVectorFunction() {\n+                    public double[] value(double[] point) {\n+                        final double h = FastMath.hypot(point[0], point[1]);\n+                        return new double[] { point[0] / h, point[1] / h };\n+                    }\n+                };\n+            }\n+            \n+        };\n+\n+        MultivariateDifferentiableFunction converted = FunctionUtils.toMultivariateDifferentiableFunction(hypot);\n+        for (double x = 0.1; x < 0.5; x += 0.01) {\n+            for (double y = 0.1; y < 0.5; y += 0.01) {\n+                DerivativeStructure[] t = new DerivativeStructure[] {\n+                    new DerivativeStructure(3, 1, x, 1.0, 2.0, 3.0 ),\n+                    new DerivativeStructure(3, 1, y, 4.0, 5.0, 6.0 )\n+                };\n+                DerivativeStructure h = DerivativeStructure.hypot(t[0], t[1]);\n+                Assert.assertEquals(h.getValue(), converted.value(t).getValue(), 1.0e-10);\n+                Assert.assertEquals(h.getPartialDerivative(1, 0, 0),\n+                                    converted.value(t).getPartialDerivative(1, 0, 0),\n+                                    1.0e-10);\n+                Assert.assertEquals(h.getPartialDerivative(0, 1, 0),\n+                                    converted.value(t).getPartialDerivative(0, 1, 0),\n+                                    1.0e-10);\n+                Assert.assertEquals(h.getPartialDerivative(0, 0, 1),\n+                                    converted.value(t).getPartialDerivative(0, 0, 1),\n+                                    1.0e-10);\n+            }\n+        }\n+    }\n+\n }", "timestamp": 1351107585, "metainfo": ""}