{"sha": "1ae19043a1f78a2661e6907bf9ac3ee1be82e0b0", "log": "added scalar multiply to the Complex class JIRA: MATH-277  ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n     }\n     \n     /**\n+     * Return the product of this complex number and the given scalar number.\n+     * <p>\n+     * Implements preliminary checks for NaN and infinity followed by\n+     * the definitional formula:\n+     * <pre><code>\n+     * c(a + bi) = (ca) + (cb)i\n+     * </code></pre>\n+     * </p>\n+     * <p>\n+     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n+     * NaN parts.\n+     * </p>\n+     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n+     * NaN parts and if either this or <code>rhs</code> has one or more\n+     * infinite parts (same result is returned regardless of the sign of the\n+     * components).\n+     * </p>\n+     * <p>\n+     * Returns finite values in components of the result per the\n+     * definitional formula in all remaining cases.\n+     *  </p>\n+     * \n+     * @param rhs the scalar number\n+     * @return the complex number product\n+     */\n+    public Complex multiply(double rhs) {\n+        if (isNaN() || Double.isNaN(rhs)) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n+            Double.isInfinite(rhs)) {\n+            // we don't use Complex.isInfinite() to avoid testing for NaN again\n+            return INF;\n+        }\n+        return createComplex(real * rhs, imaginary * rhs);\n+    }\n+    \n+    /**\n      * Return the additive inverse of this complex number.\n      * <p>\n      * Returns <code>Complex.NaN</code> if either real or imaginary\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n         w = negInfNegInf.multiply(oneNaN);\n         assertTrue(Double.isNaN(w.getReal()));\n         assertTrue(Double.isNaN(w.getImaginary()));  \n+    }\n+    \n+    public void testScalarMultiply() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double y = 2.0;\n+        Complex z = x.multiply(y);\n+        assertEquals(6.0, z.getReal(), 1.0e-5);\n+        assertEquals(8.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testScalarMultiplyNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.multiply(Double.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testScalarMultiplyInf() {\n+        Complex z = new Complex(1,1);\n+        Complex w = z.multiply(Double.POSITIVE_INFINITY);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n+\n+        w = z.multiply(Double.NEGATIVE_INFINITY);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n     }\n     \n     public void testNegate() {", "timestamp": 1246798393, "metainfo": ""}