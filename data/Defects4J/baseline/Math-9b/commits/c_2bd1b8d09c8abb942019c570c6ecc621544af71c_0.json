{"sha": "2bd1b8d09c8abb942019c570c6ecc621544af71c", "log": "In o.a.c.m3.SymmLQ.State, created accessors   - RealVector getRightHandSideVector(),   - RealVector getSolution(),   - double getNormOfResidual(), see MATH-761.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n         /** The value of beta[k+1] * M * P' * v[k+1]. */\n         private RealVector r2;\n \n+        /**\n+         * The value of the updated, preconditioned residual P * r. This value is\n+         * given by {@code min(}{@link #cgnorm}{@code , }{@link #lqnorm}{@code )}.\n+         */\n+        private double rnorm;\n+\n         /** Copy of the {@code shift} parameter. */\n         private final double shift;\n \n          * the value of xL[k-1] if {@code goodb} is {@code false}, (xL[k-1] -\n          * bstep[k-1] * v[1]) otherwise.\n          */\n-        private final RealVector x;\n+        private final RealVector xL;\n \n         /** The value of beta[k+1] * P' * v[k+1]. */\n         private RealVector y;\n             this.a = a;\n             this.minv = minv;\n             this.b = b;\n-            this.x = x;\n+            this.xL = x;\n             this.goodb = goodb;\n             this.shift = shift;\n             this.minvb = minv == null ? b : minv.operate(b);\n          * the convergence tests involve only cgnorm, so we're unlikely to stop\n          * at an LQ point, except if the iteration limit interferes.\n          *\n-         * @param xRefined the vector to be updated with the refined value of x\n-         */\n-        public void refine(final RealVector xRefined) {\n-            final int n = this.x.getDimension();\n+         * @param xC the vector to be updated with the refined value of xL\n+         */\n+        void moveToCG(final RealVector xC) {\n+            final int n = this.xL.getDimension();\n             if (lqnorm < cgnorm) {\n                 if (!goodb) {\n-                    xRefined.setSubVector(0, this.x);\n+                    xC.setSubVector(0, this.xL);\n                 } else {\n                     final double step = bstep / beta1;\n                     for (int i = 0; i < n; i++) {\n                         final double bi = minvb.getEntry(i);\n-                        final double xi = this.x.getEntry(i);\n-                        xRefined.setEntry(i, xi + step * bi);\n+                        final double xi = this.xL.getEntry(i);\n+                        xC.setEntry(i, xi + step * bi);\n                     }\n                 }\n             } else {\n                 // ynorm = FastMath.sqrt(ynorm2 + zbar * zbar);\n                 if (!goodb) {\n                     for (int i = 0; i < n; i++) {\n-                        final double xi = this.x.getEntry(i);\n+                        final double xi = this.xL.getEntry(i);\n                         final double wi = wbar.getEntry(i);\n-                        xRefined.setEntry(i, xi + zbar * wi);\n+                        xC.setEntry(i, xi + zbar * wi);\n                     }\n                 } else {\n                     for (int i = 0; i < n; i++) {\n-                        final double xi = this.x.getEntry(i);\n+                        final double xi = this.xL.getEntry(i);\n                         final double wi = wbar.getEntry(i);\n                         final double bi = minvb.getEntry(i);\n-                        xRefined.setEntry(i, xi + zbar * wi + step * bi);\n+                        xC.setEntry(i, xi + zbar * wi + step * bi);\n                     }\n                 }\n             }\n          * 1.\n          */\n         private void init() {\n-            this.x.set(0.);\n+            this.xL.set(0.);\n             /*\n              * Set up y for the first Lanczos vector. y and beta1 will be zero\n              * if b = 0.\n              */\n             final double zetaC = zeta * c;\n             final double zetaS = zeta * s;\n-            final int n = x.getDimension();\n+            final int n = xL.getDimension();\n             for (int i = 0; i < n; i++) {\n-                final double xi = x.getEntry(i);\n+                final double xi = xL.getEntry(i);\n                 final double vi = v.getEntry(i);\n                 final double wi = wbar.getEntry(i);\n-                x.setEntry(i, xi + wi * zetaC + vi * zetaS);\n+                xL.setEntry(i, xi + wi * zetaC + vi * zetaS);\n                 wbar.setEntry(i, wi * s - vi * c);\n             }\n             /*\n                  */\n                 throw new SingularOperatorException();\n             }\n+            rnorm = FastMath.min(cgnorm, lqnorm);\n             hasConverged = (cgnorm <= epsx) || (cgnorm <= epsr);\n         }\n \n          *\n          * @return {@code true} if convergence of the iterations has occured\n          */\n-        public boolean hasConverged() {\n+        boolean hasConverged() {\n             return hasConverged;\n         }\n \n          *\n          * @return the boolean value of {@code b == 0}\n          */\n-        public boolean bEqualsNullVector() {\n+        boolean bEqualsNullVector() {\n             return bIsNull;\n         }\n \n          *\n          * @return {@code true} if {@code beta < }{@link #MACH_PREC}\n          */\n-        public boolean betaEqualsZero() {\n+        boolean betaEqualsZero() {\n             return beta < MACH_PREC;\n+        }\n+\n+        /**\n+         * Returns the right-hand side vector.\n+         *\n+         * @return the right-hand side vector, b\n+         */\n+        RealVector getRightHandSideVector() {\n+            return b;\n+        }\n+\n+        /**\n+         * Returns the current estimate of the solution (LQ point).\n+         *\n+         * @return the solution, xL\n+         */\n+        RealVector getSolution() {\n+            return xL;\n+        }\n+\n+        /**\n+         * Returns the norm of the updated, preconditioned residual.\n+         *\n+         * @return the norm of the residual, ||P * r||\n+         */\n+        double getNormOfResidual() {\n+            return rnorm;\n         }\n     }\n \n         /** {@inheritDoc} */\n         @Override\n         public double getNormOfResidual() {\n-            return FastMath.min(state.cgnorm, state.lqnorm);\n+            return state.getNormOfResidual();\n         }\n \n         /** {@inheritDoc} */\n         @Override\n         public RealVector getRightHandSideVector() {\n-            return RealVector.unmodifiableRealVector(state.b);\n+            return RealVector.unmodifiableRealVector(state.getRightHandSideVector());\n         }\n \n         /** {@inheritDoc} */\n         @Override\n         public RealVector getSolution() {\n-            final int n = state.x.getDimension();\n-            final RealVector x = new ArrayRealVector(n);\n-            state.refine(x);\n+            final RealVector x = state.getSolution().copy();\n+            state.moveToCG(x);\n             return x;\n         }\n     }\n         manager.resetIterationCount();\n         manager.incrementIterationCount();\n \n-        final State state = new State(a, minv, b, x, goodb, shift, delta, check);\n+        final State state = new State(a, minv, b, x.copy(), goodb, shift, delta, check);\n+        /*\n+         * There is no need to create a new SymmLQEvent each time the state is\n+         * updated, as SymmLQEvent keeps a reference to the current state.\n+         */\n         final IterativeLinearSolverEvent event = new SymmLQEvent(this, state);\n         if (state.bEqualsNullVector()) {\n             /* If b = 0 exactly, stop with x = 0. */\n                 manager.fireIterationPerformedEvent(event);\n             } while (!state.hasConverged());\n         }\n-        state.refine(x);\n-        /*\n-         * The following two lines are a hack because state.x is now refined,\n-         * so further calls to state.refine() (via event.getSolution()) should\n-         * *not* return an altered value of state.x.\n-         */\n-        state.bstep = 0.;\n-        state.gammaZeta = 0.;\n+        state.moveToCG(x);\n         manager.fireTerminationEvent(event);\n         return x;\n     }\n--- a/src/test/java/org/apache/commons/math3/linear/SymmLQTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/SymmLQTest.java\n import java.util.Arrays;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.IterationEvent;\n import org.apache.commons.math3.util.IterationListener;\n             public void iterationPerformed(final IterationEvent e) {\n                 ++count[2];\n                 Assert.assertEquals(\"iteration performed\",\n-                    count[2], e.getIterations() - 1);\n+                                    count[2],\n+                                    e.getIterations() - 1);\n             }\n \n             public void iterationStarted(final IterationEvent e) {\n                 ++count[1];\n                 Assert.assertEquals(\"iteration started\",\n-                    count[1], e.getIterations() - 1);\n+                                    count[1],\n+                                    e.getIterations() - 1);\n             }\n \n             public void terminationPerformed(final IterationEvent e) {\n                 ++count[3];\n-                final IterativeLinearSolverEvent ilse = (IterativeLinearSolverEvent) e;\n+                final IterativeLinearSolverEvent ilse;\n+                ilse = (IterativeLinearSolverEvent) e;\n                 xFromListener.setSubVector(0, ilse.getSolution());\n             }\n         };\n             msg = String.format(\"column %d (finalization)\", j);\n             Assert.assertEquals(msg, 1, count[3]);\n             /*\n-             *  Check that solution is not \"over-refined\". When the last iteration has\n-             *  occurred, no further refinement should be performed.\n+             *  Check that solution is not \"over-refined\". When the last\n+             *  iteration has occurred, no further refinement should be\n+             *  performed.\n              */\n             for (int i = 0; i < n; i++){\n                 msg = String.format(\"row %d, column %d\", i, j);", "timestamp": 1332400524, "metainfo": ""}