{"sha": "ceb551bae178f85156a7d8d04e990894cadde611", "log": "MATH-689 Moved \"round\" methods over to class \"Precision\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n package org.apache.commons.math.util;\n \n-import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.MathArithmeticException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NotFiniteNumberException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n     }\n \n     /**\n-     * Round the given value to the specified number of decimal places. The\n-     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n-     *\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static double round(double x, int scale) {\n-        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n-    }\n-\n-    /**\n-     * <p>Round the given value to the specified number of decimal places. The\n-     * value is rounded using the given method which is any method defined in\n-     * {@link BigDecimal}.</p>\n-     *\n-     * <p>If {@code x} is infinite or NaN, then the value of {@code x} is\n-     * returned unchanged, regardless of the other parameters.</p>\n-     *\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @param roundingMethod the rounding method as defined in\n-     *        {@link BigDecimal}.\n-     * @return the rounded value.\n-     * @throws ArithmeticException if roundingMethod==ROUND_UNNECESSARY and the\n-     * specified scaling operation would require rounding.\n-     * @throws IllegalArgumentException if roundingMethod does not represent a\n-     * valid rounding mode.\n-     * @since 1.1\n-     */\n-    public static double round(double x, int scale, int roundingMethod) {\n-        try {\n-            return (new BigDecimal\n-                   (Double.toString(x))\n-                   .setScale(scale, roundingMethod))\n-                   .doubleValue();\n-        } catch (NumberFormatException ex) {\n-            if (Double.isInfinite(x)) {\n-                return x;\n-            } else {\n-                return Double.NaN;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Round the given value to the specified number of decimal places. The\n-     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n-     *\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static float round(float x, int scale) {\n-        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n-    }\n-\n-    /**\n-     * Round the given value to the specified number of decimal places. The\n-     * value is rounded using the given method which is any method defined in\n-     * {@link BigDecimal}.\n-     *\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @param roundingMethod the rounding method as defined in\n-     *        {@link BigDecimal}.\n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static float round(float x, int scale, int roundingMethod) {\n-        float sign = indicator(x);\n-        float factor = (float)FastMath.pow(10.0f, scale) * sign;\n-        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n-    }\n-\n-    /**\n-     * Round the given non-negative value to the \"nearest\" integer. Nearest is\n-     * determined by the rounding method specified. Rounding methods are defined\n-     * in {@link BigDecimal}.\n-     *\n-     * @param unscaled Value to round.\n-     * @param sign Sign of the original, scaled value.\n-     * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n-     * @return the rounded value.\n-     * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n-     * @since 1.1\n-     */\n-    private static double roundUnscaled(double unscaled,\n-                                        double sign,\n-                                        int roundingMethod) {\n-        switch (roundingMethod) {\n-        case BigDecimal.ROUND_CEILING :\n-            if (sign == -1) {\n-                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n-            } else {\n-                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n-            }\n-            break;\n-        case BigDecimal.ROUND_DOWN :\n-            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n-            break;\n-        case BigDecimal.ROUND_FLOOR :\n-            if (sign == -1) {\n-                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n-            } else {\n-                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n-            }\n-            break;\n-        case BigDecimal.ROUND_HALF_DOWN : {\n-            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n-            double fraction = unscaled - FastMath.floor(unscaled);\n-            if (fraction > 0.5) {\n-                unscaled = FastMath.ceil(unscaled);\n-            } else {\n-                unscaled = FastMath.floor(unscaled);\n-            }\n-            break;\n-        }\n-        case BigDecimal.ROUND_HALF_EVEN : {\n-            double fraction = unscaled - FastMath.floor(unscaled);\n-            if (fraction > 0.5) {\n-                unscaled = FastMath.ceil(unscaled);\n-            } else if (fraction < 0.5) {\n-                unscaled = FastMath.floor(unscaled);\n-            } else {\n-                // The following equality test is intentional and needed for rounding purposes\n-                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n-                    .floor(unscaled) / 2.0)) { // even\n-                    unscaled = FastMath.floor(unscaled);\n-                } else { // odd\n-                    unscaled = FastMath.ceil(unscaled);\n-                }\n-            }\n-            break;\n-        }\n-        case BigDecimal.ROUND_HALF_UP : {\n-            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n-            double fraction = unscaled - FastMath.floor(unscaled);\n-            if (fraction >= 0.5) {\n-                unscaled = FastMath.ceil(unscaled);\n-            } else {\n-                unscaled = FastMath.floor(unscaled);\n-            }\n-            break;\n-        }\n-        case BigDecimal.ROUND_UNNECESSARY :\n-            if (unscaled != FastMath.floor(unscaled)) {\n-                throw new MathArithmeticException();\n-            }\n-            break;\n-        case BigDecimal.ROUND_UP :\n-            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n-            break;\n-        default :\n-            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n-                                                   roundingMethod,\n-                                                   \"ROUND_CEILING\", BigDecimal.ROUND_CEILING,\n-                                                   \"ROUND_DOWN\", BigDecimal.ROUND_DOWN,\n-                                                   \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR,\n-                                                   \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN,\n-                                                   \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN,\n-                                                   \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP,\n-                                                   \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n-                                                   \"ROUND_UP\", BigDecimal.ROUND_UP);\n-        }\n-        return unscaled;\n-    }\n-\n-    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n      * for byte value {@code x}.\n      * <p>\n--- a/src/main/java/org/apache/commons/math/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math/util/Precision.java\n \n package org.apache.commons.math.util;\n \n+import java.math.BigDecimal;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n  * Utilities for comparing numbers.\n  *\n     public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n         return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n     }\n+\n+    /**\n+     * Rounds the given value to the specified number of decimal places.\n+     * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n+     *\n+     * @param x Value to round.\n+     * @param scale Number of digits to the right of the decimal point.\n+     * @return the rounded value.\n+     * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n+     */\n+    public static double round(double x, int scale) {\n+        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+    }\n+\n+    /**\n+     * Rounds the given value to the specified number of decimal places.\n+     * The value is rounded using the given method which is any method defined\n+     * in {@link BigDecimal}.\n+     * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n+     * returned unchanged, regardless of the other parameters.\n+     *\n+     * @param x Value to round.\n+     * @param scale Number of digits to the right of the decimal point.\n+     * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n+     * and the specified scaling operation would require rounding.\n+     * @throws IllegalArgumentException if {@code roundingMethod} does not\n+     * represent a valid rounding mode.\n+     * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n+     */\n+    public static double round(double x, int scale, int roundingMethod) {\n+        try {\n+            return (new BigDecimal\n+                   (Double.toString(x))\n+                   .setScale(scale, roundingMethod))\n+                   .doubleValue();\n+        } catch (NumberFormatException ex) {\n+            if (Double.isInfinite(x)) {\n+                return x;\n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Rounds the given value to the specified number of decimal places.\n+     * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n+     *\n+     * @param x Value to round.\n+     * @param scale Number of digits to the right of the decimal point.\n+     * @return the rounded value.\n+     * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n+     */\n+    public static float round(float x, int scale) {\n+        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+    }\n+\n+    /**\n+     * Rounds the given value to the specified number of decimal places.\n+     * The value is rounded using the given method which is any method defined\n+     * in {@link BigDecimal}.\n+     *\n+     * @param x Value to round.\n+     * @param scale Number of digits to the right of the decimal point.\n+     * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n+     */\n+    public static float round(float x, int scale, int roundingMethod) {\n+        final float sign = FastMath.copySign(1f, x);\n+        final float factor = (float) FastMath.pow(10.0f, scale) * sign;\n+        return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n+    }\n+\n+    /**\n+     * Rounds the given non-negative value to the \"nearest\" integer. Nearest is\n+     * determined by the rounding method specified. Rounding methods are defined\n+     * in {@link BigDecimal}.\n+     *\n+     * @param unscaled Value to round.\n+     * @param sign Sign of the original, scaled value.\n+     * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n+     * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n+     */\n+    private static double roundUnscaled(double unscaled,\n+                                        double sign,\n+                                        int roundingMethod) {\n+        switch (roundingMethod) {\n+        case BigDecimal.ROUND_CEILING :\n+            if (sign == -1) {\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            } else {\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+            }\n+            break;\n+        case BigDecimal.ROUND_DOWN :\n+            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            break;\n+        case BigDecimal.ROUND_FLOOR :\n+            if (sign == -1) {\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+            } else {\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            }\n+            break;\n+        case BigDecimal.ROUND_HALF_DOWN : {\n+            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            double fraction = unscaled - FastMath.floor(unscaled);\n+            if (fraction > 0.5) {\n+                unscaled = FastMath.ceil(unscaled);\n+            } else {\n+                unscaled = FastMath.floor(unscaled);\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_HALF_EVEN : {\n+            double fraction = unscaled - FastMath.floor(unscaled);\n+            if (fraction > 0.5) {\n+                unscaled = FastMath.ceil(unscaled);\n+            } else if (fraction < 0.5) {\n+                unscaled = FastMath.floor(unscaled);\n+            } else {\n+                // The following equality test is intentional and needed for rounding purposes\n+                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n+                    .floor(unscaled) / 2.0)) { // even\n+                    unscaled = FastMath.floor(unscaled);\n+                } else { // odd\n+                    unscaled = FastMath.ceil(unscaled);\n+                }\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_HALF_UP : {\n+            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            double fraction = unscaled - FastMath.floor(unscaled);\n+            if (fraction >= 0.5) {\n+                unscaled = FastMath.ceil(unscaled);\n+            } else {\n+                unscaled = FastMath.floor(unscaled);\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_UNNECESSARY :\n+            if (unscaled != FastMath.floor(unscaled)) {\n+                throw new MathArithmeticException();\n+            }\n+            break;\n+        case BigDecimal.ROUND_UP :\n+            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            break;\n+        default :\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n+                                                   roundingMethod,\n+                                                   \"ROUND_CEILING\", BigDecimal.ROUND_CEILING,\n+                                                   \"ROUND_DOWN\", BigDecimal.ROUND_DOWN,\n+                                                   \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR,\n+                                                   \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN,\n+                                                   \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN,\n+                                                   \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP,\n+                                                   \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n+                                                   \"ROUND_UP\", BigDecimal.ROUND_UP);\n+        }\n+        return unscaled;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n     }\n \n     @Test\n-    public void testRoundDouble() {\n-        double x = 1.234567890;\n-        Assert.assertEquals(1.23, MathUtils.round(x, 2), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(x, 3), 0.0);\n-        Assert.assertEquals(1.2346, MathUtils.round(x, 4), 0.0);\n-\n-        // JIRA MATH-151\n-        Assert.assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);\n-        Assert.assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        double xx = 39.0;\n-        xx = xx + 245d / 1000d;\n-        Assert.assertEquals(39.25, MathUtils.round(xx, 2), 0.0);\n-\n-        // BZ 35904\n-        Assert.assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);\n-        Assert.assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);\n-        Assert.assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);\n-        Assert.assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);\n-        Assert.assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);\n-        Assert.assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);\n-        Assert.assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);\n-        Assert.assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);\n-        Assert.assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);\n-\n-        Assert.assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-\n-        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-\n-        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-\n-        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-\n-        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-\n-        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-\n-        Assert.assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n-        Assert.assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n-\n-        try {\n-            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n-            Assert.fail();\n-        } catch (ArithmeticException ex) {\n-            // expected\n-        }\n-\n-        Assert.assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n-\n-        try {\n-            MathUtils.round(1.234, 2, 1923);\n-            Assert.fail();\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-        // MATH-151\n-        Assert.assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-\n-        // special values\n-        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);\n-        Assert.assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n-    }\n-\n-    @Test\n-    public void testRoundFloat() {\n-        float x = 1.234567890f;\n-        Assert.assertEquals(1.23f, MathUtils.round(x, 2), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(x, 3), 0.0);\n-        Assert.assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);\n-\n-        // BZ 35904\n-        Assert.assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);\n-        Assert.assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);\n-        Assert.assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);\n-        Assert.assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);\n-        Assert.assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);\n-        Assert.assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);\n-        Assert.assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);\n-\n-        Assert.assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        Assert.assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-\n-        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        Assert.assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-\n-        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-\n-        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        Assert.assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-\n-        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        Assert.assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-\n-        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        Assert.assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-\n-        Assert.assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n-        Assert.assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n-\n-        try {\n-            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n-            Assert.fail();\n-        } catch (MathArithmeticException ex) {\n-            // success\n-        }\n-\n-        Assert.assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n-        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n-\n-        try {\n-            MathUtils.round(1.234f, 2, 1923);\n-            Assert.fail();\n-        } catch (MathIllegalArgumentException ex) {\n-            // success\n-        }\n-\n-        // special values\n-        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);\n-        Assert.assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);\n-        Assert.assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n-        Assert.assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n-    }\n-\n-    @Test\n     public void testSignByte() {\n         Assert.assertEquals((byte) 1, MathUtils.sign((byte) 2));\n         Assert.assertEquals((byte) 0, MathUtils.sign((byte) 0));\n--- a/src/test/java/org/apache/commons/math/util/PrecisionTest.java\n+++ b/src/test/java/org/apache/commons/math/util/PrecisionTest.java\n  * governing permissions and limitations under the License.\n  */\n package org.apache.commons.math.util;\n+\n+import java.math.BigDecimal;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.TestUtils;\n \n import org.junit.Assert;\n import org.junit.Test;\n \n         Assert.assertEquals(+1, Precision.compareTo(Double.MAX_VALUE, Double.NaN, Integer.MAX_VALUE));\n         Assert.assertEquals(+1, Precision.compareTo(Double.NaN, Double.MAX_VALUE, Integer.MAX_VALUE));\n-\n+    }\n+\n+    @Test\n+    public void testRoundDouble() {\n+        double x = 1.234567890;\n+        Assert.assertEquals(1.23, Precision.round(x, 2), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(x, 3), 0.0);\n+        Assert.assertEquals(1.2346, Precision.round(x, 4), 0.0);\n+\n+        // JIRA MATH-151\n+        Assert.assertEquals(39.25, Precision.round(39.245, 2), 0.0);\n+        Assert.assertEquals(39.24, Precision.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        double xx = 39.0;\n+        xx = xx + 245d / 1000d;\n+        Assert.assertEquals(39.25, Precision.round(xx, 2), 0.0);\n+\n+        // BZ 35904\n+        Assert.assertEquals(30.1d, Precision.round(30.095d, 2), 0.0d);\n+        Assert.assertEquals(30.1d, Precision.round(30.095d, 1), 0.0d);\n+        Assert.assertEquals(33.1d, Precision.round(33.095d, 1), 0.0d);\n+        Assert.assertEquals(33.1d, Precision.round(33.095d, 2), 0.0d);\n+        Assert.assertEquals(50.09d, Precision.round(50.085d, 2), 0.0d);\n+        Assert.assertEquals(50.19d, Precision.round(50.185d, 2), 0.0d);\n+        Assert.assertEquals(50.01d, Precision.round(50.005d, 2), 0.0d);\n+        Assert.assertEquals(30.01d, Precision.round(30.005d, 2), 0.0d);\n+        Assert.assertEquals(30.65d, Precision.round(30.645d, 2), 0.0d);\n+\n+        Assert.assertEquals(1.24, Precision.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.234, Precision.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.2345, Precision.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.234, Precision.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.2345, Precision.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.234, Precision.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.2345, Precision.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.234, Precision.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.2345, Precision.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.24, Precision.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+\n+        Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.234, Precision.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.234, Precision.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.234, Precision.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.234, Precision.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.236, Precision.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.236, Precision.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+\n+        Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235, Precision.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        Assert.assertEquals(-1.23, Precision.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        Assert.assertEquals(1.23, Precision.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+\n+        try {\n+            Precision.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n+            Assert.fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+\n+        Assert.assertEquals(1.24, Precision.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.24, Precision.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+\n+        try {\n+            Precision.round(1.234, 2, 1923);\n+            Assert.fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        // MATH-151\n+        Assert.assertEquals(39.25, Precision.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        // special values\n+        TestUtils.assertEquals(Double.NaN, Precision.round(Double.NaN, 2), 0.0);\n+        Assert.assertEquals(0.0, Precision.round(0.0, 2), 0.0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, Precision.round(Double.POSITIVE_INFINITY, 2), 0.0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, Precision.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n+    }\n+\n+    @Test\n+    public void testRoundFloat() {\n+        float x = 1.234567890f;\n+        Assert.assertEquals(1.23f, Precision.round(x, 2), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(x, 3), 0.0);\n+        Assert.assertEquals(1.2346f, Precision.round(x, 4), 0.0);\n+\n+        // BZ 35904\n+        Assert.assertEquals(30.1f, Precision.round(30.095f, 2), 0.0f);\n+        Assert.assertEquals(30.1f, Precision.round(30.095f, 1), 0.0f);\n+        Assert.assertEquals(50.09f, Precision.round(50.085f, 2), 0.0f);\n+        Assert.assertEquals(50.19f, Precision.round(50.185f, 2), 0.0f);\n+        Assert.assertEquals(50.01f, Precision.round(50.005f, 2), 0.0f);\n+        Assert.assertEquals(30.01f, Precision.round(30.005f, 2), 0.0f);\n+        Assert.assertEquals(30.65f, Precision.round(30.645f, 2), 0.0f);\n+\n+        Assert.assertEquals(1.24f, Precision.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.234f, Precision.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.2345f, Precision.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.234f, Precision.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.2345f, Precision.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.234f, Precision.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.2345f, Precision.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.234f, Precision.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.2345f, Precision.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.24f, Precision.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+\n+        Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.234f, Precision.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.234f, Precision.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.234f, Precision.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.234f, Precision.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.236f, Precision.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.236f, Precision.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+\n+        Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235f, Precision.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        Assert.assertEquals(-1.23f, Precision.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        Assert.assertEquals(1.23f, Precision.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+\n+        try {\n+            Precision.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n+            Assert.fail();\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+\n+        Assert.assertEquals(1.24f, Precision.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.24f, Precision.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+\n+        try {\n+            Precision.round(1.234f, 2, 1923);\n+            Assert.fail();\n+        } catch (MathIllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        // special values\n+        TestUtils.assertEquals(Float.NaN, Precision.round(Float.NaN, 2), 0.0f);\n+        Assert.assertEquals(0.0f, Precision.round(0.0f, 2), 0.0f);\n+        Assert.assertEquals(Float.POSITIVE_INFINITY, Precision.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n+        Assert.assertEquals(Float.NEGATIVE_INFINITY, Precision.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n     }\n }", "timestamp": 1319577406, "metainfo": ""}