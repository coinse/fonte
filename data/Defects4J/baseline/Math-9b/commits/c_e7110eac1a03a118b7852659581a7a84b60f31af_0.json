{"sha": "e7110eac1a03a118b7852659581a7a84b60f31af", "log": "Simplified integration end handling using the same method as other integrators (based on a dedicated event handler)  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n     }\n     interpolator.storeTime(t0);\n \n-    stepStart  = t0;\n+    // set up integration control objects\n+    stepStart         = t0;\n     double  hNew      = 0;\n     boolean firstTime = true;\n-    boolean lastStep;\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n-    do {\n+    CombinedEventsManager manager = addEndTimeChecker(t, eventsHandlersManager);\n+    boolean lastStep = false;\n+\n+    // main integration loop\n+    while (!lastStep) {\n \n       interpolator.shift();\n \n \n         stepSize = hNew;\n \n-        // step adjustment near bounds\n-        if ((forward && (stepStart + stepSize > t)) ||\n-            ((! forward) && (stepStart + stepSize < t))) {\n-          stepSize = t - stepStart;\n-        }\n-\n         // next stages\n         for (int k = 1; k < stages; ++k) {\n \n         error = estimateError(yDotK, y, yTmp, stepSize);\n         if (error <= 1.0) {\n \n-          // Discrete events handling\n+          // discrete events handling\n           interpolator.storeTime(stepStart + stepSize);\n-          if (eventsHandlersManager.evaluateStep(interpolator)) {\n+          if (manager.evaluateStep(interpolator)) {\n             // reject the step to match exactly the next switch time\n-            hNew = eventsHandlersManager.getEventTime() - stepStart;\n+            hNew = manager.getEventTime() - stepStart;\n           } else {\n             // accept the step\n             loop = false;\n       // the step has been accepted\n       final double nextStep = stepStart + stepSize;\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      eventsHandlersManager.stepAccepted(nextStep, y);\n-      if (eventsHandlersManager.stop()) {\n-        lastStep = true;\n-      } else {\n-        lastStep = forward ? (nextStep >= t) : (nextStep <= t);\n-      }\n+      manager.stepAccepted(nextStep, y);\n+      lastStep = manager.stop();\n \n       // provide the step data to the step handler\n       interpolator.storeTime(nextStep);\n         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n       }\n \n-      if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n+      if (manager.reset(stepStart, y) && ! lastStep) {\n         // some event handler has triggered changes that\n         // invalidate the derivatives, we need to recompute them\n         equations.computeDerivatives(stepStart, y, yDotK[0]);\n         hNew = filterStep(scaledH, nextIsLast);\n       }\n \n-    } while (! lastStep);\n+    }\n \n     final double stopTime = stepStart;\n     resetInternalState();", "timestamp": 1215699733, "metainfo": ""}