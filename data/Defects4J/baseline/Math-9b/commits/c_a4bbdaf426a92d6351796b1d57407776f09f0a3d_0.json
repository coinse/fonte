{"sha": "a4bbdaf426a92d6351796b1d57407776f09f0a3d", "log": "Converted tests to Junit4.  There is one thing remaining: the retry feature in RetryTestCase has been disabled temporarily. We need to find some way to implement it using Junit 4 API.  JIRA: MATH-423  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n \n package org.apache.commons.math;\n \n-import junit.framework.TestCase;\n \n import java.util.Locale;\n \n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class ConvergenceExceptionTest extends TestCase {\n+public class ConvergenceExceptionTest {\n \n+    @Test\n     public void testConstructor(){\n         ConvergenceException ex = new ConvergenceException();\n-        assertNull(ex.getCause());\n-        assertNotNull(ex.getMessage());\n-        assertNotNull(ex.getMessage(Locale.FRENCH));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+        Assert.assertNull(ex.getCause());\n+        Assert.assertNotNull(ex.getMessage());\n+        Assert.assertNotNull(ex.getMessage(Locale.FRENCH));\n+        Assert.assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n \n+    @Test\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         ConvergenceException ex = new ConvergenceException(cause);\n-        assertEquals(cause, ex.getCause());\n+        Assert.assertEquals(cause, ex.getCause());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n \n package org.apache.commons.math;\n \n-import junit.framework.TestCase;\n \n import java.util.Locale;\n \n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class MathConfigurationExceptionTest extends TestCase {\n+public class MathConfigurationExceptionTest {\n \n+    @Test\n     public void testConstructor(){\n         MathConfigurationException ex = new MathConfigurationException();\n-        assertNull(ex.getCause());\n-        assertEquals(\"\", ex.getMessage());\n-        assertEquals(\"\", ex.getMessage(Locale.FRENCH));\n+        Assert.assertNull(ex.getCause());\n+        Assert.assertEquals(\"\", ex.getMessage());\n+        Assert.assertEquals(\"\", ex.getMessage(Locale.FRENCH));\n     }\n \n+    @Test\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathConfigurationException ex = new MathConfigurationException(cause);\n-        assertEquals(cause, ex.getCause());\n+        Assert.assertEquals(cause, ex.getCause());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathExceptionTest.java\n \n package org.apache.commons.math;\n \n-import junit.framework.TestCase;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n \n import org.apache.commons.math.exception.util.DummyLocalizable;\n import org.apache.commons.math.exception.util.Localizable;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class MathExceptionTest extends TestCase {\n+public class MathExceptionTest {\n \n+    @Test\n     public void testConstructor(){\n         MathException ex = new MathException();\n-        assertNull(ex.getCause());\n-        assertEquals(\"\", ex.getMessage());\n-        assertEquals(\"\", ex.getMessage(Locale.FRENCH));\n+        Assert.assertNull(ex.getCause());\n+        Assert.assertEquals(\"\", ex.getMessage());\n+        Assert.assertEquals(\"\", ex.getMessage(Locale.FRENCH));\n     }\n \n+    @Test\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathException ex = new MathException(cause);\n-        assertEquals(cause, ex.getCause());\n+        Assert.assertEquals(cause, ex.getCause());\n     }\n \n     /**\n      * Tests the printStackTrace() operation.\n      */\n+    @Test\n     public void testPrintStackTrace() {\n         Localizable outMsg = new DummyLocalizable(\"outer message\");\n         Localizable inMsg = new DummyLocalizable(\"inner message\");\n         String outerMsg = \"org.apache.commons.math.MathException: outer message\";\n         String innerMsg = \"Caused by: \" +\n         \"org.apache.commons.math.MathConfigurationException: inner message\";\n-        assertTrue(stack.startsWith(outerMsg));\n-        assertTrue(stack.indexOf(innerMsg) > 0);\n+        Assert.assertTrue(stack.startsWith(outerMsg));\n+        Assert.assertTrue(stack.indexOf(innerMsg) > 0);\n \n         PrintWriter pw = new PrintWriter(ps, true);\n         ex.printStackTrace(pw);\n         stack = baos.toString();\n-        assertTrue(stack.startsWith(outerMsg));\n-        assertTrue(stack.indexOf(innerMsg) > 0);\n+        Assert.assertTrue(stack.startsWith(outerMsg));\n+        Assert.assertTrue(stack.indexOf(innerMsg) > 0);\n     }\n \n     /**\n      * Test serialization\n      */\n+    @Test\n     public void testSerialization() {\n         Localizable outMsg = new DummyLocalizable(\"outer message\");\n         Localizable inMsg = new DummyLocalizable(\"inner message\");\n         }\n \n         if (jdkSupportsNesting) {\n-            assertEquals(stack, stack2);\n+            Assert.assertEquals(stack, stack2);\n         } else {\n-            assertTrue(stack2.indexOf(inMsg.getSourceString()) != -1);\n-            assertTrue(stack2.indexOf(\"MathConfigurationException\") != -1);\n+            Assert.assertTrue(stack2.indexOf(inMsg.getSourceString()) != -1);\n+            Assert.assertTrue(stack2.indexOf(\"MathConfigurationException\") != -1);\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/RetryTestCase.java\n+++ b/src/test/java/org/apache/commons/math/RetryTestCase.java\n \n package org.apache.commons.math;\n \n-import junit.framework.AssertionFailedError;\n-import junit.framework.TestCase;\n \n /**\n- * A TestCase that retries tests when assertions fail.\n- * <p>\n- * If one or more tests throw an AssertionFailedError, all tests are\n- * repeated one time.\n- * <p>\n- * Errors or exceptions other than AssertionFailedError do not lead to retries.\n- *\n+ * A Test case that retries tests when assertions fail.\n  * @version $Revision$ $Date$\n  */\n-public abstract class RetryTestCase extends TestCase {\n+public abstract class RetryTestCase {\n \n-    public RetryTestCase() {\n-        super();\n-    }\n+    // TODO implement retry policy using Junit 4  API\n \n-    public RetryTestCase(String arg0) {\n-        super(arg0);\n-    }\n-\n-    /**\n-     *  Override runTest() to catch AssertionFailedError and retry\n-     */\n-    @Override\n-    protected void runTest() throws Throwable {\n-        try {\n-            super.runTest();\n-        } catch (AssertionFailedError err) {\n-            // System.out.println(\"Retrying \" + this.getName());\n-            super.runTest();\n-        }\n-    }\n+    //    /**\n+//     *  Override runTest() to catch AssertionFailedError and retry\n+//     */\n+//    @Override\n+//    protected void runTest() throws Throwable {\n+//        try {\n+//            super.runTest();\n+//        } catch (AssertionFailedError err) {\n+//            // System.out.println(\"Retrying \" + this.getName());\n+//            super.runTest();\n+//        }\n+//    }\n \n }\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n import java.io.ObjectOutputStream;\n import java.text.DecimalFormat;\n \n-import junit.framework.Assert;\n-import junit.framework.AssertionFailedError;\n \n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.complex.ComplexFormat;\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n \n /**\n  * @version $Revision$ $Date$\n      * infinities of the same sign.\n      */\n     public static void assertEquals(double expected, double actual, double delta) {\n-        assertEquals(null, expected, actual, delta);\n+        Assert.assertEquals(null, expected, actual, delta);\n     }\n \n     /**\n      * both NaN or infinities of same sign, or identical floating point values.\n      */\n     public static void assertSame(double expected, double actual) {\n-     assertEquals(expected, actual, 0);\n+     Assert.assertEquals(expected, actual, 0);\n     }\n \n     /**\n      * differ by at most delta.  Also ensures that NaN / infinite components match.\n      */\n     public static void assertEquals(Complex expected, Complex actual, double delta) {\n-        assertEquals(expected.getReal(), actual.getReal(), delta);\n-        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);\n+        Assert.assertEquals(expected.getReal(), actual.getReal(), delta);\n+        Assert.assertEquals(expected.getImaginary(), actual.getImaginary(), delta);\n     }\n \n     /**\n      */\n     public static void assertContains(String msg, Complex[] values,\n                                       Complex z, double epsilon) {\n-        int i = 0;\n-        boolean found = false;\n-        while (!found && i < values.length) {\n-            try {\n-                assertEquals(values[i], z, epsilon);\n-                found = true;\n-            } catch (AssertionFailedError er) {\n-                // no match\n-            }\n-            i++;\n-        }\n-        if (!found) {\n-            Assert.fail(msg +\n-                        \" Unable to find \" + (new ComplexFormat()).format(z));\n-        }\n+        for (Complex value : values) {\n+            if (MathUtils.equals(value.getReal(), z.getReal(), epsilon) &&\n+                MathUtils.equals(value.getImaginary(), z.getImaginary(), epsilon)) {\n+                return;\n+            }\n+        }\n+        Assert.fail(msg + \" Unable to find \" + (new ComplexFormat()).format(z));\n     }\n \n     /**\n      */\n     public static void assertContains(String msg, double[] values,\n             double x, double epsilon) {\n-        int i = 0;\n-        boolean found = false;\n-        while (!found && i < values.length) {\n-            try {\n-                assertEquals(values[i], x, epsilon);\n-                found = true;\n-            } catch (AssertionFailedError er) {\n-                // no match\n-            }\n-            i++;\n-        }\n-        if (!found) {\n-            Assert.fail(msg + \" Unable to find\" + x);\n-        }\n+        for (double value : values) {\n+            if (MathUtils.equals(value, x, epsilon)) {\n+                return;\n+            }\n+        }\n+        Assert.fail(msg + \" Unable to find \" + x);\n     }\n \n     /**\n     }\n \n     /** verifies that two matrices are close (1-norm) */\n-    public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed,\n-        double tolerance) {\n+    public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed, double tolerance) {\n \n         Assert.assertNotNull(msg + \"\\nObserved should not be null\",observed);\n \n     }\n \n     /** verifies that two arrays are close (sup norm) */\n-    public static void assertEquals(String msg, double[] expected, double[] observed,\n-        double tolerance) {\n+    public static void assertEquals(String msg, double[] expected, double[] observed, double tolerance) {\n         StringBuilder out = new StringBuilder(msg);\n         if (expected.length != observed.length) {\n             out.append(\"\\n Arrays not same length. \\n\");\n         }\n         boolean failure = false;\n         for (int i=0; i < expected.length; i++) {\n-            try {\n-                assertEquals(expected[i], observed[i], tolerance);\n-            } catch (AssertionFailedError ex) {\n+            if (!MathUtils.equalsIncludingNaN(expected[i], observed[i], tolerance)) {\n                 failure = true;\n                 out.append(\"\\n Elements at index \");\n                 out.append(i);\n      */\n     public static void assertChiSquareAccept(String[] valueLabels, double[] expected, long[] observed, double alpha) throws Exception {\n         ChiSquareTest chiSquareTest = new ChiSquareTestImpl();\n-        try {\n-            // Fail if we can reject null hypothesis that distributions are the same\n-            Assert.assertFalse(chiSquareTest.chiSquareTest(expected, observed, alpha));\n-        } catch (AssertionFailedError ex) {\n+\n+        // Fail if we can reject null hypothesis that distributions are the same\n+        if (chiSquareTest.chiSquareTest(expected, observed, alpha)) {\n             StringBuilder msgBuffer = new StringBuilder();\n             DecimalFormat df = new DecimalFormat(\"#.##\");\n             msgBuffer.append(\"Chisquare test failed\");\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.*;\n \n-public class LegendreGaussIntegratorTest\n-extends TestCase {\n+public class LegendreGaussIntegratorTest {\n \n-    public LegendreGaussIntegratorTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testSinFunction() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(5, 64);\n         tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n                              FastMath.abs(expected * integrator.getRelativeAccuracy()));\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n                 FastMath.abs(expected * integrator.getRelativeAccuracy()));\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n+    @Test\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);\n \n         min = 0; max = 1; expected = -1.0/48;\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, 1.0e-16);\n+        Assert.assertEquals(expected, result, 1.0e-16);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, 1.0e-16);\n+        Assert.assertEquals(expected, result, 1.0e-16);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, 1.0e-16);\n+        Assert.assertEquals(expected, result, 1.0e-16);\n     }\n \n+    @Test\n     public void testExactIntegration()\n         throws ConvergenceException, MathUserException {\n         Random random = new Random(86343623467878363l);\n                     PolynomialFunction p = new PolynomialFunction(coeff);\n                     double result    = integrator.integrate(p, -5.0, 15.0);\n                     double reference = exactIntegration(p, -5.0, 15.0);\n-                    assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));\n+                    Assert.assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));\n                 }\n             }\n \n--- a/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n- * Testcase for Romberg integrator.\n+ * Test case for Romberg integrator.\n  * <p>\n  * Romberg algorithm is very fast for good behavior integrand. Test runs\n  * show that for a default relative accuracy of 1E-6, it generally takes\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class RombergIntegratorTest extends TestCase {\n+public final class RombergIntegratorTest {\n \n     /**\n      * Test of integrator for the sine function.\n      */\n+    @Test\n     public void testSinFunction() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new RombergIntegrator();\n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of integrator for the quintic function.\n      */\n+    @Test\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new RombergIntegrator();\n         min = 0; max = 1; expected = -1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the integrator.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new RombergIntegrator();\n         try {\n             // bad interval\n             integrator.integrate(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n             integrator.setMinimalIterationCount(5);\n             integrator.setMaximalIterationCount(4);\n             integrator.integrate(f, -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n             integrator.setMinimalIterationCount(10);\n             integrator.setMaximalIterationCount(50);\n             integrator.integrate(f, -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n- * Testcase for Simpson integrator.\n+ * Test case for Simpson integrator.\n  * <p>\n  * Test runs show that for a default relative accuracy of 1E-6, it\n  * generally takes 5 to 10 iterations for the integral to converge.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class SimpsonIntegratorTest extends TestCase {\n+public final class SimpsonIntegratorTest {\n \n     /**\n      * Test of integrator for the sine function.\n      */\n+    @Test\n     public void testSinFunction() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of integrator for the quintic function.\n      */\n+    @Test\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n         min = 0; max = 1; expected = -1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the integrator.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n         try {\n             // bad interval\n             integrator.integrate(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n             integrator.setMinimalIterationCount(5);\n             integrator.setMaximalIterationCount(4);\n             integrator.integrate(f, -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n             integrator.setMinimalIterationCount(10);\n             integrator.setMaximalIterationCount(99);\n             integrator.integrate(f, -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n- * Testcase for trapezoid integrator.\n+ * Test case for trapezoid integrator.\n  * <p>\n  * Test runs show that for a default relative accuracy of 1E-6, it\n  * generally takes 10 to 15 iterations for the integral to converge.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class TrapezoidIntegratorTest extends TestCase {\n+public final class TrapezoidIntegratorTest {\n \n     /**\n      * Test of integrator for the sine function.\n      */\n+    @Test\n     public void testSinFunction() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n         min = 0; max = FastMath.PI; expected = 2;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -FastMath.PI/3; max = 0; expected = -0.5;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of integrator for the quintic function.\n      */\n+    @Test\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n         min = 0; max = 1; expected = -1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n         tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the integrator.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n         try {\n             // bad interval\n             integrator.integrate(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n             integrator.setMinimalIterationCount(5);\n             integrator.setMaximalIterationCount(4);\n             integrator.integrate(f, -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n             integrator.setMinimalIterationCount(10);\n             integrator.setMaximalIterationCount(99);\n             integrator.integrate(f, -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for the bicubic function.\n+ * Test case for the bicubic function.\n  * \n  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n  */\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for the bicubic interpolator.\n+ * Test case for the bicubic interpolator.\n  * \n  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n  */\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n- * Testcase for Divided Difference interpolator.\n+ * Test case for Divided Difference interpolator.\n  * <p>\n  * The error of polynomial interpolation is\n  *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class DividedDifferenceInterpolatorTest extends TestCase {\n+public final class DividedDifferenceInterpolatorTest {\n \n     /**\n      * Test of interpolator for the sine function.\n      * <p>\n      * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n      */\n+    @Test\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n \n         z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * <p>\n      * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n      */\n+    @Test\n     public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n \n         z = 0.0; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 0.5; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = -0.5; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the interpolator.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n \n             double y[] = { 0.0, 4.0, 4.0, 2.5 };\n             UnivariateRealFunction p = interpolator.interpolate(x, y);\n             p.value(0.0);\n-            fail(\"Expecting NonMonotonousSequenceException - bad abscissas array\");\n+            Assert.fail(\"Expecting NonMonotonousSequenceException - bad abscissas array\");\n         } catch (NonMonotonousSequenceException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for the \"microsphere projection\" interpolator.\n+ * Test case for the \"microsphere projection\" interpolator.\n  *\n  * @version $Revision$ $Date$\n  */\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n- * Testcase for Neville interpolator.\n+ * Test case for Neville interpolator.\n  * <p>\n  * The error of polynomial interpolation is\n  *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class NevilleInterpolatorTest extends TestCase {\n+public final class NevilleInterpolatorTest {\n \n     /**\n      * Test of interpolator for the sine function.\n      * <p>\n      * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n      */\n+    @Test\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n \n         z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * <p>\n      * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n      */\n+    @Test\n     public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n \n         z = 0.0; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 0.5; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = -0.5; expected = f.value(z); result = p.value(z);\n         tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the interpolator.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n \n             double y[] = { 0.0, 4.0, 4.0, 2.5 };\n             UnivariateRealFunction p = interpolator.interpolate(x, y);\n             p.value(0.0);\n-            fail(\"Expecting NonMonotonousSequenceException - bad abscissas array\");\n+            Assert.fail(\"Expecting NonMonotonousSequenceException - bad abscissas array\");\n         } catch (NonMonotonousSequenceException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for the smoothing bicubic interpolator.\n+ * Test case for the smoothing bicubic interpolator.\n  * \n  * @version $Revision$ $Date$\n  */\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for the bicubic function.\n+ * Test case for the bicubic function.\n  * \n  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n  */\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for the tricubic interpolator.\n+ * Test case for the tricubic interpolator.\n  * \n  * @version $Revision$ $Date$ \n  */\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n-import junit.framework.TestCase;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for Lagrange form of polynomial function.\n+ * Test case for Lagrange form of polynomial function.\n  * <p>\n  * We use n+1 points to interpolate a polynomial of degree n. This should\n  * give us the exact same polynomial as result. Thus we can use a very\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n+public final class PolynomialFunctionLagrangeFormTest {\n \n     /**\n      * Test of polynomial for the linear function.\n      */\n+    @Test\n     public void testLinearFunction() {\n         PolynomialFunctionLagrangeForm p;\n         double c[], z, expected, result, tolerance = 1E-12;\n         p = new PolynomialFunctionLagrangeForm(x, y);\n \n         z = 2.0; expected = -1.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 4.5; expected = 2.75; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 6.0; expected = 5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n-        assertEquals(1, p.degree());\n+        Assert.assertEquals(1, p.degree());\n \n         c = p.getCoefficients();\n-        assertEquals(2, c.length);\n-        assertEquals(-4.0, c[0], tolerance);\n-        assertEquals(1.5, c[1], tolerance);\n+        Assert.assertEquals(2, c.length);\n+        Assert.assertEquals(-4.0, c[0], tolerance);\n+        Assert.assertEquals(1.5, c[1], tolerance);\n     }\n \n     /**\n      * Test of polynomial for the quadratic function.\n      */\n+    @Test\n     public void testQuadraticFunction() {\n         PolynomialFunctionLagrangeForm p;\n         double c[], z, expected, result, tolerance = 1E-12;\n         p = new PolynomialFunctionLagrangeForm(x, y);\n \n         z = 1.0; expected = 4.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 2.5; expected = 22.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = -2.0; expected = -5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n-        assertEquals(2, p.degree());\n+        Assert.assertEquals(2, p.degree());\n \n         c = p.getCoefficients();\n-        assertEquals(3, c.length);\n-        assertEquals(-3.0, c[0], tolerance);\n-        assertEquals(5.0, c[1], tolerance);\n-        assertEquals(2.0, c[2], tolerance);\n+        Assert.assertEquals(3, c.length);\n+        Assert.assertEquals(-3.0, c[0], tolerance);\n+        Assert.assertEquals(5.0, c[1], tolerance);\n+        Assert.assertEquals(2.0, c[2], tolerance);\n     }\n \n     /**\n      * Test of polynomial for the quintic function.\n      */\n+    @Test\n     public void testQuinticFunction() {\n         PolynomialFunctionLagrangeForm p;\n         double c[], z, expected, result, tolerance = 1E-12;\n         p = new PolynomialFunctionLagrangeForm(x, y);\n \n         z = 0.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = -2.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 4.0; expected = 360.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n-        assertEquals(5, p.degree());\n+        Assert.assertEquals(5, p.degree());\n \n         c = p.getCoefficients();\n-        assertEquals(6, c.length);\n-        assertEquals(0.0, c[0], tolerance);\n-        assertEquals(6.0, c[1], tolerance);\n-        assertEquals(1.0, c[2], tolerance);\n-        assertEquals(-7.0, c[3], tolerance);\n-        assertEquals(-1.0, c[4], tolerance);\n-        assertEquals(1.0, c[5], tolerance);\n+        Assert.assertEquals(6, c.length);\n+        Assert.assertEquals(0.0, c[0], tolerance);\n+        Assert.assertEquals(6.0, c[1], tolerance);\n+        Assert.assertEquals(1.0, c[2], tolerance);\n+        Assert.assertEquals(-7.0, c[3], tolerance);\n+        Assert.assertEquals(-1.0, c[4], tolerance);\n+        Assert.assertEquals(1.0, c[5], tolerance);\n     }\n \n     /**\n      * Test of parameters for the polynomial.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n \n         try {\n             double x[] = { 1.0 };\n             double y[] = { 2.0 };\n             new PolynomialFunctionLagrangeForm(x, y);\n-            fail(\"Expecting MathIllegalArgumentException - bad input array length\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - bad input array length\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n             double x[] = { 1.0, 2.0, 3.0, 4.0 };\n             double y[] = { 0.0, -4.0, -24.0 };\n             new PolynomialFunctionLagrangeForm(x, y);\n-            fail(\"Expecting MathIllegalArgumentException - mismatch input arrays\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - mismatch input arrays\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n package org.apache.commons.math.analysis.polynomials;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n- * Testcase for Newton form of polynomial function.\n+ * Test case for Newton form of polynomial function.\n  * <p>\n  * The small tolerance number is used only to account for round-off errors.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class PolynomialFunctionNewtonFormTest extends TestCase {\n+public final class PolynomialFunctionNewtonFormTest {\n \n     /**\n      * Test of polynomial for the linear function.\n      */\n+    @Test\n     public void testLinearFunction() {\n         PolynomialFunctionNewtonForm p;\n         double coefficients[], z, expected, result, tolerance = 1E-12;\n         p = new PolynomialFunctionNewtonForm(a, c);\n \n         z = 2.0; expected = -1.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 4.5; expected = 2.75; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 6.0; expected = 5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n-        assertEquals(1, p.degree());\n+        Assert.assertEquals(1, p.degree());\n \n         coefficients = p.getCoefficients();\n-        assertEquals(2, coefficients.length);\n-        assertEquals(-4.0, coefficients[0], tolerance);\n-        assertEquals(1.5, coefficients[1], tolerance);\n+        Assert.assertEquals(2, coefficients.length);\n+        Assert.assertEquals(-4.0, coefficients[0], tolerance);\n+        Assert.assertEquals(1.5, coefficients[1], tolerance);\n     }\n \n     /**\n      * Test of polynomial for the quadratic function.\n      */\n+    @Test\n     public void testQuadraticFunction() {\n         PolynomialFunctionNewtonForm p;\n         double coefficients[], z, expected, result, tolerance = 1E-12;\n         p = new PolynomialFunctionNewtonForm(a, c);\n \n         z = 1.0; expected = 4.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 2.5; expected = 22.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = -2.0; expected = -5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n-        assertEquals(2, p.degree());\n+        Assert.assertEquals(2, p.degree());\n \n         coefficients = p.getCoefficients();\n-        assertEquals(3, coefficients.length);\n-        assertEquals(-3.0, coefficients[0], tolerance);\n-        assertEquals(5.0, coefficients[1], tolerance);\n-        assertEquals(2.0, coefficients[2], tolerance);\n+        Assert.assertEquals(3, coefficients.length);\n+        Assert.assertEquals(-3.0, coefficients[0], tolerance);\n+        Assert.assertEquals(5.0, coefficients[1], tolerance);\n+        Assert.assertEquals(2.0, coefficients[2], tolerance);\n     }\n \n     /**\n      * Test of polynomial for the quintic function.\n      */\n+    @Test\n     public void testQuinticFunction() {\n         PolynomialFunctionNewtonForm p;\n         double coefficients[], z, expected, result, tolerance = 1E-12;\n         p = new PolynomialFunctionNewtonForm(a, c);\n \n         z = 0.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = -2.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         z = 4.0; expected = 360.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n-        assertEquals(5, p.degree());\n+        Assert.assertEquals(5, p.degree());\n \n         coefficients = p.getCoefficients();\n-        assertEquals(6, coefficients.length);\n-        assertEquals(0.0, coefficients[0], tolerance);\n-        assertEquals(6.0, coefficients[1], tolerance);\n-        assertEquals(1.0, coefficients[2], tolerance);\n-        assertEquals(-7.0, coefficients[3], tolerance);\n-        assertEquals(-1.0, coefficients[4], tolerance);\n-        assertEquals(1.0, coefficients[5], tolerance);\n+        Assert.assertEquals(6, coefficients.length);\n+        Assert.assertEquals(0.0, coefficients[0], tolerance);\n+        Assert.assertEquals(6.0, coefficients[1], tolerance);\n+        Assert.assertEquals(1.0, coefficients[2], tolerance);\n+        Assert.assertEquals(-7.0, coefficients[3], tolerance);\n+        Assert.assertEquals(-1.0, coefficients[4], tolerance);\n+        Assert.assertEquals(1.0, coefficients[5], tolerance);\n     }\n \n     /**\n      * Test of parameters for the polynomial.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n \n         try {\n             double a[] = { 1.0 };\n             double c[] = { 2.0 };\n             new PolynomialFunctionNewtonForm(a, c);\n-            fail(\"Expecting MathIllegalArgumentException - bad input array length\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - bad input array length\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n             double a[] = { 1.0, 2.0, 3.0, 4.0 };\n             double c[] = { 4.0, 3.0, 2.0, 1.0 };\n             new PolynomialFunctionNewtonForm(a, c);\n-            fail(\"Expecting MathIllegalArgumentException - mismatch input arrays\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - mismatch input arrays\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n package org.apache.commons.math.analysis.polynomials;\n \n import java.util.Arrays;\n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Tests the PolynomialSplineFunction implementation.\n  *\n  * @version $Revision$\n  */\n-public class PolynomialSplineFunctionTest extends TestCase {\n+public class PolynomialSplineFunctionTest {\n \n     /** Error tolerance for tests */\n     protected double tolerance = 1.0e-12;\n         new PolynomialFunction(new double[] {1d, 2d});\n \n \n+    @Test\n     public void testConstructor() {\n         PolynomialSplineFunction spline =\n             new PolynomialSplineFunction(knots, polynomials);\n-        assertTrue(Arrays.equals(knots, spline.getKnots()));\n-        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);\n-        assertEquals(3, spline.getN());\n+        Assert.assertTrue(Arrays.equals(knots, spline.getKnots()));\n+        Assert.assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);\n+        Assert.assertEquals(3, spline.getN());\n \n         try { // too few knots\n             new PolynomialSplineFunction(new double[] {0}, polynomials);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try { // too many knots\n             new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try { // knots not increasing\n             new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testValues() throws Exception {\n         PolynomialSplineFunction spline =\n             new PolynomialSplineFunction(knots, polynomials);\n         for (int i = 0; i < 10; i++) {\n            x+=0.25;\n            index = findKnot(knots, x);\n-           assertEquals(\"spline function evaluation failed for x=\" + x,\n+           Assert.assertEquals(\"spline function evaluation failed for x=\" + x,\n                    polynomials[index].value(x - knots[index]), spline.value(x), tolerance);\n-           assertEquals(\"spline derivative evaluation failed for x=\" + x,\n+           Assert.assertEquals(\"spline derivative evaluation failed for x=\" + x,\n                    dp.value(x - knots[index]), dSpline.value(x), tolerance);\n         }\n \n         // knot points -- centering should zero arguments\n         for (int i = 0; i < 3; i++) {\n-            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+            Assert.assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n                     polynomials[i].value(0), spline.value(knots[i]), tolerance);\n-            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+            Assert.assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n                     dp.value(0), dSpline.value(knots[i]), tolerance);\n         }\n \n         try { //outside of domain -- under min\n             x = spline.value(-1.5);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n \n         try { //outside of domain -- over max\n             x = spline.value(2.5);\n-            fail(\"Expecting OutOfRangeException\");\n+            Assert.fail(\"Expecting OutOfRangeException\");\n         } catch (OutOfRangeException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n \n     }\n \n+    @Test\n     public void testHermiteDifferentials() {\n         for (int k = 0; k < 12; ++k) {\n \n \n     }\n \n+    @Test\n     public void testLaguerreDifferentials() {\n         for (int k = 0; k < 12; ++k) {\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for {@link BrentSolver Brent} solver.\n+ * Test case for {@link BrentSolver Brent} solver.\n  * Because Brent-Dekker is guaranteed to converge in less than the default\n  * maximum iteration count due to bisection fallback, it is quite hard to\n  * debug. I include measured iteration counts plus one in order to detect\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for Laguerre solver.\n+ * Test case for Laguerre solver.\n  * <p>\n  * Laguerre's method is very efficient in solving polynomials. Test runs\n  * show that for a default absolute accuracy of 1E-6, it generally takes\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n import org.junit.Test;\n \n /**\n- * Testcase for {@link MullerSolver2 Muller} solver.\n+ * Test case for {@link MullerSolver2 Muller} solver.\n  * <p>\n  * Muller's method converges almost quadratically near roots, but it can\n  * be very slow in regions far away from zeros. Test runs show that for\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for {@link MullerSolver Muller} solver.\n+ * Test case for {@link MullerSolver Muller} solver.\n  * <p>\n  * Muller's method converges almost quadratically near roots, but it can\n  * be very slow in regions far away from zeros. Test runs show that for\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for {@link RiddersSolver Ridders} solver.\n+ * Test case for {@link RiddersSolver Ridders} solver.\n  * <p>\n  * Ridders' method converges superlinearly, more specific, its rate of\n  * convergence is sqrt(2). Test runs show that for a default absolute\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n import org.junit.Test;\n \n /**\n- * Testcase for {@link SecantSolver}.\n+ * Test case for {@link SecantSolver}.\n  *\n  * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n--- a/src/test/java/org/apache/commons/math/complex/ComplexFieldTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFieldTest.java\n  */\n package org.apache.commons.math.complex;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ComplexFieldTest {\n \n     @Test\n     public void testZero() {\n-        assertEquals(Complex.ZERO, ComplexField.getInstance().getZero());\n+        Assert.assertEquals(Complex.ZERO, ComplexField.getInstance().getZero());\n     }\n \n     @Test\n     public void testOne() {\n-        assertEquals(Complex.ONE, ComplexField.getInstance().getOne());\n+        Assert.assertEquals(Complex.ONE, ComplexField.getInstance().getOne());\n     }\n \n     @Test\n     public void testSerial() {\n         // deserializing the singleton should give the singleton itself back\n         ComplexField field = ComplexField.getInstance();\n-        assertTrue(field == TestUtils.serializeAndRecover(field));\n+        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n import java.util.List;\n \n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class ComplexTest extends TestCase {\n+public class ComplexTest {\n \n \n     private double inf = Double.POSITIVE_INFINITY;\n     private Complex nanNegInf = new Complex(nan, neginf);\n     private Complex nanZero = new Complex(nan, 0);\n \n+    @Test\n     public void testConstructor() {\n         Complex z = new Complex(3.0, 4.0);\n-        assertEquals(3.0, z.getReal(), 1.0e-5);\n-        assertEquals(4.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(3.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(4.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testConstructorNaN() {\n         Complex z = new Complex(3.0, Double.NaN);\n-        assertTrue(z.isNaN());\n+        Assert.assertTrue(z.isNaN());\n \n         z = new Complex(nan, 4.0);\n-        assertTrue(z.isNaN());\n+        Assert.assertTrue(z.isNaN());\n \n         z = new Complex(3.0, 4.0);\n-        assertFalse(z.isNaN());\n-    }\n-\n+        Assert.assertFalse(z.isNaN());\n+    }\n+\n+    @Test\n     public void testAbs() {\n         Complex z = new Complex(3.0, 4.0);\n-        assertEquals(5.0, z.abs(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(5.0, z.abs(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testAbsNaN() {\n-        assertTrue(Double.isNaN(Complex.NaN.abs()));\n+        Assert.assertTrue(Double.isNaN(Complex.NaN.abs()));\n         Complex z = new Complex(inf, nan);\n-        assertTrue(Double.isNaN(z.abs()));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(z.abs()));\n+    }\n+\n+    @Test\n     public void testAbsInfinite() {\n         Complex z = new Complex(inf, 0);\n-        assertEquals(inf, z.abs(), 0);\n+        Assert.assertEquals(inf, z.abs(), 0);\n         z = new Complex(0, neginf);\n-        assertEquals(inf, z.abs(), 0);\n+        Assert.assertEquals(inf, z.abs(), 0);\n         z = new Complex(inf, neginf);\n-        assertEquals(inf, z.abs(), 0);\n-    }\n-\n+        Assert.assertEquals(inf, z.abs(), 0);\n+    }\n+\n+    @Test\n     public void testAdd() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         Complex z = x.add(y);\n-        assertEquals(8.0, z.getReal(), 1.0e-5);\n-        assertEquals(10.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(8.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(10.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testAddNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.add(Complex.NaN);\n-        assertTrue(z.isNaN());\n+        Assert.assertTrue(z.isNaN());\n         z = new Complex(1, nan);\n         Complex w = x.add(z);\n-        assertEquals(w.getReal(), 4.0, 0);\n-        assertTrue(Double.isNaN(w.getImaginary()));\n-    }\n-\n+        Assert.assertEquals(w.getReal(), 4.0, 0);\n+        Assert.assertTrue(Double.isNaN(w.getImaginary()));\n+    }\n+\n+    @Test\n     public void testAddInfinite() {\n         Complex x = new Complex(1, 1);\n         Complex z = new Complex(inf, 0);\n         Complex w = x.add(z);\n-        assertEquals(w.getImaginary(), 1, 0);\n-        assertEquals(inf, w.getReal(), 0);\n+        Assert.assertEquals(w.getImaginary(), 1, 0);\n+        Assert.assertEquals(inf, w.getReal(), 0);\n \n         x = new Complex(neginf, 0);\n-        assertTrue(Double.isNaN(x.add(z).getReal()));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(x.add(z).getReal()));\n+    }\n+\n+    @Test\n     public void testConjugate() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.conjugate();\n-        assertEquals(3.0, z.getReal(), 1.0e-5);\n-        assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(3.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testConjugateNaN() {\n         Complex z = Complex.NaN.conjugate();\n-        assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertTrue(z.isNaN());\n+    }\n+\n+    @Test\n     public void testConjugateInfiinite() {\n         Complex z = new Complex(0, inf);\n-        assertEquals(neginf, z.conjugate().getImaginary(), 0);\n+        Assert.assertEquals(neginf, z.conjugate().getImaginary(), 0);\n         z = new Complex(0, neginf);\n-        assertEquals(inf, z.conjugate().getImaginary(), 0);\n-    }\n-\n+        Assert.assertEquals(inf, z.conjugate().getImaginary(), 0);\n+    }\n+\n+    @Test\n     public void testDivide() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         Complex z = x.divide(y);\n-        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);\n-        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testDivideReal() {\n         Complex x = new Complex(2d, 3d);\n         Complex y = new Complex(2d, 0d);\n-        assertEquals(new Complex(1d, 1.5), x.divide(y));\n-\n-    }\n-\n+        Assert.assertEquals(new Complex(1d, 1.5), x.divide(y));\n+\n+    }\n+\n+    @Test\n     public void testDivideImaginary() {\n         Complex x = new Complex(2d, 3d);\n         Complex y = new Complex(0d, 2d);\n-        assertEquals(new Complex(1.5d, -1d), x.divide(y));\n-    }\n-\n+        Assert.assertEquals(new Complex(1.5d, -1d), x.divide(y));\n+    }\n+\n+    @Test\n     public void testDivideInfinite() {\n         Complex x = new Complex(3, 4);\n         Complex w = new Complex(neginf, inf);\n-        assertTrue(x.divide(w).equals(Complex.ZERO));\n+        Assert.assertTrue(x.divide(w).equals(Complex.ZERO));\n \n         Complex z = w.divide(x);\n-        assertTrue(Double.isNaN(z.getReal()));\n-        assertEquals(inf, z.getImaginary(), 0);\n+        Assert.assertTrue(Double.isNaN(z.getReal()));\n+        Assert.assertEquals(inf, z.getImaginary(), 0);\n \n         w = new Complex(inf, inf);\n         z = w.divide(x);\n-        assertTrue(Double.isNaN(z.getImaginary()));\n-        assertEquals(inf, z.getReal(), 0);\n+        Assert.assertTrue(Double.isNaN(z.getImaginary()));\n+        Assert.assertEquals(inf, z.getReal(), 0);\n \n         w = new Complex(1, inf);\n         z = w.divide(w);\n-        assertTrue(Double.isNaN(z.getReal()));\n-        assertTrue(Double.isNaN(z.getImaginary()));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(z.getReal()));\n+        Assert.assertTrue(Double.isNaN(z.getImaginary()));\n+    }\n+\n+    @Test\n     public void testDivideZero() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.divide(Complex.ZERO);\n-        assertEquals(z, Complex.NaN);\n-    }\n-\n+        Assert.assertEquals(z, Complex.NaN);\n+    }\n+\n+    @Test\n     public void testDivideNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.divide(Complex.NaN);\n-        assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertTrue(z.isNaN());\n+    }\n+\n+    @Test\n     public void testDivideNaNInf() {\n        Complex z = oneInf.divide(Complex.ONE);\n-       assertTrue(Double.isNaN(z.getReal()));\n-       assertEquals(inf, z.getImaginary(), 0);\n+       Assert.assertTrue(Double.isNaN(z.getReal()));\n+       Assert.assertEquals(inf, z.getImaginary(), 0);\n \n        z = negInfNegInf.divide(oneNaN);\n-       assertTrue(Double.isNaN(z.getReal()));\n-       assertTrue(Double.isNaN(z.getImaginary()));\n+       Assert.assertTrue(Double.isNaN(z.getReal()));\n+       Assert.assertTrue(Double.isNaN(z.getImaginary()));\n \n        z = negInfInf.divide(Complex.ONE);\n-       assertTrue(Double.isNaN(z.getReal()));\n-       assertTrue(Double.isNaN(z.getImaginary()));\n-    }\n-\n+       Assert.assertTrue(Double.isNaN(z.getReal()));\n+       Assert.assertTrue(Double.isNaN(z.getImaginary()));\n+    }\n+\n+    @Test\n     public void testMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         Complex z = x.multiply(y);\n-        assertEquals(-9.0, z.getReal(), 1.0e-5);\n-        assertEquals(38.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(-9.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(38.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testMultiplyNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Complex.NaN);\n-        assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertTrue(z.isNaN());\n+    }\n+\n+    @Test\n     public void testMultiplyNaNInf() {\n         Complex z = new Complex(1,1);\n         Complex w = z.multiply(infOne);\n-        assertEquals(w.getReal(), inf, 0);\n-        assertEquals(w.getImaginary(), inf, 0);\n+        Assert.assertEquals(w.getReal(), inf, 0);\n+        Assert.assertEquals(w.getImaginary(), inf, 0);\n \n         // [MATH-164]\n-        assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));\n-        assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));\n-        assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));\n+        Assert.assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));\n+        Assert.assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));\n+        Assert.assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));\n \n         w = oneInf.multiply(oneNegInf);\n-        assertEquals(w.getReal(), inf, 0);\n-        assertEquals(w.getImaginary(), inf, 0);\n+        Assert.assertEquals(w.getReal(), inf, 0);\n+        Assert.assertEquals(w.getImaginary(), inf, 0);\n \n         w = negInfNegInf.multiply(oneNaN);\n-        assertTrue(Double.isNaN(w.getReal()));\n-        assertTrue(Double.isNaN(w.getImaginary()));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(w.getReal()));\n+        Assert.assertTrue(Double.isNaN(w.getImaginary()));\n+    }\n+\n+    @Test\n     public void testScalarMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n         double y = 2.0;\n         Complex z = x.multiply(y);\n-        assertEquals(6.0, z.getReal(), 1.0e-5);\n-        assertEquals(8.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(6.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(8.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testScalarMultiplyNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Double.NaN);\n-        assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertTrue(z.isNaN());\n+    }\n+\n+    @Test\n     public void testScalarMultiplyInf() {\n         Complex z = new Complex(1,1);\n         Complex w = z.multiply(Double.POSITIVE_INFINITY);\n-        assertEquals(w.getReal(), inf, 0);\n-        assertEquals(w.getImaginary(), inf, 0);\n+        Assert.assertEquals(w.getReal(), inf, 0);\n+        Assert.assertEquals(w.getImaginary(), inf, 0);\n \n         w = z.multiply(Double.NEGATIVE_INFINITY);\n-        assertEquals(w.getReal(), inf, 0);\n-        assertEquals(w.getImaginary(), inf, 0);\n-    }\n-\n+        Assert.assertEquals(w.getReal(), inf, 0);\n+        Assert.assertEquals(w.getImaginary(), inf, 0);\n+    }\n+\n+    @Test\n     public void testNegate() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.negate();\n-        assertEquals(-3.0, z.getReal(), 1.0e-5);\n-        assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(-3.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testNegateNaN() {\n         Complex z = Complex.NaN.negate();\n-        assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertTrue(z.isNaN());\n+    }\n+\n+    @Test\n     public void testSubtract() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         Complex z = x.subtract(y);\n-        assertEquals(-2.0, z.getReal(), 1.0e-5);\n-        assertEquals(-2.0, z.getImaginary(), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(-2.0, z.getReal(), 1.0e-5);\n+        Assert.assertEquals(-2.0, z.getImaginary(), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testSubtractNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.subtract(Complex.NaN);\n-        assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertTrue(z.isNaN());\n+    }\n+\n+    @Test\n     public void testEqualsNull() {\n         Complex x = new Complex(3.0, 4.0);\n-        assertFalse(x.equals(null));\n-    }\n-\n+        Assert.assertFalse(x.equals(null));\n+    }\n+\n+    @Test\n     public void testEqualsClass() {\n         Complex x = new Complex(3.0, 4.0);\n-        assertFalse(x.equals(this));\n-    }\n-\n+        Assert.assertFalse(x.equals(this));\n+    }\n+\n+    @Test\n     public void testEqualsSame() {\n         Complex x = new Complex(3.0, 4.0);\n-        assertTrue(x.equals(x));\n-    }\n-\n+        Assert.assertTrue(x.equals(x));\n+    }\n+\n+    @Test\n     public void testEqualsTrue() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(3.0, 4.0);\n-        assertTrue(x.equals(y));\n-    }\n-\n+        Assert.assertTrue(x.equals(y));\n+    }\n+\n+    @Test\n     public void testEqualsRealDifference() {\n         Complex x = new Complex(0.0, 0.0);\n         Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n-        assertFalse(x.equals(y));\n-    }\n-\n+        Assert.assertFalse(x.equals(y));\n+    }\n+\n+    @Test\n     public void testEqualsImaginaryDifference() {\n         Complex x = new Complex(0.0, 0.0);\n         Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n-        assertFalse(x.equals(y));\n-    }\n-\n+        Assert.assertFalse(x.equals(y));\n+    }\n+\n+    @Test\n     public void testEqualsNaN() {\n         Complex realNaN = new Complex(Double.NaN, 0.0);\n         Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n         Complex complexNaN = Complex.NaN;\n-        assertTrue(realNaN.equals(imaginaryNaN));\n-        assertTrue(imaginaryNaN.equals(complexNaN));\n-        assertTrue(realNaN.equals(complexNaN));\n-    }\n-\n+        Assert.assertTrue(realNaN.equals(imaginaryNaN));\n+        Assert.assertTrue(imaginaryNaN.equals(complexNaN));\n+        Assert.assertTrue(realNaN.equals(complexNaN));\n+    }\n+\n+    @Test\n     public void testHashCode() {\n         Complex x = new Complex(0.0, 0.0);\n         Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n-        assertFalse(x.hashCode()==y.hashCode());\n+        Assert.assertFalse(x.hashCode()==y.hashCode());\n         y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n-        assertFalse(x.hashCode()==y.hashCode());\n+        Assert.assertFalse(x.hashCode()==y.hashCode());\n         Complex realNaN = new Complex(Double.NaN, 0.0);\n         Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n-        assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n-        assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n-    }\n-\n+        Assert.assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n+        Assert.assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n+    }\n+\n+    @Test\n     public void testAcos() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.936812, -2.30551);\n                 Complex.ZERO.acos(), 1.0e-12);\n     }\n \n+    @Test\n     public void testAcosInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.acos());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.acos());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());\n     }\n \n+    @Test\n     public void testAcosNaN() {\n-        assertTrue(Complex.NaN.acos().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.acos().isNaN());\n+    }\n+\n+    @Test\n     public void testAsin() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.633984, 2.30551);\n         TestUtils.assertEquals(expected, z.asin(), 1.0e-5);\n     }\n \n+    @Test\n     public void testAsinNaN() {\n-        assertTrue(Complex.NaN.asin().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.asin().isNaN());\n+    }\n+\n+    @Test\n     public void testAsinInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.asin());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.asin());\n     }\n \n \n+    @Test\n     public void testAtan() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.44831, 0.158997);\n         TestUtils.assertEquals(expected, z.atan(), 1.0e-5);\n     }\n \n+    @Test\n     public void testAtanInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.atan());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.atan());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());\n     }\n \n+    @Test\n     public void testAtanNaN() {\n-        assertTrue(Complex.NaN.atan().isNaN());\n-        assertTrue(Complex.I.atan().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.atan().isNaN());\n+        Assert.assertTrue(Complex.I.atan().isNaN());\n+    }\n+\n+    @Test\n     public void testCos() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-27.03495, -3.851153);\n         TestUtils.assertEquals(expected, z.cos(), 1.0e-5);\n     }\n \n+    @Test\n     public void testCosNaN() {\n-        assertTrue(Complex.NaN.cos().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.cos().isNaN());\n+    }\n+\n+    @Test\n     public void testCosInf() {\n         TestUtils.assertSame(infNegInf, oneInf.cos());\n         TestUtils.assertSame(infInf, oneNegInf.cos());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());\n     }\n \n+    @Test\n     public void testCosh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-6.58066, -7.58155);\n         TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);\n     }\n \n+    @Test\n     public void testCoshNaN() {\n-        assertTrue(Complex.NaN.cosh().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.cosh().isNaN());\n+    }\n+\n+    @Test\n     public void testCoshInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.cosh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());\n     }\n \n+    @Test\n     public void testExp() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-13.12878, -15.20078);\n                 iPi.exp(), 10e-12);\n     }\n \n+    @Test\n     public void testExpNaN() {\n-        assertTrue(Complex.NaN.exp().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.exp().isNaN());\n+    }\n+\n+    @Test\n     public void testExpInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.exp());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.exp());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());\n     }\n \n+    @Test\n     public void testLog() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.60944, 0.927295);\n         TestUtils.assertEquals(expected, z.log(), 1.0e-5);\n     }\n \n+    @Test\n     public void testLogNaN() {\n-        assertTrue(Complex.NaN.log().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.log().isNaN());\n+    }\n+\n+    @Test\n     public void testLogInf() {\n         TestUtils.assertEquals(new Complex(inf, pi / 2),\n                 oneInf.log(), 10e-12);\n                 negInfNegInf.log(), 10e-12);\n     }\n \n+    @Test\n     public void testLogZero() {\n         TestUtils.assertSame(negInfZero, Complex.ZERO.log());\n     }\n \n+    @Test\n     public void testPow() {\n         Complex x = new Complex(3, 4);\n         Complex y = new Complex(5, 6);\n         TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);\n     }\n \n+    @Test\n     public void testPowNaNBase() {\n         Complex x = new Complex(3, 4);\n-        assertTrue(Complex.NaN.pow(x).isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.pow(x).isNaN());\n+    }\n+\n+    @Test\n     public void testPowNaNExponent() {\n         Complex x = new Complex(3, 4);\n-        assertTrue(x.pow(Complex.NaN).isNaN());\n-    }\n-\n+        Assert.assertTrue(x.pow(Complex.NaN).isNaN());\n+    }\n+\n+   @Test\n    public void testPowInf() {\n        TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));\n        TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));\n        TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));\n    }\n \n+   @Test\n    public void testPowZero() {\n        TestUtils.assertSame(Complex.NaN,\n                Complex.ZERO.pow(Complex.ONE));\n                new Complex(-1, 3).pow(Complex.ZERO), 10e-12);\n    }\n \n+    @Test\n     public void testpowNull() {\n         try {\n             Complex.ONE.pow(null);\n-            fail(\"Expecting NullPointerException\");\n+            Assert.fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testSin() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(3.853738, -27.01681);\n         TestUtils.assertEquals(expected, z.sin(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSinInf() {\n         TestUtils.assertSame(infInf, oneInf.sin());\n         TestUtils.assertSame(infNegInf, oneNegInf.sin());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());\n     }\n \n+    @Test\n     public void testSinNaN() {\n-        assertTrue(Complex.NaN.sin().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.sin().isNaN());\n+    }\n+\n+    @Test\n     public void testSinh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-6.54812, -7.61923);\n         TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSinhNaN() {\n-        assertTrue(Complex.NaN.sinh().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.sinh().isNaN());\n+    }\n+\n+    @Test\n     public void testSinhInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.sinh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());\n     }\n \n+    @Test\n     public void testSqrtRealPositive() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(2, 1);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSqrtRealZero() {\n         Complex z = new Complex(0.0, 4);\n         Complex expected = new Complex(1.41421, 1.41421);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSqrtRealNegative() {\n         Complex z = new Complex(-3.0, 4);\n         Complex expected = new Complex(1, 2);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSqrtImaginaryZero() {\n         Complex z = new Complex(-3.0, 0.0);\n         Complex expected = new Complex(0.0, 1.73205);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSqrtImaginaryNegative() {\n         Complex z = new Complex(-3.0, -4.0);\n         Complex expected = new Complex(1.0, -2.0);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSqrtPolar() {\n         double r = 1;\n         for (int i = 0; i < 5; i++) {\n         }\n     }\n \n+    @Test\n     public void testSqrtNaN() {\n-        assertTrue(Complex.NaN.sqrt().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.sqrt().isNaN());\n+    }\n+\n+    @Test\n     public void testSqrtInf() {\n         TestUtils.assertSame(infNaN, oneInf.sqrt());\n         TestUtils.assertSame(infNaN, oneNegInf.sqrt());\n         TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());\n     }\n \n+    @Test\n     public void testSqrt1z() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(4.08033, -2.94094);\n         TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);\n     }\n \n+    @Test\n     public void testSqrt1zNaN() {\n-        assertTrue(Complex.NaN.sqrt1z().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.sqrt1z().isNaN());\n+    }\n+\n+    @Test\n     public void testTan() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-0.000187346, 0.999356);\n         TestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n     }\n \n+    @Test\n     public void testTanNaN() {\n-        assertTrue(Complex.NaN.tan().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.tan().isNaN());\n+    }\n+\n+    @Test\n     public void testTanInf() {\n         TestUtils.assertSame(zeroNaN, oneInf.tan());\n         TestUtils.assertSame(zeroNaN, oneNegInf.tan());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());\n     }\n \n+   @Test\n    public void testTanCritical() {\n         TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());\n         TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());\n     }\n \n+    @Test\n     public void testTanh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.00071, 0.00490826);\n         TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n     }\n \n+    @Test\n     public void testTanhNaN() {\n-        assertTrue(Complex.NaN.tanh().isNaN());\n-    }\n-\n+        Assert.assertTrue(Complex.NaN.tanh().isNaN());\n+    }\n+\n+    @Test\n     public void testTanhInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.tanh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());\n     }\n \n+    @Test\n     public void testTanhCritical() {\n         TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());\n     }\n \n     /** test issue MATH-221 */\n+    @Test\n     public void testMath221() {\n-        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n+        Assert.assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n     }\n \n     /**\n      * </code>\n      * </pre>\n      */\n+    @Test\n     public void testNthRoot_normal_thirdRoot() {\n         // The complex number we want to compute all third-roots for.\n         Complex z = new Complex(-2,2);\n         // The List holding all third roots\n         Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n         // Returned Collection must not be empty!\n-        assertEquals(3, thirdRootsOfZ.length);\n+        Assert.assertEquals(3, thirdRootsOfZ.length);\n         // test z_0\n-        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5);\n-        assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5);\n+        Assert.assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n-        assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);\n-        assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        Assert.assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n         // test z_2\n-        assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);\n-        assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        Assert.assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n     }\n \n \n      * </code>\n      * </pre>\n      */\n+    @Test\n     public void testNthRoot_normal_fourthRoot() {\n         // The complex number we want to compute all third-roots for.\n         Complex z = new Complex(5,-2);\n         // The List holding all fourth roots\n         Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]);\n         // Returned Collection must not be empty!\n-        assertEquals(4, fourthRootsOfZ.length);\n+        Assert.assertEquals(4, fourthRootsOfZ.length);\n         // test z_0\n-        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5);\n-        assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5);\n+        Assert.assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n-        assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);\n-        assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);\n+        Assert.assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);\n         // test z_2\n-        assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);\n-        assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);\n+        Assert.assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);\n         // test z_3\n-        assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);\n-        assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);\n+        Assert.assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);\n     }\n \n     /**\n      * </code>\n      * </pre>\n      */\n+    @Test\n     public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() {\n         // The number 8 has three third roots. One we all already know is the number 2.\n         // But there are two more complex roots.\n         // The List holding all third roots\n         Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n         // Returned Collection must not be empty!\n-        assertEquals(3, thirdRootsOfZ.length);\n+        Assert.assertEquals(3, thirdRootsOfZ.length);\n         // test z_0\n-        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5);\n-        assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5);\n+        Assert.assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n-        assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);\n-        assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        Assert.assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n         // test z_2\n-        assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);\n-        assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        Assert.assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n     }\n \n \n      * </code>\n      * </pre>\n      */\n+    @Test\n     public void testNthRoot_cornercase_thirdRoot_realPartZero() {\n         // complex number with only imaginary part\n         Complex z = new Complex(0,2);\n         // The List holding all third roots\n         Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n         // Returned Collection must not be empty!\n-        assertEquals(3, thirdRootsOfZ.length);\n+        Assert.assertEquals(3, thirdRootsOfZ.length);\n         // test z_0\n-        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5);\n-        assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5);\n+        Assert.assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n-        assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);\n-        assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        Assert.assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n         // test z_2\n-        assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);\n-        assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+        Assert.assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        Assert.assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n     }\n \n     /**\n      * Test cornercases with NaN and Infinity.\n      */\n+    @Test\n     public void testNthRoot_cornercase_NAN_Inf() {\n         // NaN + finite -> NaN\n         List<Complex> roots = oneNaN.nthRoot(3);\n-        assertEquals(1,roots.size());\n-        assertEquals(Complex.NaN, roots.get(0));\n+        Assert.assertEquals(1,roots.size());\n+        Assert.assertEquals(Complex.NaN, roots.get(0));\n \n         roots = nanZero.nthRoot(3);\n-        assertEquals(1,roots.size());\n-        assertEquals(Complex.NaN, roots.get(0));\n+        Assert.assertEquals(1,roots.size());\n+        Assert.assertEquals(Complex.NaN, roots.get(0));\n \n         // NaN + infinite -> NaN\n         roots = nanInf.nthRoot(3);\n-        assertEquals(1,roots.size());\n-        assertEquals(Complex.NaN, roots.get(0));\n+        Assert.assertEquals(1,roots.size());\n+        Assert.assertEquals(Complex.NaN, roots.get(0));\n \n         // finite + infinite -> Inf\n         roots = oneInf.nthRoot(3);\n-        assertEquals(1,roots.size());\n-        assertEquals(Complex.INF, roots.get(0));\n+        Assert.assertEquals(1,roots.size());\n+        Assert.assertEquals(Complex.INF, roots.get(0));\n \n         // infinite + infinite -> Inf\n         roots = negInfInf.nthRoot(3);\n-        assertEquals(1,roots.size());\n-        assertEquals(Complex.INF, roots.get(0));\n+        Assert.assertEquals(1,roots.size());\n+        Assert.assertEquals(Complex.INF, roots.get(0));\n     }\n \n     /**\n      * Test standard values\n      */\n+    @Test\n     public void testGetArgument() {\n         Complex z = new Complex(1, 0);\n-        assertEquals(0.0, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(0.0, z.getArgument(), 1.0e-12);\n \n         z = new Complex(1, 1);\n-        assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n         z = new Complex(0, 1);\n-        assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12);\n \n         z = new Complex(-1, 1);\n-        assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n         z = new Complex(-1, 0);\n-        assertEquals(FastMath.PI, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI, z.getArgument(), 1.0e-12);\n \n         z = new Complex(-1, -1);\n-        assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n         z = new Complex(0, -1);\n-        assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12);\n \n         z = new Complex(1, -1);\n-        assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12);\n+        Assert.assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n     }\n \n     /**\n      * Verify atan2-style handling of infinite parts\n      */\n+    @Test\n     public void testGetArgumentInf() {\n-        assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12);\n-        assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12);\n-        assertEquals(0.0, infOne.getArgument(), 1.0e-12);\n-        assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12);\n-        assertEquals(0.0, infZero.getArgument(), 1.0e-12);\n-        assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12);\n-        assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12);\n-        assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12);\n+        Assert.assertEquals(0.0, infOne.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12);\n+        Assert.assertEquals(0.0, infZero.getArgument(), 1.0e-12);\n+        Assert.assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12);\n+        Assert.assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12);\n+        Assert.assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12);\n     }\n \n     /**\n      * Verify that either part NaN results in NaN\n      */\n+    @Test\n     public void testGetArgumentNaN() {\n-        assertEquals(nan, nanZero.getArgument());\n-        assertEquals(nan, zeroNaN.getArgument());\n-        assertEquals(nan, Complex.NaN.getArgument());\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(nanZero.getArgument()));\n+        Assert.assertTrue(Double.isNaN(zeroNaN.getArgument()));\n+        Assert.assertTrue(Double.isNaN(Complex.NaN.getArgument()));\n+    }\n+\n+    @Test\n     public void testSerial() {\n         Complex z = new Complex(3.0, 4.0);\n-        assertEquals(z, TestUtils.serializeAndRecover(z));\n+        Assert.assertEquals(z, TestUtils.serializeAndRecover(z));\n         Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN);\n-        assertEquals(nanZero, ncmplx);\n-        assertTrue(ncmplx.isNaN());\n+        Assert.assertEquals(nanZero, ncmplx);\n+        Assert.assertTrue(ncmplx.isNaN());\n         Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf);\n-        assertEquals(infInf, infcmplx);\n-        assertTrue(infcmplx.isInfinite());\n+        Assert.assertEquals(infInf, infcmplx);\n+        Assert.assertTrue(infcmplx.isInfinite());\n         TestComplex tz = new TestComplex(3.0, 4.0);\n-        assertEquals(tz, TestUtils.serializeAndRecover(tz));\n+        Assert.assertEquals(tz, TestUtils.serializeAndRecover(tz));\n         TestComplex ntcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN));\n-        assertEquals(nanZero, ntcmplx);\n-        assertTrue(ntcmplx.isNaN());\n+        Assert.assertEquals(nanZero, ntcmplx);\n+        Assert.assertTrue(ntcmplx.isNaN());\n         TestComplex inftcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf));\n-        assertEquals(infInf, inftcmplx);\n-        assertTrue(inftcmplx.isInfinite());\n+        Assert.assertEquals(infInf, inftcmplx);\n+        Assert.assertTrue(inftcmplx.isInfinite());\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class ComplexUtilsTest extends TestCase {\n+public class ComplexUtilsTest {\n \n     private double inf = Double.POSITIVE_INFINITY;\n     private double negInf = Double.NEGATIVE_INFINITY;\n     private Complex negInfNegInf = new Complex(negInf, negInf);\n     private Complex infNaN = new Complex(inf, nan);\n \n+    @Test\n     public void testPolar2Complex() {\n         TestUtils.assertEquals(Complex.ONE,\n                 ComplexUtils.polar2Complex(1, 0), 10e-12);\n         return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));\n     }\n \n+    @Test\n     public void testPolar2ComplexIllegalModulus() {\n         try {\n             ComplexUtils.polar2Complex(-1, 0);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testPolar2ComplexNaN() {\n         TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));\n         TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));\n                 ComplexUtils.polar2Complex(nan, nan));\n     }\n \n+    @Test\n     public void testPolar2ComplexInf() {\n         TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));\n         TestUtils.assertSame(Complex.NaN,\n--- a/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n-import junit.framework.TestCase;\n import org.apache.commons.math.MathException;\n-\n-public class BetaDistributionTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class BetaDistributionTest {\n+    @Test\n     public void testCumulative() throws MathException {\n         double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};\n         // all test data computed using R 2.5\n     private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {\n         BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n         for (int i = 0; i < x.length; i++) {\n-            assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);\n+            Assert.assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);\n         }\n \n         for (int i = 1; i < x.length - 1; i++) {\n-            assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);\n+            Assert.assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);\n         }\n     }\n \n+    @Test\n     public void testDensity() {\n         double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};\n         checkDensity(0.1, 0.1,\n     private void checkDensity(double alpha, double beta, double[] x, double[] expected) {\n         BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n         for (int i = 0; i < x.length; i++) {\n-            assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n+            Assert.assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n         }\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         BetaDistribution dist;\n         \n         dist = new BetaDistributionImpl(1, 1);\n-        assertEquals(dist.getNumericalMean(), 0.5, tol);\n-        assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 0.5, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol); \n         \n         dist = new BetaDistributionImpl(2, 5);\n-        assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol);\n-        assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol); \n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.junit.Assert;\n+import org.junit.Test;\n+\n /**\n  * Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest.\n  * See class javadoc for IntegerDistributionAbstractTest for details.\n  *          2009) $\n  */\n public class BinomialDistributionTest extends IntegerDistributionAbstractTest {\n-\n-    /**\n-     * Constructor for BinomialDistributionTest.\n-     *\n-     * @param name\n-     */\n-    public BinomialDistributionTest(String name) {\n-        super(name);\n-    }\n \n     // -------------- Implementations for abstract methods\n     // -----------------------\n     // ----------------- Additional test cases ---------------------------------\n \n     /** Test degenerate case p = 0 */\n+    @Test\n     public void testDegenerate0() throws Exception {\n         setDistribution(new BinomialDistributionImpl(5, 0.0d));\n         setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });\n     }\n \n     /** Test degenerate case p = 1 */\n+    @Test\n     public void testDegenerate1() throws Exception {\n         setDistribution(new BinomialDistributionImpl(5, 1.0d));\n         setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         BinomialDistribution dist;\n         \n         dist = new BinomialDistributionImpl(10, 0.5);\n-        assertEquals(dist.getNumericalMean(), 10d * 0.5d, tol);\n-        assertEquals(dist.getNumericalVariance(), 10d * 0.5d * 0.5d, tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 10d * 0.5d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 10d * 0.5d * 0.5d, tol); \n         \n         dist = new BinomialDistributionImpl(30, 0.3);\n-        assertEquals(dist.getNumericalMean(), 30d * 0.3d, tol);\n-        assertEquals(dist.getNumericalVariance(), 30d * 0.3d * (1d - 0.3d), tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 30d * 0.3d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 30d * 0.3d * (1d - 0.3d), tol);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for CauchyDistribution.\n  */\n public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n \n-    /**\n-     * Constructor for CauchyDistributionTest.\n-     * @param arg0\n-     */\n-    public CauchyDistributionTest(String arg0) {\n-        super(arg0);\n-    }\n-\n     // --------------------- Override tolerance  --------------\n     protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(defaultTolerance);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n         setInverseCumulativeTestValues(\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testMedian() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        assertEquals(1.2, distribution.getMedian(), 0.0);\n+        Assert.assertEquals(1.2, distribution.getMedian(), 0.0);\n     }\n \n+    @Test\n     public void testScale() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        assertEquals(2.1, distribution.getScale(), 0.0);\n+        Assert.assertEquals(2.1, distribution.getScale(), 0.0);\n     }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new CauchyDistributionImpl(0, 0);\n-            fail(\"Cannot have zero scale\");\n+            Assert.fail(\"Cannot have zero scale\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n             new CauchyDistributionImpl(0, -1);\n-            fail(\"Cannot have negative scale\");\n+            Assert.fail(\"Cannot have negative scale\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testMomonts() {\n         CauchyDistribution dist;\n         \n         dist = new CauchyDistributionImpl(10.2, 0.15);        \n-        assertTrue(Double.isNaN(dist.getNumericalMean()));\n-        assertTrue(Double.isNaN(dist.getNumericalVariance()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n         \n         dist = new CauchyDistributionImpl(23.12, 2.12);\n-        assertTrue(Double.isNaN(dist.getNumericalMean()));\n-        assertTrue(Double.isNaN(dist.getNumericalVariance()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n+import org.junit.Assert;\n+import org.junit.Test;\n+\n /**\n  * Test cases for ChiSquareDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * @version $Revision$ $Date$\n  */\n public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {\n-\n-    /**\n-     * Constructor for ChiSquareDistributionTest.\n-     * @param name\n-     */\n-    public ChiSquareDistributionTest(String name) {\n-        super(name);\n-    }\n \n     //-------------- Implementations for abstract methods -----------------------\n \n \n  // --------------------- Override tolerance  --------------\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1e-9);\n     }\n \n  //---------------------------- Additional test cases -------------------------\n \n+    @Test\n     public void testSmallDf() throws Exception {\n         setDistribution(new ChiSquaredDistributionImpl(0.1d));\n         setTolerance(1E-4);\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testDfAccessors() {\n         ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();\n-        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        Assert.assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n     }\n \n+    @Test\n     public void testDensity() {\n         double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n         //R 2.5: print(dchisq(x, df=1), digits=10)\n     private void checkDensity(double df, double[] x, double[] expected) {\n         ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);\n         for (int i = 0; i < x.length; i++) {\n-            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+            Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);\n         }\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         ChiSquaredDistribution dist;\n         \n         dist = new ChiSquaredDistributionImpl(1500);\n-        assertEquals(dist.getNumericalMean(), 1500, tol);\n-        assertEquals(dist.getNumericalVariance(), 3000, tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 1500, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 3000, tol); \n         \n         dist = new ChiSquaredDistributionImpl(1.12);\n-        assertEquals(dist.getNumericalMean(), 1.12, tol);\n-        assertEquals(dist.getNumericalVariance(), 2.24, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 1.12, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 2.24, tol);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n  */\n package org.apache.commons.math.distribution;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Abstract base class for {@link ContinuousDistribution} tests.\n  *\n  * @version $Revision$ $Date$\n  */\n-public abstract class ContinuousDistributionAbstractTest extends TestCase {\n+public abstract class ContinuousDistributionAbstractTest {\n \n //-------------------- Private test instance data -------------------------\n     /**  Distribution instance used to perform tests */\n     /** Values used to test density calculations */\n     private double[] densityTestValues;\n \n-    //-------------------------------------------------------------------------\n-\n-    /**\n-     * Constructor for ContinuousDistributionAbstractTest.\n-     * @param name\n-     */\n-    public ContinuousDistributionAbstractTest(String name) {\n-        super(name);\n-    }\n-\n     //-------------------- Abstract methods -----------------------------------\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     /**\n      * Setup sets all test instance data to default values\n      */\n-    @Override\n-    protected void setUp() throws Exception {\n-        super.setUp();\n+    @Before\n+    public void setUp() throws Exception {\n         distribution = makeDistribution();\n         cumulativeTestPoints = makeCumulativeTestPoints();\n         cumulativeTestValues = makeCumulativeTestValues();\n     /**\n      * Cleans up test instance data\n      */\n-    @Override\n-    protected void tearDown() throws Exception {\n-        super.tearDown();\n+    @After\n+    public void tearDown() throws Exception {\n         distribution = null;\n         cumulativeTestPoints = null;\n         cumulativeTestValues = null;\n      * Verifies that cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n+    @Test\n     public void testCumulativeProbabilities() throws Exception {\n         verifyCumulativeProbabilities();\n     }\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n+    @Test\n     public void testInverseCumulativeProbabilities() throws Exception {\n         verifyInverseCumulativeProbabilities();\n     }\n      * Verifies that density calculations return expected values\n      * for default test instance data\n      */\n+    @Test\n     public void testDensities() throws Exception {\n         verifyDensities();\n     }\n     /**\n      * Verifies that probability computations are consistent\n      */\n+    @Test\n     public void testConsistency() throws Exception {\n         for (int i=1; i < cumulativeTestPoints.length; i++) {\n \n     /**\n      * Verifies that illegal arguments are correctly handled\n      */\n+    @Test\n     public void testIllegalArguments() throws Exception {\n         try {\n             distribution.cumulativeProbability(1, 0);\n-            fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(-1);\n-            fail(\"Expecting MathIllegalArgumentException for p = -1\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for p = -1\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(2);\n-            fail(\"Expecting MathIllegalArgumentException for p = 2\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for p = 2\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     /**\n      * Test sampling\n      */\n+    @Test\n     public void testSampling() throws Exception {\n         AbstractContinuousDistribution dist = (AbstractContinuousDistribution) makeDistribution();\n         final int sampleSize = 1000;\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for ExponentialDistribution.\n  */\n public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {\n \n-    /**\n-     * Constructor for ExponentialDistributionTest.\n-     * @param name\n-     */\n-    public ExponentialDistributionTest(String name) {\n-        super(name);\n-    }\n-\n     // --------------------- Override tolerance  --------------\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1E-9);\n     }\n \n     //------------ Additional tests -------------------------------------------\n \n+    @Test\n     public void testCumulativeProbabilityExtremes() throws Exception {\n         setCumulativeTestPoints(new double[] {-2, 0});\n         setCumulativeTestValues(new double[] {0, 0});\n         verifyCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n          setInverseCumulativeTestPoints(new double[] {0, 1});\n          setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n          verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testCumulativeProbability2() throws Exception {\n         double actual = getDistribution().cumulativeProbability(0.25, 0.75);\n-        assertEquals(0.0905214, actual, 10e-4);\n+        Assert.assertEquals(0.0905214, actual, 10e-4);\n     }\n \n+    @Test\n     public void testDensity() {\n         ExponentialDistribution d1 = new ExponentialDistributionImpl(1);\n-        assertEquals(0.0, d1.density(-1e-9));\n-        assertEquals(1.0, d1.density(0.0));\n-        assertEquals(0.0, d1.density(1000.0));\n-        assertEquals(FastMath.exp(-1), d1.density(1.0));\n-        assertEquals(FastMath.exp(-2), d1.density(2.0));\n+        Assert.assertTrue(MathUtils.equals(0.0, d1.density(-1e-9), 1));\n+        Assert.assertTrue(MathUtils.equals(1.0, d1.density(0.0), 1));\n+        Assert.assertTrue(MathUtils.equals(0.0, d1.density(1000.0), 1));\n+        Assert.assertTrue(MathUtils.equals(FastMath.exp(-1), d1.density(1.0), 1));\n+        Assert.assertTrue(MathUtils.equals(FastMath.exp(-2), d1.density(2.0), 1));\n \n         ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n-        assertEquals(1/3.0, d2.density(0.0));\n+        Assert.assertTrue(MathUtils.equals(1/3.0, d2.density(0.0), 1));\n         // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5\n-        assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n+        Assert.assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n \n         // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5\n-        assertEquals(0.1711390397, d2.density(2.0), 1e-8);\n+        Assert.assertEquals(0.1711390397, d2.density(2.0), 1e-8);\n     }\n \n+    @Test\n     public void testMeanAccessors() {\n         ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();\n-        assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);\n+        Assert.assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);\n     }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new ExponentialDistributionImpl(0);\n-            fail(\"Should have generated NotStrictlyPositiveException\");\n+            Assert.fail(\"Should have generated NotStrictlyPositiveException\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         ExponentialDistribution dist;\n         \n         dist = new ExponentialDistributionImpl(11d);\n-        assertEquals(dist.getNumericalMean(), 11d, tol);\n-        assertEquals(dist.getNumericalVariance(), 11d * 11d, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 11d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 11d * 11d, tol);\n         \n         dist = new ExponentialDistributionImpl(10.5d);\n-        assertEquals(dist.getNumericalMean(), 10.5d, tol);\n-        assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 10.5d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for FDistribution.\n  * @version $Revision$ $Date$\n  */\n public class FDistributionTest extends ContinuousDistributionAbstractTest {\n-\n-    /**\n-     * Constructor for FDistributionTest.\n-     * @param name\n-     */\n-    public FDistributionTest(String name) {\n-        super(name);\n-    }\n \n     //-------------- Implementations for abstract methods -----------------------\n \n \n     // --------------------- Override tolerance  --------------\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1e-9);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n \n+    @Test\n     public void testCumulativeProbabilityExtremes() throws Exception {\n         setCumulativeTestPoints(new double[] {-2, 0});\n         setCumulativeTestValues(new double[] {0, 0});\n         verifyCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testDfAccessors() {\n         FDistribution dist = (FDistribution) getDistribution();\n-        assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n-        assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n+        Assert.assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n+        Assert.assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n     }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new FDistributionImpl(0, 1);\n-            fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n+            Assert.fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n             new FDistributionImpl(1, 0);\n-            fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n+            Assert.fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testLargeDegreesOfFreedom() throws Exception {\n         FDistributionImpl fd = new FDistributionImpl(100000, 100000);\n         double p = fd.cumulativeProbability(.999);\n         double x = fd.inverseCumulativeProbability(p);\n-        assertEquals(.999, x, 1.0e-5);\n+        Assert.assertEquals(.999, x, 1.0e-5);\n     }\n \n+    @Test\n     public void testSmallDegreesOfFreedom() throws Exception {\n         FDistributionImpl fd = new FDistributionImpl(1, 1);\n         double p = fd.cumulativeProbability(0.975);\n         double x = fd.inverseCumulativeProbability(p);\n-        assertEquals(0.975, x, 1.0e-5);\n+        Assert.assertEquals(0.975, x, 1.0e-5);\n \n         fd = new FDistributionImpl(1, 2);\n         p = fd.cumulativeProbability(0.975);\n         x = fd.inverseCumulativeProbability(p);\n-        assertEquals(0.975, x, 1.0e-5);\n+        Assert.assertEquals(0.975, x, 1.0e-5);\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         FDistribution dist;\n         \n         dist = new FDistributionImpl(1, 2);\n-        assertTrue(Double.isNaN(dist.getNumericalMean()));\n-        assertTrue(Double.isNaN(dist.getNumericalVariance()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n         \n         dist = new FDistributionImpl(1, 3);\n-        assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol);\n-        assertTrue(Double.isNaN(dist.getNumericalVariance()));\n+        Assert.assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol);\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n         \n         dist = new FDistributionImpl(1, 5);\n-        assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol);\n-        assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);        \n+        Assert.assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);        \n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for GammaDistribution.\n  * @version $Revision$ $Date$\n  */\n public class GammaDistributionTest extends ContinuousDistributionAbstractTest {\n-\n-    /**\n-     * Constructor for GammaDistributionTest.\n-     * @param name\n-     */\n-    public GammaDistributionTest(String name) {\n-        super(name);\n-    }\n \n     //-------------- Implementations for abstract methods -----------------------\n \n \n     // --------------------- Override tolerance  --------------\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1e-9);\n     }\n \n     //---------------------------- Additional test cases -------------------------\n+    @Test\n     public void testParameterAccessors() {\n         GammaDistribution distribution = (GammaDistribution) getDistribution();\n-        assertEquals(4d, distribution.getAlpha(), 0);\n-        assertEquals(2d, distribution.getBeta(), 0);\n+        Assert.assertEquals(4d, distribution.getAlpha(), 0);\n+        Assert.assertEquals(2d, distribution.getBeta(), 0);\n     }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new GammaDistributionImpl(0, 1);\n-            fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n+            Assert.fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n             new GammaDistributionImpl(1, 0);\n-            fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n+            Assert.fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testProbabilities() throws Exception {\n         testProbability(-1.000, 4.0, 2.0, .0000);\n         testProbability(15.501, 4.0, 2.0, .9499);\n         testProbability(5.000, 2.0, 2.0, .7127);\n     }\n \n+    @Test\n     public void testValues() throws Exception {\n         testValue(15.501, 4.0, 2.0, .9499);\n         testValue(0.504, 4.0, 1.0, .0018);\n     private void testProbability(double x, double a, double b, double expected) throws Exception {\n         GammaDistribution distribution = new GammaDistributionImpl( a, b );\n         double actual = distribution.cumulativeProbability(x);\n-        assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+        Assert.assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n     }\n \n     private void testValue(double expected, double a, double b, double p) throws Exception {\n         GammaDistribution distribution = new GammaDistributionImpl( a, b );\n         double actual = distribution.inverseCumulativeProbability(p);\n-        assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n+        Assert.assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n     }\n \n+    @Test\n     public void testDensity() {\n         double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n         // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)\n     private void checkDensity(double alpha, double rate, double[] x, double[] expected) {\n         GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);\n         for (int i = 0; i < x.length; i++) {\n-            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+            Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);\n         }\n     }\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         GammaDistribution dist;\n         \n         dist = new GammaDistributionImpl(1, 2);\n-        assertEquals(dist.getNumericalMean(), 2, tol);\n-        assertEquals(dist.getNumericalVariance(), 4, tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 2, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 4, tol); \n         \n         dist = new GammaDistributionImpl(1.1, 4.2);\n-        assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);\n-        assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for HyperGeometriclDistribution.\n  */\n public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {\n \n-    /**\n-     * Constructor for ChiSquareDistributionTest.\n-     * @param name\n-     */\n-    public HypergeometricDistributionTest(String name) {\n-        super(name);\n-    }\n-\n //-------------- Implementations for abstract methods -----------------------\n \n     /** Creates the default discrete distribution instance to use in tests. */\n     //-------------------- Additional test cases ------------------------------\n \n     /** Verify that if there are no failures, mass is concentrated on sampleSize */\n+    @Test\n     public void testDegenerateNoFailures() throws Exception {\n         setDistribution(new HypergeometricDistributionImpl(5,5,3));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n     }\n \n     /** Verify that if there are no successes, mass is concentrated on 0 */\n+    @Test\n     public void testDegenerateNoSuccesses() throws Exception {\n         setDistribution(new HypergeometricDistributionImpl(5,0,3));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n     }\n \n     /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */\n+    @Test\n     public void testDegenerateFullSample() throws Exception {\n         setDistribution(new HypergeometricDistributionImpl(5,3,5));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new HypergeometricDistributionImpl(0, 3, 5);\n-            fail(\"negative population size. NotStrictlyPositiveException expected\");\n+            Assert.fail(\"negative population size. NotStrictlyPositiveException expected\");\n         } catch(NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n             new HypergeometricDistributionImpl(5, -1, 5);\n-            fail(\"negative number of successes. NotPositiveException expected\");\n+            Assert.fail(\"negative number of successes. NotPositiveException expected\");\n         } catch(NotPositiveException ex) {\n             // Expected.\n         }\n         try {\n             new HypergeometricDistributionImpl(5, 3, -1);\n-            fail(\"negative sample size. NotPositiveException expected\");\n+            Assert.fail(\"negative sample size. NotPositiveException expected\");\n         } catch(NotPositiveException ex) {\n             // Expected.\n         }\n         try {\n             new HypergeometricDistributionImpl(5, 6, 5);\n-            fail(\"numberOfSuccesses > populationSize. NumberIsTooLargeException expected\");\n+            Assert.fail(\"numberOfSuccesses > populationSize. NumberIsTooLargeException expected\");\n         } catch(NumberIsTooLargeException ex) {\n             // Expected.\n         }\n         try {\n             new HypergeometricDistributionImpl(5, 3, 6);\n-            fail(\"sampleSize > populationSize. NumberIsTooLargeException expected\");\n+            Assert.fail(\"sampleSize > populationSize. NumberIsTooLargeException expected\");\n         } catch(NumberIsTooLargeException ex) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testAccessors() {\n         HypergeometricDistribution dist = new HypergeometricDistributionImpl(5, 3, 4);\n-        assertEquals(5, dist.getPopulationSize());\n-        assertEquals(3, dist.getNumberOfSuccesses());\n-        assertEquals(4, dist.getSampleSize());\n-    }\n-\n+        Assert.assertEquals(5, dist.getPopulationSize());\n+        Assert.assertEquals(3, dist.getNumberOfSuccesses());\n+        Assert.assertEquals(4, dist.getSampleSize());\n+    }\n+\n+    @Test\n     public void testLargeValues() {\n         int populationSize = 3456;\n         int sampleSize = 789;\n         }\n     }\n \n+    @Test\n     public void testMoreLargeValues() {\n         int populationSize = 26896;\n         int sampleSize = 895;\n         testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         HypergeometricDistribution dist;\n         \n         dist = new HypergeometricDistributionImpl(1500, 40, 100);\n-        assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol);\n-        assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol); \n         \n         dist = new HypergeometricDistributionImpl(3000, 55, 200);\n-        assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol);\n-        assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-\n-import junit.framework.TestCase;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n \n /**\n  * Abstract base class for {@link IntegerDistribution} tests.\n  *\n  * @version $Revision$ $Date$\n  */\n-public abstract class IntegerDistributionAbstractTest extends TestCase {\n+public abstract class IntegerDistributionAbstractTest {\n \n //-------------------- Private test instance data -------------------------\n     /** Discrete distribution instance used to perform tests */\n     /** Values used to test inverse cumulative probability density calculations */\n     private int[] inverseCumulativeTestValues;\n \n-    //-------------------------------------------------------------------------\n-\n-    /**\n-     * Constructor for IntegerDistributionAbstractTest.\n-     * @param name\n-     */\n-    public IntegerDistributionAbstractTest(String name) {\n-        super(name);\n-    }\n-\n     //-------------------- Abstract methods -----------------------------------\n \n     /** Creates the default discrete distribution instance to use in tests. */\n     /**\n      * Setup sets all test instance data to default values\n      */\n-    @Override\n-    protected void setUp() throws Exception {\n-        super.setUp();\n+    @Before\n+    public void setUp() {\n         distribution = makeDistribution();\n         densityTestPoints = makeDensityTestPoints();\n         densityTestValues = makeDensityTestValues();\n     /**\n      * Cleans up test instance data\n      */\n-    @Override\n-    protected void tearDown() throws Exception {\n-        super.tearDown();\n+    @After\n+    public void tearDown() {\n         distribution = null;\n         densityTestPoints = null;\n         densityTestValues = null;\n      */\n     protected void verifyDensities() throws Exception {\n         for (int i = 0; i < densityTestPoints.length; i++) {\n-            assertEquals(\"Incorrect density value returned for \" + densityTestPoints[i],\n+            Assert.assertEquals(\"Incorrect density value returned for \" + densityTestPoints[i],\n                     densityTestValues[i],\n                     distribution.probability(densityTestPoints[i]), tolerance);\n         }\n      */\n     protected void verifyCumulativeProbabilities() throws Exception {\n         for (int i = 0; i < cumulativeTestPoints.length; i++) {\n-            assertEquals(\"Incorrect cumulative probability value returned for \" + cumulativeTestPoints[i],\n+            Assert.assertEquals(\"Incorrect cumulative probability value returned for \" + cumulativeTestPoints[i],\n                     cumulativeTestValues[i],\n                     distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);\n         }\n      */\n     protected void verifyInverseCumulativeProbabilities() throws Exception {\n         for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n-            assertEquals(\"Incorrect inverse cumulative probability value returned for \"\n+            Assert.assertEquals(\"Incorrect inverse cumulative probability value returned for \"\n                     + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],\n                     distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));\n         }\n      * Verifies that probability density calculations match expected values\n      * using default test instance data\n      */\n+    @Test\n     public void testDensities() throws Exception {\n         verifyDensities();\n     }\n      * Verifies that cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n+    @Test\n     public void testCumulativeProbabilities() throws Exception {\n         verifyCumulativeProbabilities();\n     }\n      * cumulativeProbablility(-,-)\n      * JIRA: MATH-184\n      */\n+    @Test\n     public void testFloatingPointArguments() throws Exception {\n         for (int i = 0; i < cumulativeTestPoints.length; i++) {\n             double arg = cumulativeTestPoints[i];\n-            assertEquals(\n+            Assert.assertEquals(\n                     \"Incorrect cumulative probability value returned for \" +\n                     cumulativeTestPoints[i],\n                     cumulativeTestValues[i],\n                     distribution.cumulativeProbability(arg), tolerance);\n             if (i < cumulativeTestPoints.length - 1) {\n                 double arg2 = cumulativeTestPoints[i + 1];\n-                assertEquals(\"Inconsistent probability for discrete range \" +\n+                Assert.assertEquals(\"Inconsistent probability for discrete range \" +\n                         \"[ \" + arg + \",\" + arg2 + \" ]\",\n                    distribution.cumulativeProbability(\n                            cumulativeTestPoints[i],\n                    distribution.cumulativeProbability(arg, arg2), tolerance);\n                 arg = arg - FastMath.random();\n                 arg2 = arg2 + FastMath.random();\n-                assertEquals(\"Inconsistent probability for discrete range \" +\n+                Assert.assertEquals(\"Inconsistent probability for discrete range \" +\n                         \"[ \" + arg + \",\" + arg2 + \" ]\",\n                    distribution.cumulativeProbability(\n                            cumulativeTestPoints[i],\n         double oned = one;\n         double twod = two;\n         double tend = ten;\n-        assertEquals(distribution.cumulativeProbability(one, two),\n+        Assert.assertEquals(distribution.cumulativeProbability(one, two),\n                 distribution.cumulativeProbability(oned, twod), tolerance);\n-        assertEquals(distribution.cumulativeProbability(one, two),\n+        Assert.assertEquals(distribution.cumulativeProbability(one, two),\n                 distribution.cumulativeProbability(oned - tolerance,\n                         twod + 0.9), tolerance);\n-        assertEquals(distribution.cumulativeProbability(two, ten),\n+        Assert.assertEquals(distribution.cumulativeProbability(two, ten),\n                 distribution.cumulativeProbability(twod, tend), tolerance);\n-        assertEquals(distribution.cumulativeProbability(two, ten),\n+        Assert.assertEquals(distribution.cumulativeProbability(two, ten),\n                 distribution.cumulativeProbability(twod - tolerance,\n                         tend + 0.9), tolerance);\n     }\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n+    @Test\n     public void testInverseCumulativeProbabilities() throws Exception {\n         verifyInverseCumulativeProbabilities();\n     }\n     /**\n      * Verifies that illegal arguments are correctly handled\n      */\n+    @Test\n     public void testIllegalArguments() throws Exception {\n         try {\n             distribution.cumulativeProbability(1, 0);\n-            fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(-1);\n-            fail(\"Expecting MathIllegalArgumentException for p = -1\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for p = -1\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(2);\n-            fail(\"Expecting MathIllegalArgumentException for p = 2\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for p = 2\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     /**\n      * Test sampling\n      */\n+    @Test\n     public void testSampling() throws Exception {\n         int[] densityPoints = makeDensityTestPoints();\n         double[] densityValues = makeDensityTestValues();\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for NormalDistribution.\n  */\n public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {\n \n-    /**\n-     * Constructor for NormalDistributionTest.\n-     * @param arg0\n-     */\n-    public NormalDistributionTest(String arg0) {\n-        super(arg0);\n-    }\n-\n     //-------------- Implementations for abstract methods -----------------------\n \n     /** Creates the default continuous distribution instance to use in tests. */\n     // --------------------- Override tolerance  --------------\n     protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(defaultTolerance);\n     }\n         verifyCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testQuantiles() throws Exception {\n         setDensityTestValues(new double[] {0.0385649760808, 0.172836231799, 0.284958771715, 0.172836231799, 0.0385649760808,\n                 0.00316560600853, 9.55930184035e-05, 1.06194251052e-06});\n         verifyDensities();\n     }\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testGetMean() {\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n-        assertEquals(2.1, distribution.getMean(), 0);\n-    }\n-\n+        Assert.assertEquals(2.1, distribution.getMean(), 0);\n+    }\n+\n+    @Test\n     public void testGetStandardDeviation() {\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n-        assertEquals(1.4, distribution.getStandardDeviation(), 0);\n-    }\n-\n+        Assert.assertEquals(1.4, distribution.getStandardDeviation(), 0);\n+    }\n+\n+    @Test\n     public void testPreconditions() {\n         try {\n             new NormalDistributionImpl(1, 0);\n-            fail(\"Should have generated NotStrictlyPositiveException\");\n+            Assert.fail(\"Should have generated NotStrictlyPositiveException\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testDensity() {\n         double [] x = new double[]{-2, -1, 0, 1, 2};\n         // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)\n     private void checkDensity(double mean, double sd, double[] x, double[] expected) {\n         NormalDistribution d = new NormalDistributionImpl(mean, sd);\n         for (int i = 0; i < x.length; i++) {\n-            assertEquals(expected[i], d.density(x[i]), 1e-9);\n+            Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);\n         }\n     }\n \n      * Check to make sure top-coding of extreme values works correctly.\n      * Verifies fixes for JIRA MATH-167, MATH-414\n      */\n+    @Test\n     public void testExtremeValues() throws Exception {\n         NormalDistribution distribution = new NormalDistributionImpl(0, 1);\n         for (int i = 0; i < 100; i++) { // make sure no convergence exception\n             if (i < 9) { // make sure not top-coded \n                 // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned\n                 // TODO: once MATH-364 is resolved, replace 9 with 30\n-                assertTrue(lowerTail > 0.0d);\n-                assertTrue(upperTail < 1.0d);\n+                Assert.assertTrue(lowerTail > 0.0d);\n+                Assert.assertTrue(upperTail < 1.0d);\n             }\n             else { // make sure top coding not reversed\n-                assertTrue(lowerTail < 0.00001);\n-                assertTrue(upperTail > 0.99999);\n+                Assert.assertTrue(lowerTail < 0.00001);\n+                Assert.assertTrue(upperTail > 0.99999);\n             }\n         }\n         \n-        assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n-        assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n-        assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n-        assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n+        Assert.assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n+        Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n+        Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n+        Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n         \n    }\n \n+    @Test\n     public void testMath280() throws MathException {\n         NormalDistribution normal = new NormalDistributionImpl(0,1);\n         double result = normal.inverseCumulativeProbability(0.9986501019683698);\n-        assertEquals(3.0, result, defaultTolerance);\n+        Assert.assertEquals(3.0, result, defaultTolerance);\n         result = normal.inverseCumulativeProbability(0.841344746068543);\n-        assertEquals(1.0, result, defaultTolerance);\n+        Assert.assertEquals(1.0, result, defaultTolerance);\n         result = normal.inverseCumulativeProbability(0.9999683287581673);\n-        assertEquals(4.0, result, defaultTolerance);\n+        Assert.assertEquals(4.0, result, defaultTolerance);\n         result = normal.inverseCumulativeProbability(0.9772498680518209);\n-        assertEquals(2.0, result, defaultTolerance);\n-    }\n-\n+        Assert.assertEquals(2.0, result, defaultTolerance);\n+    }\n+\n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         NormalDistribution dist;\n         \n         dist = new NormalDistributionImpl(0, 1);        \n-        assertEquals(dist.getNumericalMean(), 0, tol);\n-        assertEquals(dist.getNumericalVariance(), 1, tol);        \n+        Assert.assertEquals(dist.getNumericalMean(), 0, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1, tol);        \n  \n         dist = new NormalDistributionImpl(2.2, 1.4);\n-        assertEquals(dist.getNumericalMean(), 2.2, tol);\n-        assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 2.2, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol);\n         \n         dist = new NormalDistributionImpl(-2000.9, 10.4);\n-        assertEquals(dist.getNumericalMean(), -2000.9, tol);\n-        assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), -2000.9, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.junit.Assert;\n+import org.junit.Test;\n+\n /**\n  * Test cases for PascalDistribution.\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  */\n public class PascalDistributionTest extends IntegerDistributionAbstractTest {\n \n-    /**\n-     * Constructor for PascalDistributionTest.\n-     * @param name\n-     */\n-    public PascalDistributionTest(String name) {\n-        super(name);\n-    }\n-\n     // --------------------- Override tolerance  --------------\n     protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() {\n         super.setUp();\n         setTolerance(defaultTolerance);\n     }\n     //----------------- Additional test cases ---------------------------------\n \n     /** Test degenerate case p = 0   */\n+    @Test\n     public void testDegenerate0() throws Exception {\n         setDistribution(new PascalDistributionImpl(5,0.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });\n     }\n \n     /** Test degenerate case p = 1   */\n+    @Test\n     public void testDegenerate1() throws Exception {\n         setDistribution(new PascalDistributionImpl(5,1.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         PascalDistribution dist;\n         \n         dist = new PascalDistributionImpl(10, 0.5);\n-        assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol);\n-        assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol); \n+        Assert.assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol); \n         \n         dist = new PascalDistributionImpl(25, 0.3);\n-        assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol);\n-        assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol);\n+        Assert.assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * <code>PoissonDistributionTest</code>\n      * Constructor.\n      * @param name\n      */\n-    public PoissonDistributionTest(String name) {\n-        super(name);\n+    public PoissonDistributionTest() {\n         setTolerance(1e-12);\n     }\n \n      * calculating P(90 &le; X &le; 110) for X = Po(100) and\n      * P(9900 &le; X &le; 10200) for X  = Po(10000)\n      */\n+    @Test\n     public void testNormalApproximateProbability() throws Exception {\n         PoissonDistribution dist = new PoissonDistributionImpl(100);\n         double result = dist.normalApproximateProbability(110)\n                 - dist.normalApproximateProbability(89);\n-        assertEquals(0.706281887248, result, 1E-10);\n+        Assert.assertEquals(0.706281887248, result, 1E-10);\n \n         dist = new PoissonDistributionImpl(10000);\n         result = dist.normalApproximateProbability(10200)\n         - dist.normalApproximateProbability(9899);\n-        assertEquals(0.820070051552, result, 1E-10);\n+        Assert.assertEquals(0.820070051552, result, 1E-10);\n     }\n \n     /**\n      * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.\n      * @throws Exception\n      */\n+    @Test\n     public void testDegenerateInverseCumulativeProbability() throws Exception {\n         PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n-        assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n-        assertEquals(-1, dist.inverseCumulativeProbability(0d));\n-    }\n-\n+        Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n+        Assert.assertEquals(-1, dist.inverseCumulativeProbability(0d));\n+    }\n+\n+    @Test\n     public void testMean() {\n         PoissonDistribution dist;\n         try {\n             dist = new PoissonDistributionImpl(-1);\n-            fail(\"negative mean: NotStrictlyPositiveException expected\");\n+            Assert.fail(\"negative mean: NotStrictlyPositiveException expected\");\n         } catch(NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n \n         dist = new PoissonDistributionImpl(10.0);\n-        assertEquals(10.0, dist.getMean(), 0.0);\n-    }\n-\n+        Assert.assertEquals(10.0, dist.getMean(), 0.0);\n+    }\n+\n+    @Test\n     public void testLargeMeanCumulativeProbability() {\n         double mean = 1.0;\n         while (mean <= 10000000.0) {\n             while (x >= 0) {\n                 try {\n                     p = dist.cumulativeProbability(x);\n-                    assertFalse(\"NaN cumulative probability returned for mean = \" +\n+                    Assert.assertFalse(\"NaN cumulative probability returned for mean = \" +\n                             mean + \" x = \" + x,Double.isNaN(p));\n                     if (x > mean - 2 * sigma) {\n-                        assertTrue(\"Zero cum probaility returned for mean = \" +\n+                        Assert.assertTrue(\"Zero cum probaility returned for mean = \" +\n                                 mean + \" x = \" + x, p > 0);\n                     }\n                 } catch (MathException ex) {\n-                    fail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n+                    Assert.fail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n                 }\n                 x -= dx;\n             }\n     /**\n      * JIRA: MATH-282\n      */\n+    @Test\n     public void testCumulativeProbabilitySpecial() throws Exception {\n         PoissonDistribution dist;\n         dist = new PoissonDistributionImpl(9120);\n \n     private void checkProbability(PoissonDistribution dist, double x) throws Exception {\n         double p = dist.cumulativeProbability(x);\n-        assertFalse(\"NaN cumulative probability returned for mean = \" +\n+        Assert.assertFalse(\"NaN cumulative probability returned for mean = \" +\n                 dist.getMean() + \" x = \" + x, Double.isNaN(p));\n-        assertTrue(\"Zero cum probability returned for mean = \" +\n+        Assert.assertTrue(\"Zero cum probability returned for mean = \" +\n                 dist.getMean() + \" x = \" + x, p > 0);\n     }\n \n+    @Test\n     public void testLargeMeanInverseCumulativeProbability() throws Exception {\n         double mean = 1.0;\n         while (mean <= 100000.0) { // Extended test value: 1E7.  Reduced to limit run time.\n                 try {\n                     ret = dist.inverseCumulativeProbability(p);\n                     // Verify that returned value satisties definition\n-                    assertTrue(p >= dist.cumulativeProbability(ret));\n-                    assertTrue(p < dist.cumulativeProbability(ret + 1));\n+                    Assert.assertTrue(p >= dist.cumulativeProbability(ret));\n+                    Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));\n                 } catch (MathException ex) {\n-                    fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n+                    Assert.fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n                 }\n                 p += dp;\n             }\n         }\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         PoissonDistribution dist;\n         \n         dist = new PoissonDistributionImpl(1);\n-        assertEquals(dist.getNumericalMean(), 1, tol);\n-        assertEquals(dist.getNumericalVariance(), 1, tol); \n+        Assert.assertEquals(dist.getNumericalMean(), 1, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1, tol); \n         \n         dist = new PoissonDistributionImpl(11.23);\n-        assertEquals(dist.getNumericalMean(), 11.23, tol);\n-        assertEquals(dist.getNumericalVariance(), 11.23, tol);\n+        Assert.assertEquals(dist.getNumericalMean(), 11.23, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 11.23, tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for TDistribution.\n  * @version $Revision$ $Date$\n  */\n public class TDistributionTest extends ContinuousDistributionAbstractTest {\n-\n-    /**\n-     * Constructor for TDistributionTest.\n-     * @param name\n-     */\n-    public TDistributionTest(String name) {\n-        super(name);\n-    }\n \n //-------------- Implementations for abstract methods -----------------------\n \n \n     // --------------------- Override tolerance  --------------\n     @Override\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1E-9);\n     }\n      * @see <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=27243\">\n      *      Bug report that prompted this unit test.</a>\n      */\n+    @Test\n     public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {\n         TDistributionImpl td = new TDistributionImpl(5.);\n         td.cumulativeProbability(.1);\n         td.cumulativeProbability(.01);\n     }\n \n+    @Test\n     public void testSmallDf() throws Exception {\n         setDistribution(new TDistributionImpl(1d));\n         // quantiles computed using R version 2.9.2\n         verifyDensities();\n     }\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testDfAccessors() {\n         TDistribution dist = (TDistribution) getDistribution();\n-        assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        Assert.assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);\n     }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new TDistributionImpl(0);\n-            fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n+            Assert.fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n         } catch (NotStrictlyPositiveException ex) {\n             // expected\n         }\n     }\n     \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         TDistribution dist;\n         \n         dist = new TDistributionImpl(1);\n-        assertTrue(Double.isNaN(dist.getNumericalMean()));\n-        assertTrue(Double.isNaN(dist.getNumericalVariance()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n+        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n         \n         dist = new TDistributionImpl(1.5);\n-        assertEquals(dist.getNumericalMean(), 0, tol);\n-        assertTrue(Double.isInfinite(dist.getNumericalVariance()));\n+        Assert.assertEquals(dist.getNumericalMean(), 0, tol);\n+        Assert.assertTrue(Double.isInfinite(dist.getNumericalVariance()));\n         \n         dist = new TDistributionImpl(5);\n-        assertEquals(dist.getNumericalMean(), 0, tol);\n-        assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);        \n+        Assert.assertEquals(dist.getNumericalMean(), 0, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);        \n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for WeibullDistribution.\n  * @version $Revision$ $Date$\n  */\n public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n-\n-    /**\n-     * Constructor for CauchyDistributionTest.\n-     * @param arg0\n-     */\n-    public WeibullDistributionTest(String arg0) {\n-        super(arg0);\n-    }\n \n     //-------------- Implementations for abstract methods -----------------------\n \n \n     //---------------------------- Additional test cases -------------------------\n \n+    @Test\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n         setInverseCumulativeTestValues(\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n     public void testAlpha() {\n         WeibullDistribution dist = new WeibullDistributionImpl(1, 2);\n-        assertEquals(1, dist.getShape(), 0);\n+        Assert.assertEquals(1, dist.getShape(), 0);\n         try {\n             dist = new WeibullDistributionImpl(0, 2);\n-            fail(\"NotStrictlyPositiveException expected\");\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testBeta() {\n         WeibullDistribution dist = new WeibullDistributionImpl(1, 2);\n-        assertEquals(2, dist.getScale(), 0);\n+        Assert.assertEquals(2, dist.getScale(), 0);\n         try {\n             dist = new WeibullDistributionImpl(1, 0);\n-            fail(\"NotStrictlyPositiveException expected\");\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n         }\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         WeibullDistribution dist;\n         \n         dist = new WeibullDistributionImpl(2.5, 3.5);\n         // In R: 3.5*gamma(1+(1/2.5)) (or emperically: mean(rweibull(10000, 2.5, 3.5)))\n-        assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))), tol);\n-        assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) * \n+        Assert.assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))), tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) * \n                 FastMath.exp(Gamma.logGamma(1 + (2 / 2.5))) -\n                 (dist.getNumericalMean() * dist.getNumericalMean()), tol); \n         \n         dist = new WeibullDistributionImpl(10.4, 2.222);\n-        assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))), tol);\n-        assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) * \n+        Assert.assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))), tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) * \n                 FastMath.exp(Gamma.logGamma(1 + (2 / 10.4))) -\n                 (dist.getNumericalMean() * dist.getNumericalMean()), tol);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for {@link ZipfDistribution}.\n  * @version $Revision$ $Date$\n  */\n public class ZipfDistributionTest extends IntegerDistributionAbstractTest {\n-    public ZipfDistributionTest(String name) {\n-        super(name);\n-    }\n \n+    @Test\n     public void testPreconditions() {\n         try {\n             new ZipfDistributionImpl(0, 1);\n-            fail(\"NotStrictlyPositiveException expected\");\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n         }\n         try {\n             new ZipfDistributionImpl(1, 0);\n-            fail(\"NotStrictlyPositiveException expected\");\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n         }\n         return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};\n     }\n \n+    @Test\n     public void testMomonts() {\n         final double tol = 1e-9;\n         ZipfDistribution dist;\n         \n         dist = new ZipfDistributionImpl(2, 0.5);\n-        assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol);\n-        assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol); \n+        Assert.assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol); \n     }\n }\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionFieldTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFieldTest.java\n  */\n package org.apache.commons.math.fraction;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class BigFractionFieldTest {\n \n     @Test\n     public void testZero() {\n-        assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero());\n+        Assert.assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero());\n     }\n \n     @Test\n     public void testOne() {\n-        assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne());\n+        Assert.assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne());\n     }\n \n     @Test\n     public void testSerial() {\n         // deserializing the singleton should give the singleton itself back\n         BigFractionField field = BigFractionField.getInstance();\n-        assertTrue(field == TestUtils.serializeAndRecover(field));\n+        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n import java.util.Locale;\n \n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n-\n-public class BigFractionFormatTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+\n+public class BigFractionFormatTest {\n \n     BigFractionFormat properFormat = null;\n     BigFractionFormat improperFormat = null;\n         return Locale.getDefault();\n     }\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    @Before\n+    public void setUp() throws Exception {\n         properFormat = BigFractionFormat.getProperInstance(getLocale());\n         improperFormat = BigFractionFormat.getImproperInstance(getLocale());\n     }\n \n+    @Test\n     public void testFormat() {\n         BigFraction c = new BigFraction(1, 2);\n         String expected = \"1 / 2\";\n \n         String actual = properFormat.format(c);\n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testFormatNegative() {\n         BigFraction c = new BigFraction(-1, 2);\n         String expected = \"-1 / 2\";\n \n         String actual = properFormat.format(c);\n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testFormatZero() {\n         BigFraction c = new BigFraction(0, 1);\n         String expected = \"0 / 1\";\n \n         String actual = properFormat.format(c);\n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testFormatImproper() {\n         BigFraction c = new BigFraction(5, 3);\n \n         String actual = properFormat.format(c);\n-        assertEquals(\"1 2 / 3\", actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(\"5 / 3\", actual);\n-    }\n-\n+        Assert.assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(\"5 / 3\", actual);\n+    }\n+\n+    @Test\n     public void testFormatImproperNegative() {\n         BigFraction c = new BigFraction(-5, 3);\n \n         String actual = properFormat.format(c);\n-        assertEquals(\"-1 2 / 3\", actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(\"-5 / 3\", actual);\n-    }\n-\n+        Assert.assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(\"-5 / 3\", actual);\n+    }\n+\n+    @Test\n     public void testParse() {\n         String source = \"1 / 2\";\n \n         try {\n             BigFraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(BigInteger.ONE, c.getNumerator());\n-            assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(BigInteger.ONE, c.getNumerator());\n+            Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n \n             c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(BigInteger.ONE, c.getNumerator());\n-            assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(BigInteger.ONE, c.getNumerator());\n+            Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseInteger() {\n         String source = \"10\";\n         try {\n             BigFraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(BigInteger.TEN, c.getNumerator());\n-            assertEquals(BigInteger.ONE, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(BigInteger.TEN, c.getNumerator());\n+            Assert.assertEquals(BigInteger.ONE, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n         }\n         try {\n             BigFraction c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(BigInteger.TEN, c.getNumerator());\n-            assertEquals(BigInteger.ONE, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(BigInteger.TEN, c.getNumerator());\n+            Assert.assertEquals(BigInteger.ONE, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseInvalid() {\n         String source = \"a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n         try {\n             properFormat.parse(source);\n-            fail(msg);\n+            Assert.fail(msg);\n         } catch (ParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseInvalidDenominator() {\n         String source = \"10 / a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n         try {\n             properFormat.parse(source);\n-            fail(msg);\n+            Assert.fail(msg);\n         } catch (ParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegative() {\n \n         try {\n             String source = \"-1 / 2\";\n             BigFraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumeratorAsInt());\n-            assertEquals(2, c.getDenominatorAsInt());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumeratorAsInt());\n+            Assert.assertEquals(2, c.getDenominatorAsInt());\n \n             c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumeratorAsInt());\n-            assertEquals(2, c.getDenominatorAsInt());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumeratorAsInt());\n+            Assert.assertEquals(2, c.getDenominatorAsInt());\n \n             source = \"1 / -2\";\n             c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumeratorAsInt());\n-            assertEquals(2, c.getDenominatorAsInt());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumeratorAsInt());\n+            Assert.assertEquals(2, c.getDenominatorAsInt());\n \n             c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumeratorAsInt());\n-            assertEquals(2, c.getDenominatorAsInt());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumeratorAsInt());\n+            Assert.assertEquals(2, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseProper() {\n         String source = \"1 2 / 3\";\n \n         try {\n             BigFraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(5, c.getNumeratorAsInt());\n-            assertEquals(3, c.getDenominatorAsInt());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(5, c.getNumeratorAsInt());\n+            Assert.assertEquals(3, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n-            fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseProperNegative() {\n         String source = \"-1 2 / 3\";\n         try {\n             BigFraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-5, c.getNumeratorAsInt());\n-            assertEquals(3, c.getDenominatorAsInt());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-5, c.getNumeratorAsInt());\n+            Assert.assertEquals(3, c.getDenominatorAsInt());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n-            fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseProperInvalidMinus() {\n         String source = \"2 -2 / 3\";\n         try {\n             properFormat.parse(source);\n-            fail(\"invalid minus in improper fraction.\");\n+            Assert.fail(\"invalid minus in improper fraction.\");\n         } catch (ParseException ex) {\n             // expected\n         }\n         source = \"2 2 / -3\";\n         try {\n             properFormat.parse(source);\n-            fail(\"invalid minus in improper fraction.\");\n+            Assert.fail(\"invalid minus in improper fraction.\");\n         } catch (ParseException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testParseBig() throws ParseException {\n         BigFraction f1 =\n             improperFormat.parse(\"167213075789791382630275400487886041651764456874403\" +\n                                  \" / \" +\n                                  \"53225575123090058458126718248444563466137046489291\");\n-        assertEquals(FastMath.PI, f1.doubleValue(), 0.0);\n+        Assert.assertEquals(FastMath.PI, f1.doubleValue(), 0.0);\n         BigFraction f2 =\n             properFormat.parse(\"3 \" +\n                                \"7536350420521207255895245742552351253353317406530\" +\n                                \" / \" +\n                                \"53225575123090058458126718248444563466137046489291\");\n-        assertEquals(FastMath.PI, f2.doubleValue(), 0.0);\n-        assertEquals(f1, f2);\n+        Assert.assertEquals(FastMath.PI, f2.doubleValue(), 0.0);\n+        Assert.assertEquals(f1, f2);\n         BigDecimal pi =\n             new BigDecimal(\"3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068\");\n-        assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));\n-    }\n-\n+        Assert.assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));\n+    }\n+\n+    @Test\n     public void testNumeratorFormat() {\n         NumberFormat old = properFormat.getNumeratorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         properFormat.setNumeratorFormat(nf);\n-        assertEquals(nf, properFormat.getNumeratorFormat());\n+        Assert.assertEquals(nf, properFormat.getNumeratorFormat());\n         properFormat.setNumeratorFormat(old);\n \n         old = improperFormat.getNumeratorFormat();\n         nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         improperFormat.setNumeratorFormat(nf);\n-        assertEquals(nf, improperFormat.getNumeratorFormat());\n+        Assert.assertEquals(nf, improperFormat.getNumeratorFormat());\n         improperFormat.setNumeratorFormat(old);\n     }\n \n+    @Test\n     public void testDenominatorFormat() {\n         NumberFormat old = properFormat.getDenominatorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         properFormat.setDenominatorFormat(nf);\n-        assertEquals(nf, properFormat.getDenominatorFormat());\n+        Assert.assertEquals(nf, properFormat.getDenominatorFormat());\n         properFormat.setDenominatorFormat(old);\n \n         old = improperFormat.getDenominatorFormat();\n         nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         improperFormat.setDenominatorFormat(nf);\n-        assertEquals(nf, improperFormat.getDenominatorFormat());\n+        Assert.assertEquals(nf, improperFormat.getDenominatorFormat());\n         improperFormat.setDenominatorFormat(old);\n     }\n \n+    @Test\n     public void testWholeFormat() {\n         ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;\n \n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         format.setWholeFormat(nf);\n-        assertEquals(nf, format.getWholeFormat());\n+        Assert.assertEquals(nf, format.getWholeFormat());\n         format.setWholeFormat(old);\n     }\n \n+    @Test\n     public void testLongFormat() {\n-        assertEquals(\"10 / 1\", improperFormat.format(10l));\n-    }\n-\n+        Assert.assertEquals(\"10 / 1\", improperFormat.format(10l));\n+    }\n+\n+    @Test\n     public void testDoubleFormat() {\n-        assertEquals(\"1 / 16\", improperFormat.format(0.0625));\n+        Assert.assertEquals(\"1 / 16\", improperFormat.format(0.0625));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n-\n-public class BigFractionTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class BigFractionTest {\n \n     private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) {\n-        assertEquals(expectedNumerator, actual.getNumeratorAsInt());\n-        assertEquals(expectedDenominator, actual.getDenominatorAsInt());\n+        Assert.assertEquals(expectedNumerator, actual.getNumeratorAsInt());\n+        Assert.assertEquals(expectedDenominator, actual.getDenominatorAsInt());\n     }\n \n     private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) {\n-        assertEquals(expectedNumerator, actual.getNumeratorAsLong());\n-        assertEquals(expectedDenominator, actual.getDenominatorAsLong());\n-    }\n-\n+        Assert.assertEquals(expectedNumerator, actual.getNumeratorAsLong());\n+        Assert.assertEquals(expectedDenominator, actual.getDenominatorAsLong());\n+    }\n+\n+    @Test\n     public void testConstructor() throws Exception {\n         assertFraction(0, 1, new BigFraction(0, 1));\n         assertFraction(0, 1, new BigFraction(0l, 2l));\n         assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100));\n         assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100));\n \n-        assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);\n-        assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);\n-        assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);\n+        Assert.assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);\n+        Assert.assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);\n+        Assert.assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);\n         assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001));\n         assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001));\n         try {\n             new BigFraction(null, BigInteger.ONE);\n-            fail(\"Expecting NullArgumentException\");\n+            Assert.fail(\"Expecting NullArgumentException\");\n         } catch (NullArgumentException npe) {\n             // expected\n         }\n         try {\n             new BigFraction(BigInteger.ONE, null);\n-            fail(\"Expecting NullArgumentException\");\n+            Assert.fail(\"Expecting NullArgumentException\");\n         } catch (NullArgumentException npe) {\n             // expected\n         }\n         try {\n             new BigFraction(BigInteger.ONE, BigInteger.ZERO);\n-            fail(\"Expecting ArithmeticException\");\n+            Assert.fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException npe) {\n             // expected\n         }\n         try {\n             new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000);\n-            fail(\"Expecting FractionConversionException\");\n+            Assert.fail(\"Expecting FractionConversionException\");\n         } catch (FractionConversionException fce) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGoldenRatio() {\n         try {\n             // the golden ratio is notoriously a difficult number for continuous\n             // fraction\n             new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (ConvergenceException ce) {\n             // expected behavior\n         }\n     }\n \n     // MATH-179\n+    @Test\n     public void testDoubleConstructor() throws ConvergenceException {\n         assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100));\n         assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100));\n     }\n \n     // MATH-181\n+    @Test\n     public void testDigitLimitConstructor() throws ConvergenceException {\n         assertFraction(2, 5, new BigFraction(0.4, 9));\n         assertFraction(2, 5, new BigFraction(0.4, 99));\n         assertFraction(769, 1250, new BigFraction(0.6152, 9999));\n     }\n \n+    @Test\n     public void testEpsilonLimitConstructor() throws ConvergenceException {\n         assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100));\n \n         assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100));\n     }\n \n+    @Test\n     public void testCompareTo() {\n         BigFraction first = new BigFraction(1, 2);\n         BigFraction second = new BigFraction(1, 3);\n         BigFraction third = new BigFraction(1, 2);\n \n-        assertEquals(0, first.compareTo(first));\n-        assertEquals(0, first.compareTo(third));\n-        assertEquals(1, first.compareTo(second));\n-        assertEquals(-1, second.compareTo(first));\n+        Assert.assertEquals(0, first.compareTo(first));\n+        Assert.assertEquals(0, first.compareTo(third));\n+        Assert.assertEquals(1, first.compareTo(second));\n+        Assert.assertEquals(-1, second.compareTo(first));\n \n         // these two values are different approximations of PI\n         // the first  one is approximately PI - 3.07e-18\n         // the second one is approximately PI + 1.936e-17\n         BigFraction pi1 = new BigFraction(1068966896, 340262731);\n         BigFraction pi2 = new BigFraction( 411557987, 131002976);\n-        assertEquals(-1, pi1.compareTo(pi2));\n-        assertEquals( 1, pi2.compareTo(pi1));\n-        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n-\n-    }\n-\n+        Assert.assertEquals(-1, pi1.compareTo(pi2));\n+        Assert.assertEquals( 1, pi2.compareTo(pi1));\n+        Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n+\n+    }\n+\n+    @Test\n     public void testDoubleValue() {\n         BigFraction first = new BigFraction(1, 2);\n         BigFraction second = new BigFraction(1, 3);\n \n-        assertEquals(0.5, first.doubleValue(), 0.0);\n-        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n-    }\n-\n+        Assert.assertEquals(0.5, first.doubleValue(), 0.0);\n+        Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n+    }\n+\n+    @Test\n     public void testFloatValue() {\n         BigFraction first = new BigFraction(1, 2);\n         BigFraction second = new BigFraction(1, 3);\n \n-        assertEquals(0.5f, first.floatValue(), 0.0f);\n-        assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);\n-    }\n-\n+        Assert.assertEquals(0.5f, first.floatValue(), 0.0f);\n+        Assert.assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);\n+    }\n+\n+    @Test\n     public void testIntValue() {\n         BigFraction first = new BigFraction(1, 2);\n         BigFraction second = new BigFraction(3, 2);\n \n-        assertEquals(0, first.intValue());\n-        assertEquals(1, second.intValue());\n-    }\n-\n+        Assert.assertEquals(0, first.intValue());\n+        Assert.assertEquals(1, second.intValue());\n+    }\n+\n+    @Test\n     public void testLongValue() {\n         BigFraction first = new BigFraction(1, 2);\n         BigFraction second = new BigFraction(3, 2);\n \n-        assertEquals(0L, first.longValue());\n-        assertEquals(1L, second.longValue());\n-    }\n-\n+        Assert.assertEquals(0L, first.longValue());\n+        Assert.assertEquals(1L, second.longValue());\n+    }\n+\n+    @Test\n     public void testConstructorDouble() {\n         assertFraction(1, 2, new BigFraction(0.5));\n         assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0));\n         for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) {\n             try {\n                 new BigFraction(v);\n-                fail(\"Expecting IllegalArgumentException\");\n+                Assert.fail(\"Expecting IllegalArgumentException\");\n             } catch (IllegalArgumentException iae) {\n                 // expected\n             }\n         }\n-        assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());\n-        assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());\n-        assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());\n-    }\n-\n+        Assert.assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());\n+        Assert.assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());\n+        Assert.assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());\n+    }\n+\n+    @Test\n     public void testAbs() {\n         BigFraction a = new BigFraction(10, 21);\n         BigFraction b = new BigFraction(-10, 21);\n         assertFraction(10, 21, c.abs());\n     }\n \n+    @Test\n     public void testReciprocal() {\n         BigFraction f = null;\n \n         f = new BigFraction(50, 75);\n         f = f.reciprocal();\n-        assertEquals(3, f.getNumeratorAsInt());\n-        assertEquals(2, f.getDenominatorAsInt());\n+        Assert.assertEquals(3, f.getNumeratorAsInt());\n+        Assert.assertEquals(2, f.getDenominatorAsInt());\n \n         f = new BigFraction(4, 3);\n         f = f.reciprocal();\n-        assertEquals(3, f.getNumeratorAsInt());\n-        assertEquals(4, f.getDenominatorAsInt());\n+        Assert.assertEquals(3, f.getNumeratorAsInt());\n+        Assert.assertEquals(4, f.getDenominatorAsInt());\n \n         f = new BigFraction(-15, 47);\n         f = f.reciprocal();\n-        assertEquals(-47, f.getNumeratorAsInt());\n-        assertEquals(15, f.getDenominatorAsInt());\n+        Assert.assertEquals(-47, f.getNumeratorAsInt());\n+        Assert.assertEquals(15, f.getDenominatorAsInt());\n \n         f = new BigFraction(0, 3);\n         try {\n             f = f.reciprocal();\n-            fail(\"expecting ArithmeticException\");\n+            Assert.fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n         }\n \n         // large values\n         f = new BigFraction(Integer.MAX_VALUE, 1);\n         f = f.reciprocal();\n-        assertEquals(1, f.getNumeratorAsInt());\n-        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n-    }\n-\n+        Assert.assertEquals(1, f.getNumeratorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+    }\n+\n+    @Test\n     public void testNegate() {\n         BigFraction f = null;\n \n         f = new BigFraction(50, 75);\n         f = f.negate();\n-        assertEquals(-2, f.getNumeratorAsInt());\n-        assertEquals(3, f.getDenominatorAsInt());\n+        Assert.assertEquals(-2, f.getNumeratorAsInt());\n+        Assert.assertEquals(3, f.getDenominatorAsInt());\n \n         f = new BigFraction(-50, 75);\n         f = f.negate();\n-        assertEquals(2, f.getNumeratorAsInt());\n-        assertEquals(3, f.getDenominatorAsInt());\n+        Assert.assertEquals(2, f.getNumeratorAsInt());\n+        Assert.assertEquals(3, f.getDenominatorAsInt());\n \n         // large values\n         f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);\n         f = f.negate();\n-        assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());\n-        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n-\n-    }\n-\n+        Assert.assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+\n+    }\n+\n+    @Test\n     public void testAdd() {\n         BigFraction a = new BigFraction(1, 2);\n         BigFraction b = new BigFraction(2, 3);\n         BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n         BigFraction f2 = BigFraction.ONE;\n         BigFraction f = f1.add(f2);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(-1, 13 * 13 * 2 * 2);\n         f2 = new BigFraction(-2, 13 * 17 * 2);\n         f = f1.add(f2);\n-        assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());\n-        assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());\n+        Assert.assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());\n+        Assert.assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());\n \n         try {\n             f.add((BigFraction) null);\n-            fail(\"expecting NullArgumentException\");\n+            Assert.fail(\"expecting NullArgumentException\");\n         } catch (NullArgumentException ex) {\n         }\n \n         f1 = new BigFraction(1, 32768 * 3);\n         f2 = new BigFraction(1, 59049);\n         f = f1.add(f2);\n-        assertEquals(52451, f.getNumeratorAsInt());\n-        assertEquals(1934917632, f.getDenominatorAsInt());\n+        Assert.assertEquals(52451, f.getNumeratorAsInt());\n+        Assert.assertEquals(1934917632, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MIN_VALUE, 3);\n         f2 = new BigFraction(1, 3);\n         f = f1.add(f2);\n-        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n-        assertEquals(3, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n+        Assert.assertEquals(3, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n         f = f1.add(BigInteger.ONE);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f = f.add(BigInteger.ZERO);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n         f = f1.add(1);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f = f.add(0);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n         f = f1.add(1l);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f = f.add(0l);\n-        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n-\n-    }\n-\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n+\n+    }\n+\n+    @Test\n     public void testDivide() {\n         BigFraction a = new BigFraction(1, 2);\n         BigFraction b = new BigFraction(2, 3);\n         BigFraction f2 = BigFraction.ZERO;\n         try {\n             f1.divide(f2);\n-            fail(\"expecting ArithmeticException\");\n+            Assert.fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n         }\n \n         f1 = new BigFraction(0, 5);\n         f2 = new BigFraction(2, 7);\n         BigFraction f = f1.divide(f2);\n-        assertSame(BigFraction.ZERO, f);\n+        Assert.assertSame(BigFraction.ZERO, f);\n \n         f1 = new BigFraction(2, 7);\n         f2 = BigFraction.ONE;\n         f = f1.divide(f2);\n-        assertEquals(2, f.getNumeratorAsInt());\n-        assertEquals(7, f.getDenominatorAsInt());\n+        Assert.assertEquals(2, f.getNumeratorAsInt());\n+        Assert.assertEquals(7, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(1, Integer.MAX_VALUE);\n         f = f1.divide(f1);\n-        assertEquals(1, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(1, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         f2 = new BigFraction(1, Integer.MAX_VALUE);\n         f = f1.divide(f2);\n-        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         try {\n             f.divide((BigFraction) null);\n-            fail(\"expecting NullArgumentException\");\n+            Assert.fail(\"expecting NullArgumentException\");\n         } catch (NullArgumentException ex) {\n         }\n \n         f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));\n-        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n-        assertEquals(1, f.getNumeratorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        Assert.assertEquals(1, f.getNumeratorAsInt());\n \n         f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         f = f1.divide(Integer.MIN_VALUE);\n-        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n-        assertEquals(1, f.getNumeratorAsInt());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        Assert.assertEquals(1, f.getNumeratorAsInt());\n \n         f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         f = f1.divide((long) Integer.MIN_VALUE);\n-        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n-        assertEquals(1, f.getNumeratorAsInt());\n-\n-    }\n-\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        Assert.assertEquals(1, f.getNumeratorAsInt());\n+\n+    }\n+\n+    @Test\n     public void testMultiply() {\n         BigFraction a = new BigFraction(1, 2);\n         BigFraction b = new BigFraction(2, 3);\n         BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1);\n         BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         BigFraction f = f1.multiply(f2);\n-        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f = f2.multiply(Integer.MAX_VALUE);\n-        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         f = f2.multiply((long) Integer.MAX_VALUE);\n-        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n \n         try {\n             f.multiply((BigFraction) null);\n-            fail(\"expecting NullArgumentException\");\n+            Assert.fail(\"expecting NullArgumentException\");\n         } catch (NullArgumentException ex) {\n         }\n \n     }\n \n+    @Test\n     public void testSubtract() {\n         BigFraction a = new BigFraction(1, 2);\n         BigFraction b = new BigFraction(2, 3);\n         BigFraction f = new BigFraction(1, 1);\n         try {\n             f.subtract((BigFraction) null);\n-            fail(\"expecting NullArgumentException\");\n+            Assert.fail(\"expecting NullArgumentException\");\n         } catch (NullArgumentException ex) {\n         }\n \n         BigFraction f1 = new BigFraction(1, 32768 * 3);\n         BigFraction f2 = new BigFraction(1, 59049);\n         f = f1.subtract(f2);\n-        assertEquals(-13085, f.getNumeratorAsInt());\n-        assertEquals(1934917632, f.getDenominatorAsInt());\n+        Assert.assertEquals(-13085, f.getNumeratorAsInt());\n+        Assert.assertEquals(1934917632, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MIN_VALUE, 3);\n         f2 = new BigFraction(1, 3).negate();\n         f = f1.subtract(f2);\n-        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n-        assertEquals(3, f.getDenominatorAsInt());\n+        Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n+        Assert.assertEquals(3, f.getDenominatorAsInt());\n \n         f1 = new BigFraction(Integer.MAX_VALUE, 1);\n         f2 = BigFraction.ONE;\n         f = f1.subtract(f2);\n-        assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());\n-        assertEquals(1, f.getDenominatorAsInt());\n-\n-    }\n-\n+        Assert.assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());\n+        Assert.assertEquals(1, f.getDenominatorAsInt());\n+\n+    }\n+\n+    @Test\n     public void testBigDecimalValue() {\n-        assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());\n-        assertEquals(new BigDecimal(\"0.0003\"), new BigFraction(3, 10000).bigDecimalValue());\n-        assertEquals(new BigDecimal(\"0\"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));\n-        assertEquals(new BigDecimal(\"0.333\"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));\n-    }\n-\n+        Assert.assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());\n+        Assert.assertEquals(new BigDecimal(\"0.0003\"), new BigFraction(3, 10000).bigDecimalValue());\n+        Assert.assertEquals(new BigDecimal(\"0\"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));\n+        Assert.assertEquals(new BigDecimal(\"0.333\"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));\n+    }\n+\n+    @Test\n     public void testEqualsAndHashCode() {\n         BigFraction zero = new BigFraction(0, 1);\n         BigFraction nullFraction = null;\n-        assertTrue(zero.equals(zero));\n-        assertFalse(zero.equals(nullFraction));\n-        assertFalse(zero.equals(Double.valueOf(0)));\n+        Assert.assertTrue(zero.equals(zero));\n+        Assert.assertFalse(zero.equals(nullFraction));\n+        Assert.assertFalse(zero.equals(Double.valueOf(0)));\n         BigFraction zero2 = new BigFraction(0, 2);\n-        assertTrue(zero.equals(zero2));\n-        assertEquals(zero.hashCode(), zero2.hashCode());\n+        Assert.assertTrue(zero.equals(zero2));\n+        Assert.assertEquals(zero.hashCode(), zero2.hashCode());\n         BigFraction one = new BigFraction(1, 1);\n-        assertFalse((one.equals(zero) || zero.equals(one)));\n-        assertTrue(one.equals(BigFraction.ONE));\n-    }\n-\n+        Assert.assertFalse((one.equals(zero) || zero.equals(one)));\n+        Assert.assertTrue(one.equals(BigFraction.ONE));\n+    }\n+\n+    @Test\n     public void testGetReducedFraction() {\n         BigFraction threeFourths = new BigFraction(3, 4);\n-        assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));\n-        assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));\n+        Assert.assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));\n+        Assert.assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));\n         try {\n             BigFraction.getReducedFraction(1, 0);\n-            fail(\"expecting ArithmeticException\");\n+            Assert.fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n             // expected\n         }\n-        assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);\n-        assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);\n-    }\n-\n+        Assert.assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);\n+        Assert.assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);\n+    }\n+\n+    @Test\n     public void testPow() {\n-        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13));\n-        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l));\n-        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l)));\n-        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0));\n-        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l));\n-        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l)));\n-        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13));\n-        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l));\n-        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l)));\n-    }\n-\n+        Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13));\n+        Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l));\n+        Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l)));\n+        Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0));\n+        Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l));\n+        Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l)));\n+        Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13));\n+        Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l));\n+        Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l)));\n+    }\n+\n+    @Test\n     public void testMath340() {\n         BigFraction fractionA = new BigFraction(0.00131);\n         BigFraction fractionB = new BigFraction(.37).reciprocal();\n         BigFraction errorResult = fractionA.multiply(fractionB);\n         BigFraction correctResult = new BigFraction(fractionA.getNumerator().multiply(fractionB.getNumerator()),\n                                                     fractionA.getDenominator().multiply(fractionB.getDenominator()));\n-        assertEquals(correctResult, errorResult);\n-    }\n-\n+        Assert.assertEquals(correctResult, errorResult);\n+    }\n+\n+    @Test\n     public void testSerial() throws FractionConversionException {\n         BigFraction[] fractions = {\n             new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO,\n             new BigFraction(-5, 2)\n         };\n         for (BigFraction fraction : fractions) {\n-            assertEquals(fraction, TestUtils.serializeAndRecover(fraction));\n+            Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction));\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/fraction/FractionFieldTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFieldTest.java\n  */\n package org.apache.commons.math.fraction;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class FractionFieldTest {\n \n     @Test\n     public void testZero() {\n-        assertEquals(Fraction.ZERO, FractionField.getInstance().getZero());\n+        Assert.assertEquals(Fraction.ZERO, FractionField.getInstance().getZero());\n     }\n \n     @Test\n     public void testOne() {\n-        assertEquals(Fraction.ONE, FractionField.getInstance().getOne());\n+        Assert.assertEquals(Fraction.ONE, FractionField.getInstance().getOne());\n     }\n \n     @Test\n     public void testSerial() {\n         // deserializing the singleton should give the singleton itself back\n         FractionField field = FractionField.getInstance();\n-        assertTrue(field == TestUtils.serializeAndRecover(field));\n+        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n import java.util.Locale;\n \n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n-\n-public class FractionFormatTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+\n+public class FractionFormatTest {\n \n     FractionFormat properFormat = null;\n     FractionFormat improperFormat = null;\n         return Locale.getDefault();\n     }\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    @Before\n+    public void setUp() throws Exception {\n         properFormat = FractionFormat.getProperInstance(getLocale());\n         improperFormat = FractionFormat.getImproperInstance(getLocale());\n     }\n \n+    @Test\n     public void testFormat() {\n         Fraction c = new Fraction(1, 2);\n         String expected = \"1 / 2\";\n \n         String actual = properFormat.format(c);\n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testFormatNegative() {\n         Fraction c = new Fraction(-1, 2);\n         String expected = \"-1 / 2\";\n \n         String actual = properFormat.format(c);\n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testFormatZero() {\n         Fraction c = new Fraction(0, 1);\n         String expected = \"0 / 1\";\n \n         String actual = properFormat.format(c);\n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testFormatImproper() {\n         Fraction c = new Fraction(5, 3);\n \n         String actual = properFormat.format(c);\n-        assertEquals(\"1 2 / 3\", actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(\"5 / 3\", actual);\n-    }\n-\n+        Assert.assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(\"5 / 3\", actual);\n+    }\n+\n+    @Test\n     public void testFormatImproperNegative() {\n         Fraction c = new Fraction(-5, 3);\n \n         String actual = properFormat.format(c);\n-        assertEquals(\"-1 2 / 3\", actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(\"-5 / 3\", actual);\n-    }\n-\n+        Assert.assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c);\n+        Assert.assertEquals(\"-5 / 3\", actual);\n+    }\n+\n+    @Test\n     public void testParse() {\n         String source = \"1 / 2\";\n \n         try {\n             Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(1, c.getNumerator());\n+            Assert.assertEquals(2, c.getDenominator());\n \n             c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(1, c.getNumerator());\n+            Assert.assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseInteger() {\n         String source = \"10\";\n         try {\n             Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(10, c.getNumerator());\n-            assertEquals(1, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(10, c.getNumerator());\n+            Assert.assertEquals(1, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n         }\n         try {\n             Fraction c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(10, c.getNumerator());\n-            assertEquals(1, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(10, c.getNumerator());\n+            Assert.assertEquals(1, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseInvalid() {\n         String source = \"a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n         try {\n             properFormat.parse(source);\n-            fail(msg);\n+            Assert.fail(msg);\n         } catch (ParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseInvalidDenominator() {\n         String source = \"10 / a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n         try {\n             properFormat.parse(source);\n-            fail(msg);\n+            Assert.fail(msg);\n         } catch (ParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegative() {\n \n         try {\n             String source = \"-1 / 2\";\n             Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumerator());\n+            Assert.assertEquals(2, c.getDenominator());\n \n             c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumerator());\n+            Assert.assertEquals(2, c.getDenominator());\n \n             source = \"1 / -2\";\n             c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumerator());\n+            Assert.assertEquals(2, c.getDenominator());\n \n             c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-1, c.getNumerator());\n+            Assert.assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseProper() {\n         String source = \"1 2 / 3\";\n \n         try {\n             Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(5, c.getNumerator());\n-            assertEquals(3, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(5, c.getNumerator());\n+            Assert.assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n-            fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseProperNegative() {\n         String source = \"-1 2 / 3\";\n         try {\n             Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-5, c.getNumerator());\n-            assertEquals(3, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n+            Assert.assertNotNull(c);\n+            Assert.assertEquals(-5, c.getNumerator());\n+            Assert.assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n-            fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-\n+            Assert.fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+\n+    @Test\n     public void testParseProperInvalidMinus() {\n         String source = \"2 -2 / 3\";\n         try {\n             properFormat.parse(source);\n-            fail(\"invalid minus in improper fraction.\");\n+            Assert.fail(\"invalid minus in improper fraction.\");\n         } catch (ParseException ex) {\n             // expected\n         }\n         source = \"2 2 / -3\";\n         try {\n             properFormat.parse(source);\n-            fail(\"invalid minus in improper fraction.\");\n+            Assert.fail(\"invalid minus in improper fraction.\");\n         } catch (ParseException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testNumeratorFormat() {\n         NumberFormat old = properFormat.getNumeratorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         properFormat.setNumeratorFormat(nf);\n-        assertEquals(nf, properFormat.getNumeratorFormat());\n+        Assert.assertEquals(nf, properFormat.getNumeratorFormat());\n         properFormat.setNumeratorFormat(old);\n \n         old = improperFormat.getNumeratorFormat();\n         nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         improperFormat.setNumeratorFormat(nf);\n-        assertEquals(nf, improperFormat.getNumeratorFormat());\n+        Assert.assertEquals(nf, improperFormat.getNumeratorFormat());\n         improperFormat.setNumeratorFormat(old);\n     }\n \n+    @Test\n     public void testDenominatorFormat() {\n         NumberFormat old = properFormat.getDenominatorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         properFormat.setDenominatorFormat(nf);\n-        assertEquals(nf, properFormat.getDenominatorFormat());\n+        Assert.assertEquals(nf, properFormat.getDenominatorFormat());\n         properFormat.setDenominatorFormat(old);\n \n         old = improperFormat.getDenominatorFormat();\n         nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         improperFormat.setDenominatorFormat(nf);\n-        assertEquals(nf, improperFormat.getDenominatorFormat());\n+        Assert.assertEquals(nf, improperFormat.getDenominatorFormat());\n         improperFormat.setDenominatorFormat(old);\n     }\n \n+    @Test\n     public void testWholeFormat() {\n         ProperFractionFormat format = (ProperFractionFormat)properFormat;\n \n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         format.setWholeFormat(nf);\n-        assertEquals(nf, format.getWholeFormat());\n+        Assert.assertEquals(nf, format.getWholeFormat());\n         format.setWholeFormat(old);\n     }\n \n+    @Test\n     public void testLongFormat() {\n-        assertEquals(\"10 / 1\", improperFormat.format(10l));\n-    }\n-\n+        Assert.assertEquals(\"10 / 1\", improperFormat.format(10l));\n+    }\n+\n+    @Test\n     public void testDoubleFormat() {\n-        assertEquals(\"355 / 113\", improperFormat.format(FastMath.PI));\n+        Assert.assertEquals(\"355 / 113\", improperFormat.format(FastMath.PI));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class FractionTest extends TestCase {\n+public class FractionTest {\n \n     private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {\n-        assertEquals(expectedNumerator, actual.getNumerator());\n-        assertEquals(expectedDenominator, actual.getDenominator());\n-    }\n-\n+        Assert.assertEquals(expectedNumerator, actual.getNumerator());\n+        Assert.assertEquals(expectedDenominator, actual.getDenominator());\n+    }\n+\n+    @Test\n     public void testConstructor() throws Exception {\n         assertFraction(0, 1, new Fraction(0, 1));\n         assertFraction(0, 1, new Fraction(0, 2));\n         // overflow\n         try {\n             new Fraction(Integer.MIN_VALUE, -1);\n-            fail();\n+            Assert.fail();\n         } catch (MathArithmeticException ex) {\n             // success\n         }\n         try {\n             new Fraction(1, Integer.MIN_VALUE);\n-            fail();\n+            Assert.fail();\n         } catch (MathArithmeticException ex) {\n             // success\n         }\n         assertFraction(15, 1, new Fraction(15.0000000000001));\n     }\n \n+    @Test\n     public void testGoldenRatio() {\n         try {\n             // the golden ratio is notoriously a difficult number for continuous fraction\n             new Fraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (ConvergenceException ce) {\n             // expected behavior\n         }\n     }\n \n     // MATH-179\n+    @Test\n     public void testDoubleConstructor() throws ConvergenceException  {\n         assertFraction(1, 2, new Fraction((double)1 / (double)2));\n         assertFraction(1, 3, new Fraction((double)1 / (double)3));\n     }\n \n     // MATH-181\n+    @Test\n     public void testDigitLimitConstructor() throws ConvergenceException  {\n         assertFraction(2, 5, new Fraction(0.4,   9));\n         assertFraction(2, 5, new Fraction(0.4,  99));\n         assertFraction(769, 1250, new Fraction(0.6152, 9999));\n     }\n \n+    @Test\n     public void testIntegerOverflow() {\n         checkIntegerOverflow(0.75000000001455192);\n         checkIntegerOverflow(1.0e10);\n     private void checkIntegerOverflow(double a) {\n         try {\n             new Fraction(a, 1.0e-12, 1000);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (ConvergenceException ce) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testEpsilonLimitConstructor() throws ConvergenceException  {\n         assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100));\n \n         assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100));\n     }\n \n+    @Test\n     public void testCompareTo() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);\n         Fraction third = new Fraction(1, 2);\n \n-        assertEquals(0, first.compareTo(first));\n-        assertEquals(0, first.compareTo(third));\n-        assertEquals(1, first.compareTo(second));\n-        assertEquals(-1, second.compareTo(first));\n+        Assert.assertEquals(0, first.compareTo(first));\n+        Assert.assertEquals(0, first.compareTo(third));\n+        Assert.assertEquals(1, first.compareTo(second));\n+        Assert.assertEquals(-1, second.compareTo(first));\n \n         // these two values are different approximations of PI\n         // the first  one is approximately PI - 3.07e-18\n         // the second one is approximately PI + 1.936e-17\n         Fraction pi1 = new Fraction(1068966896, 340262731);\n         Fraction pi2 = new Fraction( 411557987, 131002976);\n-        assertEquals(-1, pi1.compareTo(pi2));\n-        assertEquals( 1, pi2.compareTo(pi1));\n-        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n-    }\n-\n+        Assert.assertEquals(-1, pi1.compareTo(pi2));\n+        Assert.assertEquals( 1, pi2.compareTo(pi1));\n+        Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n+    }\n+\n+    @Test\n     public void testDoubleValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);\n \n-        assertEquals(0.5, first.doubleValue(), 0.0);\n-        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n-    }\n-\n+        Assert.assertEquals(0.5, first.doubleValue(), 0.0);\n+        Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n+    }\n+\n+    @Test\n     public void testFloatValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);\n \n-        assertEquals(0.5f, first.floatValue(), 0.0f);\n-        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);\n-    }\n-\n+        Assert.assertEquals(0.5f, first.floatValue(), 0.0f);\n+        Assert.assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);\n+    }\n+\n+    @Test\n     public void testIntValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(3, 2);\n \n-        assertEquals(0, first.intValue());\n-        assertEquals(1, second.intValue());\n-    }\n-\n+        Assert.assertEquals(0, first.intValue());\n+        Assert.assertEquals(1, second.intValue());\n+    }\n+\n+    @Test\n     public void testLongValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(3, 2);\n \n-        assertEquals(0L, first.longValue());\n-        assertEquals(1L, second.longValue());\n-    }\n-\n+        Assert.assertEquals(0L, first.longValue());\n+        Assert.assertEquals(1L, second.longValue());\n+    }\n+\n+    @Test\n     public void testConstructorDouble() throws Exception {\n         assertFraction(1, 2, new Fraction(0.5));\n         assertFraction(1, 3, new Fraction(1.0 / 3.0));\n         assertFraction(-317, 100, new Fraction(-317.0 / 100.0));\n     }\n \n+    @Test\n     public void testAbs() {\n         Fraction a = new Fraction(10, 21);\n         Fraction b = new Fraction(-10, 21);\n         assertFraction(10, 21, c.abs());\n     }\n \n+    @Test\n     public void testReciprocal() {\n         Fraction f = null;\n \n         f = new Fraction(50, 75);\n         f = f.reciprocal();\n-        assertEquals(3, f.getNumerator());\n-        assertEquals(2, f.getDenominator());\n+        Assert.assertEquals(3, f.getNumerator());\n+        Assert.assertEquals(2, f.getDenominator());\n \n         f = new Fraction(4, 3);\n         f = f.reciprocal();\n-        assertEquals(3, f.getNumerator());\n-        assertEquals(4, f.getDenominator());\n+        Assert.assertEquals(3, f.getNumerator());\n+        Assert.assertEquals(4, f.getDenominator());\n \n         f = new Fraction(-15, 47);\n         f = f.reciprocal();\n-        assertEquals(-47, f.getNumerator());\n-        assertEquals(15, f.getDenominator());\n+        Assert.assertEquals(-47, f.getNumerator());\n+        Assert.assertEquals(15, f.getDenominator());\n \n         f = new Fraction(0, 3);\n         try {\n             f = f.reciprocal();\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         // large values\n         f = new Fraction(Integer.MAX_VALUE, 1);\n         f = f.reciprocal();\n-        assertEquals(1, f.getNumerator());\n-        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n-    }\n-\n+        Assert.assertEquals(1, f.getNumerator());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+    }\n+\n+    @Test\n     public void testNegate() {\n         Fraction f = null;\n \n         f = new Fraction(50, 75);\n         f = f.negate();\n-        assertEquals(-2, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n+        Assert.assertEquals(-2, f.getNumerator());\n+        Assert.assertEquals(3, f.getDenominator());\n \n         f = new Fraction(-50, 75);\n         f = f.negate();\n-        assertEquals(2, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n+        Assert.assertEquals(2, f.getNumerator());\n+        Assert.assertEquals(3, f.getDenominator());\n \n         // large values\n         f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n         f = f.negate();\n-        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n-        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+        Assert.assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator());\n \n         f = new Fraction(Integer.MIN_VALUE, 1);\n         try {\n             f = f.negate();\n-            fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {}\n-    }\n-\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n+    }\n+\n+    @Test\n     public void testAdd() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n         Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n         Fraction f2 = Fraction.ONE;\n         Fraction f = f1.add(f2);\n-        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n         f = f1.add(1);\n-        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n \n         f1 = new Fraction(-1, 13*13*2*2);\n         f2 = new Fraction(-2, 13*17*2);\n         f = f1.add(f2);\n-        assertEquals(13*13*17*2*2, f.getDenominator());\n-        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        Assert.assertEquals(13*13*17*2*2, f.getDenominator());\n+        Assert.assertEquals(-17 - 2*13*2, f.getNumerator());\n \n         try {\n             f.add(null);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n         // if this fraction is added naively, it will overflow.\n         f1 = new Fraction(1,32768*3);\n         f2 = new Fraction(1,59049);\n         f = f1.add(f2);\n-        assertEquals(52451, f.getNumerator());\n-        assertEquals(1934917632, f.getDenominator());\n+        Assert.assertEquals(52451, f.getNumerator());\n+        Assert.assertEquals(1934917632, f.getDenominator());\n \n         f1 = new Fraction(Integer.MIN_VALUE, 3);\n         f2 = new Fraction(1,3);\n         f = f1.add(f2);\n-        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n+        Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        Assert.assertEquals(3, f.getDenominator());\n \n         f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n         f2 = Fraction.ONE;\n         f = f1.add(f2);\n-        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n \n         try {\n             f = f.add(Fraction.ONE); // should overflow\n-            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+            Assert.fail(\"expecting MathArithmeticException but got: \" + f.toString());\n         } catch (MathArithmeticException ex) {}\n \n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f2 = new Fraction(-1,5);\n         try {\n             f = f1.add(f2); // should overflow\n-            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+            Assert.fail(\"expecting MathArithmeticException but got: \" + f.toString());\n         } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(3,327680);\n         f2 = new Fraction(2,59049);\n         try {\n             f = f1.add(f2); // should overflow\n-            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n-        } catch (MathArithmeticException ex) {}\n-    }\n-\n+            Assert.fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n+    }\n+\n+    @Test\n     public void testDivide() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n         Fraction f2 = Fraction.ZERO;\n         try {\n             f1.divide(f2);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(0, 5);\n         f2 = new Fraction(2, 7);\n         Fraction f = f1.divide(f2);\n-        assertSame(Fraction.ZERO, f);\n+        Assert.assertSame(Fraction.ZERO, f);\n \n         f1 = new Fraction(2, 7);\n         f2 = Fraction.ONE;\n         f = f1.divide(f2);\n-        assertEquals(2, f.getNumerator());\n-        assertEquals(7, f.getDenominator());\n+        Assert.assertEquals(2, f.getNumerator());\n+        Assert.assertEquals(7, f.getDenominator());\n \n         f1 = new Fraction(1, Integer.MAX_VALUE);\n         f = f1.divide(f1);\n-        assertEquals(1, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(1, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n \n         f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         f2 = new Fraction(1, Integer.MAX_VALUE);\n         f = f1.divide(f2);\n-        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n \n         try {\n             f.divide(null);\n-            fail(\"MathIllegalArgumentException\");\n+            Assert.fail(\"MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n         try {\n             f1 = new Fraction(1, Integer.MAX_VALUE);\n             f = f1.divide(f1.reciprocal());  // should overflow\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n         try {\n             f1 = new Fraction(1, -Integer.MAX_VALUE);\n             f = f1.divide(f1.reciprocal());  // should overflow\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(6, 35);\n         f  = f1.divide(15);\n-        assertEquals(2, f.getNumerator());\n-        assertEquals(175, f.getDenominator());\n-\n-    }\n-\n+        Assert.assertEquals(2, f.getNumerator());\n+        Assert.assertEquals(175, f.getDenominator());\n+\n+    }\n+\n+    @Test\n     public void testMultiply() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n         Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);\n         Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         Fraction f = f1.multiply(f2);\n-        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n \n         try {\n             f.multiply(null);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n         f1 = new Fraction(6, 35);\n         f  = f1.multiply(15);\n-        assertEquals(18, f.getNumerator());\n-        assertEquals(7, f.getDenominator());\n-    }\n-\n+        Assert.assertEquals(18, f.getNumerator());\n+        Assert.assertEquals(7, f.getDenominator());\n+    }\n+\n+    @Test\n     public void testSubtract() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n         Fraction f = new Fraction(1,1);\n         try {\n             f.subtract(null);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n         // if this fraction is subtracted naively, it will overflow.\n         Fraction f1 = new Fraction(1,32768*3);\n         Fraction f2 = new Fraction(1,59049);\n         f = f1.subtract(f2);\n-        assertEquals(-13085, f.getNumerator());\n-        assertEquals(1934917632, f.getDenominator());\n+        Assert.assertEquals(-13085, f.getNumerator());\n+        Assert.assertEquals(1934917632, f.getDenominator());\n \n         f1 = new Fraction(Integer.MIN_VALUE, 3);\n         f2 = new Fraction(1,3).negate();\n         f = f1.subtract(f2);\n-        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n+        Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        Assert.assertEquals(3, f.getDenominator());\n \n         f1 = new Fraction(Integer.MAX_VALUE, 1);\n         f2 = Fraction.ONE;\n         f = f1.subtract(f2);\n-        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n         f = f1.subtract(1);\n-        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n+        Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        Assert.assertEquals(1, f.getDenominator());\n \n         try {\n             f1 = new Fraction(1, Integer.MAX_VALUE);\n             f2 = new Fraction(1, Integer.MAX_VALUE - 1);\n             f = f1.subtract(f2);\n-            fail(\"expecting MathArithmeticException\");  //should overflow\n+            Assert.fail(\"expecting MathArithmeticException\");  //should overflow\n         } catch (MathArithmeticException ex) {}\n \n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f2 = new Fraction(1,5);\n         try {\n             f = f1.subtract(f2); // should overflow\n-            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+            Assert.fail(\"expecting MathArithmeticException but got: \" + f.toString());\n         } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(Integer.MIN_VALUE, 1);\n             f = f.subtract(Fraction.ONE);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(Integer.MAX_VALUE, 1);\n             f = f.subtract(Fraction.ONE.negate());\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(3,327680);\n         f2 = new Fraction(2,59049);\n         try {\n             f = f1.subtract(f2); // should overflow\n-            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n-        } catch (MathArithmeticException ex) {}\n-    }\n-\n+            Assert.fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n+    }\n+\n+    @Test\n     public void testEqualsAndHashCode() {\n         Fraction zero  = new Fraction(0,1);\n         Fraction nullFraction = null;\n-        assertTrue( zero.equals(zero));\n-        assertFalse(zero.equals(nullFraction));\n-        assertFalse(zero.equals(Double.valueOf(0)));\n+        Assert.assertTrue( zero.equals(zero));\n+        Assert.assertFalse(zero.equals(nullFraction));\n+        Assert.assertFalse(zero.equals(Double.valueOf(0)));\n         Fraction zero2 = new Fraction(0,2);\n-        assertTrue(zero.equals(zero2));\n-        assertEquals(zero.hashCode(), zero2.hashCode());\n+        Assert.assertTrue(zero.equals(zero2));\n+        Assert.assertEquals(zero.hashCode(), zero2.hashCode());\n         Fraction one = new Fraction(1,1);\n-        assertFalse((one.equals(zero) ||zero.equals(one)));\n-    }\n-\n+        Assert.assertFalse((one.equals(zero) ||zero.equals(one)));\n+    }\n+\n+    @Test\n     public void testGetReducedFraction() {\n         Fraction threeFourths = new Fraction(3, 4);\n-        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));\n-        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));\n+        Assert.assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));\n+        Assert.assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));\n         try {\n             Fraction.getReducedFraction(1, 0);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // expected\n         }\n-        assertEquals(Fraction.getReducedFraction\n+        Assert.assertEquals(Fraction.getReducedFraction\n                 (2, Integer.MIN_VALUE).getNumerator(),-1);\n-        assertEquals(Fraction.getReducedFraction\n+        Assert.assertEquals(Fraction.getReducedFraction\n                 (1, -1).getNumerator(), -1);\n     }\n \n+    @Test\n     public void testToString() {\n-        assertEquals(\"0\", new Fraction(0, 3).toString());\n-        assertEquals(\"3\", new Fraction(6, 2).toString());\n-        assertEquals(\"2 / 3\", new Fraction(18, 27).toString());\n-    }\n-\n+        Assert.assertEquals(\"0\", new Fraction(0, 3).toString());\n+        Assert.assertEquals(\"3\", new Fraction(6, 2).toString());\n+        Assert.assertEquals(\"2 / 3\", new Fraction(18, 27).toString());\n+    }\n+\n+    @Test\n     public void testSerial() throws FractionConversionException {\n         Fraction[] fractions = {\n             new Fraction(3, 4), Fraction.ONE, Fraction.ZERO,\n             new Fraction(-5, 2)\n         };\n         for (Fraction fraction : fractions) {\n-            assertEquals(fraction, TestUtils.serializeAndRecover(fraction));\n+            Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction));\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/genetics/BinaryChromosomeTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/BinaryChromosomeTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class BinaryChromosomeTest {\n         for (Integer[] repr : reprs) {\n             try {\n                 new DummyBinaryChromosome(repr);\n-                fail(\"Exception not caught\");\n+                Assert.fail(\"Exception not caught\");\n             } catch (IllegalArgumentException e) {\n \n             }\n         Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});\n         Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n \n-        assertFalse(c1.isSame(c2));\n-        assertFalse(c1.isSame(c3));\n-        assertFalse(c1.isSame(c4));\n-        assertFalse(c1.isSame(c5));\n-        assertTrue(c1.isSame(c6));\n+        Assert.assertFalse(c1.isSame(c2));\n+        Assert.assertFalse(c1.isSame(c3));\n+        Assert.assertFalse(c1.isSame(c4));\n+        Assert.assertFalse(c1.isSame(c5));\n+        Assert.assertTrue(c1.isSame(c6));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/genetics/BinaryMutationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/BinaryMutationTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class BinaryMutationTest {\n                 if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j))\n                     numDifferent++;\n             }\n-            assertEquals(1, numDifferent);\n+            Assert.assertEquals(1, numDifferent);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/genetics/ChromosomeTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/ChromosomeTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n import java.util.List;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ChromosomeTest {\n             }\n         };\n \n-        assertTrue(c1.compareTo(c2) < 0);\n-        assertTrue(c2.compareTo(c1) > 0);\n-        assertEquals(0,c3.compareTo(c2));\n-        assertEquals(0,c2.compareTo(c3));\n+        Assert.assertTrue(c1.compareTo(c2) < 0);\n+        Assert.assertTrue(c2.compareTo(c1) > 0);\n+        Assert.assertEquals(0,c3.compareTo(c2));\n+        Assert.assertEquals(0,c2.compareTo(c3));\n     }\n \n     private abstract static class DummyChromosome extends Chromosome {\n             }\n         };\n \n-        assertNull(c5.findSameChromosome(pop));\n-        assertEquals(c1, c4.findSameChromosome(pop));\n+        Assert.assertNull(c5.findSameChromosome(pop));\n+        Assert.assertEquals(c1, c4.findSameChromosome(pop));\n \n         c4.searchForFitnessUpdate(pop);\n-        assertEquals(1, c4.getFitness(),0);\n+        Assert.assertEquals(1, c4.getFitness(),0);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/genetics/ElitisticListPopulationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/ElitisticListPopulationTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ElitisticListPopulationTest {\n \n         Population nextGeneration = pop.nextGeneration();\n \n-        assertEquals(20, nextGeneration.getPopulationSize());\n+        Assert.assertEquals(20, nextGeneration.getPopulationSize());\n     }\n \n     private static class DummyChromosome extends Chromosome {\n--- a/src/test/java/org/apache/commons/math/genetics/FitnessCachingTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/FitnessCachingTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n import java.util.LinkedList;\n import java.util.List;\n+\n+import org.junit.Assert;\n import org.junit.Test;\n \n \n             POPULATION_SIZE /*initial population*/ +\n             (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/\n             ;\n-        assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones\n+        Assert.assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones\n     }\n \n \n--- a/src/test/java/org/apache/commons/math/genetics/FixedGenerationCountTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/FixedGenerationCountTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n import java.util.Iterator;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class FixedGenerationCountTest {\n             }\n         };\n \n-        while (!fgc.isSatisfied(pop))\n+        while (!fgc.isSatisfied(pop)) {\n             cnt++;\n-        assertEquals(20, cnt);\n+        }\n+        Assert.assertEquals(20, cnt);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n import java.util.LinkedList;\n import java.util.List;\n+\n+import org.junit.Assert;\n import org.junit.Test;\n \n /**\n                 new TournamentSelection(TOURNAMENT_ARITY)\n         );\n \n-        assertEquals(0, ga.getGenerationsEvolved());\n+        Assert.assertEquals(0, ga.getGenerationsEvolved());\n \n         // initial population\n         Population initial = randomPopulation();\n         // the only thing we can test is whether the final solution is not worse than the initial one\n         // however, for some implementations of GA, this need not be true :)\n \n-        assertTrue(bestFinal.compareTo(bestInitial) > 0);\n-        assertEquals(NUM_GENERATIONS, ga.getGenerationsEvolved());\n+        Assert.assertTrue(bestFinal.compareTo(bestInitial) > 0);\n+        Assert.assertEquals(NUM_GENERATIONS, ga.getGenerationsEvolved());\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n /**\n         // the only thing we can test is whether the final solution is not worse than the initial one\n         // however, for some implementations of GA, this need not be true :)\n \n-        assertTrue(bestFinal.compareTo(bestInitial) > 0);\n+        Assert.assertTrue(bestFinal.compareTo(bestInitial) > 0);\n \n         //System.out.println(bestInitial);\n         //System.out.println(bestFinal);\n--- a/src/test/java/org/apache/commons/math/genetics/ListPopulationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/ListPopulationTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ListPopulationTest {\n             }\n         };\n \n-        assertEquals(c3, population.getFittestChromosome());\n+        Assert.assertEquals(c3, population.getFittestChromosome());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/genetics/OnePointCrossoverTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/OnePointCrossoverTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class OnePointCrossoverTest {\n             c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);\n \n             // first and last values will be the same\n-            assertEquals((int) p1[0], (int) c1[0]);\n-            assertEquals((int) p2[0], (int) c2[0]);\n-            assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);\n-            assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);\n+            Assert.assertEquals((int) p1[0], (int) c1[0]);\n+            Assert.assertEquals((int) p2[0], (int) c2[0]);\n+            Assert.assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);\n+            Assert.assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);\n             // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same\n-            assertEquals((int) p1[2], (int) c1[2]);\n-            assertEquals((int) p2[2], (int) c2[2]);\n-            assertEquals((int) p1[3], (int) c1[3]);\n-            assertEquals((int) p2[3], (int) c2[3]);\n-            assertEquals((int) p1[7], (int) c1[7]);\n-            assertEquals((int) p2[7], (int) c2[7]);\n+            Assert.assertEquals((int) p1[2], (int) c1[2]);\n+            Assert.assertEquals((int) p2[2], (int) c2[2]);\n+            Assert.assertEquals((int) p1[3], (int) c1[3]);\n+            Assert.assertEquals((int) p2[3], (int) c2[3]);\n+            Assert.assertEquals((int) p1[7], (int) c1[7]);\n+            Assert.assertEquals((int) p2[7], (int) c2[7]);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/genetics/RandomKeyMutationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/RandomKeyMutationTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class RandomKeyMutationTest {\n                     changes++;\n                 }\n             }\n-            assertEquals(1,changes);\n+            Assert.assertEquals(1,changes);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/genetics/RandomKeyTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/RandomKeyTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n \n import java.util.Arrays;\n import java.util.Comparator;\n import java.util.List;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class RandomKeyTest {\n         DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});\n         DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});\n \n-        assertTrue(drk1.isSame(drk2));\n-        assertTrue(drk2.isSame(drk3));\n-        assertFalse(drk3.isSame(drk4));\n-        assertFalse(drk4.isSame(drk5));\n+        Assert.assertTrue(drk1.isSame(drk2));\n+        Assert.assertTrue(drk2.isSame(drk3));\n+        Assert.assertFalse(drk3.isSame(drk4));\n+        Assert.assertFalse(drk4.isSame(drk5));\n     }\n \n     @Test\n         DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n         List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n \n-        assertEquals(\"b\", decoded.get(0));\n-        assertEquals(\"e\", decoded.get(1));\n-        assertEquals(\"a\", decoded.get(2));\n-        assertEquals(\"c\", decoded.get(3));\n-        assertEquals(\"d\", decoded.get(4));\n+        Assert.assertEquals(\"b\", decoded.get(0));\n+        Assert.assertEquals(\"e\", decoded.get(1));\n+        Assert.assertEquals(\"a\", decoded.get(2));\n+        Assert.assertEquals(\"c\", decoded.get(3));\n+        Assert.assertEquals(\"d\", decoded.get(4));\n     }\n \n     @Test\n         // never generate an invalid one\n         for (int i=0; i<10; i++) {\n             DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));\n-            assertNotNull(drk);\n+            Assert.assertNotNull(drk);\n         }\n     }\n \n         DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));\n         List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n \n-        assertEquals(\"a\", decoded.get(0));\n-        assertEquals(\"b\", decoded.get(1));\n-        assertEquals(\"c\", decoded.get(2));\n-        assertEquals(\"d\", decoded.get(3));\n-        assertEquals(\"e\", decoded.get(4));\n+        Assert.assertEquals(\"a\", decoded.get(0));\n+        Assert.assertEquals(\"b\", decoded.get(1));\n+        Assert.assertEquals(\"c\", decoded.get(2));\n+        Assert.assertEquals(\"d\", decoded.get(3));\n+        Assert.assertEquals(\"e\", decoded.get(4));\n     }\n \n     @Test\n         });\n         Double[] permArr = new Double[data.size()];\n         permArr = permutation.toArray(permArr);\n-        assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);\n+        Assert.assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);\n         List<String> decodedData = new DummyRandomKey(permutation).decode(data);\n-        assertEquals(\"b\", decodedData.get(0));\n-        assertEquals(\"b\", decodedData.get(1));\n-        assertEquals(\"c\", decodedData.get(2));\n-        assertEquals(\"x\", decodedData.get(3));\n-        assertEquals(\"z\", decodedData.get(4));\n+        Assert.assertEquals(\"b\", decodedData.get(0));\n+        Assert.assertEquals(\"b\", decodedData.get(1));\n+        Assert.assertEquals(\"c\", decodedData.get(2));\n+        Assert.assertEquals(\"x\", decodedData.get(3));\n+        Assert.assertEquals(\"z\", decodedData.get(4));\n \n         permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n             public int compare(String o1, String o2) {\n         });\n         permArr = new Double[data.size()];\n         permArr = permutation.toArray(permArr);\n-        assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);\n+        Assert.assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);\n         decodedData = new DummyRandomKey(permutation).decode(data);\n-        assertEquals(\"z\", decodedData.get(0));\n-        assertEquals(\"x\", decodedData.get(1));\n-        assertEquals(\"c\", decodedData.get(2));\n-        assertEquals(\"b\", decodedData.get(3));\n-        assertEquals(\"b\", decodedData.get(4));\n+        Assert.assertEquals(\"z\", decodedData.get(0));\n+        Assert.assertEquals(\"x\", decodedData.get(1));\n+        Assert.assertEquals(\"c\", decodedData.get(2));\n+        Assert.assertEquals(\"b\", decodedData.get(3));\n+        Assert.assertEquals(\"b\", decodedData.get(4));\n     }\n \n     @Test\n         DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));\n         List<String> decoded = drk.decode(origData);\n \n-        assertEquals(\"d\", decoded.get(0));\n-        assertEquals(\"b\", decoded.get(1));\n-        assertEquals(\"c\", decoded.get(2));\n-        assertEquals(\"a\", decoded.get(3));\n-        assertEquals(\"d\", decoded.get(4));\n+        Assert.assertEquals(\"d\", decoded.get(0));\n+        Assert.assertEquals(\"b\", decoded.get(1));\n+        Assert.assertEquals(\"c\", decoded.get(2));\n+        Assert.assertEquals(\"a\", decoded.get(3));\n+        Assert.assertEquals(\"d\", decoded.get(4));\n \n         try {\n             RandomKey.inducedPermutation(\n                     Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"}),\n                     Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\"})\n             );\n-            fail(\"Uncaught exception\");\n+            Assert.fail(\"Uncaught exception\");\n         } catch (IllegalArgumentException e) {\n             // no-op\n         }\n                     Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"}),\n                     Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"f\"})\n             );\n-            fail(\"Uncaught exception\");\n+            Assert.fail(\"Uncaught exception\");\n         } catch (IllegalArgumentException e) {\n             // no-op\n         }\n     public void testEqualRepr() {\n         DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});\n         List<String> decodedData = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\"}));\n-        assertEquals(\"a\", decodedData.get(0));\n-        assertEquals(\"b\", decodedData.get(1));\n-        assertEquals(\"c\", decodedData.get(2));\n+        Assert.assertEquals(\"a\", decodedData.get(0));\n+        Assert.assertEquals(\"b\", decodedData.get(1));\n+        Assert.assertEquals(\"c\", decodedData.get(2));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/genetics/TournamentSelectionTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/TournamentSelectionTest.java\n  */\n package org.apache.commons.math.genetics;\n \n-import static org.junit.Assert.*;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class TournamentSelectionTest {\n         for (int i=0; i<20; i++) {\n             ChromosomePair pair = ts.select(pop);\n             // the worst chromosome should NEVER be selected\n-            assertTrue(pair.getFirst().getFitness() > 0);\n-            assertTrue(pair.getSecond().getFitness() > 0);\n+            Assert.assertTrue(pair.getFirst().getFitness() > 0);\n+            Assert.assertTrue(pair.getSecond().getFitness() > 0);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/geometry/RotationOrderTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/RotationOrderTest.java\n import java.lang.reflect.Field;\n \n import org.apache.commons.math.geometry.RotationOrder;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.*;\n \n-public class RotationOrderTest\n-  extends TestCase {\n+public class RotationOrderTest {\n \n-  public RotationOrderTest(String name) {\n-    super(name);\n-  }\n-\n+  @Test\n   public void testName() {\n \n     RotationOrder[] orders = {\n     };\n \n     for (int i = 0; i < orders.length; ++i) {\n-      assertEquals(getFieldName(orders[i]), orders[i].toString());\n+      Assert.assertEquals(getFieldName(orders[i]), orders[i].toString());\n     }\n \n   }\n--- a/src/test/java/org/apache/commons/math/geometry/RotationTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/RotationTest.java\n import org.apache.commons.math.geometry.Vector3D;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n-\n-import junit.framework.*;\n-\n-public class RotationTest\n-  extends TestCase {\n-\n-  public RotationTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class RotationTest {\n+\n+  @Test\n   public void testIdentity() {\n \n     Rotation r = Rotation.IDENTITY;\n \n   }\n \n+  @Test\n   public void testAxisAngle() {\n \n     Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);\n \n     try {\n       new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     }\n \n \n   }\n \n+  @Test\n   public void testRevert() {\n     Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);\n     Rotation reverted = r.revert();\n     checkRotation(r.applyTo(reverted), 1, 0, 0, 0);\n     checkRotation(reverted.applyTo(r), 1, 0, 0, 0);\n-    assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);\n-    assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);\n-  }\n-\n+    Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);\n+    Assert.assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);\n+  }\n+\n+  @Test\n   public void testVectorOnePair() {\n \n     Vector3D u = new Vector3D(3, 2, 1);\n \n     try {\n         new Rotation(u, Vector3D.ZERO);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch (IllegalArgumentException e) {\n         // expected behavior\n     }\n \n   }\n \n+  @Test\n   public void testVectorTwoPairs() {\n \n     Vector3D u1 = new Vector3D(3, 0, 0);\n \n     try {\n         new Rotation(u1, u2, Vector3D.ZERO, v2);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch (IllegalArgumentException e) {\n       // expected behavior\n     }\n \n   }\n \n+  @Test\n   public void testMatrix()\n     throws NotARotationMatrixException {\n \n                      { 0.0, 1.0, 0.0 },\n                      { 1.0, 0.0, 0.0 }\n                    }, 1.0e-7);\n-      fail(\"Expecting NotARotationMatrixException\");\n+      Assert.fail(\"Expecting NotARotationMatrixException\");\n     } catch (NotARotationMatrixException nrme) {\n       // expected behavior\n     }\n                      {  0.821760, -0.184320,  0.539200 },\n                      { -0.354816,  0.574912,  0.737280 }\n                    }, 1.0e-7);\n-      fail(\"Expecting NotARotationMatrixException\");\n+      Assert.fail(\"Expecting NotARotationMatrixException\");\n     } catch (NotARotationMatrixException nrme) {\n       // expected behavior\n     }\n                        { -0.4,  0.6,  0.7 },\n                        {  0.8, -0.2,  0.5 }\n                      }, 1.0e-15);\n-        fail(\"Expecting NotARotationMatrixException\");\n+        Assert.fail(\"Expecting NotARotationMatrixException\");\n       } catch (NotARotationMatrixException nrme) {\n         // expected behavior\n       }\n     double d21 = m2[2][1] - m3[2][1];\n     double d22 = m2[2][2] - m3[2][2];\n \n-    assertTrue(FastMath.abs(d00) < 6.0e-6);\n-    assertTrue(FastMath.abs(d01) < 6.0e-6);\n-    assertTrue(FastMath.abs(d02) < 6.0e-6);\n-    assertTrue(FastMath.abs(d10) < 6.0e-6);\n-    assertTrue(FastMath.abs(d11) < 6.0e-6);\n-    assertTrue(FastMath.abs(d12) < 6.0e-6);\n-    assertTrue(FastMath.abs(d20) < 6.0e-6);\n-    assertTrue(FastMath.abs(d21) < 6.0e-6);\n-    assertTrue(FastMath.abs(d22) < 6.0e-6);\n-\n-    assertTrue(FastMath.abs(d00) > 4.0e-7);\n-    assertTrue(FastMath.abs(d01) > 4.0e-7);\n-    assertTrue(FastMath.abs(d02) > 4.0e-7);\n-    assertTrue(FastMath.abs(d10) > 4.0e-7);\n-    assertTrue(FastMath.abs(d11) > 4.0e-7);\n-    assertTrue(FastMath.abs(d12) > 4.0e-7);\n-    assertTrue(FastMath.abs(d20) > 4.0e-7);\n-    assertTrue(FastMath.abs(d21) > 4.0e-7);\n-    assertTrue(FastMath.abs(d22) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d00) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d01) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d02) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d10) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d11) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d12) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d20) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d21) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d22) < 6.0e-6);\n+\n+    Assert.assertTrue(FastMath.abs(d00) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d01) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d02) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d10) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d11) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d12) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d20) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d21) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d22) > 4.0e-7);\n \n     for (int i = 0; i < 3; ++i) {\n       for (int j = 0; j < 3; ++j) {\n                      + m3[i][1] * m3[j][1]\n                      + m3[i][2] * m3[j][2];\n         if (i == j) {\n-          assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n+          Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n         } else {\n-          assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n+          Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n         }\n       }\n     }\n                         { 0.0, 1.0, 0.0 },\n                         { 1.0, 0.0, 0.0 } };\n       r = new Rotation(m5, 1.0e-7);\n-      fail(\"got \" + r + \", should have caught an exception\");\n+      Assert.fail(\"got \" + r + \", should have caught an exception\");\n     } catch (NotARotationMatrixException e) {\n       // expected\n     }\n \n   }\n \n+  @Test\n   public void testAngles()\n     throws CardanEulerSingularityException {\n \n \n   }\n \n+  @Test\n   public void testSingularities() {\n \n     RotationOrder[] CardanOrders = {\n         Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);\n         try {\n           r.getAngles(CardanOrders[i]);\n-          fail(\"an exception should have been caught\");\n+          Assert.fail(\"an exception should have been caught\");\n         } catch (CardanEulerSingularityException cese) {\n           // expected behavior\n         }\n         Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);\n         try {\n           r.getAngles(EulerOrders[i]);\n-          fail(\"an exception should have been caught\");\n+          Assert.fail(\"an exception should have been caught\");\n         } catch (CardanEulerSingularityException cese) {\n           // expected behavior\n         }\n \n   }\n \n+  @Test\n   public void testQuaternion() {\n \n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n \n   }\n \n+  @Test\n   public void testCompose() {\n \n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n \n   }\n \n+  @Test\n   public void testComposeInverse() {\n \n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n \n   }\n \n+  @Test\n   public void testApplyInverseTo() {\n \n     Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n   }\n \n   private void checkVector(Vector3D v1, Vector3D v2) {\n-    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n+    Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n   }\n \n   private void checkAngle(double a1, double a2) {\n-    assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);\n+    Assert.assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);\n   }\n \n   private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {\n-    assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);\n+    Assert.assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);\n   }\n \n }\n--- a/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n         }\n     }\n \n-    private static void assertEquals(double[] d1, double[] d2) {\n-        Assert.assertEquals(d1.length, d2.length);\n-        for(int i=0; i<d1.length; i++) Assert.assertEquals(d1[i], d2[i], 0);\n-    }\n-\n     @Test\n     public void testMap() throws Exception {\n         double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };\n         RealVector v = new TestVectorImpl(vec1.clone());\n         RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });\n-        assertEquals(vec1Squared, w.getData());\n+        double[] d2 = w.getData();\n+        Assert.assertEquals(vec1Squared.length, d2.length);\n+        for(int i=0; i<vec1Squared.length; i++) {\n+            Assert.assertEquals(vec1Squared[i], d2[i], 0);\n+        }\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n \n-import junit.framework.TestCase;\n-\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n-import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link ArrayFieldVector} class.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class ArrayFieldVectorTest extends TestCase {\n+public class ArrayFieldVectorTest {\n \n     //\n     protected Fraction[][] ma1 = {\n \n     }\n \n+    @Test\n     public void testConstructors() {\n \n         ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance());\n-        assertEquals(0, v0.getDimension());\n+        Assert.assertEquals(0, v0.getDimension());\n \n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7);\n-        assertEquals(7, v1.getDimension());\n-        assertEquals(new Fraction(0), v1.getEntry(6));\n+        Assert.assertEquals(7, v1.getDimension());\n+        Assert.assertEquals(new Fraction(0), v1.getEntry(6));\n \n         ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100));\n-        assertEquals(5, v2.getDimension());\n-        assertEquals(new Fraction(123, 100), v2.getEntry(4));\n+        Assert.assertEquals(5, v2.getDimension());\n+        Assert.assertEquals(new Fraction(123, 100), v2.getEntry(4));\n \n         ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);\n-        assertEquals(3, v3.getDimension());\n-        assertEquals(new Fraction(2), v3.getEntry(1));\n+        Assert.assertEquals(3, v3.getDimension());\n+        Assert.assertEquals(new Fraction(2), v3.getEntry(1));\n \n         ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);\n-        assertEquals(2, v4.getDimension());\n-        assertEquals(new Fraction(4), v4.getEntry(0));\n+        Assert.assertEquals(2, v4.getDimension());\n+        Assert.assertEquals(new Fraction(4), v4.getEntry(0));\n         try {\n             new ArrayFieldVector<Fraction>(vec4, 8, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1);\n-        assertEquals(9, v5_i.getDimension());\n-        assertEquals(new Fraction(9), v5_i.getEntry(8));\n+        Assert.assertEquals(9, v5_i.getDimension());\n+        Assert.assertEquals(new Fraction(9), v5_i.getEntry(8));\n \n         ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1);\n-        assertEquals(9, v5.getDimension());\n-        assertEquals(new Fraction(9), v5.getEntry(8));\n+        Assert.assertEquals(9, v5.getDimension());\n+        Assert.assertEquals(new Fraction(9), v5.getEntry(8));\n \n         ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2);\n-        assertEquals(2, v6.getDimension());\n-        assertEquals(new Fraction(4), v6.getEntry(0));\n+        Assert.assertEquals(2, v6.getDimension());\n+        Assert.assertEquals(new Fraction(4), v6.getEntry(0));\n         try {\n             new ArrayFieldVector<Fraction>(dvec1, 8, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1);\n-        assertEquals(7, v7.getDimension());\n-        assertEquals(new Fraction(0), v7.getEntry(6));\n+        Assert.assertEquals(7, v7.getDimension());\n+        Assert.assertEquals(new Fraction(0), v7.getEntry(6));\n \n         FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);\n \n         ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i);\n-        assertEquals(3, v7_2.getDimension());\n-        assertEquals(new Fraction(2), v7_2.getEntry(1));\n+        Assert.assertEquals(3, v7_2.getDimension());\n+        Assert.assertEquals(new Fraction(2), v7_2.getEntry(1));\n \n         ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true);\n-        assertEquals(7, v8.getDimension());\n-        assertEquals(new Fraction(0), v8.getEntry(6));\n-        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+        Assert.assertEquals(7, v8.getDimension());\n+        Assert.assertEquals(new Fraction(0), v8.getEntry(6));\n+        Assert.assertNotSame(\"testData not same object \", v1.data, v8.data);\n \n         ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false);\n-        assertEquals(7, v8_2.getDimension());\n-        assertEquals(new Fraction(0), v8_2.getEntry(6));\n-        assertEquals(v1.data, v8_2.data);\n+        Assert.assertEquals(7, v8_2.getDimension());\n+        Assert.assertEquals(new Fraction(0), v8_2.getEntry(6));\n+        Assert.assertArrayEquals(v1.data, v8_2.data);\n \n         ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3);\n-        assertEquals(10, v9.getDimension());\n-        assertEquals(new Fraction(1), v9.getEntry(7));\n-\n-    }\n-\n+        Assert.assertEquals(10, v9.getDimension());\n+        Assert.assertEquals(new Fraction(1), v9.getEntry(7));\n+\n+    }\n+\n+    @Test\n     public void testDataInOut() {\n \n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n         FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);\n \n         FieldVector<Fraction> v_append_1 = v1.append(v2);\n-        assertEquals(6, v_append_1.getDimension());\n-        assertEquals(new Fraction(4), v_append_1.getEntry(3));\n+        Assert.assertEquals(6, v_append_1.getDimension());\n+        Assert.assertEquals(new Fraction(4), v_append_1.getEntry(3));\n \n         FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));\n-        assertEquals(4, v_append_2.getDimension());\n-        assertEquals(new Fraction(2), v_append_2.getEntry(3));\n+        Assert.assertEquals(4, v_append_2.getDimension());\n+        Assert.assertEquals(new Fraction(2), v_append_2.getEntry(3));\n \n         FieldVector<Fraction> v_append_3 = v1.append(vec2);\n-        assertEquals(6, v_append_3.getDimension());\n-        assertEquals(new Fraction(4), v_append_3.getEntry(3));\n+        Assert.assertEquals(6, v_append_3.getDimension());\n+        Assert.assertEquals(new Fraction(4), v_append_3.getEntry(3));\n \n         FieldVector<Fraction> v_append_4 = v1.append(v2_t);\n-        assertEquals(6, v_append_4.getDimension());\n-        assertEquals(new Fraction(4), v_append_4.getEntry(3));\n+        Assert.assertEquals(6, v_append_4.getDimension());\n+        Assert.assertEquals(new Fraction(4), v_append_4.getEntry(3));\n \n         FieldVector<Fraction> v_copy = v1.copy();\n-        assertEquals(3, v_copy.getDimension());\n-        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+        Assert.assertEquals(3, v_copy.getDimension());\n+        Assert.assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n \n         Fraction[] a_frac = v1.toArray();\n-        assertEquals(3, a_frac.length);\n-        assertNotSame(\"testData not same object \", v1.data, a_frac);\n+        Assert.assertEquals(3, a_frac.length);\n+        Assert.assertNotSame(\"testData not same object \", v1.data, a_frac);\n \n \n //      ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone();\n-//      assertEquals(3, vout4.getDimension());\n-//      assertEquals(v1.data, vout4.data);\n+//      Assert.assertEquals(3, vout4.getDimension());\n+//      Assert.assertEquals(v1.data, vout4.data);\n \n \n         FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);\n-        assertEquals(3, vout5.getDimension());\n-        assertEquals(new Fraction(5), vout5.getEntry(1));\n+        Assert.assertEquals(3, vout5.getDimension());\n+        Assert.assertEquals(new Fraction(5), vout5.getEntry(1));\n         try {\n             v4.getSubVector(3, 7);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy();\n         v_set1.setEntry(1, new Fraction(11));\n-        assertEquals(new Fraction(11), v_set1.getEntry(1));\n+        Assert.assertEquals(new Fraction(11), v_set1.getEntry(1));\n         try {\n             v_set1.setEntry(3, new Fraction(11));\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy();\n         v_set2.set(3, v1);\n-        assertEquals(new Fraction(1), v_set2.getEntry(3));\n-        assertEquals(new Fraction(7), v_set2.getEntry(6));\n+        Assert.assertEquals(new Fraction(1), v_set2.getEntry(3));\n+        Assert.assertEquals(new Fraction(7), v_set2.getEntry(6));\n         try {\n             v_set2.set(7, v1);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy();\n         v_set3.set(new Fraction(13));\n-        assertEquals(new Fraction(13), v_set3.getEntry(2));\n+        Assert.assertEquals(new Fraction(13), v_set3.getEntry(2));\n \n         try {\n             v_set3.getEntry(23);\n-            fail(\"ArrayIndexOutOfBoundsException expected\");\n+            Assert.fail(\"ArrayIndexOutOfBoundsException expected\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected behavior\n         }\n \n         ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy();\n         v_set4.setSubVector(3, v2_t);\n-        assertEquals(new Fraction(4), v_set4.getEntry(3));\n-        assertEquals(new Fraction(7), v_set4.getEntry(6));\n+        Assert.assertEquals(new Fraction(4), v_set4.getEntry(3));\n+        Assert.assertEquals(new Fraction(7), v_set4.getEntry(6));\n         try {\n             v_set4.setSubVector(7, v2_t);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();\n         ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();\n-        assertEquals(vout10, vout10_2);\n+        Assert.assertEquals(vout10, vout10_2);\n         vout10_2.setEntry(0, new Fraction(11, 10));\n-        assertNotSame(vout10, vout10_2);\n-\n-    }\n-\n+        Assert.assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    @Test\n     public void testMapFunctions() {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n \n \n     }\n \n+    @Test\n     public void testBasicFunctions() {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n         ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n \n         // octave  dot(v1,v2)\n         Fraction dot =  v1.dotProduct(v2);\n-        assertEquals(\"compare val \",new Fraction(32), dot);\n+        Assert.assertEquals(\"compare val \",new Fraction(32), dot);\n \n         // octave  dot(v1,v2_t)\n         Fraction dot_2 =  v1.dotProduct(v2_t);\n-        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+        Assert.assertEquals(\"compare val \",new Fraction(32), dot_2);\n \n         FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n-        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n \n         FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n-        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n \n         ArrayFieldVector<Fraction> v_projection = v1.projection(v2);\n         Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n \n     }\n \n+    @Test\n     public void testMisc() {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n         ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n         FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);\n \n         String out1 = v1.toString();\n-        assertTrue(\"some output \",  out1.length()!=0);\n+        Assert.assertTrue(\"some output \",  out1.length()!=0);\n         /*\n          Fraction[] dout1 = v1.copyOut();\n-        assertEquals(3, dout1.length);\n+        Assert.assertEquals(3, dout1.length);\n         assertNotSame(\"testData not same object \", v1.data, dout1);\n          */\n         try {\n             v1.checkVectorDimensions(2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n        try {\n             v1.checkVectorDimensions(v4);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         try {\n             v1.checkVectorDimensions(v4_2);\n-            fail(\"MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected behavior\n-        }\n-\n-    }\n-\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n     public void testSerial()  {\n         ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);\n-        assertEquals(v,TestUtils.serializeAndRecover(v));\n-    }\n-\n+        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));\n+    }\n+\n+    @Test\n     public void testZeroVectors() {\n \n         // when the field is not specified, array cannot be empty\n         try {\n             new ArrayFieldVector<Fraction>(new Fraction[0]);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n         try {\n             new ArrayFieldVector<Fraction>(new Fraction[0], true);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n         try {\n             new ArrayFieldVector<Fraction>(new Fraction[0], false);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         // when the field is specified, array can be empty\n-        assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0]).getDimension());\n-        assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], true).getDimension());\n-        assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], false).getDimension());\n+        Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0]).getDimension());\n+        Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], true).getDimension());\n+        Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], false).getDimension());\n \n     }\n \n     /** verifies that two vectors are equals */\n     protected void checkArray(String msg, Fraction[] m, Fraction[] n) {\n         if (m.length != n.length) {\n-            fail(\"vectors have different lengths\");\n+            Assert.fail(\"vectors have different lengths\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+            Assert.assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n-public class CholeskySolverTest extends TestCase {\n+public class CholeskySolverTest {\n \n     private double[][] testData = new double[][] {\n             {  1,  2,   4,   7,  11 },\n             { 11, 58, 182, 430, 855 }\n     };\n \n-    public CholeskySolverTest(String name) {\n-        super(name);\n-    }\n-\n     /** test solve dimension errors */\n+    @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n             new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n \n     /** test solve */\n+    @Test\n     public void testSolve() {\n         DecompositionSolver solver =\n             new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n         });\n \n         // using RealMatrix\n-        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         // using ArrayRealVector\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             ArrayRealVectorTest.RealVectorTestImpl v =\n                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n     }\n \n     /** test determinant */\n+    @Test\n     public void testDeterminant() {\n-        assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n+        Assert.assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n     }\n \n     private double getDeterminant(RealMatrix m) {\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n import java.util.Arrays;\n import java.util.Random;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n-\n-public class EigenDecompositionImplTest extends TestCase {\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class EigenDecompositionImplTest {\n \n     private double[] refValues;\n     private RealMatrix matrix;\n \n-    public EigenDecompositionImplTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testDimension1() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n-    }\n-\n+        Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n+    }\n+\n+    @Test\n     public void testDimension2() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n                     { 12.0, 66.0 }\n             });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n-        assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n-    }\n-\n+        Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n+    }\n+\n+    @Test\n     public void testDimension3() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n                                    { -16560.0,  7920.0,  17300.0 }\n                                });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n-        assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n-        assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n-    }\n-\n+        Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n+        Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n+        Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n+    }\n+\n+    @Test\n     public void testDimension3MultipleRoot() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n                     { 15,   30,   45 }\n             });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);\n-        assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);\n-        assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);\n-    }\n-\n+        Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);\n+        Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);\n+        Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);\n+    }\n+\n+    @Test\n     public void testDimension4WithSplit() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n                                    {  0.000,  0.000, -0.048,  0.136 }\n                                });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n-        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n-        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n-        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n-    }\n-\n+        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n+    }\n+\n+    @Test\n     public void testDimension4WithoutSplit() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n                                });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n-        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n-        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n-        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n+        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n     }\n \n     // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0\n+    @Test\n     public void testMath308() {\n \n         double[] mainTridiagonal = {\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n-            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n-            assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n-        }\n-\n-    }\n-\n+            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n+            Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n+        }\n+\n+    }\n+\n+    @Test\n     public void testMathpbx02() {\n \n         double[] mainTridiagonal = {\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n-            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n+            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n-                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n             } else {\n-                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n             }\n         }\n \n     }\n \n+    @Test\n     public void testMathpbx03() {\n \n         double[] mainTridiagonal = {\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n-            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);\n+            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);\n             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n-                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n             } else {\n-                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n             }\n         }\n \n     }\n \n     /** test a matrix already in tridiagonal form. */\n+    @Test\n     public void testTridiagonal() {\n         Random r = new Random(4366663527842l);\n         double[] ref = new double[30];\n                                        t.getSecondaryDiagonalRef(),\n                                        MathUtils.SAFE_MIN);\n         double[] eigenValues = ed.getRealEigenvalues();\n-        assertEquals(ref.length, eigenValues.length);\n+        Assert.assertEquals(ref.length, eigenValues.length);\n         for (int i = 0; i < ref.length; ++i) {\n-            assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n+            Assert.assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n         }\n \n     }\n \n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         final int m = matrix.getRowDimension();\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(m, ed.getV().getRowDimension());\n-        assertEquals(m, ed.getV().getColumnDimension());\n-        assertEquals(m, ed.getD().getColumnDimension());\n-        assertEquals(m, ed.getD().getColumnDimension());\n-        assertEquals(m, ed.getVT().getRowDimension());\n-        assertEquals(m, ed.getVT().getColumnDimension());\n+        Assert.assertEquals(m, ed.getV().getRowDimension());\n+        Assert.assertEquals(m, ed.getV().getColumnDimension());\n+        Assert.assertEquals(m, ed.getD().getColumnDimension());\n+        Assert.assertEquals(m, ed.getD().getColumnDimension());\n+        Assert.assertEquals(m, ed.getVT().getRowDimension());\n+        Assert.assertEquals(m, ed.getVT().getColumnDimension());\n     }\n \n     /** test eigenvalues */\n+    @Test\n     public void testEigenvalues() {\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         double[] eigenValues = ed.getRealEigenvalues();\n-        assertEquals(refValues.length, eigenValues.length);\n+        Assert.assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n-            assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n+            Assert.assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n         }\n     }\n \n     /** test eigenvalues for a big matrix. */\n+    @Test\n     public void testBigMatrix() {\n         Random r = new Random(17748333525117l);\n         double[] bigValues = new double[200];\n         EigenDecomposition ed =\n             new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);\n         double[] eigenValues = ed.getRealEigenvalues();\n-        assertEquals(bigValues.length, eigenValues.length);\n+        Assert.assertEquals(bigValues.length, eigenValues.length);\n         for (int i = 0; i < bigValues.length; ++i) {\n-            assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n+            Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n         }\n     }\n \n     /** test eigenvectors */\n+    @Test\n     public void testEigenvectors() {\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n             double lambda = ed.getRealEigenvalue(i);\n             RealVector v  = ed.getEigenvector(i);\n             RealVector mV = matrix.operate(v);\n-            assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n+            Assert.assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n         }\n     }\n \n     /** test A = VDVt */\n+    @Test\n     public void testAEqualVDVt() {\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         RealMatrix v  = ed.getV();\n         RealMatrix d  = ed.getD();\n         RealMatrix vT = ed.getVT();\n         double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();\n-        assertEquals(0, norm, 6.0e-13);\n+        Assert.assertEquals(0, norm, 6.0e-13);\n     }\n \n     /** test that V is orthogonal */\n+    @Test\n     public void testVOrthogonal() {\n         RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();\n         RealMatrix vTv = v.transpose().multiply(v);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n-        assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n+        Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n     }\n \n     /** test diagonal matrix */\n+    @Test\n     public void testDiagonal() {\n         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n         RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n         EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);\n-        assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n-        assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n-        assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n-        assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);\n+        Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n+        Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n+        Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n+        Assert.assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);\n     }\n \n     /**\n      * Matrix with eigenvalues {8, -1, -1}\n      */\n+    @Test\n     public void testRepeatedEigenvalue() {\n         RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {\n                 {3,  2,  4},\n     /**\n      * Matrix with eigenvalues {2, 0, 12}\n      */\n+    @Test\n     public void testDistinctEigenvalues() {\n         RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {\n                 {3, 1, -4},\n     /**\n      * Verifies operation on indefinite matrix\n      */\n+    @Test\n     public void testZeroDivide() {\n         RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {\n                 { 0.0, 1.0, -1.0 },\n             EigenDecomposition ed, double tolerance) {\n         double[] observed = ed.getRealEigenvalues();\n         for (int i = 0; i < observed.length; i++) {\n-            assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n-            assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n+            Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n+            Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n         }\n     }\n \n      */\n     protected void checkEigenVector(double[] eigenVector,\n             EigenDecomposition ed, double tolerance) {\n-        assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n+        Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n     }\n \n     /**\n         return found;\n     }\n \n-    @Override\n+    @Before\n     public void setUp() {\n         refValues = new double[] {\n                 2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n         matrix = createTestMatrix(new Random(35992629946426l), refValues);\n     }\n \n-    @Override\n+    @After\n     public void tearDown() {\n         refValues = null;\n         matrix    = null;\n--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n \n import java.math.BigDecimal;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link MatrixUtils} class.\n  * @version $Revision$ $Date$\n  */\n \n-public final class MatrixUtilsTest extends TestCase {\n+public final class MatrixUtilsTest {\n \n     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n     protected double[][] nullMatrix = null;\n     protected Fraction[][] fractionColMatrix =\n         {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}};\n \n-    public MatrixUtilsTest(String name) {\n-        super(name);\n-    }\n-\n-\n+    @Test\n     public void testCreateRealMatrix() {\n-        assertEquals(new BlockRealMatrix(testData),\n+        Assert.assertEquals(new BlockRealMatrix(testData),\n                 MatrixUtils.createRealMatrix(testData));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createRealMatrix(null);  // null\n-            fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testcreateFieldMatrix() {\n-        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),\n+        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),\n                      MatrixUtils.createFieldMatrix(asFraction(testData)));\n-        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),\n+        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),\n                      MatrixUtils.createFieldMatrix(fractionColMatrix));\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createFieldMatrix((Fraction[][])null);  // null\n-            fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testCreateRowRealMatrix() {\n-        assertEquals(MatrixUtils.createRowRealMatrix(row),\n+        Assert.assertEquals(MatrixUtils.createRowRealMatrix(row),\n                      new BlockRealMatrix(rowMatrix));\n         try {\n             MatrixUtils.createRowRealMatrix(new double[] {});  // empty\n-            fail(\"Expecting NotStrictlyPositiveException\");\n+            Assert.fail(\"Expecting NotStrictlyPositiveException\");\n         } catch (NotStrictlyPositiveException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createRowRealMatrix(null);  // null\n-            fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testCreateRowFieldMatrix() {\n-        assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),\n+        Assert.assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),\n                      new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));\n-        assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),\n+        Assert.assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),\n                      new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));\n         try {\n             MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null\n-            fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testCreateColumnRealMatrix() {\n-        assertEquals(MatrixUtils.createColumnRealMatrix(col),\n+        Assert.assertEquals(MatrixUtils.createColumnRealMatrix(col),\n                      new BlockRealMatrix(colMatrix));\n         try {\n             MatrixUtils.createColumnRealMatrix(new double[] {});  // empty\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createColumnRealMatrix(null);  // null\n-            fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testCreateColumnFieldMatrix() {\n-        assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),\n+        Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),\n                      new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));\n-        assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),\n+        Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),\n                      new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));\n \n         try {\n             MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null\n-            fail(\"Expecting NullArgumentException\");\n+            Assert.fail(\"Expecting NullArgumentException\");\n         } catch (NullArgumentException ex) {\n             // expected\n         }\n         for (int i = 0; i < m.getRowDimension(); i++) {\n             for (int j =0; j < m.getColumnDimension(); j++) {\n                 if (i == j) {\n-                    assertEquals(m.getEntry(i, j), 1d, 0);\n+                    Assert.assertEquals(m.getEntry(i, j), 1d, 0);\n                 } else {\n-                    assertEquals(m.getEntry(i, j), 0d, 0);\n+                    Assert.assertEquals(m.getEntry(i, j), 0d, 0);\n                 }\n             }\n         }\n     }\n \n+    @Test\n     public void testCreateIdentityMatrix() {\n         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));\n         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));\n         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));\n         try {\n             MatrixUtils.createRealIdentityMatrix(0);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         for (int i = 0; i < m.getRowDimension(); i++) {\n             for (int j =0; j < m.getColumnDimension(); j++) {\n                 if (i == j) {\n-                    assertEquals(m.getEntry(i, j), Fraction.ONE);\n+                    Assert.assertEquals(m.getEntry(i, j), Fraction.ONE);\n                 } else {\n-                    assertEquals(m.getEntry(i, j), Fraction.ZERO);\n+                    Assert.assertEquals(m.getEntry(i, j), Fraction.ZERO);\n                 }\n             }\n         }\n     }\n \n+    @Test\n     public void testcreateFieldIdentityMatrix() {\n         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3));\n         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2));\n         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1));\n         try {\n             MatrixUtils.createRealIdentityMatrix(0);\n-            fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testBigFractionConverter() {\n         BigFraction[][] bfData = {\n                 { new BigFraction(1), new BigFraction(2), new BigFraction(3) },\n         FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false);\n         RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m);\n         RealMatrix reference = new Array2DRowRealMatrix(testData, false);\n-        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n-    }\n-\n+        Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n+    }\n+\n+    @Test\n     public void testFractionConverter() {\n         Fraction[][] fData = {\n                 { new Fraction(1), new Fraction(2), new Fraction(3) },\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false);\n         RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m);\n         RealMatrix reference = new Array2DRowRealMatrix(testData, false);\n-        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n+        Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n     }\n \n     public static final Fraction[][] asFraction(double[][] data) {\n                 d[i] = dI;\n             }\n         } catch (FractionConversionException fce) {\n-            fail(fce.getMessage());\n+            Assert.fail(fce.getMessage());\n         }\n         return d;\n     }\n                 d[i] = new Fraction(data[i]);\n             }\n         } catch (FractionConversionException fce) {\n-            fail(fce.getMessage());\n+            Assert.fail(fce.getMessage());\n         }\n         return d;\n     }\n--- a/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n import java.util.Random;\n \n import org.apache.commons.math.exception.MathUserException;\n-\n-import junit.framework.TestCase;\n-\n-public class QRDecompositionImplTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class QRDecompositionImplTest {\n     double[][] testData3x3NonSingular = {\n             { 12, -51, 4 },\n             { 6, 167, -68 },\n \n     private static final double normTolerance = 10e-14;\n \n-    public QRDecompositionImplTest(String name) {\n-        super(name);\n-    }\n-\n     /** test dimensions \n      * @throws MathUserException */\n+    @Test\n     public void testDimensions() throws MathUserException {\n         checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n         int rows = m.getRowDimension();\n         int columns = m.getColumnDimension();\n         QRDecomposition qr = new QRDecompositionImpl(m);\n-        assertEquals(rows,    qr.getQ().getRowDimension());\n-        assertEquals(rows,    qr.getQ().getColumnDimension());\n-        assertEquals(rows,    qr.getR().getRowDimension());\n-        assertEquals(columns, qr.getR().getColumnDimension());\n+        Assert.assertEquals(rows,    qr.getQ().getRowDimension());\n+        Assert.assertEquals(rows,    qr.getQ().getColumnDimension());\n+        Assert.assertEquals(rows,    qr.getR().getRowDimension());\n+        Assert.assertEquals(columns, qr.getR().getColumnDimension());\n     }\n \n     /** test A = QR \n      * @throws MathUserException */\n+    @Test\n     public void testAEqualQR() throws MathUserException {\n         checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n     private void checkAEqualQR(RealMatrix m) {\n         QRDecomposition qr = new QRDecompositionImpl(m);\n         double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        Assert.assertEquals(0, norm, normTolerance);\n     }\n \n     /** test the orthogonality of Q \n      * @throws MathUserException */\n+    @Test\n     public void testQOrthogonal() throws MathUserException {\n         checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n         QRDecomposition qr = new QRDecompositionImpl(m);\n         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());\n         double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        Assert.assertEquals(0, norm, normTolerance);\n     }\n \n     /** test that R is upper triangular */\n+    @Test\n     public void testRUpperTriangular() throws MathUserException {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n             @Override\n             public void visit(int row, int column, double value) {\n                 if (column < row) {\n-                    assertEquals(0.0, value, entryTolerance);\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n                 }\n             }\n         });\n \n     /** test that H is trapezoidal \n      * @throws MathUserException */\n+    @Test\n     public void testHTrapezoidal() throws MathUserException {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n         checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n             @Override\n             public void visit(int row, int column, double value) {\n                 if (column > row) {\n-                    assertEquals(0.0, value, entryTolerance);\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n                 }\n             }\n         });\n     }\n     /** test matrices values */\n+    @Test\n     public void testMatricesValues() {\n         QRDecomposition qr =\n             new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n \n         // check values against known references\n         RealMatrix q = qr.getQ();\n-        assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n         RealMatrix qT = qr.getQT();\n-        assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n         RealMatrix r = qr.getR();\n-        assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n         RealMatrix h = qr.getH();\n-        assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n+        Assert.assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n \n         // check the same cached instance is returned the second time\n-        assertTrue(q == qr.getQ());\n-        assertTrue(r == qr.getR());\n-        assertTrue(h == qr.getH());\n+        Assert.assertTrue(q == qr.getQ());\n+        Assert.assertTrue(r == qr.getR());\n+        Assert.assertTrue(h == qr.getH());\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n \n import java.util.Random;\n \n-import junit.framework.TestCase;\n-\n-public class SingularValueDecompositionImplTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class SingularValueDecompositionImplTest {\n \n     private double[][] testSquare = {\n             { 24.0 / 25.0, 43.0 / 25.0 },\n \n     private static final double normTolerance = 10e-14;\n \n-    public SingularValueDecompositionImplTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testMoreRows() {\n         final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n         final int rows    = singularValues.length + 2;\n         SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));\n         double[] computedSV = svd.getSingularValues();\n-        assertEquals(singularValues.length, computedSV.length);\n+        Assert.assertEquals(singularValues.length, computedSV.length);\n         for (int i = 0; i < singularValues.length; ++i) {\n-            assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+            Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n         }\n     }\n \n+    @Test\n     public void testMoreColumns() {\n         final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n         final int rows    = singularValues.length;\n         SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));\n         double[] computedSV = svd.getSingularValues();\n-        assertEquals(singularValues.length, computedSV.length);\n+        Assert.assertEquals(singularValues.length, computedSV.length);\n         for (int i = 0; i < singularValues.length; ++i) {\n-            assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+            Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n         }\n     }\n \n     /** test dimensions */\n+    @Test\n     public void testDimensions() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);\n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n         SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n-        assertEquals(m, svd.getU().getRowDimension());\n-        assertEquals(m, svd.getU().getColumnDimension());\n-        assertEquals(m, svd.getS().getColumnDimension());\n-        assertEquals(n, svd.getS().getColumnDimension());\n-        assertEquals(n, svd.getV().getRowDimension());\n-        assertEquals(n, svd.getV().getColumnDimension());\n+        Assert.assertEquals(m, svd.getU().getRowDimension());\n+        Assert.assertEquals(m, svd.getU().getColumnDimension());\n+        Assert.assertEquals(m, svd.getS().getColumnDimension());\n+        Assert.assertEquals(n, svd.getS().getColumnDimension());\n+        Assert.assertEquals(n, svd.getV().getRowDimension());\n+        Assert.assertEquals(n, svd.getV().getColumnDimension());\n \n     }\n \n     /** Test based on a dimension 4 Hadamard matrix. */\n+    @Test\n     public void testHadamard() {\n         RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {\n                 {15.0 / 2.0,  5.0 / 2.0,  9.0 / 2.0,  3.0 / 2.0 },\n                 { 3.0 / 2.0,  9.0 / 2.0,  5.0 / 2.0, 15.0 / 2.0 }\n         }, false);\n         SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n-        assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);\n-        assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);\n-        assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);\n-        assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);\n+        Assert.assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);\n+        Assert.assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);\n+        Assert.assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);\n+        Assert.assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);\n \n         RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] {\n                 {  85.0 / 1024, -51.0 / 1024, -75.0 / 1024,  45.0 / 1024 },\n                 { -75.0 / 1024,  45.0 / 1024,  85.0 / 1024, -51.0 / 1024 },\n                 {  45.0 / 1024, -75.0 / 1024, -51.0 / 1024,  85.0 / 1024 }\n         }, false);\n-        assertEquals(0.0,\n+        Assert.assertEquals(0.0,\n                      fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),\n                      1.0e-14);\n \n                 {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },\n                 {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 }\n         }, false);\n-        assertEquals(0.0,\n+        Assert.assertEquals(0.0,\n                      halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),\n                      1.0e-14);\n \n     }\n \n     /** test A = USVt */\n+    @Test\n     public void testAEqualUSVt() {\n         checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));\n         checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));\n         RealMatrix s = svd.getS();\n         RealMatrix v = svd.getV();\n         double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();\n-        assertEquals(0, norm, normTolerance);\n+        Assert.assertEquals(0, norm, normTolerance);\n \n     }\n \n     /** test that U is orthogonal */\n+    @Test\n     public void testUOrthogonal() {\n         checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getU());\n         checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getU());\n     }\n \n     /** test that V is orthogonal */\n+    @Test\n     public void testVOrthogonal() {\n         checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getV());\n         checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getV());\n     public void checkOrthogonal(final RealMatrix m) {\n         RealMatrix mTm = m.transpose().multiply(m);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n-        assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);\n+        Assert.assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);\n     }\n \n     /** test matrices values */\n+    @Test\n     public void testMatricesValues1() {\n        SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n \n         // check values against known references\n         RealMatrix u = svd.getU();\n-        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n         RealMatrix s = svd.getS();\n-        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n         RealMatrix v = svd.getV();\n-        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n \n         // check the same cached instance is returned the second time\n-        assertTrue(u == svd.getU());\n-        assertTrue(s == svd.getS());\n-        assertTrue(v == svd.getV());\n+        Assert.assertTrue(u == svd.getU());\n+        Assert.assertTrue(s == svd.getS());\n+        Assert.assertTrue(v == svd.getV());\n \n     }\n \n         SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare));\n         RealMatrix u = svd.getU();\n-        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n         RealMatrix s = svd.getS();\n-        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n         RealMatrix v = svd.getV();\n-        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n \n         // check the same cached instance is returned the second time\n-        assertTrue(u == svd.getU());\n-        assertTrue(s == svd.getS());\n-        assertTrue(v == svd.getV());\n+        Assert.assertTrue(u == svd.getU());\n+        Assert.assertTrue(s == svd.getS());\n+        Assert.assertTrue(v == svd.getV());\n \n     }\n \n     /** test condition number */\n+    @Test\n     public void testConditionNumber() {\n         SingularValueDecompositionImpl svd =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n         // replace 1.0e-15 with 1.5e-15\n-        assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);\n+        Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);\n     }\n \n     private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n     }\n \n     /* Disable for now\n+    @Test\n     public void testToString() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n         Assert.assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n import org.apache.commons.math.fraction.FractionConversionException;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the {@link SparseFieldVector} class.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class SparseFieldVectorTest extends TestCase {\n+public class SparseFieldVectorTest {\n \n     //\n     protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};\n \n     protected FractionField field = FractionField.getInstance();\n \n+    @Test\n     public void testMapFunctions() throws FractionConversionException {\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n \n         //octave =  v1 .+ 2.0\n         FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));\n         Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};\n-        assertEquals(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n \n         //octave =  v1 .+ 2.0\n         FieldVector<Fraction> v_mapAddToSelf = v1.copy();\n         v_mapAddToSelf.mapAddToSelf(new Fraction(2));\n         Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};\n-        assertEquals(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n \n         //octave =  v1 .- 2.0\n         FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));\n         Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n-        assertEquals(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n \n         //octave =  v1 .- 2.0\n         FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();\n         v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));\n         Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n-        assertEquals(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n \n         //octave =  v1 .* 2.0\n         FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));\n         Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};\n-        assertEquals(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n \n         //octave =  v1 .* 2.0\n         FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();\n         v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));\n         Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};\n-        assertEquals(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n \n         //octave =  v1 ./ 2.0\n         FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));\n         Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};\n-        assertEquals(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n \n         //octave =  v1 ./ 2.0\n         FieldVector<Fraction> v_mapDivideToSelf = v1.copy();\n         v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));\n         Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};\n-        assertEquals(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n \n         //octave =  v1 .^-1\n         FieldVector<Fraction> v_mapInv = v1.mapInv();\n         Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};\n-        assertEquals(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n+        Assert.assertEquals(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n \n         //octave =  v1 .^-1\n         FieldVector<Fraction> v_mapInvToSelf = v1.copy();\n         v_mapInvToSelf.mapInvToSelf();\n         Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};\n-        assertEquals(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n-\n-\n-    }\n-\n+        Assert.assertEquals(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n+\n+\n+    }\n+\n+    @Test\n     public void testBasicFunctions() throws FractionConversionException {\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n         SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);\n         //octave =  v1 + v2\n         FieldVector<Fraction> v_add = v1.add(v2);\n         Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n-        assertEquals(\"compare vect\" ,v_add.getData(),result_add);\n+        Assert.assertEquals(\"compare vect\" ,v_add.getData(),result_add);\n \n         SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);\n         FieldVector<Fraction> v_add_i = v1.add(vt2);\n         Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n-        assertEquals(\"compare vect\" ,v_add_i.getData(),result_add_i);\n+        Assert.assertEquals(\"compare vect\" ,v_add_i.getData(),result_add_i);\n \n         //octave =  v1 - v2\n         SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);\n \n         // octave  dot(v1,v2)\n         Fraction dot =  v1.dotProduct(v2);\n-        assertEquals(\"compare val \",new Fraction(32), dot);\n+        Assert.assertEquals(\"compare val \",new Fraction(32), dot);\n \n         // octave  dot(v1,v2_t)\n         Fraction dot_2 =  v1.dotProduct(v2_t);\n-        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+        Assert.assertEquals(\"compare val \",new Fraction(32), dot_2);\n \n         FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n-        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n \n         FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n-        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n-\n-    }\n-\n-\n+        Assert.assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+\n+    }\n+\n+\n+    @Test\n     public void testMisc() {\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n \n         String out1 = v1.toString();\n-        assertTrue(\"some output \",  out1.length()!=0);\n+        Assert.assertTrue(\"some output \",  out1.length()!=0);\n         try {\n             v1.checkVectorDimensions(2);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testPredicates() {\n \n         SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });\n \n         v.setEntry(0, field.getZero());\n-        assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));\n-        assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));\n+        Assert.assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));\n+        Assert.assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));\n \n     }\n \n     /** verifies that two vectors are close (sup norm) */\n     protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {\n         if (m.length != n.length) {\n-            fail(\"vectors have different lengths\");\n+            Assert.fail(\"vectors have different lengths\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+            Assert.assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n         }\n     }\n \n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {\n         if (m.length != n.length) {\n-            fail(\"vectors have different lengths\");\n+            Assert.fail(\"vectors have different lengths\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" +  i + \" elements differ\", m[i].doubleValue(),n[i].doubleValue(), tolerance);\n+            Assert.assertEquals(msg + \" \" +  i + \" elements differ\", m[i].doubleValue(),n[i].doubleValue(), tolerance);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n \n package org.apache.commons.math.ode;\n \n-import junit.framework.*;\n import java.util.Random;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-public class ContinuousOutputModelTest\n-  extends TestCase {\n-\n-  public ContinuousOutputModelTest(String name) {\n-    super(name);\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ContinuousOutputModelTest {\n+\n+  public ContinuousOutputModelTest() {\n     pb    = null;\n     integ = null;\n   }\n \n+  @Test\n   public void testBoundaries()\n     throws MathUserException, IntegratorException {\n     integ.addStepHandler(new ContinuousOutputModel());\n     cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));\n   }\n \n+  @Test\n   public void testRandomAccess()\n     throws MathUserException, IntegratorException {\n \n       }\n     }\n \n-    assertTrue(maxError < 1.0e-9);\n-\n-  }\n-\n+    Assert.assertTrue(maxError < 1.0e-9);\n+\n+  }\n+\n+  @Test\n   public void testModelsMerging()\n     throws MathUserException, IntegratorException {\n \n       cm.append(cm1);\n \n       // check circle\n-      assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12);\n-      assertEquals(0, cm.getFinalTime(), 1.0e-12);\n-      assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);\n+      Assert.assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12);\n+      Assert.assertEquals(0, cm.getFinalTime(), 1.0e-12);\n+      Assert.assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);\n       for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) {\n           cm.setInterpolatedTime(t);\n           double[] y = cm.getInterpolatedState();\n-          assertEquals(FastMath.cos(t), y[0], 1.0e-7);\n-          assertEquals(FastMath.sin(t), y[1], 1.0e-7);\n+          Assert.assertEquals(FastMath.cos(t), y[0], 1.0e-7);\n+          Assert.assertEquals(FastMath.sin(t), y[1], 1.0e-7);\n       }\n \n   }\n \n+  @Test\n   public void testErrorConditions()\n     throws MathUserException {\n \n       cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);\n \n       // dimension mismatch\n-      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));\n+      Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));\n \n       // hole between time ranges\n-      assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));\n+      Assert.assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));\n \n       // propagation direction mismatch\n-      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));\n+      Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));\n \n       // no errors\n-      assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));\n+      Assert.assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));\n \n   }\n \n   }\n \n   public void checkValue(double value, double reference) {\n-    assertTrue(FastMath.abs(value - reference) < 1.0e-10);\n-  }\n-\n-  @Override\n+    Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  @Before\n   public void setUp() {\n     pb = new TestProblem3(0.9);\n     double minStep = 0;\n     integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);\n   }\n \n-  @Override\n+  @After\n   public void tearDown() {\n     pb    = null;\n     integ = null;\n--- a/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.*;\n \n-public class FirstOrderConverterTest\n-  extends TestCase {\n+public class FirstOrderConverterTest {\n \n-  public FirstOrderConverterTest(String name) {\n-    super(name);\n-  }\n-\n+  @Test\n   public void testDoubleDimension() {\n     for (int i = 1; i < 10; ++i) {\n       SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);\n       FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);\n-      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));\n+      Assert.assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));\n     }\n   }\n \n+  @Test\n   public void testDecreasingSteps()\n     throws MathUserException, IntegratorException {\n \n       double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)\n                    - FastMath.sin(4.0);\n       if (i > 0) {\n-        assertTrue(FastMath.abs(error) < FastMath.abs(previousError));\n+        Assert.assertTrue(FastMath.abs(error) < FastMath.abs(previousError));\n       }\n       previousError = error;\n \n     }\n   }\n \n+  @Test\n   public void testSmallStep()\n     throws MathUserException, IntegratorException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n                    - FastMath.sin(4.0);\n-    assertTrue(FastMath.abs(error) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(error) < 1.0e-10);\n   }\n \n+  @Test\n   public void testBigStep()\n     throws MathUserException, IntegratorException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n                    - FastMath.sin(4.0);\n-    assertTrue(FastMath.abs(error) > 0.1);\n+    Assert.assertTrue(FastMath.abs(error) > 0.1);\n   }\n \n   private static class Equations\n--- a/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n \n package org.apache.commons.math.ode.events;\n \n-import junit.framework.Assert;\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class EventStateTest {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.TestProblem6;\n import org.apache.commons.math.ode.TestProblemHandler;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class AdamsBashforthIntegratorTest {\n             // the 31 and 36 factors are only valid for this test\n             // and has been obtained from trial and error\n             // there is no general relation between local and global errors\n-            assertTrue(handler.getMaximalValueError() > (31.0 * scalAbsoluteTolerance));\n-            assertTrue(handler.getMaximalValueError() < (36.0 * scalAbsoluteTolerance));\n-            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+            Assert.assertTrue(handler.getMaximalValueError() > (31.0 * scalAbsoluteTolerance));\n+            Assert.assertTrue(handler.getMaximalValueError() < (36.0 * scalAbsoluteTolerance));\n+            Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n \n             int calls = pb.getCalls();\n-            assertEquals(integ.getEvaluations(), calls);\n-            assertTrue(calls <= previousCalls);\n+            Assert.assertEquals(integ.getEvaluations(), calls);\n+            Assert.assertTrue(calls <= previousCalls);\n             previousCalls = calls;\n \n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        assertTrue(handler.getLastError() < 1.0e-8);\n-        assertTrue(handler.getMaximalValueError() < 1.0e-8);\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n-        assertEquals(\"Adams-Bashforth\", integ.getName());\n+        Assert.assertTrue(handler.getLastError() < 1.0e-8);\n+        Assert.assertTrue(handler.getMaximalValueError() < 1.0e-8);\n+        Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+        Assert.assertEquals(\"Adams-Bashforth\", integ.getName());\n     }\n \n     @Test\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (nSteps < 4) {\n-                assertTrue(integ.getEvaluations() > 150);\n+                Assert.assertTrue(integ.getEvaluations() > 150);\n             } else {\n-                assertTrue(integ.getEvaluations() < 70);\n+                Assert.assertTrue(integ.getEvaluations() < 70);\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.TestProblem6;\n import org.apache.commons.math.ode.TestProblemHandler;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class AdamsMoultonIntegratorTest {\n             // the 0.15 and 3.0 factors are only valid for this test\n             // and has been obtained from trial and error\n             // there is no general relation between local and global errors\n-            assertTrue(handler.getMaximalValueError() > (0.15 * scalAbsoluteTolerance));\n-            assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));\n-            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+            Assert.assertTrue(handler.getMaximalValueError() > (0.15 * scalAbsoluteTolerance));\n+            Assert.assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));\n+            Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n \n             int calls = pb.getCalls();\n-            assertEquals(integ.getEvaluations(), calls);\n-            assertTrue(calls <= previousCalls);\n+            Assert.assertEquals(integ.getEvaluations(), calls);\n+            Assert.assertTrue(calls <= previousCalls);\n             previousCalls = calls;\n \n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        assertTrue(handler.getLastError() < 1.0e-9);\n-        assertTrue(handler.getMaximalValueError() < 1.0e-9);\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n-        assertEquals(\"Adams-Moulton\", integ.getName());\n+        Assert.assertTrue(handler.getLastError() < 1.0e-9);\n+        Assert.assertTrue(handler.getMaximalValueError() < 1.0e-9);\n+        Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+        Assert.assertEquals(\"Adams-Moulton\", integ.getName());\n     }\n \n     @Test\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (nSteps < 4) {\n-                assertTrue(integ.getEvaluations() > 140);\n+                Assert.assertTrue(integ.getEvaluations() > 140);\n             } else {\n-                assertTrue(integ.getEvaluations() < 90);\n+                Assert.assertTrue(integ.getEvaluations() < 90);\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-public class ClassicalRungeKuttaIntegratorTest\n-  extends TestCase {\n-\n-  public ClassicalRungeKuttaIntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ClassicalRungeKuttaIntegratorTest {\n+\n+  @Test\n   public void testMissedEndEvent() throws IntegratorException, MathUserException {\n       final double   t0     = 1878250320.0000029;\n       final double   tEvent = 1878250379.9999986;\n \n   }\n \n+  @Test\n   public void testSanityChecks() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n                                                         0.0, new double[pb.getDimension()+10],\n                                                         1.0, new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n     try  {\n         new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n                                                           0.0, new double[pb.getDimension()],\n                                                           1.0, new double[pb.getDimension()+10]);\n-          fail(\"an exception should have been thrown\");\n+          Assert.fail(\"an exception should have been thrown\");\n       } catch(MathUserException de) {\n-        fail(\"wrong exception caught\");\n+        Assert.fail(\"wrong exception caught\");\n       } catch(IntegratorException ie) {\n       }\n     try  {\n       new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n                                                         0.0, new double[pb.getDimension()],\n                                                         0.0, new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testDecreasingSteps()\n     throws MathUserException, IntegratorException  {\n \n           integ.addEventHandler(functions[l],\n                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n-        assertEquals(functions.length, integ.getEventHandlers().size());\n+        Assert.assertEquals(functions.length, integ.getEventHandlers().size());\n         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                           pb.getFinalTime(), new double[pb.getDimension()]);\n         if (functions.length == 0) {\n-            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < FastMath.abs(previousValueError));\n+          Assert.assertTrue(error < FastMath.abs(previousValueError));\n         }\n         previousValueError = error;\n \n         double timeError = handler.getMaximalTimeError();\n         if (i > 4) {\n-          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));\n         }\n         previousTimeError = timeError;\n \n         integ.clearEventHandlers();\n-        assertEquals(0, integ.getEventHandlers().size());\n-      }\n-\n-    }\n-\n-  }\n-\n+        Assert.assertEquals(0, integ.getEventHandlers().size());\n+      }\n+\n+    }\n+\n+  }\n+\n+  @Test\n   public void testSmallStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() < 2.0e-13);\n-    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(\"classical Runge-Kutta\", integ.getName());\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() < 2.0e-13);\n+    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  @Test\n   public void testBigStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() > 0.0004);\n-    assertTrue(handler.getMaximalValueError() > 0.005);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() > 0.0004);\n+    Assert.assertTrue(handler.getMaximalValueError() > 0.005);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  @Test\n   public void testBackward()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() < 5.0e-10);\n-    assertTrue(handler.getMaximalValueError() < 7.0e-10);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(\"classical Runge-Kutta\", integ.getName());\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() < 5.0e-10);\n+    Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n         // even with more than 1000 evaluations per period,\n         // RK4 is not able to integrate such an eccentric\n         // orbit with a good accuracy\n-        assertTrue(maxError > 0.005);\n+        Assert.assertTrue(maxError > 0.005);\n       }\n     }\n     private double maxError = 0;\n     private TestProblem3 pb;\n   }\n \n+  @Test\n   public void testStepSize()\n     throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       integ.addStepHandler(new StepHandler() {\n           public void handleStep(StepInterpolator interpolator, boolean isLast) {\n               if (! isLast) {\n-                  assertEquals(step,\n+                  Assert.assertEquals(step,\n                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n                                1.0e-12);\n               }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ClassicalRungeKuttaStepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 753000);\n-    assertTrue(bos.size () < 754000);\n+    Assert.assertTrue(bos.size () > 753000);\n+    Assert.assertTrue(bos.size () < 754000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError > 0.005);\n+    Assert.assertTrue(maxError > 0.005);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.*;\n-\n-public class DormandPrince54IntegratorTest\n-  extends TestCase {\n-\n-  public DormandPrince54IntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class DormandPrince54IntegratorTest {\n+\n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       integrator.integrate(pb,\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testMinStep() {\n \n     try {\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n \n   }\n \n+  @Test\n   public void testSmallLastStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertTrue(handler.wasLastSeen());\n-    assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n-\n-  }\n-\n+    Assert.assertTrue(handler.wasLastSeen());\n+    Assert.assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+\n+  }\n+\n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 2.0e-7);\n-      assertTrue(handler.getMaximalValueError() < 2.0e-7);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+      Assert.assertTrue(handler.getLastError() < 2.0e-7);\n+      Assert.assertTrue(handler.getMaximalValueError() < 2.0e-7);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n   }\n \n   private static class DP54SmallLastHandler implements StepHandler {\n       if (isLast) {\n         lastSeen = true;\n         double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n-        assertTrue(FastMath.abs(h) < minStep);\n+        Assert.assertTrue(FastMath.abs(h) < minStep);\n       }\n     }\n \n \n   }\n \n+  @Test\n   public void testIncreasingTolerance()\n     throws MathUserException, IntegratorException {\n \n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n-      assertEquals(0.8, integ.getSafety(), 1.0e-12);\n-      assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);\n-      assertEquals(0.3, integ.getMinReduction(), 1.0e-12);\n+      Assert.assertEquals(0.8, integ.getSafety(), 1.0e-12);\n+      Assert.assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);\n+      Assert.assertEquals(0.3, integ.getMinReduction(), 1.0e-12);\n \n       // the 0.7 factor is only valid for this test\n       // and has been obtained from trial and error\n       // there is no general relation between local and global errors\n-      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n-      assertEquals(integ.getEvaluations(), calls);\n-      assertTrue(calls <= previousCalls);\n+      Assert.assertEquals(integ.getEvaluations(), calls);\n+      Assert.assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n     }\n \n   }\n \n+  @Test\n   public void testEvents()\n     throws MathUserException, IntegratorException {\n \n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventHandlers().size());\n+    Assert.assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalValueError() < 5.0e-6);\n-    assertEquals(0, handler.getMaximalTimeError(), convergence);\n-    assertEquals(12.0, handler.getLastTime(), convergence);\n+    Assert.assertTrue(handler.getMaximalValueError() < 5.0e-6);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    Assert.assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n-    assertEquals(0, integ.getEventHandlers().size());\n-\n-  }\n-\n+    Assert.assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertEquals(integ.getEvaluations(), pb.getCalls());\n-    assertTrue(pb.getCalls() < 2800);\n-\n-  }\n-\n+    Assert.assertEquals(integ.getEvaluations(), pb.getCalls());\n+    Assert.assertTrue(pb.getCalls() < 2800);\n+\n+  }\n+\n+  @Test\n   public void testVariableSteps()\n     throws MathUserException, IntegratorException {\n \n     integ.addStepHandler(new VariableHandler());\n     double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                       pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n   }\n \n   private static class KeplerHandler implements StepHandler {\n         }\n       }\n       if (isLast) {\n-        assertTrue(maxError < 7.0e-10);\n-        assertTrue(nbSteps < 400);\n+        Assert.assertTrue(maxError < 7.0e-10);\n+        Assert.assertTrue(nbSteps < 400);\n       }\n     }\n     private int nbSteps;\n       }\n \n       if (isLast) {\n-        assertTrue(minStep < (1.0 / 450.0));\n-        assertTrue(maxStep > (1.0 / 4.2));\n+        Assert.assertTrue(minStep < (1.0 / 450.0));\n+        Assert.assertTrue(maxStep > (1.0 / 4.2));\n       }\n     }\n     private boolean firstTime;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class DormandPrince54StepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 126000);\n-    assertTrue(bos.size () < 127000);\n+    Assert.assertTrue(bos.size () > 126000);\n+    Assert.assertTrue(bos.size () < 127000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError < 7.0e-10);\n+    Assert.assertTrue(maxError < 7.0e-10);\n \n   }\n \n               double tA = cloned.getPreviousTime();\n               double tB = cloned.getCurrentTime();\n               double halfStep = FastMath.abs(tB - tA) / 2;\n-              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n-              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+              Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+              Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n               for (int i = 0; i < 10; ++i) {\n                   double t = (i * tB + (9 - i) * tA) / 9;\n                   interpolator.setInterpolatedTime(t);\n-                  assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                  Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                   cloned.setInterpolatedTime(t);\n-                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                  Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                   double[] referenceState = interpolator.getInterpolatedState();\n                   double[] cloneState     = cloned.getInterpolatedState();\n                   for (int j = 0; j < referenceState.length; ++j) {\n-                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                      Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n                   }\n               }\n           }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.*;\n-\n-public class DormandPrince853IntegratorTest\n-  extends TestCase {\n-\n-  public DormandPrince853IntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class DormandPrince853IntegratorTest {\n+\n+  @Test\n   public void testMissedEndEvent() throws IntegratorException, MathUserException {\n       final double   t0     = 1878250320.0000029;\n       final double   tEvent = 1878250379.9999986;\n \n   }\n \n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       integrator.integrate(pb,\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testNullIntervalCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       integrator.integrate(pb,\n                            0.0, new double[pb.getDimension()],\n                            0.0, new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testMinStep() {\n \n     try {\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n \n   }\n \n+  @Test\n   public void testIncreasingTolerance()\n     throws MathUserException, IntegratorException {\n \n       // the 1.3 factor is only valid for this test\n       // and has been obtained from trial and error\n       // there is no general relation between local and global errors\n-      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n-      assertEquals(integ.getEvaluations(), calls);\n-      assertTrue(calls <= previousCalls);\n+      Assert.assertEquals(integ.getEvaluations(), calls);\n+      Assert.assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n     }\n \n   }\n \n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 1.1e-7);\n-      assertTrue(handler.getMaximalValueError() < 1.1e-7);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n-  }\n-\n+      Assert.assertTrue(handler.getLastError() < 1.1e-7);\n+      Assert.assertTrue(handler.getMaximalValueError() < 1.1e-7);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  @Test\n   public void testEvents()\n     throws MathUserException, IntegratorException {\n \n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventHandlers().size());\n+    Assert.assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertEquals(0, handler.getMaximalValueError(), 1.1e-7);\n-    assertEquals(0, handler.getMaximalTimeError(), convergence);\n-    assertEquals(12.0, handler.getLastTime(), convergence);\n+    Assert.assertEquals(0, handler.getMaximalValueError(), 1.1e-7);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    Assert.assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n-    assertEquals(0, integ.getEventHandlers().size());\n-\n-  }\n-\n+    Assert.assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertEquals(integ.getEvaluations(), pb.getCalls());\n-    assertTrue(pb.getCalls() < 3300);\n-\n-  }\n-\n+    Assert.assertEquals(integ.getEvaluations(), pb.getCalls());\n+    Assert.assertTrue(pb.getCalls() < 3300);\n+\n+  }\n+\n+  @Test\n   public void testVariableSteps()\n     throws MathUserException, IntegratorException {\n \n     double stopTime = integ.integrate(pb,\n                                       pb.getInitialTime(), pb.getInitialState(),\n                                       pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n-    assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n-  }\n-\n+    Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    Assert.assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  @Test\n   public void testNoDenseOutput()\n     throws MathUserException, IntegratorException {\n     TestProblem1 pb1 = new TestProblem1();\n                     pb1.getInitialTime(), pb1.getInitialState(),\n                     pb1.getFinalTime(), new double[pb1.getDimension()]);\n     int callsWithoutDenseOutput = pb1.getCalls();\n-    assertEquals(integ.getEvaluations(), callsWithoutDenseOutput);\n+    Assert.assertEquals(integ.getEvaluations(), callsWithoutDenseOutput);\n \n     integ.addStepHandler(new InterpolatingStepHandler());\n     integ.integrate(pb2,\n                     pb2.getInitialTime(), pb2.getInitialState(),\n                     pb2.getFinalTime(), new double[pb2.getDimension()]);\n     int callsWithDenseOutput = pb2.getCalls();\n-    assertEquals(integ.getEvaluations(), callsWithDenseOutput);\n-\n-    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n-\n-  }\n-\n+    Assert.assertEquals(integ.getEvaluations(), callsWithDenseOutput);\n+\n+    Assert.assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n+\n+  }\n+\n+  @Test\n   public void testUnstableDerivative()\n   throws MathUserException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n     double[] y = { Double.NaN };\n     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n-    assertEquals(8.0, y[0], 1.0e-12);\n+    Assert.assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n   private static class KeplerHandler implements StepHandler {\n         }\n       }\n       if (isLast) {\n-        assertTrue(maxError < 2.4e-10);\n-        assertTrue(nbSteps < 150);\n+        Assert.assertTrue(maxError < 2.4e-10);\n+        Assert.assertTrue(nbSteps < 150);\n       }\n     }\n     private int nbSteps;\n       }\n \n       if (isLast) {\n-        assertTrue(minStep < (1.0 / 100.0));\n-        assertTrue(maxStep > (1.0 / 2.0));\n+        Assert.assertTrue(minStep < (1.0 / 100.0));\n+        Assert.assertTrue(maxStep > (1.0 / 2.0));\n       }\n     }\n     private boolean firstTime = true;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class DormandPrince853StepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 88000);\n-    assertTrue(bos.size () < 89000);\n+    Assert.assertTrue(bos.size () > 88000);\n+    Assert.assertTrue(bos.size () < 89000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError < 2.4e-10);\n+    Assert.assertTrue(maxError < 2.4e-10);\n \n   }\n \n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n             double halfStep = FastMath.abs(tB - tA) / 2;\n-            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n-            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n             for (int i = 0; i < 10; ++i) {\n                 double t = (i * tB + (9 - i) * tA) / 9;\n                 interpolator.setInterpolatedTime(t);\n-                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                 cloned.setInterpolatedTime(t);\n-                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                 double[] referenceState = interpolator.getInterpolatedState();\n                 double[] cloneState     = cloned.getInterpolatedState();\n                 for (int j = 0; j < referenceState.length; ++j) {\n-                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                    Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n                 }\n             }\n         }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-public class EulerIntegratorTest\n-  extends TestCase {\n+public class EulerIntegratorTest {\n \n-  public EulerIntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       new EulerIntegrator(0.01).integrate(pb,\n                                           0.0, new double[pb.getDimension()+10],\n                                           1.0, new double[pb.getDimension()+10]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testDecreasingSteps()\n     throws MathUserException, IntegratorException {\n \n         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                           pb.getFinalTime(), new double[pb.getDimension()]);\n         if (functions.length == 0) {\n-            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n         double valueError = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(valueError < FastMath.abs(previousValueError));\n+          Assert.assertTrue(valueError < FastMath.abs(previousValueError));\n         }\n         previousValueError = valueError;\n \n         double timeError = handler.getMaximalTimeError();\n         if (i > 4) {\n-          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));\n         }\n         previousTimeError = timeError;\n \n \n   }\n \n+  @Test\n   public void testSmallStep()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-   assertTrue(handler.getLastError() < 2.0e-4);\n-   assertTrue(handler.getMaximalValueError() < 1.0e-3);\n-   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-   assertEquals(\"Euler\", integ.getName());\n+   Assert.assertTrue(handler.getLastError() < 2.0e-4);\n+   Assert.assertTrue(handler.getMaximalValueError() < 1.0e-3);\n+   Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+   Assert.assertEquals(\"Euler\", integ.getName());\n \n   }\n \n+  @Test\n   public void testBigStep()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() > 0.01);\n-    assertTrue(handler.getMaximalValueError() > 0.2);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertTrue(handler.getLastError() > 0.01);\n+    Assert.assertTrue(handler.getMaximalValueError() > 0.2);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n \n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 0.45);\n-      assertTrue(handler.getMaximalValueError() < 0.45);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"Euler\", integ.getName());\n+      Assert.assertTrue(handler.getLastError() < 0.45);\n+      Assert.assertTrue(handler.getMaximalValueError() < 0.45);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"Euler\", integ.getName());\n   }\n \n+  @Test\n   public void testStepSize()\n     throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       integ.addStepHandler(new StepHandler() {\n         public void handleStep(StepInterpolator interpolator, boolean isLast) {\n             if (! isLast) {\n-                assertEquals(step,\n+                Assert.assertEquals(step,\n                              interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n                              1.0e-12);\n             }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class EulerStepInterpolatorTest {\n \n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n+      Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);\n+      Assert.assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);\n     }\n \n     interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n     result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n+      Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n \n     interpolator.setInterpolatedTime(0.1);\n     double[] result = interpolator.getInterpolatedState();\n-    assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10);\n-    assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10);\n-    assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10);\n \n     interpolator.setInterpolatedTime(0.5);\n     result = interpolator.getInterpolatedState();\n-    assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10);\n-    assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10);\n-    assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10);\n \n   }\n \n         maxError = error;\n       }\n     }\n-    assertTrue(maxError < 0.001);\n+    Assert.assertTrue(maxError < 0.001);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-public class GillIntegratorTest\n-  extends TestCase {\n-\n-  public GillIntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GillIntegratorTest {\n+\n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       new GillIntegrator(0.01).integrate(pb,\n                                          0.0, new double[pb.getDimension()+10],\n                                          1.0, new double[pb.getDimension()+10]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testDecreasingSteps()\n     throws MathUserException, IntegratorException  {\n \n         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                           pb.getFinalTime(), new double[pb.getDimension()]);\n         if (functions.length == 0) {\n-            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n         double valueError = handler.getMaximalValueError();\n         if (i > 5) {\n-          assertTrue(valueError < FastMath.abs(previousValueError));\n+          Assert.assertTrue(valueError < FastMath.abs(previousValueError));\n         }\n         previousValueError = valueError;\n \n         double timeError = handler.getMaximalTimeError();\n         if (i > 5) {\n-          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));\n         }\n         previousTimeError = timeError;\n \n \n   }\n \n+  @Test\n   public void testSmallStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() < 2.0e-13);\n-    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(\"Gill\", integ.getName());\n-\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() < 2.0e-13);\n+    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertEquals(\"Gill\", integ.getName());\n+\n+  }\n+\n+  @Test\n   public void testBigStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() > 0.0004);\n-    assertTrue(handler.getMaximalValueError() > 0.005);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() > 0.0004);\n+    Assert.assertTrue(handler.getMaximalValueError() > 0.005);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 5.0e-10);\n-      assertTrue(handler.getMaximalValueError() < 7.0e-10);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"Gill\", integ.getName());\n-  }\n-\n+      Assert.assertTrue(handler.getLastError() < 5.0e-10);\n+      Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"Gill\", integ.getName());\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n                     pb.getFinalTime(), new double[pb.getDimension()]);\n   }\n \n+  @Test\n   public void testUnstableDerivative()\n   throws MathUserException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n     double[] y = { Double.NaN };\n     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n-    assertEquals(8.0, y[0], 1.0e-12);\n+    Assert.assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n   private static class KeplerStepHandler implements StepHandler {\n         // even with more than 1000 evaluations per period,\n         // RK4 is not able to integrate such an eccentric\n         // orbit with a good accuracy\n-        assertTrue(maxError > 0.001);\n+        Assert.assertTrue(maxError > 0.001);\n       }\n     }\n     private double maxError;\n     private TestProblem3 pb;\n   }\n \n+  @Test\n   public void testStepSize()\n     throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       integ.addStepHandler(new StepHandler() {\n           public void handleStep(StepInterpolator interpolator, boolean isLast) {\n               if (! isLast) {\n-                  assertEquals(step,\n+                  Assert.assertEquals(step,\n                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n                                1.0e-12);\n               }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.util.Random;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class GillStepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 753000);\n-    assertTrue(bos.size () < 754000);\n+    Assert.assertTrue(bos.size () > 753000);\n+    Assert.assertTrue(bos.size () < 754000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError < 0.003);\n+    Assert.assertTrue(maxError < 0.003);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.*;\n-\n-public class GraggBulirschStoerIntegratorTest\n-  extends TestCase {\n-\n-  public GraggBulirschStoerIntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class GraggBulirschStoerIntegratorTest {\n+\n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       integrator.integrate(pb,\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testNullIntervalCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       integrator.integrate(pb,\n                            0.0, new double[pb.getDimension()],\n                            0.0, new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testMinStep() {\n \n     try {\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n \n   }\n \n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 7.5e-9);\n-      assertTrue(handler.getMaximalValueError() < 8.1e-9);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n-  }\n-\n+      Assert.assertTrue(handler.getLastError() < 7.5e-9);\n+      Assert.assertTrue(handler.getMaximalValueError() < 8.1e-9);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  @Test\n   public void testIncreasingTolerance()\n     throws MathUserException, IntegratorException {\n \n       // and have been obtained from trial and error\n       // there is no general relation between local and global errors\n       double ratio =  handler.getMaximalValueError() / absTolerance;\n-      assertTrue(ratio < 2.4);\n-      assertTrue(ratio > 0.02);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertTrue(ratio < 2.4);\n+      Assert.assertTrue(ratio > 0.02);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n-      assertEquals(integ.getEvaluations(), calls);\n-      assertTrue(calls <= previousCalls);\n+      Assert.assertEquals(integ.getEvaluations(), calls);\n+      Assert.assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n     }\n \n   }\n \n+  @Test\n   public void testIntegratorControls()\n   throws MathUserException, IntegratorException {\n \n \n     // stability control\n     integ.setStabilityCheck(true, 2, 1, 0.99);\n-    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n     integ.setStabilityCheck(true, -1, -1, -1);\n \n     integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);\n-    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n     integ.setStepsizeControl(-1, -1, -1, -1);\n \n     integ.setOrderControl(10, 0.7, 0.95);\n-    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n     integ.setOrderControl(-1, -1, -1);\n \n     integ.setInterpolationControl(true, 3);\n-    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n     integ.setInterpolationControl(true, -1);\n \n   }\n       return handler.getMaximalValueError();\n   }\n \n+  @Test\n   public void testEvents()\n     throws MathUserException, IntegratorException {\n \n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventHandlers().size());\n+    Assert.assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n-    assertEquals(0, handler.getMaximalTimeError(), convergence);\n-    assertEquals(12.0, handler.getLastTime(), convergence);\n+    Assert.assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    Assert.assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n-    assertEquals(0, integ.getEventHandlers().size());\n-\n-  }\n-\n+    Assert.assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertEquals(integ.getEvaluations(), pb.getCalls());\n-    assertTrue(pb.getCalls() < 2150);\n-\n-  }\n-\n+    Assert.assertEquals(integ.getEvaluations(), pb.getCalls());\n+    Assert.assertTrue(pb.getCalls() < 2150);\n+\n+  }\n+\n+  @Test\n   public void testVariableSteps()\n     throws MathUserException, IntegratorException {\n \n     double stopTime = integ.integrate(pb,\n                                       pb.getInitialTime(), pb.getInitialState(),\n                                       pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n-    assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n-  }\n-\n+    Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    Assert.assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  @Test\n   public void testUnstableDerivative()\n     throws MathUserException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n     double[] y = { Double.NaN };\n     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n-    assertEquals(8.0, y[0], 1.0e-12);\n+    Assert.assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n   private static class KeplerStepHandler implements StepHandler {\n         }\n       }\n       if (isLast) {\n-        assertTrue(maxError < 2.7e-6);\n-        assertTrue(nbSteps < 80);\n+        Assert.assertTrue(maxError < 2.7e-6);\n+        Assert.assertTrue(nbSteps < 80);\n       }\n     }\n     private int nbSteps;\n       }\n \n       if (isLast) {\n-        assertTrue(minStep < 8.2e-3);\n-        assertTrue(maxStep > 1.7);\n+        Assert.assertTrue(minStep < 8.2e-3);\n+        Assert.assertTrue(maxStep > 1.7);\n       }\n     }\n     private boolean firstTime;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class GraggBulirschStoerStepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 34000);\n-    assertTrue(bos.size () < 35000);\n+    Assert.assertTrue(bos.size () > 34000);\n+    Assert.assertTrue(bos.size () < 35000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError < 5.0e-10);\n+    Assert.assertTrue(maxError < 5.0e-10);\n \n   }\n \n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n             double halfStep = FastMath.abs(tB - tA) / 2;\n-            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n-            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n             for (int i = 0; i < 10; ++i) {\n                 double t = (i * tB + (9 - i) * tA) / 9;\n                 interpolator.setInterpolatedTime(t);\n-                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                 cloned.setInterpolatedTime(t);\n-                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                 double[] referenceState = interpolator.getInterpolatedState();\n                 double[] cloneState     = cloned.getInterpolatedState();\n                 for (int j = 0; j < referenceState.length; ++j) {\n-                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                    Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n                 }\n             }\n         }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.ode.events.EventException;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.util.FastMath;\n-\n-public class HighamHall54IntegratorTest\n-  extends TestCase {\n-\n-  public HighamHall54IntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class HighamHall54IntegratorTest {\n+\n+  @Test\n   public void testWrongDerivative() throws Exception {\n       HighamHall54Integrator integrator =\n           new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n \n       try  {\n         integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n       } catch(MathUserException de) {\n         // expected behavior\n       }\n \n       try  {\n         integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n       } catch(MathUserException de) {\n         // expected behavior\n       }\n \n   }\n \n+  @Test\n   public void testMinStep() {\n \n     try {\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n \n   }\n \n+  @Test\n   public void testIncreasingTolerance()\n     throws MathUserException, IntegratorException {\n \n       // the 1.3 factor is only valid for this test\n       // and has been obtained from trial and error\n       // there is no general relation between local and global errors\n-      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n-      assertEquals(integ.getEvaluations(), calls);\n-      assertTrue(calls <= previousCalls);\n+      Assert.assertEquals(integ.getEvaluations(), calls);\n+      Assert.assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n     }\n \n   }\n \n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 5.0e-7);\n-      assertTrue(handler.getMaximalValueError() < 5.0e-7);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n-  }\n-\n+      Assert.assertTrue(handler.getLastError() < 5.0e-7);\n+      Assert.assertTrue(handler.getMaximalValueError() < 5.0e-7);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+  }\n+\n+  @Test\n   public void testEvents()\n     throws MathUserException, IntegratorException {\n \n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventHandlers().size());\n+    Assert.assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalValueError() < 1.0e-7);\n-    assertEquals(0, handler.getMaximalTimeError(), convergence);\n-    assertEquals(12.0, handler.getLastTime(), convergence);\n+    Assert.assertTrue(handler.getMaximalValueError() < 1.0e-7);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    Assert.assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n-    assertEquals(0, integ.getEventHandlers().size());\n-\n-  }\n-\n+    Assert.assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  @Test\n   public void testEventsErrors() throws Exception {\n \n       final TestProblem1 pb = new TestProblem1();\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n-      } catch (IntegratorException ie) {\n-        // expected behavior\n-      }\n-\n-  }\n-\n+        Assert.fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+  }\n+\n+  @Test\n   public void testEventsNoConvergence() throws Exception {\n \n     final TestProblem1 pb = new TestProblem1();\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n-      fail(\"an exception should have been thrown\");\n+      Assert.fail(\"an exception should have been thrown\");\n     } catch (TooManyEvaluationsException tmee) {\n         // Expected.\n     }\n \n }\n \n+  @Test\n   public void testSanityChecks() throws Exception {\n       final TestProblem3 pb  = new TestProblem3(0.9);\n       double minStep = 0;\n             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n         integ.integrate(pb, pb.getInitialTime(), new double[6],\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n       } catch (IntegratorException ie) {\n         // expected behavior\n       }\n             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[6]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n       } catch (IntegratorException ie) {\n         // expected behavior\n       }\n             new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n       } catch (IntegratorException ie) {\n         // expected behavior\n       }\n             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n       } catch (IntegratorException ie) {\n         // expected behavior\n       }\n             new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getInitialTime(), new double[pb.getDimension()]);\n-        fail(\"an exception should have been thrown\");\n-      } catch (IntegratorException ie) {\n-        // expected behavior\n-      }\n-\n-  }\n-\n+        Assert.fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4);\n-    assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+    Assert.assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4);\n+    Assert.assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n   }\n \n }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class HighamHall54StepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 167000);\n-    assertTrue(bos.size () < 168000);\n+    Assert.assertTrue(bos.size () > 167000);\n+    Assert.assertTrue(bos.size () < 168000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError < 1.6e-10);\n+    Assert.assertTrue(maxError < 1.6e-10);\n \n   }\n \n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n             double halfStep = FastMath.abs(tB - tA) / 2;\n-            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n-            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n             for (int i = 0; i < 10; ++i) {\n                 double t = (i * tB + (9 - i) * tA) / 9;\n                 interpolator.setInterpolatedTime(t);\n-                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                 cloned.setInterpolatedTime(t);\n-                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                 double[] referenceState = interpolator.getInterpolatedState();\n                 double[] cloneState     = cloned.getInterpolatedState();\n                 for (int j = 0; j < referenceState.length; ++j) {\n-                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                    Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n                 }\n             }\n         }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-public class MidpointIntegratorTest\n-  extends TestCase {\n+public class MidpointIntegratorTest {\n \n-  public MidpointIntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       new MidpointIntegrator(0.01).integrate(pb,\n                                              0.0, new double[pb.getDimension()+10],\n                                              1.0, new double[pb.getDimension()+10]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testDecreasingSteps()\n     throws MathUserException, IntegratorException  {\n \n                                           pb.getInitialTime(), pb.getInitialState(),\n                                           pb.getFinalTime(), new double[pb.getDimension()]);\n         if (functions.length == 0) {\n-            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n         double valueError = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(valueError < FastMath.abs(previousValueError));\n+          Assert.assertTrue(valueError < FastMath.abs(previousValueError));\n         }\n         previousValueError = valueError;\n \n         double timeError = handler.getMaximalTimeError();\n         if (i > 4) {\n-          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));\n         }\n         previousTimeError = timeError;\n \n \n   }\n \n+  @Test\n   public void testSmallStep()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() < 2.0e-7);\n-    assertTrue(handler.getMaximalValueError() < 1.0e-6);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(\"midpoint\", integ.getName());\n+    Assert.assertTrue(handler.getLastError() < 2.0e-7);\n+    Assert.assertTrue(handler.getMaximalValueError() < 1.0e-6);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertEquals(\"midpoint\", integ.getName());\n \n   }\n \n+  @Test\n   public void testBigStep()\n     throws MathUserException, IntegratorException {\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() > 0.01);\n-    assertTrue(handler.getMaximalValueError() > 0.05);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertTrue(handler.getLastError() > 0.01);\n+    Assert.assertTrue(handler.getMaximalValueError() > 0.05);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n   }\n \n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 6.0e-4);\n-      assertTrue(handler.getMaximalValueError() < 6.0e-4);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"midpoint\", integ.getName());\n+      Assert.assertTrue(handler.getLastError() < 6.0e-4);\n+      Assert.assertTrue(handler.getMaximalValueError() < 6.0e-4);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"midpoint\", integ.getName());\n   }\n \n+  @Test\n   public void testStepSize()\n     throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       integ.addStepHandler(new StepHandler() {\n           public void handleStep(StepInterpolator interpolator, boolean isLast) {\n               if (! isLast) {\n-                  assertEquals(step,\n+                  Assert.assertEquals(step,\n                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n                                1.0e-12);\n               }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class MidpointStepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 114000);\n-    assertTrue(bos.size () < 115000);\n+    Assert.assertTrue(bos.size () > 114000);\n+    Assert.assertTrue(bos.size () < 115000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError < 1.0e-6);\n+    Assert.assertTrue(maxError < 1.0e-6);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n-\n-public class ThreeEighthesIntegratorTest\n-  extends TestCase {\n-\n-  public ThreeEighthesIntegratorTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ThreeEighthesIntegratorTest {\n+\n+  @Test\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n       new ThreeEighthesIntegrator(0.01).integrate(pb,\n                                                   0.0, new double[pb.getDimension()+10],\n                                                   1.0, new double[pb.getDimension()+10]);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch(MathUserException de) {\n-      fail(\"wrong exception caught\");\n+      Assert.fail(\"wrong exception caught\");\n     } catch(IntegratorException ie) {\n     }\n   }\n \n+  @Test\n   public void testDecreasingSteps()\n     throws MathUserException, IntegratorException  {\n \n         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                           pb.getFinalTime(), new double[pb.getDimension()]);\n         if (functions.length == 0) {\n-            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < FastMath.abs(previousValueError));\n+          Assert.assertTrue(error < FastMath.abs(previousValueError));\n         }\n         previousValueError = error;\n \n         double timeError = handler.getMaximalTimeError();\n         if (i > 4) {\n-          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));\n         }\n         previousTimeError = timeError;\n \n \n   }\n \n+ @Test\n  public void testSmallStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() < 2.0e-13);\n-    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(\"3/8\", integ.getName());\n-\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() < 2.0e-13);\n+    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    Assert.assertEquals(\"3/8\", integ.getName());\n+\n+  }\n+\n+  @Test\n   public void testBigStep()\n     throws MathUserException, IntegratorException {\n \n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getLastError() > 0.0004);\n-    assertTrue(handler.getMaximalValueError() > 0.005);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-\n-  }\n-\n+    Assert.assertTrue(handler.getLastError() > 0.0004);\n+    Assert.assertTrue(handler.getMaximalValueError() > 0.005);\n+    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  @Test\n   public void testBackward()\n       throws MathUserException, IntegratorException {\n \n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 5.0e-10);\n-      assertTrue(handler.getMaximalValueError() < 7.0e-10);\n-      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-      assertEquals(\"3/8\", integ.getName());\n-  }\n-\n+      Assert.assertTrue(handler.getLastError() < 5.0e-10);\n+      Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      Assert.assertEquals(\"3/8\", integ.getName());\n+  }\n+\n+  @Test\n   public void testKepler()\n     throws MathUserException, IntegratorException {\n \n         // even with more than 1000 evaluations per period,\n         // RK4 is not able to integrate such an eccentric\n         // orbit with a good accuracy\n-        assertTrue(maxError > 0.005);\n+        Assert.assertTrue(maxError > 0.005);\n       }\n     }\n \n \n   }\n \n+  @Test\n   public void testStepSize()\n     throws MathUserException, IntegratorException {\n       final double step = 1.23456;\n       integ.addStepHandler(new StepHandler() {\n           public void handleStep(StepInterpolator interpolator, boolean isLast) {\n               if (! isLast) {\n-                  assertEquals(step,\n+                  Assert.assertEquals(step,\n                                interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n                                1.0e-12);\n               }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ThreeEighthesStepInterpolatorTest {\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 753000);\n-    assertTrue(bos.size () < 754000);\n+    Assert.assertTrue(bos.size () > 753000);\n+    Assert.assertTrue(bos.size () < 754000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n       }\n     }\n \n-    assertTrue(maxError > 0.005);\n+    Assert.assertTrue(maxError > 0.005);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.sampling;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n import java.io.ByteArrayOutputStream;\n import java.io.ByteArrayInputStream;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class DummyStepInterpolatorTest {\n \n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n+      Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     interpolator.setInterpolatedTime(0.1);\n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n+        Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n     interpolator.setInterpolatedTime(0.5);\n     result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n+        Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n     oos.writeObject(interpolator);\n \n-    assertTrue(bos.size () > 200);\n-    assertTrue(bos.size () < 300);\n+    Assert.assertTrue(bos.size () > 200);\n+    Assert.assertTrue(bos.size () < 300);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n     dsi.setInterpolatedTime(0.5);\n     double[] result = dsi.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n+        Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n     try {\n         oos.writeObject(interpolator);\n-        fail(\"an exception should have been thrown\");\n+        Assert.fail(\"an exception should have been thrown\");\n     } catch (IOException ioe) {\n         // expected behavior\n-        assertEquals(0, ioe.getMessage().length());\n+        Assert.assertEquals(0, ioe.getMessage().length());\n     }\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.sampling;\n \n-import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import org.apache.commons.math.ode.TestProblem1;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class NordsieckStepInterpolatorTest {\n             oos.writeObject(handler);\n         }\n \n-        assertTrue(bos.size () >  25500);\n-        assertTrue(bos.size () <  26500);\n+        Assert.assertTrue(bos.size () >  25500);\n+        Assert.assertTrue(bos.size () <  26500);\n \n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);\n             }\n         }\n \n-        assertTrue(maxError < 1.0e-6);\n+        Assert.assertTrue(maxError < 1.0e-6);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n  */\n package org.apache.commons.math.ode.sampling;\n \n-import static org.junit.Assert.assertEquals;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblemAbstract;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n \n public class StepInterpolatorTestUtils {\n \n                                                32 * (yP3h[i] - yM3h[i]) +\n                                              -168 * (yP2h[i] - yM2h[i]) +\n                                               672 * (yP1h[i] - yM1h[i])) / (840 * h);\n-                    assertEquals(approYDot, yDot[i], threshold);\n+                    Assert.assertEquals(approYDot, yDot[i], threshold);\n                 }\n \n             }\n--- a/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n import org.apache.commons.math.ode.sampling.FixedStepHandler;\n import org.apache.commons.math.ode.sampling.StepNormalizer;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n-import junit.framework.*;\n \n-public class StepNormalizerTest\n-  extends TestCase {\n+public class StepNormalizerTest {\n \n-  public StepNormalizerTest(String name) {\n-    super(name);\n+  public StepNormalizerTest() {\n     pb    = null;\n     integ = null;\n   }\n \n+  @Test\n   public void testBoundaries()\n     throws MathUserException, IntegratorException {\n     double range = pb.getFinalTime() - pb.getInitialTime();\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertTrue(lastSeen);\n+    Assert.assertTrue(lastSeen);\n   }\n \n+  @Test\n   public void testBeforeEnd()\n     throws MathUserException, IntegratorException {\n     final double range = pb.getFinalTime() - pb.getInitialTime();\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n-    assertTrue(lastSeen);\n+    Assert.assertTrue(lastSeen);\n   }\n \n   public void checkValue(double value, double reference) {\n-    assertTrue(FastMath.abs(value - reference) < 1.0e-10);\n+    Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);\n   }\n \n   public void setLastSeen(boolean lastSeen) {\n     this.lastSeen = lastSeen;\n   }\n \n-  @Override\n+  @Before\n   public void setUp() {\n     pb = new TestProblem3(0.9);\n     double minStep = 0;\n     lastSeen = false;\n   }\n \n-  @Override\n+  @After\n   public void tearDown() {\n     pb    = null;\n     integ = null;\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n \n package org.apache.commons.math.optimization;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.awt.geom.Point2D;\n import java.util.ArrayList;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomVectorGenerator;\n import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class MultiStartDifferentiableMultivariateRealOptimizerTest {\n         BrentSolver solver = new BrentSolver();\n         RealPointValuePair optimum =\n             optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n-        assertEquals(200, optimizer.getMaxEvaluations());\n+        Assert.assertEquals(200, optimizer.getMaxEvaluations());\n         RealPointValuePair[] optima = optimizer.getOptima();\n         for (RealPointValuePair o : optima) {\n             Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);\n-            assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n-            assertEquals(96.075902096, center.x, 1.0e-8);\n-            assertEquals(48.135167894, center.y, 1.0e-8);\n+            Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n+            Assert.assertEquals(96.075902096, center.x, 1.0e-8);\n+            Assert.assertEquals(48.135167894, center.y, 1.0e-8);\n         }\n-        assertTrue(optimizer.getEvaluations() > 70);\n-        assertTrue(optimizer.getEvaluations() < 90);\n-        assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n+        Assert.assertTrue(optimizer.getEvaluations() > 70);\n+        Assert.assertTrue(optimizer.getEvaluations() < 90);\n+        Assert.assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n     }\n \n     private static class Circle implements DifferentiableMultivariateRealFunction {\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n \n package org.apache.commons.math.optimization;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n import java.io.Serializable;\n \n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomVectorGenerator;\n import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Assert;\n import org.junit.Test;\n \n /**\n         // no optima before first optimization attempt\n         try {\n             optimizer.getOptima();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (MathIllegalStateException ise) {\n             // expected\n         }\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n-        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n         VectorialPointValuePair[] optima = optimizer.getOptima();\n-        assertEquals(10, optima.length);\n+        Assert.assertEquals(10, optima.length);\n         for (int i = 0; i < optima.length; ++i) {\n-            assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);\n-            assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);\n+            Assert.assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);\n+            Assert.assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);\n         }\n-        assertTrue(optimizer.getEvaluations() > 20);\n-        assertTrue(optimizer.getEvaluations() < 50);\n-        assertEquals(100, optimizer.getMaxEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 20);\n+        Assert.assertTrue(optimizer.getEvaluations() < 50);\n+        Assert.assertEquals(100, optimizer.getMaxEvaluations());\n     }\n \n     @Test(expected = MathUserException.class)\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n \n package org.apache.commons.math.optimization;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomVectorGenerator;\n import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class MultiStartMultivariateRealOptimizerTest {\n         RealPointValuePair optimum =\n             optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n-        assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n-        assertTrue(optimizer.getEvaluations() > 900);\n-        assertTrue(optimizer.getEvaluations() < 1200);\n-        assertTrue(optimum.getValue() < 8.0e-4);\n+        Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 900);\n+        Assert.assertTrue(optimizer.getEvaluations() < 1200);\n+        Assert.assertTrue(optimum.getValue() < 8.0e-4);\n     }\n \n     private static class Rosenbrock implements MultivariateRealFunction {\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.LeastSquaresConverter;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class SimplexOptimizerNelderMeadTest {\n \n         // minimization\n         optimum = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n-        assertEquals(xM,        optimum.getPoint()[0], 2e-7);\n-        assertEquals(yP,        optimum.getPoint()[1], 2e-5);\n-        assertEquals(valueXmYp, optimum.getValue(),    6e-12);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 90);\n+        Assert.assertEquals(xM,        optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(yP,        optimum.getPoint()[1], 2e-5);\n+        Assert.assertEquals(valueXmYp, optimum.getValue(),    6e-12);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 90);\n \n         optimum = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n-        assertEquals(xP,        optimum.getPoint()[0], 5e-6);\n-        assertEquals(yM,        optimum.getPoint()[1], 6e-6);\n-        assertEquals(valueXpYm, optimum.getValue(),    1e-11);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 90);\n+        Assert.assertEquals(xP,        optimum.getPoint()[0], 5e-6);\n+        Assert.assertEquals(yM,        optimum.getPoint()[1], 6e-6);\n+        Assert.assertEquals(valueXpYm, optimum.getValue(),    1e-11);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 90);\n \n         // maximization\n         optimum = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 });\n-        assertEquals(xM,        optimum.getPoint()[0], 1e-5);\n-        assertEquals(yM,        optimum.getPoint()[1], 3e-6);\n-        assertEquals(valueXmYm, optimum.getValue(),    3e-12);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 90);\n+        Assert.assertEquals(xM,        optimum.getPoint()[0], 1e-5);\n+        Assert.assertEquals(yM,        optimum.getPoint()[1], 3e-6);\n+        Assert.assertEquals(valueXmYm, optimum.getValue(),    3e-12);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 90);\n \n         optimum = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n-        assertEquals(xP,        optimum.getPoint()[0], 4e-6);\n-        assertEquals(yP,        optimum.getPoint()[1], 5e-6);\n-        assertEquals(valueXpYp, optimum.getValue(),    7e-12);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 90);\n+        Assert.assertEquals(xP,        optimum.getPoint()[0], 4e-6);\n+        Assert.assertEquals(yP,        optimum.getPoint()[1], 5e-6);\n+        Assert.assertEquals(valueXpYp, optimum.getValue(),    7e-12);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 90);\n     }\n \n     @Test\n         RealPointValuePair optimum =\n             optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n \n-        assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n-        assertTrue(optimizer.getEvaluations() > 40);\n-        assertTrue(optimizer.getEvaluations() < 50);\n-        assertTrue(optimum.getValue() < 8e-4);\n+        Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 40);\n+        Assert.assertTrue(optimizer.getEvaluations() < 50);\n+        Assert.assertTrue(optimum.getValue() < 8e-4);\n     }\n \n     @Test\n         optimizer.setSimplex(new NelderMeadSimplex(4));\n         RealPointValuePair optimum =\n             optimizer.optimize(200, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n-        assertEquals(powell.getCount(), optimizer.getEvaluations());\n-        assertTrue(optimizer.getEvaluations() > 110);\n-        assertTrue(optimizer.getEvaluations() < 130);\n-        assertTrue(optimum.getValue() < 2e-3);\n+        Assert.assertEquals(powell.getCount(), optimizer.getEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 110);\n+        Assert.assertTrue(optimizer.getEvaluations() < 130);\n+        Assert.assertTrue(optimum.getValue() < 2e-3);\n     }\n \n     @Test\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n         RealPointValuePair optimum =\n             optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n-        assertEquals( 2, optimum.getPointRef()[0], 3e-5);\n-        assertEquals(-3, optimum.getPointRef()[1], 4e-4);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 80);\n-        assertTrue(optimum.getValue() < 1.0e-6);\n+        Assert.assertEquals( 2, optimum.getPointRef()[0], 3e-5);\n+        Assert.assertEquals(-3, optimum.getPointRef()[1], 4e-4);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 80);\n+        Assert.assertTrue(optimum.getValue() < 1.0e-6);\n     }\n \n     @Test\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n         RealPointValuePair optimum =\n             optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n-        assertEquals( 2, optimum.getPointRef()[0], 5e-5);\n-        assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 80);\n-        assertTrue(optimum.getValue() < 1e-6);\n+        Assert.assertEquals( 2, optimum.getPointRef()[0], 5e-5);\n+        Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 80);\n+        Assert.assertTrue(optimum.getValue() < 1e-6);\n     }\n \n     @Test\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n         RealPointValuePair optimum =\n             optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n-        assertEquals( 2, optimum.getPointRef()[0], 2e-3);\n-        assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n-        assertTrue(optimizer.getEvaluations() > 60);\n-        assertTrue(optimizer.getEvaluations() < 80);\n-        assertTrue(optimum.getValue() < 1e-6);\n+        Assert.assertEquals( 2, optimum.getPointRef()[0], 2e-3);\n+        Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n+        Assert.assertTrue(optimizer.getEvaluations() > 60);\n+        Assert.assertTrue(optimizer.getEvaluations() < 80);\n+        Assert.assertTrue(optimum.getValue() < 1e-6);\n     }\n \n     @Test(expected = TooManyEvaluationsException.class)\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class GaussNewtonOptimizerTest\n-extends TestCase {\n-\n-    public GaussNewtonOptimizerTest(String name) {\n-        super(name);\n-    }\n-\n+public class GaussNewtonOptimizerTest {\n+\n+    @Test\n     public void testTrivial() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testColumnsPermutation() throws MathUserException {\n \n         LinearProblem problem =\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n-        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n-        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n-\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n+\n+    }\n+\n+    @Test\n     public void testNoDependency() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         for (int i = 0; i < problem.target.length; ++i) {\n-            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n-        }\n-    }\n-\n+            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    @Test\n     public void testOneSet() throws MathUserException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n-\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+\n+    }\n+\n+    @Test\n     public void testTwoSets() throws MathUserException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n-        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n-        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n-        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n-\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+\n+    }\n+\n+    @Test\n     public void testNonInversible() throws Exception {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-            fail(\"an exception should have been caught\");\n+            Assert.fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testIllConditioned() throws MathUserException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n         VectorialPointValuePair optimum1 =\n             optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n \n         LinearProblem problem2 = new LinearProblem(new double[][] {\n                 { 10.00, 7.00, 8.10, 7.20 },\n         VectorialPointValuePair optimum2 =\n             optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n-        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n-        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n-        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n-\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n+        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n+        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n+        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n+\n+    }\n+\n+    @Test\n     public void testMoreEstimatedParametersSimple() throws Exception {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n         try {\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 7, 6, 5, 4 });\n-            fail(\"an exception should have been caught\");\n+            Assert.fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testMoreEstimatedParametersUnsorted() throws Exception {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                  { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n         try {\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 2, 2, 2, 2, 2, 2 });\n-            fail(\"an exception should have been caught\");\n+            Assert.fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testRedundantEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 1, 1 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n-        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n-\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n+        Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n+\n+    }\n+\n+    @Test\n     public void testInconsistentEquations() throws MathUserException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n-        assertTrue(optimizer.getRMS() > 0.1);\n-\n-    }\n-\n+        Assert.assertTrue(optimizer.getRMS() > 0.1);\n+\n+    }\n+\n+    @Test\n     public void testInconsistentSizes() throws MathUserException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n \n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n \n         try {\n             optimizer.optimize(100, problem, problem.target,\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (DimensionMismatchException oe) {\n             // expected behavior\n         }\n             optimizer.optimize(100, problem, new double[] { 1 },\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (DimensionMismatchException oe) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testMaxEvaluations() throws Exception {\n         CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n             optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n-            fail(\"an exception should have been caught\");\n+            Assert.fail(\"an exception should have been caught\");\n         } catch (TooManyEvaluationsException ee) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testCircleFitting() throws MathUserException {\n         CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n             optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n-        assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n+        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);\n-        assertEquals(96.07590209601095, center.x, 1.0e-10);\n-        assertEquals(48.135167894714,   center.y, 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);\n+        Assert.assertEquals(96.07590209601095, center.x, 1.0e-10);\n+        Assert.assertEquals(48.135167894714,   center.y, 1.0e-10);\n+    }\n+\n+    @Test\n     public void testCircleFittingBadInit() throws MathUserException {\n         CircleVectorial circle = new CircleVectorial();\n         double[][] points = new double[][] {\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n-            fail(\"an exception should have been caught\");\n+            Assert.fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n \n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });\n-        assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n-        assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n-        assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n+        Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n+        Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n+        Assert.assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import java.util.Arrays;\n import java.util.List;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class LevenbergMarquardtOptimizerTest\n-  extends TestCase {\n-\n-    public LevenbergMarquardtOptimizerTest(String name) {\n-        super(name);\n-    }\n-\n+public class LevenbergMarquardtOptimizerTest {\n+\n+    @Test\n     public void testTrivial() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         try {\n             optimizer.guessParametersErrors();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NumberIsTooSmallException ee) {\n             // expected behavior\n         }\n-        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testQRColumnsPermutation() {\n \n         LinearProblem problem =\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n-        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n-        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testNoDependency() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         for (int i = 0; i < problem.target.length; ++i) {\n-            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n-        }\n-    }\n-\n+            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    @Test\n     public void testOneSet() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testTwoSets() {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n-        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n-        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n-        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testNonInvertible() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-        assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n+        Assert.assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n         try {\n             optimizer.getCovariances();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (SingularMatrixException ee) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testIllConditioned() {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n         VectorialPointValuePair optimum1 =\n             optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n-        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n \n         LinearProblem problem2 = new LinearProblem(new double[][] {\n                 { 10.00, 7.00, 8.10, 7.20 },\n         VectorialPointValuePair optimum2 =\n             optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n-        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n-        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n-        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n+        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n+        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n+        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n+    }\n+\n+    @Test\n     public void testMoreEstimatedParametersSimple() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                 new double[] { 7, 6, 5, 4 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+    }\n+\n+    @Test\n     public void testMoreEstimatedParametersUnsorted() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 2, 2, 2, 2, 2, 2 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n-        assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n-        assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n-        assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n+        Assert.assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n+        Assert.assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n+        Assert.assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testRedundantEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 1, 1 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n-        assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n-    }\n-\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n+    }\n+\n+    @Test\n     public void testInconsistentEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n-        assertTrue(optimizer.getRMS() > 0.1);\n-    }\n-\n+        Assert.assertTrue(optimizer.getRMS() > 0.1);\n+    }\n+\n+    @Test\n     public void testInconsistentSizes() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n \n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n-        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n \n         try {\n             optimizer.optimize(100, problem, problem.target,\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (DimensionMismatchException oe) {\n             // expected behavior\n         }\n             optimizer.optimize(100, problem, new double[] { 1 },\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (DimensionMismatchException oe) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testControlParameters() {\n         CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n             optimizer.optimize(maxCostEval, problem, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n-            assertTrue(!shouldFail);\n+            Assert.assertTrue(!shouldFail);\n         } catch (DimensionMismatchException ee) {\n-            assertTrue(shouldFail);\n+            Assert.assertTrue(shouldFail);\n         } catch (TooManyEvaluationsException ee) {\n-            assertTrue(shouldFail);\n-        }\n-    }\n-\n+            Assert.assertTrue(shouldFail);\n+        }\n+    }\n+\n+    @Test\n     public void testCircleFitting() {\n         CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n-        assertTrue(optimizer.getEvaluations() < 10);\n-        assertTrue(optimizer.getJacobianEvaluations() < 10);\n+        Assert.assertTrue(optimizer.getEvaluations() < 10);\n+        Assert.assertTrue(optimizer.getJacobianEvaluations() < 10);\n         double rms = optimizer.getRMS();\n-        assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);\n+        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n-        assertEquals(96.07590211815305, center.x,      1.0e-10);\n-        assertEquals(48.13516790438953, center.y,      1.0e-10);\n+        Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n+        Assert.assertEquals(96.07590211815305, center.x,      1.0e-10);\n+        Assert.assertEquals(48.13516790438953, center.y,      1.0e-10);\n         double[][] cov = optimizer.getCovariances();\n-        assertEquals(1.839, cov[0][0], 0.001);\n-        assertEquals(0.731, cov[0][1], 0.001);\n-        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n-        assertEquals(0.786, cov[1][1], 0.001);\n+        Assert.assertEquals(1.839, cov[0][0], 0.001);\n+        Assert.assertEquals(0.731, cov[0][1], 0.001);\n+        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        Assert.assertEquals(0.786, cov[1][1], 0.001);\n         double[] errors = optimizer.guessParametersErrors();\n-        assertEquals(1.384, errors[0], 0.001);\n-        assertEquals(0.905, errors[1], 0.001);\n+        Assert.assertEquals(1.384, errors[0], 0.001);\n+        Assert.assertEquals(0.905, errors[1], 0.001);\n \n         // add perfect measurements and check errors are reduced\n         double  r = circle.getRadius(center);\n         Arrays.fill(weights, 2.0);\n         optimizer.optimize(100, circle, target, weights, new double[] { 98.680, 47.345 });\n         cov = optimizer.getCovariances();\n-        assertEquals(0.0016, cov[0][0], 0.001);\n-        assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n-        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n-        assertEquals(0.0016, cov[1][1], 0.001);\n+        Assert.assertEquals(0.0016, cov[0][0], 0.001);\n+        Assert.assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n+        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        Assert.assertEquals(0.0016, cov[1][1], 0.001);\n         errors = optimizer.guessParametersErrors();\n-        assertEquals(0.004, errors[0], 0.001);\n-        assertEquals(0.004, errors[1], 0.001);\n-    }\n-\n+        Assert.assertEquals(0.004, errors[0], 0.001);\n+        Assert.assertEquals(0.004, errors[1], 0.001);\n+    }\n+\n+    @Test\n     public void testCircleFittingBadInit() {\n         CircleVectorial circle = new CircleVectorial();\n         double[][] points = new double[][] {\n         VectorialPointValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        assertTrue(optimizer.getEvaluations() < 25);\n-        assertTrue(optimizer.getJacobianEvaluations() < 20);\n-        assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n-        assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n-        assertEquals(-0.151738,  center.x,      1.0e-6);\n-        assertEquals( 0.2075001, center.y,      1.0e-6);\n-    }\n-\n+        Assert.assertTrue(optimizer.getEvaluations() < 25);\n+        Assert.assertTrue(optimizer.getJacobianEvaluations() < 20);\n+        Assert.assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n+        Assert.assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n+        Assert.assertEquals(-0.151738,  center.x,      1.0e-6);\n+        Assert.assertEquals( 0.2075001, center.y,      1.0e-6);\n+    }\n+\n+    @Test\n     public void testMath199() {\n         try {\n             QuadraticProblem problem = new QuadraticProblem();\n                                new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },\n                                new double[] { 0, 0, 0 });\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class MinpackTest extends TestCase {\n-\n-  public MinpackTest(String name) {\n-    super(name);\n-  }\n-\n+public class MinpackTest {\n+\n+  @Test\n   public void testMinpackLinearFullRank() {\n     minpackTest(new LinearFullRankFunction(10, 5, 1.0,\n                                            5.0, 2.23606797749979), false);\n                                            8.06225774829855, 6.70820393249937), false);\n   }\n \n+  @Test\n   public void testMinpackLinearRank1() {\n     minpackTest(new LinearRank1Function(10, 5, 1.0,\n                                         291.521868819476, 1.4638501094228), false);\n                                         3101.60039334535, 3.48263016573496), false);\n   }\n \n+  @Test\n   public void testMinpackLinearRank1ZeroColsAndRows() {\n     minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);\n     minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);\n   }\n \n+  @Test\n   public void testMinpackRosenbrok() {\n     minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n                                        FastMath.sqrt(24.2)), false);\n                                        11.0 * FastMath.sqrt(169000121.0)), false);\n   }\n \n+  @Test\n   public void testMinpackHelicalValley() {\n     minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },\n                                           50.0), false);\n                                           991.261822123701), false);\n   }\n \n+  @Test\n   public void testMinpackPowellSingular() {\n     minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n                                            14.6628782986152), false);\n                                            126887.903284750), false);\n   }\n \n+  @Test\n   public void testMinpackFreudensteinRoth() {\n     minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n                                              20.0124960961895, 6.99887517584575,\n                                              }), false);\n   }\n \n+  @Test\n   public void testMinpackBard() {\n     minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n                                  new double[] {\n                                  }), false);\n   }\n \n+  @Test\n   public void testMinpackKowalikOsborne() {\n     minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n                                            0.0728915102882945,\n                                            }), false);\n   }\n \n+  @Test\n   public void testMinpackMeyer() {\n     minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n                                   41153.4665543031, 9.37794514651874,\n                                   }), true);\n   }\n \n+  @Test\n   public void testMinpackWatson() {\n \n     minpackTest(new WatsonFunction(6, 0.0,\n \n   }\n \n+  @Test\n   public void testMinpackBox3Dimensional() {\n     minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n                                             32.1115837449572), false);\n   }\n \n+  @Test\n   public void testMinpackJennrichSampson() {\n     minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                             64.5856498144943, 11.1517793413499,\n                                             }), false);\n   }\n \n+  @Test\n   public void testMinpackBrownDennis() {\n     minpackTest(new BrownDennisFunction(20,\n                                         new double[] { 25.0, 5.0, -5.0, -1.0 },\n                                         }), false);\n   }\n \n+  @Test\n   public void testMinpackChebyquad() {\n     minpackTest(new ChebyquadFunction(1, 8, 1.0,\n                                       1.88623796907732, 1.88623796907732,\n                                       }), false);\n   }\n \n+  @Test\n   public void testMinpackBrownAlmostLinear() {\n     minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n                                               16.5302162063499, 0.0,\n                                               }), false);\n     }\n \n+  @Test\n   public void testMinpackOsborne1() {\n       minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n                                        0.937564021037838, 0.00739249260904843,\n                                        }), false);\n     }\n \n+  @Test\n   public void testMinpackOsborne2() {\n \n     minpackTest(new Osborne2Function(new double[] {\n           = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16),\n                                             FastMath.sqrt(2.22044604926e-16),\n                                             2.22044604926e-16);\n-//      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n+//      Assert.assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n       try {\n           VectorialPointValuePair optimum =\n               optimizer.optimize(400 * (function.getN() + 1), function,\n                                  function.getTarget(), function.getWeight(),\n                                  function.getStartPoint());\n-          assertFalse(exceptionExpected);\n+          Assert.assertFalse(exceptionExpected);\n           function.checkTheoreticalMinCost(optimizer.getRMS());\n           function.checkTheoreticalMinParams(optimum);\n       } catch (TooManyEvaluationsException e) {\n-          assertTrue(exceptionExpected);\n+          Assert.assertTrue(exceptionExpected);\n       } catch (MathUserException fe) {\n-          assertTrue(exceptionExpected);\n+          Assert.assertTrue(exceptionExpected);\n       }\n   }\n \n \n       public void checkTheoreticalMinCost(double rms) {\n           double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n-          assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);\n+          Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);\n       }\n \n       public void checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n               for (int i = 0; i < theoreticalMinParams.length; ++i) {\n                   double mi = theoreticalMinParams[i];\n                   double vi = params[i];\n-                  assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));\n+                  Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));\n               }\n           }\n       }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.junit.Assert;\n import org.junit.Test;\n \n /**\n     public void testSinMin() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n-        assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n-        assertTrue(optimizer.getEvaluations() <= 50);\n-        assertEquals(200, optimizer.getMaxEvaluations());\n-        assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);\n-        assertTrue(optimizer.getEvaluations() <= 100);\n-        assertTrue(optimizer.getEvaluations() >= 15);\n+        Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n+        Assert.assertTrue(optimizer.getEvaluations() <= 50);\n+        Assert.assertEquals(200, optimizer.getMaxEvaluations());\n+        Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);\n+        Assert.assertTrue(optimizer.getEvaluations() <= 100);\n+        Assert.assertTrue(optimizer.getEvaluations() >= 15);\n         try {\n             optimizer.optimize(10, f, GoalType.MINIMIZE, 4, 5);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (TooManyEvaluationsException fee) {\n             // expected\n         }\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n-        assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n-        assertEquals( 0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n-        assertTrue(optimizer.getEvaluations() <= 50);\n+        Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n+        Assert.assertEquals( 0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n+        Assert.assertTrue(optimizer.getEvaluations() <= 50);\n \n         // search in a large interval\n-        assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);\n-        assertTrue(optimizer.getEvaluations() <= 50);\n+        Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);\n+        Assert.assertTrue(optimizer.getEvaluations() <= 50);\n     }\n \n     @Test\n \n         final double meanOptValue = stat[0].getMean();\n         final double medianEval = stat[1].getPercentile(50);\n-        assertTrue(meanOptValue > -0.2719561281);\n-        assertTrue(meanOptValue < -0.2719561280);\n-        assertEquals(23, (int) medianEval);\n+        Assert.assertTrue(meanOptValue > -0.2719561281);\n+        Assert.assertTrue(meanOptValue < -0.2719561280);\n+        Assert.assertEquals(23, (int) medianEval);\n     }\n \n     @Test\n         // The function has a local maximum at 0.27195613.\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);\n-        assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n+        Assert.assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n         try {\n             optimizer.optimize(5, f, GoalType.MAXIMIZE, 0.2, 0.3);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (TooManyEvaluationsException miee) {\n             // expected\n         }\n \n         // endpoint is minimum\n         double result = optimizer.optimize(50, f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();\n-        assertEquals(3 * Math.PI / 2, result, 1e-6);\n+        Assert.assertEquals(3 * Math.PI / 2, result, 1e-6);\n \n         result = optimizer.optimize(50, f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();\n-        assertEquals(3 * Math.PI / 2, result, 1e-6);\n+        Assert.assertEquals(3 * Math.PI / 2, result, 1e-6);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n         UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n         for (int i = 1; i < optima.length; ++i) {\n             double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);\n-            assertTrue (FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);\n-            assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);\n-            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);\n+            Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);\n+            Assert.assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);\n+            Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);\n         }\n-        assertTrue(optimizer.getEvaluations() > 200);\n-        assertTrue(optimizer.getEvaluations() < 300);\n+        Assert.assertTrue(optimizer.getEvaluations() > 200);\n+        Assert.assertTrue(optimizer.getEvaluations() < 300);\n     }\n \n     @Test\n \n         UnivariateRealPointValuePair optimum\n             = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n-        assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n-        assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n+        Assert.assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n+        Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n \n         UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n         for (int i = 0; i < optima.length; ++i) {\n-            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n+            Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n         }\n-        assertTrue(optimizer.getEvaluations() >= 50);\n-        assertTrue(optimizer.getEvaluations() <= 100);\n+        Assert.assertTrue(optimizer.getEvaluations() >= 50);\n+        Assert.assertTrue(optimizer.getEvaluations() <= 100);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n \n import org.apache.commons.math.stat.Frequency;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the AbstractRandomGenerator class\n \n     protected TestRandomGenerator testGenerator = new TestRandomGenerator();\n \n-    public AbstractRandomGeneratorTest(String name) {\n-        super(name);\n+    public AbstractRandomGeneratorTest() {\n         randomData = new RandomDataImpl(testGenerator);\n     }\n \n     @Override\n+    @Test\n     public void testNextInt() {\n         try {\n             testGenerator.nextInt(-1);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         int value = 0;\n         for (int i=0; i<smallSampleSize; i++) {\n             value = testGenerator.nextInt(4);\n-            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            Assert.assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n             freq.addValue(value);\n         }\n         long[] observed = new long[4];\n         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n          * Change to 11.34 for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected,observed) < 16.27);\n     }\n \n     @Override\n+    @Test\n     public void testNextLong() {\n         long q1 = Long.MAX_VALUE/4;\n         long q2 = 2 *  q1;\n         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n          * Change to 11.34 for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected,observed) < 16.27);\n     }\n \n+    @Test\n     public void testNextBoolean() {\n         long halfSampleSize = smallSampleSize / 2;\n         double[] expected = {halfSampleSize, halfSampleSize};\n         /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n          * Change to 6.635 for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected,observed) < 10.828);\n     }\n \n+    @Test\n     public void testNextFloat() {\n         Frequency freq = new Frequency();\n         float val = 0;\n         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n          * Change to 11.34 for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected,observed) < 16.27);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Test cases for the EmpiricalDistribution class\n     protected URL url = null;\n     protected double[] dataArray = null;\n \n-    public EmpiricalDistributionTest(String name) {\n-        super(name);\n-    }\n-\n-    @Override\n+    @Before\n     public void setUp() throws IOException {\n         empiricalDistribution = new EmpiricalDistributionImpl(100);\n         url = getClass().getResource(\"testData.txt\");\n      * Check that the sampleCount, mu and sigma match data in\n      * the sample data file.\n      */\n+    @Test\n     public void testLoad() throws Exception {\n         empiricalDistribution.load(url);\n         // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n         // Make sure that loaded distribution matches this\n-        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);\n+        Assert.assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);\n         //TODO: replace with statistical tests\n-        assertEquals\n-            (empiricalDistribution.getSampleStats().getMean(),\n+        Assert.assertEquals(empiricalDistribution.getSampleStats().getMean(),\n                 5.069831575018909,10E-7);\n-        assertEquals\n-          (empiricalDistribution.getSampleStats().getStandardDeviation(),\n+        Assert.assertEquals(empiricalDistribution.getSampleStats().getStandardDeviation(),\n                 1.0173699343977738,10E-7);\n     }\n \n      * Check that the sampleCount, mu and sigma match data in\n      * the sample data file.\n      */\n+    @Test\n     public void testDoubleLoad() throws Exception {\n         empiricalDistribution2.load(dataArray);\n         // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n         // Make sure that loaded distribution matches this\n-        assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);\n+        Assert.assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);\n         //TODO: replace with statistical tests\n-        assertEquals\n-            (empiricalDistribution2.getSampleStats().getMean(),\n+        Assert.assertEquals(empiricalDistribution2.getSampleStats().getMean(),\n                 5.069831575018909,10E-7);\n-        assertEquals\n-          (empiricalDistribution2.getSampleStats().getStandardDeviation(),\n+        Assert.assertEquals(empiricalDistribution2.getSampleStats().getStandardDeviation(),\n                 1.0173699343977738,10E-7);\n \n         double[] bounds = ((EmpiricalDistributionImpl) empiricalDistribution2).getGeneratorUpperBounds();\n-        assertEquals(bounds.length, 100);\n-        assertEquals(bounds[99], 1.0, 10e-12);\n+        Assert.assertEquals(bounds.length, 100);\n+        Assert.assertEquals(bounds[99], 1.0, 10e-12);\n \n     }\n \n       * Note that there is a non-zero (but very small) probability that\n       * these tests will fail even if the code is working as designed.\n       */\n+    @Test\n     public void testNext() throws Exception {\n         tstGen(0.1);\n         tstDoubleGen(0.1);\n       * Make sure exception thrown if digest getNext is attempted\n       * before loading empiricalDistribution.\n      */\n+    @Test\n     public void testNexFail() {\n         try {\n             empiricalDistribution.getNextValue();\n             empiricalDistribution2.getNextValue();\n-            fail(\"Expecting IllegalStateException\");\n+            Assert.fail(\"Expecting IllegalStateException\");\n         } catch (IllegalStateException ex) {\n             // expected\n         }\n     /**\n      * Make sure we can handle a grid size that is too fine\n      */\n+    @Test\n     public void testGridTooFine() throws Exception {\n         empiricalDistribution = new EmpiricalDistributionImpl(1001);\n         tstGen(0.1);\n     /**\n      * How about too fat?\n      */\n+    @Test\n     public void testGridTooFat() throws Exception {\n         empiricalDistribution = new EmpiricalDistributionImpl(1);\n         tstGen(5); // ridiculous tolerance; but ridiculous grid size\n     /**\n      * Test bin index overflow problem (BZ 36450)\n      */\n+    @Test\n     public void testBinIndexOverflow() throws Exception {\n         double[] x = new double[] {9474.94326071674, 2080107.8865462579};\n         new EmpiricalDistributionImpl().load(x);\n     }\n \n+    @Test\n     public void testSerialization() {\n         // Empty\n         EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n         verifySame(empiricalDistribution2, dist2);\n     }\n \n+    @Test\n     public void testLoadNullDoubleArray() {\n         EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n         try {\n             dist.load((double[]) null);\n-            fail(\"load((double[]) null) expected NullPointerException\");\n+            Assert.fail(\"load((double[]) null) expected NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testLoadNullURL() throws Exception {\n         EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n         try {\n             dist.load((URL) null);\n-            fail(\"load((URL) null) expected NullPointerException\");\n+            Assert.fail(\"load((URL) null) expected NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testLoadNullFile() throws Exception {\n         EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n         try {\n             dist.load((File) null);\n-            fail(\"load((File) null) expected NullPointerException\");\n+            Assert.fail(\"load((File) null) expected NullPointerException\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n     /**\n      * MATH-298\n      */\n+    @Test\n     public void testGetBinUpperBounds() {\n         double[] testData = {0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10};\n         EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl(5);\n     }\n \n     private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {\n-        assertEquals(d1.isLoaded(), d2.isLoaded());\n-        assertEquals(d1.getBinCount(), d2.getBinCount());\n-        assertEquals(d1.getSampleStats(), d2.getSampleStats());\n+        Assert.assertEquals(d1.isLoaded(), d2.isLoaded());\n+        Assert.assertEquals(d1.getBinCount(), d2.getBinCount());\n+        Assert.assertEquals(d1.getSampleStats(), d2.getSampleStats());\n         if (d1.isLoaded()) {\n             for (int i = 0;  i < d1.getUpperBounds().length; i++) {\n-                assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);\n+                Assert.assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);\n             }\n-            assertEquals(d1.getBinStats(), d2.getBinStats());\n+            Assert.assertEquals(d1.getBinStats(), d2.getBinStats());\n         }\n     }\n \n         for (int i = 1; i < 1000; i++) {\n             stats.addValue(empiricalDistribution.getNextValue());\n         }\n-        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n-        assertEquals\n-         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+        Assert.assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        Assert.assertEquals(\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n     }\n \n     private void tstDoubleGen(double tolerance)throws Exception {\n         for (int i = 1; i < 1000; i++) {\n             stats.addValue(empiricalDistribution2.getNextValue());\n         }\n-        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n-        assertEquals\n-         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+        Assert.assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        Assert.assertEquals(\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/random/GaussianRandomGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/GaussianRandomGeneratorTest.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.stat.StatUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.*;\n \n-public class GaussianRandomGeneratorTest\n-extends TestCase {\n+public class GaussianRandomGeneratorTest {\n \n-    public GaussianRandomGeneratorTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testMeanAndStandardDeviation() {\n         RandomGenerator rg = new JDKRandomGenerator();\n         rg.setSeed(17399225432l);\n         for (int i = 0; i < sample.length; ++i) {\n             sample[i] = generator.nextNormalizedDouble();\n         }\n-        assertEquals(0.0, StatUtils.mean(sample), 0.012);\n-        assertEquals(1.0, StatUtils.variance(sample), 0.01);\n+        Assert.assertEquals(0.0, StatUtils.mean(sample), 0.012);\n+        Assert.assertEquals(1.0, StatUtils.variance(sample), 0.01);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n+++ b/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n  */\n package org.apache.commons.math.random;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class MersenneTwisterTest {\n         for (int i = 0; i < 1000; ++i) {\n             sample.addValue(mt.nextGaussian());\n         }\n-        assertEquals(0.0, sample.getMean(), 0.005);\n-        assertEquals(1.0, sample.getStandardDeviation(), 0.025);\n+        Assert.assertEquals(0.0, sample.getMean(), 0.005);\n+        Assert.assertEquals(1.0, sample.getStandardDeviation(), 0.025);\n     }\n \n     @Test\n         for (int i = 0; i < 1000; ++i) {\n             sample.addValue(mt.nextDouble());\n         }\n-        assertEquals(0.5, sample.getMean(), 0.02);\n-        assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n+        Assert.assertEquals(0.5, sample.getMean(), 0.02);\n+        Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n                      sample.getStandardDeviation(),\n                      0.002);\n     }\n         for (int i = 0; i < 1000; ++i) {\n             sample.addValue(mt.nextFloat());\n         }\n-        assertEquals(0.5, sample.getMean(), 0.01);\n-        assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n+        Assert.assertEquals(0.5, sample.getMean(), 0.01);\n+        Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n                      sample.getStandardDeviation(),\n                      0.006);\n     }\n             for (int k = 0; k < 10000; ++k) {\n                 int l = mt.nextInt(n);\n                 ++count[l];\n-                assertTrue(l >= 0);\n-                assertTrue(l <  n);\n+                Assert.assertTrue(l >= 0);\n+                Assert.assertTrue(l <  n);\n             }\n             for (int i = 0; i < n; ++i) {\n-                assertTrue(n * count[i] >  8600);\n-                assertTrue(n * count[i] < 11200);\n+                Assert.assertTrue(n * count[i] >  8600);\n+                Assert.assertTrue(n * count[i] < 11200);\n             }\n         }\n     }\n                --walk;\n            }\n         }\n-        assertTrue(FastMath.abs(walk) < 120);\n+        Assert.assertTrue(FastMath.abs(walk) < 120);\n     }\n \n     @Test\n                --walk;\n            }\n         }\n-        assertTrue(FastMath.abs(walk) < 50);\n+        Assert.assertTrue(FastMath.abs(walk) < 50);\n     }\n \n     @Test\n                --walk;\n            }\n         }\n-        assertTrue(FastMath.abs(walk) < 250);\n+        Assert.assertTrue(FastMath.abs(walk) < 250);\n     }\n \n     @Test\n             max = FastMath.max(max, c);\n         }\n         int expected = (100000 * bytes.length) / count.length;\n-        assertTrue((expected - 200) < min);\n-        assertTrue(max < (expected + 200));\n+        Assert.assertTrue((expected - 200) < min);\n+        Assert.assertTrue(max < (expected + 200));\n     }\n \n     @Test\n \n         for (int i = 0; i < refInt.length; ++i) {\n             int r = mt.nextInt();\n-            assertEquals(refInt[i], (r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l));\n+            Assert.assertEquals(refInt[i], (r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l));\n         }\n \n         for (int i = 0; i < refDouble.length; ++i) {\n             int r = mt.nextInt();\n-            assertEquals(refDouble[i],\n+            Assert.assertEquals(refDouble[i],\n                          ((r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l)) / 4294967296.0,\n                          1.0e-8);\n         }\n--- a/src/test/java/org/apache/commons/math/random/RandomAdaptorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomAdaptorTest.java\n \n import java.util.Random;\n \n+import org.junit.Assert;\n+import org.junit.Test;\n+\n /**\n  * Test cases for the RandomAdaptor class\n  *\n \n public class RandomAdaptorTest extends RandomDataTest {\n \n-    public RandomAdaptorTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testAdaptor() {\n         ConstantGenerator generator = new ConstantGenerator();\n         Random random = RandomAdaptor.createAdaptor(generator);\n     private void checkConstant(Random random) {\n         byte[] bytes = new byte[] {0};\n         random.nextBytes(bytes);\n-        assertEquals(0, bytes[0]);\n-        assertEquals(false, random.nextBoolean());\n-        assertEquals(0, random.nextDouble(), 0);\n-        assertEquals(0, random.nextFloat(), 0);\n-        assertEquals(0, random.nextGaussian(), 0);\n-        assertEquals(0, random.nextInt());\n-        assertEquals(0, random.nextInt(1));\n-        assertEquals(0, random.nextLong());\n+        Assert.assertEquals(0, bytes[0]);\n+        Assert.assertEquals(false, random.nextBoolean());\n+        Assert.assertEquals(0, random.nextDouble(), 0);\n+        Assert.assertEquals(0, random.nextFloat(), 0);\n+        Assert.assertEquals(0, random.nextGaussian(), 0);\n+        Assert.assertEquals(0, random.nextInt());\n+        Assert.assertEquals(0, random.nextInt(1));\n+        Assert.assertEquals(0, random.nextLong());\n         random.setSeed(100);\n-        assertEquals(0, random.nextDouble(), 0);\n+        Assert.assertEquals(0, random.nextDouble(), 0);\n     }\n \n     /*\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import java.util.HashSet;\n import java.util.List;\n \n-import junit.framework.AssertionFailedError;\n \n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the RandomData class.\n \n public class RandomDataTest extends RetryTestCase {\n \n-    public RandomDataTest(String name) {\n-        super(name);\n+    public RandomDataTest() {\n         randomData = new RandomDataImpl();\n     }\n \n     protected RandomDataImpl randomData = null;\n     protected final ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n \n+    @Test\n     public void testNextIntExtremeValues() {\n         int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        assertFalse(x == y);\n-    }\n-\n+        Assert.assertFalse(x == y);\n+    }\n+\n+    @Test\n     public void testNextLongExtremeValues() {\n         long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n         long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n-        assertFalse(x == y);\n+        Assert.assertFalse(x == y);\n     }\n \n     /** test dispersion and failure modes for nextInt() */\n+    @Test\n     public void testNextInt() {\n         try {\n             randomData.nextInt(4, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         int value = 0;\n         for (int i = 0; i < smallSampleSize; i++) {\n             value = randomData.nextInt(0, 3);\n-            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n             freq.addValue(value);\n         }\n         long[] observed = new long[4];\n          * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 16.27);\n     }\n \n     /** test dispersion and failure modes for nextLong() */\n+    @Test\n     public void testNextLong() {\n         try {\n             randomData.nextLong(4, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         long value = 0;\n         for (int i = 0; i < smallSampleSize; i++) {\n             value = randomData.nextLong(0, 3);\n-            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n             freq.addValue(value);\n         }\n         long[] observed = new long[4];\n          * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 16.27);\n     }\n \n     /** test dispersion and failure modes for nextSecureLong() */\n+    @Test\n     public void testNextSecureLong() {\n         try {\n             randomData.nextSecureLong(4, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         long value = 0;\n         for (int i = 0; i < smallSampleSize; i++) {\n             value = randomData.nextSecureLong(0, 3);\n-            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n             freq.addValue(value);\n         }\n         long[] observed = new long[4];\n          * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 16.27);\n     }\n \n     /** test dispersion and failure modes for nextSecureInt() */\n+    @Test\n     public void testNextSecureInt() {\n         try {\n             randomData.nextSecureInt(4, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         int value = 0;\n         for (int i = 0; i < smallSampleSize; i++) {\n             value = randomData.nextSecureInt(0, 3);\n-            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n             freq.addValue(value);\n         }\n         long[] observed = new long[4];\n          * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 16.27);\n     }\n \n      * fails when mean is non-positive TODO: replace with statistical test,\n      * adding test stat to TestStatistic\n      */\n+    @Test\n     public void testNextPoisson() {\n         try {\n             randomData.nextPoisson(0);\n-            fail(\"zero mean -- expecting MathIllegalArgumentException\");\n+            Assert.fail(\"zero mean -- expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         long sumFreq = f.getSumFreq();\n         double cumPct = Double.valueOf(cumFreq).doubleValue()\n                 / Double.valueOf(sumFreq).doubleValue();\n-        assertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n+        Assert.assertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n         try {\n             randomData.nextPoisson(-1);\n-            fail(\"negative mean supplied -- MathIllegalArgumentException expected\");\n+            Assert.fail(\"negative mean supplied -- MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextPoisson(0);\n-            fail(\"0 mean supplied -- MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-\n-    }\n-\n+            Assert.fail(\"0 mean supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+    }\n+\n+    @Test\n     public void testNextPoissonConsistency() throws Exception {\n         \n         // Reseed randomGenerator to get fixed sequence\n \n         // Use chisquare test to verify that generated values are poisson(mean)-distributed\n         ChiSquareTest chiSquareTest = new ChiSquareTestImpl();\n-        try {\n             // Fail if we can reject null hypothesis that distributions are the same\n-            assertFalse(chiSquareTest.chiSquareTest(expected, observed, alpha));\n-        } catch (AssertionFailedError ex) {\n+        if (chiSquareTest.chiSquareTest(expected, observed, alpha)) {\n             StringBuilder msgBuffer = new StringBuilder();\n             DecimalFormat df = new DecimalFormat(\"#.##\");\n             msgBuffer.append(\"Chisquare test failed for mean = \");\n             msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n             msgBuffer.append(alpha);\n             msgBuffer.append(\".\");\n-            fail(msgBuffer.toString());\n+            Assert.fail(msgBuffer.toString());\n         }\n     }\n \n     /** test dispersion and failure modes for nextHex() */\n+    @Test\n     public void testNextHex() {\n         try {\n             randomData.nextHexString(-1);\n-            fail(\"negative length supplied -- MathIllegalArgumentException expected\");\n+            Assert.fail(\"negative length supplied -- MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextHexString(0);\n-            fail(\"zero length supplied -- MathIllegalArgumentException expected\");\n+            Assert.fail(\"zero length supplied -- MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         String hexString = randomData.nextHexString(3);\n         if (hexString.length() != 3) {\n-            fail(\"incorrect length for generated string\");\n+            Assert.fail(\"incorrect length for generated string\");\n         }\n         hexString = randomData.nextHexString(1);\n         if (hexString.length() != 1) {\n-            fail(\"incorrect length for generated string\");\n+            Assert.fail(\"incorrect length for generated string\");\n         }\n         try {\n             hexString = randomData.nextHexString(0);\n-            fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n+            Assert.fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         if (hexString.length() != 1) {\n-            fail(\"incorrect length for generated string\");\n+            Assert.fail(\"incorrect length for generated string\");\n         }\n         Frequency f = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n             hexString = randomData.nextHexString(100);\n             if (hexString.length() != 100) {\n-                fail(\"incorrect length for generated string\");\n+                Assert.fail(\"incorrect length for generated string\");\n             }\n             for (int j = 0; j < hexString.length(); j++) {\n                 f.addValue(hexString.substring(j, j + 1));\n          * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 37.70);\n     }\n \n     /** test dispersion and failure modes for nextHex() */\n+    @Test\n     public void testNextSecureHex() {\n         try {\n             randomData.nextSecureHexString(-1);\n-            fail(\"negative length -- MathIllegalArgumentException expected\");\n+            Assert.fail(\"negative length -- MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextSecureHexString(0);\n-            fail(\"zero length -- MathIllegalArgumentException expected\");\n+            Assert.fail(\"zero length -- MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         String hexString = randomData.nextSecureHexString(3);\n         if (hexString.length() != 3) {\n-            fail(\"incorrect length for generated string\");\n+            Assert.fail(\"incorrect length for generated string\");\n         }\n         hexString = randomData.nextSecureHexString(1);\n         if (hexString.length() != 1) {\n-            fail(\"incorrect length for generated string\");\n+            Assert.fail(\"incorrect length for generated string\");\n         }\n         try {\n             hexString = randomData.nextSecureHexString(0);\n-            fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n+            Assert.fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         if (hexString.length() != 1) {\n-            fail(\"incorrect length for generated string\");\n+            Assert.fail(\"incorrect length for generated string\");\n         }\n         Frequency f = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n             hexString = randomData.nextSecureHexString(100);\n             if (hexString.length() != 100) {\n-                fail(\"incorrect length for generated string\");\n+                Assert.fail(\"incorrect length for generated string\");\n             }\n             for (int j = 0; j < hexString.length(); j++) {\n                 f.addValue(hexString.substring(j, j + 1));\n          * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 37.70);\n     }\n \n     /** test failure modes and dispersion of nextUniform() */\n+    @Test\n     public void testNextUniform() {\n         try {\n             randomData.nextUniform(4, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextUniform(3, 3);\n-            fail(\"MathIllegalArgumentException expected\");\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         for (int i = 0; i < 1000; i++) {\n             result = randomData.nextUniform(lower, upper);\n             if ((result == lower) || (result == upper)) {\n-                fail(\"generated value equal to an endpoint: \" + result);\n+                Assert.fail(\"generated value equal to an endpoint: \" + result);\n             }\n             if (result < midpoint) {\n                 observed[0]++;\n          * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for\n          * alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 10.83);\n     }\n \n     /** test exclusive endpoints of nextUniform **/\n+    @Test\n     public void testNextUniformExclusiveEndpoints() {\n         for (int i = 0; i < 1000; i++) {\n             double u = randomData.nextUniform(0.99, 1);\n-            assertTrue(u > 0.99 && u < 1);\n+            Assert.assertTrue(u > 0.99 && u < 1);\n         }\n     }\n \n     /** test failure modes and distribution of nextGaussian() */\n+    @Test\n     public void testNextGaussian() {\n         try {\n             randomData.nextGaussian(0, 0);\n-            fail(\"zero sigma -- MathIllegalArgumentException expected\");\n+            Assert.fail(\"zero sigma -- MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n          * t-test at .001-level TODO: replace with externalized t-test, with\n          * test statistic defined in TestStatistic\n          */\n-        assertTrue(FastMath.abs(xbar) / (s / FastMath.sqrt(n)) < 3.29);\n+        Assert.assertTrue(FastMath.abs(xbar) / (s / FastMath.sqrt(n)) < 3.29);\n     }\n \n     /** test failure modes and distribution of nextExponential() */\n+    @Test\n     public void testNextExponential() {\n         try {\n             randomData.nextExponential(-1);\n-            fail(\"negative mean -- expecting MathIllegalArgumentException\");\n+            Assert.fail(\"negative mean -- expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextExponential(0);\n-            fail(\"zero mean -- expecting MathIllegalArgumentException\");\n+            Assert.fail(\"zero mean -- expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         double v = 0;\n         for (int i = 0; i < largeSampleSize; i++) {\n             v = randomData.nextExponential(1);\n-            assertTrue(\"exponential deviate postive\", v > 0);\n+            Assert.assertTrue(\"exponential deviate postive\", v > 0);\n             if (v < 2)\n                 cumFreq++;\n         }\n          * TestStatistic. Check below compares observed cumulative distribution\n          * evaluated at 2 with exponential CDF\n          */\n-        assertEquals(\"exponential cumulative distribution\", (double) cumFreq\n+        Assert.assertEquals(\"exponential cumulative distribution\", (double) cumFreq\n                 / (double) largeSampleSize, 0.8646647167633873, .2);\n     }\n \n     /** test reseeding, algorithm/provider games */\n+    @Test\n     public void testConfig() {\n         randomData.reSeed(1000);\n         double v = randomData.nextUniform(0, 1);\n         randomData.reSeed();\n-        assertTrue(\"different seeds\", Math\n+        Assert.assertTrue(\"different seeds\", Math\n                 .abs(v - randomData.nextUniform(0, 1)) > 10E-12);\n         randomData.reSeed(1000);\n-        assertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n+        Assert.assertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n         randomData.reSeedSecure(1000);\n         String hex = randomData.nextSecureHexString(40);\n         randomData.reSeedSecure();\n-        assertTrue(\"different seeds\", !hex.equals(randomData\n+        Assert.assertTrue(\"different seeds\", !hex.equals(randomData\n                 .nextSecureHexString(40)));\n         randomData.reSeedSecure(1000);\n-        assertTrue(\"same seeds\", !hex\n+        Assert.assertTrue(\"same seeds\", !hex\n                 .equals(randomData.nextSecureHexString(40)));\n \n         /*\n          * remove this test back soon, since it takes about 4 seconds\n          *\n          * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n-         * (NoSuchProviderException ex) { ; } assertTrue(\"different seeds\",\n+         * (NoSuchProviderException ex) { ; } Assert.assertTrue(\"different seeds\",\n          * !hex.equals(randomData.nextSecureHexString(40))); try {\n          * randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n-         * fail(\"expecting NoSuchAlgorithmException\"); } catch\n+         * Assert.fail(\"expecting NoSuchAlgorithmException\"); } catch\n          * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n          * ex) { ; }\n          *\n          * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n-         * fail(\"expecting NoSuchProviderException\"); } catch\n+         * Assert.fail(\"expecting NoSuchProviderException\"); } catch\n          * (NoSuchProviderException ex) { ; }\n          */\n \n     }\n \n     /** tests for nextSample() sampling from Collection */\n+    @Test\n     public void testNextSample() {\n         Object[][] c = { { \"0\", \"1\" }, { \"0\", \"2\" }, { \"0\", \"3\" },\n                 { \"0\", \"4\" }, { \"1\", \"2\" }, { \"1\", \"3\" }, { \"1\", \"4\" },\n          * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 27.88);\n \n         // Make sure sample of size = size of collection returns same collection\n         Object[] one = randomData.nextSample(hs, 1);\n         String oneString = (String) one[0];\n         if ((one.length != 1) || !oneString.equals(\"one\")) {\n-            fail(\"bad sample for set size = 1, sample size = 1\");\n+            Assert.fail(\"bad sample for set size = 1, sample size = 1\");\n         }\n \n         // Make sure we fail for sample size > collection size\n         try {\n             one = randomData.nextSample(hs, 2);\n-            fail(\"sample size > set size, expecting MathIllegalArgumentException\");\n+            Assert.fail(\"sample size > set size, expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             hs = new HashSet<Object>();\n             one = randomData.nextSample(hs, 0);\n-            fail(\"n = k = 0, expecting MathIllegalArgumentException\");\n+            Assert.fail(\"n = k = 0, expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n                 return i;\n             }\n         }\n-        fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+        Assert.fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n         return -1;\n     }\n \n     /** tests for nextPermutation */\n+    @Test\n     public void testNextPermutation() {\n         int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },\n                 { 2, 0, 1 }, { 2, 1, 0 } };\n          * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09\n          * for alpha = .01\n          */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n                 testStatistic.chiSquare(expected, observed) < 20.52);\n \n         // Check size = 1 boundary case\n         int[] perm = randomData.nextPermutation(1, 1);\n         if ((perm.length != 1) || (perm[0] != 0)) {\n-            fail(\"bad permutation for n = 1, sample k = 1\");\n+            Assert.fail(\"bad permutation for n = 1, sample k = 1\");\n \n             // Make sure we fail for k size > n\n             try {\n                 perm = randomData.nextPermutation(2, 3);\n-                fail(\"permutation k > n, expecting MathIllegalArgumentException\");\n+                Assert.fail(\"permutation k > n, expecting MathIllegalArgumentException\");\n             } catch (MathIllegalArgumentException ex) {\n                 // ignored\n             }\n             // Make sure we fail for n = 0\n             try {\n                 perm = randomData.nextPermutation(0, 0);\n-                fail(\"permutation k = n = 0, expecting MathIllegalArgumentException\");\n+                Assert.fail(\"permutation k = n = 0, expecting MathIllegalArgumentException\");\n             } catch (MathIllegalArgumentException ex) {\n                 // ignored\n             }\n             // Make sure we fail for k < n < 0\n             try {\n                 perm = randomData.nextPermutation(-1, -3);\n-                fail(\"permutation k < n < 0, expecting MathIllegalArgumentException\");\n+                Assert.fail(\"permutation k < n < 0, expecting MathIllegalArgumentException\");\n             } catch (MathIllegalArgumentException ex) {\n                 // ignored\n             }\n \n     // Disable until we have equals\n     //public void testSerial() {\n-    //    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n+    //    Assert.assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n     //}\n \n     private int findPerm(int[][] p, int[] samp) {\n                 return i;\n             }\n         }\n-        fail(\"permutation not found\");\n+        Assert.fail(\"permutation not found\");\n         return -1;\n     }\n     \n+    @Test\n     public void testNextInversionDeviate() throws Exception {\n         // Set the seed for the default random generator\n         randomData.reSeed(100);\n          */\n         for (int i = 0; i < 10; i++) {\n             double value = randomData.nextInversionDeviate(betaDistribution);\n-            assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);\n+            Assert.assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);\n         } \n     }\n     \n+    @Test\n     public void testNextBeta() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistributionImpl(2,5));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextCauchy() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextChiSquare() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistributionImpl(12));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextF() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new FDistributionImpl(12, 5));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextGamma() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextT() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new TDistributionImpl(10));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextWeibull() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));\n         long[] counts = new long[4];\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n+    @Test\n     public void testNextBinomial() throws Exception {\n-        BinomialDistributionTest testInstance = new BinomialDistributionTest(\"\");\n+        BinomialDistributionTest testInstance = new BinomialDistributionTest();\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n     \n+    @Test\n     public void testNextHypergeometric() throws Exception {\n-        HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest(\"\");\n+        HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest();\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n     \n+    @Test\n     public void testNextPascal() throws Exception {\n-        PascalDistributionTest testInstance = new PascalDistributionTest(\"\");\n+        PascalDistributionTest testInstance = new PascalDistributionTest();\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n     \n+    @Test\n     public void testNextZipf() throws Exception {\n-        ZipfDistributionTest testInstance = new ZipfDistributionTest(\"\");\n+        ZipfDistributionTest testInstance = new ZipfDistributionTest();\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n--- a/src/test/java/org/apache/commons/math/random/UniformRandomGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/UniformRandomGeneratorTest.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.stat.StatUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.*;\n \n-public class UniformRandomGeneratorTest\n-extends TestCase {\n+public class UniformRandomGeneratorTest {\n \n-    public UniformRandomGeneratorTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testMeanAndStandardDeviation() {\n         RandomGenerator rg = new JDKRandomGenerator();\n         rg.setSeed(17399225432l);\n         for (int i = 0; i < sample.length; ++i) {\n             sample[i] = generator.nextNormalizedDouble();\n         }\n-        assertEquals(0.0, StatUtils.mean(sample), 0.07);\n-        assertEquals(1.0, StatUtils.variance(sample), 0.02);\n+        Assert.assertEquals(0.0, StatUtils.mean(sample), 0.07);\n+        Assert.assertEquals(1.0, StatUtils.variance(sample), 0.02);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/random/ValueServerTest.java\n+++ b/src/test/java/org/apache/commons/math/random/ValueServerTest.java\n \n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Test cases for the ValueServer class.\n \n     private ValueServer vs = new ValueServer();\n \n-    public ValueServerTest(String name) {\n-        super(name);\n-    }\n-\n-    @Override\n+    @Before\n     public void setUp() {\n         vs.setMode(ValueServer.DIGEST_MODE);\n         URL url = getClass().getResource(\"testData.txt\");\n       * Note that there is a non-zero (but very small) probability that\n       * these tests will fail even if the code is working as designed.\n       */\n+    @Test\n     public void testNextDigest() throws Exception{\n         double next = 0.0;\n         double tolerance = 0.1;\n         vs.computeDistribution();\n-        assertTrue(\"empirical distribution property\",\n+        Assert.assertTrue(\"empirical distribution property\",\n             vs.getEmpiricalDistribution() != null);\n         SummaryStatistics stats = new SummaryStatistics();\n         for (int i = 1; i < 1000; i++) {\n             next = vs.getNext();\n             stats.addValue(next);\n         }\n-        assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n-        assertEquals\n-         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(),\n+        Assert.assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n+        Assert.assertEquals(\"std dev\", 1.0173699343977738, stats.getStandardDeviation(),\n             tolerance);\n \n         vs.computeDistribution(500);\n             next = vs.getNext();\n             stats.addValue(next);\n         }\n-        assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n-        assertEquals\n-         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(),\n+        Assert.assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n+        Assert.assertEquals(\"std dev\", 1.0173699343977738, stats.getStandardDeviation(),\n             tolerance);\n \n     }\n       * Make sure exception thrown if digest getNext is attempted\n       * before loading empiricalDistribution.\n       */\n+    @Test\n     public void testNextDigestFail() throws Exception {\n         try {\n             vs.getNext();\n-            fail(\"Expecting IllegalStateException\");\n+            Assert.fail(\"Expecting IllegalStateException\");\n         } catch (IllegalStateException ex) {}\n     }\n \n+    @Test\n     public void testEmptyReplayFile() throws Exception {\n         try {\n             URL url = getClass().getResource(\"emptyFile.txt\");\n             vs.setMode(ValueServer.REPLAY_MODE);\n             vs.setValuesFileURL(url);\n             vs.getNext();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (EOFException eof) {\n             // expected behavior\n         }\n     }\n \n+    @Test\n     public void testEmptyDigestFile() throws Exception {\n         try {\n             URL url = getClass().getResource(\"emptyFile.txt\");\n             vs.setMode(ValueServer.DIGEST_MODE);\n             vs.setValuesFileURL(url);\n             vs.computeDistribution();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (EOFException eof) {\n             // expected behavior\n         }\n      * Check that the values 1,2,1001,1002 match data file values 1 and 2.\n      * the sample data file.\n      */\n+    @Test\n     public void testReplay() throws Exception {\n         double firstDataValue = 4.038625496201205;\n         double secondDataValue = 3.6485326248346936;\n         vs.setMode(ValueServer.REPLAY_MODE);\n         vs.resetReplayFile();\n         compareValue = vs.getNext();\n-        assertEquals(compareValue,firstDataValue,tolerance);\n-        compareValue = vs.getNext();\n-        assertEquals(compareValue,secondDataValue,tolerance);\n+        Assert.assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        Assert.assertEquals(compareValue,secondDataValue,tolerance);\n         for (int i = 3; i < 1001; i++) {\n            compareValue = vs.getNext();\n         }\n         compareValue = vs.getNext();\n-        assertEquals(compareValue,firstDataValue,tolerance);\n-        compareValue = vs.getNext();\n-        assertEquals(compareValue,secondDataValue,tolerance);\n+        Assert.assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        Assert.assertEquals(compareValue,secondDataValue,tolerance);\n         vs.closeReplayFile();\n         // make sure no NPE\n         vs.closeReplayFile();\n     /**\n      * Test other ValueServer modes\n      */\n+    @Test\n     public void testModes() throws Exception {\n         vs.setMode(ValueServer.CONSTANT_MODE);\n         vs.setMu(0);\n-        assertEquals(\"constant mode test\",vs.getMu(),vs.getNext(),Double.MIN_VALUE);\n+        Assert.assertEquals(\"constant mode test\",vs.getMu(),vs.getNext(),Double.MIN_VALUE);\n         vs.setMode(ValueServer.UNIFORM_MODE);\n         vs.setMu(2);\n         double val = vs.getNext();\n-        assertTrue(val > 0 && val < 4);\n+        Assert.assertTrue(val > 0 && val < 4);\n         vs.setSigma(1);\n         vs.setMode(ValueServer.GAUSSIAN_MODE);\n         val = vs.getNext();\n-        assertTrue(\"gaussian value close enough to mean\",\n+        Assert.assertTrue(\"gaussian value close enough to mean\",\n             val < vs.getMu() + 100*vs.getSigma());\n         vs.setMode(ValueServer.EXPONENTIAL_MODE);\n         val = vs.getNext();\n-        assertTrue(val > 0);\n+        Assert.assertTrue(val > 0);\n         try {\n             vs.setMode(1000);\n             vs.getNext();\n-            fail(\"bad mode, expecting IllegalStateException\");\n+            Assert.fail(\"bad mode, expecting IllegalStateException\");\n         } catch (IllegalStateException ex) {\n             // ignored\n         }\n     /**\n      * Test fill\n      */\n+    @Test\n     public void testFill() throws Exception {\n         vs.setMode(ValueServer.CONSTANT_MODE);\n         vs.setMu(2);\n         double[] val = new double[5];\n         vs.fill(val);\n         for (int i = 0; i < 5; i++) {\n-            assertEquals(\"fill test in place\",2,val[i],Double.MIN_VALUE);\n+            Assert.assertEquals(\"fill test in place\",2,val[i],Double.MIN_VALUE);\n         }\n         double v2[] = vs.fill(3);\n         for (int i = 0; i < 3; i++) {\n-            assertEquals(\"fill test in place\",2,v2[i],Double.MIN_VALUE);\n+            Assert.assertEquals(\"fill test in place\",2,v2[i],Double.MIN_VALUE);\n         }\n     }\n \n     /**\n      * Test getters to make Clover happy\n      */\n+    @Test\n     public void testProperties() throws Exception {\n         vs.setMode(ValueServer.CONSTANT_MODE);\n-        assertEquals(\"mode test\",ValueServer.CONSTANT_MODE,vs.getMode());\n+        Assert.assertEquals(\"mode test\",ValueServer.CONSTANT_MODE,vs.getMode());\n         vs.setValuesFileURL(\"http://www.apache.org\");\n         URL url = vs.getValuesFileURL();\n-        assertEquals(\"valuesFileURL test\",\"http://www.apache.org\",url.toString());\n+        Assert.assertEquals(\"valuesFileURL test\",\"http://www.apache.org\",url.toString());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/CertifiedDataTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/CertifiedDataTest.java\n import java.io.BufferedReader;\n import java.io.InputStreamReader;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Certified data test cases.\n  * @version $Revision$ $Date$\n  */\n-public class CertifiedDataTest extends TestCase  {\n+public class CertifiedDataTest {\n \n     protected double mean = Double.NaN;\n \n     protected double std = Double.NaN;\n \n     /**\n-     * Certified Data Test Constructor\n-     * @param name\n-     */\n-    public CertifiedDataTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n      * Test SummaryStatistics - implementations that do not store the data\n      * and use single pass algorithms to compute statistics\n     */\n+    @Test\n     public void testSummaryStatistics() throws Exception {\n         SummaryStatistics u = new SummaryStatistics();\n         loadStats(\"data/PiDigits.txt\", u);\n-        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-13);\n-        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-13);\n+        Assert.assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-13);\n+        Assert.assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-13);\n \n         loadStats(\"data/Mavro.txt\", u);\n-        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/Michelso.txt\", u);\n-        assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-13);\n-        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-13);\n+        Assert.assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-13);\n+        Assert.assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-13);\n \n         loadStats(\"data/NumAcc1.txt\", u);\n-        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/NumAcc2.txt\", u);\n-        assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n     }\n \n     /**\n      * Test DescriptiveStatistics - implementations that store full array of\n      * values and execute multi-pass algorithms\n      */\n+    @Test\n     public void testDescriptiveStatistics() throws Exception {\n \n         DescriptiveStatistics u = new DescriptiveStatistics();\n \n         loadStats(\"data/PiDigits.txt\", u);\n-        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/Mavro.txt\", u);\n-        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/Michelso.txt\", u);\n-        assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/NumAcc1.txt\", u);\n-        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/NumAcc2.txt\", u);\n-        assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n+        Assert.assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n+        Assert.assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/FrequencyTest.java\n import java.io.StringReader;\n import java.util.Iterator;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link Frequency} class.\n  * @version $Revision$ $Date$\n  */\n \n-public final class FrequencyTest extends TestCase {\n+public final class FrequencyTest {\n     private long oneL = 1;\n     private long twoL = 2;\n     private long threeL = 3;\n     private double tolerance = 10E-15;\n     private Frequency f = null;\n \n-    public FrequencyTest(String name) {\n-        super(name);\n-    }\n-\n-    @Override\n+    @Before\n     public void setUp() {\n         f = new Frequency();\n     }\n \n     /** test freq counts */\n+    @Test\n     public void testCounts() {\n-        assertEquals(\"total count\",0,f.getSumFreq());\n+        Assert.assertEquals(\"total count\",0,f.getSumFreq());\n         f.addValue(oneL);\n         f.addValue(twoL);\n         f.addValue(1);\n         f.addValue(oneI);\n-        assertEquals(\"one frequency count\",3,f.getCount(1));\n-        assertEquals(\"two frequency count\",1,f.getCount(2));\n-        assertEquals(\"three frequency count\",0,f.getCount(3));\n-        assertEquals(\"total count\",4,f.getSumFreq());\n-        assertEquals(\"zero cumulative frequency\", 0, f.getCumFreq(0));\n-        assertEquals(\"one cumulative frequency\", 3,  f.getCumFreq(1));\n-        assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(2));\n-        assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(Integer.valueOf(2)));\n-        assertEquals(\"five cumulative frequency\", 4,  f.getCumFreq(5));\n-        assertEquals(\"foo cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n+        Assert.assertEquals(\"one frequency count\",3,f.getCount(1));\n+        Assert.assertEquals(\"two frequency count\",1,f.getCount(2));\n+        Assert.assertEquals(\"three frequency count\",0,f.getCount(3));\n+        Assert.assertEquals(\"total count\",4,f.getSumFreq());\n+        Assert.assertEquals(\"zero cumulative frequency\", 0, f.getCumFreq(0));\n+        Assert.assertEquals(\"one cumulative frequency\", 3,  f.getCumFreq(1));\n+        Assert.assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(2));\n+        Assert.assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(Integer.valueOf(2)));\n+        Assert.assertEquals(\"five cumulative frequency\", 4,  f.getCumFreq(5));\n+        Assert.assertEquals(\"foo cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n \n         f.clear();\n-        assertEquals(\"total count\",0,f.getSumFreq());\n+        Assert.assertEquals(\"total count\",0,f.getSumFreq());\n \n         // userguide examples -------------------------------------------------------------------\n         f.addValue(\"one\");\n         f.addValue(\"One\");\n         f.addValue(\"oNe\");\n         f.addValue(\"Z\");\n-        assertEquals(\"one cumulative frequency\", 1 ,  f.getCount(\"one\"));\n-        assertEquals(\"Z cumulative pct\", 0.5,  f.getCumPct(\"Z\"), tolerance);\n-        assertEquals(\"z cumulative pct\", 1.0,  f.getCumPct(\"z\"), tolerance);\n-        assertEquals(\"Ot cumulative pct\", 0.25,  f.getCumPct(\"Ot\"), tolerance);\n+        Assert.assertEquals(\"one cumulative frequency\", 1 ,  f.getCount(\"one\"));\n+        Assert.assertEquals(\"Z cumulative pct\", 0.5,  f.getCumPct(\"Z\"), tolerance);\n+        Assert.assertEquals(\"z cumulative pct\", 1.0,  f.getCumPct(\"z\"), tolerance);\n+        Assert.assertEquals(\"Ot cumulative pct\", 0.25,  f.getCumPct(\"Ot\"), tolerance);\n         f.clear();\n \n         f = null;\n         f.addValue(Long.valueOf(1));\n         f.addValue(2);\n         f.addValue(Integer.valueOf(-1));\n-        assertEquals(\"1 count\", 3, f.getCount(1));\n-        assertEquals(\"1 count\", 3, f.getCount(Integer.valueOf(1)));\n-        assertEquals(\"0 cum pct\", 0.2, f.getCumPct(0), tolerance);\n-        assertEquals(\"1 pct\", 0.6, f.getPct(Integer.valueOf(1)), tolerance);\n-        assertEquals(\"-2 cum pct\", 0, f.getCumPct(-2), tolerance);\n-        assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);\n+        Assert.assertEquals(\"1 count\", 3, f.getCount(1));\n+        Assert.assertEquals(\"1 count\", 3, f.getCount(Integer.valueOf(1)));\n+        Assert.assertEquals(\"0 cum pct\", 0.2, f.getCumPct(0), tolerance);\n+        Assert.assertEquals(\"1 pct\", 0.6, f.getPct(Integer.valueOf(1)), tolerance);\n+        Assert.assertEquals(\"-2 cum pct\", 0, f.getCumPct(-2), tolerance);\n+        Assert.assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);\n \n         f = null;\n         f = new Frequency(String.CASE_INSENSITIVE_ORDER);\n         f.addValue(\"One\");\n         f.addValue(\"oNe\");\n         f.addValue(\"Z\");\n-        assertEquals(\"one count\", 3 ,  f.getCount(\"one\"));\n-        assertEquals(\"Z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"Z\"), tolerance);\n-        assertEquals(\"z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"z\"), tolerance);\n+        Assert.assertEquals(\"one count\", 3 ,  f.getCount(\"one\"));\n+        Assert.assertEquals(\"Z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"Z\"), tolerance);\n+        Assert.assertEquals(\"z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"z\"), tolerance);\n \n         f = null;\n         f = new Frequency();\n-        assertEquals(0L, f.getCount('a'));\n-        assertEquals(0L, f.getCumFreq('b'));\n+        Assert.assertEquals(0L, f.getCount('a'));\n+        Assert.assertEquals(0L, f.getCumFreq('b'));\n         TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);\n         TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);\n         f.addValue('a');\n         f.addValue('b');\n         f.addValue('c');\n         f.addValue('d');\n-        assertEquals(1L, f.getCount('a'));\n-        assertEquals(2L, f.getCumFreq('b'));\n-        assertEquals(0.25, f.getPct('a'), 0.0);\n-        assertEquals(0.5, f.getCumPct('b'), 0.0);\n-        assertEquals(1.0, f.getCumPct('e'), 0.0);\n+        Assert.assertEquals(1L, f.getCount('a'));\n+        Assert.assertEquals(2L, f.getCumFreq('b'));\n+        Assert.assertEquals(0.25, f.getPct('a'), 0.0);\n+        Assert.assertEquals(0.5, f.getCumPct('b'), 0.0);\n+        Assert.assertEquals(1.0, f.getCumPct('e'), 0.0);\n     }\n \n     /** test pcts */\n+    @Test\n     public void testPcts() {\n         f.addValue(oneL);\n         f.addValue(twoL);\n         f.addValue(threeL);\n         f.addValue(3);\n         f.addValue(threeI);\n-        assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n-        assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n-        assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n-        assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n-        assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n-        assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n-        assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n-        assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n-        assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n-        assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n-        assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n-        assertEquals(\"foo cum pct\",0,f.getCumPct(\"foo\"),tolerance);\n+        Assert.assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n+        Assert.assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n+        Assert.assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n+        Assert.assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n+        Assert.assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n+        Assert.assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n+        Assert.assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n+        Assert.assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n+        Assert.assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n+        Assert.assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n+        Assert.assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n+        Assert.assertEquals(\"foo cum pct\",0,f.getCumPct(\"foo\"),tolerance);\n     }\n \n     /** test adding incomparable values */\n+    @Test\n     public void testAdd() {\n         char aChar = 'a';\n         char bChar = 'b';\n         f.addValue(bChar);\n         try {\n             f.addValue(aString);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             f.addValue(2);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        assertEquals(\"a pct\",0.5,f.getPct(aChar),tolerance);\n-        assertEquals(\"b cum pct\",1.0,f.getCumPct(bChar),tolerance);\n-        assertEquals(\"a string pct\",0.0,f.getPct(aString),tolerance);\n-        assertEquals(\"a string cum pct\",0.0,f.getCumPct(aString),tolerance);\n+        Assert.assertEquals(\"a pct\",0.5,f.getPct(aChar),tolerance);\n+        Assert.assertEquals(\"b cum pct\",1.0,f.getCumPct(bChar),tolerance);\n+        Assert.assertEquals(\"a string pct\",0.0,f.getPct(aString),tolerance);\n+        Assert.assertEquals(\"a string cum pct\",0.0,f.getCumPct(aString),tolerance);\n \n         f = new Frequency();\n         f.addValue(\"One\");\n         try {\n             f.addValue(new Integer(\"One\"));\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n     /** test empty table */\n+    @Test\n     public void testEmptyTable() {\n-        assertEquals(\"freq sum, empty table\", 0, f.getSumFreq());\n-        assertEquals(\"count, empty table\", 0, f.getCount(0));\n-        assertEquals(\"count, empty table\",0, f.getCount(Integer.valueOf(0)));\n-        assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(0));\n-        assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(\"x\"));\n-        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(0)));\n-        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(Integer.valueOf(0))));\n-        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(0)));\n-        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));\n+        Assert.assertEquals(\"freq sum, empty table\", 0, f.getSumFreq());\n+        Assert.assertEquals(\"count, empty table\", 0, f.getCount(0));\n+        Assert.assertEquals(\"count, empty table\",0, f.getCount(Integer.valueOf(0)));\n+        Assert.assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(0));\n+        Assert.assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(\"x\"));\n+        Assert.assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(0)));\n+        Assert.assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(Integer.valueOf(0))));\n+        Assert.assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(0)));\n+        Assert.assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));\n     }\n \n     /**\n      * Tests toString()\n      */\n+    @Test\n     public void testToString() throws Exception {\n         f.addValue(oneL);\n         f.addValue(twoL);\n \n         String s = f.toString();\n         //System.out.println(s);\n-        assertNotNull(s);\n+        Assert.assertNotNull(s);\n         BufferedReader reader = new BufferedReader(new StringReader(s));\n         String line = reader.readLine(); // header line\n-        assertNotNull(line);\n+        Assert.assertNotNull(line);\n \n         line = reader.readLine(); // one's or two's line\n-        assertNotNull(line);\n+        Assert.assertNotNull(line);\n \n         line = reader.readLine(); // one's or two's line\n-        assertNotNull(line);\n+        Assert.assertNotNull(line);\n \n         line = reader.readLine(); // no more elements\n-        assertNull(line);\n-    }\n-\n+        Assert.assertNull(line);\n+    }\n+\n+    @Test\n     public void testIntegerValues() {\n         Comparable<?> obj1 = null;\n         obj1 = Integer.valueOf(1);\n         f.addValue(int1);\n         f.addValue(2);\n         f.addValue(Long.valueOf(2));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(1));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(Integer.valueOf(1)));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(Long.valueOf(1)));\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(1), tolerance);\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);\n+        Assert.assertEquals(\"Integer 1 count\", 2, f.getCount(1));\n+        Assert.assertEquals(\"Integer 1 count\", 2, f.getCount(Integer.valueOf(1)));\n+        Assert.assertEquals(\"Integer 1 count\", 2, f.getCount(Long.valueOf(1)));\n+        Assert.assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(1), tolerance);\n+        Assert.assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);\n+        Assert.assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);\n         Iterator<?> it = f.valuesIterator();\n         while (it.hasNext()) {\n-            assertTrue(it.next() instanceof Long);\n-        }\n-    }\n-\n+            Assert.assertTrue(it.next() instanceof Long);\n+        }\n+    }\n+\n+    @Test\n     public void testSerial() {\n         f.addValue(oneL);\n         f.addValue(twoL);\n         f.addValue(oneI);\n         f.addValue(twoI);\n-        assertEquals(f, TestUtils.serializeAndRecover(f));\n+        Assert.assertEquals(f, TestUtils.serializeAndRecover(f));\n     }\n     \n+    @Test\n     public void testGetUniqueCount() {\n-        assertEquals(0, f.getUniqueCount());\n-        f.addValue(oneL);\n-        assertEquals(1, f.getUniqueCount());\n-        f.addValue(oneL);\n-        assertEquals(1, f.getUniqueCount());\n-        f.addValue(twoI);\n-        assertEquals(2, f.getUniqueCount());\n+        Assert.assertEquals(0, f.getUniqueCount());\n+        f.addValue(oneL);\n+        Assert.assertEquals(1, f.getUniqueCount());\n+        f.addValue(oneL);\n+        Assert.assertEquals(1, f.getUniqueCount());\n+        f.addValue(twoI);\n+        Assert.assertEquals(2, f.getUniqueCount());\n     }\n }\n \n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n  */\n package org.apache.commons.math.stat;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link StatUtils} class.\n  * @version $Revision$ $Date$\n  */\n \n-public final class StatUtilsTest extends TestCase {\n+public final class StatUtilsTest {\n \n     private double one = 1;\n     private float two = 2;\n     private double tolerance = 10E-15;\n     private double nan = Double.NaN;\n \n-    public StatUtilsTest(String name) {\n-        super(name);\n-    }\n-\n     /** test stats */\n+    @Test\n     public void testStats() {\n         double[] values = new double[] { one, two, two, three };\n-        assertEquals(\"sum\", sum, StatUtils.sum(values), tolerance);\n-        assertEquals(\"sumsq\", sumSq, StatUtils.sumSq(values), tolerance);\n-        assertEquals(\"var\", var, StatUtils.variance(values), tolerance);\n-        assertEquals(\"var with mean\", var, StatUtils.variance(values, mean), tolerance);\n-        assertEquals(\"mean\", mean, StatUtils.mean(values), tolerance);\n-        assertEquals(\"min\", min, StatUtils.min(values), tolerance);\n-        assertEquals(\"max\", max, StatUtils.max(values), tolerance);\n-    }\n-\n+        Assert.assertEquals(\"sum\", sum, StatUtils.sum(values), tolerance);\n+        Assert.assertEquals(\"sumsq\", sumSq, StatUtils.sumSq(values), tolerance);\n+        Assert.assertEquals(\"var\", var, StatUtils.variance(values), tolerance);\n+        Assert.assertEquals(\"var with mean\", var, StatUtils.variance(values, mean), tolerance);\n+        Assert.assertEquals(\"mean\", mean, StatUtils.mean(values), tolerance);\n+        Assert.assertEquals(\"min\", min, StatUtils.min(values), tolerance);\n+        Assert.assertEquals(\"max\", max, StatUtils.max(values), tolerance);\n+    }\n+\n+    @Test\n     public void testN0andN1Conditions() throws Exception {\n         double[] values = new double[0];\n \n-        assertTrue(\n+        Assert.assertTrue(\n             \"Mean of n = 0 set should be NaN\",\n             Double.isNaN(StatUtils.mean(values)));\n-        assertTrue(\n+        Assert.assertTrue(\n             \"Variance of n = 0 set should be NaN\",\n             Double.isNaN(StatUtils.variance(values)));\n \n         values = new double[] { one };\n \n-        assertTrue(\n+        Assert.assertTrue(\n             \"Mean of n = 1 set should be value of single item n1\",\n             StatUtils.mean(values) == one);\n-        assertTrue(\n+        Assert.assertTrue(\n             \"Variance of n = 1 set should be zero\",\n             StatUtils.variance(values) == 0);\n     }\n \n+    @Test\n     public void testArrayIndexConditions() throws Exception {\n         double[] values = { 1.0, 2.0, 3.0, 4.0 };\n \n-        assertEquals(\n+        Assert.assertEquals(\n             \"Sum not expected\",\n             5.0,\n             StatUtils.sum(values, 1, 2),\n             Double.MIN_VALUE);\n-        assertEquals(\n+        Assert.assertEquals(\n             \"Sum not expected\",\n             3.0,\n             StatUtils.sum(values, 0, 2),\n             Double.MIN_VALUE);\n-        assertEquals(\n+        Assert.assertEquals(\n             \"Sum not expected\",\n             7.0,\n             StatUtils.sum(values, 2, 2),\n \n         try {\n             StatUtils.sum(values, 2, 3);\n-            fail(\"Expected RuntimeException\");\n+            Assert.fail(\"Expected RuntimeException\");\n         } catch (RuntimeException e) {\n             // expected\n         }\n \n         try {\n             StatUtils.sum(values, -1, 2);\n-            fail(\"Expected RuntimeException\");\n+            Assert.fail(\"Expected RuntimeException\");\n         } catch (RuntimeException e) {\n             // expected\n         }\n \n     }\n \n+    @Test\n     public void testSumSq() {\n         double[] x = null;\n \n         // test null\n         try {\n             StatUtils.sumSq(x);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.sumSq(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);\n     }\n \n+    @Test\n     public void testProduct() {\n         double[] x = null;\n \n         // test null\n         try {\n             StatUtils.product(x);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.product(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);\n     }\n \n+    @Test\n     public void testSumLog() {\n         double[] x = null;\n \n         // test null\n         try {\n             StatUtils.sumLog(x);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.sumLog(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(2.0 * FastMath.log(two), StatUtils.sumLog(x, 1, 2), tolerance);\n     }\n \n+    @Test\n     public void testMean() {\n         double[] x = null;\n \n         try {\n             StatUtils.mean(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);\n     }\n \n+    @Test\n     public void testVariance() {\n         double[] x = null;\n \n         try {\n             StatUtils.variance(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);\n     }\n \n+    @Test\n     public void testMax() {\n         double[] x = null;\n \n         try {\n             StatUtils.max(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);\n     }\n \n+    @Test\n     public void testMin() {\n         double[] x = null;\n \n         try {\n             StatUtils.min(x, 0, 4);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);\n     }\n \n+    @Test\n     public void testPercentile() {\n         double[] x = null;\n \n         // test null\n         try {\n             StatUtils.percentile(x, .25);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.percentile(x, 0, 4, 0.25);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);\n     }\n \n+    @Test\n     public void testDifferenceStats() throws Exception {\n         double sample1[] = {1d, 2d, 3d, 4d};\n         double sample2[] = {1d, 3d, 4d, 2d};\n         double diff[] = {0d, -1d, -1d, 2d};\n         double small[] = {1d, 4d};\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n-        assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);\n-        assertEquals(meanDifference, StatUtils.mean(diff), tolerance);\n-        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),\n+        Assert.assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);\n+        Assert.assertEquals(meanDifference, StatUtils.mean(diff), tolerance);\n+        Assert.assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),\n                 StatUtils.variance(diff), tolerance);\n         try {\n             StatUtils.meanDifference(sample1, small);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             StatUtils.varianceDifference(sample1, small, meanDifference);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             double[] single = {1.0};\n             StatUtils.varianceDifference(single, single, meanDifference);\n-            fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testGeometricMean() throws Exception {\n         double[] test = null;\n         try {\n             StatUtils.geometricMean(test);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         test = new double[] {2, 4, 6, 8};\n-        assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),\n+        Assert.assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),\n                 StatUtils.geometricMean(test), Double.MIN_VALUE);\n-        assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),\n+        Assert.assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),\n                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);\n     }\n     \n      * Run the test with the values 50 and 100 and assume standardized values    \n      */\n \n+    @Test\n     public void testNormalize1() {\n         double sample[] = { 50, 100 };\n         double expectedSample[] = { -25 / Math.sqrt(1250), 25 / Math.sqrt(1250) };\n         double[] out = StatUtils.normalize(sample);\n         for (int i = 0; i < out.length; i++) {\n-            assertEquals(out[i], expectedSample[i]);\n+            Assert.assertTrue(MathUtils.equals(out[i], expectedSample[i], 1));\n         }\n \n     }\n      * precision of 1E-10.\n      */\n \n+    @Test\n     public void testNormalize2() {\n         // create an sample with 77 values    \n         int length = 77;\n         // the calculations do have a limited precision    \n         double distance = 1E-10;\n         // check the mean an standard deviation\n-        assertEquals(0.0, stats.getMean(), distance);\n-        assertEquals(1.0, stats.getStandardDeviation(), distance);\n+        Assert.assertEquals(0.0, stats.getMean(), distance);\n+        Assert.assertEquals(1.0, stats.getStandardDeviation(), distance);\n \n     }\n     \n--- a/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n \n package org.apache.commons.math.stat.clustering;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class EuclideanIntegerPointTest {\n     @Test\n     public void testArrayIsReference() {\n         int[] array = { -3, -2, -1, 0, 1 };\n-        assertTrue(array == new EuclideanIntegerPoint(array).getPoint());\n+        Assert.assertTrue(array == new EuclideanIntegerPoint(array).getPoint());\n     }\n \n     @Test\n     public void testDistance() {\n         EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n         EuclideanIntegerPoint e2 = new EuclideanIntegerPoint(new int[] {  1,  0, -1, 1, 1 });\n-        assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);\n-        assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);\n-        assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);\n+        Assert.assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);\n+        Assert.assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);\n+        Assert.assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);\n     }\n \n     @Test\n         list.add(new EuclideanIntegerPoint(new int[] {  3,  3 }));\n         list.add(new EuclideanIntegerPoint(new int[] {  2,  4 }));\n         EuclideanIntegerPoint c = list.get(0).centroidOf(list);\n-        assertEquals(2, c.getPoint()[0]);\n-        assertEquals(3, c.getPoint()[1]);\n+        Assert.assertEquals(2, c.getPoint()[0]);\n+        Assert.assertEquals(3, c.getPoint()[1]);\n     }\n \n     @Test\n     public void testSerial() {\n         EuclideanIntegerPoint p = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n-        assertEquals(p, TestUtils.serializeAndRecover(p));\n+        Assert.assertEquals(p, TestUtils.serializeAndRecover(p));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n \n package org.apache.commons.math.stat.clustering;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n         List<Cluster<EuclideanIntegerPoint>> clusters =\n             transformer.cluster(Arrays.asList(points), 3, 10);\n \n-        assertEquals(3, clusters.size());\n+        Assert.assertEquals(3, clusters.size());\n         boolean cluster1Found = false;\n         boolean cluster2Found = false;\n         boolean cluster3Found = false;\n             int[] center = cluster.getCenter().getPoint();\n             if (center[0] < 0) {\n                 cluster1Found = true;\n-                assertEquals(8, cluster.getPoints().size());\n-                assertEquals(-14, center[0]);\n-                assertEquals( 4, center[1]);\n+                Assert.assertEquals(8, cluster.getPoints().size());\n+                Assert.assertEquals(-14, center[0]);\n+                Assert.assertEquals( 4, center[1]);\n             } else if (center[1] < 0) {\n                 cluster2Found = true;\n-                assertEquals(5, cluster.getPoints().size());\n-                assertEquals( 0, center[0]);\n-                assertEquals(-1, center[1]);\n+                Assert.assertEquals(5, cluster.getPoints().size());\n+                Assert.assertEquals( 0, center[0]);\n+                Assert.assertEquals(-1, center[1]);\n             } else {\n                 cluster3Found = true;\n-                assertEquals(8, cluster.getPoints().size());\n-                assertEquals(15, center[0]);\n-                assertEquals(5, center[1]);\n-            }\n-        }\n-        assertTrue(cluster1Found);\n-        assertTrue(cluster2Found);\n-        assertTrue(cluster3Found);\n+                Assert.assertEquals(8, cluster.getPoints().size());\n+                Assert.assertEquals(15, center[0]);\n+                Assert.assertEquals(5, center[1]);\n+            }\n+        }\n+        Assert.assertTrue(cluster1Found);\n+        Assert.assertTrue(cluster2Found);\n+        Assert.assertTrue(cluster3Found);\n \n     }\n \n                 new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                 new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n         List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n-        assertEquals(1, clusters.size());\n-        assertEquals(2, (clusters.get(0).getPoints().size()));\n+        Assert.assertEquals(1, clusters.size());\n+        Assert.assertEquals(2, (clusters.get(0).getPoints().size()));\n         EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n         EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n-        assertTrue(clusters.get(0).getPoints().contains(pt1));\n-        assertTrue(clusters.get(0).getPoints().contains(pt2));\n+        Assert.assertTrue(clusters.get(0).getPoints().contains(pt1));\n+        Assert.assertTrue(clusters.get(0).getPoints().contains(pt2));\n \n     }\n \n                 uniquePointIsCenter = true;\n             }\n         }\n-        assertTrue(uniquePointIsCenter);\n+        Assert.assertTrue(uniquePointIsCenter);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/correlation/CovarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/CovarianceTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.Variance;\n-\n-import junit.framework.TestCase;\n-\n-public class CovarianceTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class CovarianceTest {\n \n     protected final double[] longleyData = new double[] {\n             60323,83.0,234289,2356,1590,107608,1947,\n      * Data are from NIST:\n      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat\n      */\n+    @Test\n     public void testLongly() {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n      * Test R Swiss fertility dataset against R.\n      * Data Source: R datasets package\n      */\n+    @Test\n     public void testSwissFertility() {\n          RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n          RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n     /**\n      * Constant column\n      */\n+    @Test\n     public void testConstant() {\n         double[] noVariance = new double[] {1, 1, 1, 1};\n         double[] values = new double[] {1, 2, 3, 4};\n-        assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);\n-        assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);\n+        Assert.assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);\n+        Assert.assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);\n     }\n \n \n     /**\n      * Insufficient data\n      */\n+    @Test\n     public void testInsufficientData() {\n         double[] one = new double[] {1};\n         double[] two = new double[] {2};\n         try {\n             new Covariance().covariance(one, two, false);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n         RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {{0},{1}});\n         try {\n             new Covariance(matrix);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n      * Verify that diagonal entries are consistent with Variance computation and matrix matches\n      * column-by-column covariances\n      */\n+    @Test\n     public void testConsistency() {\n         final RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n         final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n         // Variances on the diagonal\n         Variance variance = new Variance();\n         for (int i = 0; i < 5; i++) {\n-            assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);\n+            Assert.assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);\n         }\n \n         // Symmetry, column-consistency\n-        assertEquals(covarianceMatrix.getEntry(2, 3),\n+        Assert.assertEquals(covarianceMatrix.getEntry(2, 3),\n                 new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);\n-        assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);\n+        Assert.assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);\n \n         // All columns same -> all entries = column variance\n         RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);\n         double columnVariance = variance.evaluate(matrix.getColumn(0));\n         for (int i = 0; i < 3; i++) {\n             for (int j = 0; j < 3; j++) {\n-                assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);\n+                Assert.assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);\n             }\n         }\n \n \n         double[] x = data[0];\n         double[] y = data[1];\n-        assertEquals(new Covariance().covariance(x, y),\n+        Assert.assertEquals(new Covariance().covariance(x, y),\n                 new Covariance().covariance(x, y, true), Double.MIN_VALUE);\n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n-\n-public class PearsonsCorrelationTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class PearsonsCorrelationTest {\n \n     protected final double[] longleyData = new double[] {\n             60323,83.0,234289,2356,1590,107608,1947,\n     /**\n      * Test Longley dataset against R.\n      */\n+    @Test\n     public void testLongly() throws Exception {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n     /**\n      * Test R Swiss fertility dataset against R.\n      */\n+    @Test\n     public void testSwissFertility() throws Exception {\n          RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n          PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n     /**\n      * Test p-value near 0. JIRA: MATH-371\n      */\n+    @Test\n     public void testPValueNearZero() throws Exception {\n         /*\n          * Create a dataset that has r -> 1, p -> 0 as dimension increases.\n             data[i][1] = i + 1/((double)i + 1);\n         }\n         PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);\n-        assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);\n+        Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);\n     }\n     \n \n     /**\n      * Constant column\n      */\n+    @Test\n     public void testConstant() {\n         double[] noVariance = new double[] {1, 1, 1, 1};\n         double[] values = new double[] {1, 2, 3, 4};\n-        assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));\n+        Assert.assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));\n     }\n \n \n      * Insufficient data\n      */\n \n+    @Test\n     public void testInsufficientData() {\n         double[] one = new double[] {1};\n         double[] two = new double[] {2};\n         try {\n             new PearsonsCorrelation().correlation(one, two);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n         RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});\n         try {\n             new PearsonsCorrelation(matrix);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n      * Verify that direct t-tests using standard error estimates are consistent\n      * with reported p-values\n      */\n+    @Test\n     public void testStdErrorConsistency() throws Exception {\n         TDistribution tDistribution = new TDistributionImpl(45);\n         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n             for (int j = 0; j < i; j++) {\n                 double t = FastMath.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);\n                 double p = 2 * (1 - tDistribution.cumulativeProbability(t));\n-                assertEquals(p, pValues.getEntry(i, j), 10E-15);\n+                Assert.assertEquals(p, pValues.getEntry(i, j), 10E-15);\n             }\n         }\n     }\n      * Verify that creating correlation from covariance gives same results as\n      * direct computation from the original matrix\n      */\n+    @Test\n     public void testCovarianceConsistency() throws Exception {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n     }\n \n \n+    @Test\n     public void testConsistency() {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n         double[][] data = matrix.getData();\n         double[] x = matrix.getColumn(0);\n         double[] y = matrix.getColumn(1);\n-        assertEquals(new PearsonsCorrelation().correlation(x, y),\n+        Assert.assertEquals(new PearsonsCorrelation().correlation(x, y),\n                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n         TestUtils.assertEquals(\"Correlation matrix\", corrInstance.getCorrelationMatrix(),\n                 new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n--- a/src/test/java/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for Spearman's rank correlation\n  */\n public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest {\n \n-    @Override\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-    }\n-\n-    @Override\n-    protected void tearDown() throws Exception {\n-        super.tearDown();\n-    }\n-\n     /**\n      * Test Longley dataset against R.\n      */\n     @Override\n+    @Test\n     public void testLongly() throws Exception {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);\n     /**\n      * Test R swiss fertility dataset.\n      */\n+    @Test\n     public void testSwiss() throws Exception {\n         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n         SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);\n      * Constant column\n      */\n     @Override\n+    @Test\n     public void testConstant() {\n         double[] noVariance = new double[] {1, 1, 1, 1};\n         double[] values = new double[] {1, 2, 3, 4};\n-        assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));\n+        Assert.assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));\n     }\n \n     /**\n      * Insufficient data\n      */\n     @Override\n+    @Test\n     public void testInsufficientData() {\n         double[] one = new double[] {1};\n         double[] two = new double[] {2};\n         try {\n             new SpearmansCorrelation().correlation(one, two);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n         RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});\n         try {\n             new SpearmansCorrelation(matrix);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n     }\n \n     @Override\n+    @Test\n     public void testConsistency() {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);\n         double[][] data = matrix.getData();\n         double[] x = matrix.getColumn(0);\n         double[] y = matrix.getColumn(1);\n-        assertEquals(new SpearmansCorrelation().correlation(x, y),\n+        Assert.assertEquals(new SpearmansCorrelation().correlation(x, y),\n                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n         TestUtils.assertEquals(\"Correlation matrix\", corrInstance.getCorrelationMatrix(),\n                 new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n \n     // Not relevant here\n     @Override\n+    @Test\n     public void testStdErrorConsistency() throws Exception {}\n     @Override\n+    @Test\n     public void testCovarianceConsistency() throws Exception {}\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n import java.util.HashMap;\n import java.util.Map;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public abstract class CertifiedDataAbstractTest extends TestCase {\n+public abstract class CertifiedDataAbstractTest {\n \n     private DescriptiveStatistics descriptives;\n \n \n     private Map<String, Double> certifiedValues;\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    @Before\n+    public void setUp() throws IOException {\n         descriptives = new DescriptiveStatistics();\n         summaries = new SummaryStatistics();\n         certifiedValues = new HashMap<String, Double>();\n         return 1.0e-5;\n     }\n \n-    @Override\n-    protected void tearDown() throws Exception {\n+    @After\n+    public void tearDown() throws Exception {\n         descriptives.clear();\n         descriptives = null;\n \n         certifiedValues = null;\n     }\n \n+    @Test\n     public void testCertifiedValues() {\n         for (String name : certifiedValues.keySet()) {\n             Double expectedValue = certifiedValues.get(name);\n             } else if (meth.getReturnType().equals(Long.TYPE)) {\n                 return Double.valueOf(((Long) property).doubleValue());\n             } else {\n-                fail(\"wrong type: \" + meth.getReturnType().getName());\n+                Assert.fail(\"wrong type: \" + meth.getReturnType().getName());\n             }\n         } catch (NoSuchMethodException nsme) {\n             // ignored\n         } catch (InvocationTargetException ite) {\n-            fail(ite.getMessage());\n+            Assert.fail(ite.getMessage());\n         } catch (IllegalAccessException iae) {\n-            fail(iae.getMessage());\n+            Assert.fail(iae.getMessage());\n         }\n         return null;\n     }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n  */\n package org.apache.commons.math.stat.descriptive;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Tests for AbstractUnivariateStatistic\n  *\n  * @version $Revision$ $Date$\n  */\n-public class AbstractUnivariateStatisticTest extends TestCase {\n-\n-    public AbstractUnivariateStatisticTest(String name) {\n-        super(name);\n-    }\n+public class AbstractUnivariateStatisticTest {\n \n     protected double[] testArray = {0, 1, 2, 3, 4, 5};\n     protected double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};\n     protected double[] singletonArray = {0};\n     protected Mean testStatistic = new Mean();\n \n+    @Test\n     public void testTestPositive() {\n         for (int j = 0; j < 6; j++) {\n             for (int i = 1; i < (7 - j); i++) {\n-                assertTrue(testStatistic.test(testArray, 0, i));\n+                Assert.assertTrue(testStatistic.test(testArray, 0, i));\n             }\n         }\n-        assertTrue(testStatistic.test(singletonArray, 0, 1));\n-        assertTrue(testStatistic.test(singletonArray, 0, 0, true));\n+        Assert.assertTrue(testStatistic.test(singletonArray, 0, 1));\n+        Assert.assertTrue(testStatistic.test(singletonArray, 0, 0, true));\n     }\n \n+    @Test\n     public void testTestNegative() {\n-        assertFalse(testStatistic.test(singletonArray, 0, 0));\n-        assertFalse(testStatistic.test(testArray, 0, 0));\n+        Assert.assertFalse(testStatistic.test(singletonArray, 0, 0));\n+        Assert.assertFalse(testStatistic.test(testArray, 0, 0));\n         try {\n             testStatistic.test(singletonArray, 2, 1);  // start past end\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, 0, 7);  // end past end\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, -1, 1);  // start negative\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, 0, -1);  // length negative\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(nullArray, 0, 1);  // null array\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, nullArray, 0, 1);  // null weights array\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n import java.util.ArrayList;\n import java.util.Collection;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.random.RandomData;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n \n /**\n  * Test cases for {@link AggregateSummaryStatistics}\n  *\n  */\n-public class AggregateSummaryStatisticsTest extends TestCase {\n+public class AggregateSummaryStatisticsTest {\n \n     /**\n      * Tests the standard aggregation behavior\n      */\n+    @Test\n     public void testAggregation() {\n         AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n         SummaryStatistics setOneStats = aggregate.createContributingStatistics();\n         SummaryStatistics setTwoStats = aggregate.createContributingStatistics();\n \n-        assertNotNull(\"The set one contributing stats are null\", setOneStats);\n-        assertNotNull(\"The set two contributing stats are null\", setTwoStats);\n-        assertNotSame(\"Contributing stats objects are the same\", setOneStats, setTwoStats);\n+        Assert.assertNotNull(\"The set one contributing stats are null\", setOneStats);\n+        Assert.assertNotNull(\"The set two contributing stats are null\", setTwoStats);\n+        Assert.assertNotSame(\"Contributing stats objects are the same\", setOneStats, setTwoStats);\n \n         setOneStats.addValue(2);\n         setOneStats.addValue(3);\n         setOneStats.addValue(5);\n         setOneStats.addValue(7);\n         setOneStats.addValue(11);\n-        assertEquals(\"Wrong number of set one values\", 5, setOneStats.getN());\n-        assertEquals(\"Wrong sum of set one values\", 28.0, setOneStats.getSum());\n+        Assert.assertEquals(\"Wrong number of set one values\", 5, setOneStats.getN());\n+        Assert.assertTrue(\"Wrong sum of set one values\", MathUtils.equals(28.0, setOneStats.getSum(), 1));\n \n         setTwoStats.addValue(2);\n         setTwoStats.addValue(4);\n         setTwoStats.addValue(8);\n-        assertEquals(\"Wrong number of set two values\", 3, setTwoStats.getN());\n-        assertEquals(\"Wrong sum of set two values\", 14.0, setTwoStats.getSum());\n-\n-        assertEquals(\"Wrong number of aggregate values\", 8, aggregate.getN());\n-        assertEquals(\"Wrong aggregate sum\", 42.0, aggregate.getSum());\n+        Assert.assertEquals(\"Wrong number of set two values\", 3, setTwoStats.getN());\n+        Assert.assertTrue(\"Wrong sum of set two values\", MathUtils.equals(14.0, setTwoStats.getSum(), 1));\n+\n+        Assert.assertEquals(\"Wrong number of aggregate values\", 8, aggregate.getN());\n+        Assert.assertTrue(\"Wrong aggregate sum\", MathUtils.equals(42.0, aggregate.getSum(), 1));\n     }\n \n     /**\n      *     returned by a single SummaryStatistics instance that is provided\n      *     the full dataset\n      */\n+    @Test\n     public void testAggregationConsistency() throws Exception {\n \n         // Generate a random sample and random partition\n          * as <totalStats>.\n          *\n          */\n-        assertEquals(totalStats.getSummary(), aggregate.getSummary());\n+        Assert.assertEquals(totalStats.getSummary(), aggregate.getSummary());\n \n     }\n \n      *\n      * @throws Exception\n      */\n+    @Test\n     public void testAggregate() throws Exception {\n \n         // Generate a random sample and random partition\n     }\n \n \n+    @Test\n     public void testAggregateDegenerate() throws Exception {\n         double[] totalSample = {1, 2, 3, 4, 5};\n         double[][] subSamples = {{1}, {2}, {3}, {4}, {5}};\n         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n     }\n \n+    @Test\n     public void testAggregateSpecialValues() throws Exception {\n         double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5};\n         double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}};\n     protected static void assertEquals(StatisticalSummary expected, StatisticalSummary observed, double delta) {\n         TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0);\n         TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0);\n-        assertEquals(expected.getN(), observed.getN());\n+        Assert.assertEquals(expected.getN(), observed.getN());\n         TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta);\n         TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta);\n         TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta);\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n \n import java.util.Locale;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.stat.descriptive.rank.Percentile;\n import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the DescriptiveStatistics class.\n  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n-public class DescriptiveStatisticsTest extends TestCase {\n-\n-    public DescriptiveStatisticsTest(String name) {\n-        super(name);\n-    }\n+public class DescriptiveStatisticsTest {\n \n     protected DescriptiveStatistics createDescriptiveStatistics() {\n         return new DescriptiveStatistics();\n     }\n \n+    @Test\n     public void testSetterInjection() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         stats.addValue(3);\n-        assertEquals(2, stats.getMean(), 1E-10);\n+        Assert.assertEquals(2, stats.getMean(), 1E-10);\n         // Now lets try some new math\n         stats.setMeanImpl(new deepMean());\n-        assertEquals(42, stats.getMean(), 1E-10);\n-    }\n-\n+        Assert.assertEquals(42, stats.getMean(), 1E-10);\n+    }\n+\n+    @Test\n     public void testCopy() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         stats.addValue(3);\n         DescriptiveStatistics copy = new DescriptiveStatistics(stats);\n-        assertEquals(2, copy.getMean(), 1E-10);\n+        Assert.assertEquals(2, copy.getMean(), 1E-10);\n         // Now lets try some new math\n         stats.setMeanImpl(new deepMean());\n         copy = stats.copy();\n-        assertEquals(42, copy.getMean(), 1E-10);\n-    }\n-\n+        Assert.assertEquals(42, copy.getMean(), 1E-10);\n+    }\n+\n+    @Test\n     public void testWindowSize() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.setWindowSize(300);\n             stats.addValue(i + 1);\n         }\n         int refSum = (100 * 101) / 2;\n-        assertEquals(refSum / 100.0, stats.getMean(), 1E-10);\n-        assertEquals(300, stats.getWindowSize());\n+        Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10);\n+        Assert.assertEquals(300, stats.getWindowSize());\n         try {\n             stats.setWindowSize(-3);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected\n         }\n-        assertEquals(300, stats.getWindowSize());\n+        Assert.assertEquals(300, stats.getWindowSize());\n         stats.setWindowSize(50);\n-        assertEquals(50, stats.getWindowSize());\n+        Assert.assertEquals(50, stats.getWindowSize());\n         int refSum2 = refSum - (50 * 51) / 2;\n-        assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);\n-    }\n-\n+        Assert.assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);\n+    }\n+\n+    @Test\n     public void testGetValues() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         for (int i = 100; i > 0; --i) {\n             stats.addValue(i);\n         }\n         int refSum = (100 * 101) / 2;\n-        assertEquals(refSum / 100.0, stats.getMean(), 1E-10);\n+        Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10);\n         double[] v = stats.getValues();\n         for (int i = 0; i < v.length; ++i) {\n-            assertEquals(100.0 - i, v[i], 1.0e-10);\n+            Assert.assertEquals(100.0 - i, v[i], 1.0e-10);\n         }\n         double[] s = stats.getSortedValues();\n         for (int i = 0; i < s.length; ++i) {\n-            assertEquals(i + 1.0, s[i], 1.0e-10);\n-        }\n-        assertEquals(12.0, stats.getElement(88), 1.0e-10);\n-    }\n-\n+            Assert.assertEquals(i + 1.0, s[i], 1.0e-10);\n+        }\n+        Assert.assertEquals(12.0, stats.getElement(88), 1.0e-10);\n+    }\n+\n+    @Test\n     public void testToString() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         stats.addValue(3);\n         Locale d = Locale.getDefault();\n         Locale.setDefault(Locale.US);\n-        assertEquals(\"DescriptiveStatistics:\\n\" +\n+        Assert.assertEquals(\"DescriptiveStatistics:\\n\" +\n                      \"n: 3\\n\" +\n                      \"min: 1.0\\n\" +\n                      \"max: 3.0\\n\" +\n         Locale.setDefault(d);\n     }\n \n+    @Test\n     public void testShuffledStatistics() {\n         // the purpose of this test is only to check the get/set methods\n         // we are aware shuffling statistics like this is really not\n             shuffled.addValue(i);\n         }\n \n-        assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);\n-        assertEquals(reference.getKurtosis(),      shuffled.getMean(),          1.0e-10);\n-        assertEquals(reference.getSkewness(),      shuffled.getKurtosis(), 1.0e-10);\n-        assertEquals(reference.getVariance(),      shuffled.getSkewness(), 1.0e-10);\n-        assertEquals(reference.getMax(),           shuffled.getVariance(), 1.0e-10);\n-        assertEquals(reference.getMin(),           shuffled.getMax(), 1.0e-10);\n-        assertEquals(reference.getSum(),           shuffled.getMin(), 1.0e-10);\n-        assertEquals(reference.getSumsq(),         shuffled.getSum(), 1.0e-10);\n-        assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);\n-\n-    }\n-\n+        Assert.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);\n+        Assert.assertEquals(reference.getKurtosis(),      shuffled.getMean(),          1.0e-10);\n+        Assert.assertEquals(reference.getSkewness(),      shuffled.getKurtosis(), 1.0e-10);\n+        Assert.assertEquals(reference.getVariance(),      shuffled.getSkewness(), 1.0e-10);\n+        Assert.assertEquals(reference.getMax(),           shuffled.getVariance(), 1.0e-10);\n+        Assert.assertEquals(reference.getMin(),           shuffled.getMax(), 1.0e-10);\n+        Assert.assertEquals(reference.getSum(),           shuffled.getMin(), 1.0e-10);\n+        Assert.assertEquals(reference.getSumsq(),         shuffled.getSum(), 1.0e-10);\n+        Assert.assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);\n+\n+    }\n+\n+    @Test\n     public void testPercentileSetter() throws Exception {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         stats.addValue(2);\n         stats.addValue(3);\n-        assertEquals(2, stats.getPercentile(50.0), 1E-10);\n+        Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10);\n \n         // Inject wrapped Percentile impl\n         stats.setPercentileImpl(new goodPercentile());\n-        assertEquals(2, stats.getPercentile(50.0), 1E-10);\n+        Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10);\n \n         // Try \"new math\" impl\n         stats.setPercentileImpl(new subPercentile());\n-        assertEquals(10.0, stats.getPercentile(10.0), 1E-10);\n+        Assert.assertEquals(10.0, stats.getPercentile(10.0), 1E-10);\n \n         // Try to set bad impl\n         try {\n             stats.setPercentileImpl(new badPercentile());\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void test20090720() {\n         DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics(100);\n         for (int i = 0; i < 161; i++) {\n         }\n         descriptiveStatistics.clear();\n         descriptiveStatistics.addValue(1.2);\n-        assertEquals(1, descriptiveStatistics.getN());\n-    }\n-\n+        Assert.assertEquals(1, descriptiveStatistics.getN());\n+    }\n+\n+    @Test\n     public void testRemoval() {\n \n         final DescriptiveStatistics dstat = createDescriptiveStatistics();\n             dstat.addValue(i);\n         }\n \n-        assertTrue(MathUtils.equalsIncludingNaN(mean1, dstat.getMean()));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean1, dstat.getMean()));\n         dstat.replaceMostRecentValue(0);\n-        assertTrue(MathUtils.equalsIncludingNaN(mean2, dstat.getMean()));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean2, dstat.getMean()));\n         dstat.removeMostRecentValue();\n-        assertTrue(MathUtils.equalsIncludingNaN(mean3, dstat.getMean()));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean3, dstat.getMean()));\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/InteractionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/InteractionTest.java\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.moment.Skewness;\n import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class InteractionTest extends TestCase {\n+public class InteractionTest {\n \n     protected double mean = 12.40454545454550;\n     protected double var = 10.00235930735930;\n             9,\n             12.3 };\n \n-    public InteractionTest(String name) {\n-        super(name);\n-    }\n-\n-\n+    @Test\n     public void testInteraction() {\n \n         FourthMoment m4 = new FourthMoment();\n             m4.increment(testArray[i]);\n         }\n \n-        assertEquals(mean,m.getResult(),tolerance);\n-        assertEquals(var,v.getResult(),tolerance);\n-        assertEquals(skew ,s.getResult(),tolerance);\n-        assertEquals(kurt,k.getResult(),tolerance);\n+        Assert.assertEquals(mean,m.getResult(),tolerance);\n+        Assert.assertEquals(var,v.getResult(),tolerance);\n+        Assert.assertEquals(skew ,s.getResult(),tolerance);\n+        Assert.assertEquals(kurt,k.getResult(),tolerance);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link ListUnivariateImpl} class.\n  * @version $Revision$ $Date$\n  */\n \n-public final class ListUnivariateImplTest extends TestCase {\n+public final class ListUnivariateImplTest {\n \n     private double one = 1;\n     private float two = 2;\n     private double max = 3;\n     private double tolerance = 10E-15;\n \n-    public ListUnivariateImplTest(String name) {\n-        super(name);\n-    }\n-\n     /** test stats */\n+    @Test\n     public void testStats() {\n         List<Object> externalList = new ArrayList<Object>();\n \n         DescriptiveStatistics u = new ListUnivariateImpl( externalList );\n \n-        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        Assert.assertEquals(\"total count\",0,u.getN(),tolerance);\n         u.addValue(one);\n         u.addValue(two);\n         u.addValue(two);\n         u.addValue(three);\n-        assertEquals(\"N\",n,u.getN(),tolerance);\n-        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n-        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n-        assertEquals(\"var\",var,u.getVariance(),tolerance);\n-        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n-        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n-        assertEquals(\"min\",min,u.getMin(),tolerance);\n-        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        Assert.assertEquals(\"N\",n,u.getN(),tolerance);\n+        Assert.assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        Assert.assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        Assert.assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        Assert.assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        Assert.assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        Assert.assertEquals(\"min\",min,u.getMin(),tolerance);\n+        Assert.assertEquals(\"max\",max,u.getMax(),tolerance);\n         u.clear();\n-        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        Assert.assertEquals(\"total count\",0,u.getN(),tolerance);\n     }\n \n+    @Test\n     public void testN0andN1Conditions() throws Exception {\n         List<Object> list = new ArrayList<Object>();\n \n         DescriptiveStatistics u = new ListUnivariateImpl( list );\n \n-        assertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n-        assertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n-        assertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n+        Assert.assertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n+        Assert.assertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n+        Assert.assertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n \n         list.add( Double.valueOf(one));\n \n-        assertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n-        assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n-        assertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\n+        Assert.assertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n+        Assert.assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n+        Assert.assertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\n     }\n \n+    @Test\n     public void testSkewAndKurtosis() {\n         DescriptiveStatistics u = new DescriptiveStatistics();\n \n             u.addValue( testArray[i]);\n         }\n \n-        assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n-        assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n-        assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n-        assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+        Assert.assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+        Assert.assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+        Assert.assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+        Assert.assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n     }\n \n+    @Test\n     public void testProductAndGeometricMean() throws Exception {\n         ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());\n         u.setWindowSize(10);\n         u.addValue( 3.0 );\n         u.addValue( 4.0 );\n \n-        assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n+        Assert.assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n \n         // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n         // of a discarded element\n         }\n         // Values should be (2,3,4,5,6,7,8,9,10,11)\n \n-        assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n+        Assert.assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n \n \n     }\n \n     /** test stats */\n+    @Test\n     public void testSerialization() {\n \n         DescriptiveStatistics u = new ListUnivariateImpl();\n \n-        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        Assert.assertEquals(\"total count\",0,u.getN(),tolerance);\n         u.addValue(one);\n         u.addValue(two);\n \n         u2.addValue(two);\n         u2.addValue(three);\n \n-        assertEquals(\"N\",n,u2.getN(),tolerance);\n-        assertEquals(\"sum\",sum,u2.getSum(),tolerance);\n-        assertEquals(\"sumsq\",sumSq,u2.getSumsq(),tolerance);\n-        assertEquals(\"var\",var,u2.getVariance(),tolerance);\n-        assertEquals(\"std\",std,u2.getStandardDeviation(),tolerance);\n-        assertEquals(\"mean\",mean,u2.getMean(),tolerance);\n-        assertEquals(\"min\",min,u2.getMin(),tolerance);\n-        assertEquals(\"max\",max,u2.getMax(),tolerance);\n+        Assert.assertEquals(\"N\",n,u2.getN(),tolerance);\n+        Assert.assertEquals(\"sum\",sum,u2.getSum(),tolerance);\n+        Assert.assertEquals(\"sumsq\",sumSq,u2.getSumsq(),tolerance);\n+        Assert.assertEquals(\"var\",var,u2.getVariance(),tolerance);\n+        Assert.assertEquals(\"std\",std,u2.getStandardDeviation(),tolerance);\n+        Assert.assertEquals(\"mean\",mean,u2.getMean(),tolerance);\n+        Assert.assertEquals(\"min\",min,u2.getMin(),tolerance);\n+        Assert.assertEquals(\"max\",max,u2.getMax(),tolerance);\n \n         u2.clear();\n-        assertEquals(\"total count\",0,u2.getN(),tolerance);\n+        Assert.assertEquals(\"total count\",0,u2.getN(),tolerance);\n     }\n }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.NumberTransformer;\n import org.apache.commons.math.util.TransformerMap;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link ListUnivariateImpl} class.\n  * @version $Revision$ $Date$\n  */\n \n-public final class MixedListUnivariateImplTest extends TestCase {\n+public final class MixedListUnivariateImplTest {\n     private double one = 1;\n     private float two = 2;\n     private int three = 3;\n \n     private TransformerMap transformers = new TransformerMap();\n \n-    public MixedListUnivariateImplTest(String name) {\n-        super(name);\n+    public MixedListUnivariateImplTest() {\n         transformers = new TransformerMap();\n \n         transformers.putTransformer(Foo.class, new FooTransformer());\n     }\n \n     /** test stats */\n+    @Test\n     public void testStats() {\n         List<Object> externalList = new ArrayList<Object>();\n \n         DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);\n \n-        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+        Assert.assertEquals(\"total count\", 0, u.getN(), tolerance);\n         u.addValue(one);\n         u.addValue(two);\n         u.addValue(two);\n         u.addValue(three);\n-        assertEquals(\"N\", n, u.getN(), tolerance);\n-        assertEquals(\"sum\", sum, u.getSum(), tolerance);\n-        assertEquals(\"sumsq\", sumSq, u.getSumsq(), tolerance);\n-        assertEquals(\"var\", var, u.getVariance(), tolerance);\n-        assertEquals(\"std\", std, u.getStandardDeviation(), tolerance);\n-        assertEquals(\"mean\", mean, u.getMean(), tolerance);\n-        assertEquals(\"min\", min, u.getMin(), tolerance);\n-        assertEquals(\"max\", max, u.getMax(), tolerance);\n+        Assert.assertEquals(\"N\", n, u.getN(), tolerance);\n+        Assert.assertEquals(\"sum\", sum, u.getSum(), tolerance);\n+        Assert.assertEquals(\"sumsq\", sumSq, u.getSumsq(), tolerance);\n+        Assert.assertEquals(\"var\", var, u.getVariance(), tolerance);\n+        Assert.assertEquals(\"std\", std, u.getStandardDeviation(), tolerance);\n+        Assert.assertEquals(\"mean\", mean, u.getMean(), tolerance);\n+        Assert.assertEquals(\"min\", min, u.getMin(), tolerance);\n+        Assert.assertEquals(\"max\", max, u.getMax(), tolerance);\n         u.clear();\n-        assertEquals(\"total count\", 0, u.getN(), tolerance);\n-    }\n-\n+        Assert.assertEquals(\"total count\", 0, u.getN(), tolerance);\n+    }\n+\n+    @Test\n     public void testN0andN1Conditions() throws Exception {\n         DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n \n-        assertTrue(\n+        Assert.assertTrue(\n             \"Mean of n = 0 set should be NaN\",\n             Double.isNaN(u.getMean()));\n-        assertTrue(\n+        Assert.assertTrue(\n             \"Standard Deviation of n = 0 set should be NaN\",\n             Double.isNaN(u.getStandardDeviation()));\n-        assertTrue(\n+        Assert.assertTrue(\n             \"Variance of n = 0 set should be NaN\",\n             Double.isNaN(u.getVariance()));\n \n         u.addValue(one);\n \n-        assertTrue(\n+        Assert.assertTrue(\n             \"Mean of n = 1 set should be value of single item n1, instead it is \" + u.getMean() ,\n             u.getMean() == one);\n \n-        assertTrue(\n+        Assert.assertTrue(\n             \"StdDev of n = 1 set should be zero, instead it is: \"\n                 + u.getStandardDeviation(),\n             u.getStandardDeviation() == 0);\n-        assertTrue(\n+        Assert.assertTrue(\n             \"Variance of n = 1 set should be zero\",\n             u.getVariance() == 0);\n     }\n \n+    @Test\n     public void testSkewAndKurtosis() {\n         ListUnivariateImpl u =\n             new ListUnivariateImpl(new ArrayList<Object>(), transformers);\n         u.addObject(\"12.3\");\n \n \n-        assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n-        assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n-        assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n-        assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n-    }\n-\n+        Assert.assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+        Assert.assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+        Assert.assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+        Assert.assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    @Test\n     public void testProductAndGeometricMean() throws Exception {\n         ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n         u.setWindowSize(10);\n         u.addValue(3.0);\n         u.addValue(4.0);\n \n-        assertEquals(\n+        Assert.assertEquals(\n             \"Geometric mean not expected\",\n             2.213364,\n             u.getGeometricMean(),\n             u.addValue(i + 2);\n         }\n         // Values should be (2,3,4,5,6,7,8,9,10,11)\n-        assertEquals(\n+        Assert.assertEquals(\n             \"Geometric mean not expected\",\n             5.755931,\n             u.getGeometricMean(),\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n \n import java.util.Locale;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n /**\n  * Test cases for the {@link StatisticalSummaryValues} class.\n  *\n  * @version $Revision$ $Date$\n  */\n \n-public final class StatisticalSummaryValuesTest extends TestCase {\n+public final class StatisticalSummaryValuesTest {\n \n-\n-    public StatisticalSummaryValuesTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testSerialization() {\n         StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n         TestUtils.checkSerializedEquality(u);\n         verifyEquality(u, t);\n     }\n \n+    @Test\n     public void testEqualsAndHashCode() {\n         StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n         StatisticalSummaryValues t = null;\n-        assertTrue(\"reflexive\", u.equals(u));\n-        assertFalse(\"non-null compared to null\", u.equals(t));\n-        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n+        Assert.assertTrue(\"reflexive\", u.equals(u));\n+        Assert.assertFalse(\"non-null compared to null\", u.equals(t));\n+        Assert.assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n         t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n-        assertTrue(\"instances with same data should be equal\", t.equals(u));\n-        assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n+        Assert.assertTrue(\"instances with same data should be equal\", t.equals(u));\n+        Assert.assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n \n         u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);\n         t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);\n-        assertFalse(\"instances based on different data should be different\",\n+        Assert.assertFalse(\"instances based on different data should be different\",\n                 (u.equals(t) ||t.equals(u)));\n     }\n \n     private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {\n-        assertEquals(\"N\",s.getN(),u.getN());\n+        Assert.assertEquals(\"N\",s.getN(),u.getN());\n         TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(), 0);\n         TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(), 0);\n         TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(), 0);\n         TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(), 0);\n     }\n     \n+    @Test\n     public void testToString() {\n         StatisticalSummaryValues u  = new StatisticalSummaryValues(4.5, 16, 10, 5, 4, 45);\n         Locale d = Locale.getDefault();\n         Locale.setDefault(Locale.US);\n-        assertEquals(\"StatisticalSummaryValues:\\n\" +\n+        Assert.assertEquals(\"StatisticalSummaryValues:\\n\" +\n                      \"n: 10\\n\" +\n                      \"min: 4.0\\n\" +\n                      \"max: 5.0\\n\" +\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for {@link StorelessUnivariateStatistic} classes.\n public abstract class StorelessUnivariateStatisticAbstractTest\n     extends UnivariateStatisticAbstractTest {\n \n-    public StorelessUnivariateStatisticAbstractTest(String name) {\n-        super(name);\n-    }\n-\n     /** Small sample arrays */\n     protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};\n \n     /**\n      *  Verifies that increment() and incrementAll work properly.\n      */\n+    @Test\n     public void testIncrementation() throws Exception {\n \n         StorelessUnivariateStatistic statistic =\n             statistic.increment(testArray[i]);\n         }\n \n-        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n-        assertEquals(testArray.length, statistic.getN());\n+        Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        Assert.assertEquals(testArray.length, statistic.getN());\n \n         statistic.clear();\n \n         // Add testArray all at once and check again\n         statistic.incrementAll(testArray);\n-        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n-        assertEquals(testArray.length, statistic.getN());\n+        Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        Assert.assertEquals(testArray.length, statistic.getN());\n \n         statistic.clear();\n \n         // Cleared\n         checkClearValue(statistic);\n-        assertEquals(0, statistic.getN());\n+        Assert.assertEquals(0, statistic.getN());\n \n     }\n \n     protected void checkClearValue(StorelessUnivariateStatistic statistic){\n-        assertTrue(Double.isNaN(statistic.getResult()));\n+        Assert.assertTrue(Double.isNaN(statistic.getResult()));\n     }\n     \n+    @Test\n     public void testSerialization() throws Exception {\n \n         StorelessUnivariateStatistic statistic =\n \n         TestUtils.checkSerializedEquality(statistic);\n \n-        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n \n         statistic.clear();\n \n \n     }\n \n+    @Test\n     public void testEqualsAndHashCode() {\n         StorelessUnivariateStatistic statistic =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n         StorelessUnivariateStatistic statistic2 = null;\n \n-        assertTrue(\"non-null, compared to null\", !statistic.equals(statistic2));\n-        assertTrue(\"reflexive, non-null\", statistic.equals(statistic));\n+        Assert.assertTrue(\"non-null, compared to null\", !statistic.equals(statistic2));\n+        Assert.assertTrue(\"reflexive, non-null\", statistic.equals(statistic));\n \n         int emptyHash = statistic.hashCode();\n         statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();\n-        assertTrue(\"empty stats should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"empty stats should have the same hashcode\",\n+        Assert.assertTrue(\"empty stats should be equal\", statistic.equals(statistic2));\n+        Assert.assertEquals(\"empty stats should have the same hashcode\",\n                 emptyHash, statistic2.hashCode());\n \n         statistic.increment(1d);\n-        assertTrue(\"reflexive, non-empty\", statistic.equals(statistic));\n-        assertTrue(\"non-empty, compared to empty\", !statistic.equals(statistic2));\n-        assertTrue(\"non-empty, compared to empty\", !statistic2.equals(statistic));\n-        assertTrue(\"non-empty stat should have different hashcode from empty stat\",\n+        Assert.assertTrue(\"reflexive, non-empty\", statistic.equals(statistic));\n+        Assert.assertTrue(\"non-empty, compared to empty\", !statistic.equals(statistic2));\n+        Assert.assertTrue(\"non-empty, compared to empty\", !statistic2.equals(statistic));\n+        Assert.assertTrue(\"non-empty stat should have different hashcode from empty stat\",\n                 statistic.hashCode() != emptyHash);\n \n         statistic2.increment(1d);\n-        assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"stats with same data should have the same hashcode\",\n+        Assert.assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n+        Assert.assertEquals(\"stats with same data should have the same hashcode\",\n                 statistic.hashCode(), statistic2.hashCode());\n \n         statistic.increment(Double.POSITIVE_INFINITY);\n-        assertTrue(\"stats with different n's should not be equal\", !statistic2.equals(statistic));\n-        assertTrue(\"stats with different n's should have different hashcodes\",\n+        Assert.assertTrue(\"stats with different n's should not be equal\", !statistic2.equals(statistic));\n+        Assert.assertTrue(\"stats with different n's should have different hashcodes\",\n                 statistic.hashCode() != statistic2.hashCode());\n \n         statistic2.increment(Double.POSITIVE_INFINITY);\n-        assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"stats with same data should have the same hashcode\",\n+        Assert.assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n+        Assert.assertEquals(\"stats with same data should have the same hashcode\",\n                 statistic.hashCode(), statistic2.hashCode());\n \n         statistic.clear();\n         statistic2.clear();\n-        assertTrue(\"cleared stats should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"cleared stats should have thashcode of empty stat\",\n+        Assert.assertTrue(\"cleared stats should be equal\", statistic.equals(statistic2));\n+        Assert.assertEquals(\"cleared stats should have thashcode of empty stat\",\n                 emptyHash, statistic2.hashCode());\n-        assertEquals(\"cleared stats should have thashcode of empty stat\",\n+        Assert.assertEquals(\"cleared stats should have thashcode of empty stat\",\n                 emptyHash, statistic.hashCode());\n \n     }\n \n+    @Test\n     public void testMomentSmallSamples() {\n         UnivariateStatistic stat = getUnivariateStatistic();\n         if (stat instanceof SecondMoment) {\n             SecondMoment moment = (SecondMoment) getUnivariateStatistic();\n-            assertTrue(Double.isNaN(moment.getResult()));\n+            Assert.assertTrue(Double.isNaN(moment.getResult()));\n             moment.increment(1d);\n-            assertEquals(0d, moment.getResult(), 0);\n+            Assert.assertEquals(0d, moment.getResult(), 0);\n         }\n     }\n \n      * Make sure that evaluate(double[]) and inrementAll(double[]),\n      * getResult() give same results.\n      */\n+    @Test\n     public void testConsistency() {\n         StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();\n         stat.incrementAll(testArray);\n-        assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());\n+        Assert.assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());\n         for (int i = 0; i < smallSamples.length; i++) {\n             stat.clear();\n             for (int j =0; j < smallSamples[i].length; j++) {\n      * incremented the same way.\n      *\n      */\n+    @Test\n     public void testCopyConsistency() {\n \n         StorelessUnivariateStatistic master =\n         replica = master.copy();\n \n         // Check same\n-        assertTrue(replica.equals(master));\n-        assertTrue(master.equals(replica));\n+        Assert.assertTrue(replica.equals(master));\n+        Assert.assertTrue(master.equals(replica));\n \n         // Now add second part to both and check again\n         master.incrementAll(testArray,\n                 (int) index, (int) (testArray.length - index));\n         replica.incrementAll(testArray,\n                 (int) index, (int) (testArray.length - index));\n-        assertTrue(replica.equals(master));\n-        assertTrue(master.equals(replica));\n-    }\n-\n+        Assert.assertTrue(replica.equals(master));\n+        Assert.assertTrue(master.equals(replica));\n+    }\n+\n+    @Test\n     public void testSerial() {\n         StorelessUnivariateStatistic s =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n-        assertEquals(s, TestUtils.serializeAndRecover(s));\n+        Assert.assertEquals(s, TestUtils.serializeAndRecover(s));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n  */\n package org.apache.commons.math.stat.descriptive;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n /**\n  * Test cases for the {@link SummaryStatistics} class.\n  *\n  * @version $Revision$ $Date$\n  */\n \n-public class SummaryStatisticsTest extends TestCase {\n+public class SummaryStatisticsTest {\n \n     private double one = 1;\n     private float twoF = 2;\n     private double max = 3;\n     private double tolerance = 10E-15;\n \n-    public SummaryStatisticsTest(String name) {\n-        super(name);\n-    }\n-\n     protected SummaryStatistics createSummaryStatistics() {\n         return new SummaryStatistics();\n     }\n \n     /** test stats */\n+    @Test\n     public void testStats() {\n         SummaryStatistics u = createSummaryStatistics();\n-        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        Assert.assertEquals(\"total count\",0,u.getN(),tolerance);\n         u.addValue(one);\n         u.addValue(twoF);\n         u.addValue(twoL);\n         u.addValue(three);\n-        assertEquals(\"N\",n,u.getN(),tolerance);\n-        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n-        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n-        assertEquals(\"var\",var,u.getVariance(),tolerance);\n-        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n-        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n-        assertEquals(\"min\",min,u.getMin(),tolerance);\n-        assertEquals(\"max\",max,u.getMax(),tolerance);\n-        u.clear();\n-        assertEquals(\"total count\",0,u.getN(),tolerance);\n-    }\n-\n+        Assert.assertEquals(\"N\",n,u.getN(),tolerance);\n+        Assert.assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        Assert.assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        Assert.assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        Assert.assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        Assert.assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        Assert.assertEquals(\"min\",min,u.getMin(),tolerance);\n+        Assert.assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        Assert.assertEquals(\"total count\",0,u.getN(),tolerance);\n+    }\n+\n+    @Test\n     public void testN0andN1Conditions() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n-        assertTrue(\"Mean of n = 0 set should be NaN\",\n+        Assert.assertTrue(\"Mean of n = 0 set should be NaN\",\n                 Double.isNaN( u.getMean() ) );\n-        assertTrue(\"Standard Deviation of n = 0 set should be NaN\",\n+        Assert.assertTrue(\"Standard Deviation of n = 0 set should be NaN\",\n                 Double.isNaN( u.getStandardDeviation() ) );\n-        assertTrue(\"Variance of n = 0 set should be NaN\",\n+        Assert.assertTrue(\"Variance of n = 0 set should be NaN\",\n                 Double.isNaN(u.getVariance() ) );\n \n         /* n=1 */\n         u.addValue(one);\n-        assertTrue(\"mean should be one (n = 1)\",\n+        Assert.assertTrue(\"mean should be one (n = 1)\",\n                 u.getMean() == one);\n-        assertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(),\n+        Assert.assertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(),\n                 u.getGeometricMean() == one);\n-        assertTrue(\"Std should be zero (n = 1)\",\n+        Assert.assertTrue(\"Std should be zero (n = 1)\",\n                 u.getStandardDeviation() == 0.0);\n-        assertTrue(\"variance should be zero (n = 1)\",\n+        Assert.assertTrue(\"variance should be zero (n = 1)\",\n                 u.getVariance() == 0.0);\n \n         /* n=2 */\n         u.addValue(twoF);\n-        assertTrue(\"Std should not be zero (n = 2)\",\n+        Assert.assertTrue(\"Std should not be zero (n = 2)\",\n                 u.getStandardDeviation() != 0.0);\n-        assertTrue(\"variance should not be zero (n = 2)\",\n+        Assert.assertTrue(\"variance should not be zero (n = 2)\",\n                 u.getVariance() != 0.0);\n \n     }\n \n+    @Test\n     public void testProductAndGeometricMean() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.addValue( 1.0 );\n         u.addValue( 3.0 );\n         u.addValue( 4.0 );\n \n-        assertEquals( \"Geometric mean not expected\", 2.213364,\n+        Assert.assertEquals( \"Geometric mean not expected\", 2.213364,\n                 u.getGeometricMean(), 0.00001 );\n     }\n \n+    @Test\n     public void testNaNContracts() {\n         SummaryStatistics u = createSummaryStatistics();\n-        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean()));\n-        assertTrue(\"min not NaN\",Double.isNaN(u.getMin()));\n-        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation()));\n-        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance()));\n-        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        Assert.assertTrue(\"mean not NaN\",Double.isNaN(u.getMean()));\n+        Assert.assertTrue(\"min not NaN\",Double.isNaN(u.getMin()));\n+        Assert.assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation()));\n+        Assert.assertTrue(\"var not NaN\",Double.isNaN(u.getVariance()));\n+        Assert.assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n \n         u.addValue(1.0);\n \n-        assertEquals( \"mean not expected\", 1.0,\n+        Assert.assertEquals( \"mean not expected\", 1.0,\n                 u.getMean(), Double.MIN_VALUE);\n-        assertEquals( \"variance not expected\", 0.0,\n+        Assert.assertEquals( \"variance not expected\", 0.0,\n                 u.getVariance(), Double.MIN_VALUE);\n-        assertEquals( \"geometric mean not expected\", 1.0,\n+        Assert.assertEquals( \"geometric mean not expected\", 1.0,\n                 u.getGeometricMean(), Double.MIN_VALUE);\n \n         u.addValue(-1.0);\n \n-        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        Assert.assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n \n         u.addValue(0.0);\n \n-        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        Assert.assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n \n         //FiXME: test all other NaN contract specs\n     }\n \n+    @Test\n     public void testGetSummary() {\n         SummaryStatistics u = createSummaryStatistics();\n         StatisticalSummary summary = u.getSummary();\n         verifySummary(u, summary);\n     }\n \n+    @Test\n     public void testSerialization() {\n         SummaryStatistics u = createSummaryStatistics();\n         // Empty test\n \n     }\n \n+    @Test\n     public void testEqualsAndHashCode() {\n         SummaryStatistics u = createSummaryStatistics();\n         SummaryStatistics t = null;\n         int emptyHash = u.hashCode();\n-        assertTrue(\"reflexive\", u.equals(u));\n-        assertFalse(\"non-null compared to null\", u.equals(t));\n-        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n+        Assert.assertTrue(\"reflexive\", u.equals(u));\n+        Assert.assertFalse(\"non-null compared to null\", u.equals(t));\n+        Assert.assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n         t = createSummaryStatistics();\n-        assertTrue(\"empty instances should be equal\", t.equals(u));\n-        assertTrue(\"empty instances should be equal\", u.equals(t));\n-        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+        Assert.assertTrue(\"empty instances should be equal\", t.equals(u));\n+        Assert.assertTrue(\"empty instances should be equal\", u.equals(t));\n+        Assert.assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n \n         // Add some data to u\n         u.addValue(2d);\n         u.addValue(1d);\n         u.addValue(3d);\n         u.addValue(4d);\n-        assertFalse(\"different n's should make instances not equal\", t.equals(u));\n-        assertFalse(\"different n's should make instances not equal\", u.equals(t));\n-        assertTrue(\"different n's should make hashcodes different\",\n+        Assert.assertFalse(\"different n's should make instances not equal\", t.equals(u));\n+        Assert.assertFalse(\"different n's should make instances not equal\", u.equals(t));\n+        Assert.assertTrue(\"different n's should make hashcodes different\",\n                 u.hashCode() != t.hashCode());\n \n         //Add data in same order to t\n         t.addValue(1d);\n         t.addValue(3d);\n         t.addValue(4d);\n-        assertTrue(\"summaries based on same data should be equal\", t.equals(u));\n-        assertTrue(\"summaries based on same data should be equal\", u.equals(t));\n-        assertEquals(\"summaries based on same data should have same hashcodes\",\n+        Assert.assertTrue(\"summaries based on same data should be equal\", t.equals(u));\n+        Assert.assertTrue(\"summaries based on same data should be equal\", u.equals(t));\n+        Assert.assertEquals(\"summaries based on same data should have same hashcodes\",\n                 u.hashCode(), t.hashCode());\n \n         // Clear and make sure summaries are indistinguishable from empty summary\n         u.clear();\n         t.clear();\n-        assertTrue(\"empty instances should be equal\", t.equals(u));\n-        assertTrue(\"empty instances should be equal\", u.equals(t));\n-        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n-        assertEquals(\"empty hash code\", emptyHash, u.hashCode());\n-    }\n-\n+        Assert.assertTrue(\"empty instances should be equal\", t.equals(u));\n+        Assert.assertTrue(\"empty instances should be equal\", u.equals(t));\n+        Assert.assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+        Assert.assertEquals(\"empty hash code\", emptyHash, u.hashCode());\n+    }\n+\n+    @Test\n     public void testCopy() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.addValue(2d);\n         u.addValue(3d);\n         u.addValue(4d);\n         SummaryStatistics v = new SummaryStatistics(u);\n-        assertEquals(u, v);\n-        assertEquals(v, u);\n-        assertTrue(v.geoMean == v.getGeoMeanImpl());\n-        assertTrue(v.mean == v.getMeanImpl());\n-        assertTrue(v.min == v.getMinImpl());\n-        assertTrue(v.max == v.getMaxImpl());\n-        assertTrue(v.sum == v.getSumImpl());\n-        assertTrue(v.sumsq == v.getSumsqImpl());\n-        assertTrue(v.sumLog == v.getSumLogImpl());\n-        assertTrue(v.variance == v.getVarianceImpl());\n+        Assert.assertEquals(u, v);\n+        Assert.assertEquals(v, u);\n+        Assert.assertTrue(v.geoMean == v.getGeoMeanImpl());\n+        Assert.assertTrue(v.mean == v.getMeanImpl());\n+        Assert.assertTrue(v.min == v.getMinImpl());\n+        Assert.assertTrue(v.max == v.getMaxImpl());\n+        Assert.assertTrue(v.sum == v.getSumImpl());\n+        Assert.assertTrue(v.sumsq == v.getSumsqImpl());\n+        Assert.assertTrue(v.sumLog == v.getSumLogImpl());\n+        Assert.assertTrue(v.variance == v.getVarianceImpl());\n \n         // Make sure both behave the same with additional values added\n         u.addValue(7d);\n         v.addValue(9d);\n         v.addValue(11d);\n         v.addValue(23d);\n-        assertEquals(u, v);\n-        assertEquals(v, u);\n+        Assert.assertEquals(u, v);\n+        Assert.assertEquals(v, u);\n \n         // Check implementation pointers are preserved\n         u.clear();\n         u.setSumImpl(new Sum());\n         SummaryStatistics.copy(u,v);\n-        assertEquals(u.sum, v.sum);\n-        assertEquals(u.getSumImpl(), v.getSumImpl());\n+        Assert.assertEquals(u.sum, v.sum);\n+        Assert.assertEquals(u.getSumImpl(), v.getSumImpl());\n \n     }\n \n     private void verifySummary(SummaryStatistics u, StatisticalSummary s) {\n-        assertEquals(\"N\",s.getN(),u.getN());\n+        Assert.assertEquals(\"N\",s.getN(),u.getN());\n         TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(),tolerance);\n         TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(),tolerance);\n         TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);\n         TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(),tolerance);\n     }\n \n+    @Test\n     public void testSetterInjection() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.setMeanImpl(new Sum());\n         u.setSumLogImpl(new Sum());\n         u.addValue(1);\n         u.addValue(3);\n-        assertEquals(4, u.getMean(), 1E-14);\n-        assertEquals(4, u.getSumOfLogs(), 1E-14);\n-        assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14);\n+        Assert.assertEquals(4, u.getMean(), 1E-14);\n+        Assert.assertEquals(4, u.getSumOfLogs(), 1E-14);\n+        Assert.assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14);\n         u.clear();\n         u.addValue(1);\n         u.addValue(2);\n-        assertEquals(3, u.getMean(), 1E-14);\n+        Assert.assertEquals(3, u.getMean(), 1E-14);\n         u.clear();\n         u.setMeanImpl(new Mean()); // OK after clear\n     }\n \n+    @Test\n     public void testSetterIllegalState() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.addValue(1);\n         u.addValue(3);\n         try {\n             u.setMeanImpl(new Sum());\n-            fail(\"Expecting IllegalStateException\");\n+            Assert.fail(\"Expecting IllegalStateException\");\n         } catch (IllegalStateException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatisticsTest.java\n  */\n public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {\n \n-    public SynchronizedDescriptiveStatisticsTest(String name) {\n-        super(name);\n-    }\n-\n     @Override\n     protected DescriptiveStatistics createDescriptiveStatistics() {\n         return new SynchronizedDescriptiveStatistics();\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n  */\n public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {\n \n-    public SynchronizedSummaryStatisticsTest(String name) {\n-        super(name);\n-    }\n-\n     @Override\n     protected SummaryStatistics createSummaryStatistics() {\n         return new SynchronizedSummaryStatistics();\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.random.RandomData;\n import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n  * @version $Revision$ $Date$\n  */\n-public abstract class UnivariateStatisticAbstractTest extends TestCase {\n+public abstract class UnivariateStatisticAbstractTest {\n \n     protected double mean = 12.404545454545455d;\n     protected double geoMean = 12.070589161633011d;\n            1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,\n            1.0,  1.0 };\n \n-\n-    public UnivariateStatisticAbstractTest(String name) {\n-        super(name);\n-    }\n-\n     public abstract UnivariateStatistic getUnivariateStatistic();\n \n     public abstract double expectedValue();\n         return tolerance;\n     }\n \n+    @Test\n     public void testEvaluation() throws Exception {\n-        assertEquals(\n+        Assert.assertEquals(\n             expectedValue(),\n             getUnivariateStatistic().evaluate(testArray),\n             getTolerance());\n     }\n \n+    @Test\n     public void testCopy() throws Exception {\n         UnivariateStatistic original = getUnivariateStatistic();\n         UnivariateStatistic copy = original.copy();\n-        assertEquals(\n+        Assert.assertEquals(\n                 expectedValue(),\n                 copy.evaluate(testArray),\n                 getTolerance());\n      * in the repeating array.\n      */\n \n+    @Test\n     public void testWeightedConsistency() throws Exception {\n \n         // See if this statistic computes weighted statistics\n                 10E-14);\n \n         // Check consistency of weighted evaluation methods\n-        assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),\n+        Assert.assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),\n                 weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);\n \n     }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n     protected FirstMoment stat;\n \n     /**\n-     * @param name\n-     */\n-    public FirstMomentTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n     protected FourthMoment stat;\n \n     /**\n-     * @param name\n-     */\n-    public FourthMomentTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected GeometricMean stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public GeometricMeanTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.geoMean;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         GeometricMean mean = new GeometricMean();\n         // empty\n-        assertTrue(Double.isNaN(mean.getResult()));\n+        Assert.assertTrue(Double.isNaN(mean.getResult()));\n \n         // finite data\n         mean.increment(1d);\n-        assertFalse(Double.isNaN(mean.getResult()));\n+        Assert.assertFalse(Double.isNaN(mean.getResult()));\n \n         // add 0 -- makes log sum blow to minus infinity, should make 0\n         mean.increment(0d);\n-        assertEquals(0d, mean.getResult(), 0);\n+        Assert.assertEquals(0d, mean.getResult(), 0);\n \n         // add positive infinity - note the minus infinity above\n         mean.increment(Double.POSITIVE_INFINITY);\n-        assertTrue(Double.isNaN(mean.getResult()));\n+        Assert.assertTrue(Double.isNaN(mean.getResult()));\n \n         // clear\n         mean.clear();\n-        assertTrue(Double.isNaN(mean.getResult()));\n+        Assert.assertTrue(Double.isNaN(mean.getResult()));\n \n         // positive infinity by itself\n         mean.increment(Double.POSITIVE_INFINITY);\n-        assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);\n \n         // negative value -- should make NaN\n         mean.increment(-2d);\n-        assertTrue(Double.isNaN(mean.getResult()));\n+        Assert.assertTrue(Double.isNaN(mean.getResult()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Kurtosis stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public KurtosisTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n      * Make sure Double.NaN is returned iff n < 4\n      *\n      */\n+    @Test\n     public void testNaN() {\n         Kurtosis kurt = new Kurtosis();\n-        assertTrue(Double.isNaN(kurt.getResult()));\n+        Assert.assertTrue(Double.isNaN(kurt.getResult()));\n         kurt.increment(1d);\n-        assertTrue(Double.isNaN(kurt.getResult()));\n+        Assert.assertTrue(Double.isNaN(kurt.getResult()));\n         kurt.increment(1d);\n-        assertTrue(Double.isNaN(kurt.getResult()));\n+        Assert.assertTrue(Double.isNaN(kurt.getResult()));\n         kurt.increment(1d);\n-        assertTrue(Double.isNaN(kurt.getResult()));\n+        Assert.assertTrue(Double.isNaN(kurt.getResult()));\n         kurt.increment(1d);\n-        assertFalse(Double.isNaN(kurt.getResult()));\n+        Assert.assertFalse(Double.isNaN(kurt.getResult()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class MeanTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Mean stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public MeanTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.weightedMean;\n     }\n \n+    @Test\n     public void testSmallSamples() {\n         Mean mean = new Mean();\n-        assertTrue(Double.isNaN(mean.getResult()));\n+        Assert.assertTrue(Double.isNaN(mean.getResult()));\n         mean.increment(1d);\n-        assertEquals(1d, mean.getResult(), 0);\n+        Assert.assertEquals(1d, mean.getResult(), 0);\n     }\n \n+    @Test\n     public void testWeightedMean() {\n         Mean mean = new Mean();\n-        assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n-        assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance());\n+        Assert.assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n+        Assert.assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n     protected SecondMoment stat;\n \n     /**\n-     * @param name\n-     */\n-    public SecondMomentTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.StatUtils;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n-public class SemiVarianceTest extends TestCase {\n+public class SemiVarianceTest {\n \n+    @Test\n     public void testInsufficientData() {\n         double[] nothing = null;\n         SemiVariance sv = new SemiVariance();\n         try {\n             sv.evaluate(nothing);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException iae) {\n         }\n \n         try {\n             sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n             sv.evaluate(nothing);\n-            fail(\"null is not a valid data array.\");\n+            Assert.fail(\"null is not a valid data array.\");\n         } catch (MathIllegalArgumentException iae) {\n         }\n         nothing = new double[] {};\n-        assertTrue(Double.isNaN(sv.evaluate(nothing)));\n+        Assert.assertTrue(Double.isNaN(sv.evaluate(nothing)));\n     }\n \n+    @Test\n     public void testSingleDown() {\n         SemiVariance sv = new SemiVariance();\n         double[] values = { 50.0d };\n         double singletest = sv.evaluate(values);\n-        assertEquals(0.0d, singletest, 0);\n+        Assert.assertEquals(0.0d, singletest, 0);\n     }\n \n+    @Test\n     public void testSingleUp() {\n         SemiVariance sv = new SemiVariance(SemiVariance.UPSIDE_VARIANCE);\n         double[] values = { 50.0d };\n         double singletest = sv.evaluate(values);\n-        assertEquals(0.0d, singletest, 0);\n+        Assert.assertEquals(0.0d, singletest, 0);\n     }\n \n+    @Test\n     public void testSample() {\n         final double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n         final int length = values.length;\n         final double mean = StatUtils.mean(values); // 6.333...\n         final SemiVariance sv = new SemiVariance();  // Default bias correction is true\n         final double downsideSemiVariance = sv.evaluate(values); // Downside is the default\n-        assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1),\n+        Assert.assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1),\n                 downsideSemiVariance, 1E-14);\n \n         sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n         final double upsideSemiVariance = sv.evaluate(values);\n-        assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),\n+        Assert.assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),\n                 upsideSemiVariance, 1E-14);\n \n         // Verify that upper + lower semivariance against the mean sum to variance\n-        assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);\n+        Assert.assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);\n     }\n \n+    @Test\n     public void testPopulation() {\n         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n         SemiVariance sv = new SemiVariance(false);\n \n         double singletest = sv.evaluate(values);\n-        assertEquals(19.556d, singletest, 0.01d);\n+        Assert.assertEquals(19.556d, singletest, 0.01d);\n \n         sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n         singletest = sv.evaluate(values);\n-        assertEquals(36.222d, singletest, 0.01d);\n+        Assert.assertEquals(36.222d, singletest, 0.01d);\n     }\n \n+    @Test\n     public void testNonMeanCutoffs() {\n         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n         SemiVariance sv = new SemiVariance(false); // Turn off bias correction - use df = length\n \n         double singletest = sv.evaluate(values, 1.0d, SemiVariance.DOWNSIDE_VARIANCE, false, 0, values.length);\n-        assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length,\n+        Assert.assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length,\n                 singletest, 0.01d);\n \n         singletest = sv.evaluate(values, 3.0d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length);\n-        assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest,\n+        Assert.assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest,\n                 0.01d);\n     }\n \n      * Check that the lower + upper semivariance against the mean sum to the\n      * variance.\n      */\n+    @Test\n     public void testVarianceDecompMeanCutoff() {\n         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n         double variance = StatUtils.variance(values);\n         final double lower = sv.evaluate(values);\n         sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n         final double upper = sv.evaluate(values);\n-        assertEquals(variance, lower + upper, 10e-12);\n+        Assert.assertEquals(variance, lower + upper, 10e-12);\n     }\n \n     /**\n      * of squared deviations of the full set of values against the cutoff\n      * divided by df = length - 1 (assuming bias-corrected).\n      */\n+    @Test\n     public void testVarianceDecompNonMeanCutoff() {\n         double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n         double target = 0;\n         double lower = sv.evaluate(values, target);\n         sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n         double upper = sv.evaluate(values, target);\n-        assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);\n+        Assert.assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);\n     }\n \n+    @Test\n     public void testNoVariance() {\n         final double[] values = {100d, 100d, 100d, 100d};\n         SemiVariance sv = new SemiVariance();\n-        assertEquals(0, sv.evaluate(values), 10E-12);\n-        assertEquals(0, sv.evaluate(values, 100d), 10E-12);\n-        assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12);\n+        Assert.assertEquals(0, sv.evaluate(values), 10E-12);\n+        Assert.assertEquals(0, sv.evaluate(values, 100d), 10E-12);\n+        Assert.assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Skewness stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public SkewnessTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n      * Make sure Double.NaN is returned iff n < 3\n      *\n      */\n+    @Test\n     public void testNaN() {\n         Skewness skew = new Skewness();\n-        assertTrue(Double.isNaN(skew.getResult()));\n+        Assert.assertTrue(Double.isNaN(skew.getResult()));\n         skew.increment(1d);\n-        assertTrue(Double.isNaN(skew.getResult()));\n+        Assert.assertTrue(Double.isNaN(skew.getResult()));\n         skew.increment(1d);\n-        assertTrue(Double.isNaN(skew.getResult()));\n+        Assert.assertTrue(Double.isNaN(skew.getResult()));\n         skew.increment(1d);\n-        assertFalse(Double.isNaN(skew.getResult()));\n+        Assert.assertFalse(Double.isNaN(skew.getResult()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected StandardDeviation stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public StandardDeviationTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n      * Make sure Double.NaN is returned iff n = 0\n      *\n      */\n+    @Test\n     public void testNaN() {\n         StandardDeviation std = new StandardDeviation();\n-        assertTrue(Double.isNaN(std.getResult()));\n+        Assert.assertTrue(Double.isNaN(std.getResult()));\n         std.increment(1d);\n-        assertEquals(0d, std.getResult(), 0);\n+        Assert.assertEquals(0d, std.getResult(), 0);\n     }\n \n     /**\n      * Test population version of variance\n      */\n+    @Test\n     public void testPopulation() {\n         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n         double sigma = populationStandardDeviation(values);\n         m.evaluate(values);  // side effect is to add values\n         StandardDeviation s1 = new StandardDeviation();\n         s1.setBiasCorrected(false);\n-        assertEquals(sigma, s1.evaluate(values), 1E-14);\n+        Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);\n         s1.incrementAll(values);\n-        assertEquals(sigma, s1.getResult(), 1E-14);\n+        Assert.assertEquals(sigma, s1.getResult(), 1E-14);\n         s1 = new StandardDeviation(false, m);\n-        assertEquals(sigma, s1.getResult(), 1E-14);\n+        Assert.assertEquals(sigma, s1.getResult(), 1E-14);\n         s1 = new StandardDeviation(false);\n-        assertEquals(sigma, s1.evaluate(values), 1E-14);\n+        Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);\n         s1.incrementAll(values);\n-        assertEquals(sigma, s1.getResult(), 1E-14);\n+        Assert.assertEquals(sigma, s1.getResult(), 1E-14);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n     protected ThirdMoment stat;\n \n     /**\n-     * @param name\n-     */\n-    public ThirdMomentTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Variance stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public VarianceTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n      * Make sure Double.NaN is returned iff n = 0\n      *\n      */\n+    @Test\n     public void testNaN() {\n         StandardDeviation std = new StandardDeviation();\n-        assertTrue(Double.isNaN(std.getResult()));\n+        Assert.assertTrue(Double.isNaN(std.getResult()));\n         std.increment(1d);\n-        assertEquals(0d, std.getResult(), 0);\n+        Assert.assertEquals(0d, std.getResult(), 0);\n     }\n \n     /**\n      * Test population version of variance\n      */\n+    @Test\n     public void testPopulation() {\n         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n         SecondMoment m = new SecondMoment();\n         m.evaluate(values);  // side effect is to add values\n         Variance v1 = new Variance();\n         v1.setBiasCorrected(false);\n-        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n+        Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n         v1.incrementAll(values);\n-        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n+        Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n         v1 = new Variance(false, m);\n-        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n+        Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n         v1 = new Variance(false);\n-        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n+        Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n         v1.incrementAll(values);\n-        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n+        Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n     }\n \n     /**\n         return sum / v.length;\n     }\n \n+    @Test\n     public void testWeightedVariance() {\n         Variance variance = new Variance();\n-        assertEquals(expectedWeightedValue(),\n+        Assert.assertEquals(expectedWeightedValue(),\n                 variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n \n         // All weights = 1 -> weighted variance = unweighted variance\n-        assertEquals(expectedValue(),\n+        Assert.assertEquals(expectedValue(),\n                 variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n \n         // All weights the same -> when weights are normalized to sum to the length of the values array,\n         // weighted variance = unweighted value\n-        assertEquals(expectedValue(),\n+        Assert.assertEquals(expectedValue(),\n                 variance.evaluate(testArray, MathUtils.normalizeArray(identicalWeightsArray, testArray.length),\n                         0, testArray.length), getTolerance());\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n  * @version $Revision$ $Date$\n  */\n-public class MaxTest extends StorelessUnivariateStatisticAbstractTest{\n+public class MaxTest extends StorelessUnivariateStatisticAbstractTest {\n \n     protected Max stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public MaxTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.max;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,\n                 Double.POSITIVE_INFINITY};\n         Max max = new Max();\n-        assertTrue(Double.isNaN(max.getResult()));\n+        Assert.assertTrue(Double.isNaN(max.getResult()));\n         max.increment(testArray[0]);\n-        assertEquals(0d, max.getResult(), 0);\n+        Assert.assertEquals(0d, max.getResult(), 0);\n         max.increment(testArray[1]);\n-        assertEquals(0d, max.getResult(), 0);\n+        Assert.assertEquals(0d, max.getResult(), 0);\n         max.increment(testArray[2]);\n-        assertEquals(0d, max.getResult(), 0);\n+        Assert.assertEquals(0d, max.getResult(), 0);\n         max.increment(testArray[3]);\n-        assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);\n-        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);\n     }\n \n+    @Test\n     public void testNaNs() {\n         Max max = new Max();\n         double nan = Double.NaN;\n-        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);\n-        assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);\n-        assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);\n-        assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));\n+        Assert.assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);\n+        Assert.assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);\n+        Assert.assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);\n+        Assert.assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n     protected Median stat;\n \n     /**\n-     * @param name\n-     */\n-    public MedianTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n      * {@inheritDoc}\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class MinTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Min stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public MinTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.min;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,\n                 Double.NEGATIVE_INFINITY};\n         Min min = new Min();\n-        assertTrue(Double.isNaN(min.getResult()));\n+        Assert.assertTrue(Double.isNaN(min.getResult()));\n         min.increment(testArray[0]);\n-        assertEquals(0d, min.getResult(), 0);\n+        Assert.assertEquals(0d, min.getResult(), 0);\n         min.increment(testArray[1]);\n-        assertEquals(0d, min.getResult(), 0);\n+        Assert.assertEquals(0d, min.getResult(), 0);\n         min.increment(testArray[2]);\n-        assertEquals(0d, min.getResult(), 0);\n+        Assert.assertEquals(0d, min.getResult(), 0);\n         min.increment(testArray[3]);\n-        assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);\n-        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);\n     }\n \n+    @Test\n     public void testNaNs() {\n         Min min = new Min();\n         double nan = Double.NaN;\n-        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);\n-        assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);\n-        assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);\n-        assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));\n+        Assert.assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);\n+        Assert.assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);\n+        Assert.assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);\n+        Assert.assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class PercentileTest extends UnivariateStatisticAbstractTest{\n \n     protected Percentile stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public PercentileTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.percentile95;\n     }\n \n+    @Test\n     public void testHighPercentile(){\n         double[] d = new double[]{1, 2, 3};\n         Percentile p = new Percentile(75);\n-        assertEquals(3.0, p.evaluate(d), 1.0e-5);\n+        Assert.assertEquals(3.0, p.evaluate(d), 1.0e-5);\n     }\n \n+    @Test\n     public void testPercentile() {\n         double[] d = new double[] {1, 3, 2, 4};\n         Percentile p = new Percentile(30);\n-        assertEquals(1.5, p.evaluate(d), 1.0e-5);\n+        Assert.assertEquals(1.5, p.evaluate(d), 1.0e-5);\n         p.setQuantile(25);\n-        assertEquals(1.25, p.evaluate(d), 1.0e-5);\n+        Assert.assertEquals(1.25, p.evaluate(d), 1.0e-5);\n         p.setQuantile(75);\n-        assertEquals(3.75, p.evaluate(d), 1.0e-5);\n+        Assert.assertEquals(3.75, p.evaluate(d), 1.0e-5);\n         p.setQuantile(50);\n-        assertEquals(2.5, p.evaluate(d), 1.0e-5);\n+        Assert.assertEquals(2.5, p.evaluate(d), 1.0e-5);\n \n         // invalid percentiles\n         try {\n             p.evaluate(d, 0, d.length, -1.0);\n-            fail();\n+            Assert.fail();\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         try {\n             p.evaluate(d, 0, d.length, 101.0);\n-            fail();\n+            Assert.fail();\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testNISTExample() {\n         double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,\n                 95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682\n         };\n         Percentile p = new Percentile(90);\n-        assertEquals(95.1981, p.evaluate(d), 1.0e-4);\n-        assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);\n+        Assert.assertEquals(95.1981, p.evaluate(d), 1.0e-4);\n+        Assert.assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);\n     }\n \n+    @Test\n     public void test5() {\n         Percentile percentile = new Percentile(5);\n-        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());\n+        Assert.assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());\n     }\n \n+    @Test\n     public void testNullEmpty() {\n         Percentile percentile = new Percentile(50);\n         double[] nullArray = null;\n         double[] emptyArray = new double[] {};\n         try {\n             percentile.evaluate(nullArray);\n-            fail(\"Expecting MathIllegalArgumentException for null array\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException for null array\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n-        assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));\n+        Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));\n     }\n \n+    @Test\n     public void testSingleton() {\n         Percentile percentile = new Percentile(50);\n         double[] singletonArray = new double[] {1d};\n-        assertEquals(1d, percentile.evaluate(singletonArray), 0);\n-        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);\n-        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);\n-        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);\n-        assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));\n+        Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);\n+        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);\n+        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);\n+        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);\n+        Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         Percentile percentile = new Percentile(50);\n         double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};\n-        assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n+        Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n         specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,\n                 Double.NaN, Double.POSITIVE_INFINITY};\n-        assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n+        Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n         specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,\n                 Double.POSITIVE_INFINITY};\n-        assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));\n+        Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));\n         specialValues = new double[] {1d, 1d, Double.NaN,\n                 Double.NaN};\n-        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n+        Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n         specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,\n                 Double.NEGATIVE_INFINITY};\n         // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY\n-        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n+        Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n     }\n \n+    @Test\n     public void testSetQuantile() {\n         Percentile percentile = new Percentile(10);\n         percentile.setQuantile(100); // OK\n-        assertEquals(100, percentile.getQuantile(), 0);\n+        Assert.assertEquals(100, percentile.getQuantile(), 0);\n         try {\n             percentile.setQuantile(0);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             new Percentile(0);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class ProductTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Product stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public ProductTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.weightedProduct;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         Product product = new Product();\n-        assertEquals(1, product.getResult(), 0);\n+        Assert.assertEquals(1, product.getResult(), 0);\n         product.increment(1);\n-        assertEquals(1, product.getResult(), 0);\n+        Assert.assertEquals(1, product.getResult(), 0);\n         product.increment(Double.POSITIVE_INFINITY);\n-        assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);\n         product.increment(Double.NEGATIVE_INFINITY);\n-        assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);\n         product.increment(Double.NaN);\n-        assertTrue(Double.isNaN(product.getResult()));\n+        Assert.assertTrue(Double.isNaN(product.getResult()));\n         product.increment(1);\n-        assertTrue(Double.isNaN(product.getResult()));\n+        Assert.assertTrue(Double.isNaN(product.getResult()));\n     }\n \n+    @Test\n     public void testWeightedProduct() {\n         Product product = new Product();\n-        assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());\n-        assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n+        Assert.assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());\n+        Assert.assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n     }\n     \n     @Override\n     protected void checkClearValue(StorelessUnivariateStatistic statistic){\n-        assertEquals(1, statistic.getResult(), 0);\n+        Assert.assertEquals(1, statistic.getResult(), 0);\n     }\n \n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected SumOfLogs stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public SumLogTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.sumLog;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         SumOfLogs sum = new SumOfLogs();\n         // empty\n-        assertEquals(0, sum.getResult(), 0);\n+        Assert.assertEquals(0, sum.getResult(), 0);\n \n         // finite data\n         sum.increment(1d);\n-        assertFalse(Double.isNaN(sum.getResult()));\n+        Assert.assertFalse(Double.isNaN(sum.getResult()));\n \n         // add negative infinity\n         sum.increment(0d);\n-        assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);\n \n         // add positive infinity -- should make NaN\n         sum.increment(Double.POSITIVE_INFINITY);\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        Assert.assertTrue(Double.isNaN(sum.getResult()));\n \n         // clear\n         sum.clear();\n-        assertEquals(0, sum.getResult(), 0);\n+        Assert.assertEquals(0, sum.getResult(), 0);\n \n         // positive infinity by itself\n         sum.increment(Double.POSITIVE_INFINITY);\n-        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n \n         // negative value -- should make NaN\n         sum.increment(-2d);\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        Assert.assertTrue(Double.isNaN(sum.getResult()));\n     }\n     \n     @Override\n     protected void checkClearValue(StorelessUnivariateStatistic statistic){\n-        assertEquals(0, statistic.getResult(), 0);\n+        Assert.assertEquals(0, statistic.getResult(), 0);\n     }\n     \n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link SumOfSquares} class.\n public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected SumOfSquares stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public SumSqTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.sumSq;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         SumOfSquares sumSq = new SumOfSquares();\n-        assertEquals(0, sumSq.getResult(), 0);\n+        Assert.assertEquals(0, sumSq.getResult(), 0);\n         sumSq.increment(2d);\n-        assertEquals(4d, sumSq.getResult(), 0);\n+        Assert.assertEquals(4d, sumSq.getResult(), 0);\n         sumSq.increment(Double.POSITIVE_INFINITY);\n-        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n         sumSq.increment(Double.NEGATIVE_INFINITY);\n-        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n         sumSq.increment(Double.NaN);\n-        assertTrue(Double.isNaN(sumSq.getResult()));\n+        Assert.assertTrue(Double.isNaN(sumSq.getResult()));\n         sumSq.increment(1);\n-        assertTrue(Double.isNaN(sumSq.getResult()));\n+        Assert.assertTrue(Double.isNaN(sumSq.getResult()));\n     }\n     \n     @Override\n     protected void checkClearValue(StorelessUnivariateStatistic statistic){\n-        assertEquals(0, statistic.getResult(), 0);\n+        Assert.assertEquals(0, statistic.getResult(), 0);\n     }\n \n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link Sum} class.\n public class SumTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Sum stat;\n-\n-    /**\n-     * @param name\n-     */\n-    public SumTest(String name) {\n-        super(name);\n-    }\n \n     /**\n      * {@inheritDoc}\n         return this.weightedSum;\n     }\n \n+    @Test\n     public void testSpecialValues() {\n         Sum sum = new Sum();\n-        assertEquals(0, sum.getResult(), 0);\n+        Assert.assertEquals(0, sum.getResult(), 0);\n         sum.increment(1);\n-        assertEquals(1, sum.getResult(), 0);\n+        Assert.assertEquals(1, sum.getResult(), 0);\n         sum.increment(Double.POSITIVE_INFINITY);\n-        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n         sum.increment(Double.NEGATIVE_INFINITY);\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        Assert.assertTrue(Double.isNaN(sum.getResult()));\n         sum.increment(1);\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        Assert.assertTrue(Double.isNaN(sum.getResult()));\n     }\n \n+    @Test\n     public void testWeightedSum() {\n         Sum sum = new Sum();\n-        assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n-        assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n+        Assert.assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n+        Assert.assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n     }\n     \n     @Override\n     protected void checkClearValue(StorelessUnivariateStatistic statistic){\n-        assertEquals(0, statistic.getResult(), 0);\n+        Assert.assertEquals(0, statistic.getResult(), 0);\n     }\n \n \n--- a/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the ChiSquareTestImpl class.\n  * @version $Revision$ $Date$\n  */\n \n-public class ChiSquareTestTest extends TestCase {\n+public class ChiSquareTestTest {\n \n     protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();\n \n-    public ChiSquareTestTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testChiSquare() throws Exception {\n \n         // Target values computed using R version 1.8.1\n \n         long[] observed = {10, 9, 11};\n         double[] expected = {10, 10, 10};\n-        assertEquals(\"chi-square statistic\", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);\n-        assertEquals(\"chi-square p-value\", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);\n+        Assert.assertEquals(\"chi-square statistic\", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);\n+        Assert.assertEquals(\"chi-square p-value\", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);\n \n         long[] observed1 = { 500, 623, 72, 70, 31 };\n         double[] expected1 = { 485, 541, 82, 61, 37 };\n-        assertEquals( \"chi-square test statistic\", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);\n-        assertEquals(\"chi-square p-value\", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);\n-        assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(expected1, observed1, 0.08));\n-        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(expected1, observed1, 0.05));\n+        Assert.assertEquals( \"chi-square test statistic\", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);\n+        Assert.assertEquals(\"chi-square p-value\", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);\n+        Assert.assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(expected1, observed1, 0.08));\n+        Assert.assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(expected1, observed1, 0.05));\n \n         try {\n             testStatistic.chiSquareTest(expected1, observed1, 95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         double[] tooShortEx = { 1 };\n         try {\n             testStatistic.chiSquare(tooShortEx, tooShortObs);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         double[] unMatchedEx = { 1, 1, 2 };\n         try {\n             testStatistic.chiSquare(unMatchedEx, unMatchedObs);\n-            fail(\"arrays have different lengths, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arrays have different lengths, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         expected[0] = 0;\n         try {\n             testStatistic.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, MathIllegalArgumentException expected\");\n+            Assert.fail(\"bad expected count, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         observed[0] = -1;\n         try {\n             testStatistic.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-    }\n-\n+            Assert.fail(\"bad expected count, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n     public void testChiSquareIndependence() throws Exception {\n \n         // Target values computed using R version 1.8.1\n \n         long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n-        assertEquals( \"chi-square test statistic\", 22.709027688, testStatistic.chiSquare(counts), 1E-9);\n-        assertEquals(\"chi-square p-value\", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);\n-        assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(counts, 0.0002));\n-        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts, 0.0001));\n+        Assert.assertEquals( \"chi-square test statistic\", 22.709027688, testStatistic.chiSquare(counts), 1E-9);\n+        Assert.assertEquals(\"chi-square p-value\", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);\n+        Assert.assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(counts, 0.0002));\n+        Assert.assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts, 0.0001));\n \n         long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n-        assertEquals( \"chi-square test statistic\", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);\n-        assertEquals(\"chi-square p-value\",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);\n-        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts2, 0.1));\n+        Assert.assertEquals( \"chi-square test statistic\", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);\n+        Assert.assertEquals(\"chi-square p-value\",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);\n+        Assert.assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts2, 0.1));\n \n         // ragged input array\n         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n         try {\n             testStatistic.chiSquare(counts3);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts4 = {{40, 22, 43}};\n         try {\n             testStatistic.chiSquare(counts4);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts5 = {{40}, {40}, {30}, {10}};\n         try {\n             testStatistic.chiSquare(counts5);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n         try {\n             testStatistic.chiSquare(counts6);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         // bad alpha\n         try {\n             testStatistic.chiSquareTest(counts, 0);\n-            fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testChiSquareLargeTestStatistic() throws Exception {\n         double[] exp = new double[] {\n             3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,\n         org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n             new org.apache.commons.math.stat.inference.ChiSquareTestImpl();\n         double cst = csti.chiSquareTest(exp, obs);\n-        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n-        assertEquals( \"chi-square test statistic\",\n+        Assert.assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n+        Assert.assertEquals( \"chi-square test statistic\",\n                 114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);\n     }\n \n     /** Contingency table containing zeros - PR # 32531 */\n+    @Test\n     public void testChiSquareZeroCount() throws Exception {\n         // Target values computed using R version 1.8.1\n         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n-        assertEquals( \"chi-square test statistic\", 9.67444662263,\n+        Assert.assertEquals( \"chi-square test statistic\", 9.67444662263,\n                 testStatistic.chiSquare(counts), 1E-9);\n-        assertEquals(\"chi-square p-value\", 0.0462835770603,\n+        Assert.assertEquals(\"chi-square p-value\", 0.0462835770603,\n                 testStatistic.chiSquareTest(counts), 1E-9);\n     }\n \n     /** Target values verified using DATAPLOT version 2006.3 */\n+    @Test\n     public void testChiSquareDataSetsComparisonEqualCounts()\n     throws Exception {\n         long[] observed1 = {10, 12, 12, 10};\n         long[] observed2 = {5, 15, 14, 10};\n-        assertEquals(\"chi-square p value\", 0.541096,\n-                testStatistic.chiSquareTestDataSetsComparison(\n-                observed1, observed2), 1E-6);\n-        assertEquals(\"chi-square test statistic\", 2.153846,\n+        Assert.assertEquals(\"chi-square p value\", 0.541096,\n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2), 1E-6);\n+        Assert.assertEquals(\"chi-square test statistic\", 2.153846,\n                 testStatistic.chiSquareDataSetsComparison(\n                 observed1, observed2), 1E-6);\n-        assertFalse(\"chi-square test result\",\n+        Assert.assertFalse(\"chi-square test result\",\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2, 0.4));\n     }\n \n     /** Target values verified using DATAPLOT version 2006.3 */\n+    @Test\n     public void testChiSquareDataSetsComparisonUnEqualCounts()\n     throws Exception {\n         long[] observed1 = {10, 12, 12, 10, 15};\n         long[] observed2 = {15, 10, 10, 15, 5};\n-        assertEquals(\"chi-square p value\", 0.124115,\n-                testStatistic.chiSquareTestDataSetsComparison(\n-                observed1, observed2), 1E-6);\n-        assertEquals(\"chi-square test statistic\", 7.232189,\n+        Assert.assertEquals(\"chi-square p value\", 0.124115,\n+                testStatistic.chiSquareTestDataSetsComparison(\n+                observed1, observed2), 1E-6);\n+        Assert.assertEquals(\"chi-square test statistic\", 7.232189,\n                 testStatistic.chiSquareDataSetsComparison(\n                 observed1, observed2), 1E-6);\n-        assertTrue(\"chi-square test result\",\n+        Assert.assertTrue(\"chi-square test result\",\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2, 0.13));\n-        assertFalse(\"chi-square test result\",\n+        Assert.assertFalse(\"chi-square test result\",\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2, 0.12));\n     }\n \n+    @Test\n     public void testChiSquareDataSetsComparisonBadCounts()\n     throws Exception {\n         long[] observed1 = {10, -1, 12, 10, 15};\n         try {\n             testStatistic.chiSquareTestDataSetsComparison(\n                     observed1, observed2);\n-            fail(\"Expecting MathIllegalArgumentException - negative count\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - negative count\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.chiSquareTestDataSetsComparison(\n                     observed3, observed4);\n-            fail(\"Expecting MathIllegalArgumentException - double 0's\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - double 0's\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.chiSquareTestDataSetsComparison(\n                     observed5, observed6);\n-            fail(\"Expecting MathIllegalArgumentException - vanishing counts\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException - vanishing counts\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/stat/inference/MannWhitneyUTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/MannWhitneyUTestTest.java\n  */\n package org.apache.commons.math.stat.inference;\n \n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the ChiSquareTestImpl class.\n  * @version $Revision$ $Date$\n  */\n \n-public class MannWhitneyUTestTest extends TestCase {\n+public class MannWhitneyUTestTest {\n \n     protected MannWhitneyUTest testStatistic = new MannWhitneyUTestImpl();\n \n-    public MannWhitneyUTestTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testMannWhitneyUSimple() throws Exception {\n         /* Target values computed using R version 2.11.1\n          * x <- c(19, 22, 16, 29, 24)\n         final double x[] = {19, 22, 16, 29, 24};\n         final double y[] = {20, 11, 17, 12};\n         \n-        assertEquals(17, testStatistic.mannWhitneyU(x, y), 1e-10);\n-        assertEquals(0.08641, testStatistic.mannWhitneyUTest(x, y), 1e-5);\n+        Assert.assertEquals(17, testStatistic.mannWhitneyU(x, y), 1e-10);\n+        Assert.assertEquals(0.08641, testStatistic.mannWhitneyUTest(x, y), 1e-5);\n     }\n \n \n+    @Test\n     public void testMannWhitneyUInputValidation() throws Exception {\n         /* Samples must be present, i.e. length > 0\n          */\n         try {\n             testStatistic.mannWhitneyUTest(new double[] { }, new double[] { 1.0 });\n-            fail(\"x does not contain samples (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x does not contain samples (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.mannWhitneyUTest(new double[] { 1.0 }, new double[] { });\n-            fail(\"y does not contain samples (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"y does not contain samples (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n          */\n         try {\n             testStatistic.mannWhitneyUTest(null, null);\n-            fail(\"x and y is null (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x and y is null (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         try {\n             testStatistic.mannWhitneyUTest(null, null);\n-            fail(\"x and y is null (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"x and y is null (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n          */\n         try {\n             testStatistic.mannWhitneyUTest(null, new double[] { 1.0 });\n-            fail(\"x is null (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x is null (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         try {\n             testStatistic.mannWhitneyUTest(new double[] { 1.0 }, null);\n-            fail(\"y is null (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"y is null (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the OneWayAnovaImpl class.\n  * @version $Revision$ $Date$\n  */\n \n-public class OneWayAnovaTest extends TestCase {\n+public class OneWayAnovaTest {\n \n     protected OneWayAnova testStatistic = new OneWayAnovaImpl();\n \n     private double[] classC =\n             {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };\n \n-    public OneWayAnovaTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testAnovaFValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n         List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n \n-        assertEquals(\"ANOVA F-value\",  24.67361709460624,\n+        Assert.assertEquals(\"ANOVA F-value\",  24.67361709460624,\n                  testStatistic.anovaFValue(threeClasses), 1E-12);\n \n         List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n \n-        assertEquals(\"ANOVA F-value\",  0.0150579150579,\n+        Assert.assertEquals(\"ANOVA F-value\",  0.0150579150579,\n                  testStatistic.anovaFValue(twoClasses), 1E-12);\n \n         List<double[]> emptyContents = new ArrayList<double[]>();\n         emptyContents.add(classC);\n         try {\n             testStatistic.anovaFValue(emptyContents);\n-            fail(\"empty array for key classX, IllegalArgumentException expected\");\n+            Assert.fail(\"empty array for key classX, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         tooFew.add(classA);\n         try {\n             testStatistic.anovaFValue(tooFew);\n-            fail(\"less than two classes, IllegalArgumentException expected\");\n+            Assert.fail(\"less than two classes, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n \n+    @Test\n     public void testAnovaPValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n         List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n \n-        assertEquals(\"ANOVA P-value\", 6.959446E-06,\n+        Assert.assertEquals(\"ANOVA P-value\", 6.959446E-06,\n                  testStatistic.anovaPValue(threeClasses), 1E-12);\n \n         List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n \n-        assertEquals(\"ANOVA P-value\",  0.904212960464,\n+        Assert.assertEquals(\"ANOVA P-value\",  0.904212960464,\n                  testStatistic.anovaPValue(twoClasses), 1E-12);\n \n     }\n \n+    @Test\n     public void testAnovaTest() throws Exception {\n         // Target comparison values computed using R version 2.3.1 (Linux version)\n         List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n \n-        assertTrue(\"ANOVA Test P<0.01\", testStatistic.anovaTest(threeClasses, 0.01));\n+        Assert.assertTrue(\"ANOVA Test P<0.01\", testStatistic.anovaTest(threeClasses, 0.01));\n \n         List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n \n-        assertFalse(\"ANOVA Test P>0.01\", testStatistic.anovaTest(twoClasses, 0.01));\n+        Assert.assertFalse(\"ANOVA Test P>0.01\", testStatistic.anovaTest(twoClasses, 0.01));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n  */\n package org.apache.commons.math.stat.inference;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Test cases for the TTestImpl class.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class TTestTest extends TestCase {\n+public class TTestTest {\n \n     protected TTest testStatistic = new TTestImpl();\n \n     private SummaryStatistics emptyStats = new SummaryStatistics();\n    SummaryStatistics tooShortStats = null;\n \n-    public TTestTest(String name) {\n-        super(name);\n-    }\n-\n-    @Override\n+    @Before\n     public void setUp() {\n         tooShortStats = new SummaryStatistics();\n         tooShortStats.addValue(0d);\n     }\n \n+    @Test\n     public void testOneSampleT() throws Exception {\n         double[] observed =\n             {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };\n         }\n \n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"t statistic\",  -2.81976445346,\n+        Assert.assertEquals(\"t statistic\",  -2.81976445346,\n                 testStatistic.t(mu, observed), 10E-10);\n-        assertEquals(\"t statistic\",  -2.81976445346,\n+        Assert.assertEquals(\"t statistic\",  -2.81976445346,\n                 testStatistic.t(mu, sampleStats), 10E-10);\n-        assertEquals(\"p value\", 0.0136390585873,\n+        Assert.assertEquals(\"p value\", 0.0136390585873,\n                 testStatistic.tTest(mu, observed), 10E-10);\n-        assertEquals(\"p value\", 0.0136390585873,\n+        Assert.assertEquals(\"p value\", 0.0136390585873,\n                 testStatistic.tTest(mu, sampleStats), 10E-10);\n \n         try {\n             testStatistic.t(mu, (double[]) null);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, (SummaryStatistics) null);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, emptyObs);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, emptyStats);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, tooShortObs);\n-            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.tTest(mu, tooShortObs);\n-            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n            // expected\n         }\n \n         try {\n             testStatistic.t(mu, tooShortStats);\n-            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.tTest(mu, tooShortStats);\n-            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testOneSampleTTest() throws Exception {\n         double[] oneSidedP =\n             {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };\n             oneSidedPStats.addValue(oneSidedP[i]);\n         }\n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"one sample t stat\", 3.86485535541,\n+        Assert.assertEquals(\"one sample t stat\", 3.86485535541,\n                 testStatistic.t(0d, oneSidedP), 10E-10);\n-        assertEquals(\"one sample t stat\", 3.86485535541,\n+        Assert.assertEquals(\"one sample t stat\", 3.86485535541,\n                 testStatistic.t(0d, oneSidedPStats),1E-10);\n-        assertEquals(\"one sample p value\", 0.000521637019637,\n+        Assert.assertEquals(\"one sample p value\", 0.000521637019637,\n                 testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);\n-        assertEquals(\"one sample p value\", 0.000521637019637,\n+        Assert.assertEquals(\"one sample p value\", 0.000521637019637,\n                 testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);\n-        assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedP, 0.01));\n-        assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedPStats, 0.01));\n-        assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedP, 0.0001));\n-        assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));\n+        Assert.assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedP, 0.01));\n+        Assert.assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedPStats, 0.01));\n+        Assert.assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedP, 0.0001));\n+        Assert.assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));\n \n         try {\n             testStatistic.tTest(0d, oneSidedP, 95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(0d, oneSidedPStats, 95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-    }\n-\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n     public void testTwoSampleTHeterscedastic() throws Exception {\n         double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n         double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n         }\n \n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n+        Assert.assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 testStatistic.t(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n+        Assert.assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 testStatistic.t(sampleStats1, sampleStats2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n+        Assert.assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n                 testStatistic.tTest(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n+        Assert.assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n                 testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);\n-        assertTrue(\"two sample heteroscedastic t-test reject\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test reject\",\n                 testStatistic.tTest(sample1, sample2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test reject\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test reject\",\n                 testStatistic.tTest(sampleStats1, sampleStats2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test accept\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !testStatistic.tTest(sample1, sample2, 0.1));\n-        assertTrue(\"two sample heteroscedastic t-test accept\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));\n \n         try {\n             testStatistic.tTest(sample1, sample2, .95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sampleStats1, sampleStats2, .95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sample1, tooShortObs, .01);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sampleStats1, tooShortStats, .01);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sample1, tooShortObs);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n            // expected\n         }\n \n         try {\n             testStatistic.tTest(sampleStats1, tooShortStats);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(sample1, tooShortObs);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(sampleStats1, tooShortStats);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n            // expected\n         }\n     }\n+    @Test\n     public void testTwoSampleTHomoscedastic() throws Exception {\n         double[] sample1 ={2, 4, 6, 8, 10, 97};\n         double[] sample2 = {4, 6, 8, 10, 16};\n         }\n \n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086,\n+        Assert.assertEquals(\"two sample homoscedastic t stat\", 0.73096310086,\n               testStatistic.homoscedasticT(sample1, sample2), 10E-11);\n-        assertEquals(\"two sample homoscedastic p value\", 0.4833963785,\n+        Assert.assertEquals(\"two sample homoscedastic p value\", 0.4833963785,\n                 testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);\n-        assertTrue(\"two sample homoscedastic t-test reject\",\n+        Assert.assertTrue(\"two sample homoscedastic t-test reject\",\n                 testStatistic.homoscedasticTTest(sample1, sample2, 0.49));\n-        assertTrue(\"two sample homoscedastic t-test accept\",\n+        Assert.assertTrue(\"two sample homoscedastic t-test accept\",\n                 !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));\n     }\n \n+    @Test\n     public void testSmallSamples() throws Exception {\n         double[] sample1 = {1d, 3d};\n         double[] sample2 = {4d, 5d};\n \n         // Target values computed using R, version 1.8.1 (linux version)\n-        assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),\n+        Assert.assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),\n                 1E-10);\n-        assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),\n+        Assert.assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),\n                 1E-10);\n     }\n \n+    @Test\n     public void testPaired() throws Exception {\n         double[] sample1 = {1d, 3d, 5d, 7d};\n         double[] sample2 = {0d, 6d, 11d, 2d};\n         double[] sample3 = {5d, 7d, 8d, 10d};\n \n         // Target values computed using R, version 1.8.1 (linux version)\n-        assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);\n-        assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);\n-        assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);\n-        assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));\n-        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));\n+        Assert.assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);\n+        Assert.assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);\n+        Assert.assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);\n+        Assert.assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));\n+        Assert.assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the TestUtils class.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class TestUtilsTest extends TestCase {\n-\n-    public TestUtilsTest(String name) {\n-        super(name);\n-    }\n-\n+public class TestUtilsTest {\n+\n+    @Test\n     public void testChiSquare() throws Exception {\n \n         // Target values computed using R version 1.8.1\n \n         long[] observed = {10, 9, 11};\n         double[] expected = {10, 10, 10};\n-        assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n-        assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n+        Assert.assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n+        Assert.assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n \n         long[] observed1 = { 500, 623, 72, 70, 31 };\n         double[] expected1 = { 485, 541, 82, 61, 37 };\n-        assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n-        assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n-        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n-        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n+        Assert.assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n+        Assert.assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n+        Assert.assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n+        Assert.assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n \n         try {\n             TestUtils.chiSquareTest(expected1, observed1, 95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         double[] tooShortEx = { 1 };\n         try {\n             TestUtils.chiSquare(tooShortEx, tooShortObs);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         double[] unMatchedEx = { 1, 1, 2 };\n         try {\n             TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n-            fail(\"arrays have different lengths, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arrays have different lengths, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         expected[0] = 0;\n         try {\n             TestUtils.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, MathIllegalArgumentException expected\");\n+            Assert.fail(\"bad expected count, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         observed[0] = -1;\n         try {\n             TestUtils.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-    }\n-\n+            Assert.fail(\"bad expected count, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n     public void testChiSquareIndependence() throws Exception {\n \n         // Target values computed using R version 1.8.1\n \n         long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n-        assertEquals( \"chi-square test statistic\", 22.709027688, TestUtils.chiSquare(counts), 1E-9);\n-        assertEquals(\"chi-square p-value\", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);\n-        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(counts, 0.0002));\n-        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts, 0.0001));\n+        Assert.assertEquals( \"chi-square test statistic\", 22.709027688, TestUtils.chiSquare(counts), 1E-9);\n+        Assert.assertEquals(\"chi-square p-value\", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);\n+        Assert.assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(counts, 0.0002));\n+        Assert.assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts, 0.0001));\n \n         long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n-        assertEquals( \"chi-square test statistic\", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);\n-        assertEquals(\"chi-square p-value\",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);\n-        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts2, 0.1));\n+        Assert.assertEquals( \"chi-square test statistic\", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);\n+        Assert.assertEquals(\"chi-square p-value\",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);\n+        Assert.assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts2, 0.1));\n \n         // ragged input array\n         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n         try {\n             TestUtils.chiSquare(counts3);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts4 = {{40, 22, 43}};\n         try {\n             TestUtils.chiSquare(counts4);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts5 = {{40}, {40}, {30}, {10}};\n         try {\n             TestUtils.chiSquare(counts5);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n         try {\n             TestUtils.chiSquare(counts6);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         // bad alpha\n         try {\n             TestUtils.chiSquareTest(counts, 0);\n-            fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testChiSquareLargeTestStatistic() throws Exception {\n         double[] exp = new double[] {\n                 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,\n         org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n             new org.apache.commons.math.stat.inference.ChiSquareTestImpl();\n         double cst = csti.chiSquareTest(exp, obs);\n-        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n-        assertEquals( \"chi-square test statistic\",\n+        Assert.assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n+        Assert.assertEquals( \"chi-square test statistic\",\n                 114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n     }\n \n     /** Contingency table containing zeros - PR # 32531 */\n+    @Test\n     public void testChiSquareZeroCount() throws Exception {\n         // Target values computed using R version 1.8.1\n         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n-        assertEquals( \"chi-square test statistic\", 9.67444662263,\n+        Assert.assertEquals( \"chi-square test statistic\", 9.67444662263,\n                 TestUtils.chiSquare(counts), 1E-9);\n-        assertEquals(\"chi-square p-value\", 0.0462835770603,\n+        Assert.assertEquals(\"chi-square p-value\", 0.0462835770603,\n                 TestUtils.chiSquareTest(counts), 1E-9);\n     }\n \n     private double[] emptyObs = {};\n     private SummaryStatistics emptyStats = new SummaryStatistics();\n \n+    @Test\n     public void testOneSampleT() throws Exception {\n         double[] observed =\n             {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };\n         }\n \n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"t statistic\",  -2.81976445346,\n+        Assert.assertEquals(\"t statistic\",  -2.81976445346,\n                 TestUtils.t(mu, observed), 10E-10);\n-        assertEquals(\"t statistic\",  -2.81976445346,\n+        Assert.assertEquals(\"t statistic\",  -2.81976445346,\n                 TestUtils.t(mu, sampleStats), 10E-10);\n-        assertEquals(\"p value\", 0.0136390585873,\n+        Assert.assertEquals(\"p value\", 0.0136390585873,\n                 TestUtils.tTest(mu, observed), 10E-10);\n-        assertEquals(\"p value\", 0.0136390585873,\n+        Assert.assertEquals(\"p value\", 0.0136390585873,\n                 TestUtils.tTest(mu, sampleStats), 10E-10);\n \n         try {\n             TestUtils.t(mu, (double[]) null);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, (SummaryStatistics) null);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, emptyObs);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, emptyStats);\n-            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+            Assert.fail(\"arguments too short, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, tooShortObs);\n-            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             TestUtils.tTest(mu, tooShortObs);\n-            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, (SummaryStatistics) null);\n-            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             TestUtils.tTest(mu, (SummaryStatistics) null);\n-            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n+            Assert.fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n     public void testOneSampleTTest() throws Exception {\n         double[] oneSidedP =\n             {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };\n             oneSidedPStats.addValue(oneSidedP[i]);\n         }\n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"one sample t stat\", 3.86485535541,\n+        Assert.assertEquals(\"one sample t stat\", 3.86485535541,\n                 TestUtils.t(0d, oneSidedP), 10E-10);\n-        assertEquals(\"one sample t stat\", 3.86485535541,\n+        Assert.assertEquals(\"one sample t stat\", 3.86485535541,\n                 TestUtils.t(0d, oneSidedPStats),1E-10);\n-        assertEquals(\"one sample p value\", 0.000521637019637,\n+        Assert.assertEquals(\"one sample p value\", 0.000521637019637,\n                 TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);\n-        assertEquals(\"one sample p value\", 0.000521637019637,\n+        Assert.assertEquals(\"one sample p value\", 0.000521637019637,\n                 TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);\n-        assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedP, 0.01));\n-        assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedPStats, 0.01));\n-        assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedP, 0.0001));\n-        assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));\n+        Assert.assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedP, 0.01));\n+        Assert.assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedPStats, 0.01));\n+        Assert.assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedP, 0.0001));\n+        Assert.assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));\n \n         try {\n             TestUtils.tTest(0d, oneSidedP, 95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(0d, oneSidedPStats, 95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-    }\n-\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n     public void testTwoSampleTHeterscedastic() throws Exception {\n         double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n         double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n         }\n \n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n+        Assert.assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 TestUtils.t(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n+        Assert.assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 TestUtils.t(sampleStats1, sampleStats2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n+        Assert.assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n                 TestUtils.tTest(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n+        Assert.assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n                 TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);\n-        assertTrue(\"two sample heteroscedastic t-test reject\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test reject\",\n                 TestUtils.tTest(sample1, sample2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test reject\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test reject\",\n                 TestUtils.tTest(sampleStats1, sampleStats2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test accept\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !TestUtils.tTest(sample1, sample2, 0.1));\n-        assertTrue(\"two sample heteroscedastic t-test accept\",\n+        Assert.assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));\n \n         try {\n             TestUtils.tTest(sample1, sample2, .95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sampleStats1, sampleStats2, .95);\n-            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+            Assert.fail(\"alpha out of range, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sample1, tooShortObs, .01);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sample1, tooShortObs);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sampleStats1, (SummaryStatistics) null);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(sample1, tooShortObs);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(sampleStats1, (SummaryStatistics) null);\n-            fail(\"insufficient data, MathIllegalArgumentException expected\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n+            Assert.fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    @Test\n     public void testTwoSampleTHomoscedastic() throws Exception {\n         double[] sample1 ={2, 4, 6, 8, 10, 97};\n         double[] sample2 = {4, 6, 8, 10, 16};\n         }\n \n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086,\n+        Assert.assertEquals(\"two sample homoscedastic t stat\", 0.73096310086,\n                 TestUtils.homoscedasticT(sample1, sample2), 10E-11);\n-        assertEquals(\"two sample homoscedastic p value\", 0.4833963785,\n+        Assert.assertEquals(\"two sample homoscedastic p value\", 0.4833963785,\n                 TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);\n-        assertTrue(\"two sample homoscedastic t-test reject\",\n+        Assert.assertTrue(\"two sample homoscedastic t-test reject\",\n                 TestUtils.homoscedasticTTest(sample1, sample2, 0.49));\n-        assertTrue(\"two sample homoscedastic t-test accept\",\n+        Assert.assertTrue(\"two sample homoscedastic t-test accept\",\n                 !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));\n     }\n \n+    @Test\n     public void testSmallSamples() throws Exception {\n         double[] sample1 = {1d, 3d};\n         double[] sample2 = {4d, 5d};\n \n         // Target values computed using R, version 1.8.1 (linux version)\n-        assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),\n+        Assert.assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),\n                 1E-10);\n-        assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),\n+        Assert.assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),\n                 1E-10);\n     }\n \n+    @Test\n     public void testPaired() throws Exception {\n         double[] sample1 = {1d, 3d, 5d, 7d};\n         double[] sample2 = {0d, 6d, 11d, 2d};\n         double[] sample3 = {5d, 7d, 8d, 10d};\n \n         // Target values computed using R, version 1.8.1 (linux version)\n-        assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);\n-        assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);\n-        assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);\n-        assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));\n-        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));\n+        Assert.assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);\n+        Assert.assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);\n+        Assert.assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);\n+        Assert.assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));\n+        Assert.assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));\n     }\n \n     private double[] classA =\n     private List<double[]> classes = new ArrayList<double[]>();\n     private OneWayAnova oneWayAnova = new OneWayAnovaImpl();\n \n+    @Test\n     public void testOneWayAnovaUtils() throws Exception {\n         classes.add(classA);\n         classes.add(classB);\n         classes.add(classC);\n-        assertEquals(oneWayAnova.anovaFValue(classes),\n+        Assert.assertEquals(oneWayAnova.anovaFValue(classes),\n                 TestUtils.oneWayAnovaFValue(classes), 10E-12);\n-        assertEquals(oneWayAnova.anovaPValue(classes),\n+        Assert.assertEquals(oneWayAnova.anovaPValue(classes),\n                 TestUtils.oneWayAnovaPValue(classes), 10E-12);\n-        assertEquals(oneWayAnova.anovaTest(classes, 0.01),\n+        Assert.assertEquals(oneWayAnova.anovaTest(classes, 0.01),\n                 TestUtils.oneWayAnovaTest(classes, 0.01));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestTest.java\n  */\n package org.apache.commons.math.stat.inference;\n \n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the ChiSquareTestImpl class.\n  * @version $Revision$ $Date$\n  */\n \n-public class WilcoxonSignedRankTestTest extends TestCase {\n+public class WilcoxonSignedRankTestTest {\n \n     protected WilcoxonSignedRankTest testStatistic = new WilcoxonSignedRankTestImpl();\n \n-    public WilcoxonSignedRankTestTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testWilcoxonSignedRankSimple() throws Exception {\n         /* Target values computed using R version 2.11.1\n          * x <- c(1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30)\n          * \n          * Corresponds to the value obtained in R.\n          */\n-        assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);\n-        assertEquals(0.03906, testStatistic.wilcoxonSignedRankTest(x, y, true), 1e-5);        \n+        Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);\n+        Assert.assertEquals(0.03906, testStatistic.wilcoxonSignedRankTest(x, y, true), 1e-5);        \n         \n         /* ASYMPTOTIC:\n          * wilcox.test(x, y, alternative = \"two.sided\", mu = 0, paired = TRUE, exact = FALSE, correct = FALSE)\n          * e.g. http://mlsc.lboro.ac.uk/resources/statistics/wsrt.pdf\n          * and src/library/stats/R/wilcox.test.R in the R source\n          */\n-        assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);\n-        assertEquals(0.0329693812, testStatistic.wilcoxonSignedRankTest(x, y, false), 1e-10);\n+        Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);\n+        Assert.assertEquals(0.0329693812, testStatistic.wilcoxonSignedRankTest(x, y, false), 1e-10);\n     }\n     \n+    @Test\n     public void testWilcoxonSignedRankInputValidation() throws Exception {\n         /*\n          * Exact only for sample size <= 30\n         \n         try {\n             testStatistic.wilcoxonSignedRankTest(x2, y2, true);\n-            fail(\"More than 30 samples and exact chosen, IllegalArgumentException expected\");\n+            Assert.fail(\"More than 30 samples and exact chosen, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n          */\n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, true);\n-            fail(\"x does not contain samples (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x does not contain samples (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, false);\n-            fail(\"x does not contain samples (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"x does not contain samples (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, true);\n-            fail(\"y does not contain samples (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"y does not contain samples (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, false);\n-            fail(\"y does not contain samples (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"y does not contain samples (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n          */\n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, true);\n-            fail(\"x and y not same size (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x and y not same size (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, false);\n-            fail(\"x and y not same size (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"x and y not same size (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n          */\n         try {\n             testStatistic.wilcoxonSignedRankTest(null, null, true);\n-            fail(\"x and y is null (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x and y is null (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         try {\n             testStatistic.wilcoxonSignedRankTest(null, null, false);\n-            fail(\"x and y is null (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"x and y is null (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n          */\n         try {\n             testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, true);\n-            fail(\"x is null (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"x is null (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         try {\n             testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, false);\n-            fail(\"x is null (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"x is null (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, true);\n-            fail(\"y is null (exact), IllegalArgumentException expected\");\n+            Assert.fail(\"y is null (exact), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         try {\n             testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, false);\n-            fail(\"y is null (asymptotic), IllegalArgumentException expected\");\n+            Assert.fail(\"y is null (asymptotic), IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomGenerator;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n  * Test cases for NaturalRanking class\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n-public class NaturalRankingTest extends TestCase {\n+public class NaturalRankingTest {\n \n     private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50,\n             Double.NaN, Double.NEGATIVE_INFINITY, 17 };\n     private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 };\n     private final double[] allSame = { 0, 0, 0, 0 };\n \n-    public NaturalRankingTest(String arg0) {\n-        super(arg0);\n-    }\n-\n-    @Override\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-    }\n-\n-    @Override\n-    protected void tearDown() throws Exception {\n-        super.tearDown();\n-    }\n-\n+    @Test\n     public void testDefault() { // Ties averaged, NaNs maximal\n         NaturalRanking ranking = new NaturalRanking();\n         double[] ranks = ranking.rank(exampleData);\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n \n+    @Test\n     public void testNaNsMaximalTiesMinimum() {\n         NaturalRanking ranking = new NaturalRanking(TiesStrategy.MINIMUM);\n         double[] ranks = ranking.rank(exampleData);\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n \n+    @Test\n     public void testNaNsRemovedTiesSequential() {\n         NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED,\n                 TiesStrategy.SEQUENTIAL);\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n \n+    @Test\n     public void testNaNsMinimalTiesMaximum() {\n         NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,\n                 TiesStrategy.MAXIMUM);\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n \n+    @Test\n     public void testNaNsMinimalTiesAverage() {\n         NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);\n         double[] ranks = ranking.rank(exampleData);\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n \n+    @Test\n     public void testNaNsFixedTiesRandom() {\n         RandomGenerator randomGenerator = new JDKRandomGenerator();\n         randomGenerator.setSeed(1000);\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n \n+    @Test\n     public void testNaNsAndInfs() {\n         double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN,\n                 Double.NEGATIVE_INFINITY };\n--- a/src/test/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n  */\n package org.apache.commons.math.stat.regression;\n \n-import static org.junit.Assert.assertEquals;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.apache.commons.math.TestUtils;\n         RealMatrix combinedCovInv = regression.getOmegaInverse();\n         regression.newXSampleData(x);\n         regression.newYSampleData(y);\n-        assertEquals(combinedX, regression.X);\n-        assertEquals(combinedY, regression.Y);\n-        assertEquals(combinedCovInv, regression.getOmegaInverse());\n+        Assert.assertEquals(combinedX, regression.X);\n+        Assert.assertEquals(combinedY, regression.Y);\n+        Assert.assertEquals(combinedCovInv, regression.getOmegaInverse());\n     }\n     \n     /**\n--- a/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n \n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n \n     @Test\n     public void canEstimateRegressionParameters(){\n         double[] beta = regression.estimateRegressionParameters();\n-        assertEquals(getNumberOfRegressors(), beta.length);\n+        Assert.assertEquals(getNumberOfRegressors(), beta.length);\n     }\n \n     @Test\n     public void canEstimateResiduals(){\n         double[] e = regression.estimateResiduals();\n-        assertEquals(getSampleSize(), e.length);\n+        Assert.assertEquals(getSampleSize(), e.length);\n     }\n \n     @Test\n     public void canEstimateRegressionParametersVariance(){\n         double[][] variance = regression.estimateRegressionParametersVariance();\n-        assertEquals(getNumberOfRegressors(), variance.length);\n+        Assert.assertEquals(getNumberOfRegressors(), variance.length);\n     }\n \n     @Test\n     public void canEstimateRegressandVariance(){\n         if (getSampleSize() > getNumberOfRegressors()) {\n             double variance = regression.estimateRegressandVariance();\n-            assertTrue(variance > 0.0);\n+            Assert.assertTrue(variance > 0.0);\n         }\n     }\n     \n         RealVector flatY = regression.Y.copy();\n         regression.newXSampleData(x);\n         regression.newYSampleData(y);\n-        assertEquals(flatX, regression.X);\n-        assertEquals(flatY, regression.Y);\n+        Assert.assertEquals(flatX, regression.X);\n+        Assert.assertEquals(flatY, regression.Y);\n         \n         // No intercept\n         regression.setNoIntercept(true);\n         flatY = regression.Y.copy();\n         regression.newXSampleData(x);\n         regression.newYSampleData(y);\n-        assertEquals(flatX, regression.X);\n-        assertEquals(flatY, regression.Y);\n+        Assert.assertEquals(flatX, regression.X);\n+        Assert.assertEquals(flatY, regression.Y);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n--- a/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n  */\n package org.apache.commons.math.stat.regression;\n \n-import static org.junit.Assert.assertEquals;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.stat.StatUtils;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n \n                 return (row == column) ? 2 * x : x;\n             }\n         });\n-       assertEquals(0.0,\n+       Assert.assertEquals(0.0,\n                      errors.subtract(referenceVariance).getNorm(),\n                      5.0e-16 * referenceVariance.getNorm());\n-       assertEquals(1, ((OLSMultipleLinearRegression) regression).calculateRSquared(), 1E-12);\n+       Assert.assertEquals(1, ((OLSMultipleLinearRegression) regression).calculateRSquared(), 1E-12);\n     }\n \n \n                        455.478499142212}, errors, 1E-6);\n         \n         // Check regression standard error against R\n-        assertEquals(304.8540735619638, model.estimateRegressionStandardError(), 1E-10);\n+        Assert.assertEquals(304.8540735619638, model.estimateRegressionStandardError(), 1E-10);\n         \n         // Check R-Square statistics against R\n-        assertEquals(0.995479004577296, model.calculateRSquared(), 1E-12);\n-        assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12);\n+        Assert.assertEquals(0.995479004577296, model.calculateRSquared(), 1E-12);\n+        Assert.assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12);\n         \n         checkVarianceConsistency(model);\n         \n                       1E-10);\n         \n         // Check regression standard error against R\n-        assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10);\n+        Assert.assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10);\n         \n         // Check R-Square statistics against R\n-        assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12);\n-        assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12);\n+        Assert.assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12);\n+        Assert.assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12);\n          \n     }\n \n                 0.03726654773803}, errors, 1E-10);\n         \n         // Check regression standard error against R\n-        assertEquals(7.73642194433223, model.estimateRegressionStandardError(), 1E-12);\n+        Assert.assertEquals(7.73642194433223, model.estimateRegressionStandardError(), 1E-12);\n         \n         // Check R-Square statistics against R\n-        assertEquals(0.649789742860228, model.calculateRSquared(), 1E-12);\n-        assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12);\n+        Assert.assertEquals(0.649789742860228, model.calculateRSquared(), 1E-12);\n+        Assert.assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12);\n         \n         checkVarianceConsistency(model);\n         \n                 0.43370143099691, 0.07694953606522}, errors, 1E-10);\n         \n         // Check regression standard error against R\n-        assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10);\n+        Assert.assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10);\n         \n         // Check R-Square statistics against R\n-        assertEquals(0.946350722085, model.calculateRSquared(), 1E-12);\n-        assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12);\n+        Assert.assertEquals(0.946350722085, model.calculateRSquared(), 1E-12);\n+        Assert.assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12);\n     }\n \n     /**\n         int k = 0;\n         for (int i = 0; i < 10; i++) {\n             for (int j = i; j < 10; j++) {\n-                assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);\n-                assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);\n+                Assert.assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);\n+                Assert.assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);\n                 k++;\n             }\n         }\n         RealVector combinedY = regression.Y.copy();\n         regression.newXSampleData(x);\n         regression.newYSampleData(y);\n-        assertEquals(combinedX, regression.X);\n-        assertEquals(combinedY, regression.Y);\n+        Assert.assertEquals(combinedX, regression.X);\n+        Assert.assertEquals(combinedY, regression.Y);\n         \n         // No intercept\n         regression.setNoIntercept(true);\n         combinedY = regression.Y.copy();\n         regression.newXSampleData(x);\n         regression.newYSampleData(y);\n-        assertEquals(combinedX, regression.X);\n-        assertEquals(combinedY, regression.Y);\n+        Assert.assertEquals(combinedX, regression.X);\n+        Assert.assertEquals(combinedY, regression.Y);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n--- a/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n import java.util.Random;\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the TestStatistic class.\n  * @version $Revision$ $Date$\n  */\n \n-public final class SimpleRegressionTest extends TestCase {\n+public final class SimpleRegressionTest {\n \n     /*\n      * NIST \"Norris\" refernce data set from\n             {5, -1 }, {6, 12 }\n     };\n \n-    public SimpleRegressionTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testNorris() {\n         SimpleRegression regression = new SimpleRegression();\n         for (int i = 0; i < data.length; i++) {\n         }\n         // Tests against certified values from\n         // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n-        assertEquals(\"slope\", 1.00211681802045, regression.getSlope(), 10E-12);\n-        assertEquals(\"slope std err\", 0.429796848199937E-03,\n+        Assert.assertEquals(\"slope\", 1.00211681802045, regression.getSlope(), 10E-12);\n+        Assert.assertEquals(\"slope std err\", 0.429796848199937E-03,\n                 regression.getSlopeStdErr(),10E-12);\n-        assertEquals(\"number of observations\", 36, regression.getN());\n-        assertEquals( \"intercept\", -0.262323073774029,\n+        Assert.assertEquals(\"number of observations\", 36, regression.getN());\n+        Assert.assertEquals( \"intercept\", -0.262323073774029,\n             regression.getIntercept(),10E-12);\n-        assertEquals(\"std err intercept\", 0.232818234301152,\n+        Assert.assertEquals(\"std err intercept\", 0.232818234301152,\n             regression.getInterceptStdErr(),10E-12);\n-        assertEquals(\"r-square\", 0.999993745883712,\n+        Assert.assertEquals(\"r-square\", 0.999993745883712,\n             regression.getRSquare(), 10E-12);\n-        assertEquals(\"SSR\", 4255954.13232369,\n+        Assert.assertEquals(\"SSR\", 4255954.13232369,\n             regression.getRegressionSumSquares(), 10E-9);\n-        assertEquals(\"MSE\", 0.782864662630069,\n+        Assert.assertEquals(\"MSE\", 0.782864662630069,\n             regression.getMeanSquareError(), 10E-10);\n-        assertEquals(\"SSE\", 26.6173985294224,\n+        Assert.assertEquals(\"SSE\", 26.6173985294224,\n             regression.getSumSquaredErrors(),10E-9);\n         // ------------  End certified data tests\n \n-        assertEquals( \"predict(0)\",  -0.262323073774029,\n+        Assert.assertEquals( \"predict(0)\",  -0.262323073774029,\n             regression.predict(0), 10E-12);\n-        assertEquals(\"predict(1)\", 1.00211681802045 - 0.262323073774029,\n+        Assert.assertEquals(\"predict(1)\", 1.00211681802045 - 0.262323073774029,\n             regression.predict(1), 10E-12);\n     }\n \n+    @Test\n     public void testCorr() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.addData(corrData);\n-        assertEquals(\"number of observations\", 17, regression.getN());\n-        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n-        assertEquals(\"r\", -0.94663767742, regression.getR(), 1E-10);\n-    }\n-\n+        Assert.assertEquals(\"number of observations\", 17, regression.getN());\n+        Assert.assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        Assert.assertEquals(\"r\", -0.94663767742, regression.getR(), 1E-10);\n+    }\n+\n+    @Test\n     public void testNaNs() {\n         SimpleRegression regression = new SimpleRegression();\n-        assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n-        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n-        assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n-        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n-        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n-        assertTrue( \"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n-        assertTrue(\"SSE not NaN\",Double.isNaN(regression.getSumSquaredErrors()));\n-        assertTrue(\"SSTO not NaN\", Double.isNaN(regression.getTotalSumSquares()));\n-        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+        Assert.assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n+        Assert.assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        Assert.assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        Assert.assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        Assert.assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        Assert.assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        Assert.assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        Assert.assertTrue( \"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n+        Assert.assertTrue(\"SSE not NaN\",Double.isNaN(regression.getSumSquaredErrors()));\n+        Assert.assertTrue(\"SSTO not NaN\", Double.isNaN(regression.getTotalSumSquares()));\n+        Assert.assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n \n         regression.addData(1, 2);\n         regression.addData(1, 3);\n \n         // No x variation, so these should still blow...\n-        assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n-        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n-        assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n-        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n-        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n-        assertTrue(\"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n-        assertTrue(\"SSE not NaN\", Double.isNaN(regression.getSumSquaredErrors()));\n-        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+        Assert.assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n+        Assert.assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        Assert.assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        Assert.assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        Assert.assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        Assert.assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        Assert.assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        Assert.assertTrue(\"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n+        Assert.assertTrue(\"SSE not NaN\", Double.isNaN(regression.getSumSquaredErrors()));\n+        Assert.assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n \n         // but SSTO should be OK\n-        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+        Assert.assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n \n         regression = new SimpleRegression();\n \n         regression.addData(3, 3);\n \n         // All should be OK except MSE, s(b0), s(b1) which need one more df\n-        assertTrue(\"interceptNaN\", !Double.isNaN(regression.getIntercept()));\n-        assertTrue(\"slope NaN\", !Double.isNaN(regression.getSlope()));\n-        assertTrue (\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n-        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"r NaN\", !Double.isNaN(regression.getR()));\n-        assertTrue(\"r-square NaN\", !Double.isNaN(regression.getRSquare()));\n-        assertTrue(\"RSS NaN\", !Double.isNaN(regression.getRegressionSumSquares()));\n-        assertTrue(\"SSE NaN\", !Double.isNaN(regression.getSumSquaredErrors()));\n-        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n-        assertTrue(\"predict NaN\", !Double.isNaN(regression.predict(0)));\n+        Assert.assertTrue(\"interceptNaN\", !Double.isNaN(regression.getIntercept()));\n+        Assert.assertTrue(\"slope NaN\", !Double.isNaN(regression.getSlope()));\n+        Assert.assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        Assert.assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        Assert.assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        Assert.assertTrue(\"r NaN\", !Double.isNaN(regression.getR()));\n+        Assert.assertTrue(\"r-square NaN\", !Double.isNaN(regression.getRSquare()));\n+        Assert.assertTrue(\"RSS NaN\", !Double.isNaN(regression.getRegressionSumSquares()));\n+        Assert.assertTrue(\"SSE NaN\", !Double.isNaN(regression.getSumSquaredErrors()));\n+        Assert.assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+        Assert.assertTrue(\"predict NaN\", !Double.isNaN(regression.predict(0)));\n \n         regression.addData(1, 4);\n \n         // MSE, MSE, s(b0), s(b1) should all be OK now\n-        assertTrue(\"MSE NaN\", !Double.isNaN(regression.getMeanSquareError()));\n-        assertTrue(\"slope std err NaN\", !Double.isNaN(regression.getSlopeStdErr()));\n-        assertTrue(\"intercept std err NaN\", !Double.isNaN(regression.getInterceptStdErr()));\n-    }\n-\n+        Assert.assertTrue(\"MSE NaN\", !Double.isNaN(regression.getMeanSquareError()));\n+        Assert.assertTrue(\"slope std err NaN\", !Double.isNaN(regression.getSlopeStdErr()));\n+        Assert.assertTrue(\"intercept std err NaN\", !Double.isNaN(regression.getInterceptStdErr()));\n+    }\n+\n+    @Test\n     public void testClear() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.addData(corrData);\n-        assertEquals(\"number of observations\", 17, regression.getN());\n+        Assert.assertEquals(\"number of observations\", 17, regression.getN());\n         regression.clear();\n-        assertEquals(\"number of observations\", 0, regression.getN());\n+        Assert.assertEquals(\"number of observations\", 0, regression.getN());\n         regression.addData(corrData);\n-        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        Assert.assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n         regression.addData(data);\n-        assertEquals(\"number of observations\", 53, regression.getN());\n-    }\n-\n+        Assert.assertEquals(\"number of observations\", 53, regression.getN());\n+    }\n+\n+    @Test\n     public void testInference() throws Exception {\n         //----------  verified against R, version 1.8.1 -----\n         // infData\n         SimpleRegression regression = new SimpleRegression();\n         regression.addData(infData);\n-        assertEquals(\"slope std err\", 0.011448491,\n+        Assert.assertEquals(\"slope std err\", 0.011448491,\n                 regression.getSlopeStdErr(), 1E-10);\n-        assertEquals(\"std err intercept\", 0.286036932,\n-                regression.getInterceptStdErr(),1E-8);\n-        assertEquals(\"significance\", 4.596e-07,\n+        Assert.assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        Assert.assertEquals(\"significance\", 4.596e-07,\n                 regression.getSignificance(),1E-8);\n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n+        Assert.assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n         // infData2\n         regression = new SimpleRegression();\n         regression.addData(infData2);\n-        assertEquals(\"slope std err\", 1.07260253,\n+        Assert.assertEquals(\"slope std err\", 1.07260253,\n                 regression.getSlopeStdErr(), 1E-8);\n-        assertEquals(\"std err intercept\",4.17718672,\n-                regression.getInterceptStdErr(),1E-8);\n-        assertEquals(\"significance\", 0.261829133982,\n+        Assert.assertEquals(\"std err intercept\",4.17718672,\n+                regression.getInterceptStdErr(),1E-8);\n+        Assert.assertEquals(\"significance\", 0.261829133982,\n                 regression.getSignificance(),1E-11);\n-        assertEquals(\"slope conf interval half-width\", 2.97802204827,\n+        Assert.assertEquals(\"slope conf interval half-width\", 2.97802204827,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n         //------------- End R-verified tests -------------------------------\n \n         //FIXME: get a real example to test against with alpha = .01\n-        assertTrue(\"tighter means wider\",\n+        Assert.assertTrue(\"tighter means wider\",\n                 regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));\n \n         try {\n             regression.getSlopeConfidenceInterval(1);\n-            fail(\"expecting MathIllegalArgumentException for alpha = 1\");\n+            Assert.fail(\"expecting MathIllegalArgumentException for alpha = 1\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n     }\n \n+    @Test\n     public void testPerfect() throws Exception {\n         SimpleRegression regression = new SimpleRegression();\n         int n = 100;\n         for (int i = 0; i < n; i++) {\n             regression.addData(((double) i) / (n - 1), i);\n         }\n-        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n-        assertTrue(regression.getSlope() > 0.0);\n-        assertTrue(regression.getSumSquaredErrors() >= 0.0);\n-    }\n-\n+        Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+        Assert.assertTrue(regression.getSlope() > 0.0);\n+        Assert.assertTrue(regression.getSumSquaredErrors() >= 0.0);\n+    }\n+\n+    @Test\n     public void testPerfectNegative() throws Exception {\n         SimpleRegression regression = new SimpleRegression();\n         int n = 100;\n             regression.addData(- ((double) i) / (n - 1), i);\n         }\n \n-        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n-        assertTrue(regression.getSlope() < 0.0);\n-    }\n-\n+        Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+        Assert.assertTrue(regression.getSlope() < 0.0);\n+    }\n+\n+    @Test\n     public void testRandom() throws Exception {\n         SimpleRegression regression = new SimpleRegression();\n         Random random = new Random(1);\n             regression.addData(((double) i) / (n - 1), random.nextDouble());\n         }\n \n-        assertTrue( 0.0 < regression.getSignificance()\n+        Assert.assertTrue( 0.0 < regression.getSignificance()\n                     && regression.getSignificance() < 1.0);\n     }\n \n \n     // Jira MATH-85 = Bugzilla 39432\n+    @Test\n     public void testSSENonNegative() {\n         double[] y = { 8915.102, 8919.302, 8923.502 };\n         double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };\n         for (int i = 0; i < x.length; i++) {\n             reg.addData(x[i], y[i]);\n         }\n-        assertTrue(reg.getSumSquaredErrors() >= 0.0);\n+        Assert.assertTrue(reg.getSumSquaredErrors() >= 0.0);\n     }\n \n     // Test remove X,Y (single observation)\n+    @Test\n     public void testRemoveXY() throws Exception {\n         // Create regression with inference data then remove to test\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeX, removeY);\n         regression.addData(removeX, removeY);\n         // Use the inference assertions to make sure that everything worked\n-        assertEquals(\"slope std err\", 0.011448491,\n+        Assert.assertEquals(\"slope std err\", 0.011448491,\n                 regression.getSlopeStdErr(), 1E-10);\n-        assertEquals(\"std err intercept\", 0.286036932,\n-                regression.getInterceptStdErr(),1E-8);\n-        assertEquals(\"significance\", 4.596e-07,\n+        Assert.assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        Assert.assertEquals(\"significance\", 4.596e-07,\n                 regression.getSignificance(),1E-8);\n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n+        Assert.assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n      }\n \n \n     // Test remove single observation in array\n+    @Test\n     public void testRemoveSingle() throws Exception {\n         // Create regression with inference data then remove to test\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeSingle);\n         regression.addData(removeSingle);\n         // Use the inference assertions to make sure that everything worked\n-        assertEquals(\"slope std err\", 0.011448491,\n+        Assert.assertEquals(\"slope std err\", 0.011448491,\n                 regression.getSlopeStdErr(), 1E-10);\n-        assertEquals(\"std err intercept\", 0.286036932,\n-                regression.getInterceptStdErr(),1E-8);\n-        assertEquals(\"significance\", 4.596e-07,\n+        Assert.assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        Assert.assertEquals(\"significance\", 4.596e-07,\n                 regression.getSignificance(),1E-8);\n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n+        Assert.assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n      }\n \n     // Test remove multiple observations\n+    @Test\n     public void testRemoveMultiple() throws Exception {\n         // Create regression with inference data then remove to test\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeMultiple);\n         regression.addData(removeMultiple);\n         // Use the inference assertions to make sure that everything worked\n-        assertEquals(\"slope std err\", 0.011448491,\n+        Assert.assertEquals(\"slope std err\", 0.011448491,\n                 regression.getSlopeStdErr(), 1E-10);\n-        assertEquals(\"std err intercept\", 0.286036932,\n-                regression.getInterceptStdErr(),1E-8);\n-        assertEquals(\"significance\", 4.596e-07,\n+        Assert.assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        Assert.assertEquals(\"significance\", 4.596e-07,\n                 regression.getSignificance(),1E-8);\n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n+        Assert.assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n      }\n \n     // Remove observation when empty\n+    @Test\n     public void testRemoveObsFromEmpty() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeX, removeY);\n-        assertEquals(regression.getN(), 0);\n+        Assert.assertEquals(regression.getN(), 0);\n     }\n \n     // Remove single observation to empty\n+    @Test\n     public void testRemoveObsFromSingle() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.addData(removeX, removeY);\n         regression.removeData(removeX, removeY);\n-        assertEquals(regression.getN(), 0);\n+        Assert.assertEquals(regression.getN(), 0);\n     }\n \n     // Remove multiple observations to empty\n+    @Test\n     public void testRemoveMultipleToEmpty() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.addData(removeMultiple);\n         regression.removeData(removeMultiple);\n-        assertEquals(regression.getN(), 0);\n+        Assert.assertEquals(regression.getN(), 0);\n     }\n \n     // Remove multiple observations past empty (i.e. size of array > n)\n+    @Test\n     public void testRemoveMultiplePastEmpty() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.addData(removeX, removeY);\n         regression.removeData(removeMultiple);\n-        assertEquals(regression.getN(), 0);\n+        Assert.assertEquals(regression.getN(), 0);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n \n import org.apache.commons.math.analysis.*;\n import org.apache.commons.math.util.FastMath;\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for fast cosine transformer.\n+ * Test case for fast cosine transformer.\n  * <p>\n  * FCT algorithm is exact, the small tolerance number is used only\n  * to account for round-off errors.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class FastCosineTransformerTest extends TestCase {\n+public final class FastCosineTransformerTest {\n \n     /**\n      * Test of transformer for the ad hoc data.\n      */\n+    @Test\n     public void testAdHocData() {\n         FastCosineTransformer transformer = new FastCosineTransformer();\n         double result[], tolerance = 1E-12;\n \n         result = transformer.transform(x);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(y[i], result[i], tolerance);\n+            Assert.assertEquals(y[i], result[i], tolerance);\n         }\n \n         result = transformer.inversetransform(y);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(x[i], result[i], tolerance);\n+            Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n         FastFourierTransformer.scaleArray(x, FastMath.sqrt(0.5 * (x.length-1)));\n \n         result = transformer.transform2(y);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(x[i], result[i], tolerance);\n+            Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n         result = transformer.inversetransform2(x);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(y[i], result[i], tolerance);\n+            Assert.assertEquals(y[i], result[i], tolerance);\n         }\n     }\n \n     /**\n      * Test of transformer for the sine function.\n      */\n+    @Test\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         FastCosineTransformer transformer = new FastCosineTransformer();\n         min = 0.0; max = 2.0 * FastMath.PI * N / (N-1);\n         result = transformer.transform(f, min, max, N);\n         for (int i = 0; i < N; i++) {\n-            assertEquals(expected[i], result[i], tolerance);\n+            Assert.assertEquals(expected[i], result[i], tolerance);\n         }\n \n         min = -FastMath.PI; max = FastMath.PI * (N+1) / (N-1);\n         result = transformer.transform(f, min, max, N);\n         for (int i = 0; i < N; i++) {\n-            assertEquals(-expected[i], result[i], tolerance);\n+            Assert.assertEquals(-expected[i], result[i], tolerance);\n         }\n     }\n \n     /**\n      * Test of parameters for the transformer.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         FastCosineTransformer transformer = new FastCosineTransformer();\n         try {\n             // bad interval\n             transformer.transform(f, 1, -1, 65);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 64);\n-            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n import org.apache.commons.math.analysis.*;\n import org.apache.commons.math.complex.*;\n import org.apache.commons.math.util.FastMath;\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for fast Fourier transformer.\n+ * Test case for fast Fourier transformer.\n  * <p>\n  * FFT algorithm is exact, the small tolerance number is used only\n  * to account for round-off errors.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class FastFourierTransformerTest extends TestCase {\n+public final class FastFourierTransformerTest {\n \n     /**\n      * Test of transformer for the ad hoc data taken from Mathematica.\n      */\n+    @Test\n     public void testAdHocData() {\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         Complex result[]; double tolerance = 1E-12;\n \n         result = transformer.transform(x);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(y[i].getReal(), result[i].getReal(), tolerance);\n-            assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);\n+            Assert.assertEquals(y[i].getReal(), result[i].getReal(), tolerance);\n+            Assert.assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);\n         }\n \n         result = transformer.inversetransform(y);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(x[i], result[i].getReal(), tolerance);\n-            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+            Assert.assertEquals(x[i], result[i].getReal(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n         }\n \n         double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};\n \n         result = transformer.transform2(y2);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(x2[i], result[i].getReal(), tolerance);\n-            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+            Assert.assertEquals(x2[i], result[i].getReal(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n         }\n \n         result = transformer.inversetransform2(x2);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);\n-            assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n+            Assert.assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);\n+            Assert.assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n         }\n     }\n \n+    @Test\n     public void test2DData() {\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         double tolerance = 1E-12;\n         Complex[][] output = (Complex[][])transformer.mdfft(input, true);\n         Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);\n \n-        assertEquals(input.length, output.length);\n-        assertEquals(input.length, output2.length);\n-        assertEquals(input[0].length, output[0].length);\n-        assertEquals(input[0].length, output2[0].length);\n-        assertEquals(input[1].length, output[1].length);\n-        assertEquals(input[1].length, output2[1].length);\n+        Assert.assertEquals(input.length, output.length);\n+        Assert.assertEquals(input.length, output2.length);\n+        Assert.assertEquals(input[0].length, output[0].length);\n+        Assert.assertEquals(input[0].length, output2[0].length);\n+        Assert.assertEquals(input[1].length, output[1].length);\n+        Assert.assertEquals(input[1].length, output2[1].length);\n \n         for (int i = 0; i < input.length; i++) {\n             for (int j = 0; j < input[0].length; j++) {\n-                assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n+                Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n                              tolerance);\n-                assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n-                assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),\n+                Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n+                Assert.assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),\n                              tolerance);\n-                assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);\n+                Assert.assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);\n             }\n         }\n     }\n     /**\n      * Test of transformer for the sine function.\n      */\n+    @Test\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         FastFourierTransformer transformer = new FastFourierTransformer();\n \n         min = 0.0; max = 2.0 * FastMath.PI;\n         result = transformer.transform(f, min, max, N);\n-        assertEquals(0.0, result[1].getReal(), tolerance);\n-        assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n-        assertEquals(0.0, result[N-1].getReal(), tolerance);\n-        assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);\n+        Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n+        Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n+        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        Assert.assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);\n         for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n-            assertEquals(0.0, result[i].getReal(), tolerance);\n-            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getReal(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n         }\n \n         min = -FastMath.PI; max = FastMath.PI;\n         result = transformer.inversetransform(f, min, max, N);\n-        assertEquals(0.0, result[1].getReal(), tolerance);\n-        assertEquals(-0.5, result[1].getImaginary(), tolerance);\n-        assertEquals(0.0, result[N-1].getReal(), tolerance);\n-        assertEquals(0.5, result[N-1].getImaginary(), tolerance);\n+        Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n+        Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance);\n+        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        Assert.assertEquals(0.5, result[N-1].getImaginary(), tolerance);\n         for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n-            assertEquals(0.0, result[i].getReal(), tolerance);\n-            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getReal(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n         }\n     }\n \n     /**\n      * Test of parameters for the transformer.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         try {\n             // bad interval\n             transformer.transform(f, 1, -1, 64);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 0);\n-            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 100);\n-            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n  */\n package org.apache.commons.math.transform;\n \n-import junit.framework.TestCase;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * JUnit Test for HadamardTransformerTest\n  * @see org.apache.commons.math.transform.FastHadamardTransformer\n  */\n-public final class FastHadamardTransformerTest extends TestCase {\n+public final class FastHadamardTransformerTest {\n \n     /**\n      * Test of transformer for the a 8-point FHT (means n=8)\n      */\n+    @Test\n     public void test8Points() {\n         checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },\n                        new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });\n     /**\n      * Test of transformer for the a 4-points FHT (means n=4)\n      */\n+    @Test\n     public void test4Points() {\n         checkAllTransforms(new int[] { 1, 2, 3, 4 },\n                            new int[] { 10, -2, -4, 0 });\n     /**\n      * Test the inverse transform of an integer vector is not always an integer vector\n      */\n+    @Test\n     public void testNoIntInverse() {\n         FastHadamardTransformer transformer = new FastHadamardTransformer();\n         double[] x = transformer.inversetransform(new double[] { 0, 1, 0, 1});\n-        assertEquals( 0.5, x[0], 0);\n-        assertEquals(-0.5, x[1], 0);\n-        assertEquals( 0.0, x[2], 0);\n-        assertEquals( 0.0, x[3], 0);\n+        Assert.assertEquals( 0.5, x[0], 0);\n+        Assert.assertEquals(-0.5, x[1], 0);\n+        Assert.assertEquals( 0.0, x[2], 0);\n+        Assert.assertEquals( 0.0, x[3], 0);\n     }\n \n     /**\n      * Test of transformer for wrong number of points\n      */\n+    @Test\n     public void test3Points() {\n         try {\n             new FastHadamardTransformer().transform(new double[3]);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected\n         }\n         double dResult[] = transformer.transform(dX);\n         for (int i = 0; i < dResult.length; i++) {\n             // compare computed results to precomputed results\n-            assertEquals((double) y[i], dResult[i]);\n+            Assert.assertTrue(MathUtils.equals((double) y[i], dResult[i], 1));\n         }\n     }\n \n         int iResult[] = transformer.transform(x);\n         for (int i = 0; i < iResult.length; i++) {\n             // compare computed results to precomputed results\n-            assertEquals(y[i], iResult[i]);\n+            Assert.assertEquals(y[i], iResult[i]);\n         }\n \n     }\n         double dResult[] = transformer.inversetransform(dY);\n         for (int i = 0; i < dResult.length; i++) {\n             // compare computed results to precomputed results\n-            assertEquals((double) x[i], dResult[i]);\n+            Assert.assertTrue(MathUtils.equals((double) x[i], dResult[i], 1));\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n \n import org.apache.commons.math.analysis.*;\n import org.apache.commons.math.util.FastMath;\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for fast sine transformer.\n+ * Test case for fast sine transformer.\n  * <p>\n  * FST algorithm is exact, the small tolerance number is used only\n  * to account for round-off errors.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class FastSineTransformerTest extends TestCase {\n+public final class FastSineTransformerTest {\n \n     /**\n      * Test of transformer for the ad hoc data.\n      */\n+    @Test\n     public void testAdHocData() {\n         FastSineTransformer transformer = new FastSineTransformer();\n         double result[], tolerance = 1E-12;\n \n         result = transformer.transform(x);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(y[i], result[i], tolerance);\n+            Assert.assertEquals(y[i], result[i], tolerance);\n         }\n \n         result = transformer.inversetransform(y);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(x[i], result[i], tolerance);\n+            Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n         FastFourierTransformer.scaleArray(x, FastMath.sqrt(x.length / 2.0));\n \n         result = transformer.transform2(y);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(x[i], result[i], tolerance);\n+            Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n         result = transformer.inversetransform2(x);\n         for (int i = 0; i < result.length; i++) {\n-            assertEquals(y[i], result[i], tolerance);\n+            Assert.assertEquals(y[i], result[i], tolerance);\n         }\n     }\n \n     /**\n      * Test of transformer for the sine function.\n      */\n+    @Test\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         FastSineTransformer transformer = new FastSineTransformer();\n \n         min = 0.0; max = 2.0 * FastMath.PI;\n         result = transformer.transform(f, min, max, N);\n-        assertEquals(N >> 1, result[2], tolerance);\n+        Assert.assertEquals(N >> 1, result[2], tolerance);\n         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n-            assertEquals(0.0, result[i], tolerance);\n+            Assert.assertEquals(0.0, result[i], tolerance);\n         }\n \n         min = -FastMath.PI; max = FastMath.PI;\n         result = transformer.transform(f, min, max, N);\n-        assertEquals(-(N >> 1), result[2], tolerance);\n+        Assert.assertEquals(-(N >> 1), result[2], tolerance);\n         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n-            assertEquals(0.0, result[i], tolerance);\n+            Assert.assertEquals(0.0, result[i], tolerance);\n         }\n     }\n \n     /**\n      * Test of parameters for the transformer.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         FastSineTransformer transformer = new FastSineTransformer();\n         try {\n             // bad interval\n             transformer.transform(f, 1, -1, 64);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 0);\n-            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 100);\n-            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/util/BigRealFieldTest.java\n+++ b/src/test/java/org/apache/commons/math/util/BigRealFieldTest.java\n  */\n package org.apache.commons.math.util;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class BigRealFieldTest {\n \n     @Test\n     public void testZero() {\n-        assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero());\n+        Assert.assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero());\n     }\n \n     @Test\n     public void testOne() {\n-        assertEquals(BigReal.ONE, BigRealField.getInstance().getOne());\n+        Assert.assertEquals(BigReal.ONE, BigRealField.getInstance().getOne());\n     }\n \n     @Test\n     public void testSerial() {\n         // deserializing the singleton should give the singleton itself back\n         BigRealField field = BigRealField.getInstance();\n-        assertTrue(field == TestUtils.serializeAndRecover(field));\n+        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/util/BigRealTest.java\n+++ b/src/test/java/org/apache/commons/math/util/BigRealTest.java\n  */\n package org.apache.commons.math.util;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.math.MathContext;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class BigRealTest {\n \n     @Test\n     public void testConstructor() {\n-        assertEquals(1.625, new BigReal(new BigDecimal(\"1.625\")).doubleValue(), 1.0e-15);\n-        assertEquals(-5.0, new BigReal(new BigInteger(\"-5\")).doubleValue(), 1.0e-15);\n-        assertEquals(-5.0, new BigReal(new BigInteger(\"-5\"), MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(0.125, new BigReal(new BigInteger(\"125\"), 3).doubleValue(), 1.0e-15);\n-        assertEquals(0.125, new BigReal(new BigInteger(\"125\"), 3, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15);\n-        assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15);\n-        assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(\"1.625\").doubleValue(), 1.0e-15);\n-        assertEquals(1.625, new BigReal(\"1.625\", MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(new BigDecimal(\"1.625\")).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(-5.0, new BigReal(new BigInteger(\"-5\")).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(-5.0, new BigReal(new BigInteger(\"-5\"), MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(0.125, new BigReal(new BigInteger(\"125\"), 3).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(0.125, new BigReal(new BigInteger(\"125\"), 3, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(\"1.625\").doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.625, new BigReal(\"1.625\", MathContext.DECIMAL64).doubleValue(), 1.0e-15);\n     }\n \n     @Test\n         BigReal second = new BigReal(1.0 / 3.0);\n         BigReal third = new BigReal(1.0 / 2.0);\n \n-        assertEquals(0, first.compareTo(first));\n-        assertEquals(0, first.compareTo(third));\n-        assertEquals(1, first.compareTo(second));\n-        assertEquals(-1, second.compareTo(first));\n+        Assert.assertEquals(0, first.compareTo(first));\n+        Assert.assertEquals(0, first.compareTo(third));\n+        Assert.assertEquals(1, first.compareTo(second));\n+        Assert.assertEquals(-1, second.compareTo(first));\n \n     }\n \n+    @Test\n     public void testAdd() {\n         BigReal a = new BigReal(\"1.2345678\");\n         BigReal b = new BigReal(\"8.7654321\");\n-        assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15);\n     }\n \n+    @Test\n     public void testSubtract() {\n         BigReal a = new BigReal(\"1.2345678\");\n         BigReal b = new BigReal(\"8.7654321\");\n-        assertEquals( -7.5308643, a.subtract(b).doubleValue(), 1.0e-15);\n+        Assert.assertEquals( -7.5308643, a.subtract(b).doubleValue(), 1.0e-15);\n     }\n \n+    @Test\n     public void testDivide() {\n         BigReal a = new BigReal(\"1.0000000000\");\n         BigReal b = new BigReal(\"0.0009765625\");\n-        assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15);\n     }\n \n+    @Test\n     public void testMultiply() {\n         BigReal a = new BigReal(\"1024.0\");\n         BigReal b = new BigReal(\"0.0009765625\");\n-        assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);\n     }\n \n     @Test\n     public void testDoubleValue() {\n-        assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15);\n+        Assert.assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15);\n     }\n \n     @Test\n     public void testBigDecimalValue() {\n         BigDecimal pi = new BigDecimal(\"3.1415926535897932384626433832795028841971693993751\");\n-        assertEquals(pi, new BigReal(pi).bigDecimalValue());\n-        assertEquals(new BigDecimal(0.5), new BigReal(1.0 / 2.0).bigDecimalValue());\n+        Assert.assertEquals(pi, new BigReal(pi).bigDecimalValue());\n+        Assert.assertEquals(new BigDecimal(0.5), new BigReal(1.0 / 2.0).bigDecimalValue());\n     }\n \n     @Test\n     public void testEqualsAndHashCode() {\n         BigReal zero = new BigReal(0.0);\n         BigReal nullReal = null;\n-        assertTrue(zero.equals(zero));\n-        assertFalse(zero.equals(nullReal));\n-        assertFalse(zero.equals(Double.valueOf(0)));\n+        Assert.assertTrue(zero.equals(zero));\n+        Assert.assertFalse(zero.equals(nullReal));\n+        Assert.assertFalse(zero.equals(Double.valueOf(0)));\n         BigReal zero2 = new BigReal(0.0);\n-        assertTrue(zero.equals(zero2));\n-        assertEquals(zero.hashCode(), zero2.hashCode());\n+        Assert.assertTrue(zero.equals(zero2));\n+        Assert.assertEquals(zero.hashCode(), zero2.hashCode());\n         BigReal one = new BigReal(1.0);\n-        assertFalse((one.equals(zero) || zero.equals(one)));\n-        assertTrue(one.equals(BigReal.ONE));\n+        Assert.assertFalse((one.equals(zero) || zero.equals(one)));\n+        Assert.assertTrue(one.equals(BigReal.ONE));\n     }\n \n+    @Test\n     public void testSerial() {\n         BigReal[] Reals = {\n             new BigReal(3.0), BigReal.ONE, BigReal.ZERO,\n             new BigReal(-2.5)\n         };\n         for (BigReal Real : Reals) {\n-            assertEquals(Real, TestUtils.serializeAndRecover(Real));\n+            Assert.assertEquals(Real, TestUtils.serializeAndRecover(Real));\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/util/ContinuedFractionTest.java\n+++ b/src/test/java/org/apache/commons/math/util/ContinuedFractionTest.java\n  */\n package org.apache.commons.math.util;\n \n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class ContinuedFractionTest extends TestCase {\n-    /**\n-     * Constructor for ContinuedFractionTest.\n-     * @param name\n-     */\n-    public ContinuedFractionTest(String name) {\n-        super(name);\n-    }\n+public class ContinuedFractionTest {\n \n+    @Test\n     public void testGoldenRatio() throws Exception {\n         ContinuedFraction cf = new ContinuedFraction() {\n \n         };\n \n         double gr = cf.evaluate(0.0, 10e-9);\n-        assertEquals(1.61803399, gr, 10e-9);\n+        Assert.assertEquals(1.61803399, gr, 10e-9);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/util/DefaultTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/util/DefaultTransformerTest.java\n \n import java.math.BigDecimal;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class DefaultTransformerTest extends TestCase {\n+public class DefaultTransformerTest {\n     /**\n      *\n      */\n+    @Test\n     public void testTransformDouble() throws Exception {\n         double expected = 1.0;\n         Double input = Double.valueOf(expected);\n         DefaultTransformer t = new DefaultTransformer();\n-        assertEquals(expected, t.transform(input), 1.0e-4);\n+        Assert.assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testTransformNull() throws Exception {\n         DefaultTransformer t = new DefaultTransformer();\n         try {\n             t.transform(null);\n-            fail(\"Expecting NullArgumentException\");\n+            Assert.fail(\"Expecting NullArgumentException\");\n         } catch (NullArgumentException e) {\n             // expected\n         }\n     /**\n      *\n      */\n+    @Test\n     public void testTransformInteger() throws Exception {\n         double expected = 1.0;\n         Integer input = Integer.valueOf(1);\n         DefaultTransformer t = new DefaultTransformer();\n-        assertEquals(expected, t.transform(input), 1.0e-4);\n+        Assert.assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testTransformBigDecimal() throws Exception {\n         double expected = 1.0;\n         BigDecimal input = new BigDecimal(\"1.0\");\n         DefaultTransformer t = new DefaultTransformer();\n-        assertEquals(expected, t.transform(input), 1.0e-4);\n+        Assert.assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testTransformString() throws Exception {\n         double expected = 1.0;\n         String input = \"1.0\";\n         DefaultTransformer t = new DefaultTransformer();\n-        assertEquals(expected, t.transform(input), 1.0e-4);\n+        Assert.assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testTransformObject(){\n         Boolean input = Boolean.TRUE;\n         DefaultTransformer t = new DefaultTransformer();\n         try {\n             t.transform(input);\n-            fail(\"Expecting MathException\");\n+            Assert.fail(\"Expecting MathException\");\n         } catch (MathException e) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testSerial() {\n-        assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer()));\n+        Assert.assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n package org.apache.commons.math.util;\n \n import org.apache.commons.math.stat.StatUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n  * This class contains test cases for the ExpandableDoubleArray.\n  *\n  * @version $Revision$ $Date$\n  */\n-public abstract class DoubleArrayAbstractTest extends TestCase {\n+public abstract class DoubleArrayAbstractTest {\n \n     protected DoubleArray da = null;\n \n     // Array used to test rolling\n     protected DoubleArray ra = null;\n \n-    public DoubleArrayAbstractTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testAdd1000() {\n \n         for (int i = 0; i < 1000; i++) {\n             da.addElement(i);\n         }\n \n-        assertEquals(\n+        Assert.assertEquals(\n             \"Number of elements should be equal to 1000 after adding 1000 values\",\n             1000,\n             da.getNumElements());\n \n-        assertEquals(\n+        Assert.assertEquals(\n             \"The element at the 56th index should be 56\",\n             56.0,\n             da.getElement(56),\n \n     }\n \n+    @Test\n     public void testGetValues() {\n         double[] controlArray = { 2.0, 4.0, 6.0 };\n \n         double[] testArray = da.getElements();\n \n         for (int i = 0; i < da.getNumElements(); i++) {\n-            assertEquals(\n+            Assert.assertEquals(\n                 \"The testArray values should equal the controlArray values, index i: \"\n                     + i\n                     + \" does not match\",\n \n     }\n \n+    @Test\n     public void testAddElementRolling() {\n         ra.addElement(0.5);\n         ra.addElement(1.0);\n         ra.addElement(1.0);\n         ra.addElementRolling(2.0);\n \n-        assertEquals(\n+        Assert.assertEquals(\n             \"There should be 6 elements in the eda\",\n             6,\n             ra.getNumElements());\n-        assertEquals(\n+        Assert.assertEquals(\n             \"The max element should be 2.0\",\n             2.0,\n             StatUtils.max(ra.getElements()),\n             Double.MIN_VALUE);\n-        assertEquals(\n+        Assert.assertEquals(\n             \"The min element should be 1.0\",\n             1.0,\n             StatUtils.min(ra.getElements()),\n             ra.addElementRolling(i);\n         }\n \n-        assertEquals(\n+        Assert.assertEquals(\n             \"We just inserted 1024 rolling elements, num elements should still be 6\",\n             6,\n             ra.getNumElements());\n     }\n \n+    @Test\n     public void testMinMax() {\n         da.addElement(2.0);\n         da.addElement(22.0);\n         da.addElement(122.0);\n         da.addElement(1212.0);\n \n-        assertEquals(\"Min should be -2.0\", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);\n-        assertEquals(\n+        Assert.assertEquals(\"Min should be -2.0\", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);\n+        Assert.assertEquals(\n             \"Max should be 1212.0\",\n             1212.0,\n             StatUtils.max(da.getElements()),\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n import java.util.List;\n import java.util.Map;\n \n-import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.NonMonotonousSequenceException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the MathUtils class.\n  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n-public final class MathUtilsTest extends TestCase {\n-\n-    public MathUtilsTest(String name) {\n-        super(name);\n-    }\n+public final class MathUtilsTest {\n \n     /** cached binomial coefficients */\n     private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n     }\n \n     /** Verify that b(0,0) = 1 */\n+    @Test\n     public void test0Choose0() {\n-        assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n-        assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);\n-        assertEquals(MathUtils.binomialCoefficient(0, 0), 1);\n-    }\n-\n+        Assert.assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n+        Assert.assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);\n+        Assert.assertEquals(MathUtils.binomialCoefficient(0, 0), 1);\n+    }\n+\n+    @Test\n     public void testAddAndCheck() {\n         int big = Integer.MAX_VALUE;\n         int bigNeg = Integer.MIN_VALUE;\n-        assertEquals(big, MathUtils.addAndCheck(big, 0));\n+        Assert.assertEquals(big, MathUtils.addAndCheck(big, 0));\n         try {\n             MathUtils.addAndCheck(big, 1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n         }\n         try {\n             MathUtils.addAndCheck(bigNeg, -1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n         }\n     }\n \n+    @Test\n     public void testAddAndCheckLong() {\n         long max = Long.MAX_VALUE;\n         long min = Long.MIN_VALUE;\n-        assertEquals(max, MathUtils.addAndCheck(max, 0L));\n-        assertEquals(min, MathUtils.addAndCheck(min, 0L));\n-        assertEquals(max, MathUtils.addAndCheck(0L, max));\n-        assertEquals(min, MathUtils.addAndCheck(0L, min));\n-        assertEquals(1, MathUtils.addAndCheck(-1L, 2L));\n-        assertEquals(1, MathUtils.addAndCheck(2L, -1L));\n-        assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));\n-        assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));\n+        Assert.assertEquals(max, MathUtils.addAndCheck(max, 0L));\n+        Assert.assertEquals(min, MathUtils.addAndCheck(min, 0L));\n+        Assert.assertEquals(max, MathUtils.addAndCheck(0L, max));\n+        Assert.assertEquals(min, MathUtils.addAndCheck(0L, min));\n+        Assert.assertEquals(1, MathUtils.addAndCheck(-1L, 2L));\n+        Assert.assertEquals(1, MathUtils.addAndCheck(2L, -1L));\n+        Assert.assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));\n+        Assert.assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));\n         testAddAndCheckLongFailure(max, 1L);\n         testAddAndCheckLongFailure(min, -1L);\n         testAddAndCheckLongFailure(1L, max);\n     private void testAddAndCheckLongFailure(long a, long b) {\n         try {\n             MathUtils.addAndCheck(a, b);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testBinomialCoefficient() {\n         long[] bcoef5 = {\n             1,\n             6,\n             1 };\n         for (int i = 0; i < 6; i++) {\n-            assertEquals(\"5 choose \" + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));\n+            Assert.assertEquals(\"5 choose \" + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));\n         }\n         for (int i = 0; i < 7; i++) {\n-            assertEquals(\"6 choose \" + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));\n+            Assert.assertEquals(\"6 choose \" + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));\n         }\n \n         for (int n = 1; n < 10; n++) {\n             for (int k = 0; k <= n; k++) {\n-                assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));\n-                assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n-                assertEquals(n + \" choose \" + k, FastMath.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n+                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));\n+                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n+                Assert.assertEquals(n + \" choose \" + k, FastMath.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n             }\n         }\n \n         int[] k = { 17, 33, 10, 1500 - 4, 4 };\n         for (int i = 0; i < n.length; i++) {\n             long expected = binomialCoefficient(n[i], k[i]);\n-            assertEquals(n[i] + \" choose \" + k[i], expected,\n+            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n                 MathUtils.binomialCoefficient(n[i], k[i]));\n-            assertEquals(n[i] + \" choose \" + k[i], expected,\n+            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n                 MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n-            assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", FastMath.log(expected),\n+            Assert.assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", FastMath.log(expected),\n                 MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n         }\n     }\n      * Tests correctness for large n and sharpness of upper bound in API doc\n      * JIRA: MATH-241\n      */\n+    @Test\n     public void testBinomialCoefficientLarge() throws Exception {\n         // This tests all legal and illegal values for n <= 200.\n         for (int n = 0; n <= 200; n++) {\n                 } catch (MathArithmeticException ex) {\n                     shouldThrow = true;\n                 }\n-                assertEquals(n + \" choose \" + k, exactResult, ourResult);\n-                assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n-                assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n+                Assert.assertEquals(n + \" choose \" + k, exactResult, ourResult);\n+                Assert.assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n+                Assert.assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n \n                 if (!shouldThrow && exactResult > 1) {\n-                    assertEquals(n + \" choose \" + k, 1.,\n+                    Assert.assertEquals(n + \" choose \" + k, 1.,\n                         MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n-                    assertEquals(n + \" choose \" + k, 1,\n+                    Assert.assertEquals(n + \" choose \" + k, 1,\n                         MathUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);\n                 }\n             }\n \n         long ourResult = MathUtils.binomialCoefficient(300, 3);\n         long exactResult = binomialCoefficient(300, 3);\n-        assertEquals(exactResult, ourResult);\n+        Assert.assertEquals(exactResult, ourResult);\n \n         ourResult = MathUtils.binomialCoefficient(700, 697);\n         exactResult = binomialCoefficient(700, 697);\n-        assertEquals(exactResult, ourResult);\n+        Assert.assertEquals(exactResult, ourResult);\n \n         // This one should throw\n         try {\n             MathUtils.binomialCoefficient(700, 300);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // Expected\n         }\n         int n = 10000;\n         ourResult = MathUtils.binomialCoefficient(n, 3);\n         exactResult = binomialCoefficient(n, 3);\n-        assertEquals(exactResult, ourResult);\n-        assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n-        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);\n-\n-    }\n-\n+        Assert.assertEquals(exactResult, ourResult);\n+        Assert.assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n+        Assert.assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);\n+\n+    }\n+\n+    @Test\n     public void testBinomialCoefficientFail() {\n         try {\n             MathUtils.binomialCoefficient(4, 5);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficientDouble(4, 5);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficientLog(4, 5);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficient(-1, -2);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.binomialCoefficientDouble(-1, -2);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.binomialCoefficientLog(-1, -2);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficient(67, 30);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.binomialCoefficient(67, 34);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // ignored\n         }\n         double x = MathUtils.binomialCoefficientDouble(1030, 515);\n-        assertTrue(\"expecting infinite binomial coefficient\", Double\n+        Assert.assertTrue(\"expecting infinite binomial coefficient\", Double\n             .isInfinite(x));\n     }\n \n+    @Test\n     public void testCompareTo() {\n-      assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));\n-      assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);\n-      assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);\n-    }\n-\n+      Assert.assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));\n+      Assert.assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);\n+      Assert.assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);\n+    }\n+\n+    @Test\n     public void testCosh() {\n         double x = 3.0;\n         double expected = 10.06766;\n-        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(expected, MathUtils.cosh(x), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testCoshNaN() {\n-        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n+    }\n+\n+    @Test\n     public void testEqualsIncludingNaN() {\n         double[] testArray = {\n             Double.NaN,\n         for (int i = 0; i < testArray.length; i++) {\n             for (int j = 0; j < testArray.length; j++) {\n                 if (i == j) {\n-                    assertTrue(MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n-                    assertTrue(MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n+                    Assert.assertTrue(MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n+                    Assert.assertTrue(MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n                 } else {\n-                    assertTrue(!MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n-                    assertTrue(!MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n+                    Assert.assertTrue(!MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n+                    Assert.assertTrue(!MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n                 }\n             }\n         }\n     }\n \n+    @Test\n     public void testEqualsWithAllowedDelta() {\n-        assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));\n-        assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));\n-        assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));\n-        assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));\n-        assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));\n-        assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1.0));\n-        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n-        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));\n+        Assert.assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));\n+        Assert.assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));\n+        Assert.assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));\n+        Assert.assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));\n+        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1.0));\n+        Assert.assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        Assert.assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n+        Assert.assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+    }\n+\n+    @Test\n     public void testMath475() {\n         final double a = 1.7976931348623182E16;\n         final double b = FastMath.nextUp(a);\n         // Because they are adjacent floating point numbers, \"a\" and \"b\" are\n         // considered equal even though the allowed error is smaller than\n         // their difference.\n-        assertTrue(MathUtils.equals(a, b, 0.5 * diff));\n+        Assert.assertTrue(MathUtils.equals(a, b, 0.5 * diff));\n \n         final double c = FastMath.nextUp(b);\n         diff = FastMath.abs(a - c);\n         // Because \"a\" and \"c\" are not adjacent, the tolerance is taken into\n         // account for assessing equality.\n-        assertTrue(MathUtils.equals(a, c, diff));\n-        assertFalse(MathUtils.equals(a, c, (1 - 1e-16) * diff));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(a, c, diff));\n+        Assert.assertFalse(MathUtils.equals(a, c, (1 - 1e-16) * diff));\n+    }\n+\n+    @Test\n     public void testEqualsIncludingNaNWithAllowedDelta() {\n-        assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0000, .0625));\n-        assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0625));\n-        assertTrue(MathUtils.equalsIncludingNaN(152.9375, 153.0000, .0625));\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n-        assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-        assertFalse(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0624));\n-        assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0000, .0625));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0625));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(152.9375, 153.0000, .0625));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0624));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));\n     }\n \n     // Tests for floating point equality\n+    @Test\n     public void testFloatEqualsWithAllowedUlps() {\n-        assertTrue(\"+0.0f == -0.0f\",MathUtils.equals(0.0f, -0.0f));\n-        assertTrue(\"+0.0f == -0.0f (1 ulp)\",MathUtils.equals(0.0f, -0.0f, 1));\n+        Assert.assertTrue(\"+0.0f == -0.0f\",MathUtils.equals(0.0f, -0.0f));\n+        Assert.assertTrue(\"+0.0f == -0.0f (1 ulp)\",MathUtils.equals(0.0f, -0.0f, 1));\n         float oneFloat = 1.0f;\n-        assertTrue(\"1.0f == 1.0f + 1 ulp\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));\n-        assertTrue(\"1.0f == 1.0f + 1 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1));\n-        assertFalse(\"1.0f != 1.0f + 2 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1));\n-\n-        assertTrue(MathUtils.equals(153.0f, 153.0f, 1));\n+        Assert.assertTrue(\"1.0f == 1.0f + 1 ulp\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));\n+        Assert.assertTrue(\"1.0f == 1.0f + 1 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1));\n+        Assert.assertFalse(\"1.0f != 1.0f + 2 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1));\n+\n+        Assert.assertTrue(MathUtils.equals(153.0f, 153.0f, 1));\n \n         // These tests need adjusting for floating point precision\n-//        assertTrue(MathUtils.equals(153.0f, 153.00000000000003f, 1));\n-//        assertFalse(MathUtils.equals(153.0f, 153.00000000000006f, 1));\n-//        assertTrue(MathUtils.equals(153.0f, 152.99999999999997f, 1));\n-//        assertFalse(MathUtils.equals(153f, 152.99999999999994f, 1));\n+//        Assert.assertTrue(MathUtils.equals(153.0f, 153.00000000000003f, 1));\n+//        Assert.assertFalse(MathUtils.equals(153.0f, 153.00000000000006f, 1));\n+//        Assert.assertTrue(MathUtils.equals(153.0f, 152.99999999999997f, 1));\n+//        Assert.assertFalse(MathUtils.equals(153f, 152.99999999999994f, 1));\n //\n-//        assertTrue(MathUtils.equals(-128.0f, -127.99999999999999f, 1));\n-//        assertFalse(MathUtils.equals(-128.0f, -127.99999999999997f, 1));\n-//        assertTrue(MathUtils.equals(-128.0f, -128.00000000000003f, 1));\n-//        assertFalse(MathUtils.equals(-128.0f, -128.00000000000006f, 1));\n-\n-        assertTrue(MathUtils.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1));\n-        assertTrue(MathUtils.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1));\n-\n-        assertTrue(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1));\n-        assertTrue(MathUtils.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1));\n-\n-        assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 1));\n-\n-        assertFalse(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000));\n-    }\n-\n+//        Assert.assertTrue(MathUtils.equals(-128.0f, -127.99999999999999f, 1));\n+//        Assert.assertFalse(MathUtils.equals(-128.0f, -127.99999999999997f, 1));\n+//        Assert.assertTrue(MathUtils.equals(-128.0f, -128.00000000000003f, 1));\n+//        Assert.assertFalse(MathUtils.equals(-128.0f, -128.00000000000006f, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1));\n+        Assert.assertTrue(MathUtils.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1));\n+        Assert.assertTrue(MathUtils.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1));\n+\n+        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 1));\n+\n+        Assert.assertFalse(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    @Test\n     public void testEqualsWithAllowedUlps() {\n-        assertTrue(MathUtils.equals(0.0, -0.0, 1));\n-\n-        assertTrue(MathUtils.equals(1.0, 1 + FastMath.ulp(1d), 1));\n-        assertFalse(MathUtils.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n+        Assert.assertTrue(MathUtils.equals(0.0, -0.0, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(1.0, 1 + FastMath.ulp(1d), 1));\n+        Assert.assertFalse(MathUtils.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n \n         final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n         final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n-        assertTrue(MathUtils.equals(1.0, nUp1, 1));\n-        assertTrue(MathUtils.equals(nUp1, nnUp1, 1));\n-        assertFalse(MathUtils.equals(1.0, nnUp1, 1));\n-\n-        assertTrue(MathUtils.equals(0.0, FastMath.ulp(0d), 1));\n-        assertTrue(MathUtils.equals(0.0, -FastMath.ulp(0d), 1));\n-\n-        assertTrue(MathUtils.equals(153.0, 153.0, 1));\n-\n-        assertTrue(MathUtils.equals(153.0, 153.00000000000003, 1));\n-        assertFalse(MathUtils.equals(153.0, 153.00000000000006, 1));\n-        assertTrue(MathUtils.equals(153.0, 152.99999999999997, 1));\n-        assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n-\n-        assertTrue(MathUtils.equals(-128.0, -127.99999999999999, 1));\n-        assertFalse(MathUtils.equals(-128.0, -127.99999999999997, 1));\n-        assertTrue(MathUtils.equals(-128.0, -128.00000000000003, 1));\n-        assertFalse(MathUtils.equals(-128.0, -128.00000000000006, 1));\n-\n-        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n-        assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n-\n-        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n-        assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n-\n-        assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1));\n-\n-        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(1.0, nUp1, 1));\n+        Assert.assertTrue(MathUtils.equals(nUp1, nnUp1, 1));\n+        Assert.assertFalse(MathUtils.equals(1.0, nnUp1, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(0.0, FastMath.ulp(0d), 1));\n+        Assert.assertTrue(MathUtils.equals(0.0, -FastMath.ulp(0d), 1));\n+\n+        Assert.assertTrue(MathUtils.equals(153.0, 153.0, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(153.0, 153.00000000000003, 1));\n+        Assert.assertFalse(MathUtils.equals(153.0, 153.00000000000006, 1));\n+        Assert.assertTrue(MathUtils.equals(153.0, 152.99999999999997, 1));\n+        Assert.assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(-128.0, -127.99999999999999, 1));\n+        Assert.assertFalse(MathUtils.equals(-128.0, -127.99999999999997, 1));\n+        Assert.assertTrue(MathUtils.equals(-128.0, -128.00000000000003, 1));\n+        Assert.assertFalse(MathUtils.equals(-128.0, -128.00000000000006, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        Assert.assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        Assert.assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1));\n+\n+        Assert.assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    @Test\n     public void testEqualsIncludingNaNWithAllowedUlps() {\n-        assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n \n         final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n         final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n-        assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.00000000000003, 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(153.0, 153.00000000000006, 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(153.0, 152.99999999999997, 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(153, 152.99999999999994, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999999, 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999997, 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000003, 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000006, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n-\n-        assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1));\n-\n-        assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.00000000000003, 1));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(153.0, 153.00000000000006, 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 152.99999999999997, 1));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(153, 152.99999999999994, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999999, 1));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999997, 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000003, 1));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000006, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1));\n+\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    @Test\n     public void testArrayEquals() {\n-        assertFalse(MathUtils.equals(new double[] { 1d }, null));\n-        assertFalse(MathUtils.equals(null, new double[] { 1d }));\n-        assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n-\n-        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n-        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n-        assertTrue(MathUtils.equals(new double[] {\n+        Assert.assertFalse(MathUtils.equals(new double[] { 1d }, null));\n+        Assert.assertFalse(MathUtils.equals(null, new double[] { 1d }));\n+        Assert.assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n+\n+        Assert.assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n+        Assert.assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n+        Assert.assertTrue(MathUtils.equals(new double[] {\n                                       Double.POSITIVE_INFINITY,\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }, new double[] {\n                                       Double.POSITIVE_INFINITY,\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }));\n-        assertFalse(MathUtils.equals(new double[] { Double.NaN },\n+        Assert.assertFalse(MathUtils.equals(new double[] { Double.NaN },\n                                      new double[] { Double.NaN }));\n-        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n+        Assert.assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n                                      new double[] { Double.NEGATIVE_INFINITY }));\n-        assertFalse(MathUtils.equals(new double[] { 1d },\n+        Assert.assertFalse(MathUtils.equals(new double[] { 1d },\n                                      new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n \n     }\n \n+    @Test\n     public void testArrayEqualsIncludingNaN() {\n-        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, null));\n-        assertFalse(MathUtils.equalsIncludingNaN(null, new double[] { 1d }));\n-        assertTrue(MathUtils.equalsIncludingNaN((double[]) null, (double[]) null));\n-\n-        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[0]));\n-        assertTrue(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));\n-        assertTrue(MathUtils.equalsIncludingNaN(new double[] {\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, null));\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(null, new double[] { 1d }));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN((double[]) null, (double[]) null));\n+\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[0]));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));\n+        Assert.assertTrue(MathUtils.equalsIncludingNaN(new double[] {\n                     Double.NaN, Double.POSITIVE_INFINITY,\n                     Double.NEGATIVE_INFINITY, 1d, 0d\n                 }, new double[] {\n                     Double.NaN, Double.POSITIVE_INFINITY,\n                     Double.NEGATIVE_INFINITY, 1d, 0d\n                 }));\n-        assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },\n                                                  new double[] { Double.NEGATIVE_INFINITY }));\n-        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },\n+        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },\n                                                  new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n     }\n \n+    @Test\n     public void testFactorial() {\n         for (int i = 1; i < 21; i++) {\n-            assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n-            assertEquals(i + \"! \", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n-            assertEquals(i + \"! \", FastMath.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);\n-        }\n-\n-        assertEquals(\"0\", 1, MathUtils.factorial(0));\n-        assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n-        assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n-    }\n-\n+            Assert.assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n+            Assert.assertEquals(i + \"! \", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n+            Assert.assertEquals(i + \"! \", FastMath.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);\n+        }\n+\n+        Assert.assertEquals(\"0\", 1, MathUtils.factorial(0));\n+        Assert.assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n+        Assert.assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n+    }\n+\n+    @Test\n     public void testFactorialFail() {\n         try {\n             MathUtils.factorial(-1);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.factorialDouble(-1);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.factorialLog(-1);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.factorial(21);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // ignored\n         }\n-        assertTrue(\"expecting infinite factorial value\", Double.isInfinite(MathUtils.factorialDouble(171)));\n-    }\n-\n+        Assert.assertTrue(\"expecting infinite factorial value\", Double.isInfinite(MathUtils.factorialDouble(171)));\n+    }\n+\n+    @Test\n     public void testGcd() {\n         int a = 30;\n         int b = 50;\n         int c = 77;\n \n-        assertEquals(0, MathUtils.gcd(0, 0));\n-\n-        assertEquals(b, MathUtils.gcd(0, b));\n-        assertEquals(a, MathUtils.gcd(a, 0));\n-        assertEquals(b, MathUtils.gcd(0, -b));\n-        assertEquals(a, MathUtils.gcd(-a, 0));\n-\n-        assertEquals(10, MathUtils.gcd(a, b));\n-        assertEquals(10, MathUtils.gcd(-a, b));\n-        assertEquals(10, MathUtils.gcd(a, -b));\n-        assertEquals(10, MathUtils.gcd(-a, -b));\n-\n-        assertEquals(1, MathUtils.gcd(a, c));\n-        assertEquals(1, MathUtils.gcd(-a, c));\n-        assertEquals(1, MathUtils.gcd(a, -c));\n-        assertEquals(1, MathUtils.gcd(-a, -c));\n-\n-        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n-\n-        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n-        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n-        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n+        Assert.assertEquals(0, MathUtils.gcd(0, 0));\n+\n+        Assert.assertEquals(b, MathUtils.gcd(0, b));\n+        Assert.assertEquals(a, MathUtils.gcd(a, 0));\n+        Assert.assertEquals(b, MathUtils.gcd(0, -b));\n+        Assert.assertEquals(a, MathUtils.gcd(-a, 0));\n+\n+        Assert.assertEquals(10, MathUtils.gcd(a, b));\n+        Assert.assertEquals(10, MathUtils.gcd(-a, b));\n+        Assert.assertEquals(10, MathUtils.gcd(a, -b));\n+        Assert.assertEquals(10, MathUtils.gcd(-a, -b));\n+\n+        Assert.assertEquals(1, MathUtils.gcd(a, c));\n+        Assert.assertEquals(1, MathUtils.gcd(-a, c));\n+        Assert.assertEquals(1, MathUtils.gcd(a, -c));\n+        Assert.assertEquals(1, MathUtils.gcd(-a, -c));\n+\n+        Assert.assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n+\n+        Assert.assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n+        Assert.assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n+        Assert.assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n         try {\n             // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n             MathUtils.gcd(Integer.MIN_VALUE, 0);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n             MathUtils.gcd(0, Integer.MIN_VALUE);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n             MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void  testGcdLong(){\n         long a = 30;\n         long b = 50;\n         long c = 77;\n \n-        assertEquals(0, MathUtils.gcd(0L, 0));\n-\n-        assertEquals(b, MathUtils.gcd(0, b));\n-        assertEquals(a, MathUtils.gcd(a, 0));\n-        assertEquals(b, MathUtils.gcd(0, -b));\n-        assertEquals(a, MathUtils.gcd(-a, 0));\n-\n-        assertEquals(10, MathUtils.gcd(a, b));\n-        assertEquals(10, MathUtils.gcd(-a, b));\n-        assertEquals(10, MathUtils.gcd(a, -b));\n-        assertEquals(10, MathUtils.gcd(-a, -b));\n-\n-        assertEquals(1, MathUtils.gcd(a, c));\n-        assertEquals(1, MathUtils.gcd(-a, c));\n-        assertEquals(1, MathUtils.gcd(a, -c));\n-        assertEquals(1, MathUtils.gcd(-a, -c));\n-\n-        assertEquals(3L * (1L<<45), MathUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));\n-\n-        assertEquals(1L<<45, MathUtils.gcd(1L<<45, Long.MIN_VALUE));\n-\n-        assertEquals(Long.MAX_VALUE, MathUtils.gcd(Long.MAX_VALUE, 0L));\n-        assertEquals(Long.MAX_VALUE, MathUtils.gcd(-Long.MAX_VALUE, 0L));\n-        assertEquals(1, MathUtils.gcd(60247241209L, 153092023L));\n+        Assert.assertEquals(0, MathUtils.gcd(0L, 0));\n+\n+        Assert.assertEquals(b, MathUtils.gcd(0, b));\n+        Assert.assertEquals(a, MathUtils.gcd(a, 0));\n+        Assert.assertEquals(b, MathUtils.gcd(0, -b));\n+        Assert.assertEquals(a, MathUtils.gcd(-a, 0));\n+\n+        Assert.assertEquals(10, MathUtils.gcd(a, b));\n+        Assert.assertEquals(10, MathUtils.gcd(-a, b));\n+        Assert.assertEquals(10, MathUtils.gcd(a, -b));\n+        Assert.assertEquals(10, MathUtils.gcd(-a, -b));\n+\n+        Assert.assertEquals(1, MathUtils.gcd(a, c));\n+        Assert.assertEquals(1, MathUtils.gcd(-a, c));\n+        Assert.assertEquals(1, MathUtils.gcd(a, -c));\n+        Assert.assertEquals(1, MathUtils.gcd(-a, -c));\n+\n+        Assert.assertEquals(3L * (1L<<45), MathUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));\n+\n+        Assert.assertEquals(1L<<45, MathUtils.gcd(1L<<45, Long.MIN_VALUE));\n+\n+        Assert.assertEquals(Long.MAX_VALUE, MathUtils.gcd(Long.MAX_VALUE, 0L));\n+        Assert.assertEquals(Long.MAX_VALUE, MathUtils.gcd(-Long.MAX_VALUE, 0L));\n+        Assert.assertEquals(1, MathUtils.gcd(60247241209L, 153092023L));\n         try {\n             // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE\n             MathUtils.gcd(Long.MIN_VALUE, 0);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE\n             MathUtils.gcd(0, Long.MIN_VALUE);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE\n             MathUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testGcdConsistency() {\n         int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131};\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n             int i1 = p1 * p2 * p3;\n             int i2 = p1 * p2 * p4;\n             int gcd = p1 * p2;\n-            assertEquals(gcd, MathUtils.gcd(i1, i2));\n+            Assert.assertEquals(gcd, MathUtils.gcd(i1, i2));\n             long l1 = i1;\n             long l2 = i2;\n-            assertEquals(gcd, MathUtils.gcd(l1, l2));\n-        }\n-    }\n-\n+            Assert.assertEquals(gcd, MathUtils.gcd(l1, l2));\n+        }\n+    }\n+\n+    @Test\n     public void testHash() {\n         double[] testArray = {\n             Double.NaN,\n         for (int i = 0; i < testArray.length; i++) {\n             for (int j = 0; j < testArray.length; j++) {\n                 if (i == j) {\n-                    assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));\n-                    assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));\n+                    Assert.assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));\n+                    Assert.assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));\n                 } else {\n-                    assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));\n-                    assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));\n+                    Assert.assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));\n+                    Assert.assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));\n                 }\n             }\n         }\n     }\n \n+    @Test\n     public void testArrayHash() {\n-        assertEquals(0, MathUtils.hash((double[]) null));\n-        assertEquals(MathUtils.hash(new double[] {\n+        Assert.assertEquals(0, MathUtils.hash((double[]) null));\n+        Assert.assertEquals(MathUtils.hash(new double[] {\n                                       Double.NaN, Double.POSITIVE_INFINITY,\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }),\n                                       Double.NaN, Double.POSITIVE_INFINITY,\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }));\n-        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n+        Assert.assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                     MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) }));\n-        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n+        Assert.assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                     MathUtils.hash(new double[] { 1d, 1d }));\n     }\n \n     /**\n      * Make sure that permuted arrays do not hash to the same value.\n      */\n+    @Test\n     public void testPermutedArrayHash() {\n         double[] original = new double[10];\n         double[] permuted = new double[10];\n         } while (isIdentity);\n \n         // Verify that permuted array has different hash\n-        assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));\n-    }\n-\n+        Assert.assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));\n+    }\n+\n+    @Test\n     public void testIndicatorByte() {\n-        assertEquals((byte)1, MathUtils.indicator((byte)2));\n-        assertEquals((byte)1, MathUtils.indicator((byte)0));\n-        assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));\n-    }\n-\n+        Assert.assertEquals((byte)1, MathUtils.indicator((byte)2));\n+        Assert.assertEquals((byte)1, MathUtils.indicator((byte)0));\n+        Assert.assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));\n+    }\n+\n+    @Test\n     public void testIndicatorDouble() {\n         double delta = 0.0;\n-        assertEquals(1.0, MathUtils.indicator(2.0), delta);\n-        assertEquals(1.0, MathUtils.indicator(0.0), delta);\n-        assertEquals(-1.0, MathUtils.indicator(-2.0), delta);\n-        assertEquals(Double.NaN, MathUtils.indicator(Double.NaN));\n-    }\n-\n+        Assert.assertEquals(1.0, MathUtils.indicator(2.0), delta);\n+        Assert.assertEquals(1.0, MathUtils.indicator(0.0), delta);\n+        Assert.assertEquals(-1.0, MathUtils.indicator(-2.0), delta);\n+        Assert.assertTrue(Double.isNaN(MathUtils.indicator(Double.NaN)));\n+    }\n+\n+    @Test\n     public void testIndicatorFloat() {\n         float delta = 0.0F;\n-        assertEquals(1.0F, MathUtils.indicator(2.0F), delta);\n-        assertEquals(1.0F, MathUtils.indicator(0.0F), delta);\n-        assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);\n-    }\n-\n+        Assert.assertEquals(1.0F, MathUtils.indicator(2.0F), delta);\n+        Assert.assertEquals(1.0F, MathUtils.indicator(0.0F), delta);\n+        Assert.assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);\n+    }\n+\n+    @Test\n     public void testIndicatorInt() {\n-        assertEquals(1, MathUtils.indicator((2)));\n-        assertEquals(1, MathUtils.indicator((0)));\n-        assertEquals((-1), MathUtils.indicator((-2)));\n-    }\n-\n+        Assert.assertEquals(1, MathUtils.indicator((2)));\n+        Assert.assertEquals(1, MathUtils.indicator((0)));\n+        Assert.assertEquals((-1), MathUtils.indicator((-2)));\n+    }\n+\n+    @Test\n     public void testIndicatorLong() {\n-        assertEquals(1L, MathUtils.indicator(2L));\n-        assertEquals(1L, MathUtils.indicator(0L));\n-        assertEquals(-1L, MathUtils.indicator(-2L));\n-    }\n-\n+        Assert.assertEquals(1L, MathUtils.indicator(2L));\n+        Assert.assertEquals(1L, MathUtils.indicator(0L));\n+        Assert.assertEquals(-1L, MathUtils.indicator(-2L));\n+    }\n+\n+    @Test\n     public void testIndicatorShort() {\n-        assertEquals((short)1, MathUtils.indicator((short)2));\n-        assertEquals((short)1, MathUtils.indicator((short)0));\n-        assertEquals((short)(-1), MathUtils.indicator((short)(-2)));\n-    }\n-\n+        Assert.assertEquals((short)1, MathUtils.indicator((short)2));\n+        Assert.assertEquals((short)1, MathUtils.indicator((short)0));\n+        Assert.assertEquals((short)(-1), MathUtils.indicator((short)(-2)));\n+    }\n+\n+    @Test\n     public void testLcm() {\n         int a = 30;\n         int b = 50;\n         int c = 77;\n \n-        assertEquals(0, MathUtils.lcm(0, b));\n-        assertEquals(0, MathUtils.lcm(a, 0));\n-        assertEquals(b, MathUtils.lcm(1, b));\n-        assertEquals(a, MathUtils.lcm(a, 1));\n-        assertEquals(150, MathUtils.lcm(a, b));\n-        assertEquals(150, MathUtils.lcm(-a, b));\n-        assertEquals(150, MathUtils.lcm(a, -b));\n-        assertEquals(150, MathUtils.lcm(-a, -b));\n-        assertEquals(2310, MathUtils.lcm(a, c));\n+        Assert.assertEquals(0, MathUtils.lcm(0, b));\n+        Assert.assertEquals(0, MathUtils.lcm(a, 0));\n+        Assert.assertEquals(b, MathUtils.lcm(1, b));\n+        Assert.assertEquals(a, MathUtils.lcm(a, 1));\n+        Assert.assertEquals(150, MathUtils.lcm(a, b));\n+        Assert.assertEquals(150, MathUtils.lcm(-a, b));\n+        Assert.assertEquals(150, MathUtils.lcm(a, -b));\n+        Assert.assertEquals(150, MathUtils.lcm(-a, -b));\n+        Assert.assertEquals(2310, MathUtils.lcm(a, c));\n \n         // Assert that no intermediate value overflows:\n         // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n-        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n+        Assert.assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n \n         // Special case\n-        assertEquals(0, MathUtils.lcm(0, 0));\n+        Assert.assertEquals(0, MathUtils.lcm(0, 0));\n \n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n \n         try {\n             MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testLcmLong() {\n         long a = 30;\n         long b = 50;\n         long c = 77;\n \n-        assertEquals(0, MathUtils.lcm(0, b));\n-        assertEquals(0, MathUtils.lcm(a, 0));\n-        assertEquals(b, MathUtils.lcm(1, b));\n-        assertEquals(a, MathUtils.lcm(a, 1));\n-        assertEquals(150, MathUtils.lcm(a, b));\n-        assertEquals(150, MathUtils.lcm(-a, b));\n-        assertEquals(150, MathUtils.lcm(a, -b));\n-        assertEquals(150, MathUtils.lcm(-a, -b));\n-        assertEquals(2310, MathUtils.lcm(a, c));\n-\n-        assertEquals(Long.MAX_VALUE, MathUtils.lcm(60247241209L, 153092023L));\n+        Assert.assertEquals(0, MathUtils.lcm(0, b));\n+        Assert.assertEquals(0, MathUtils.lcm(a, 0));\n+        Assert.assertEquals(b, MathUtils.lcm(1, b));\n+        Assert.assertEquals(a, MathUtils.lcm(a, 1));\n+        Assert.assertEquals(150, MathUtils.lcm(a, b));\n+        Assert.assertEquals(150, MathUtils.lcm(-a, b));\n+        Assert.assertEquals(150, MathUtils.lcm(a, -b));\n+        Assert.assertEquals(150, MathUtils.lcm(-a, -b));\n+        Assert.assertEquals(2310, MathUtils.lcm(a, c));\n+\n+        Assert.assertEquals(Long.MAX_VALUE, MathUtils.lcm(60247241209L, 153092023L));\n \n         // Assert that no intermediate value overflows:\n         // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n-        assertEquals((1L<<50)*15, MathUtils.lcm((1L<<45)*3, (1L<<50)*5));\n+        Assert.assertEquals((1L<<50)*15, MathUtils.lcm((1L<<45)*3, (1L<<50)*5));\n \n         // Special case\n-        assertEquals(0L, MathUtils.lcm(0L, 0L));\n+        Assert.assertEquals(0L, MathUtils.lcm(0L, 0L));\n \n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Long.MIN_VALUE, 1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Long.MIN_VALUE, 1<<20);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n \n-        assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),\n+        Assert.assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),\n             MathUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));\n         try {\n             MathUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testLog() {\n-        assertEquals(2.0, MathUtils.log(2, 4), 0);\n-        assertEquals(3.0, MathUtils.log(2, 8), 0);\n-        assertTrue(Double.isNaN(MathUtils.log(-1, 1)));\n-        assertTrue(Double.isNaN(MathUtils.log(1, -1)));\n-        assertTrue(Double.isNaN(MathUtils.log(0, 0)));\n-        assertEquals(0, MathUtils.log(0, 10), 0);\n-        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);\n-    }\n-\n+        Assert.assertEquals(2.0, MathUtils.log(2, 4), 0);\n+        Assert.assertEquals(3.0, MathUtils.log(2, 8), 0);\n+        Assert.assertTrue(Double.isNaN(MathUtils.log(-1, 1)));\n+        Assert.assertTrue(Double.isNaN(MathUtils.log(1, -1)));\n+        Assert.assertTrue(Double.isNaN(MathUtils.log(0, 0)));\n+        Assert.assertEquals(0, MathUtils.log(0, 10), 0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);\n+    }\n+\n+    @Test\n     public void testMulAndCheck() {\n         int big = Integer.MAX_VALUE;\n         int bigNeg = Integer.MIN_VALUE;\n-        assertEquals(big, MathUtils.mulAndCheck(big, 1));\n+        Assert.assertEquals(big, MathUtils.mulAndCheck(big, 1));\n         try {\n             MathUtils.mulAndCheck(big, 2);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n         }\n         try {\n             MathUtils.mulAndCheck(bigNeg, 2);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n         }\n     }\n \n+    @Test\n     public void testMulAndCheckLong() {\n         long max = Long.MAX_VALUE;\n         long min = Long.MIN_VALUE;\n-        assertEquals(max, MathUtils.mulAndCheck(max, 1L));\n-        assertEquals(min, MathUtils.mulAndCheck(min, 1L));\n-        assertEquals(0L, MathUtils.mulAndCheck(max, 0L));\n-        assertEquals(0L, MathUtils.mulAndCheck(min, 0L));\n-        assertEquals(max, MathUtils.mulAndCheck(1L, max));\n-        assertEquals(min, MathUtils.mulAndCheck(1L, min));\n-        assertEquals(0L, MathUtils.mulAndCheck(0L, max));\n-        assertEquals(0L, MathUtils.mulAndCheck(0L, min));\n-        assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));\n-        assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));\n+        Assert.assertEquals(max, MathUtils.mulAndCheck(max, 1L));\n+        Assert.assertEquals(min, MathUtils.mulAndCheck(min, 1L));\n+        Assert.assertEquals(0L, MathUtils.mulAndCheck(max, 0L));\n+        Assert.assertEquals(0L, MathUtils.mulAndCheck(min, 0L));\n+        Assert.assertEquals(max, MathUtils.mulAndCheck(1L, max));\n+        Assert.assertEquals(min, MathUtils.mulAndCheck(1L, min));\n+        Assert.assertEquals(0L, MathUtils.mulAndCheck(0L, max));\n+        Assert.assertEquals(0L, MathUtils.mulAndCheck(0L, min));\n+        Assert.assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));\n+        Assert.assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));\n         testMulAndCheckLongFailure(max, 2L);\n         testMulAndCheckLongFailure(2L, max);\n         testMulAndCheckLongFailure(min, 2L);\n     private void testMulAndCheckLongFailure(long a, long b) {\n         try {\n             MathUtils.mulAndCheck(a, b);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testNormalizeAngle() {\n         for (double a = -15.0; a <= 15.0; a += 0.1) {\n             for (double b = -15.0; b <= 15.0; b += 0.2) {\n                 double c = MathUtils.normalizeAngle(a, b);\n-                assertTrue((b - FastMath.PI) <= c);\n-                assertTrue(c <= (b + FastMath.PI));\n+                Assert.assertTrue((b - FastMath.PI) <= c);\n+                Assert.assertTrue(c <= (b + FastMath.PI));\n                 double twoK = FastMath.rint((a - c) / FastMath.PI);\n-                assertEquals(c, a - twoK * FastMath.PI, 1.0e-14);\n+                Assert.assertEquals(c, a - twoK * FastMath.PI, 1.0e-14);\n             }\n         }\n     }\n \n+    @Test\n     public void testNormalizeArray() {\n         double[] testValues1 = new double[] {1, 1, 2};\n         TestUtils.assertEquals(\n         double[] zeroSum = new double[] {-1, 1};\n         try {\n             MathUtils.normalizeArray(zeroSum, 1);\n-            fail(\"expecting MathArithmeticException\");\n+            Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {}\n \n         // Infinite elements -> MathArithmeticException\n         double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};\n         try {\n             MathUtils.normalizeArray(hasInf, 1);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n         // Infinite target -> MathIllegalArgumentException\n         try {\n             MathUtils.normalizeArray(testValues1, Double.POSITIVE_INFINITY);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n         // NaN target -> MathIllegalArgumentException\n         try {\n             MathUtils.normalizeArray(testValues1, Double.NaN);\n-            fail(\"expecting MathIllegalArgumentException\");\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n \n     }\n \n+    @Test\n     public void testRoundDouble() {\n         double x = 1.234567890;\n-        assertEquals(1.23, MathUtils.round(x, 2), 0.0);\n-        assertEquals(1.235, MathUtils.round(x, 3), 0.0);\n-        assertEquals(1.2346, MathUtils.round(x, 4), 0.0);\n+        Assert.assertEquals(1.23, MathUtils.round(x, 2), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(x, 3), 0.0);\n+        Assert.assertEquals(1.2346, MathUtils.round(x, 4), 0.0);\n \n         // JIRA MATH-151\n-        assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);\n-        assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);\n+        Assert.assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);\n         double xx = 39.0;\n         xx = xx + 245d / 1000d;\n-        assertEquals(39.25, MathUtils.round(xx, 2), 0.0);\n+        Assert.assertEquals(39.25, MathUtils.round(xx, 2), 0.0);\n \n         // BZ 35904\n-        assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);\n-        assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);\n-        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);\n-        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);\n-        assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);\n-        assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);\n-        assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);\n-        assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);\n-        assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);\n-\n-        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-\n-        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-\n-        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-\n-        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-\n-        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-\n-        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-\n-        assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n-        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        Assert.assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);\n+        Assert.assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);\n+        Assert.assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);\n+        Assert.assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);\n+        Assert.assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);\n+        Assert.assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);\n+        Assert.assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);\n+        Assert.assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);\n+        Assert.assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);\n+\n+        Assert.assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+\n+        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+\n+        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        Assert.assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        Assert.assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n \n         try {\n             MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n-            fail();\n+            Assert.fail();\n         } catch (MathRuntimeException ex) { // XXX Loosing semantics?\n             // success\n         }\n \n-        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n \n         try {\n             MathUtils.round(1.234, 2, 1923);\n-            fail();\n+            Assert.fail();\n         } catch (MathRuntimeException ex) { // XXX Loosing semantics?\n             // success\n         }\n \n         // MATH-151\n-        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n \n         // special values\n         TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);\n-        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);\n-        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);\n-        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n-    }\n-\n+        Assert.assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n+    }\n+\n+    @Test\n     public void testRoundFloat() {\n         float x = 1.234567890f;\n-        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);\n-        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);\n-        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);\n+        Assert.assertEquals(1.23f, MathUtils.round(x, 2), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(x, 3), 0.0);\n+        Assert.assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);\n \n         // BZ 35904\n-        assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);\n-        assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);\n-        assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);\n-        assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);\n-        assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);\n-        assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);\n-        assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);\n-\n-        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n-        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n-\n-        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n-        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n-\n-        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n-        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n-\n-        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n-\n-        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n-\n-        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n-\n-        assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n-        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        Assert.assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);\n+        Assert.assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);\n+        Assert.assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);\n+        Assert.assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);\n+        Assert.assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);\n+        Assert.assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);\n+        Assert.assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);\n+\n+        Assert.assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        Assert.assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        Assert.assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+\n+        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        Assert.assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+\n+        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        Assert.assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+\n+        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        Assert.assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+\n+        Assert.assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        Assert.assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n \n         try {\n             MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n-            fail();\n+            Assert.fail();\n         } catch (MathArithmeticException ex) {\n             // success\n         }\n \n-        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n-        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n \n         try {\n             MathUtils.round(1.234f, 2, 1923);\n-            fail();\n+            Assert.fail();\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         // special values\n         TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);\n-        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);\n-        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n-        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n-    }\n-\n+        Assert.assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);\n+        Assert.assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n+        Assert.assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n+    }\n+\n+    @Test\n     public void testSignByte() {\n-        assertEquals((byte) 1, MathUtils.sign((byte) 2));\n-        assertEquals((byte) 0, MathUtils.sign((byte) 0));\n-        assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));\n-    }\n-\n+        Assert.assertEquals((byte) 1, MathUtils.sign((byte) 2));\n+        Assert.assertEquals((byte) 0, MathUtils.sign((byte) 0));\n+        Assert.assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));\n+    }\n+\n+    @Test\n     public void testSignDouble() {\n         double delta = 0.0;\n-        assertEquals(1.0, MathUtils.sign(2.0), delta);\n-        assertEquals(0.0, MathUtils.sign(0.0), delta);\n-        assertEquals(-1.0, MathUtils.sign(-2.0), delta);\n+        Assert.assertEquals(1.0, MathUtils.sign(2.0), delta);\n+        Assert.assertEquals(0.0, MathUtils.sign(0.0), delta);\n+        Assert.assertEquals(-1.0, MathUtils.sign(-2.0), delta);\n         TestUtils.assertSame(-0. / 0., MathUtils.sign(Double.NaN));\n     }\n \n+    @Test\n     public void testSignFloat() {\n         float delta = 0.0F;\n-        assertEquals(1.0F, MathUtils.sign(2.0F), delta);\n-        assertEquals(0.0F, MathUtils.sign(0.0F), delta);\n-        assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);\n+        Assert.assertEquals(1.0F, MathUtils.sign(2.0F), delta);\n+        Assert.assertEquals(0.0F, MathUtils.sign(0.0F), delta);\n+        Assert.assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);\n         TestUtils.assertSame(Float.NaN, MathUtils.sign(Float.NaN));\n     }\n \n+    @Test\n     public void testSignInt() {\n-        assertEquals(1, MathUtils.sign(2));\n-        assertEquals(0, MathUtils.sign(0));\n-        assertEquals((-1), MathUtils.sign((-2)));\n-    }\n-\n+        Assert.assertEquals(1, MathUtils.sign(2));\n+        Assert.assertEquals(0, MathUtils.sign(0));\n+        Assert.assertEquals((-1), MathUtils.sign((-2)));\n+    }\n+\n+    @Test\n     public void testSignLong() {\n-        assertEquals(1L, MathUtils.sign(2L));\n-        assertEquals(0L, MathUtils.sign(0L));\n-        assertEquals(-1L, MathUtils.sign(-2L));\n-    }\n-\n+        Assert.assertEquals(1L, MathUtils.sign(2L));\n+        Assert.assertEquals(0L, MathUtils.sign(0L));\n+        Assert.assertEquals(-1L, MathUtils.sign(-2L));\n+    }\n+\n+    @Test\n     public void testSignShort() {\n-        assertEquals((short) 1, MathUtils.sign((short) 2));\n-        assertEquals((short) 0, MathUtils.sign((short) 0));\n-        assertEquals((short) (-1), MathUtils.sign((short) (-2)));\n-    }\n-\n+        Assert.assertEquals((short) 1, MathUtils.sign((short) 2));\n+        Assert.assertEquals((short) 0, MathUtils.sign((short) 0));\n+        Assert.assertEquals((short) (-1), MathUtils.sign((short) (-2)));\n+    }\n+\n+    @Test\n     public void testSinh() {\n         double x = 3.0;\n         double expected = 10.01787;\n-        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);\n-    }\n-\n+        Assert.assertEquals(expected, MathUtils.sinh(x), 1.0e-5);\n+    }\n+\n+    @Test\n     public void testSinhNaN() {\n-        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));\n+    }\n+\n+    @Test\n     public void testSubAndCheck() {\n         int big = Integer.MAX_VALUE;\n         int bigNeg = Integer.MIN_VALUE;\n-        assertEquals(big, MathUtils.subAndCheck(big, 0));\n-        assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));\n-        assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));\n+        Assert.assertEquals(big, MathUtils.subAndCheck(big, 0));\n+        Assert.assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));\n+        Assert.assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));\n         try {\n             MathUtils.subAndCheck(big, -1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n         }\n         try {\n             MathUtils.subAndCheck(bigNeg, 1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n         }\n     }\n \n+    @Test\n     public void testSubAndCheckErrorMessage() {\n         int big = Integer.MAX_VALUE;\n         try {\n             MathUtils.subAndCheck(big, -1);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n-            assertTrue(ex.getMessage().length() > 1);\n-        }\n-    }\n-\n+            Assert.assertTrue(ex.getMessage().length() > 1);\n+        }\n+    }\n+\n+    @Test\n     public void testSubAndCheckLong() {\n         long max = Long.MAX_VALUE;\n         long min = Long.MIN_VALUE;\n-        assertEquals(max, MathUtils.subAndCheck(max, 0));\n-        assertEquals(min, MathUtils.subAndCheck(min, 0));\n-        assertEquals(-max, MathUtils.subAndCheck(0, max));\n-        assertEquals(min + 1, MathUtils.subAndCheck(min, -1));\n+        Assert.assertEquals(max, MathUtils.subAndCheck(max, 0));\n+        Assert.assertEquals(min, MathUtils.subAndCheck(min, 0));\n+        Assert.assertEquals(-max, MathUtils.subAndCheck(0, max));\n+        Assert.assertEquals(min + 1, MathUtils.subAndCheck(min, -1));\n         // min == -1-max\n-        assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));\n-        assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));\n+        Assert.assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));\n+        Assert.assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));\n         testSubAndCheckLongFailure(0L, min);\n         testSubAndCheckLongFailure(max, -1L);\n         testSubAndCheckLongFailure(min, 1L);\n     private void testSubAndCheckLongFailure(long a, long b) {\n         try {\n             MathUtils.subAndCheck(a, b);\n-            fail(\"Expecting MathArithmeticException\");\n+            Assert.fail(\"Expecting MathArithmeticException\");\n         } catch (MathArithmeticException ex) {\n             // success\n         }\n \n     }\n \n+    @Test\n     public void testPow() {\n \n-        assertEquals(1801088541, MathUtils.pow(21, 7));\n-        assertEquals(1, MathUtils.pow(21, 0));\n+        Assert.assertEquals(1801088541, MathUtils.pow(21, 7));\n+        Assert.assertEquals(1, MathUtils.pow(21, 0));\n         try {\n             MathUtils.pow(21, -7);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n-        assertEquals(1801088541, MathUtils.pow(21, 7l));\n-        assertEquals(1, MathUtils.pow(21, 0l));\n+        Assert.assertEquals(1801088541, MathUtils.pow(21, 7l));\n+        Assert.assertEquals(1, MathUtils.pow(21, 0l));\n         try {\n             MathUtils.pow(21, -7l);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n-        assertEquals(1801088541l, MathUtils.pow(21l, 7));\n-        assertEquals(1l, MathUtils.pow(21l, 0));\n+        Assert.assertEquals(1801088541l, MathUtils.pow(21l, 7));\n+        Assert.assertEquals(1l, MathUtils.pow(21l, 0));\n         try {\n             MathUtils.pow(21l, -7);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n-        assertEquals(1801088541l, MathUtils.pow(21l, 7l));\n-        assertEquals(1l, MathUtils.pow(21l, 0l));\n+        Assert.assertEquals(1801088541l, MathUtils.pow(21l, 7l));\n+        Assert.assertEquals(1l, MathUtils.pow(21l, 0l));\n         try {\n             MathUtils.pow(21l, -7l);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         BigInteger twentyOne = BigInteger.valueOf(21l);\n-        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));\n-        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));\n+        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));\n+        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));\n         try {\n             MathUtils.pow(twentyOne, -7);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n-        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));\n-        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));\n+        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));\n+        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));\n         try {\n             MathUtils.pow(twentyOne, -7l);\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n-        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));\n-        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));\n+        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));\n+        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));\n         try {\n             MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));\n-            fail(\"Expecting MathIllegalArgumentException\");\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n             new BigInteger(\"1543786922199448028351389769265814882661837148\" +\n                            \"4763915343722775611762713982220306372888519211\" +\n                            \"560905579993523402015636025177602059044911261\");\n-        assertEquals(bigOne, MathUtils.pow(twentyOne, 103));\n-        assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));\n-        assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));\n-\n-    }\n-\n+        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, 103));\n+        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));\n+        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));\n+\n+    }\n+\n+    @Test\n     public void testL1DistanceDouble() {\n         double[] p1 = { 2.5,  0.0 };\n         double[] p2 = { -0.5, 4.0 };\n-        assertEquals(7.0, MathUtils.distance1(p1, p2));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(7.0, MathUtils.distance1(p1, p2), 1));\n+    }\n+\n+    @Test\n     public void testL1DistanceInt() {\n         int[] p1 = { 3, 0 };\n         int[] p2 = { 0, 4 };\n-        assertEquals(7, MathUtils.distance1(p1, p2));\n-    }\n-\n+        Assert.assertEquals(7, MathUtils.distance1(p1, p2));\n+    }\n+\n+    @Test\n     public void testL2DistanceDouble() {\n         double[] p1 = { 2.5,  0.0 };\n         double[] p2 = { -0.5, 4.0 };\n-        assertEquals(5.0, MathUtils.distance(p1, p2));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(5.0, MathUtils.distance(p1, p2), 1));\n+    }\n+\n+    @Test\n     public void testL2DistanceInt() {\n         int[] p1 = { 3, 0 };\n         int[] p2 = { 0, 4 };\n-        assertEquals(5.0, MathUtils.distance(p1, p2));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(5, MathUtils.distance(p1, p2), 1));\n+    }\n+\n+    @Test\n     public void testLInfDistanceDouble() {\n         double[] p1 = { 2.5,  0.0 };\n         double[] p2 = { -0.5, 4.0 };\n-        assertEquals(4.0, MathUtils.distanceInf(p1, p2));\n-    }\n-\n+        Assert.assertTrue(MathUtils.equals(4.0, MathUtils.distanceInf(p1, p2), 1));\n+    }\n+\n+    @Test\n     public void testLInfDistanceInt() {\n         int[] p1 = { 3, 0 };\n         int[] p2 = { 0, 4 };\n-        assertEquals(4, MathUtils.distanceInf(p1, p2));\n-    }\n-\n+        Assert.assertEquals(4, MathUtils.distanceInf(p1, p2));\n+    }\n+\n+    @Test\n     public void testCheckOrder() {\n         MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15},\n                              MathUtils.OrderDirection.INCREASING, true);\n         try {\n             MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},\n                                  MathUtils.OrderDirection.INCREASING, true);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2},\n                                  MathUtils.OrderDirection.INCREASING, false);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},\n                                  MathUtils.OrderDirection.DECREASING, true);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},\n                                  MathUtils.OrderDirection.DECREASING, false);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NonMonotonousSequenceException e) {\n             // Expected\n         }\n     }\n \n+    @Test\n     public void testCheckFinite() {\n         try {\n             MathUtils.checkFinite(Double.POSITIVE_INFINITY);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NotFiniteNumberException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkFinite(Double.NEGATIVE_INFINITY);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NotFiniteNumberException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkFinite(Double.NaN);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NotFiniteNumberException e) {\n             // Expected\n         }\n \n         try {\n             MathUtils.checkFinite(new double[] {0, -1, Double.POSITIVE_INFINITY, -2, 3});\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NotFiniteNumberException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkFinite(new double[] {1, Double.NEGATIVE_INFINITY, -2, 3});\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NotFiniteNumberException e) {\n             // Expected\n         }\n         try {\n             MathUtils.checkFinite(new double[] {4, 3, -1, Double.NaN, -2, 1});\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NotFiniteNumberException e) {\n             // Expected\n         }\n     }\n \n+    @Test\n     public void testSortInPlace() {\n         final double[] x1 = {2,   5,  -3, 1,  4};\n         final double[] x2 = {4,  25,   9, 1, 16};\n         \n         MathUtils.sortInPlace(x1, x2, x3);\n \n-        assertEquals(-3,  x1[0], Math.ulp(1d));\n-        assertEquals(9,   x2[0], Math.ulp(1d));\n-        assertEquals(-27, x3[0], Math.ulp(1d));\n-\n-        assertEquals(1, x1[1], Math.ulp(1d));\n-        assertEquals(1, x2[1], Math.ulp(1d));\n-        assertEquals(1, x3[1], Math.ulp(1d));\n-\n-        assertEquals(2, x1[2], Math.ulp(1d));\n-        assertEquals(4, x2[2], Math.ulp(1d));\n-        assertEquals(8, x3[2], Math.ulp(1d));\n-\n-        assertEquals(4,  x1[3], Math.ulp(1d));\n-        assertEquals(16, x2[3], Math.ulp(1d));\n-        assertEquals(64, x3[3], Math.ulp(1d));\n-\n-        assertEquals(5,   x1[4], Math.ulp(1d));\n-        assertEquals(25,  x2[4], Math.ulp(1d));\n-        assertEquals(125, x3[4], Math.ulp(1d));\n-    }\n-\n+        Assert.assertEquals(-3,  x1[0], Math.ulp(1d));\n+        Assert.assertEquals(9,   x2[0], Math.ulp(1d));\n+        Assert.assertEquals(-27, x3[0], Math.ulp(1d));\n+\n+        Assert.assertEquals(1, x1[1], Math.ulp(1d));\n+        Assert.assertEquals(1, x2[1], Math.ulp(1d));\n+        Assert.assertEquals(1, x3[1], Math.ulp(1d));\n+\n+        Assert.assertEquals(2, x1[2], Math.ulp(1d));\n+        Assert.assertEquals(4, x2[2], Math.ulp(1d));\n+        Assert.assertEquals(8, x3[2], Math.ulp(1d));\n+\n+        Assert.assertEquals(4,  x1[3], Math.ulp(1d));\n+        Assert.assertEquals(16, x2[3], Math.ulp(1d));\n+        Assert.assertEquals(64, x3[3], Math.ulp(1d));\n+\n+        Assert.assertEquals(5,   x1[4], Math.ulp(1d));\n+        Assert.assertEquals(25,  x2[4], Math.ulp(1d));\n+        Assert.assertEquals(125, x3[4], Math.ulp(1d));\n+    }\n+\n+    @Test\n     public void testCopyOfInt() {\n         final int[] source = { Integer.MIN_VALUE,\n                                -1, 0, 1, 3, 113, 4769,\n                                Integer.MAX_VALUE };\n         final int[] dest = MathUtils.copyOf(source);\n \n-        assertEquals(dest.length, source.length);\n+        Assert.assertEquals(dest.length, source.length);\n         for (int i = 0; i < source.length; i++) {\n-            assertEquals(source[i], dest[i]);\n-        }\n-    }\n-\n+            Assert.assertEquals(source[i], dest[i]);\n+        }\n+    }\n+\n+    @Test\n     public void testCopyOfInt2() {\n         final int[] source = { Integer.MIN_VALUE,\n                                -1, 0, 1, 3, 113, 4769,\n         final int offset = 3;\n         final int[] dest = MathUtils.copyOf(source, source.length - offset);\n \n-        assertEquals(dest.length, source.length - offset);\n+        Assert.assertEquals(dest.length, source.length - offset);\n         for (int i = 0; i < source.length - offset; i++) {\n-            assertEquals(source[i], dest[i]);\n-        }\n-    }\n-\n+            Assert.assertEquals(source[i], dest[i]);\n+        }\n+    }\n+\n+    @Test\n     public void testCopyOfInt3() {\n         final int[] source = { Integer.MIN_VALUE,\n                                -1, 0, 1, 3, 113, 4769,\n         final int offset = 3;\n         final int[] dest = MathUtils.copyOf(source, source.length + offset);\n \n-        assertEquals(dest.length, source.length + offset);\n+        Assert.assertEquals(dest.length, source.length + offset);\n         for (int i = 0; i < source.length; i++) {\n-            assertEquals(source[i], dest[i]);\n+            Assert.assertEquals(source[i], dest[i]);\n         }\n         for (int i = source.length; i < source.length + offset; i++) {\n-            assertEquals(0, dest[i], 0);\n-        }\n-    }\n-\n+            Assert.assertEquals(0, dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n     public void testCopyOfDouble() {\n         final double[] source = { Double.NEGATIVE_INFINITY,\n                                   -Double.MAX_VALUE,\n                                   Double.POSITIVE_INFINITY };\n         final double[] dest = MathUtils.copyOf(source);\n \n-        assertEquals(dest.length, source.length);\n+        Assert.assertEquals(dest.length, source.length);\n         for (int i = 0; i < source.length; i++) {\n-            assertEquals(source[i], dest[i], 0);\n-        }\n-    }\n-\n+            Assert.assertEquals(source[i], dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n     public void testCopyOfDouble2() {\n         final double[] source = { Double.NEGATIVE_INFINITY,\n                                   -Double.MAX_VALUE,\n         final int offset = 3;\n         final double[] dest = MathUtils.copyOf(source, source.length - offset);\n \n-        assertEquals(dest.length, source.length - offset);\n+        Assert.assertEquals(dest.length, source.length - offset);\n         for (int i = 0; i < source.length - offset; i++) {\n-            assertEquals(source[i], dest[i], 0);\n-        }\n-    }\n-\n+            Assert.assertEquals(source[i], dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n     public void testCopyOfDouble3() {\n         final double[] source = { Double.NEGATIVE_INFINITY,\n                                   -Double.MAX_VALUE,\n         final int offset = 3;\n         final double[] dest = MathUtils.copyOf(source, source.length + offset);\n \n-        assertEquals(dest.length, source.length + offset);\n+        Assert.assertEquals(dest.length, source.length + offset);\n         for (int i = 0; i < source.length; i++) {\n-            assertEquals(source[i], dest[i], 0);\n+            Assert.assertEquals(source[i], dest[i], 0);\n         }\n         for (int i = source.length; i < source.length + offset; i++) {\n-            assertEquals(0, dest[i], 0);\n-        }\n-    }\n-\n+            Assert.assertEquals(0, dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n     public void testCheckNotNull1() {\n         try {\n             Object obj = null;\n         }\n     }\n \n+    @Test\n     public void testCheckNotNull2() {\n         try {\n             double[] array = null;\n-            MathUtils.checkNotNull(array, LocalizedFormats.INPUT_ARRAY, null);\n+            MathUtils.checkNotNull(array, LocalizedFormats.INPUT_ARRAY);\n         } catch (NullArgumentException e) {\n             // Expected.\n         }\n--- a/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n import java.util.Random;\n import java.util.Set;\n \n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n \n /**\n  * Test cases for the {@link OpenIntToDoubleHashMap}.\n  */\n-public class OpenIntToDoubleHashMapTest extends TestCase {\n+public class OpenIntToDoubleHashMapTest {\n \n     private Map<Integer, Double> javaMap = new HashMap<Integer, Double>();\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    @Before\n+    public void setUp() throws Exception {\n         javaMap.put(50, 100.0);\n         javaMap.put(75, 75.0);\n         javaMap.put(25, 500.0);\n         return map;\n     }\n \n+    @Test\n     public void testPutAndGetWith0ExpectedSize() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);\n         assertPutAndGet(map);\n     }\n \n+    @Test\n     public void testPutAndGetWithExpectedSize() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);\n         assertPutAndGet(map);\n     }\n \n+    @Test\n     public void testPutAndGet() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n         assertPutAndGet(map);\n \n     private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,\n             Set<Integer> keysInMap) {\n-        assertEquals(mapSize, map.size());\n+        Assert.assertEquals(mapSize, map.size());\n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n             if (!keysInMap.contains(mapEntry.getKey()))\n                 ++mapSize;\n-            assertEquals(mapSize, map.size());\n-            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n-        }\n-    }\n-\n+            Assert.assertEquals(mapSize, map.size());\n+            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n+        }\n+    }\n+\n+    @Test\n     public void testPutAbsentOnExisting() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         int size = javaMap.size();\n         for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n-            assertEquals(++size, map.size());\n-            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n-        }\n-    }\n-\n+            Assert.assertEquals(++size, map.size());\n+            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n+        }\n+    }\n+\n+    @Test\n     public void testPutOnExisting() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n-            assertEquals(javaMap.size(), map.size());\n-            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n-        }\n-    }\n-\n+            Assert.assertEquals(javaMap.size(), map.size());\n+            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n+        }\n+    }\n+\n+    @Test\n     public void testGetAbsent() {\n         Map<Integer, Double> generated = generateAbsent();\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n \n         for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())\n-            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n-    }\n-\n+            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+    }\n+\n+    @Test\n     public void testGetFromEmpty() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n-        assertTrue(Double.isNaN(map.get(5)));\n-        assertTrue(Double.isNaN(map.get(0)));\n-        assertTrue(Double.isNaN(map.get(50)));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(map.get(5)));\n+        Assert.assertTrue(Double.isNaN(map.get(0)));\n+        Assert.assertTrue(Double.isNaN(map.get(50)));\n+    }\n+\n+    @Test\n     public void testRemove() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         int mapSize = javaMap.size();\n-        assertEquals(mapSize, map.size());\n+        Assert.assertEquals(mapSize, map.size());\n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n             map.remove(mapEntry.getKey());\n-            assertEquals(--mapSize, map.size());\n-            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+            Assert.assertEquals(--mapSize, map.size());\n+            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n         }\n \n         /* Ensure that put and get still work correctly after removals */\n     }\n \n     /* This time only remove some entries */\n+    @Test\n     public void testRemove2() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         int mapSize = javaMap.size();\n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n             keysInMap.remove(mapEntry.getKey());\n             map.remove(mapEntry.getKey());\n-            assertEquals(--mapSize, map.size());\n-            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+            Assert.assertEquals(--mapSize, map.size());\n+            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n             if (count++ > 5)\n                 break;\n         }\n         assertPutAndGet(map, mapSize, keysInMap);\n     }\n \n+    @Test\n     public void testRemoveFromEmpty() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n-        assertTrue(Double.isNaN(map.remove(50)));\n-    }\n-\n+        Assert.assertTrue(Double.isNaN(map.remove(50)));\n+    }\n+\n+    @Test\n     public void testRemoveAbsent() {\n         Map<Integer, Double> generated = generateAbsent();\n \n \n         for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {\n             map.remove(mapEntry.getKey());\n-            assertEquals(mapSize, map.size());\n-            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n+            Assert.assertEquals(mapSize, map.size());\n+            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n         }\n     }\n \n         return generated;\n     }\n \n+    @Test\n     public void testCopy() {\n         OpenIntToDoubleHashMap copy =\n             new OpenIntToDoubleHashMap(createFromJavaMap());\n-        assertEquals(javaMap.size(), copy.size());\n+        Assert.assertEquals(javaMap.size(), copy.size());\n \n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())\n-            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n-    }\n-\n+            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), copy.get(mapEntry.getKey()), 1));\n+    }\n+\n+    @Test\n     public void testContainsKey() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n-            assertTrue(map.containsKey(mapEntry.getKey()));\n+            Assert.assertTrue(map.containsKey(mapEntry.getKey()));\n         }\n         for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n-            assertFalse(map.containsKey(mapEntry.getKey()));\n+            Assert.assertFalse(map.containsKey(mapEntry.getKey()));\n         }\n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n             int key = mapEntry.getKey();\n-            assertTrue(map.containsKey(key));\n+            Assert.assertTrue(map.containsKey(key));\n             map.remove(key);\n-            assertFalse(map.containsKey(key));\n-        }\n-    }\n-\n+            Assert.assertFalse(map.containsKey(key));\n+        }\n+    }\n+\n+    @Test\n     public void testIterator() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n         for (int i = 0; i < map.size(); ++i) {\n-            assertTrue(iterator.hasNext());\n+            Assert.assertTrue(iterator.hasNext());\n             iterator.advance();\n             int key = iterator.key();\n-            assertTrue(map.containsKey(key));\n-            assertEquals(javaMap.get(key), map.get(key), 0);\n-            assertEquals(javaMap.get(key), iterator.value(), 0);\n-            assertTrue(javaMap.containsKey(key));\n-        }\n-        assertFalse(iterator.hasNext());\n+            Assert.assertTrue(map.containsKey(key));\n+            Assert.assertEquals(javaMap.get(key), map.get(key), 0);\n+            Assert.assertEquals(javaMap.get(key), iterator.value(), 0);\n+            Assert.assertTrue(javaMap.containsKey(key));\n+        }\n+        Assert.assertFalse(iterator.hasNext());\n         try {\n             iterator.advance();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NoSuchElementException nsee) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testConcurrentModification() {\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         OpenIntToDoubleHashMap.Iterator iterator = map.iterator();\n         map.put(3, 3);\n         try {\n             iterator.advance();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (ConcurrentModificationException cme) {\n             // expected\n         }\n      * loop was inconsistent with the first causing duplicate keys after the right sequence\n      * of puts and removes.\n      */\n+    @Test\n     public void testPutKeysWithCollisions() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n         int key1 = -1996012590;\n         map.put(key2, value1);\n         int key3 = 1008859686;\n         map.put(key3, value1);\n-        assertEquals(value1, map.get(key3));\n-        assertEquals(3, map.size());\n+        Assert.assertTrue(MathUtils.equals(value1, map.get(key3), 1));\n+        Assert.assertEquals(3, map.size());\n \n         map.remove(key2);\n         double value2 = 2.0;\n         map.put(key3, value2);\n-        assertEquals(value2, map.get(key3));\n-        assertEquals(2, map.size());\n+        Assert.assertTrue(MathUtils.equals(value2, map.get(key3), 1));\n+        Assert.assertEquals(2, map.size());\n     }\n \n     /**\n      * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n      * different manner.\n      */\n+    @Test\n     public void testPutKeysWithCollision2() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();\n         int key1 = 837989881;\n         map.put(key1, value1);\n         int key2 = 476463321;\n         map.put(key2, value1);\n-        assertEquals(2, map.size());\n-        assertEquals(value1, map.get(key2));\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertTrue(MathUtils.equals(value1, map.get(key2), 1));\n \n         map.remove(key1);\n         double value2 = 2.0;\n         map.put(key2, value2);\n-        assertEquals(1, map.size());\n-        assertEquals(value2, map.get(key2));\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertTrue(MathUtils.equals(value2, map.get(key2), 1));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/util/OpenIntToFieldTest.java\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToFieldTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionConversionException;\n import org.apache.commons.math.fraction.FractionField;\n-\n-import junit.framework.TestCase;\n-\n-public class OpenIntToFieldTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+\n+public class OpenIntToFieldTest {\n \n     private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>();\n     private FractionField field = FractionField.getInstance();\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    @Before\n+    public void setUp() throws FractionConversionException {\n         javaMap.put(50, new Fraction(100.0));\n         javaMap.put(75, new Fraction(75.0));\n         javaMap.put(25, new Fraction(500.0));\n         return map;\n     }\n \n+    @Test\n     public void testPutAndGetWith0ExpectedSize() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);\n         assertPutAndGet(map);\n     }\n \n+    @Test\n     public void testPutAndGetWithExpectedSize() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);\n         assertPutAndGet(map);\n     }\n \n+    @Test\n     public void testPutAndGet() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n         assertPutAndGet(map);\n \n     private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize,\n             Set<Integer> keysInMap) {\n-        assertEquals(mapSize, map.size());\n+        Assert.assertEquals(mapSize, map.size());\n         for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n             if (!keysInMap.contains(mapEntry.getKey()))\n                 ++mapSize;\n-            assertEquals(mapSize, map.size());\n-            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n-        }\n-    }\n-\n+            Assert.assertEquals(mapSize, map.size());\n+            Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    @Test\n     public void testPutAbsentOnExisting() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         int size = javaMap.size();\n         for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n-            assertEquals(++size, map.size());\n-            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n-        }\n-    }\n-\n+            Assert.assertEquals(++size, map.size());\n+            Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    @Test\n     public void testPutOnExisting() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n-            assertEquals(javaMap.size(), map.size());\n-            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n-        }\n-    }\n-\n+            Assert.assertEquals(javaMap.size(), map.size());\n+            Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    @Test\n     public void testGetAbsent() {\n         Map<Integer, Fraction> generated = generateAbsent();\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n \n         for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())\n-            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n-    }\n-\n+            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+    }\n+\n+    @Test\n     public void testGetFromEmpty() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n-        assertTrue(field.getZero().equals(map.get(5)));\n-        assertTrue(field.getZero().equals(map.get(0)));\n-        assertTrue(field.getZero().equals(map.get(50)));\n-    }\n-\n+        Assert.assertTrue(field.getZero().equals(map.get(5)));\n+        Assert.assertTrue(field.getZero().equals(map.get(0)));\n+        Assert.assertTrue(field.getZero().equals(map.get(50)));\n+    }\n+\n+    @Test\n     public void testRemove() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         int mapSize = javaMap.size();\n-        assertEquals(mapSize, map.size());\n+        Assert.assertEquals(mapSize, map.size());\n         for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n             map.remove(mapEntry.getKey());\n-            assertEquals(--mapSize, map.size());\n-            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+            Assert.assertEquals(--mapSize, map.size());\n+            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n         }\n \n         /* Ensure that put and get still work correctly after removals */\n     }\n \n     /* This time only remove some entries */\n+    @Test\n     public void testRemove2() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         int mapSize = javaMap.size();\n         for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n             keysInMap.remove(mapEntry.getKey());\n             map.remove(mapEntry.getKey());\n-            assertEquals(--mapSize, map.size());\n-            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+            Assert.assertEquals(--mapSize, map.size());\n+            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n             if (count++ > 5)\n                 break;\n         }\n         assertPutAndGet(map, mapSize, keysInMap);\n     }\n \n+    @Test\n     public void testRemoveFromEmpty() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n-        assertTrue(field.getZero().equals(map.remove(50)));\n-    }\n-\n+        Assert.assertTrue(field.getZero().equals(map.remove(50)));\n+    }\n+\n+    @Test\n     public void testRemoveAbsent() {\n         Map<Integer, Fraction> generated = generateAbsent();\n \n \n         for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {\n             map.remove(mapEntry.getKey());\n-            assertEquals(mapSize, map.size());\n-            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+            Assert.assertEquals(mapSize, map.size());\n+            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n         }\n     }\n \n         return generated;\n     }\n \n+    @Test\n     public void testCopy() {\n         OpenIntToFieldHashMap<Fraction> copy =\n             new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));\n-        assertEquals(javaMap.size(), copy.size());\n+        Assert.assertEquals(javaMap.size(), copy.size());\n \n         for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet())\n-            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n-    }\n-\n+            Assert.assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n+    }\n+\n+    @Test\n     public void testContainsKey() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n-            assertTrue(map.containsKey(mapEntry.getKey()));\n+            Assert.assertTrue(map.containsKey(mapEntry.getKey()));\n         }\n         for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {\n-            assertFalse(map.containsKey(mapEntry.getKey()));\n+            Assert.assertFalse(map.containsKey(mapEntry.getKey()));\n         }\n         for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n             int key = mapEntry.getKey();\n-            assertTrue(map.containsKey(key));\n+            Assert.assertTrue(map.containsKey(key));\n             map.remove(key);\n-            assertFalse(map.containsKey(key));\n-        }\n-    }\n-\n+            Assert.assertFalse(map.containsKey(key));\n+        }\n+    }\n+\n+    @Test\n     public void testIterator() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();\n         for (int i = 0; i < map.size(); ++i) {\n-            assertTrue(iterator.hasNext());\n+            Assert.assertTrue(iterator.hasNext());\n             iterator.advance();\n             int key = iterator.key();\n-            assertTrue(map.containsKey(key));\n-            assertEquals(javaMap.get(key), map.get(key));\n-            assertEquals(javaMap.get(key), iterator.value());\n-            assertTrue(javaMap.containsKey(key));\n-        }\n-        assertFalse(iterator.hasNext());\n+            Assert.assertTrue(map.containsKey(key));\n+            Assert.assertEquals(javaMap.get(key), map.get(key));\n+            Assert.assertEquals(javaMap.get(key), iterator.value());\n+            Assert.assertTrue(javaMap.containsKey(key));\n+        }\n+        Assert.assertFalse(iterator.hasNext());\n         try {\n             iterator.advance();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (NoSuchElementException nsee) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testConcurrentModification() {\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();\n         map.put(3, new Fraction(3));\n         try {\n             iterator.advance();\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (ConcurrentModificationException cme) {\n             // expected\n         }\n      * loop was inconsistent with the first causing duplicate keys after the right sequence\n      * of puts and removes.\n      */\n+    @Test\n     public void testPutKeysWithCollisions() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n         int key1 = -1996012590;\n         map.put(key2, value1);\n         int key3 = 1008859686;\n         map.put(key3, value1);\n-        assertEquals(value1, map.get(key3));\n-        assertEquals(3, map.size());\n+        Assert.assertEquals(value1, map.get(key3));\n+        Assert.assertEquals(3, map.size());\n \n         map.remove(key2);\n         Fraction value2 = new Fraction(2);\n         map.put(key3, value2);\n-        assertEquals(value2, map.get(key3));\n-        assertEquals(2, map.size());\n+        Assert.assertEquals(value2, map.get(key3));\n+        Assert.assertEquals(2, map.size());\n     }\n \n     /**\n      * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n      * different manner.\n      */\n+    @Test\n     public void testPutKeysWithCollision2() {\n         OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field);\n         int key1 = 837989881;\n         map.put(key1, value1);\n         int key2 = 476463321;\n         map.put(key2, value1);\n-        assertEquals(2, map.size());\n-        assertEquals(value1, map.get(key2));\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertEquals(value1, map.get(key2));\n \n         map.remove(key1);\n         Fraction value2 = new Fraction(2);\n         map.put(key2, value2);\n-        assertEquals(1, map.size());\n-        assertEquals(value2, map.get(key2));\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(value2, map.get(key2));\n     }\n \n \n--- a/src/test/java/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+++ b/src/test/java/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n package org.apache.commons.math.util;\n import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.random.RandomData;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n \n \n /**\n  */\n public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {\n \n-    public ResizableDoubleArrayTest(String name) {\n-        super( name );\n-    }\n-\n-    @Override\n-    protected void tearDown() throws Exception {\n+    @After\n+    public void tearDown() throws Exception {\n         da = null;\n         ra = null;\n     }\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    @Before\n+    public void setUp() throws Exception {\n         da = new ResizableDoubleArray();\n         ra = new ResizableDoubleArray();\n     }\n \n+    @Test\n     public void testConstructors() {\n         float defaultExpansionFactor = 2.0f;\n         float defaultContractionCriteria = 2.5f;\n         int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;\n \n         ResizableDoubleArray testDa = new ResizableDoubleArray(2);\n-        assertEquals(0, testDa.getNumElements());\n-        assertEquals(2, testDa.getInternalLength());\n-        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n-        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n-        assertEquals(defaultMode, testDa.getExpansionMode());\n+        Assert.assertEquals(0, testDa.getNumElements());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n+        Assert.assertEquals(defaultMode, testDa.getExpansionMode());\n         try {\n             da = new ResizableDoubleArray(-1);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         \n         testDa = new ResizableDoubleArray((double[]) null);\n-        assertEquals(0, testDa.getNumElements());\n+        Assert.assertEquals(0, testDa.getNumElements());\n         \n         double[] initialArray = new double[] { 0, 1, 2 };        \n         testDa = new ResizableDoubleArray(initialArray);\n-        assertEquals(3, testDa.getNumElements());\n+        Assert.assertEquals(3, testDa.getNumElements());\n \n         testDa = new ResizableDoubleArray(2, 2.0f);\n-        assertEquals(0, testDa.getNumElements());\n-        assertEquals(2, testDa.getInternalLength());\n-        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n-        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n-        assertEquals(defaultMode, testDa.getExpansionMode());\n+        Assert.assertEquals(0, testDa.getNumElements());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n+        Assert.assertEquals(defaultMode, testDa.getExpansionMode());\n \n         try {\n             da = new ResizableDoubleArray(2, 0.5f);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         testDa = new ResizableDoubleArray(2, 3.0f);\n-        assertEquals(3.0f, testDa.getExpansionFactor(), 0);\n-        assertEquals(3.5f, testDa.getContractionCriteria(), 0);\n+        Assert.assertEquals(3.0f, testDa.getExpansionFactor(), 0);\n+        Assert.assertEquals(3.5f, testDa.getContractionCriteria(), 0);\n \n         testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);\n-        assertEquals(0, testDa.getNumElements());\n-        assertEquals(2, testDa.getInternalLength());\n-        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n-        assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n-        assertEquals(defaultMode, testDa.getExpansionMode());\n+        Assert.assertEquals(0, testDa.getNumElements());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        Assert.assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n+        Assert.assertEquals(defaultMode, testDa.getExpansionMode());\n \n         try {\n             da = new ResizableDoubleArray(2, 2.0f, 1.5f);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n \n         testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n-        assertEquals(0, testDa.getNumElements());\n-        assertEquals(2, testDa.getInternalLength());\n-        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n-        assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n-        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,\n+        Assert.assertEquals(0, testDa.getNumElements());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n+        Assert.assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n+        Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE,\n                 testDa.getExpansionMode());\n \n         try {\n             da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         testDa.addElement(2.0);\n         testDa.addElement(3.2);\n         ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);\n-        assertEquals(copyDa, testDa);\n-        assertEquals(testDa, copyDa);\n-    }\n-\n-\n+        Assert.assertEquals(copyDa, testDa);\n+        Assert.assertEquals(testDa, copyDa);\n+    }\n+\n+\n+    @Test\n     public void testSetElementArbitraryExpansion() {\n \n         // MULTIPLICATIVE_MODE\n         // Expand the array arbitrarily to 1000 items\n         da.setElement(1000, 3.4);\n \n-        assertEquals( \"The number of elements should now be 1001, it isn't\",\n+        Assert.assertEquals( \"The number of elements should now be 1001, it isn't\",\n                 da.getNumElements(), 1001);\n \n-        assertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n+        Assert.assertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n                 da.getElement( 760 ), Double.MIN_VALUE );\n \n-        assertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000),\n+        Assert.assertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000),\n                 Double.MIN_VALUE );\n-        assertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0),\n+        Assert.assertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0),\n                 Double.MIN_VALUE);\n \n         // Make sure numElements and expansion work correctly for expansion boundary cases\n         da.addElement(2.0);\n         da.addElement(4.0);\n         da.addElement(6.0);\n-        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n-        assertEquals(3, da.getNumElements());\n+        Assert.assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n+        Assert.assertEquals(3, da.getNumElements());\n         da.setElement(3, 7.0);\n-        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n-        assertEquals(4, da.getNumElements());\n+        Assert.assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());\n+        Assert.assertEquals(4, da.getNumElements());\n         da.setElement(10, 10.0);\n-        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n-        assertEquals(11, da.getNumElements());\n+        Assert.assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n+        Assert.assertEquals(11, da.getNumElements());\n         da.setElement(9, 10.0);\n-        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n-        assertEquals(11, da.getNumElements());\n+        Assert.assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n+        Assert.assertEquals(11, da.getNumElements());\n \n         try {\n             da.setElement(-2, 3);\n-            fail(\"Expecting ArrayIndexOutOfBoundsException for negative index\");\n+            Assert.fail(\"Expecting ArrayIndexOutOfBoundsException for negative index\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n-        assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n         testDa.addElement(1d);\n         testDa.addElement(1d);\n-        assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n         testDa.addElement(1d);\n-        assertEquals(4, testDa.getInternalLength());\n+        Assert.assertEquals(4, testDa.getInternalLength());\n     }\n \n     @Override\n+    @Test\n     public void testAdd1000() {\n         super.testAdd1000();\n-        assertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+        Assert.assertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n                 \"16 and an expansion factor of 2.0\",\n                 1024, ((ResizableDoubleArray) da).getInternalLength());\n     }\n     \n+    @Test\n     public void testAddElements() {\n         ResizableDoubleArray testDa = new ResizableDoubleArray();\n         \n         // MULTIPLICATIVE_MODE\n         testDa.addElements(new double[] {4, 5, 6});\n-        assertEquals(3, testDa.getNumElements(), 0);\n-        assertEquals(4, testDa.getElement(0), 0);\n-        assertEquals(5, testDa.getElement(1), 0);\n-        assertEquals(6, testDa.getElement(2), 0);\n+        Assert.assertEquals(3, testDa.getNumElements(), 0);\n+        Assert.assertEquals(4, testDa.getElement(0), 0);\n+        Assert.assertEquals(5, testDa.getElement(1), 0);\n+        Assert.assertEquals(6, testDa.getElement(2), 0);\n         \n         testDa.addElements(new double[] {4, 5, 6});\n-        assertEquals(6, testDa.getNumElements());\n+        Assert.assertEquals(6, testDa.getNumElements());\n \n         // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)\n         testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,\n                 ResizableDoubleArray.ADDITIVE_MODE);        \n-        assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n         testDa.addElements(new double[] { 1d }); // x,0\n         testDa.addElements(new double[] { 2d }); // x,x\n         testDa.addElements(new double[] { 3d }); // x,x,x,0 -- expanded\n-        assertEquals(1d, testDa.getElement(0), 0);\n-        assertEquals(2d, testDa.getElement(1), 0);\n-        assertEquals(3d, testDa.getElement(2), 0);\n-        assertEquals(4, testDa.getInternalLength());  // x,x,x,0\n-        assertEquals(3, testDa.getNumElements());\n+        Assert.assertEquals(1d, testDa.getElement(0), 0);\n+        Assert.assertEquals(2d, testDa.getElement(1), 0);\n+        Assert.assertEquals(3d, testDa.getElement(2), 0);\n+        Assert.assertEquals(4, testDa.getInternalLength());  // x,x,x,0\n+        Assert.assertEquals(3, testDa.getNumElements());\n     }\n \n     @Override\n+    @Test\n     public void testAddElementRolling() {\n         super.testAddElementRolling();\n \n         da.addElement(1);\n         da.addElement(2);\n         da.addElementRolling(3);\n-        assertEquals(3, da.getElement(1), 0);\n+        Assert.assertEquals(3, da.getElement(1), 0);\n         da.addElementRolling(4);\n-        assertEquals(3, da.getElement(0), 0);\n-        assertEquals(4, da.getElement(1), 0);\n+        Assert.assertEquals(3, da.getElement(0), 0);\n+        Assert.assertEquals(4, da.getElement(1), 0);\n         da.addElement(5);\n-        assertEquals(5, da.getElement(2), 0);\n+        Assert.assertEquals(5, da.getElement(2), 0);\n         da.addElementRolling(6);\n-        assertEquals(4, da.getElement(0), 0);\n-        assertEquals(5, da.getElement(1), 0);\n-        assertEquals(6, da.getElement(2), 0);\n+        Assert.assertEquals(4, da.getElement(0), 0);\n+        Assert.assertEquals(5, da.getElement(1), 0);\n+        Assert.assertEquals(6, da.getElement(2), 0);\n \n         // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)\n         ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n-        assertEquals(2, testDa.getInternalLength());\n+        Assert.assertEquals(2, testDa.getInternalLength());\n         testDa.addElement(1d); // x,0\n         testDa.addElement(2d); // x,x\n         testDa.addElement(3d); // x,x,x,0 -- expanded\n-        assertEquals(1d, testDa.getElement(0), 0);\n-        assertEquals(2d, testDa.getElement(1), 0);\n-        assertEquals(3d, testDa.getElement(2), 0);\n-        assertEquals(4, testDa.getInternalLength());  // x,x,x,0\n-        assertEquals(3, testDa.getNumElements());\n+        Assert.assertEquals(1d, testDa.getElement(0), 0);\n+        Assert.assertEquals(2d, testDa.getElement(1), 0);\n+        Assert.assertEquals(3d, testDa.getElement(2), 0);\n+        Assert.assertEquals(4, testDa.getInternalLength());  // x,x,x,0\n+        Assert.assertEquals(3, testDa.getNumElements());\n         testDa.addElementRolling(4d);\n-        assertEquals(2d, testDa.getElement(0), 0);\n-        assertEquals(3d, testDa.getElement(1), 0);\n-        assertEquals(4d, testDa.getElement(2), 0);\n-        assertEquals(4, testDa.getInternalLength());  // 0,x,x,x\n-        assertEquals(3, testDa.getNumElements());\n+        Assert.assertEquals(2d, testDa.getElement(0), 0);\n+        Assert.assertEquals(3d, testDa.getElement(1), 0);\n+        Assert.assertEquals(4d, testDa.getElement(2), 0);\n+        Assert.assertEquals(4, testDa.getInternalLength());  // 0,x,x,x\n+        Assert.assertEquals(3, testDa.getNumElements());\n         testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract\n-        assertEquals(3d, testDa.getElement(0), 0);\n-        assertEquals(4d, testDa.getElement(1), 0);\n-        assertEquals(5d, testDa.getElement(2), 0);\n-        assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0\n-        assertEquals(3, testDa.getNumElements());\n+        Assert.assertEquals(3d, testDa.getElement(0), 0);\n+        Assert.assertEquals(4d, testDa.getElement(1), 0);\n+        Assert.assertEquals(5d, testDa.getElement(2), 0);\n+        Assert.assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0\n+        Assert.assertEquals(3, testDa.getNumElements());\n         try {\n             testDa.getElement(4);\n-            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+            Assert.fail(\"Expecting ArrayIndexOutOfBoundsException\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected\n         }\n         try {\n             testDa.getElement(-1);\n-            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+            Assert.fail(\"Expecting ArrayIndexOutOfBoundsException\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testSetNumberOfElements() {\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n-        assertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n+        Assert.assertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n \n         ((ResizableDoubleArray) da).setNumElements( 3 );\n-        assertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n+        Assert.assertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n \n         try {\n             ((ResizableDoubleArray) da).setNumElements( -3 );\n-            fail( \"Setting number of elements to negative should've thrown an exception\");\n+            Assert.fail( \"Setting number of elements to negative should've thrown an exception\");\n         } catch( IllegalArgumentException iae ) {\n         }\n \n         ((ResizableDoubleArray) da).setNumElements(1024);\n-        assertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n-        assertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n-\n-    }\n-\n+        Assert.assertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n+        Assert.assertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+\n+    }\n+\n+    @Test\n     public void testWithInitialCapacity() {\n \n         ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);\n-        assertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n+        Assert.assertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n \n         RandomData randomData = new RandomDataImpl();\n         int iterations = randomData.nextInt(100, 1000);\n             eDA2.addElement( i );\n         }\n \n-        assertEquals(\"Number of elements should be equal to \" + iterations, iterations, eDA2.getNumElements());\n+        Assert.assertEquals(\"Number of elements should be equal to \" + iterations, iterations, eDA2.getNumElements());\n \n         eDA2.addElement( 2.0 );\n \n-        assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n+        Assert.assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n                 iterations + 1 , eDA2.getNumElements() );\n     }\n \n+    @Test\n     public void testWithInitialCapacityAndExpansionFactor() {\n \n         ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);\n-        assertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n+        Assert.assertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n \n         RandomData randomData = new RandomDataImpl();\n         int iterations = randomData.nextInt(100, 3000);\n             eDA3.addElement( i );\n         }\n \n-        assertEquals(\"Number of elements should be equal to \" + iterations, iterations,eDA3.getNumElements());\n+        Assert.assertEquals(\"Number of elements should be equal to \" + iterations, iterations,eDA3.getNumElements());\n \n         eDA3.addElement( 2.0 );\n \n-        assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n+        Assert.assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n                 iterations +1, eDA3.getNumElements() );\n \n-        assertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n-    }\n-\n+        Assert.assertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n+    }\n+\n+    @Test\n     public void testDiscard() {\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n-        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        Assert.assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n \n         ((ResizableDoubleArray)da).discardFrontElements(5);\n-        assertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n-\n-        da.addElement(2.0);\n-        da.addElement(2.0);\n-        da.addElement(2.0);\n-        da.addElement(2.0);\n-        assertEquals( \"Number of elements should be 10\", 10, da.getNumElements());\n+        Assert.assertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n+\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        Assert.assertEquals( \"Number of elements should be 10\", 10, da.getNumElements());\n \n         ((ResizableDoubleArray)da).discardMostRecentElements(2);\n-        assertEquals( \"Number of elements should be 8\", 8, da.getNumElements());\n+        Assert.assertEquals( \"Number of elements should be 8\", 8, da.getNumElements());\n \n         try {\n             ((ResizableDoubleArray)da).discardFrontElements(-1);\n-            fail( \"Trying to discard a negative number of element is not allowed\");\n+            Assert.fail( \"Trying to discard a negative number of element is not allowed\");\n         } catch( Exception e ){\n         }\n \n         try {\n             ((ResizableDoubleArray)da).discardMostRecentElements(-1);\n-            fail( \"Trying to discard a negative number of element is not allowed\");\n+            Assert.fail( \"Trying to discard a negative number of element is not allowed\");\n         } catch( Exception e ){\n         }\n \n         try {\n             ((ResizableDoubleArray)da).discardFrontElements( 10000 );\n-            fail( \"You can't discard more elements than the array contains\");\n+            Assert.fail( \"You can't discard more elements than the array contains\");\n         } catch( Exception e ){\n         }\n \n         try {\n             ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );\n-            fail( \"You can't discard more elements than the array contains\");\n+            Assert.fail( \"You can't discard more elements than the array contains\");\n         } catch( Exception e ){\n         }\n \n     }\n \n+    @Test\n     public void testSubstitute() {\n \n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n-        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        Assert.assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n \n         ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n \n-        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        Assert.assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n \n         try {\n             ((ResizableDoubleArray)da).discardMostRecentElements(10);\n         } catch( Exception e ){\n-            fail( \"Trying to discard a negative number of element is not allowed\");\n+            Assert.fail( \"Trying to discard a negative number of element is not allowed\");\n         }\n \n         ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n \n-        assertEquals( \"Number of elements should be 1\", 1, da.getNumElements());\n-\n-    }\n-\n+        Assert.assertEquals( \"Number of elements should be 1\", 1, da.getNumElements());\n+\n+    }\n+\n+    @Test\n     public void testMutators() {\n         ((ResizableDoubleArray)da).setContractionCriteria(10f);\n-        assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);\n+        Assert.assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);\n         ((ResizableDoubleArray)da).setExpansionFactor(8f);\n-        assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);\n+        Assert.assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);\n         try {\n             ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         ((ResizableDoubleArray)da).setExpansionMode(\n                 ResizableDoubleArray.ADDITIVE_MODE);\n-        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,\n+        Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE,\n                 ((ResizableDoubleArray)da).getExpansionMode());\n         try {\n             ((ResizableDoubleArray)da).setExpansionMode(-1);\n-            fail (\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n     public void testEqualsAndHashCode() throws Exception {\n \n         // Wrong type\n         ResizableDoubleArray first = new ResizableDoubleArray();\n         Double other = new Double(2);\n-        assertFalse(first.equals(other));\n+        Assert.assertFalse(first.equals(other));\n \n         // Null\n         other = null;\n-        assertFalse(first.equals(other));\n+        Assert.assertFalse(first.equals(other));\n \n         // Reflexive\n-        assertTrue(first.equals(first));\n+        Assert.assertTrue(first.equals(first));\n \n         // Argumentless constructor\n         ResizableDoubleArray second = new ResizableDoubleArray();\n     }\n \n     private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {\n-        assertTrue(b.equals(a));\n-        assertTrue(a.equals(b));\n-        assertEquals(a.hashCode(), b.hashCode());\n+        Assert.assertTrue(b.equals(a));\n+        Assert.assertTrue(a.equals(b));\n+        Assert.assertEquals(a.hashCode(), b.hashCode());\n     }\n \n     private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {\n-        assertFalse(b.equals(a));\n-        assertFalse(a.equals(b));\n-        assertFalse(a.hashCode() == b.hashCode());\n+        Assert.assertFalse(b.equals(a));\n+        Assert.assertFalse(a.equals(b));\n+        Assert.assertFalse(a.hashCode() == b.hashCode());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/util/TransformerMapTest.java\n+++ b/src/test/java/org/apache/commons/math/util/TransformerMapTest.java\n package org.apache.commons.math.util;\n \n import org.apache.commons.math.TestUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class TransformerMapTest extends TestCase {\n+public class TransformerMapTest {\n     /**\n      *\n      */\n+    @Test\n     public void testPutTransformer(){\n         NumberTransformer expected = new DefaultTransformer();\n \n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertEquals(expected, map.getTransformer(TransformerMapTest.class));\n+        Assert.assertEquals(expected, map.getTransformer(TransformerMapTest.class));\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testContainsClass(){\n         NumberTransformer expected = new DefaultTransformer();\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertTrue(map.containsClass(TransformerMapTest.class));\n+        Assert.assertTrue(map.containsClass(TransformerMapTest.class));\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testContainsTransformer(){\n         NumberTransformer expected = new DefaultTransformer();\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertTrue(map.containsTransformer(expected));\n+        Assert.assertTrue(map.containsTransformer(expected));\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testRemoveTransformer(){\n         NumberTransformer expected = new DefaultTransformer();\n \n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertTrue(map.containsClass(TransformerMapTest.class));\n-        assertTrue(map.containsTransformer(expected));\n+        Assert.assertTrue(map.containsClass(TransformerMapTest.class));\n+        Assert.assertTrue(map.containsTransformer(expected));\n         map.removeTransformer(TransformerMapTest.class);\n-        assertFalse(map.containsClass(TransformerMapTest.class));\n-        assertFalse(map.containsTransformer(expected));\n+        Assert.assertFalse(map.containsClass(TransformerMapTest.class));\n+        Assert.assertFalse(map.containsTransformer(expected));\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testClear(){\n         NumberTransformer expected = new DefaultTransformer();\n \n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertTrue(map.containsClass(TransformerMapTest.class));\n+        Assert.assertTrue(map.containsClass(TransformerMapTest.class));\n         map.clear();\n-        assertFalse(map.containsClass(TransformerMapTest.class));\n+        Assert.assertFalse(map.containsClass(TransformerMapTest.class));\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testClasses(){\n         NumberTransformer expected = new DefaultTransformer();\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertTrue(map.classes().contains(TransformerMapTest.class));\n+        Assert.assertTrue(map.classes().contains(TransformerMapTest.class));\n     }\n \n     /**\n      *\n      */\n+    @Test\n     public void testTransformers(){\n         NumberTransformer expected = new DefaultTransformer();\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertTrue(map.transformers().contains(expected));\n+        Assert.assertTrue(map.transformers().contains(expected));\n     }\n \n+    @Test\n     public void testSerial(){\n         NumberTransformer expected = new DefaultTransformer();\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n-        assertEquals(map, TestUtils.serializeAndRecover(map));\n+        Assert.assertEquals(map, TestUtils.serializeAndRecover(map));\n     }\n \n }", "timestamp": 1300641854, "metainfo": ""}