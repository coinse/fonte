{"sha": "1d822a85cc7f1211a2ef32f33467572eb6f20d33", "log": "Added conversion of gradients and Hessians from spherical to Cartesian coordinates in 3D.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphericalCoordinates.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math3.util.FastMath;\n+\n+/** This class provides conversions related to <a\n+ * href=\"http://mathworld.wolfram.com/SphericalCoordinates.html\">spherical coordinates</a>.\n+ * <p>\n+ * The conventions used here are the mathematical ones, i.e. spherical coordinates are\n+ * related to Cartesian coordinates as follows:\n+ * </p>\n+ * <ul>\n+ *   <li>x = r cos(&theta;) sin(&Phi;)</li>\n+ *   <li>y = r sin(&theta;) sin(&Phi;)</li>\n+ *   <li>z = r cos(&Phi;)</li>\n+ * </ul>\n+ * <ul>\n+ *   <li>r       = &radic;(x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>)</li>\n+ *   <li>&theta; = atan2(y, x)</li>\n+ *   <li>&Phi;   = acos(z/r)</li>\n+ * </ul>\n+ * <p>\n+ * r is the radius, &theta; is the azimuthal angle in the x-y plane and &Phi; is the polar\n+ * (co-latitude) angle. These conventions are <em>different</em> from the conventions used\n+ * in physics (and in particular in spherical harmonics) where the meanings of &theta; and\n+ * &Phi; are reversed.\n+ * </p>\n+ * <p>\n+ * This class provides conversion of coordinates and also of gradient and Hessian\n+ * between spherical and Cartesian coordinates.\n+ * </p>\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class SphericalCoordinates implements Serializable {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20130206L;\n+\n+    /** Cartesian coordinates. */\n+    private final Vector3D v;\n+\n+    /** Radius. */\n+    private final double r;\n+\n+    /** Azimuthal angle in the x-y plane &theta;. */\n+    private final double theta;\n+\n+    /** Polar angle (co-latitude) &phi;. */\n+    private final double phi;\n+\n+    /** Jacobian of (r, &theta; &phi). */\n+    private double[][] jacobian;\n+\n+    /** Hessian of radius. */\n+    private double[][] rHessian;\n+\n+    /** Hessian of azimuthal angle in the x-y plane &theta;. */\n+    private double[][] thetaHessian;\n+\n+    /** Hessian of polar (co-latitude) angle &Phi;. */\n+    private double[][] phiHessian;\n+\n+    /** Build a spherical coordinates transformer from Cartesian coordinates.\n+     * @param v Cartesian coordinates\n+     */\n+    public SphericalCoordinates(final Vector3D v) {\n+\n+        // Cartesian coordinates\n+        this.v = v;\n+\n+        // remaining spherical coordinates\n+        this.r     = v.getNorm();\n+        this.theta = v.getAlpha();\n+        this.phi   = FastMath.acos(v.getZ() / r);\n+\n+    }\n+\n+    /** Build a spherical coordinates transformer from spherical coordinates.\n+     * @param r radius\n+     * @param theta azimuthal angle in x-y place\n+     * @param phi polar (co-latitude) angle\n+     */\n+    public SphericalCoordinates(final double r, final double theta, final double phi) {\n+\n+        final double cosTheta = FastMath.cos(theta);\n+        final double sinTheta = FastMath.sin(theta);\n+        final double cosPhi   = FastMath.cos(phi);\n+        final double sinPhi   = FastMath.sin(phi);\n+\n+        // spherical coordinates\n+        this.r     = r;\n+        this.theta = theta;\n+        this.phi   = phi;\n+\n+        // Cartesian coordinates\n+        this.v  = new Vector3D(r * cosTheta * sinPhi,\n+                               r * sinTheta * sinPhi,\n+                               r * cosPhi);\n+\n+    }\n+\n+    /** Get the Cartesian coordinates.\n+     * @return Cartesian coordinates\n+     */\n+    public Vector3D getCartesian() {\n+        return v;\n+    }\n+\n+    /** Get the radius.\n+     * @return radius r\n+     * @see #getTheta()\n+     * @see #getPhi()\n+     */\n+    public double getR() {\n+        return r;\n+    }\n+\n+    /** Get the azimuthal angle in x-y plane.\n+     * @return azimuthal angle in x-y plane &theta;\n+     * @see #getR()\n+     * @see #getPhi()\n+     */\n+    public double getTheta() {\n+        return theta;\n+    }\n+\n+    /** Get the polar (co-latitude) angle.\n+     * @return polar (co-latitude) angle &Phi;\n+     * @see #getR()\n+     * @see #getTheta()\n+     */\n+    public double getPhi() {\n+        return phi;\n+    }\n+\n+    /** Convert a gradient with respect to spherical coordinates into a gradient\n+     * with respect to Cartesian coordinates.\n+     * @param sGradient gradient with respect to spherical coordinates\n+     * {df/dr, df/d&theta;, df/d&Phi;}\n+     * @return gradient with respect to Cartesian coordinates\n+     * {df/dx, df/dy, df/dz}\n+     */\n+    public double[] toCartesianGradient(final double[] sGradient) {\n+\n+        // lazy evaluation of Jacobian\n+        computeJacobian();\n+\n+        // compose derivatives as gradient^T . J\n+        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\n+        return new double[] {\n+            sGradient[0] * jacobian[0][0] + sGradient[1] * jacobian[1][0] + sGradient[2] * jacobian[2][0],\n+            sGradient[0] * jacobian[0][1] + sGradient[1] * jacobian[1][1] + sGradient[2] * jacobian[2][1],\n+            sGradient[0] * jacobian[0][2]                                 + sGradient[2] * jacobian[2][2]\n+        };\n+\n+    }\n+\n+    /** Convert a Hessian with respect to spherical coordinates into a Hessian\n+     * with respect to Cartesian coordinates.\n+     * <p>\n+     * As Hessian are always symmetric, we use only the lower left part of the provided\n+     * spherical Hessian, so the upper part may not be initialized. However, we still\n+     * do fill up the complete array we create, with guaranteed symmetry.\n+     * </p>\n+     * @param sHessian Hessian with respect to spherical coordinates\n+     * {{d<sup>2</sup>f/dr<sup>2</sup>, d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/drd&Phi;},\n+     *  {d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/d&theta;<sup>2</sup>, d<sup>2</sup>f/d&theta;d&Phi;},\n+     *  {d<sup>2</sup>f/drd&Phi;, d<sup>2</sup>f/d&theta;d&Phi;, d<sup>2</sup>f/d&Phi;<sup>2</sup>}\n+     * @param sGradient gradient with respect to spherical coordinates\n+     * {df/dr, df/d&theta;, df/d&Phi;}\n+     * @return Hessian with respect to Cartesian coordinates\n+     * {{d<sup>2</sup>f/dx<sup>2</sup>, d<sup>2</sup>f/rGradient.getY(), d<sup>2</sup>f/dxdz},\n+     *  {d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dy<sup>2</sup>, d<sup>2</sup>f/dydz},\n+     *  {d<sup>2</sup>f/dxdz, d<sup>2</sup>f/dydz, d<sup>2</sup>f/dz<sup>2</sup>}}\n+     */\n+    public double[][] toCartesianHessian(final double[][] sHessian, final double[] sGradient) {\n+\n+        computeJacobian();\n+        computeHessians();\n+\n+        // compose derivative as J^T . H_f . J + df/dr H_r + df/dtheta H_theta + df/dphi H_phi\n+        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\n+        // and H_theta is only a 2x2 matrix as it does not depend on z\n+        final double[][] hj = new double[3][3];\n+        final double[][] cHessian = new double[3][3];\n+\n+        // compute H_f . J\n+        // beware we use ONLY the lower-left part of sHessian\n+        hj[0][0] = sHessian[0][0] * jacobian[0][0] + sHessian[1][0] * jacobian[1][0] + sHessian[2][0] * jacobian[2][0];\n+        hj[0][1] = sHessian[0][0] * jacobian[0][1] + sHessian[1][0] * jacobian[1][1] + sHessian[2][0] * jacobian[2][1];\n+        hj[0][2] = sHessian[0][0] * jacobian[0][2]                                   + sHessian[2][0] * jacobian[2][2];\n+        hj[1][0] = sHessian[1][0] * jacobian[0][0] + sHessian[1][1] * jacobian[1][0] + sHessian[2][1] * jacobian[2][0];\n+        hj[1][1] = sHessian[1][0] * jacobian[0][1] + sHessian[1][1] * jacobian[1][1] + sHessian[2][1] * jacobian[2][1];\n+        hj[1][2] = sHessian[1][0] * jacobian[0][2]                                   + sHessian[2][1] * jacobian[2][2];\n+        hj[2][0] = sHessian[2][0] * jacobian[0][0] + sHessian[2][1] * jacobian[1][0] + sHessian[2][2] * jacobian[2][0];\n+        hj[2][1] = sHessian[2][0] * jacobian[0][1] + sHessian[2][1] * jacobian[1][1] + sHessian[2][2] * jacobian[2][1];\n+        hj[2][2] = sHessian[2][0] * jacobian[0][2]                                   + sHessian[2][2] * jacobian[2][2];\n+\n+        // compute lower-left part of J^T . H_f . J\n+        cHessian[0][0] = jacobian[0][0] * hj[0][0] + jacobian[1][0] * hj[1][0] + jacobian[2][0] * hj[2][0];\n+        cHessian[1][0] = jacobian[0][1] * hj[0][0] + jacobian[1][1] * hj[1][0] + jacobian[2][1] * hj[2][0];\n+        cHessian[2][0] = jacobian[0][2] * hj[0][0]                             + jacobian[2][2] * hj[2][0];\n+        cHessian[1][1] = jacobian[0][1] * hj[0][1] + jacobian[1][1] * hj[1][1] + jacobian[2][1] * hj[2][1];\n+        cHessian[2][1] = jacobian[0][2] * hj[0][1]                             + jacobian[2][2] * hj[2][1];\n+        cHessian[2][2] = jacobian[0][2] * hj[0][2]                             + jacobian[2][2] * hj[2][2];\n+\n+        // add gradient contribution\n+        cHessian[0][0] += sGradient[0] * rHessian[0][0] + sGradient[1] * thetaHessian[0][0] + sGradient[2] * phiHessian[0][0];\n+        cHessian[1][0] += sGradient[0] * rHessian[1][0] + sGradient[1] * thetaHessian[1][0] + sGradient[2] * phiHessian[1][0];\n+        cHessian[2][0] += sGradient[0] * rHessian[2][0]                                     + sGradient[2] * phiHessian[2][0];\n+        cHessian[1][1] += sGradient[0] * rHessian[1][1] + sGradient[1] * thetaHessian[1][1] + sGradient[2] * phiHessian[1][1];\n+        cHessian[2][1] += sGradient[0] * rHessian[2][1]                                     + sGradient[2] * phiHessian[2][1];\n+        cHessian[2][2] += sGradient[0] * rHessian[2][2]                                     + sGradient[2] * phiHessian[2][2];\n+\n+        // ensure symmetry\n+        cHessian[0][1] = cHessian[1][0];\n+        cHessian[0][2] = cHessian[2][0];\n+        cHessian[1][2] = cHessian[2][1];\n+\n+        return cHessian;\n+\n+    }\n+\n+    /** Lazy evaluation of (r, &theta;, &phi;) Jacobian.\n+     */\n+    private void computeJacobian() {\n+        if (jacobian == null) {\n+\n+            // intermediate variables\n+            final double x    = v.getX();\n+            final double y    = v.getY();\n+            final double z    = v.getZ();\n+            final double rho2 = x * x + y * y;\n+            final double rho  = FastMath.sqrt(rho2);\n+            final double r2   = rho2 + z * z;\n+\n+            jacobian = new double[3][3];\n+\n+            // row representing the gradient of r\n+            jacobian[0][0] = x / r;\n+            jacobian[0][1] = y / r;\n+            jacobian[0][2] = z / r;\n+\n+            // row representing the gradient of theta\n+            jacobian[1][0] = -y / rho2;\n+            jacobian[1][1] =  x / rho2;\n+            // jacobian[1][2] is already set to 0 at allocation time\n+\n+            // row representing the gradient of phi\n+            jacobian[2][0] = x * z / (rho * r2);\n+            jacobian[2][1] = y * z / (rho * r2);\n+            jacobian[2][2] = -rho / r2;\n+\n+        }\n+    }\n+\n+    /** Lazy evaluation of Hessians.\n+     */\n+    private void computeHessians() {\n+\n+        if (rHessian == null) {\n+\n+            // intermediate variables\n+            final double x      = v.getX();\n+            final double y      = v.getY();\n+            final double z      = v.getZ();\n+            final double x2     = x * x;\n+            final double y2     = y * y;\n+            final double z2     = z * z;\n+            final double rho2   = x2 + y2;\n+            final double rho    = FastMath.sqrt(rho2);\n+            final double r2     = rho2 + z2;\n+            final double xOr    = x / r;\n+            final double yOr    = y / r;\n+            final double zOr    = z / r;\n+            final double xOrho2 = x / rho2;\n+            final double yOrho2 = y / rho2;\n+            final double xOr3   = xOr / r2;\n+            final double yOr3   = yOr / r2;\n+            final double zOr3   = zOr / r2;\n+\n+            // lower-left part of Hessian of r\n+            rHessian = new double[3][3];\n+            rHessian[0][0] = y * yOr3 + z * zOr3;\n+            rHessian[1][0] = -x * yOr3;\n+            rHessian[2][0] = -z * xOr3;\n+            rHessian[1][1] = x * xOr3 + z * zOr3;\n+            rHessian[2][1] = -y * zOr3;\n+            rHessian[2][2] = x * xOr3 + y * yOr3;\n+\n+            // upper-right part is symmetric\n+            rHessian[0][1] = rHessian[1][0];\n+            rHessian[0][2] = rHessian[2][0];\n+            rHessian[1][2] = rHessian[2][1];\n+\n+            // lower-left part of Hessian of azimuthal angle theta\n+            thetaHessian = new double[2][2];\n+            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n+            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n+            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n+\n+            // upper-right part is symmetric\n+            thetaHessian[0][1] = thetaHessian[1][0];\n+\n+            // lower-left part of Hessian of polar (co-latitude) angle phi\n+            final double rhor2       = rho * r2;\n+            final double rho2r2      = rho * rhor2;\n+            final double rhor4       = rhor2 * r2;\n+            final double rho3r4      = rhor4 * rho2;\n+            final double r2P2rho2    = 3 * rho2 + z2;\n+            phiHessian = new double[3][3];\n+            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n+            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n+            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n+            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n+            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n+            phiHessian[2][2] = 2 * rho * zOr3 / r;\n+\n+            // upper-right part is symmetric\n+            phiHessian[0][1] = phiHessian[1][0];\n+            phiHessian[0][2] = phiHessian[2][0];\n+            phiHessian[1][2] = phiHessian[2][1];\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Replace the instance with a data transfer object for serialization.\n+     * @return data transfer object that will be serialized\n+     */\n+    private Object writeReplace() {\n+        return new DataTransferObject(v.getX(), v.getY(), v.getZ());\n+    }\n+\n+    /** Internal class used only for serialization. */\n+    private static class DataTransferObject implements Serializable {\n+\n+        /** Serializable UID. */\n+        private static final long serialVersionUID = 20130206L;\n+\n+        /** Abscissa.\n+         * @serial\n+         */\n+        private final double x;\n+\n+        /** Ordinate.\n+         * @serial\n+         */\n+        private final double y;\n+\n+        /** Height.\n+         * @serial\n+         */\n+        private final double z;\n+\n+        /** Simple constructor.\n+         * @param x abscissa\n+         * @param y ordinate\n+         * @param z height\n+         */\n+        public DataTransferObject(final double x, final double y, final double z) {\n+            this.x = x;\n+            this.y = y;\n+            this.z = z;\n+        }\n+\n+        /** Replace the deserialized data transfer object with a {@link SphericalCoordinates}.\n+         * @return replacement {@link SphericalCoordinates}\n+         */\n+        private Object readResolve() {\n+            return new SphericalCoordinates(new Vector3D(x, y, z));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/SphericalCoordinatesTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SphericalCoordinatesTest {\n+\n+    @Test\n+    public void testCoordinatesStoC() throws DimensionMismatchException {\n+        double piO2 = 0.5 * FastMath.PI;\n+        SphericalCoordinates sc1 = new SphericalCoordinates(2.0, 0, piO2);\n+        Assert.assertEquals(0, sc1.getCartesian().distance(new Vector3D(2, 0, 0)), 1.0e-10);\n+        SphericalCoordinates sc2 = new SphericalCoordinates(2.0, piO2, piO2);\n+        Assert.assertEquals(0, sc2.getCartesian().distance(new Vector3D(0, 2, 0)), 1.0e-10);\n+        SphericalCoordinates sc3 = new SphericalCoordinates(2.0, FastMath.PI, piO2);\n+        Assert.assertEquals(0, sc3.getCartesian().distance(new Vector3D(-2, 0, 0)), 1.0e-10);\n+        SphericalCoordinates sc4 = new SphericalCoordinates(2.0, -piO2, piO2);\n+        Assert.assertEquals(0, sc4.getCartesian().distance(new Vector3D(0, -2, 0)), 1.0e-10);\n+        SphericalCoordinates sc5 = new SphericalCoordinates(2.0, 1.23456, 0);\n+        Assert.assertEquals(0, sc5.getCartesian().distance(new Vector3D(0, 0, 2)), 1.0e-10);\n+        SphericalCoordinates sc6 = new SphericalCoordinates(2.0, 6.54321, FastMath.PI);\n+        Assert.assertEquals(0, sc6.getCartesian().distance(new Vector3D(0, 0, -2)), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testCoordinatesCtoS() throws DimensionMismatchException {\n+        double piO2 = 0.5 * FastMath.PI;\n+        SphericalCoordinates sc1 = new SphericalCoordinates(new Vector3D(2, 0, 0));\n+        Assert.assertEquals(2,           sc1.getR(),     1.0e-10);\n+        Assert.assertEquals(0,           sc1.getTheta(), 1.0e-10);\n+        Assert.assertEquals(piO2,        sc1.getPhi(),   1.0e-10);\n+        SphericalCoordinates sc2 = new SphericalCoordinates(new Vector3D(0, 2, 0));\n+        Assert.assertEquals(2,           sc2.getR(),     1.0e-10);\n+        Assert.assertEquals(piO2,        sc2.getTheta(), 1.0e-10);\n+        Assert.assertEquals(piO2,        sc2.getPhi(),   1.0e-10);\n+        SphericalCoordinates sc3 = new SphericalCoordinates(new Vector3D(-2, 0, 0));\n+        Assert.assertEquals(2,           sc3.getR(),     1.0e-10);\n+        Assert.assertEquals(FastMath.PI, sc3.getTheta(), 1.0e-10);\n+        Assert.assertEquals(piO2,        sc3.getPhi(),   1.0e-10);\n+        SphericalCoordinates sc4 = new SphericalCoordinates(new Vector3D(0, -2, 0));\n+        Assert.assertEquals(2,           sc4.getR(),     1.0e-10);\n+        Assert.assertEquals(-piO2,       sc4.getTheta(), 1.0e-10);\n+        Assert.assertEquals(piO2,        sc4.getPhi(),   1.0e-10);\n+        SphericalCoordinates sc5 = new SphericalCoordinates(new Vector3D(0, 0, 2));\n+        Assert.assertEquals(2,           sc5.getR(),     1.0e-10);\n+        //  don't check theta on poles, as it is singular\n+        Assert.assertEquals(0,           sc5.getPhi(),   1.0e-10);\n+        SphericalCoordinates sc6 = new SphericalCoordinates(new Vector3D(0, 0, -2));\n+        Assert.assertEquals(2,           sc6.getR(),     1.0e-10);\n+        //  don't check theta on poles, as it is singular\n+        Assert.assertEquals(FastMath.PI, sc6.getPhi(),   1.0e-10);\n+    }\n+\n+    @Test\n+    public void testGradient() {\n+        for (double r = 0.2; r < 10; r += 0.5) {\n+            for (double theta = 0; theta < 2 * FastMath.PI; theta += 0.1) {\n+                for (double phi = 0.1; phi < FastMath.PI; phi += 0.1) {\n+                    SphericalCoordinates sc = new SphericalCoordinates(r, theta, phi);\n+\n+                    DerivativeStructure svalue = valueSpherical(new DerivativeStructure(3, 1, 0, r),\n+                                                                new DerivativeStructure(3, 1, 1, theta),\n+                                                                new DerivativeStructure(3, 1, 2, phi));\n+                    double[] sGradient = new double[] {\n+                        svalue.getPartialDerivative(1, 0, 0),\n+                        svalue.getPartialDerivative(0, 1, 0),\n+                        svalue.getPartialDerivative(0, 0, 1),\n+                    };\n+\n+                    DerivativeStructure cvalue = valueCartesian(new DerivativeStructure(3, 1, 0, sc.getCartesian().getX()),\n+                                                                new DerivativeStructure(3, 1, 1, sc.getCartesian().getY()),\n+                                                                new DerivativeStructure(3, 1, 2, sc.getCartesian().getZ()));\n+                    Vector3D refCGradient = new Vector3D(cvalue.getPartialDerivative(1, 0, 0),\n+                                                         cvalue.getPartialDerivative(0, 1, 0),\n+                                                         cvalue.getPartialDerivative(0, 0, 1));\n+\n+                    Vector3D testCGradient = new Vector3D(sc.toCartesianGradient(sGradient));\n+                    \n+                    Assert.assertEquals(0, testCGradient.distance(refCGradient) / refCGradient.getNorm(), 5.0e-14);\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testHessian() {\n+        for (double r = 0.2; r < 10; r += 0.5) {\n+            for (double theta = 0; theta < 2 * FastMath.PI; theta += 0.2) {\n+                for (double phi = 0.1; phi < FastMath.PI; phi += 0.2) {\n+                    SphericalCoordinates sc = new SphericalCoordinates(r, theta, phi);\n+\n+                    DerivativeStructure svalue = valueSpherical(new DerivativeStructure(3, 2, 0, r),\n+                                                                new DerivativeStructure(3, 2, 1, theta),\n+                                                                new DerivativeStructure(3, 2, 2, phi));\n+                    double[] sGradient = new double[] {\n+                        svalue.getPartialDerivative(1, 0, 0),\n+                        svalue.getPartialDerivative(0, 1, 0),\n+                        svalue.getPartialDerivative(0, 0, 1),\n+                    };\n+                    double[][] sHessian = new double[3][3];\n+                    sHessian[0][0] = svalue.getPartialDerivative(2, 0, 0); // d2F/dR2\n+                    sHessian[1][0] = svalue.getPartialDerivative(1, 1, 0); // d2F/dRdTheta\n+                    sHessian[2][0] = svalue.getPartialDerivative(1, 0, 1); // d2F/dRdPhi\n+                    sHessian[0][1] = Double.NaN; // just to check upper-right part is not used\n+                    sHessian[1][1] = svalue.getPartialDerivative(0, 2, 0); // d2F/dTheta2\n+                    sHessian[2][1] = svalue.getPartialDerivative(0, 1, 1); // d2F/dThetadPhi\n+                    sHessian[0][2] = Double.NaN; // just to check upper-right part is not used\n+                    sHessian[1][2] = Double.NaN; // just to check upper-right part is not used\n+                    sHessian[2][2] = svalue.getPartialDerivative(0, 0, 2); // d2F/dPhi2\n+\n+                    DerivativeStructure cvalue = valueCartesian(new DerivativeStructure(3, 2, 0, sc.getCartesian().getX()),\n+                                                                new DerivativeStructure(3, 2, 1, sc.getCartesian().getY()),\n+                                                                new DerivativeStructure(3, 2, 2, sc.getCartesian().getZ()));\n+                    double[][] refCHessian = new double[3][3];\n+                    refCHessian[0][0] = cvalue.getPartialDerivative(2, 0, 0); // d2F/dX2\n+                    refCHessian[1][0] = cvalue.getPartialDerivative(1, 1, 0); // d2F/dXdY\n+                    refCHessian[2][0] = cvalue.getPartialDerivative(1, 0, 1); // d2F/dXdZ\n+                    refCHessian[0][1] = refCHessian[1][0];\n+                    refCHessian[1][1] = cvalue.getPartialDerivative(0, 2, 0); // d2F/dY2\n+                    refCHessian[2][1] = cvalue.getPartialDerivative(0, 1, 1); // d2F/dYdZ\n+                    refCHessian[0][2] = refCHessian[2][0];\n+                    refCHessian[1][2] = refCHessian[2][1];\n+                    refCHessian[2][2] = cvalue.getPartialDerivative(0, 0, 2); // d2F/dZ2\n+                    double norm =  0;\n+                    for (int i = 0; i < 3; ++i) {\n+                        for (int j = 0; j < 3; ++j) {\n+                            norm = FastMath.max(norm, FastMath.abs(refCHessian[i][j]));\n+                        }\n+                    }\n+\n+                    double[][] testCHessian = sc.toCartesianHessian(sHessian, sGradient);\n+                    for (int i = 0; i < 3; ++i) {\n+                        for (int j = 0; j < 3; ++j) {\n+                            Assert.assertEquals(\"\" + FastMath.abs((refCHessian[i][j] - testCHessian[i][j]) / norm),\n+                                                refCHessian[i][j], testCHessian[i][j], 1.0e-14 * norm);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    public DerivativeStructure valueCartesian(DerivativeStructure x, DerivativeStructure y, DerivativeStructure z) {\n+        return x.divide(y.multiply(5).add(10)).multiply(z.pow(3));\n+    }\n+\n+    public DerivativeStructure valueSpherical(DerivativeStructure r, DerivativeStructure theta, DerivativeStructure phi) {\n+        return valueCartesian(r.multiply(theta.cos()).multiply(phi.sin()),\n+                              r.multiply(theta.sin()).multiply(phi.sin()),\n+                              r.multiply(phi.cos()));\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n+        SphericalCoordinates a = new SphericalCoordinates(3, 2, 1);\n+        SphericalCoordinates b = (SphericalCoordinates) TestUtils.serializeAndRecover(a);\n+        Assert.assertEquals(0, a.getCartesian().distance(b.getCartesian()), 1.0e-10);\n+        Assert.assertEquals(a.getR(),     b.getR(),     1.0e-10);\n+        Assert.assertEquals(a.getTheta(), b.getTheta(), 1.0e-10);\n+        Assert.assertEquals(a.getPhi(),   b.getPhi(),   1.0e-10);\n+    }\n+\n+}", "timestamp": 1360181313, "metainfo": ""}