{"sha": "89adf90e262e8867b76cc1b2ede7d1a69d1592bc", "log": "This house-cleaning improves UnivariateImpl, in a number of ways.  1.) insertValue is abolished and its contents are now in addValue  2.) UnivariateImpl now extends AbstractStoredUnivariate to deligate to  those methods directly for calculating statistics when storage is active, all methods  deligate to AbstractStoreUniv when the DoubleArray is no longer null. This also means that a majority of the StoreUnivariate interface is now implemented in Univariate to provide deligates when storage is active, and to throw runtime exceptions when its not (this at least until  we establish rolling implementations for those methods). We should consider consolidating the  StoreUnivariate interface into the Univariate interface  3.) Calculations in addValue have been reorganized, only calculations for the storageless solution are now present in this class. otherwise the value is  added/Rolling to the Double array when appropriate.  I'm satisfied that it passes all Unit tests.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n  * @author Brent Worden\n  * @author <a href=\"mailto:HotFusionMan@Yahoo.com\">Albert Davidson Chou</a>\n- * @version $Revision: 1.5 $ $Date: 2003/06/16 14:29:30 $\n+ * @version $Revision: 1.6 $ $Date: 2003/06/16 20:42:24 $\n  *\n */\n-public class UnivariateImpl implements Univariate, Serializable {\n-\n-    /** hold the window size **/\n-    private int windowSize = Univariate.INFINITE_WINDOW;\n-\n-    /** Just in case the windowSize is not infinite, we need to\n-     *  keep an array to remember values 0 to N\n-     */\n-    private DoubleArray doubleArray;\n-\n-    /** count of values that have been added */\n-    private int n = 0;\n-\n-    /** min of values that have been added */\n-    private double min = Double.MAX_VALUE;\n-\n-    /** max of values that have been added */\n-    private double max = Double.MIN_VALUE;\n-\n-    /** product of values that have been added */\n-    private double product = Double.NaN;\n-\n-    /** mean of values that have been added */\n-    private double mean = Double.NaN ;\n-\n-    /** running ( variance * (n - 1) ) of values that have been added */\n-    private double pre_variance = Double.NaN ;\n-\n-    /** variance of values that have been added */\n-    private double variance = Double.NaN ;\n-\n-    /** running sum of values that have been added */\n-    private double sum = 0.0;\n-\n-    /** running sum of squares that have been added */\n-    private double sumsq = 0.0;\n-\n-    /** running sum of 3rd powers that have been added */\n-    private double sumCube = 0.0;\n-\n-    /** running sum of 4th powers that have been added */\n-    private double sumQuad = 0.0;\n-\n-    /** Creates new univariate with an infinite window */\n-    public UnivariateImpl() {\n-        clear();\n-    }\n-\n-    /** Creates a new univariate with a fixed window **/\n-    public UnivariateImpl(int window) {\n-        windowSize = window;\n-        doubleArray = new FixedDoubleArray( window );\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n-     */\n-    public void addValue(double v) {\n-        insertValue(v);\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getMean()\n-     */\n-    public double getMean() {\n-        return mean ;\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-     */\n-    public double getGeometricMean() {\n-        if ((product <= 0.0) || (n == 0)) {\n-            return Double.NaN;\n-        } else {\n-            return Math.pow(product,( 1.0 / (double) n ) );\n-        }\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getProduct()\n-     */\n-    public double getProduct() {\n-        return product;\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n-     */\n-    public double getStandardDeviation() {\n-        double variance = getVariance();\n-\n-        if ((variance == 0.0) || (variance == Double.NaN)) {\n-            return variance;\n-        } else {\n-            return Math.sqrt(variance);\n-        }\n-    }\n-\n-    /**\n-     * Returns the variance of the values that have been added via West's\n-     * algorithm as described by\n-     * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n-     * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n-     * vol. 22 no. 9, pp. 526-531.</a>.\n-     *\n-     * @return The variance of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n-     */\n-    public double getVariance() {\n-        return variance ;\n-    }\n-\n-    /**\n-     * Returns the skewness of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n-     *\n-     * @return The skew of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n-     */\n-    public double getSkewness() {\n-\n-        if( n < 1) return Double.NaN;\n-        if( n <= 2 ) return 0.0;\n-\n-        return ( 2 * Math.pow(sum, 3) - 3 * sum * sumsq + ((double) (n * n)) * sumCube ) /\n-               ( (double) (n * (n - 1) * (n - 2)) ) ;\n-    }\n-\n-    /**\n-     * Returns the kurtosis of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n-     *\n-     * @return The kurtosis of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n-     */\n-    public double getKurtosis() {\n-\n-        if( n < 1) return Double.NaN;\n-        if( n <= 3 ) return 0.0;\n-\n-        double x1 = -6 * Math.pow(sum, 4);\n-        double x2 = 12 * ((double) n) * Math.pow(sum, 2) * sumsq;\n-        double x3 = -3 * ((double) (n * (n - 1))) * Math.pow(sumsq,2);\n-        double x4 = -4 * ((double) (n * (n + 1))) * sum * sumCube;\n-        double x5 = Math.pow(((double) n),2) * ((double) (n+1)) * sumQuad;\n-\n-        return (x1 + x2 + x3 + x4 + x5) /\n-               ( (double) (n * (n - 1) * (n - 2) * (n - 3)) );\n-    }\n-\n-    /**\n-     * Called in \"addValue\" to insert a new value into the statistic.\n-     * @param v The value to be added.\n-     */\n-    private void insertValue(double v) {\n-        // The default value of product is NaN, if you\n-        // try to retrieve the product for a univariate with\n-        // no values, we return NaN.\n-        //\n-        // If this is the first call to insertValue, we want\n-        // to set product to 1.0, so that our first element\n-        // is not \"cancelled\" out by the NaN.\n-        //\n-        // For the first value added, the mean is that value,\n-        // and the variance is zero.\n-        if( n == 0 ) {\n-            product = 1.0 ;\n-            mean = v ;\n-            pre_variance = 0.0 ;\n-            variance = 0.0 ;\n-        }\n-\n-        if( windowSize != Univariate.INFINITE_WINDOW ) {\n-            if( windowSize == n ) {\n-                double discarded = doubleArray.addElementRolling( v );\n-\n-                // Remove the influence of the discarded\n-                sum -= discarded;\n-                sumsq -= discarded * discarded;\n-                sumCube -= Math.pow(discarded, 3);\n-                sumQuad -= Math.pow(discarded, 4);\n-\n-                if(discarded == min) {\n-                    min = doubleArray.getMin();\n-                } else if(discarded == max){\n-                    max = doubleArray.getMax();\n-                }\n-\n-                if(product != 0.0){\n-                    // can safely remove discarded value\n-                    product *= v / discarded;\n-                } else if(discarded == 0.0){\n-                    // need to recompute product\n-                    product = 1.0;\n-                    double[] elements = doubleArray.getElements();\n-                    for( int i = 0; i < elements.length; i++ ) {\n-                        product *= elements[i];\n-                    }\n-                } // else product = 0 and will still be 0 after discard\n-\n-            } else {\n-                doubleArray.addElement( v );\n-                n += 1 ;\n-                if (v < min) {\n-                    min = v;\n-                }\n-                if (v > max) {\n-                    max = v;\n-                }\n-                product *= v;\n-            }\n-        } else {\n-            // If the windowSize is infinite please don't take the time to\n-            // worry about storing any values.  We don't need to discard the\n-            // influence of any single item.\n-            n += 1 ;\n-            if (v < min) {\n-                min = v;\n-            }\n-            if (v > max) {\n-                max = v;\n-            }\n-            product *= v;\n-\n-            if ( n > 1 )\n-            {\n-                double deviationFromMean = v - mean ;\n-                double deviationFromMean_overN = deviationFromMean / n ;\n-                mean += deviationFromMean_overN ;\n-                pre_variance += (n - 1) * deviationFromMean * deviationFromMean_overN ;\n-                variance = pre_variance / (n - 1) ;\n-            }\n-        }\n-\n-        sum += v;\n-        sumsq += v * v;\n-        sumCube += Math.pow(v,3);\n-        sumQuad += Math.pow(v,4);\n-    }\n-\n-    /** Getter for property max.\n-     * @return Value of property max.\n-     */\n-    public double getMax() {\n-        if (n == 0) {\n-            return Double.NaN;\n-        } else {\n-            return max;\n-        }\n-    }\n-\n-    /** Getter for property min.\n-     * @return Value of property min.\n-     */\n-    public double getMin() {\n-        if (n == 0) {\n-            return Double.NaN;\n-        } else {\n-            return min;\n-        }\n-    }\n-\n-    /** Getter for property n.\n-     * @return Value of property n.\n-     */\n-    public int getN() {\n-        return n;\n-    }\n-\n-    /** Getter for property sum.\n-     * @return Value of property sum.\n-     */\n-    public double getSum() {\n-        return sum;\n-    }\n-\n-    /** Getter for property sumsq.\n-     * @return Value of property sumsq.\n-     */\n-    public double getSumsq() {\n-        return sumsq;\n-    }\n-\n-    /** Getter for property sumCube.\n-     * @return Value of property sumCube.\n-     */\n-    public double getSumCube() {\n-        return sumCube;\n-    }\n-\n-    /** Getter for property sumQuad.\n-     * @return Value of property sumQuad.\n-     */\n-    public double getSumQuad() {\n-        return sumQuad;\n-    }\n-\n-    /**\n-     * Generates a text report displaying\n-     * univariate statistics from values that\n-     * have been added.\n-     * @return String with line feeds displaying statistics\n-     */\n-    public String toString() {\n-        StringBuffer outBuffer = new StringBuffer();\n-        outBuffer.append(\"UnivariateImpl:\\n\");\n-        outBuffer.append(\"n: \" + n + \"\\n\");\n-        outBuffer.append(\"min: \" + min + \"\\n\");\n-        outBuffer.append(\"max: \" + max + \"\\n\");\n-        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n-        outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n-        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n-        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n-        return outBuffer.toString();\n-    }\n-\n-    /**\n-     * Resets all sums, product, mean, and variance to 0; resets min and max.\n-     */\n-    public void clear() {\n-        this.sum = this.sumsq = this.sumCube = this.sumQuad = 0.0;\n-        this.n = 0;\n-        this.min = Double.MAX_VALUE;\n-        this.max = Double.MIN_VALUE;\n-        this.product = Double.NaN;\n-        this.mean = Double.NaN ;\n-        this.variance = this.pre_variance = Double.NaN ;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#getWindowSize()\n-     */\n-    public int getWindowSize() {\n-        return windowSize;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-     */\n-    public void setWindowSize(int windowSize) {\n-        String msg = \"A fixed window size must be set via the \" +\n-            \"UnivariateImpl constructor\";\n-        throw new RuntimeException( msg );\n-    }\n-}\n+public class UnivariateImpl\n+\textends AbstractStoreUnivariate\n+\timplements Univariate, Serializable {\n+\n+\t/** hold the window size **/\n+\tprivate int windowSize = Univariate.INFINITE_WINDOW;\n+\n+\t/** Just in case the windowSize is not infinite, we need to\n+\t *  keep an array to remember values 0 to N\n+\t */\n+\tprivate DoubleArray doubleArray;\n+\n+\t/** count of values that have been added */\n+\tprivate int n = 0;\n+\n+\t/** sum of values that have been added */\n+\tprivate double sum = Double.NaN;\n+\n+\t/** sum of the square of each value that has been added */\n+\tprivate double sumsq = Double.NaN;\n+\n+\t/** sum of the Cube of each value that has been added */\n+\tprivate double sumCube = Double.NaN;\n+\n+\t/** sum of the Quadrate of each value that has been added */\n+\tprivate double sumQuad = Double.NaN;\n+\n+\t/** min of values that have been added */\n+\tprivate double min = Double.NaN;\n+\n+\t/** max of values that have been added */\n+\tprivate double max = Double.NaN;\n+\n+\t/** product of values that have been added */\n+\tprivate double product = Double.NaN;\n+\n+\t/** mean of values that have been added */\n+\tprivate double mean = Double.NaN;\n+\n+\t/** running ( variance * (n - 1) ) of values that have been added */\n+\tprivate double pre_variance = Double.NaN;\n+\n+\t/** variance of values that have been added */\n+\tprivate double variance = Double.NaN;\n+\n+\t/** Creates new univariate with an infinite window */\n+\tpublic UnivariateImpl() {\n+\t\tsuper();\n+\t}\n+\n+\t/** Creates a new univariate with a fixed window **/\n+\tpublic UnivariateImpl(int window) {\n+\t\tsuper();\n+\t\tsetWindowSize(window);\n+\t}\n+\n+\t/** Getter for property n.\n+\t * @return Value of property n.\n+\t */\n+\tpublic int getN() {\n+\t\treturn n;\n+\t}\n+\n+\t/**\n+\t * Returns the sum of all values contained herein\n+\t * @see org.apache.commons.math.stat.Univariate#getSum()\n+\t */\n+\tpublic double getSum() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getSum();\n+\t\t}\n+\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * Returns the sun of the squares of all values contained herein\n+\t * @see org.apache.commons.math.stat.Univariate#getSumsq()\n+\t */\n+\tpublic double getSumsq() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getSumsq();\n+\t\t}\n+\n+\t\treturn sumsq;\n+\t}\n+\n+\t/**\n+\t * @see org.apache.commons.math.stat.Univariate#getMean()\n+\t */\n+\tpublic double getMean() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getMean();\n+\t\t}\n+\n+\t\treturn mean;\n+\t}\n+\n+\t/**\n+\t * Returns the variance of the values that have been added via West's\n+\t * algorithm as described by\n+\t * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n+\t * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n+\t * vol. 22 no. 9, pp. 526-531.</a>.\n+\t *\n+\t * @return The variance of a set of values.  Double.NaN is returned for\n+\t *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n+\t */\n+\tpublic double getVariance() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getVariance();\n+\t\t}\n+\n+\t\treturn variance;\n+\t}\n+\n+\t/**\n+\t * Returns the skewness of the values that have been added as described by\n+\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n+\t *\n+\t * @return The skew of a set of values.  Double.NaN is returned for\n+\t *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n+\t */\n+\tpublic double getSkewness() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getSkewness();\n+\t\t}\n+\n+\t\tif (n == 0) {\n+\t\t\treturn Double.NaN;\n+\t\t}\n+\n+\t\tif (n <= 2) {\n+\t\t\t/* if n <= 2, skewness to 0.0 */\n+\t\t\treturn 0.0;\n+\t\t} else {\n+\t\t\t/* else calc the skewness */\n+\t\t\treturn (\n+\t\t\t\t2 * Math.pow(sum, 3)\n+\t\t\t\t\t- 3 * sum * sumsq\n+\t\t\t\t\t+ ((double) (n * n)) * sumCube)\n+\t\t\t\t/ ((double) (n * (n - 1) * (n - 2)));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns the kurtosis of the values that have been added as described by\n+\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n+\t *\n+\t * @return The kurtosis of a set of values.  Double.NaN is returned for\n+\t *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n+\t */\n+\tpublic double getKurtosis() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getKurtosis();\n+\t\t}\n+\n+\t\tif (n == 0) {\n+\t\t\treturn Double.NaN;\n+\t\t}\n+\n+\t\tif (n <= 3) {\n+\t\t\t/* if n <= 3, kurtosis to 0.0 */\n+\t\t\treturn 0.0;\n+\t\t} else {\n+\t\t\t/* calc the kurtosis */\n+\t\t\tdouble x1 = -6 * Math.pow(sum, 4);\n+\t\t\tdouble x2 = 12 * ((double) n) * Math.pow(sum, 2) * sumsq;\n+\t\t\tdouble x3 = -3 * ((double) (n * (n - 1))) * Math.pow(sumsq, 2);\n+\t\t\tdouble x4 = -4 * ((double) (n * (n + 1))) * sum * sumCube;\n+\t\t\tdouble x5 =\n+\t\t\t\tMath.pow(((double) n), 2) * ((double) (n + 1)) * sumQuad;\n+\n+\t\t\treturn (x1 + x2 + x3 + x4 + x5)\n+\t\t\t\t/ ((double) (n * (n - 1) * (n - 2) * (n - 3)));\n+\t\t}\n+\t}\n+\n+\t/** Getter for property max.\n+\t * @return Value of property max.\n+\t */\n+\tpublic double getMax() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getMax();\n+\t\t}\n+\n+\t\treturn max;\n+\t}\n+\n+\t/** Getter for property min.\n+\t * @return Value of property min.\n+\t */\n+\tpublic double getMin() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getMin();\n+\t\t}\n+\n+\t\treturn min;\n+\t}\n+\n+\t/**\n+\t * @see org.apache.commons.math.stat.Univariate#getProduct()\n+\t */\n+\tpublic double getProduct() {\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getProduct();\n+\t\t}\n+\n+\t\treturn product;\n+\t}\n+\n+\t/**\n+\t* @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n+\t*/\n+\tpublic double getGeometricMean() {\n+\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\treturn super.getGeometricMean();\n+\t\t}\n+\n+\t\tif ((product <= 0.0) || (n == 0)) {\n+\t\t\treturn Double.NaN;\n+\t\t} else {\n+\t\t\treturn Math.pow(product, (1.0 / (double) n));\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.StoreUnivariate#getMode()\n+\t */\n+\tpublic double getMode() {\n+\t\tif (windowSize == Univariate.INFINITE_WINDOW) {\n+\t\t\tthrow new RuntimeException(\"Mode is only available if windowSize is fixed\");\n+\t\t}\n+\n+\t\treturn super.getMode();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.StoreUnivariate#getPercentile(double)\n+\t */\n+\tpublic double getPercentile(double p) {\n+\t\tif (windowSize == Univariate.INFINITE_WINDOW) {\n+\t\t\tthrow new RuntimeException(\"Percentiles are only available if windowSize is fixed\");\n+\t\t}\n+\n+\t\treturn super.getPercentile(p);\n+\n+\t}\n+\n+\t/**\n+\t * @see org.apache.commons.math.stat.Univariate#addValue(double)\n+\t */\n+\tpublic void addValue(double v) {\n+\n+\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n+\t\t\t/* then all getters deligate to AbstractStoreUnivariate \n+\t\t\t * and this clause simply adds/rolls a value in the storage array \n+\t\t\t */\n+\t\t\tif (windowSize == n) {\n+\t\t\t\tdoubleArray.addElementRolling(v);\n+\t\t\t} else {\n+\t\t\t\tn++;\n+\t\t\t\tdoubleArray.addElement(v);\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\t/* If the windowSize is infinite don't store any values and there \n+\t\t\t * is no need to discard the influence of any single item.\n+\t\t\t */\n+\t\t\tn++;\n+\n+\t\t\tif (n <= 1) {\n+\t\t\t\t/* if n <= 1, initialize the product, min, max, mean, variance and pre-variance */\n+\t\t\t\tproduct = 1.0;\n+\t\t\t\tsum = min = max = mean = v;\n+\t\t\t\tsumsq = Math.pow(v, 2);\n+\t\t\t\tsumCube = Math.pow(v, 3);\n+\t\t\t\tsumQuad = Math.pow(v, 4);\n+\t\t\t\tvariance = pre_variance = 0.0;\n+\t\t\t} else {\n+\t\t\t\t/* otherwise calc these values */\n+\t\t\t\tproduct *= v;\n+\t\t\t\tsum += v;\n+\t\t\t\tsumsq += Math.pow(v, 2);\n+\t\t\t\tsumCube += Math.pow(v, 3);\n+\t\t\t\tsumQuad += Math.pow(v, 4);\n+\t\t\t\tmin = Math.min(min, v);\n+\t\t\t\tmax = Math.max(max, v);\n+\n+\t\t\t\tdouble deviationFromMean = v - mean;\n+\t\t\t\tdouble deviationFromMean_overN = deviationFromMean / n;\n+\t\t\t\tmean += deviationFromMean_overN;\n+\t\t\t\tpre_variance += (n - 1)\n+\t\t\t\t\t* deviationFromMean\n+\t\t\t\t\t* deviationFromMean_overN;\n+\t\t\t\tvariance = pre_variance / (n - 1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generates a text report displaying\n+\t * univariate statistics from values that\n+\t * have been added.\n+\t * @return String with line feeds displaying statistics\n+\t */\n+\tpublic String toString() {\n+\t\tStringBuffer outBuffer = new StringBuffer();\n+\t\toutBuffer.append(\"UnivariateImpl:\\n\");\n+\t\toutBuffer.append(\"n: \" + n + \"\\n\");\n+\t\toutBuffer.append(\"min: \" + min + \"\\n\");\n+\t\toutBuffer.append(\"max: \" + max + \"\\n\");\n+\t\toutBuffer.append(\"mean: \" + getMean() + \"\\n\");\n+\t\toutBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n+\t\toutBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n+\t\toutBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+\t\treturn outBuffer.toString();\n+\t}\n+\n+\t/**\n+\t * Resets all stats to NaN. Reinitializes the Double Array\n+\t */\n+\tpublic void clear() {\n+\t\tthis.n = 0;\n+\t\tthis.min = this.max = Double.NaN;\n+\t\tthis.product = this.mean = Double.NaN;\n+\t\tthis.variance = this.pre_variance = Double.NaN;\n+\n+\t\tif (doubleArray != null)\n+\t\t\tdoubleArray = new FixedDoubleArray(windowSize);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#getWindowSize()\n+\t */\n+\tpublic int getWindowSize() {\n+\t\treturn windowSize;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+\t */\n+\tpublic void setWindowSize(int windowSize) {\n+\t\tclear();\n+\t\tthis.windowSize = windowSize;\n+\t\tdoubleArray = new FixedDoubleArray(windowSize);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.StoreUnivariate#getValues()\n+\t */\n+\tpublic double[] getValues() {\n+\t\tif (windowSize == Univariate.INFINITE_WINDOW) {\n+\t\t\tthrow new RuntimeException(\"Values are only available if windowSize is fixed\");\n+\t\t}\n+\n+\t\treturn this.doubleArray.getElements();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.StoreUnivariate#getElement(int)\n+\t */\n+\tpublic double getElement(int index) {\n+\t\tif (windowSize == Univariate.INFINITE_WINDOW) {\n+\t\t\tthrow new RuntimeException(\"Elements are only available if windowSize is fixed\");\n+\t\t}\n+\n+\t\treturn this.doubleArray.getElement(index);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.stat.StoreUnivariate#getSortedValues()\n+\t */\n+\tpublic double[] getSortedValues() {\n+\t\tif (windowSize == Univariate.INFINITE_WINDOW) {\n+\t\t\tthrow new RuntimeException(\"SortedValues are only available if windowSize is fixed\");\n+\t\t}\n+\n+\t\treturn super.getSortedValues();\n+\t}\n+}", "timestamp": 1055796144, "metainfo": ""}