{"sha": "2ce25c46737e53e6a00eccebec37849711de9bd4", "log": "fixed another set of warnings identified by recent findbugs versions  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n package org.apache.commons.math.ode.nonstiff;\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n--- a/src/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n package org.apache.commons.math.stat.descriptive;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * <p>\n                 aggregateStatistics.addValue(value);\n             }\n         }\n+\n+        /**\n+         * Returns true iff <code>object</code> is a\n+         * <code>SummaryStatistics</code> instance and all statistics have the\n+         * same values as this.\n+         * @param object the object to test equality against.\n+         * @return true if object equals this\n+         */\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object == this) {\n+                return true;\n+            }\n+            if (object instanceof AggregatingSummaryStatistics == false) {\n+                return false;\n+            }\n+            AggregatingSummaryStatistics stat = (AggregatingSummaryStatistics)object;\n+            return (super.equals(stat) &&\n+            \t\taggregateStatistics.equals(stat.aggregateStatistics));\n+        }\n+\n+        /**\n+         * Returns hash code based on values of statistics\n+         * @return hash code\n+         */\n+        @Override\n+        public int hashCode() {\n+            return 123 + super.hashCode() + aggregateStatistics.hashCode();\n+        }\n+\n     }\n }\n--- a/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n     }\n \n     public void addPoint(double px, double py) {\n-      points.add(new PointModel(px, py));\n+      points.add(new PointModel(this, px, py));\n     }\n \n     public int getM() {\n       return cy.getEstimate();\n     }\n \n-    private class PointModel extends WeightedMeasurement {\n-\n-      public PointModel(double px, double py) {\n+    private static class PointModel extends WeightedMeasurement {\n+\n+      public PointModel(Circle circle, double px, double py) {\n         super(1.0, 0.0);\n         this.px = px;\n         this.py = py;\n+        this.circle = circle;\n       }\n \n       @Override\n       public double getPartial(EstimatedParameter parameter) {\n-        if (parameter == cx) {\n-          return getPartialDiX() - getPartialRadiusX();\n-        } else if (parameter == cy) {\n-          return getPartialDiY() - getPartialRadiusY();\n+        if (parameter == circle.cx) {\n+          return getPartialDiX() - circle.getPartialRadiusX();\n+        } else if (parameter == circle.cy) {\n+          return getPartialDiY() - circle.getPartialRadiusY();\n         }\n         return 0;\n       }\n \n       public double getCenterDistance() {\n-        double dx = px - cx.getEstimate();\n-        double dy = py - cy.getEstimate();\n+        double dx = px - circle.cx.getEstimate();\n+        double dy = py - circle.cy.getEstimate();\n         return Math.sqrt(dx * dx + dy * dy);\n       }\n \n       public double getPartialDiX() {\n-        return (cx.getEstimate() - px) / getCenterDistance();\n+        return (circle.cx.getEstimate() - px) / getCenterDistance();\n       }\n \n       public double getPartialDiY() {\n-        return (cy.getEstimate() - py) / getCenterDistance();\n+        return (circle.cy.getEstimate() - py) / getCenterDistance();\n       }\n \n       @Override\n       public double getTheoreticalValue() {\n-        return getCenterDistance() - getRadius();\n+        return getCenterDistance() - circle.getRadius();\n       }\n \n       private double px;\n       private double py;\n+      private transient final Circle circle;\n       private static final long serialVersionUID = 1L;\n \n     }\n--- a/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n     }\n \n     public void addPoint(double px, double py) {\n-      points.add(new PointModel(px, py));\n+      points.add(new PointModel(this, px, py));\n     }\n \n     public int getM() {\n       return cy.getEstimate();\n     }\n \n-    private class PointModel extends WeightedMeasurement {\n-\n-      public PointModel(double px, double py) {\n+    private static class PointModel extends WeightedMeasurement {\n+\n+      public PointModel(Circle circle, double px, double py) {\n         super(1.0, 0.0);\n         this.px = px;\n         this.py = py;\n+        this.circle = circle;\n       }\n \n       @Override\n       public double getPartial(EstimatedParameter parameter) {\n-        if (parameter == cx) {\n-          return getPartialDiX() - getPartialRadiusX();\n-        } else if (parameter == cy) {\n-          return getPartialDiY() - getPartialRadiusY();\n+        if (parameter == circle.cx) {\n+          return getPartialDiX() - circle.getPartialRadiusX();\n+        } else if (parameter == circle.cy) {\n+          return getPartialDiY() - circle.getPartialRadiusY();\n         }\n         return 0;\n       }\n \n       public double getCenterDistance() {\n-        double dx = px - cx.getEstimate();\n-        double dy = py - cy.getEstimate();\n+        double dx = px - circle.cx.getEstimate();\n+        double dy = py - circle.cy.getEstimate();\n         return Math.sqrt(dx * dx + dy * dy);\n       }\n \n       public double getPartialDiX() {\n-        return (cx.getEstimate() - px) / getCenterDistance();\n+        return (circle.cx.getEstimate() - px) / getCenterDistance();\n       }\n \n       public double getPartialDiY() {\n-        return (cy.getEstimate() - py) / getCenterDistance();\n+        return (circle.cy.getEstimate() - py) / getCenterDistance();\n       }\n \n       @Override\n       public double getTheoreticalValue() {\n-        return getCenterDistance() - getRadius();\n+        return getCenterDistance() - circle.getRadius();\n       }\n \n       private double px;\n       private double py;\n+      private transient final Circle circle;\n       private static final long serialVersionUID = 1L;\n \n     }\n       }\n \n       public void addPoint(double x, double y, double w) {\n-          addMeasurement(new LocalMeasurement(x, y, w));\n+          addMeasurement(new LocalMeasurement(this, x, y, w));\n       }\n \n       public double theoreticalValue(double x) {\n           }\n       }\n \n-      private class LocalMeasurement extends WeightedMeasurement {\n+      private static class LocalMeasurement extends WeightedMeasurement {\n \n         private static final long serialVersionUID = 1555043155023729130L;\n         private final double x;\n+        private transient final QuadraticProblem pb;\n \n           // constructor\n-          public LocalMeasurement(double x, double y, double w) {\n+          public LocalMeasurement(QuadraticProblem pb, double x, double y, double w) {\n               super(w, y);\n               this.x = x;\n+              this.pb = pb;\n           }\n \n           @Override\n           public double getTheoreticalValue() {\n-              return theoreticalValue(x);\n+              return pb.theoreticalValue(x);\n           }\n \n           @Override\n           public double getPartial(EstimatedParameter parameter) {\n-              return partial(x, parameter);\n+              return pb.partial(x, parameter);\n           }\n \n       }\n--- a/src/test/org/apache/commons/math/estimation/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/estimation/MinpackTest.java\n     public WeightedMeasurement[] getMeasurements() {\n       WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n       for (int i = 0; i < m; ++i) {\n-        measurements[i] = new MinpackMeasurement(i);\n+        measurements[i] = new MinpackMeasurement(this, i);\n       }\n       return measurements;\n     }\n \n     protected abstract double[] getResiduals();\n \n-    private class MinpackMeasurement extends WeightedMeasurement {\n-\n-      public MinpackMeasurement(int index) {\n+    private static class MinpackMeasurement extends WeightedMeasurement {\n+\n+      public MinpackMeasurement(MinpackFunction f, int index) {\n         super(1.0, 0.0);\n         this.index = index;\n+        this.f = f;\n       }\n \n       @Override\n         // each time we need only one element, but it is only for test\n         // purposes and is simpler to check.\n         // This implementation should NOT be taken as an example, it is ugly!\n-        return getResiduals()[index];\n+        return f.getResiduals()[index];\n       }\n \n       @Override\n         // each time we need only one element, but it is only for test\n         // purposes and is simpler to check.\n         // This implementation should NOT be taken as an example, it is ugly!\n-        for (int j = 0; j < n; ++j) {\n-          if (parameter == parameters[j]) {\n-            return getJacobian()[index][j];\n+        for (int j = 0; j < f.n; ++j) {\n+          if (parameter == f.parameters[j]) {\n+            return f.getJacobian()[index][j];\n           }\n         }\n         return 0;\n       }\n \n       private int index;\n+      private transient final MinpackFunction f;\n       private static final long serialVersionUID = 1L;\n \n     }", "timestamp": 1246480310, "metainfo": ""}