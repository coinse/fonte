{"sha": "b68b4d60830123c285b22ee5fa35c13fabc04d13", "log": "Fixed accuracy issues in FastMath.pow(double, int).  The fixed version is slightly slower, but still much faster than FastMath.pow(double, double). Some random testing showed that the accuracy is now always better than 0.5ulp, even for large exponent.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n      * @return d<sup>e</sup>\n      */\n     public static double pow(double d, int e) {\n+\n         if (e == 0) {\n             return 1.0;\n         } else if (e < 0) {\n             d = 1.0 / d;\n         }\n \n-        double result = 1;\n-        double d2p    = d;\n+        // split d as two 26 bits numbers\n+        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n+        final int splitFactor = 0x8000001;\n+        final double cd       = splitFactor * d;\n+        final double d1High   = cd - (cd - d);\n+        final double d1Low    = d - d1High;\n+\n+        // prepare result\n+        double resultHigh = 1;\n+        double resultLow  = 0;\n+\n+        // d^(2p)\n+        double d2p     = d;\n+        double d2pHigh = d1High;\n+        double d2pLow  = d1Low;\n+\n         while (e != 0) {\n+\n             if ((e & 0x1) != 0) {\n-                result *= d2p;\n-            }\n-            d2p *= d2p;\n+                // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n+                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n+                final double tmpHigh = resultHigh * d2p;\n+                final double cRH     = splitFactor * resultHigh;\n+                final double rHH     = cRH - (cRH - resultHigh);\n+                final double rHL     = resultHigh - rHH;\n+                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n+                resultHigh = tmpHigh;\n+                resultLow  = resultLow * d2p + tmpLow;\n+            }\n+\n+            // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n+            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n+            final double tmpHigh = d2pHigh * d2p;\n+            final double cD2pH   = splitFactor * d2pHigh;\n+            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n+            final double d2pHL   = d2pHigh - d2pHH;\n+            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n+            final double cTmpH   = splitFactor * tmpHigh;\n+            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n+            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n+            d2p     = d2pHigh + d2pLow;\n+\n             e = e >> 1;\n-        }\n-\n-        return result;\n+\n+        }\n+\n+        return resultHigh + resultLow;\n+\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math3/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/FastMathTest.java\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Type;\n \n+import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.dfp.Dfp;\n import org.apache.commons.math3.dfp.DfpField;\n import org.apache.commons.math3.dfp.DfpMath;\n import org.apache.commons.math3.random.MersenneTwister;\n import org.apache.commons.math3.random.RandomGenerator;\n-import org.apache.commons.math3.TestUtils;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n \n     @Test\n     public void testIntPow() {\n+        final int maxExp = 300;\n+        DfpField field = new DfpField(40);\n         final double base = 1.23456789;\n-        final int maxExp = 300;\n-\n+        Dfp baseDfp = field.newDfp(base);\n+        Dfp dfpPower = field.getOne();\n         for (int i = 0; i < maxExp; i++) {\n-            final double expected = FastMath.pow(base, (double) i);\n-            Assert.assertEquals(\"exp=\" + i,\n-                                expected,\n-                                FastMath.pow(base, i),\n-                                60 * Math.ulp(expected));\n-        }\n-    }\n+            Assert.assertEquals(\"exp=\" + i, dfpPower.toDouble(), FastMath.pow(base, i),\n+                                0.6 * FastMath.ulp(dfpPower.toDouble()));\n+            dfpPower = dfpPower.multiply(baseDfp);\n+        }\n+    }\n+\n }", "timestamp": 1344599686, "metainfo": ""}