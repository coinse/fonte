{"sha": "38c7118389807feea11a786541886eb76980e40c", "log": "fixed a number of warnings identified by findbugs eclipse plugin version 1.3.9  ", "commit": "\n--- a/src/java/org/apache/commons/math/genetics/RandomKey.java\n+++ b/src/java/org/apache/commons/math/genetics/RandomKey.java\n     @Override\n     protected boolean isSame(Chromosome another) {\n         // type check\n-        if (! (another instanceof RandomKey))\n+        if (! (another instanceof RandomKey<?>))\n             return false;\n         RandomKey<?> anotherRk = (RandomKey<?>) another;\n         // size check\n--- a/src/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n+++ b/src/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n      * {@link RandomKey} instance\n      */\n     public Chromosome mutate(Chromosome original) {\n-        if (!(original instanceof RandomKey)) {\n+        if (!(original instanceof RandomKey<?>)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"RandomKeyMutation works only with RandomKeys, got \" +\n                     original.getClass().getSimpleName());\n--- a/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n \n     /** {@inheritDoc} */\n     public FieldVector<T> append(FieldVector<T> v) {\n-        if (v instanceof SparseFieldVector) {\n+        if (v instanceof SparseFieldVector<?>) {\n             return append((SparseFieldVector<T>) v);\n         } else {\n             return append(v.toArray());\n     /** {@inheritDoc} */\n     public FieldMatrix<T> outerProduct(FieldVector<T> v)\n     throws IllegalArgumentException {\n-        if(v instanceof SparseFieldVector)\n+        if(v instanceof SparseFieldVector<?>)\n             return outerProduct((SparseFieldVector<T>)v);\n         else\n             return outerProduct(v.toArray());\n     /** {@inheritDoc} */\n     public FieldVector<T> subtract(FieldVector<T> v)\n            throws IllegalArgumentException {\n-        if(v instanceof SparseFieldVector)\n+        if(v instanceof SparseFieldVector<?>)\n             return subtract((SparseFieldVector<T>)v);\n         else\n             return subtract(v.toArray());\n \n     /** {@inheritDoc} */\n     public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n-        if (v instanceof SparseFieldVector) {\n+        if (v instanceof SparseFieldVector<?>) {\n             return add((SparseFieldVector<T>)v);\n         } else {\n             return add(v.toArray());\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n      * http://jcp.org/en/jsr/detail?id=83\n      * may require additional exception throws for other basic requirements.\n      */\n-    private class MultiDimensionalComplexMatrix\n-        implements Serializable, Cloneable {\n-\n-        /** Serializable version identifier. */\n-        private static final long serialVersionUID =  0x564FCD47EBA8169BL;\n+    private static class MultiDimensionalComplexMatrix\n+        implements Cloneable {\n \n         /** Size in all dimensions. */\n         protected int[] dimensionSize;\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      * expansionCriteria\n      * \n      * @param expansionFactor factor to be checked\n-     * @param contractionCritera criteria to be checked\n+     * @param contractionCriteria criteria to be checked\n      * @throws IllegalArgumentException if the contractionCriteria is less than\n      *         the expansionCriteria.\n      */\n     protected void checkContractExpand(\n-        float contractionCritera,\n+        float contractionCriteria,\n         float expansionFactor) {\n \n-        if (contractionCritera < expansionFactor) {\n+        if (contractionCriteria < expansionFactor) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would \" +\n                     \"lead to a never ending loop of expansion and contraction as a newly expanded \" +\n                     \"internal storage array would immediately satisfy the criteria for contraction\",\n-                    contractionCritera, expansionFactor);\n+                    contractionCriteria, expansionFactor);\n         }\n \n         if (contractionCriteria <= 1.0) {\n         if (expansionFactor <= 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"expansion factor smaller than one ({0})\",\n-                    contractionCriteria);\n+                    expansionFactor);\n         }\n     }\n     \n      */\n     public void setContractionCriteria(float contractionCriteria) {\n         checkContractExpand(contractionCriteria, getExpansionFactor());\n-        this.contractionCriteria = contractionCriteria;\n+        synchronized(this) {\n+        \tthis.contractionCriteria = contractionCriteria;\n+        }\n     }\n     \n \n     public void setExpansionFactor(float expansionFactor) {\n         checkContractExpand(getContractionCriteria(), expansionFactor);\n         // The check above verifies that the expansion factor is > 1.0;\n-        this.expansionFactor = expansionFactor;\n+        synchronized(this) {\n+        \tthis.expansionFactor = expansionFactor;\n+        }\n     }\n \n     /**\n                     expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n                     ADDITIVE_MODE, \"ADDITIVE_MODE\");\n         }\n-        this.expansionMode = expansionMode;\n+        synchronized(this) {\n+        \tthis.expansionMode = expansionMode;\n+        }\n     }\n     \n     /**\n      * @since 2.0\n      */\n     @Override\n-    public int hashCode() {\n+    public synchronized int hashCode() {\n         int[] hashData = new int[7];\n         hashData[0] = new Float(expansionFactor).hashCode();\n         hashData[1] = new Float(contractionCriteria).hashCode();\n         hashData[2] = expansionMode;\n-        synchronized(this) {\n             hashData[3] = Arrays.hashCode(internalArray);\n             hashData[4] = initialCapacity;\n             hashData[5] = numElements;\n             hashData[6] = startIndex;\n-        }\n         return Arrays.hashCode(hashData);\n     }\n          \n--- a/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n           addMeasurement(new LocalMeasurement(x, y, w));\n       }\n \n-      public double getA() {\n-          return a.getEstimate();\n-      }\n-\n-      public double getB() {\n-          return b.getEstimate();\n-      }\n-\n-      public double getC() {\n-          return c.getEstimate();\n-      }\n-\n       public double theoreticalValue(double x) {\n           return ( (a.getEstimate() * x + b.getEstimate() ) * x + c.getEstimate());\n       }\n--- a/src/test/org/apache/commons/math/genetics/RandomKeyTest.java\n+++ b/src/test/org/apache/commons/math/genetics/RandomKeyTest.java\n \n     @Test(expected=IllegalArgumentException.class)\n     public void testConstructor1() {\n-        @SuppressWarnings(\"unused\")\n-        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});\n+        new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void testConstructor2() {\n-        @SuppressWarnings(\"unused\")\n-        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});\n+        new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});\n     }\n \n     @Test\n--- a/src/test/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n-        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n-        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n-        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n-        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n-        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n-        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n     private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                                   int startRow, int endRow, int startColumn, int endColumn,\n-                                   boolean mustFail) {\n+                                   int startRow, int endRow, int startColumn, int endColumn) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n-            if (mustFail) {\n+            if (reference != null) {\n+                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+            } else {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n     }\n     \n     private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                                   int[] selectedRows, int[] selectedColumns,\n-                                   boolean mustFail) {\n+                                   int[] selectedRows, int[] selectedColumns) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n \n     public void testCopySubMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n-        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n-        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n         \n-        checkCopy(m, null,  1, 0, 2, 4, true);\n-        checkCopy(m, null, -1, 1, 2, 2, true);\n-        checkCopy(m, null,  1, 0, 2, 2, true);\n-        checkCopy(m, null,  1, 0, 2, 4, true);\n-        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n-        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, -1, 1, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n     private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                           int startRow, int endRow, int startColumn, int endColumn,\n-                           boolean mustFail) {\n+                           int startRow, int endRow, int startColumn, int endColumn) {\n         try {\n             Fraction[][] sub = (reference == null) ?\n                              new Fraction[1][1] :\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n     }\n     \n     private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                           int[] selectedRows, int[] selectedColumns,\n-                           boolean mustFail) {\n+                           int[] selectedRows, int[] selectedColumns) {\n         try {\n             Fraction[][] sub = (reference == null) ?\n                     new Fraction[1][1] :\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n--- a/src/test/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/BlockRealMatrixTest.java\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n-        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n-        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n-        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n-        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n-        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n-        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n     private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n-                                   int startRow, int endRow, int startColumn, int endColumn,\n-                                   boolean mustFail) {\n+                                   int startRow, int endRow, int startColumn, int endColumn) {\n         try {\n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new BlockRealMatrix(reference), sub);\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \t assertEquals(new BlockRealMatrix(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n     }\n     \n     private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n-                                   int[] selectedRows, int[] selectedColumns,\n-                                   boolean mustFail) {\n+                                   int[] selectedRows, int[] selectedColumns) {\n         try {\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new BlockRealMatrix(reference), sub);\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new BlockRealMatrix(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n \n     public void testCopySubMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n-        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n-        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n         \n-        checkCopy(m, null,  1, 0, 2, 4, true);\n-        checkCopy(m, null, -1, 1, 2, 2, true);\n-        checkCopy(m, null,  1, 0, 2, 2, true);\n-        checkCopy(m, null,  1, 0, 2, 4, true);\n-        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n-        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, -1, 1, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n     private void checkCopy(RealMatrix m, double[][] reference,\n-                           int startRow, int endRow, int startColumn, int endColumn,\n-                           boolean mustFail) {\n+                           int startRow, int endRow, int startColumn, int endColumn) {\n         try {\n             double[][] sub = (reference == null) ?\n                              new double[1][1] :\n                              new double[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n     }\n     \n     private void checkCopy(RealMatrix m, double[][] reference,\n-                           int[] selectedRows, int[] selectedColumns,\n-                           boolean mustFail) {\n+                           int[] selectedRows, int[] selectedColumns) {\n         try {\n             double[][] sub = (reference == null) ?\n                     new double[1][1] :\n                     new double[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n         boolean found = false;\n         int i = 0;\n         while (!found && i < searchMatrix.getColumnDimension()) {\n-            double multiplier = 1d;\n+            double multiplier = 1.0;\n             boolean matching = true;\n             int j = 0;\n             while (matching && j < searchMatrix.getRowDimension()) {\n                 double colEntry = searchMatrix.getEntry(j, i);\n                 // Use the first entry where both are non-zero as scalar\n-                if (multiplier == 1d && Math.abs(colEntry) > 1E-14\n+                if (Math.abs(multiplier - 1.0) <= Math.ulp(1.0) && Math.abs(colEntry) > 1E-14\n                         && Math.abs(column[j]) > 1e-14) {\n                     multiplier = colEntry / column[j];\n                 } \n--- a/src/test/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/FieldMatrixImplTest.java\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n-        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n-        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n-        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n-        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n-        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n-        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n-        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n     private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                                   int startRow, int endRow, int startColumn, int endColumn,\n-                                   boolean mustFail) {\n+                                   int startRow, int endRow, int startColumn, int endColumn) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n     }\n     \n     private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                                   int[] selectedRows, int[] selectedColumns,\n-                                   boolean mustFail) {\n+                                   int[] selectedRows, int[] selectedColumns) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n \n     public void testCopySubMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n-        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n-        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        \n-        checkCopy(m, null,  1, 0, 2, 4, true);\n-        checkCopy(m, null, -1, 1, 2, 2, true);\n-        checkCopy(m, null,  1, 0, 2, 2, true);\n-        checkCopy(m, null,  1, 0, 2, 4, true);\n-        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n-        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, -1, 1, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 2);\n+        checkCopy(m, null,  1, 0, 2, 4);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n     private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                           int startRow, int endRow, int startColumn, int endColumn,\n-                           boolean mustFail) {\n+                           int startRow, int endRow, int startColumn, int endColumn) {\n         try {\n             Fraction[][] sub = (reference == null) ?\n                              new Fraction[1][1] :\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n     }\n     \n     private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n-                           int[] selectedRows, int[] selectedColumns,\n-                           boolean mustFail) {\n+                           int[] selectedRows, int[] selectedColumns) {\n         try {\n             Fraction[][] sub = (reference == null) ?\n                     new Fraction[1][1] :\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n-            if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n+            if (reference != null) {\n+            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+            } else {\n+            \tfail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n-            if (!mustFail) {\n+            if (reference != null) {\n                 throw e;\n             }\n         }\n--- a/src/test/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n     public void testCopyFunctions() {\n         SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);\n         FieldMatrix<Fraction> m2 = m1.copy();\n-        assertTrue(m2 instanceof SparseFieldMatrix);\n+        assertEquals(m1.getClass(), m2.getClass());\n         assertEquals((m2), m1);\n         SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);\n         FieldMatrix<Fraction> m4 = m3.copy();\n-        assertTrue(m4 instanceof SparseFieldMatrix);\n+        assertEquals(m3.getClass(), m4.getClass());\n         assertEquals((m4), m3);\n     }\n \n--- a/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n     public void testCopyFunctions() {\n         OpenMapRealMatrix m1 = createSparseMatrix(testData);\n         RealMatrix m2 = m1.copy();\n-        assertTrue(m2 instanceof OpenMapRealMatrix);\n+        assertEquals(m1.getClass(), m2.getClass());\n         assertEquals((m2), m1);\n         OpenMapRealMatrix m3 = createSparseMatrix(testData);\n         RealMatrix m4 = m3.copy();\n-        assertTrue(m4 instanceof OpenMapRealMatrix);\n+        assertEquals(m3.getClass(), m4.getClass());\n         assertEquals((m4), m3);\n     }\n \n--- a/src/test/org/apache/commons/math/ode/TestProblem1.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblem1.java\n     y = problem.y.clone();\n   }\n \n-  /**\n-   * Clone operation.\n-   * @return a copy of the instance\n-   */\n-  @Override\n-  public Object clone() {\n+  /** {@inheritDoc} */\n+  public TestProblem1 copy() {\n     return new TestProblem1(this);\n   }\n \n--- a/src/test/org/apache/commons/math/ode/TestProblem2.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblem2.java\n     y = problem.y.clone();\n   }\n \n-  /**\n-   * Clone operation.\n-   * @return a copy of the instance\n-   */\n-  @Override\n-  public Object clone() {\n+  /** {@inheritDoc} */\n+  public TestProblem2 copy() {\n     return new TestProblem2(this);\n   }\n \n--- a/src/test/org/apache/commons/math/ode/TestProblem3.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblem3.java\n     y = problem.y.clone();\n   }\n \n-  /**\n-   * Clone operation.\n-   * @return a copy of the instance\n-   */\n-  @Override\n-  public Object clone() {\n+  /** {@inheritDoc} */\n+  public TestProblem3 copy() {\n     return new TestProblem3(this);\n   }\n \n--- a/src/test/org/apache/commons/math/ode/TestProblem4.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblem4.java\n     y = problem.y.clone();\n   }\n \n-  /**\n-   * Clone operation.\n-   * @return a copy of the instance\n-   */\n-  @Override\n-  public Object clone() {\n+  /** {@inheritDoc} */\n+  public TestProblem4 copy() {\n     return new TestProblem4(this);\n   }\n \n--- a/src/test/org/apache/commons/math/ode/TestProblem5.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblem5.java\n     super();\n     setFinalConditions(2 * t0 - t1);\n   }\n- \n+\n+  /** {@inheritDoc} */\n+  public TestProblem5 copy() {\n+    return new TestProblem5();\n+  }\n }\n--- a/src/test/org/apache/commons/math/ode/TestProblem6.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblem6.java\n         y = problem.y.clone();\n     }\n \n-    /**\n-     * Clone operation.\n-     * @return a copy of the instance\n-     */\n-    @Override\n-    public Object clone() {\n-        return new TestProblem6(this);\n+    /** {@inheritDoc} */\n+    public TestProblem6 copy() {\n+      return new TestProblem6(this);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/math/ode/TestProblemAbstract.java\n+++ b/src/test/org/apache/commons/math/ode/TestProblemAbstract.java\n  * integrated during the junit tests for the ODE integrators.\n  */\n public abstract class TestProblemAbstract\n-  implements FirstOrderDifferentialEquations, Cloneable {\n+  implements FirstOrderDifferentialEquations {\n \n   /** Serializable version identifier. */\n   private static final long serialVersionUID = -8521928974502839379L;\n   }\n \n   /**\n-   * Clone operation.\n+   * Copy operation.\n    * @return a copy of the instance\n    */\n-  @Override\n-  public abstract Object clone();\n+  public abstract TestProblemAbstract copy();\n \n   /**\n    * Set the initial conditions\n--- a/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n       double previousError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n-        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n   public void testNoDenseOutput()\n     throws DerivativeException, IntegratorException {\n     TestProblem1 pb1 = new TestProblem1();\n-    TestProblem1 pb2 = (TestProblem1) pb1.clone();\n+    TestProblem1 pb2 = pb1.copy();\n     double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n     double maxStep = pb1.getFinalTime() - pb1.getInitialTime();\n     double scalAbsoluteTolerance = 1.0e-4;\n--- a/src/test/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n       double previousError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n-        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        TestProblemAbstract pb  = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n           * Math.pow(2.0, -i);\n \n--- a/src/test/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n       double previousError = Double.NaN;\n       for (int i = 5; i < 10; ++i) {\n \n-        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n           * Math.pow(2.0, -i);\n \n--- a/src/test/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n       double previousError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n-        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n           * Math.pow(2.0, -i);\n         FirstOrderIntegrator integ = new MidpointIntegrator(step);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n       double previousError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n-        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n           * Math.pow(2.0, -i);\n \n--- a/src/test/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n   }\n \n   private static class BadStepInterpolator extends DummyStepInterpolator {\n-      public BadStepInterpolator() {\n-          super();\n-      }\n-      public BadStepInterpolator(double[] y, boolean forward) {\n-          super(y, forward);\n-      }\n-      @Override\n-      protected void doFinalize()\n-      throws DerivativeException {\n+\t  @SuppressWarnings(\"unused\")\n+\t  public BadStepInterpolator() {\n+\t  }\n+\t  public BadStepInterpolator(double[] y, boolean forward) {\n+\t\t  super(y, forward);\n+\t  }\n+\t  @Override\n+\t  protected void doFinalize()\n+\t  throws DerivativeException {\n           throw new DerivativeException(null);\n       }\n   }\n--- a/src/test/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n \n   }\n \n-  private class Rosenbrock implements MultivariateRealFunction {\n+  private static class Rosenbrock implements MultivariateRealFunction {\n \n       private int count;\n \n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n       }\n   }\n \n-  private class Rosenbrock implements MultivariateRealFunction {\n+  private static class Rosenbrock implements MultivariateRealFunction {\n \n       private int count;\n \n \n   }\n \n-  private class Powell implements MultivariateRealFunction {\n+  private static class Powell implements MultivariateRealFunction {\n \n       private int count;\n \n--- a/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n         Arrays.fill(target, 0.0);\n         double[] weights = new double[circle.getN()];\n         Arrays.fill(weights, 2.0);\n-        optimum =\n-            optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n+        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n         cov = optimizer.getCovariances();\n         assertEquals(0.0016, cov[0][0], 0.001);\n         assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n--- a/src/test/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n             points.add(new Point2D.Double(px, py));\n         }\n \n-        public int getN() {\n-            return points.size();\n-        }\n-\n         public double getRadius(Point2D.Double center) {\n             double r = 0;\n             for (Point2D.Double point : points) {\n--- a/src/test/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n+++ b/src/test/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n         ranking = new NaturalRanking(NaNStrategy.MINIMAL);\n         ranks = ranking.rank(data);\n         correctRanks = new double[] { 3, 4, 1.5, 1.5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n }\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n      */\n     private long binomialCoefficient(int n, int k) throws ArithmeticException {\n         if (binomialCache.size() > n) {\n-            Long cachedResult = binomialCache.get(n).get(new Integer(k));\n+            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));\n             if (cachedResult != null) {\n                 return cachedResult.longValue();\n             }\n         for (int i = binomialCache.size(); i < n + 1; i++) {\n             binomialCache.add(new HashMap<Integer, Long>());\n         }\n-        binomialCache.get(n).put(new Integer(k), new Long(result));\n+        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));\n         return result;\n     }\n ", "timestamp": 1246464208, "metainfo": ""}