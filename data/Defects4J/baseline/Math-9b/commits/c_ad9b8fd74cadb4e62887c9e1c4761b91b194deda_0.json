{"sha": "ad9b8fd74cadb4e62887c9e1c4761b91b194deda", "log": "Added evaluate method taking mean as a parameter.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n  * one of the threads invokes the <code>increment()</code> or \n  * <code>clear()</code> method, it must be synchronized externally.\n  * \n- * @version $Revision: 1.23 $ $Date: 2004/07/04 09:02:36 $\n+ * @version $Revision: 1.24 $ $Date: 2004/07/04 22:09:07 $\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n             moment.clear();\n         }\n     }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values) {\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"input values array is null\");\n+        }\n+        return evaluate(values, 0, values.length);\n+    }\n \n     /**\n      * Returns the variance of the entries in the specified portion of\n      * See {@link Variance} for details on the computing algorithm.\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * \n      */\n     public double evaluate(final double[] values, final int begin, final int length) {\n \n-        Mean mean = new Mean();\n+        double var = Double.NaN;\n+\n+        if (test(values, begin, length)) {\n+            clear();\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                Mean mean = new Mean();\n+                double m = mean.evaluate(values, begin, length);\n+                var = evaluate(values, m, begin, length);\n+            }\n+        }\n+        return var;\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, using the precomputed mean value.  Returns \n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double mean, \n+            final int begin, final int length) {\n+        \n         double var = Double.NaN;\n \n         if (test(values, begin, length)) {\n             if (length == 1) {\n                 var = 0.0;\n             } else if (length > 1) {\n-                double m = mean.evaluate(values, begin, length);\n                 double accum = 0.0;\n                 double accum2 = 0.0;\n                 for (int i = begin; i < begin + length; i++) {\n-                    accum += Math.pow((values[i] - m), 2.0);\n-                    accum2 += (values[i] - m);\n+                    accum += Math.pow((values[i] - mean), 2.0);\n+                    accum2 += (values[i] - mean);\n                 }\n                 var = (accum - (Math.pow(accum2, 2) / ((double) length))) /\n-                    (double) (length - 1);\n+                (double) (length - 1);\n             }\n         }\n         return var;", "timestamp": 1088978947, "metainfo": ""}